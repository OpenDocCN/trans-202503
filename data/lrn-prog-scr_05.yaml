- en: Chapter 6. Making Decisions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 6 章：做出决策
- en: 'This chapter will teach you the Scratch tools you need to write programs that
    can compare values, evaluate logical expressions, and make decisions based on
    the results. We’ll also go through several useful example applications. Here’s
    what you’ll learn along the way:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你使用 Scratch 工具编写程序，这些程序能够比较值、评估逻辑表达式，并根据结果做出决策。我们还将通过几个有用的示例应用来帮助理解。以下是你将在过程中学习的内容：
- en: Basic problem-solving techniques
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本问题解决技巧
- en: How to use the **if** and **if/else** blocks to choose among alternative actions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 **if** 和 **if/else** 块在多个备选操作中做出选择
- en: How to construct logical expressions to evaluate given conditions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建逻辑表达式以评估给定条件
- en: The flow of control in branching statements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支语句中的控制流
- en: The programs we have written so far follow a simple execution model. They start
    with the first instruction, execute it, move on to the next instruction, and so
    on until they reach the end of the program. The command blocks of these programs
    are executed in sequence, without any skipping or jumping.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的程序遵循简单的执行模型。它们从第一条指令开始，执行该指令，接着执行下一条指令，一直到程序结束。这些程序的命令块按顺序执行，不会跳过或跳转。
- en: In many programming situations, however, you may want to alter this sequential
    flow of program execution. If you were writing an application to tutor children
    in basic arithmetic, you’d want to execute certain blocks to reward correct answers
    and a completely different set of blocks for wrong answers (to reveal the right
    answer or offer another chance, for example). Your script can decide what to do
    next by comparing the student’s input with the correct answer. This is the basis
    of all decision-making tasks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多编程场景中，你可能希望改变这种顺序执行的程序流程。如果你正在编写一个应用程序来辅导孩子们学习基础算术，你可能希望执行某些代码块来奖励正确答案，并为错误答案执行完全不同的一组代码块（例如，揭示正确答案或提供另一机会）。你的脚本可以通过将学生的输入与正确答案进行比较来决定接下来该做什么。这就是所有决策任务的基础。
- en: In this chapter, we’ll explore the decision-making commands available in Scratch
    and write several programs that use these commands to test inputs and perform
    different actions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Scratch 中的决策命令，并编写几个使用这些命令来测试输入并执行不同操作的程序。
- en: First, I’ll introduce you to Scratch’s comparison operators and show how you
    can use them to compare numbers, letters, and strings. Then, I’ll introduce the
    **if** and **if/else** blocks and explain their key role in decision making. You’ll
    also learn how to test multiple conditions using nested **if** and **if/else**
    blocks and write a menu-driven program to put these blocks into action. After
    that, I’ll introduce logical operators as an alternative way to test multiple
    conditions. In the last section, we’ll write several interesting programs based
    on all of the concepts you’ve learned so far.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将向你介绍 Scratch 的比较运算符，并展示如何用它们来比较数字、字母和字符串。接着，我会介绍 **if** 和 **if/else** 块，并解释它们在决策中的关键作用。你还将学习如何使用嵌套的
    **if** 和 **if/else** 块测试多个条件，并编写一个基于菜单的程序来实现这些块的功能。之后，我将介绍逻辑运算符，作为测试多个条件的另一种方式。在最后一部分，我们将编写几个有趣的程序，基于你到目前为止所学的所有概念。
- en: Comparison Operators
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: You make decisions every day, and each decision normally leads you to perform
    certain actions. You may think, for example, “If that car is less than $2,000,
    I’ll buy it.” You then ask about the car’s price and decide whether or not you
    want to buy it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你每天都会做出决策，每个决策通常都会引导你执行某些操作。例如，你可能会想，“如果那辆车的价格低于 2000 美元，我就买它。”然后你会询问这辆车的价格，决定是否购买它。
- en: You can make decisions in Scratch, too. Using *comparison operators*, you can
    compare the values of two variables or expressions to determine whether one is
    greater than, less than, or equal to the other. Comparison operators are also
    called *relational operators* because they test the relationship between two values.
    The three relational operators supported in Scratch are shown in [Table 6-1](ch06.html#relational_operators_in_scratch
    "Table 6-1. Relational Operators in Scratch").
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 Scratch 中做出决策。通过使用*比较运算符*，你可以比较两个变量或表达式的值，判断一个是否大于、少于或等于另一个。比较运算符也叫做*关系运算符*，因为它们测试两个值之间的关系。Scratch
    支持的三个关系运算符见于[表 6-1](ch06.html#relational_operators_in_scratch "表 6-1. Scratch
    中的关系运算符")。
- en: Table 6-1. Relational Operators in Scratch
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1. Scratch 中的关系运算符
- en: '| Operator | Meaning | Example |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 含义 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134663.png.jpg)
    | greater than | ![image with no caption](httpatomoreillycomsourcenostarchimages2134665.png.jpg)Is
    `price` greater than 2,000? |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134663.png.jpg)
    | 大于 | ![image with no caption](httpatomoreillycomsourcenostarchimages2134665.png.jpg)`price`是否大于2000？
    |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134667.png.jpg)
    | less than | ![image with no caption](httpatomoreillycomsourcenostarchimages2134669.png.jpg)Is
    `price` less than 2,000? |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134667.png.jpg)
    | 小于 | ![image with no caption](httpatomoreillycomsourcenostarchimages2134669.png.jpg)`price`是否小于2000？
    |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134671.png.jpg)
    | equal to | ![image with no caption](httpatomoreillycomsourcenostarchimages2134673.png.jpg)Is
    `price` equal to 2,000? |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134671.png.jpg)
    | 等于 | ![image with no caption](httpatomoreillycomsourcenostarchimages2134673.png.jpg)`price`是否等于2000？
    |'
- en: Booleans in the Real World
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的布尔值
- en: 'The word *Boolean* is used in honor of George Boole, a 19th-century British
    mathematician who invented a system of logic based on just two values: 1 and 0
    (or True and False). Boolean algebra eventually became the basis for modern-day
    computer science.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔*这个词源于19世纪英国数学家乔治·布尔，他发明了一种基于两个值：1和0（或真与假）的逻辑系统。布尔代数最终成为现代计算机科学的基础。'
- en: In real life, we use Boolean expressions all the time to make decisions. Computers
    also use them to determine which branch of a program to follow. A robotic arm
    may be programmed to inspect moving parts on an assembly line and move each part
    to Bin 1 if `goodQuality = true`, or Bin 2 if `goodQuality = false`. Home security
    systems are usually programmed to sound an alarm if the wrong code is entered
    (`correctCode = false`) or deactivate when we enter the correct code (`correctCode
    = true`). A remote server may grant or deny access when you swipe your credit
    card at a department store based on whether your card was valid (`true`) or invalid
    (`false`). One computer in your vehicle will automatically deploy the air airbags
    when it decides that a collision has occurred (`collision = true`). Your cell
    phone may display a warning icon when the battery is low (`batteryLow = true`)
    and remove the icon when the battery’s charge is acceptable (`batteryLow = false`).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，我们经常使用布尔表达式来做出决策。计算机也用它们来确定程序执行的分支。机器人臂可能被编程用于检查流水线上的移动零件，并在`goodQuality
    = true`时将每个零件移动到Bin 1，或者在`goodQuality = false`时将其移动到Bin 2。家庭安全系统通常会被编程为在输入错误密码时发出警报（`correctCode
    = false`），或者在输入正确密码时停用警报（`correctCode = true`）。当你在百货商店刷卡时，远程服务器可能根据你的卡是否有效（`true`）或无效（`false`）来决定是否授予或拒绝访问。你车上的一台计算机会在发生碰撞时自动弹出安全气囊（`collision
    = true`）。当手机电池电量低时，可能会显示警告图标（`batteryLow = true`），当电池电量正常时，移除该图标（`batteryLow =
    false`）。
- en: These are just few examples of how computers cause different actions to be taken
    by checking the results of Boolean conditions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是计算机通过检查布尔条件结果来触发不同动作的几个例子。
- en: Note that the blocks in [Table 6-1](ch06.html#relational_operators_in_scratch
    "Table 6-1. Relational Operators in Scratch") all have a hexagonal shape. As you
    might recall from [Chapter 5](ch05.html "Chapter 5. Variables"), that means the
    result of evaluating one of these blocks is a *Boolean* value, which can be either
    true or false. For this reason, these expressions are also called *Boolean expressions*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[表6-1](ch06.html#relational_operators_in_scratch "表6-1. Scratch中的关系运算符")中的所有块都是六边形形状。正如你可能还记得的[第5章](ch05.html
    "第5章. 变量")，这意味着评估这些块的结果是一个*布尔*值，可以是“真”或“假”。因此，这些表达式也被称为*布尔表达式*。
- en: For example, the expression **price < 2000** tests whether the value of the
    variable `price` is less than 2,000\. If `price` is less than 2,000, the block
    returns (or evaluates to) true; otherwise, it returns false. You can use this
    expression to construct your decision condition in the form, “If (**price < 2000**),
    then buy the car.”
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表达式**price < 2000**测试变量`price`的值是否小于2000。如果`price`小于2000，块将返回（或计算为）真；否则，返回假。你可以使用这个表达式构建决策条件：“如果(**price
    < 2000**)，则购买汽车。”
- en: Before we look at the **if** block, which allows you to implement such a test,
    let’s go over a simple example that illustrates how Boolean expressions are evaluated
    in Scratch.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看**if**块之前，先来看一个简单的例子，说明布尔表达式是如何在Scratch中被评估的。
- en: Evaluating Boolean Expressions
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估布尔表达式
- en: 'Let’s say that we set two variables, `x` and `y`, as follows: `x = 5`, and
    `y = 10`. [Table 6-2](ch06.html#sample_relational_block_uses "Table 6-2. Sample
    Relational Block Uses") shows some examples that use Scratch’s relational blocks.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们设置了两个变量，`x` 和 `y`，如下所示：`x = 5`，`y = 10`。[表 6-2](ch06.html#sample_relational_block_uses
    "表 6-2. 关系运算块的示例") 展示了一些使用 Scratch 关系块的例子。
- en: These examples reveal several important points about relational operators. First,
    we can use them to compare both individual variables (such as `x`, `y`) and complete
    expressions (such as `2 * x` and `x + 6`). Second, the result of a comparison
    is always true or false (that is, a Boolean value). Third, the **x = y** block
    doesn’t mean “Set `x` equal to `y`.” Instead, it asks, “Is `x` equal to `y`?”
    So when the statement **set z to (x = y)** is executed, the value of `x` is still
    5.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子揭示了关于关系运算符的几个重要点。首先，我们可以使用它们来比较单个变量（如 `x`、`y`）和完整的表达式（如 `2 * x` 和 `x + 6`）。其次，比较的结果总是
    true 或 false（即布尔值）。第三，**x = y** 块并不意味着“将 `x` 设置为 `y`”。它是在问：“`x` 是否等于 `y`？”因此，当执行语句
    **set z to (x = y)** 时，`x` 的值仍然是 5。
- en: Table 6-2. Sample Relational Block Uses
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-2. 关系运算块示例
- en: '| Statement | Meaning | z (output) | Explanation |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 语句 | 含义 | z（输出） | 解释 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134675.png.jpg)
    | `z = is(5 < 10)?` | `z = true` | because 5 is less than 10 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134675.png.jpg) | `z =
    is(5 < 10)?` | `z = true` | 因为 5 小于 10 |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134677.png.jpg)
    | `z = is(5 > 10)?` | `z = false` | because 5 is not more than 10 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134677.png.jpg) | `z =
    is(5 > 10)?` | `z = false` | 因为 5 不大于 10 |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134679.png.jpg)
    | `z = is(5 = 10)?` | `z = false` | because 5 is not equal to 10 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134679.png.jpg) | `z =
    is(5 = 10)?` | `z = false` | 因为 5 不等于 10 |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134681.png.jpg)
    | `z = is(10 > 2*5)?` | `z = false` | because 10 is not more than 10 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134681.png.jpg) | `z =
    is(10 > 2*5)?` | `z = false` | 因为 10 不大于 10 |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134683.png.jpg)
    | `z = is(5 = 5)?` | `z = true` | because 5 is equal to 5 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134683.png.jpg) | `z =
    is(5 = 5)?` | `z = true` | 因为 5 等于 5 |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134685.png.jpg)
    | `z = is(10 < 5 + 6)?` | `z = true` | because 10 is less than 11 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134685.png.jpg) | `z =
    is(10 < 5 + 6)?` | `z = true` | 因为 10 小于 11 |'
- en: Comparing Letters and Strings
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较字母和字符串
- en: Let’s think about a game in which the player tries to guess a one-letter secret
    code between *A* and *Z*. The game reads the player’s guess, compares it with
    the secret code, and instructs the player to refine his guess based on the alphabetical
    order of letters. If the secret letter were *G*, for example, and the player entered
    a *B*, the game should say something like “After B” to tell the player that the
    secret code comes after the letter *B* in the alphabet. How can you compare the
    correct letter with the player’s input to decide what message to display?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们玩一个游戏，玩家需要猜一个从 *A* 到 *Z* 的单个字母的秘密代码。游戏会读取玩家的猜测，将其与秘密代码进行比较，并根据字母的字母顺序指导玩家调整猜测。如果秘密字母是
    *G*，而玩家输入了 *B*，游戏应该会告诉玩家类似“在 B 之后”的提示，表示秘密代码在字母 *B* 后面。我们如何比较正确的字母和玩家的输入，来决定显示什么消息呢？
- en: Fortunately, the relational operators in Scratch can also compare letters. As
    illustrated in [Figure 6-1](ch06.html#using_relational_operators_to_compare_le
    "Figure 6-1. Using relational operators to compare letters"), Scratch compares
    letters based on their alphabetical order. Since the letter *A* comes before the
    letter *B* in the alphabet, the expression **A < B** returns true. It is important
    to note, however, that these comparisons are not case sensitive; capital letter
    *A* is the same as small letter *a*. Thus, the expression **A = a** also returns
    true.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Scratch 中的关系运算符也可以用来比较字母。如[图 6-1](ch06.html#using_relational_operators_to_compare_le
    "图 6-1. 使用关系运算符比较字母")所示，Scratch 会根据字母的字母顺序来比较字母。因为字母 *A* 在字母表中排在字母 *B* 之前，所以表达式
    **A < B** 会返回 true。然而，需要注意的是，这些比较不区分大小写；大写字母 *A* 和小写字母 *a* 被视为相同。因此，表达式 **A =
    a** 也会返回 true。
- en: '![Using relational operators to compare letters](httpatomoreillycomsourcenostarchimages2134687.png.jpg)Figure 6-1. Using
    relational operators to compare letters'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用关系运算符比较字母](httpatomoreillycomsourcenostarchimages2134687.png.jpg)图 6-1.
    使用关系运算符比较字母'
- en: 'Knowing this information, you can test the player’s guess using the following
    set of conditionals:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 知道这些信息后，你可以使用以下条件语句来测试玩家的猜测：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A *conditional* is a statement of the form, “If the condition is true, then
    take this action.” In the next section, I’ll teach you how to implement conditionals
    in Scratch, but let’s explore relational operators a bit further with our code-guessing
    game first.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件语句*是一种形式为“如果条件为真，则执行此操作”的语句。在下一节中，我将教你如何在 Scratch 中实现条件语句，但我们先通过猜字游戏进一步探讨关系运算符。'
- en: 'What if the secret code contains more than one letter? For example, the player
    might need to guess the name of an animal. Can you still use Scratch’s relational
    operators to do the comparison? Luckily, the short answer is yes: You can use
    Scratch’s relational operators to compare strings. But how does Scratch process
    a comparison like **elephant > mouse**? The examples in [Figure 6-2](ch06.html#using_relational_operators_to_compare_1
    "Figure 6-2. Using relational operators to compare ① identical strings, ② strings
    that differ only in case, ③ one string to another that contains extra spaces,
    and ④ strings that vary according to the dictionary order of their letters") illustrate
    the result of comparing strings.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果密钥包含多个字母怎么办？例如，玩家可能需要猜测一种动物的名称。你仍然可以使用 Scratch 的关系运算符进行比较吗？幸运的是，简短的回答是肯定的：你可以使用
    Scratch 的关系运算符比较字符串。那么，Scratch 如何处理像**elephant > mouse**这样的比较呢？[图 6-2](ch06.html#using_relational_operators_to_compare_1
    "图 6-2. 使用关系运算符比较 ① 完全相同的字符串，② 仅在大小写上不同的字符串，③ 一个字符串与另一个包含多余空格的字符串，④ 根据字母的字典顺序变化的字符串")中的示例说明了比较字符串的结果。
- en: '![Using relational operators to compare ① identical strings, ② strings that
    differ only in case, ③ one string to another that contains extra spaces, and ④
    strings that vary according to the dictionary order of their letters](httpatomoreillycomsourcenostarchimages2134689.png.jpg)Figure 6-2. Using
    relational operators to compare ① identical strings, ② strings that differ only
    in case, ③ one string to another that contains extra spaces, and ④ strings that
    vary according to the dictionary order of their letters'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用关系运算符比较 ① 完全相同的字符串，② 仅在大小写上不同的字符串，③ 一个字符串与另一个包含多余空格的字符串，④ 根据字母的字典顺序变化的字符串](httpatomoreillycomsourcenostarchimages2134689.png.jpg)图
    6-2. 使用关系运算符比较 ① 完全相同的字符串，② 仅在大小写上不同的字符串，③ 一个字符串与另一个包含多余空格的字符串，④ 根据字母的字典顺序变化的字符串'
- en: 'A careful study of [Figure 6-2](ch06.html#using_relational_operators_to_compare_1
    "Figure 6-2. Using relational operators to compare ① identical strings, ② strings
    that differ only in case, ③ one string to another that contains extra spaces,
    and ④ strings that vary according to the dictionary order of their letters") shows
    the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 细致研究[图 6-2](ch06.html#using_relational_operators_to_compare_1 "图 6-2. 使用关系运算符比较
    ① 完全相同的字符串，② 仅在大小写上不同的字符串，③ 一个字符串与另一个包含多余空格的字符串，④ 根据字母的字典顺序变化的字符串")显示了以下内容：
- en: Scratch compares strings irrespective of their case. The strings “HELLO” and
    “hello” in ②, for example, are considered equal.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scratch 在比较字符串时不区分大小写。例如，在②中，字符串“HELLO”和“hello”被认为是相等的。
- en: Scratch counts white spaces in its comparison. The string “HELLO”, which starts
    and ends with a single space, is not the same as the string “HELLO” ③.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scratch 在比较中会计算空格。字符串“HELLO”前后各有一个空格，它与字符串“HELLO”③不同。
- en: When comparing the strings “ABC” and “ABD”, as in ④, Scratch first considers
    the first character in the two strings. Since they are the same (the letter *A*
    in this case), Scratch examines the second character in both strings. Since this
    character is also the same in the two strings, Scratch moves on to examining the
    third character. Since the letter *C* is less than the letter *D* (that is, *C*
    comes before *D* in the alphabet), Scratch considers the first string to be less
    than the second string.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在比较字符串“ABC”和“ABD”时，如④所示，Scratch 首先比较两字符串的第一个字符。由于它们相同（此例中为字母*A*），Scratch 会继续检查两字符串的第二个字符。由于这个字符在两个字符串中也是相同的，Scratch
    会继续检查第三个字符。由于字母*C*小于字母*D*（即*C*在字母表中排在*D*前面），因此 Scratch 认为第一个字符串小于第二个字符串。
- en: Knowing this, it shouldn’t surprise you when the expression **elephant > mouse**
    evaluates to false, even though actual elephants are much larger than mice. According
    to Scratch’s string comparison rules, the string “elephant” is less than the string
    “mouse” because the letter *e* (the first letter in elephant) comes before the
    letter *m* (the first letter in mouse) in the alphabet.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点后，你就不会感到惊讶，当表达式 **elephant > mouse** 计算结果为假时，即使真正的象比老鼠大得多。根据 Scratch 的字符串比较规则，字符串“elephant”小于字符串“mouse”，因为字母
    *e*（elephant 中的第一个字母）在字母 *m*（mouse 中的第一个字母）之前出现在字母表中。
- en: Comparing and sorting strings based on the alphabetical order of their characters
    is used in many real-life situations, including ordering directory listings, books
    on bookshelves, words in dictionaries, and so on. The word *elephant* comes before
    the word *mouse* in the dictionary, and string comparison in Scratch gives an
    answer based on this order.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 基于字符的字母顺序对字符串进行比较和排序，广泛应用于许多现实生活中的场景，包括排序目录列表、书架上的书籍、字典中的单词等等。在字典中，单词 *elephant*
    排在单词 *mouse* 之前，而 Scratch 中的字符串比较也根据这一顺序给出答案。
- en: Now that you understand what relational operators are and how Scratch uses these
    operators to compare numbers and strings, it’s time to learn about conditional
    blocks.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了什么是关系运算符以及 Scratch 如何使用这些运算符来比较数字和字符串，接下来是时候学习条件块了。
- en: Decision Structures
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决策结构
- en: 'Scratch’s *Control* palette contains two blocks that allow you to make decisions
    and control actions in your programs: the **if** block and the **if/else** block.
    Using these blocks, you can ask a question and take a course of action based on
    the answer. In this section, we’ll discuss these two blocks in detail, talk about
    flags, and learn to test multiple conditions with nested **if** blocks. I’ll then
    introduce menu-driven applications and explain how nested **if** blocks can aid
    in their implementation.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Scratch 的 *控制* 调色板包含两个块，它们允许你在程序中做出决策并控制操作：**if** 块和 **if/else** 块。通过使用这些块，你可以提出一个问题，并根据答案采取行动。在这一部分，我们将详细讨论这两个块，谈论标志，并学习如何使用嵌套的
    **if** 块来测试多个条件。接下来，我将介绍基于菜单的应用程序，并解释嵌套的 **if** 块如何帮助实现这些应用程序。
- en: The if Block
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if 块
- en: The **if** block is a decision structure that gives you the ability to specify
    whether a set of commands should (or should not) be executed based on the result
    of a test condition. The structure of the **if** block and its corresponding flowchart
    are shown in [Figure 6-3](ch06.html#structure_of_the_if_block "Figure 6-3. Structure
    of the if block").
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**if** 块是一个决策结构，它使你能够根据测试条件的结果来指定一组命令是否（或是否不）应执行。**if** 块的结构及其对应的流程图如 [图 6-3](ch06.html#structure_of_the_if_block
    "图 6-3. if 块的结构") 所示。'
- en: '![Structure of the if block](httpatomoreillycomsourcenostarchimages2134691.png.jpg)Figure 6-3. Structure
    of the *if* block'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![if 块的结构](httpatomoreillycomsourcenostarchimages2134691.png.jpg)图 6-3. *if*
    块的结构'
- en: In [Figure 6-3](ch06.html#structure_of_the_if_block "Figure 6-3. Structure of
    the if block"), the diamond shape represents a decision block that gives a yes/no
    (or true/false) answer to a question. If the test condition in the *header* of
    the **if** block is true, the program executes the commands listed inside the
    *body* before moving on to the command that follows the **if** block (***Command
    M*** in the figure). If the test condition is false, the program skips those commands
    and moves directly to ***Command M***.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 6-3](ch06.html#structure_of_the_if_block "图 6-3. if 块的结构") 中，菱形表示一个决策块，它对一个问题给出“是/否”（或“真/假”）的回答。如果
    **if** 块的 *头部* 中的测试条件为真，程序会执行 *正文* 中列出的命令，然后再执行 **if** 块后面的命令（图中的 ***Command M***）。如果测试条件为假，程序会跳过这些命令，直接跳到
    ***Command M***。
- en: To see the **if** block in action, create the script shown in [Figure 6-4](ch06.html#this_script_causes_the_sprite_to_change
    "Figure 6-4. This script causes the sprite to change its color only when it is
    moving in the right half of the Stage.") and run it. The script runs a **forever**
    loop that moves a sprite around the stage, changes its color, and makes it bounce
    off the edges of the Stage.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 **if** 块的实际应用，请创建并运行 [图 6-4](ch06.html#this_script_causes_the_sprite_to_change
    "图 6-4. 该脚本仅在精灵移动到舞台的右半部分时才会改变其颜色。") 中显示的脚本。该脚本运行一个 **forever** 循环，移动一个精灵在舞台上，改变其颜色，并使其反弹舞台的边缘。
- en: '![This script causes the sprite to change its color only when it is moving
    in the right half of the Stage.](httpatomoreillycomsourcenostarchimages2134693.png.jpg)Figure 6-4. This
    script causes the sprite to change its color only when it is moving in the right
    half of the Stage.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![此脚本仅在精灵移动到舞台的右半部分时才会改变颜色。](httpatomoreillycomsourcenostarchimages2134693.png.jpg)图6-4.
    此脚本仅在精灵移动到舞台的右半部分时才会改变颜色。'
- en: The **forever** loop in our script contains an **if** block that checks the
    sprite’s *x*-position after every **move** command. If the *x*-position is greater
    than zero, the sprite should change its color. When you run this script, you’ll
    notice that the sprite changes its color only when it is moving in the right half
    of the Stage. This is because the **change color effect by 25** block is executed
    only when the **x position > 0** condition is true.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本中的**forever**循环包含一个**if**块，在每次**move**命令后检查精灵的*x*位置。如果*x*位置大于零，精灵应改变其颜色。运行此脚本时，你会发现精灵只有在移动到舞台的右半部分时才会改变颜色。这是因为**change
    color effect by 25**块仅在**x position > 0**条件为真时才会执行。
- en: Using Variables as Flags
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用变量作为标志
- en: Let’s say that you are developing a space adventure game where the goal is to
    destroy a fleet of attacking warships. The player, who is the captain, maneuvers
    a starship with the arrow keys on the keyboard and fires missiles by pressing
    the spacebar. If the player’s starship gets hit by enemy fire a certain number
    of times, the ship loses its ability to attack. At this point, pressing the spacebar
    should not fire any more missiles, and the captain has to adopt a defense strategy
    to avoid taking any more hits. Clearly, when the spacebar is pressed, your program
    needs to check the state of the starship’s attack system to decide whether or
    not the player can fire.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发一款太空冒险游戏，目标是摧毁一支正在攻击的战舰舰队。玩家扮演舰长，使用键盘上的箭头键操作星际飞船，并通过按空格键发射导弹。如果玩家的星际飞船被敌方攻击命中一定次数，飞船将失去攻击能力。这时，按空格键将不再发射导弹，舰长必须采用防御策略来避免再受攻击。显然，当按下空格键时，程序需要检查星际飞船攻击系统的状态，以决定玩家是否能继续发射。
- en: Checks of this nature are normally performed using *flags*, which are variables
    you use to indicate whether or not an event of interest has happened. You could
    use any two values to describe the event’s status, but it’s common practice to
    use 0 (or false) to indicate that the event hasn’t occurred and 1 (or true) to
    indicate that it has.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的检查通常使用*标志*来执行，标志是用于表示是否发生了某个感兴趣事件的变量。你可以使用任何两个值来描述事件的状态，但常见做法是使用0（或false）表示事件未发生，使用1（或true）表示事件已发生。
- en: In your space shooter game, you can use a flag named `canFire` to indicate the
    state of the starship. A value of 1 means that the starship can fire missiles,
    and a value of 0 means that it can’t. Based on this, your spacebar event handler
    may be coded as shown in [Figure 6-5](ch06.html#using_a_flag_for_condition_execution
    "Figure 6-5. Using a flag for condition execution").
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的太空射击游戏中，可以使用一个名为`canFire`的标志来表示星际飞船的状态。值为1表示星际飞船可以发射导弹，值为0表示不能。基于此，空格键事件处理程序的代码可能如下所示，[如图6-5](ch06.html#using_a_flag_for_condition_execution
    "图6-5. 使用标志进行条件执行")所示。
- en: '![Using a flag for condition execution](httpatomoreillycomsourcenostarchimages2134695.png.jpg)Figure 6-5. Using
    a flag for condition execution'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用标志进行条件执行](httpatomoreillycomsourcenostarchimages2134695.png.jpg)图6-5. 使用标志进行条件执行'
- en: At the start of the game, you’d initialize the value of the `canFire` flag to
    1 to indicate that the starship is capable of firing missiles. When the starship
    gets hit by a certain amount of enemy fire, you’d set the `canFire` flag to 0
    to indicate that the attack system has become dysfunctional; at that point, pressing
    the spacebar won’t fire any more missiles.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开始时，你会将`canFire`标志的值初始化为1，以表示星际飞船可以发射导弹。当星际飞船被敌人攻击命中一定次数后，你会将`canFire`标志设置为0，表示攻击系统已经失效；此时，按下空格键将不再发射导弹。
- en: Although you can name your flags anything you want, I recommend using names
    that reflect their true/false nature. [Table 6-3](ch06.html#some_examples_of_using_flags
    "Table 6-3. Some Examples of Using Flags") shows some examples of flags you might
    use in the space shooter game.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以根据需要给标志命名，但我建议使用能反映其真/假性质的名称。[表6-3](ch06.html#some_examples_of_using_flags
    "表6-3. 使用标志的示例")展示了一些你可能在太空射击游戏中使用的标志示例。
- en: Table 6-3. Some Examples of Using Flags
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-3. 使用标志的示例
- en: '| Example | Meaning and Possible Course of Action |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 示例 | 意图和可能的行动方案 |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134697.png.jpg)
    | Game has not started yet. Ignore all keyboard inputs. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134697.png.jpg) | 游戏尚未开始。忽略所有键盘输入。
    |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134699.png.jpg)
    | Game has started. Start processing user input. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134699.png.jpg) | 游戏已开始。开始处理用户输入。
    |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134701.png.jpg)
    | Game is not over yet. Show remaining time. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134701.png.jpg) | 游戏尚未结束。显示剩余时间。
    |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134703.png.jpg)
    | Game is over. Hide the remaining time display. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134703.png.jpg) | 游戏结束。隐藏剩余时间显示。
    |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134705.png.jpg)
    | The starship is not hit by enemy’s fire. Alarm sound is off. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134705.png.jpg) | 星际飞船没有被敌方火力击中。警报关闭。
    |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134707.png.jpg)
    | The starship has been hit by a missile. Play the alarm sound. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134707.png.jpg) | 星际飞船被导弹击中。播放警报声。
    |'
- en: Now that you know how to use the **if** block and flags, let’s talk about another
    conditional block, one that will let you execute one block of code when a certain
    condition is true and another if that condition is false.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何使用**if**块和标志，接下来我们来讨论另一个条件块，它可以让你在某个条件为真时执行一段代码，而当条件为假时执行另一段代码。
- en: The if/else Block
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if/else 块
- en: 'Imagine that you are creating a game to teach basic math to elementary students.
    The game presents an addition problem and then asks the student to enter an answer.
    The student should receive one point for a correct answer and lose one point for
    an incorrect answer. You can perform this task using two **if** statements:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在创建一个游戏，用于教小学学生基础数学。游戏会呈现一个加法问题，然后要求学生输入答案。学生答对了会得一分，答错了则扣一分。你可以使用两个**if**语句来完成这个任务：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You could also simplify this logic—and make the code more efficient—by combining
    the two **if** statements into one **if/else** statement as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过将两个**if**语句合并为一个**if/else**语句来简化逻辑，从而提高代码效率，代码如下：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The specified condition is tested. If the condition is true, the commands in
    the **if** part of the block are executed. If the condition is false, however,
    the commands under **else** will execute instead. The program will only execute
    one of the two groups of commands in the **if/else** block. Those alternative
    paths through the program are also called *branches*. The structure of the **if/else**
    block and its corresponding flowchart are shown in [Figure 6-6](ch06.html#structure_of_the_ifsoliduselse_block
    "Figure 6-6. Structure of the if/else block").
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的条件会被测试。如果条件为真，**if**部分的命令将会执行；但如果条件为假，**else**部分的命令则会执行。程序只会执行**if/else**块中的其中一组命令。这些替代路径也被称为*分支*。**if/else**块的结构及其相应的流程图见[图6-6](ch06.html#structure_of_the_ifsoliduselse_block
    "图6-6。if/else 块的结构")。
- en: '![Structure of the if/else block](httpatomoreillycomsourcenostarchimages2134709.png.jpg)Figure 6-6. Structure
    of the *if/else* block'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![if/else 块的结构](httpatomoreillycomsourcenostarchimages2134709.png.jpg)图6-6。*if/else*
    块的结构'
- en: You might use the **if/else** structure when you want to decide where to eat
    lunch. If you have enough money, you’ll go to a fancy restaurant; otherwise, you’ll
    settle for more casual food. Let’s call the money in your wallet `availableCash`.
    When you open your wallet, you’re checking the condition **availableCash > $20**.
    If the result is true (you have more than $20), you’ll go to a place with white
    tablecloths, and if not, you’ll head to the nearest burger joint.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想决定午餐吃什么时，可能会使用**if/else**结构。如果你有足够的钱，你会去一家高级餐厅；否则，你会选择更随意的食物。我们可以将你钱包里的钱叫做`availableCash`。当你打开钱包时，你就在检查条件**availableCash
    > $20**。如果结果为真（你有超过20美元），你会去白桌布的餐厅；如果不为真，你就会去附近的汉堡店。
- en: One simple script that illustrates using the **if/else** block is shown in [Figure 6-7](ch06.html#this_script_finds_out_whether_the_number
    "Figure 6-7. This script finds out whether the number the user entered is even
    or odd."). This example uses the *modulus operator* (**mod**), which returns the
    remainder of a division operation, to determine whether a number entered by the
    user is even or odd. (Remember that an even number has a remainder of zero when
    divided by two.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [6-7](ch06.html#this_script_finds_out_whether_the_number "图 6-7. 这个脚本用于判断用户输入的数字是偶数还是奇数")
    中显示了一个简单的脚本，演示了如何使用 **if/else** 语句块。这个例子使用了 *取模运算符*（**mod**），它返回除法操作的余数，用于判断用户输入的数字是偶数还是奇数。（记住，偶数在除以二时余数为零。）
- en: '![This script finds out whether the number the user entered is even or odd.](httpatomoreillycomsourcenostarchimages2134711.png.jpg)Figure 6-7. This
    script finds out whether the number the user entered is even or odd.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![这个脚本用于判断用户输入的数字是偶数还是奇数。](httpatomoreillycomsourcenostarchimages2134711.png.jpg)图
    6-7. 这个脚本用于判断用户输入的数字是偶数还是奇数。'
- en: '[Figure 6-7](ch06.html#this_script_finds_out_whether_the_number "Figure 6-7. This
    script finds out whether the number the user entered is even or odd.") shows two
    sample outputs for when the user enters `6` and `9`, respectively, in response
    to the **ask** command. Can you explain how this script works?'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-7](ch06.html#this_script_finds_out_whether_the_number "图 6-7. 这个脚本用于判断用户输入的数字是偶数还是奇数")
    展示了用户分别输入 `6` 和 `9` 后的两种示例输出。你能解释一下这个脚本是如何工作的吗？'
- en: Nested if and if/else Blocks
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套的 if 和 if/else 语句块
- en: 'If you want to test more than one condition before taking an action, you can
    nest multiple **if** (or **if/else**) blocks inside each other to perform the
    required test. Consider for example the script shown in [Figure 6-8](ch06.html#you_can_use_nested_ifsoliduselse_blocks
    "Figure 6-8. You can use nested if/else blocks to test multiple conditions."),
    which determines whether a student should receive a scholarship. To qualify, the
    student must have: (1) a grade point average (GPA) higher than 3.8 and (2) a grade
    above 92 percent in math.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在执行操作前测试多个条件，可以将多个 **if**（或 **if/else**）语句块嵌套在一起，执行所需的测试。例如，考虑图 [6-8](ch06.html#you_can_use_nested_ifsoliduselse_blocks
    "图 6-8. 你可以使用嵌套的 if/else 语句块来测试多个条件") 中显示的脚本，该脚本用于确定一个学生是否应该获得奖学金。要符合条件，学生必须具备：(1)
    平均成绩（GPA）高于 3.8 和 (2) 数学成绩高于 92 分。
- en: '![You can use nested if/else blocks to test multiple conditions.](httpatomoreillycomsourcenostarchimages2134713.png.jpg)Figure 6-8. You
    can use nested *if/else* blocks to test multiple conditions.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![你可以使用嵌套的 if/else 语句块来测试多个条件。](httpatomoreillycomsourcenostarchimages2134713.png.jpg)图
    6-8. 你可以使用嵌套的 *if/else* 语句块来测试多个条件。'
- en: First, the expression **gpa > 3.8** is tested. If this expression is false,
    we don’t need to check the other condition because the student doesn’t meet the
    scholarship criteria. If the expression **gpa > 3.8** is true, however, we need
    to test the second condition. This is done with the nested **if/else** block,
    which tests the condition **mathScore > 92**. If this second condition is also
    true, the student gets the scholarship. Otherwise, the student does not qualify,
    and an appropriate message explaining the reason is displayed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，测试表达式 **gpa > 3.8**。如果这个表达式为假，那么我们不需要检查其他条件，因为学生不符合奖学金的标准。如果表达式 **gpa > 3.8**
    为真，则需要测试第二个条件。这通过嵌套的 **if/else** 语句块来完成，后者测试条件 **mathScore > 92**。如果第二个条件也为真，学生将获得奖学金。否则，学生不符合资格，并且会显示一个解释原因的相应消息。
- en: Menu-Driven Programs
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 菜单驱动程序
- en: '*AreaCalculator.sb2*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*AreaCalculator.sb2*'
- en: Next, we’ll explore a typical use of nested **if** blocks. In particular, you’ll
    learn how to write programs that present the user with choices and act on the
    user’s selection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨嵌套 **if** 语句块的典型用法。特别是，你将学习如何编写程序，向用户提供选择，并根据用户的选择采取行动。
- en: When you start up some programs, they display a list (or menu) of available
    options and wait for you to make a selection. Sometimes, you’ll interact with
    these programs by entering a number that corresponds to your desired option. Such
    programs may use a sequence of nested **if/else** blocks to determine the user’s
    selection and act appropriately. To see how nested **if/else** blocks work, we’ll
    discuss an application, shown in [Figure 6-9](ch06.html#user_interface_for_the_area_calculator_p
    "Figure 6-9. User interface for the area calculator program"), that calculates
    the area of different geometric shapes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动某些程序时，它们会显示一个可用选项的列表（或菜单），并等待你做出选择。有时，你需要通过输入与期望选项对应的数字来与这些程序交互。这些程序可能使用一系列嵌套的**if/else**语句块来确定用户的选择并采取相应的行动。为了了解嵌套的**if/else**语句块是如何工作的，我们将讨论一个应用程序，如[图6-9](ch06.html#user_interface_for_the_area_calculator_p
    "图6-9. 区域计算器程序的用户界面")所示，它计算不同几何形状的面积。
- en: '![User interface for the area calculator program](httpatomoreillycomsourcenostarchimages2134715.png.jpg)Figure 6-9. User
    interface for the area calculator program'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![区域计算器程序的用户界面](httpatomoreillycomsourcenostarchimages2134715.png.jpg)图6-9.
    区域计算器程序的用户界面'
- en: The user interface for this application contains the Stage’s background image,
    which shows the available options (the numbers 1, 2, or 3), and the `Tutor` sprite,
    which asks the user for a choice, performs the calculation, and displays the result.
    The main script, shown in [Figure 6-10](ch06.html#main_script_of_the_tutor_sprite
    "Figure 6-10. The main script of the Tutor sprite"), starts when the green flag
    icon is clicked.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的用户界面包含舞台的背景图像，显示可用选项（数字1、2或3），以及`Tutor`精灵，它会询问用户选择，执行计算并显示结果。主脚本，如[图6-10](ch06.html#main_script_of_the_tutor_sprite
    "图6-10. *Tutor* 精灵的主脚本")所示，在点击绿色旗帜图标时启动。
- en: '![The main script of the Tutor sprite](httpatomoreillycomsourcenostarchimages2134717.png.jpg)Figure 6-10. The
    main script of the *`Tutor`* sprite'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![导师精灵的主脚本](httpatomoreillycomsourcenostarchimages2134717.png.jpg)图6-10. *`Tutor`*
    精灵的主脚本'
- en: After asking the user to enter a choice, the `Tutor` sprite waits for the user’s
    input and uses three **if/else** blocks to process it. If the user entered a valid
    choice (that is, 1, 2, or 3), the script calls the appropriate procedure to calculate
    the area of the indicated shape. Otherwise, the script invokes the **say** command
    to inform the user that the choice entered is invalid. The procedures for calculating
    the areas of the three shapes are shown in [Figure 6-11](ch06.html#procedures_for_the_area_calculator_progr
    "Figure 6-11. Procedures for the area calculator program").
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在询问用户输入选择后，`Tutor`精灵等待用户的输入，并使用三个**if/else**语句块来处理它。如果用户输入了有效的选择（即1、2或3），脚本会调用相应的过程来计算所选形状的面积。否则，脚本会调用**say**命令告知用户所输入的选择无效。计算三种形状面积的过程如[图6-11](ch06.html#procedures_for_the_area_calculator_progr
    "图6-11. 区域计算器程序的过程")所示。
- en: '![Procedures for the area calculator program](httpatomoreillycomsourcenostarchimages2134719.png.jpg)Figure 6-11. Procedures
    for the area calculator program'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![区域计算器程序的过程](httpatomoreillycomsourcenostarchimages2134719.png.jpg)图6-11.
    区域计算器程序的过程'
- en: Each procedure asks the user to enter the dimensions for its corresponding shape,
    calculates the area, and displays the result. For example, the **Rectangle** procedure
    asks the user to enter the length and width of the rectangle and saves the answers
    in the `length` and `width` variables, respectively. It then computes the area
    by multiplying the length by the width and displays the answer. The other two
    procedures work similarly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个过程都会要求用户输入对应形状的尺寸，计算面积，并显示结果。例如，**矩形**过程会要求用户输入矩形的长度和宽度，并将答案分别保存在`length`和`width`变量中。然后通过将长度乘以宽度来计算面积，并显示答案。其他两个过程的工作原理类似。
- en: Logical Operators
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: In the previous section, you learned how to use nested **if** and **if/else**
    blocks to test multiple conditions, but you can also do that with *logical operators*.
    Using logical operators, you can combine two or more relational expressions to
    produce a single true/false result. For example, the logical expression `(x >
    5) and (x < 10)` is made up of two logical expressions (`x > 5` and `x < 10`)
    that are combined using the logical operator **and**. We can think of `x > 5`
    and `x < 10` as the two operands of the **and** operator; the result of this operator
    is true only if both operands are true. [Table 6-4](ch06.html#logical_operators-id00012
    "Table 6-4. Logical Operators") lists the three logical operators available in
    Scratch with a brief explanation of their meaning.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，你学会了如何使用嵌套的**if**和**if/else**块来测试多个条件，但你也可以通过*逻辑运算符*来实现这一点。使用逻辑运算符，你可以将两个或更多的关系表达式结合起来，得到一个单一的真/假结果。例如，逻辑表达式`(x
    > 5) and (x < 10)`由两个逻辑表达式（`x > 5`和`x < 10`）组成，它们通过逻辑运算符**and**结合。我们可以将`x > 5`和`x
    < 10`视为**and**运算符的两个操作数；只有当两个操作数都为真时，这个运算符的结果才为真。[表6-4](ch06.html#logical_operators-id00012
    "表6-4. 逻辑运算符")列出了Scratch中可用的三种逻辑运算符，并简要解释了它们的含义。
- en: Table 6-4. Logical Operators
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-4. 逻辑运算符
- en: '| Operator | Meaning |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 含义 |'
- en: '| --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134721.png.jpg)
    | The result is true only if the two expressions are true. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134721.png.jpg) | 仅当两个表达式都为真时，结果为真。
    |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134723.png.jpg)
    | The result is true if either of the two expressions is true. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134723.png.jpg) | 如果两个表达式中的任意一个为真，结果为真。
    |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134725.png.jpg)
    | The result is true if the expression is false. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134725.png.jpg) | 如果表达式为假，结果为真。
    |'
- en: Now that you’ve seen a brief overview of each operator, let’s explore how they
    work in more detail, one at a time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看过每个运算符的简要概述，我们将逐一详细探讨它们的工作原理。
- en: The and Operator
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: and运算符
- en: The **and** operator takes two expressions as parameters. If both expressions
    are true, the **and** operator returns true; otherwise, it returns false. The
    truth table for **and**, which lists the output of the operator for all possible
    combinations of inputs, is shown in [Table 6-5](ch06.html#truth_table_for_the_and_operator
    "Table 6-5. Truth Table for the and Operator").
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**and**运算符接受两个表达式作为参数。如果两个表达式都为真，**and**运算符返回真；否则返回假。**and**的真值表，列出了所有可能输入组合下该运算符的输出，如[表6-5](ch06.html#truth_table_for_the_and_operator
    "表6-5. and运算符的真值表")所示。'
- en: Table 6-5. Truth Table for the and Operator
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-5. and运算符的真值表
- en: '| X | Y | ![image with no caption](httpatomoreillycomsourcenostarchimages2134727.png.jpg)
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| X | Y | ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134727.png.jpg)
    |'
- en: '| --- | --- | --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| true | true | true |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| true | true | true |'
- en: '| true | false | false |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| true | false | false |'
- en: '| false | true | false |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| false | true | false |'
- en: '| false | false | false |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| false | false | false |'
- en: As an example of using the **and** operator, let’s say we’re creating a game
    in which the player gets 200 bonus points when the score reaches 100 in the first
    level. The game level is tracked by a variable named `level`, and the score is
    tracked using a variable named `score`. [Figure 6-12](ch06.html#checking_multiple_conditions_using_neste
    "Figure 6-12. Checking multiple conditions using nested if blocks and the and
    operator") shows how these conditions can be tested using nested **if** blocks
    ① or with the **and** operator ②.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用**and**运算符的示例，假设我们正在制作一个游戏，在第一关当玩家得分达到100时，会获得200分的奖励积分。游戏关卡由一个名为`level`的变量跟踪，得分由一个名为`score`的变量跟踪。[图6-12](ch06.html#checking_multiple_conditions_using_neste
    "图6-12. 使用嵌套的if块和and运算符检查多个条件")展示了如何通过嵌套的**if**块①或**and**运算符②来测试这些条件。
- en: '![Checking multiple conditions using nested if blocks and the and operator](httpatomoreillycomsourcenostarchimages2134729.png.jpg)Figure 6-12. Checking
    multiple conditions using nested *if* blocks and the *and* operator'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用嵌套if块和and运算符检查多个条件](httpatomoreillycomsourcenostarchimages2134729.png.jpg)图6-12.
    使用嵌套*if*块和*and*运算符检查多个条件'
- en: In both cases, the bonus points are added only when both conditions are true.
    As you can see, the **and** operator provides a more concise way for performing
    the same test. The command(s) inside the **if** block in [Figure 6-12](ch06.html#checking_multiple_conditions_using_neste
    "Figure 6-12. Checking multiple conditions using nested if blocks and the and
    operator") ② will be executed only if `level` equals 1 and `score` equals 100\.
    If either condition is false, the entire test evaluates to false, and the **change
    score by 200** block will not be executed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，只有当两个条件都为真时，才会添加奖励积分。如你所见，**and**运算符提供了一种更简洁的方式来执行相同的测试。[图 6-12](ch06.html#checking_multiple_conditions_using_neste
    "图 6-12. 使用嵌套的**if**语句块和**and**运算符检查多个条件")中的**if**语句块②只有在`level`等于1且`score`等于100时才会执行。如果其中一个条件为假，整个测试结果将为假，**将分数增加200**语句块将不会执行。
- en: The or Operator
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 或运算符
- en: The **or** operator also takes two expressions as parameters. If either expression
    is true, the **or** operator returns true. It returns false only when the two
    expressions are both false. The truth table for the **or** operator is given in
    [Table 6-6](ch06.html#truth_table_for_the_or_operator "Table 6-6. Truth Table
    for the or Operator").
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**or**运算符还接受两个表达式作为参数。如果任一表达式为真，**or**运算符返回真。只有当两个表达式都为假时，它才返回假。**or**运算符的真值表见[表
    6-6](ch06.html#truth_table_for_the_or_operator "表 6-6. or运算符的真值表")。'
- en: Table 6-6. Truth Table for the or Operator
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-6. or运算符的真值表
- en: '| X | Y | ![image with no caption](httpatomoreillycomsourcenostarchimages2134731.png.jpg)
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| X | Y | ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134731.png.jpg)
    |'
- en: '| --- | --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| true | true | true |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| true | true | true |'
- en: '| true | false | true |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| true | false | true |'
- en: '| false | true | true |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| false | true | true |'
- en: '| false | false | false |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| false | false | false |'
- en: To demonstrate the use of the **or** operator, let’s assume that players of
    a certain game have a limited time to reach the next level. They also start with
    a given amount of energy that depletes as they navigate the current level. The
    game ends if the player fails to reach the next level in the allowable time or
    if the player depletes all the allotted energy before reaching the next level.
    The remaining time is tracked by a variable named `timeLeft`, and the player’s
    current energy level is tracked by a variable named `energyLevel`. [Figure 6-13](ch06.html#checking_multiple_conditions_usi-id00013
    "Figure 6-13. Checking multiple conditions using nested if blocks and with the
    or operator") shows how the game end condition can be tested using nested **if/else**
    blocks ① and the **or** operator ②.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示**or**运算符的使用，假设某款游戏的玩家在有限的时间内需要到达下一关卡。玩家还从一定量的能量开始，这些能量在玩家通过当前关卡时会逐渐消耗。如果玩家未能在允许的时间内到达下一关卡，或者在到达下一关卡之前消耗了所有分配的能量，游戏就结束。剩余时间由名为`timeLeft`的变量追踪，玩家当前的能量水平由名为`energyLevel`的变量追踪。[图
    6-13](ch06.html#checking_multiple_conditions_usi-id00013 "图 6-13. 使用嵌套的**if/else**语句块和**or**运算符检查多个条件")显示了如何使用嵌套的**if/else**语句块①和**or**运算符②来测试游戏结束的条件。
- en: '![Checking multiple conditions using nested if blocks and with the or operator](httpatomoreillycomsourcenostarchimages2134733.png.jpg)Figure 6-13. Checking
    multiple conditions using nested *if* blocks and with the *or* operator'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用嵌套的if语句块和or运算符检查多个条件](httpatomoreillycomsourcenostarchimages2134733.png.jpg)图
    6-13. 使用嵌套的*if*语句块和*or*运算符检查多个条件'
- en: Note again that the **or** operator provides a more concise way to test multiple
    conditions. The command(s) inside the **if** block in [Figure 6-13](ch06.html#checking_multiple_conditions_usi-id00013
    "Figure 6-13. Checking multiple conditions using nested if blocks and with the
    or operator") ② will be executed if `timeLeft` or `energyLevel` is 0\. If both
    of these two conditions are false, the entire test evaluates to false, and the
    `gameOver` flag will not be set to 1.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请再次注意，**or**运算符提供了一种更简洁的方式来测试多个条件。[图 6-13](ch06.html#checking_multiple_conditions_usi-id00013
    "图 6-13. 使用嵌套的**if/else**语句块和**or**运算符检查多个条件")中的**if**语句块②将在`timeLeft`或`energyLevel`为0时执行。如果这两个条件都为假，整个测试结果将为假，`gameOver`标志将不会被设置为1。
- en: The not Operator
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非运算符
- en: The **not** operator takes only one expression as input. The result of the operator
    is true if the expression is false and false if the expression is true. The truth
    table for this operator is given in [Table 6-7](ch06.html#truth_table_for_the_not_operator
    "Table 6-7. Truth Table for the not Operator").
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**not**运算符只接受一个表达式作为输入。如果该表达式为假，运算符的结果为真；如果表达式为真，结果为假。此运算符的真值表可见于[表 6-7](ch06.html#truth_table_for_the_not_operator
    "表 6-7. not运算符的真值表")。'
- en: Table 6-7. Truth Table for the not Operator
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-7. not 运算符的真值表
- en: '| X | ![image with no caption](httpatomoreillycomsourcenostarchimages2134735.png.jpg)
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| X | ![没有说明的图片](httpatomoreillycomsourcenostarchimages2134735.png.jpg) |'
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| true | false |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 正确 | 错误 |'
- en: '| false | true |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | 正确 |'
- en: Going back to our hypothetical game from earlier, let’s say the player can’t
    progress to the next level if the score isn’t more than 100 points. This would
    be a good place to use the **not** operator, as shown in [Figure 6-14](ch06.html#example_of_using_the_not_operator
    "Figure 6-14. Example of using the not operator"). You can read this block of
    code as, “If score is not greater than 100, do the command(s) inside the **if**
    block.”
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前假设的游戏场景，假设玩家如果分数未超过100分就无法进入下一关。这时使用**not**运算符是一个不错的选择，如[图 6-14](ch06.html#example_of_using_the_not_operator
    "图 6-14. 使用not运算符的示例")所示。你可以这样理解这段代码：“如果分数不大于100，执行**if**块中的命令。”
- en: '![Example of using the not operator](httpatomoreillycomsourcenostarchimages2134737.png.jpg)Figure 6-14. Example
    of using the *`not`* operator'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用not运算符的示例](httpatomoreillycomsourcenostarchimages2134737.png.jpg)图 6-14.
    使用*`not`* 运算符的示例'
- en: In effect, if the value of the `score` variable is 100 or lower, the test expression
    evaluates to true, and the **say** command will execute. Note that the expression
    **not (score > 100)** is equivalent to **(score ≤ 100)**.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果`score`变量的值为100或更低，测试表达式的结果为真，**say**命令将会执行。注意，表达式**not (score > 100)**
    等价于 **(score ≤ 100)**。
- en: Using Logical Operators to Check Numeric Ranges
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用逻辑运算符检查数值范围
- en: When you need to validate data entered by a user or filter out bad inputs, you
    can use logical operators to determine whether a number is inside (or outside)
    a numeric range. [Table 6-8](ch06.html#expressing_numerical_ranges "Table 6-8. Expressing
    Numerical Ranges") shows some examples of numerical ranges.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要验证用户输入的数据或筛选掉无效输入时，可以使用逻辑运算符来判断一个数字是否在数值范围内（或外）。[表 6-8](ch06.html#expressing_numerical_ranges
    "表 6-8. 表达数值范围")展示了一些数值范围的例子。
- en: Table 6-8. Expressing Numerical Ranges
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-8. 表达数值范围
- en: '| Expression | Value |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 值 |'
- en: '| --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **(x > 10) and (x < 20)** | Evaluates to true if the value of **x** is greater
    than 10 and less than 20. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **(x > 10) and (x < 20)** | 如果**x**的值大于10且小于20，结果为真。 |'
- en: '| **(x < 10) or (x > 20)** | Evaluates to true if the value of **x** is less
    than 10 or greater than 20. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **(x < 10) or (x > 20)** | 如果**x**的值小于10或大于20，结果为真。 |'
- en: '| **(x < 10) and (x > 20)** | Always false. **x** `can’t` be both less than
    10 and greater than 20. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **(x < 10) and (x > 20)** | 总是错误的。**x** `不能`同时小于10又大于20。 |'
- en: Although Scratch does not have built-in support for `≥` (greater than or equal
    to) and `≤` (less than or equal to) operators, you can use logical operators to
    implement these tests. Let’s say, for example, that you need to test the condition
    **x ≥ 10** in your program. The solution set for this inequality is shown in [Figure 6-15](ch06.html#two_ways_to_implement_the_inequality_x_g
    "Figure 6-15. Two ways to implement the inequality x ≥ 10") ①. The filled circle
    in the figure means that the number 10 is included in the solution set.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Scratch没有内建支持`≥`（大于或等于）和`≤`（小于或等于）运算符，但你可以使用逻辑运算符来实现这些测试。例如，假设你需要在程序中测试条件**x
    ≥ 10**。此不等式的解集如[图 6-15](ch06.html#two_ways_to_implement_the_inequality_x_g "图
    6-15. 实现不等式x ≥ 10的两种方式")所示①。图中的实心圆表示数字10包含在解集中。
- en: One way to test this condition is shown in [Figure 6-15](ch06.html#two_ways_to_implement_the_inequality_x_g
    "Figure 6-15. Two ways to implement the inequality x ≥ 10") ②. The figure shows
    the solution set for **x < 10**, where the nonfilled circle means that the corresponding
    point is not in the solution set. As you can see from the figure, the *complementary*
    solution (that is, “*x* is not less than 10”) is equivalent to **x ≥ 10**. Another
    way to perform the inequality test is shown in [Figure 6-15](ch06.html#two_ways_to_implement_the_inequality_x_g
    "Figure 6-15. Two ways to implement the inequality x ≥ 10") ③. Clearly, if **x
    ≥ 10**, then either *x* is greater than 10 or *x* is equal to 10.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 测试此条件的一种方法如[图 6-15](ch06.html#two_ways_to_implement_the_inequality_x_g "图 6-15.
    实现不等式 x ≥ 10 的两种方法") ② 所示。该图显示了**x < 10** 的解集，其中空心圆表示相应的点不在解集中。如图所示，*补集*解（即“*x*
    不小于 10”）等价于 **x ≥ 10**。另一种执行不等式测试的方法如[图 6-15](ch06.html#two_ways_to_implement_the_inequality_x_g
    "图 6-15. 实现不等式 x ≥ 10 的两种方法") ③ 所示。显然，如果 **x ≥ 10**，则 *x* 要么大于 10，要么等于 10。
- en: '![Two ways to implement the inequality x ≥ 10](httpatomoreillycomsourcenostarchimages2134739.png.jpg)Figure 6-15. Two
    ways to implement the inequality ***x ≥ 10***'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![实现不等式 x ≥ 10 的两种方法](httpatomoreillycomsourcenostarchimages2134739.png.jpg)图
    6-15. 实现不等式 ***x ≥ 10***'
- en: The examples provided in [Table 6-9](ch06.html#examples_of_testing_inequalities
    "Table 6-9. Examples of Testing Inequalities") demonstrate how to use Scratch’s
    relational and logical operators to express inequalities that contain the `≥`
    and the `≤` operators.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 6-9](ch06.html#examples_of_testing_inequalities "表格 6-9. 测试不等式的示例") 中提供的示例展示了如何使用
    Scratch 的关系运算符和逻辑运算符来表示包含 `≥` 和 `≤` 运算符的不等式。'
- en: Table 6-9. Examples of Testing Inequalities
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 6-9. 测试不等式的示例
- en: '| Expression | Implementation Using Logical Operators |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 使用逻辑运算符实现 |'
- en: '| --- | --- |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *x* ≥ 10 | ![image with no caption](httpatomoreillycomsourcenostarchimages2134741.png.jpg)
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| *x* ≥ 10 | ![无标题图片](httpatomoreillycomsourcenostarchimages2134741.png.jpg)
    |'
- en: '| *x* ≥ 10 | ![image with no caption](httpatomoreillycomsourcenostarchimages2134743.png.jpg)
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| *x* ≥ 10 | ![无标题图片](httpatomoreillycomsourcenostarchimages2134743.png.jpg)
    |'
- en: '| *x* ≤ 10 | ![image with no caption](httpatomoreillycomsourcenostarchimages2134745.png.jpg)
    |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| *x* ≤ 10 | ![无标题图片](httpatomoreillycomsourcenostarchimages2134745.png.jpg)
    |'
- en: '| *x* ≤ 10 | ![image with no caption](httpatomoreillycomsourcenostarchimages2134747.png.jpg)
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| *x* ≤ 10 | ![无标题图片](httpatomoreillycomsourcenostarchimages2134747.png.jpg)
    |'
- en: '| 10 ≤ *x* ≤20 | ![image with no caption](httpatomoreillycomsourcenostarchimages2134749.png.jpg)
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 10 ≤ *x* ≤20 | ![无标题图片](httpatomoreillycomsourcenostarchimages2134749.png.jpg)
    |'
- en: '| 10 ≤ *x* ≤20 | ![image with no caption](httpatomoreillycomsourcenostarchimages2134751.png.jpg)
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 10 ≤ *x* ≤20 | ![无标题图片](httpatomoreillycomsourcenostarchimages2134751.png.jpg)
    |'
- en: We’ve explored several Scratch concepts in this chapter so far, including comparisons,
    conditional statements, and logical operators. Now, let’s use that knowledge to
    create some fun and useful applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在这一章中已经探讨了几个 Scratch 概念，包括比较、条件语句和逻辑运算符。现在，让我们运用这些知识创建一些有趣且实用的应用程序。
- en: Comparing Decimal Numbers
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 比较十进制数字
- en: 'Special care must be taken when using the equal operator to compare decimal
    numbers. Because of the way these numbers are stored inside the computer, the
    comparison may sometimes be imprecise. Consider the command blocks shown here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用等于运算符比较十进制数字时必须特别小心。由于这些数字在计算机内的存储方式，这种比较有时可能不准确。考虑此处显示的命令块：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134753.png.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages2134753.png.jpg)'
- en: The result of dividing 1 by 3 is 0 .3333... with the sequence of 3s repeating
    forever. Since the computer uses a fixed amount of space to store the result,
    the fraction 1/3 cannot be exactly stored by the computer. Although Scratch tells
    you that the result of the division is 0 .33 at ①, the actual result is saved
    internally with much higher precision. Therefore, the results of the first two
    comparisons in the figure (② and ③) evaluate to false.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将 1 除以 3 的结果是 0.3333...，其中 3 会无限重复。由于计算机使用固定的空间来存储结果，分数 1/3 不能被计算机精确存储。尽管 Scratch
    在 ① 处告诉你除法结果是 0.33，实际结果内部存储的精度要高得多。因此，图中前两个比较（② 和 ③）的结果为假。
- en: 'Depending on your programming situation, you may be able to prevent this type
    of error by using one of the following approaches:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的编程环境，你可以通过使用以下一种方法来防止这种类型的错误：
- en: Use the less than (`<`) and greater than (`>`) operators instead of the equals
    operator (`=`) when possible.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用小于（`<`）和大于（`>`）运算符，而不是等于运算符（`=`）。
- en: Use the **round** block to round the two numbers you need to compare, and then
    compare the rounded numbers for equality.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**round**代码块来四舍五入你需要比较的两个数字，然后比较四舍五入后的数字是否相等。
- en: 'Test the absolute difference between the two values you are comparing. For
    example, instead of testing if *x* equals *y*, we can check to see if the absolute
    difference between *x* and *y* is within an acceptable tolerance by using a block
    similar to this one:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你比较的两个值之间的绝对差。例如，代替测试*x*是否等于*y*，我们可以检查*x*和*y*之间的绝对差是否在可接受的容差范围内，使用一个类似于这个的代码块：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134755.png.jpg)'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![没有说明的图片](httpatomoreillycomsourcenostarchimages2134755.png.jpg)'
- en: Depending on the accuracy of the numbers and the method of calculating these
    numbers, this method may be sufficient for your purpose.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据数字的精度和计算这些数字的方法，这种方法可能足以满足你的需求。
- en: Scratch Projects
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scratch 项目
- en: The new commands you’ve learned in this chapter should allow you to create a
    wide range of useful Scratch applications, and hopefully the projects I present
    in this section will give you some ideas for your own projects. I encourage you
    try out these applications, understand how they work, and then think of ways to
    enhance them.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你所学到的新命令应该使你能够创建各种有用的 Scratch 应用程序，希望我在本节中展示的项目能够给你一些关于自己项目的灵感。我鼓励你尝试这些应用程序，理解它们是如何工作的，然后思考如何改进它们。
- en: Guess My Coordinates
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 猜我的坐标
- en: '*GuessMyCoordinates.sb2*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*GuessMyCoordinates.sb2*'
- en: In this section, we’ll develop an interactive game that can be used to test
    anyone’s knowledge of the Cartesian coordinate system. The game contains a single
    sprite (called `Star`) that represents a random point on the Stage (see [Figure 6-16](ch06.html#guess_my_coordinates_interface
    "Figure 6-16. The Guess My Coordinates interface")).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个互动游戏，用于测试任何人对笛卡尔坐标系的知识。游戏包含一个精灵（称为`Star`），它代表舞台上的一个随机点（见[图 6-16](ch06.html#guess_my_coordinates_interface
    "图 6-16. 猜我的坐标界面")）。
- en: '![The Guess My Coordinates interface](httpatomoreillycomsourcenostarchimages2134757.png.jpg)Figure 6-16. The
    Guess My Coordinates interface'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![猜我的坐标界面](httpatomoreillycomsourcenostarchimages2134757.png.jpg)图 6-16. 猜我的坐标界面'
- en: Each time you run the game, the sprite moves to a different location on the
    Stage and asks the user to guess its *x*- and *y*-coordinates. The game checks
    the user’s answers and provides an appropriate feedback message. The main script
    for the `Star` sprite is shown in [Figure 6-17](ch06.html#script_for_the_guess_my_coordinates_game
    "Figure 6-17. Script for the Guess My Coordinates game").
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行游戏时，精灵会移动到舞台上的不同位置，并要求用户猜测其*x*和*y*坐标。游戏检查用户的答案，并提供适当的反馈信息。`Star`精灵的主要脚本如[图
    6-17](ch06.html#script_for_the_guess_my_coordinates_game "图 6-17. 猜我的坐标游戏的脚本")所示。
- en: This script uses two variables, `X` and `Y`, to hold the random coordinates
    of the sprite. I’ll explain how each numbered section from [Figure 6-17](ch06.html#script_for_the_guess_my_coordinates_game
    "Figure 6-17. Script for the Guess My Coordinates game") works below.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本使用两个变量，`X` 和 `Y`，来保存精灵的随机坐标。我将在下面解释[图 6-17](ch06.html#script_for_the_guess_my_coordinates_game
    "图 6-17. 猜我的坐标游戏的脚本")中的每个编号部分是如何工作的。
- en: The `X` variable is assigned a random value from the set {–220, –200, –180,
    ..., 220}. This is achieved by first selecting a random integer between –11 and
    11 and multiplying the result by 20\. Similarly, the `Y` variable is assigned
    a random value from the set {–160, –140, –120, ..., 160}. The selected `X` and
    `Y` values ensure that the resulting point is located on one of the grid intersection
    points of [Figure 6-16](ch06.html#guess_my_coordinates_interface "Figure 6-16. The
    Guess My Coordinates interface"). The sprite is then moved to the location specified
    by `X` and `Y`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`X` 变量从集合 {–220, –200, –180, ..., 220} 中随机选择一个值。通过首先选择一个在 –11 到 11 之间的随机整数，然后将结果乘以
    20 来实现。同样，`Y` 变量从集合 {–160, –140, –120, ..., 160} 中随机选择一个值。选择的 `X` 和 `Y` 值确保结果点位于[图
    6-16](ch06.html#guess_my_coordinates_interface "图 6-16. 猜我的坐标界面")中的网格交点之一。然后，精灵会移动到由
    `X` 和 `Y` 指定的位置。'
- en: '![Script for the Guess My Coordinates game](httpatomoreillycomsourcenostarchimages2134759.png.jpg)Figure 6-17. Script
    for the Guess My Coordinates game'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![猜我的坐标游戏的脚本](httpatomoreillycomsourcenostarchimages2134759.png.jpg)图 6-17.
    猜我的坐标游戏的脚本'
- en: The script asks the user to enter the *x*-coordinate of the sprite and waits
    for an answer.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本要求用户输入精灵的 *x* 坐标，并等待回答。
- en: If the answer is correct, the script moves to step 4\. Otherwise, it will call
    the **ShowAnswer** procedure to display the correct coordinates of the point.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果答案正确，脚本将进入第 4 步。否则，它将调用 **ShowAnswer** 程序来显示正确的坐标。
- en: When the user enters the correct value for the *x*-coordinate, the script prompts
    the user to enter the *y*-coordinate of the sprite and waits for an answer.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户输入正确的 *x* 坐标时，脚本提示用户输入精灵的 *y* 坐标，并等待回答。
- en: If the user answers correctly, the script displays the message “Good Job.” Otherwise,
    it calls **ShowAnswer** to display the correct coordinates.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户回答正确，脚本会显示消息“做得好”。否则，它会调用 **ShowAnswer** 来显示正确的坐标。
- en: The **ShowAnswer** procedure is shown in [Figure 6-18](ch06.html#showanswer_procedure
    "Figure 6-18. The ShowAnswer procedure"). The `point` variable is first constructed
    to have a string of the form `(X,Y)` using the **join** operator. The procedure
    then uses the **say** command to show the correct answer to the user.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**ShowAnswer** 程序见[图 6-18](ch06.html#showanswer_procedure "图 6-18. ShowAnswer
    程序")。`point` 变量首先通过 **join** 操作符构建为一个形如 `(X,Y)` 的字符串。然后，程序使用 **say** 命令将正确答案展示给用户。'
- en: '![The ShowAnswer procedure](httpatomoreillycomsourcenostarchimages2134761.png.jpg)Figure 6-18. The
    *ShowAnswer* procedureTry It Out 6-1'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![ShowAnswer 程序](httpatomoreillycomsourcenostarchimages2134761.png.jpg)图 6-18.
    *ShowAnswer* 程序试试看 6-1'
- en: Enhance this guessing game with some fun modifications. For example, you could
    make the game play music when someone wins, trigger a buzz for a wrong answer,
    run automatically (without having to press the green flag each time), or keep
    track of the number of correct answers to display the player’s score.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些有趣的修改来增强这个猜谜游戏。例如，你可以在某人获胜时播放音乐，错误回答时触发蜂鸣声，自动运行（无需每次点击绿旗），或者跟踪正确回答的次数来显示玩家的分数。
- en: Triangle Classification Game
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三角形分类游戏
- en: '*TriangleClassification.sb2*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*TriangleClassification.sb2*'
- en: As [Figure 6-19](ch06.html#classifying_a_triangle_based_on_its_side "Figure 6-19. Classifying
    a triangle based on its sides") illustrates, a triangle can be classified as scalene,
    isosceles, or equilateral based on the lengths of its sides. In this section,
    you’ll explore a game that quizzes players on these concepts.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 6-19](ch06.html#classifying_a_triangle_based_on_its_side "图 6-19. 根据三角形的边分类")所示，三角形可以根据其边长分类为不等边三角形、等腰三角形或等边三角形。在这一节中，你将探索一个对这些概念进行测试的游戏。
- en: '![Classifying a triangle based on its sides](httpatomoreillycomsourcenostarchimages2134763.png)Figure 6-19. Classifying
    a triangle based on its sides'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![根据三角形的边分类](httpatomoreillycomsourcenostarchimages2134763.png)图 6-19. 根据三角形的边分类'
- en: The game draws a triangle on the Stage and asks the player to classify that
    triangle as one of the three types. The user interface for this game is illustrated
    in [Figure 6-20](ch06.html#user_interface_for_the_triangle_classifi "Figure 6-20. User
    interface for the triangle classification game").
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏在舞台上绘制一个三角形，并要求玩家将该三角形归类为三种类型之一。此游戏的用户界面见[图 6-20](ch06.html#user_interface_for_the_triangle_classifi
    "图 6-20. 三角形分类游戏的用户界面")。
- en: '![User interface for the triangle classification game](httpatomoreillycomsourcenostarchimages2134765.png.jpg)Figure 6-20. User
    interface for the triangle classification game'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![三角形分类游戏的用户界面](httpatomoreillycomsourcenostarchimages2134765.png.jpg)图 6-20.
    三角形分类游戏的用户界面'
- en: '[Figure 6-20](ch06.html#user_interface_for_the_triangle_classifi "Figure 6-20. User
    interface for the triangle classification game") shows that this game contains
    five sprites. Three sprites (named `Scalene`, `Isosceles`, and `Equilateral`)
    represent the buttons the user clicks to select an answer, and the invisible `Painter`
    sprite draws the triangle on the Stage.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-20](ch06.html#user_interface_for_the_triangle_classifi "图 6-20. 三角形分类游戏的用户界面")显示该游戏包含五个精灵。三个精灵（分别命名为
    `Scalene`、`Isosceles` 和 `Equilateral`）表示用户点击以选择答案的按钮，另一个隐藏的 `Painter` 精灵则在舞台上绘制三角形。'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*I made the* `Painter` *sprite invisible by unchecking its Show checkbox in
    the sprite info area. If you prefer to control the sprite’s visibility from the
    script, you can add a* **hide** *block to explicitly hide the sprite when the
    game starts.*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*我通过在精灵信息区取消勾选 Show 复选框使 `Painter` 精灵变为不可见。如果你希望通过脚本控制精灵的可见性，可以添加一个**hide**
    块来在游戏开始时明确隐藏精灵。*'
- en: The `Tutor` sprite is the game’s main driver; it determines the type of triangle
    to draw for each run and checks the user’s answer. The scripts for the `Tutor`
    sprite are shown in [Figure 6-21](ch06.html#scripts_for_the_tutor_spritedot_the_main
    "Figure 6-21. Scripts for the Tutor sprite. The main driver script (top left)
    calls NewQuestion (right) and CheckAnswer (bottom left).").
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tutor` 角色是游戏的主要驱动程序；它决定每次运行时绘制的三角形类型，并检查用户的答案。`Tutor` 角色的脚本如[图6-21](ch06.html#scripts_for_the_tutor_spritedot_the_main
    "图6-21. `Tutor` 角色的脚本。主要驱动程序脚本（左上角）调用 NewQuestion（右侧）和 CheckAnswer（左下角）。")所示。'
- en: '![Scripts for the Tutor sprite. The main driver script (top left) calls NewQuestion
    (right) and CheckAnswer (bottom left).](httpatomoreillycomsourcenostarchimages2134767.png.jpg)Figure 6-21. Scripts
    for the *`Tutor`* sprite. The main driver script (top left) calls *NewQuestion*
    (right) and *CheckAnswer* (bottom left).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![Tutor角色的脚本。主要驱动程序脚本（左上角）调用 NewQuestion（右侧）和 CheckAnswer（左下角）。](httpatomoreillycomsourcenostarchimages2134767.png.jpg)图6-21.
    *`Tutor`* 角色的脚本。主要驱动程序脚本（左上角）调用 *NewQuestion*（右侧）和 *CheckAnswer*（左下角）。'
- en: When the green flag icon is clicked to start the game, the main script enters
    an infinite loop. On each pass of the loop, the script sets `choice` to 0 (to
    indicate that the player hasn’t answered yet), draws a different triangle, and
    waits for an answer. The `choice` variable should change when the user clicks
    any of the three answer buttons. When the user clicks a button to classify the
    triangle, the script checks the answer and provides appropriate feedback. Let’s
    look at each step in more detail.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击绿旗图标以开始游戏时，主脚本进入一个无限循环。每次循环时，脚本将 `choice` 设置为 0（表示玩家尚未回答），绘制一个不同的三角形，并等待答案。当用户点击任何一个答案按钮时，`choice`
    变量应该改变。当用户点击一个按钮来分类三角形时，脚本会检查答案并提供适当的反馈。我们来更详细地看一下每一步。
- en: 'The **NewQuestion** procedure starts by randomly setting `type`—which determines
    the type of the triangle to be drawn on the Stage—to 1, 2, or 3\. The script then
    uses two **if/else** blocks to set the value of the `name` variable based on the
    value of `type`. The `name` variable serves two purposes: (1) it specifies which
    broadcast message to send so the `Painter` sprite knows what to draw (note how
    the **broadcast and wait** block uses `name`), and (2) it is used in the **CheckAnswer**
    procedure to create the user’s feedback message. When the `Painter` sprite finishes
    drawing, the **NewQuestion** procedure prompts the user for an answer with the
    **say** command.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**NewQuestion** 程序首先通过随机设置 `type`（它决定了在舞台上绘制的三角形类型）为 1、2 或 3 来开始。然后，脚本使用两个
    **if/else** 块根据 `type` 的值设置 `name` 变量的值。`name` 变量有两个作用：（1）它指定发送哪个广播消息，以便 `Painter`
    角色知道要绘制什么（三星如何使用 **广播并等待** 块中的 `name`），（2）它在 **CheckAnswer** 程序中用于创建用户的反馈消息。当
    `Painter` 角色绘制完成后，**NewQuestion** 程序使用 **say** 命令提示用户输入答案。'
- en: When the `Painter` sprite receives the broadcast message, it draws the corresponding
    triangle on the Stage. To make the game more exciting, the `Painter` sprite uses
    random values for the triangle’s size, orientation, and color, as shown in [Figure 6-22](ch06.html#scripts_for_the_painter_sprite-id00015
    "Figure 6-22. Scripts for the Painter sprite").
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Painter` 角色收到广播消息时，它会在舞台上绘制相应的三角形。为了让游戏更加刺激，`Painter` 角色使用随机值来确定三角形的大小、方向和颜色，如[图6-22](ch06.html#scripts_for_the_painter_sprite-id00015
    "图6-22. *`Painter`* 角色的脚本")所示。
- en: '![Scripts for the Painter sprite](httpatomoreillycomsourcenostarchimages2134769.png.jpg)Figure 6-22. Scripts
    for the *`Painter`* sprite'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![画家角色的脚本](httpatomoreillycomsourcenostarchimages2134769.png.jpg)图6-22. *`Painter`*
    角色的脚本'
- en: After asking the user to classify the drawn triangle, the main script uses the
    **wait until** block (from the *Control* Palette) to pause until **choice > 0**
    becomes true. The three button sprites will change `choice` when they are clicked.
    The `Scalene` button sets `choice` to 1, the `Isosceles` button sets `choice`
    to 2, and the `Equilateral` button sets `choice` to 3 (see [Figure 6-23](ch06.html#scripts_for_the_three_button_sprites
    "Figure 6-23. Scripts for the three button sprites")).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求用户分类绘制的三角形后，主脚本使用 **wait until** 块（来自 *控制* 调色板）暂停，直到 **choice > 0** 成为真。三个按钮角色会在点击时改变
    `choice`。`Scalene` 按钮将 `choice` 设置为 1，`Isosceles` 按钮将 `choice` 设置为 2，而 `Equilateral`
    按钮将 `choice` 设置为 3（见[图6-23](ch06.html#scripts_for_the_three_button_sprites "图6-23.
    三个按钮角色的脚本")）。
- en: '![Scripts for the three button sprites](httpatomoreillycomsourcenostarchimages2134771.png.jpg)Figure 6-23. Scripts
    for the three button sprites'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![三个按钮精灵的脚本](httpatomoreillycomsourcenostarchimages2134771.png.jpg)图6-23. 三个按钮精灵的脚本'
- en: When a button is pressed, its sprite moves a little bit down and to the right
    to give the visual effect of a button press. When the mouse is released, the sprite
    returns to its original position and sets the value of the variable `choice` to
    indicate that the user clicked that button. Note that each sprite sets `choice`
    to a different number. The blocks for moving the buttons in these scripts are
    not strictly necessary and can be removed if desired.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被按下时，它的精灵会稍微向下和向右移动，给人一种按钮被按下的视觉效果。当鼠标释放时，精灵返回到原来的位置，并设置变量`choice`的值以表示用户点击了该按钮。注意，每个精灵都会将`choice`设置为不同的数字。这些脚本中用于移动按钮的块并非严格必要，如果需要，可以将其移除。
- en: Once the user chooses a triangle type, `choice` becomes greater than zero, and
    the main script calls the **CheckAnswer** procedure. This procedure compares the
    `type` variable (which specified the type of the drawn triangle) with the value
    of the `choice` variable. If the two variables have the same value, then the user’s
    answer was correct. Otherwise, the user’s answer was wrong, and the script will
    say the correct classification.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户选择了一个三角形类型，`choice`的值就会大于零，主脚本会调用**CheckAnswer**过程。这个过程将`type`变量（指定所画三角形的类型）与`choice`变量的值进行比较。如果两个变量的值相同，那么用户的答案是正确的。否则，用户的答案是错误的，脚本会显示正确的分类。
- en: Try It Out 6-2
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 试试第6-2节
- en: 'Open this game and play it a few times. Once you understand how it works, try
    adding some extra functions. Here are a few ideas:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 打开这个游戏并玩几次。一旦你理解了它的工作原理，尝试添加一些额外的功能。以下是一些想法：
- en: Make the game keep score. It could add a point for each correct answer and deduct
    a point for each incorrect answer.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让游戏保持计分。它可以为每个正确的答案加一分，并为每个错误的答案扣一分。
- en: Give the user an option to quit the game.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给用户一个退出游戏的选项。
- en: Define a criterion for ending the game. For example, you could set the main
    repeat loop to run 20 times instead of forever. You could also stop the game after
    five incorrect answers.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个游戏结束的标准。例如，你可以设置主循环运行20次而不是一直运行。你也可以在五次错误答案后停止游戏。
- en: Have something exciting happen while the game is running. For example, you might
    create a variable named `specialNumber` and assign it a random value at the start
    of the game. When the number of correct answers matches `specialNumber`, the game
    could give the user bonus points, play music, or even tell a joke.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏进行时，让一些令人兴奋的事情发生。例如，你可以创建一个名为`specialNumber`的变量，并在游戏开始时为它赋予一个随机值。当正确答案的数量与`specialNumber`匹配时，游戏可以给用户加分、播放音乐，甚至讲一个笑话。
- en: Bring the buttons to life with graphics effects. For example, if you add the
    script shown below to each button, the buttons will change color when the mouse
    hovers over them.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过图形效果让按钮“活起来”。例如，如果你在每个按钮上添加如下脚本，当鼠标悬停在按钮上时，按钮的颜色将发生变化。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134773.png.jpg)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2134773.png.jpg)'
- en: Line Follower
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线路跟随器
- en: '*LineFollower.sb2*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*LineFollower.sb2*'
- en: Can we make a sprite follow (or trace) a path on the Stage, like the one shown
    in [Figure 6-24](ch06.html#sample_path_for_a_sprite_to_follow "Figure 6-24. Sample
    path for a sprite to follow"), all by itself? The answer is yes, and in this section,
    we’ll write a program to do it. If you look closely at the sprite in the figure,
    you’ll notice that we painted the nose and the two ears of the cat with different
    colors. The figure also shows an enlarged view of the cat’s head.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否让精灵像[图6-24](ch06.html#sample_path_for_a_sprite_to_follow "图6-24. 精灵跟随的示例路径")中所示那样自己在舞台上跟随（或追踪）一条路径？答案是肯定的，在这一部分，我们将编写一个程序来实现这一点。如果你仔细观察图中的精灵，你会注意到我们用不同的颜色为猫的鼻子和两个耳朵上了色。图中还展示了猫头部的放大视图。
- en: '![Sample path for a sprite to follow](httpatomoreillycomsourcenostarchimages2134775.png.jpg)Figure 6-24. Sample
    path for a sprite to follow'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![精灵跟随的示例路径](httpatomoreillycomsourcenostarchimages2134775.png.jpg)图6-24. 精灵跟随的示例路径'
- en: 'The plan is to use the cat’s nose and ears as color sensors for detecting the
    black line underneath. Our algorithm for tracing the black line uses the following
    *heuristics* (rules based primarily on logical reasoning and trial-and-error experimentation):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是利用猫的鼻子和耳朵作为颜色传感器来检测下面的黑线。我们的黑线追踪算法使用以下的*启发式*（基于逻辑推理和反复试验的规则）：
- en: If the nose of the cat (pink color) is touching the line, move forward.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果猫的鼻子（粉色）接触到线条，则向前移动。
- en: If the left ear of the cat (yellow color) is touching the line, turn counterclockwise
    and move forward at a reduced speed.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果猫的左耳（黄色）接触到线条，则逆时针转弯并以较低的速度向前移动。
- en: If the right ear of the cat (green color) is touching the line, turn clockwise
    and move forward at a reduced speed.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果猫的右耳（绿色）接触到线条，则顺时针转弯并以较低的速度向前移动。
- en: Of course, the exact speed (movement steps) and turning angles can be different
    for different routes and have to be determined by experimentation. A script that
    implements the above algorithm and causes the sprite to follow the line is shown
    in [Figure 6-25](ch06.html#line-following_algorithm "Figure 6-25. Line-following
    algorithm").
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，精确的速度（移动步数）和转弯角度可以根据不同的路线有所不同，需要通过实验来确定。实现上述算法并使精灵沿线行走的脚本如[图 6-25](ch06.html#line-following_algorithm
    "图 6-25. 线条跟踪算法")所示。
- en: 'The script in [Figure 6-25](ch06.html#line-following_algorithm "Figure 6-25. Line-following
    algorithm") uses a new block: **color is touching?** (from the *Sensing* palette).
    This block checks whether a color on the sprite (specified in the first color
    square) is touching another color (specified in the second color square). If the
    specified color on the sprite is touching the other color, the block returns true;
    otherwise, it returns false. The color in a color square can be chosen by clicking
    on the color square and then clicking anywhere in the Scratch project to pick
    the desired color.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-25](ch06.html#line-following_algorithm "图 6-25. 线条跟踪算法")中的脚本使用了一个新的积木：**颜色接触？**（来自*感应*调色板）。这个积木检查精灵上的颜色（在第一个颜色方块中指定）是否与另一个颜色（在第二个颜色方块中指定）接触。如果精灵上的指定颜色与另一个颜色接触，积木返回true；否则返回false。可以通过点击颜色方块，然后在Scratch项目中的任何地方点击来选择颜色。'
- en: '![Line-following algorithm](httpatomoreillycomsourcenostarchimages2134777.png.jpg)Figure 6-25. Line-following
    algorithmTry It Out 6-3'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![线条跟踪算法](httpatomoreillycomsourcenostarchimages2134777.png.jpg)图 6-25. 线条跟踪算法尝试练习
    6-3'
- en: Open the application and run it to see how it works. Experiment with the given
    values to make the sprite finish the track in the fastest possible time. One reviewer
    completed the track in 11 seconds. Can you beat the record? Create other tracks
    and see if this simple algorithm still works.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 打开应用程序并运行它，查看它是如何工作的。尝试调整给定的值，使精灵以最快的速度完成赛道。一位评论者在11秒内完成了赛道。你能打破记录吗？创建其他赛道，看看这个简单的算法是否仍然有效。
- en: Equation of a Line
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直线方程
- en: '*EquationOfALine*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*直线方程*'
- en: The equation of a line joining two points *P* = (*x*[1], *y*[1]) and *Q* = (*x*[2],
    *y*[2]) is *y* = *mx* + *b*, where *m* = (*y*[2] – *y*[1]) / (*x*[2] – *x*[1])
    is the slope of the line and *b* is the *y*-intercept. A vertical line has an
    equation of the form *x* = *k*, and a horizontal line has an equation of the form
    *y* = *k*, where *k* is a constant. In this section, we’ll develop an application
    that finds the equation of the line that joins two points in the Cartesian plane.
    The user interface for the application is shown in [Figure 6-26](ch06.html#user_interface_for_the_equation-finder_a
    "Figure 6-26. User interface for the equation-finder application").
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 连接两点 *P* = (*x*[1], *y*[1]) 和 *Q* = (*x*[2], *y*[2]) 的直线方程是 *y* = *mx* + *b*，其中
    *m* = (*y*[2] – *y*[1]) / (*x*[2] – *x*[1]) 是直线的斜率，*b* 是 *y*-截距。垂直线的方程为 *x* =
    *k*，水平线的方程为 *y* = *k*，其中 *k* 是常数。在本节中，我们将开发一个应用程序，用于找到连接笛卡尔平面中两点的直线方程。该应用程序的用户界面如[图
    6-26](ch06.html#user_interface_for_the_equation-finder_a "图 6-26. 方程查找应用程序的用户界面")所示。
- en: '![User interface for the equation-finder application](httpatomoreillycomsourcenostarchimages2134779.png.jpg)Figure 6-26. User
    interface for the equation-finder application'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![方程查找应用程序的用户界面](httpatomoreillycomsourcenostarchimages2134779.png.jpg)图 6-26.
    方程查找应用程序的用户界面'
- en: 'The user drags the two sprites representing the end points of the line onto
    the Stage, and the application automatically displays the equation of the resulting
    line. The application contains four sprites: `Point1` and `Point2` are used to
    mark the two end points of the line; `Drawer` is a hidden sprite that draws a
    straight line between the two points; and `Tutor` is responsible for computing
    and displaying the equation of the line.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将表示线条端点的两个精灵拖到舞台上，应用程序会自动显示生成的直线方程。应用程序包含四个精灵：`Point1` 和 `Point2` 用于标记线条的两个端点；`Drawer`
    是一个隐藏精灵，负责在两个端点之间绘制直线；而 `Tutor` 负责计算和显示直线方程。
- en: The scripts for `Point1` and `Point2` are very similar. They contain some logic
    (not shown here) that restricts the sprites’ locations to the intersection points
    of the grid. Essentially, when the user drags the `Point1` sprite, it updates
    the variables that hold its coordinates (named `X1` and `Y1`) and broadcasts `Redraw`.
    Similarly, when the user drags the `Point2` sprite, it updates the variables that
    hold its coordinates (named `X2` and `Y2`) and broadcasts the same message. All
    four variables (`X1`, `X2`, `Y1`, and `Y2`) can only take integer values in the
    range –9 to 9\. You can find the details of these scripts in the file *EquationOfALine.sb2*.
    Let’s now take a look at the scripts for the `Drawer` sprite, shown in [Figure 6-27](ch06.html#scripts_for_the_drawer_sprite
    "Figure 6-27. Scripts for the Drawer sprite").
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point1` 和 `Point2` 的脚本非常相似。它们包含一些逻辑（这里没有显示）来限制精灵的位置只能处于网格的交点上。实际上，当用户拖动 `Point1`
    精灵时，它会更新保存其坐标的变量（命名为 `X1` 和 `Y1`），并广播 `Redraw` 消息。类似地，当用户拖动 `Point2` 精灵时，它会更新保存其坐标的变量（命名为
    `X2` 和 `Y2`），并广播相同的消息。所有四个变量（`X1`、`X2`、`Y1` 和 `Y2`）的值仅能是 -9 到 9 之间的整数。你可以在文件 *EquationOfALine.sb2*
    中查看这些脚本的详细信息。现在，让我们来看一下 `Drawer` 精灵的脚本，如 [图 6-27](ch06.html#scripts_for_the_drawer_sprite
    "图 6-27. Drawer 精灵的脚本") 所示。'
- en: '![Scripts for the Drawer sprite](httpatomoreillycomsourcenostarchimages2134781.png.jpg)Figure 6-27. Scripts
    for the *`Drawer`* sprite'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![Drawer 精灵的脚本](httpatomoreillycomsourcenostarchimages2134781.png.jpg)图 6-27.
    *`Drawer`* 精灵的脚本'
- en: When the game starts, this sprite sets its pen’s size and color and gets ready
    to draw. When it receives the `Redraw` message, it moves to the `Point1` sprite,
    clears the Stage, and then moves to the `Point2` sprite. The result is a straight
    line that connects `Point1` and `Point2`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏开始时，该精灵设置其画笔的大小和颜色，并准备绘制。当它接收到 `Redraw` 消息时，它会移动到 `Point1` 精灵，清除舞台，然后移动到
    `Point2` 精灵。结果是一条连接 `Point1` 和 `Point2` 的直线。
- en: The `Tutor` sprite also executes a script when it receives the `Redraw` message,
    as shown in [Figure 6-28](ch06.html#redraw_message_handler_for_the_tutor_spr "Figure 6-28. Redraw
    message handler for the Tutor sprite").
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Tutor` 精灵接收到 `Redraw` 消息时，也会执行一个脚本，如 [图 6-28](ch06.html#redraw_message_handler_for_the_tutor_spr
    "图 6-28. Redraw 消息处理程序 for Tutor 精灵") 所示。
- en: '![Redraw message handler for the Tutor sprite](httpatomoreillycomsourcenostarchimages2134783.png.jpg)Figure 6-28. *`Redraw`*
    message handler for the *`Tutor`* sprite'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![重绘消息处理程序 for Tutor 精灵](httpatomoreillycomsourcenostarchimages2134783.png.jpg)图
    6-28. *`Redraw`* 消息处理程序 for *`Tutor`* 精灵'
- en: 'The script performs the following checks:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本执行以下检查：
- en: If the coordinates of `Point1` and `Point2` are the same, there is no line to
    process. The script simply says “Same point.”
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `Point1` 和 `Point2` 的坐标相同，则没有需要处理的线。脚本只会显示“相同的点”。
- en: If the two points are different but their *x*-coordinates are the same, then
    we have a vertical line. The script displays an equation of the form *x* = *constant*.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个点不同，但它们的 *x* 坐标相同，那么我们得到一条垂直线。脚本显示一个类似 *x* = *constant* 的方程。
- en: If the two points are different but their *y*-coordinates are the same, then
    we have a horizontal line. The script displays an equation of the form *y* = *constant*.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个点不同，但它们的 *y* 坐标相同，那么我们得到一条水平线。脚本显示一个类似 *y* = *constant* 的方程。
- en: Otherwise, the two points form a straight line whose equation has the form *y*
    = *mx + b*. The script first calls the **Compute** procedure to find the slope
    and the *y*-intercept of the line. Then it calls **ShowEquation** to put the equation
    in a proper format and show it to the user.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，两个点形成一条直线，其方程为 *y* = *mx + b*。脚本首先调用 **计算** 过程来找出斜率和 *y* 截距。然后它调用 **ShowEquation**
    来将方程格式化并显示给用户。
- en: The **Compute** procedure is shown in [Figure 6-29](ch06.html#compute_procedure
    "Figure 6-29. The Compute procedure"). It computes the slope (`m`) and the *y*-intercept
    (`b`) and then rounds these values to the nearest hundredth.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算** 过程如 [图 6-29](ch06.html#compute_procedure "图 6-29. 计算过程") 所示。它计算斜率（`m`）和
    *y* 截距（`b`），然后将这些值四舍五入到最接近的百分位。'
- en: '![The Compute procedure](httpatomoreillycomsourcenostarchimages2134785.png.jpg)Figure 6-29. The
    *Compute* procedure'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![计算过程](httpatomoreillycomsourcenostarchimages2134785.png.jpg)图 6-29. *计算*
    过程'
- en: The **ShowEquation** procedure is shown in [Figure 6-30](ch06.html#showequation_procedure
    "Figure 6-30. The ShowEquation procedure"). It uses two variables (`term1` and
    `term2`) and two subprocedures to properly format the equation for display.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**ShowEquation**过程如[图6-30](ch06.html#showequation_procedure "图6-30。ShowEquation过程")所示。它使用两个变量（`term1`和`term2`）和两个子过程来正确格式化方程以供显示。'
- en: '![The ShowEquation procedure](httpatomoreillycomsourcenostarchimages2134787.png.jpg)Figure 6-30. The
    *ShowEquation* procedure'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![ShowEquation过程](httpatomoreillycomsourcenostarchimages2134787.png.jpg)图6-30。*ShowEquation*过程'
- en: 'The **ShowEquation** procedure considers the following special cases while
    formatting the line equation:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**ShowEquation**过程在格式化直线方程时会考虑以下特殊情况：'
- en: If the slope is 1, `term1` will be set to *x* (instead of 1*x*).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果斜率为1，`term1`将被设置为*x*（而不是1*x*）。
- en: If the slope is –1, `term1` will be set to –*x* (instead of –1*x*).
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果斜率为–1，`term1`将被设置为–*x*（而不是–1*x*）。
- en: '`term2` is formed using the proper sign (plus or minus) of the *y*-intercept.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`term2`是使用*y*-截距的正确符号（加号或减号）形成的。'
- en: If the *y*-intercept is 0, the equation will have the form *y* = *mx*.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*y*-截距为0，方程将具有形式*y* = *mx*。
- en: Try It Out 6-4
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下 6-4
- en: Open the application and run it. Drag the two points to different locations
    on the Stage and check the displayed equation. To enhance this application, try
    adding a script to move `Tutor` sprite out of the way if it overlaps with the
    coordinates displayed by the `Point1` and `Point2` sprites.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 打开应用程序并运行它。将两个点拖动到舞台上的不同位置，并检查显示的方程式。为了增强此应用程序，尝试添加一个脚本，如果`Tutor`精灵与`Point1`和`Point2`精灵显示的坐标重叠，则将`Tutor`精灵移开。
- en: Other Applications
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他应用程序
- en: '*GuessMyNumber.sb2*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*GuessMyNumber.sb2*'
- en: Now let’s discuss some games you’ll find in the extra resources for this book
    (download the extra resources from *[http://nostarch.com/learnscratch/](http://nostarch.com/learnscratch/)*).
    The supplementary material contains two classic games that you can explore on
    your own. The first is a “guess my number” game. The application secretly selects
    an integer at random between 1 and 100 and prompts the player to guess that number.
    The application then tells the player whether the guess was higher or lower than
    the secret number by displaying “too high” or “too low,” respectively. The player
    has six chances to guess the secret number. A correct guess wins the game; otherwise,
    it’s a loss.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一些您将在本书的附加资源中找到的游戏（请从*[http://nostarch.com/learnscratch/](http://nostarch.com/learnscratch/)*下载附加资源）。附加材料包含两个经典游戏，您可以自行探索。第一个是“猜我的数字”游戏。应用程序会在1到100之间随机选择一个整数，并提示玩家猜测该数字。然后，应用程序通过显示“太高”或“太低”来告诉玩家猜测的数字是比秘密数字高还是低。玩家有六次机会猜测秘密数字。猜对了数字则赢得游戏，否则就是失败。
- en: '*RockPaper.sb2*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*RockPaper.sb2*'
- en: 'The second game allows the user to play Rock, Paper, Scissors against the computer.
    The player makes a selection by clicking one of three buttons that represent rock,
    paper, or scissors. The computer makes a random selection. The winner is selected
    according to the following rules: Paper beats (wraps) rock, rock beats (breaks)
    scissors, and scissors beat (cut) paper.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个游戏允许用户与计算机玩“石头、剪刀、布”游戏。玩家通过点击表示石头、布或剪刀的三个按钮之一来做出选择。计算机做出随机选择。根据以下规则选出获胜者：布胜（包裹）石头，石头胜（砸碎）剪刀，剪刀胜（剪）布。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the comparison operators in Scratch and used
    them to compare numbers, characters, and strings. After that, you learned about
    the **if** and **if/else** blocks and used them to make decisions and control
    actions in several programs. You also learned how to use nested **if** and **if/else**
    blocks for testing multiple conditions and applied this technique to develop a
    menu-driven application. You also learned about logical operators as an alternative,
    and more concise, way to test multiple conditions. Finally, you explored several
    complete applications that demonstrated decision-making structures in action.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Scratch中的比较运算符，并使用它们来比较数字、字符和字符串。之后，您学习了**if**和**if/else**块，并使用它们在多个程序中做出决策和控制动作。您还学习了如何使用嵌套的**if**和**if/else**块来测试多个条件，并应用此技术开发了一个基于菜单的应用程序。您还了解了逻辑运算符，它们作为一种替代方法，是测试多个条件的更简洁的方式。最后，您探索了几个完整的应用程序，展示了决策结构的实际应用。
- en: The next chapter will take you deeper into the *Control* palette, showing you
    the various repetition structures available in Scratch and teaching you how to
    use them to write even more powerful programs.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章节将带你深入了解*控制*面板，展示 Scratch 中可用的各种重复结构，并教你如何使用它们编写更强大的程序。
- en: Problems
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '| **Q:** | 1\. What is the value of `W` after executing each command in this
    script?![image with no caption](httpatomoreillycomsourcenostarchimages2134789.png.jpg)
    |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **Q:** | 1\. 执行此脚本中的每个命令后，`W` 的值是多少？![没有标题的图片](httpatomoreillycomsourcenostarchimages2134789.png.jpg)
    |'
- en: '| **Q:** | 2\. Express each of the following statements using an **if** block:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '| **Q:** | 2\. 使用**if**块表达以下每个语句：'
- en: If `x` divided by `y` is 5, then set `x` to 100.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `x` 除以 `y` 等于 5，则将 `x` 设置为 100。
- en: If `x` times `y` is 5, then set `x` to 1.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `x` 乘以 `y` 等于 5，则将 `x` 设置为 1。
- en: If `x` is less than `y`, then double the value of `x`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `x` 小于 `y`，则将 `x` 的值加倍。
- en: If `x` is greater than `y`, then increment the value of `x` by 1.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `x` 大于 `y`，则将 `x` 的值加 1。
- en: '|'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Q:** | 3\. Write a program that prompts the user to enter five test scores
    between 1 and 10\. The program will then count the number of scores that are greater
    than 7. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| **Q:** | 3\. 编写一个程序，提示用户输入五个介于 1 和 10 之间的测试分数。程序将计算并显示大于 7 的分数个数。 |'
- en: '| **Q:** | 4\. Express each of the following statements using an **if/else**
    block:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '| **Q:** | 4\. 使用**if/else**块表达以下每个语句：'
- en: If `x` times `y` is 8, then set `x` to 1; otherwise, set `x` to 2.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `x` 乘以 `y` 等于 8，则将 `x` 设置为 1；否则，将 `x` 设置为 2。
- en: If `x` is less than `y`, then double the value of `x`; otherwise, increment
    `x` by 1.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `x` 小于 `y`，则将 `x` 的值加倍；否则，将 `x` 的值加 1。
- en: If `x` is greater than `y`, then increment both by 1; otherwise, decrement both
    by 1.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `x` 大于 `y`，则同时将 `x` 和 `y` 增加 1；否则，同时将两者减少 1。
- en: '|'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Q:** | 5\. Trace through the script on the right for each of the following
    cases to find the output of each:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '| **Q:** | 5\. 按照右侧脚本的流程，依次检查每种情况的输出结果：'
- en: '`x` = –1, `y` = –1, `z` = –1'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x` = –1, `y` = –1, `z` = –1'
- en: '`x` = 1, `y` = 1, `z` = 0'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x` = 1, `y` = 1, `z` = 0'
- en: '`x` = 1, `y` = –1, `z` = 1'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x` = 1, `y` = –1, `z` = 1'
- en: '`x` = 1, `y` = –1, `z` = –1'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x` = 1, `y` = –1, `z` = –1'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134791.png.jpg)
    |'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2134791.png.jpg) |'
- en: '| **Q:** | 6\. Write a program that asks the user to enter three numbers. The
    program will then determine and print the largest of the three numbers. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **Q:** | 6\. 编写一个程序，要求用户输入三个数字。程序将确定并打印出这三个数字中最大的一个。 |'
- en: '| **Q:** | 7\. A company sells five different products whose retail prices
    are shown in the following table. Write a program that asks the user to enter
    the product number and the quantity sold. The program will then calculate and
    display the total retail value.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '| **Q:** | 7\. 一家公司销售五种不同的产品，其零售价如下表所示。编写一个程序，要求用户输入产品编号和销售数量。程序将计算并显示总零售价。
    |'
- en: '&#124; Product Number &#124; Retail Price &#124;'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 产品编号 &#124; 零售价 &#124;'
- en: '&#124; --- &#124; --- &#124;'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; --- &#124; --- &#124;'
- en: '&#124; 1 &#124; $2.95 &#124;'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1 &#124; $2.95 &#124;'
- en: '&#124; 2 &#124; $4.99 &#124;'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 2 &#124; $4.99 &#124;'
- en: '&#124; 3 &#124; $5.49 &#124;'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3 &#124; $5.49 &#124;'
- en: '&#124; 4 &#124; $7.80 &#124;'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4 &#124; $7.80 &#124;'
- en: '&#124; 5 &#124; $8.85 &#124;'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 5 &#124; $8.85 &#124;'
- en: '|'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Q:** | 8\. Construct a logical expression to represent each of the following
    conditions:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '| **Q:** | 8\. 构造一个逻辑表达式，表示以下每个条件：'
- en: '`score` is greater than 90 and less than 95.'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`score` 大于 90 且小于 95。'
- en: '`answer` is either y or yes.'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`answer` 是 y 或 yes。'
- en: '`answer` is an even number between 1 and 10.'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`answer` 是介于 1 和 10 之间的偶数。'
- en: '`answer` is an odd number between 1 and 10.'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`answer` 是介于 1 和 10 之间的奇数。'
- en: '`answer` is between 1 and 5 but not equal to 4.'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`answer` 介于 1 和 5 之间，但不等于 4。'
- en: '`answer` is between 1 and 100 and divisible by 3.'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`answer` 是介于 1 和 100 之间并且能被 3 整除的数。'
- en: '|'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Q:** | 9\. The *triangle inequality theorem* states that the sum of the
    lengths of any two sides of a triangle is greater than the length of the third
    side. Write a program that gets three numbers from the user and determines whether
    they could represent the sides of a triangle. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| **Q:** | 9\. *三角不等式定理*指出，三角形的任意两边之和大于第三边的长度。编写一个程序，从用户那里获取三个数字，并判断它们是否可以代表三角形的三边。
    |'
- en: '| **Q:** | 10\. The *Pythagorean theorem* states that if *a* and *b* are the
    lengths of the legs of a right triangle and *c* is the length of the hypotenuse
    (the longest side), then *a*² + *b*² = *c*². Write a program that gets three numbers
    from the user and determines whether they could represent the sides of a right
    triangle. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 10\. *毕达哥拉斯定理*指出，如果*a*和*b*是直角三角形的两条直角边，*c*是斜边的长度（最长的一边），那么*a*² +
    *b*² = *c*²。编写一个程序，获取用户输入的三个数字，并判断它们是否能够表示直角三角形的三条边。 |'
