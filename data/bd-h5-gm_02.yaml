- en: Chapter 1. Preparation and Setup
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。准备与设置
- en: In this chapter, we’ll begin to develop a full game using HTML, CSS, and JavaScript.
    Our simple bubble shooter game will demonstrate a range of development techniques,
    but it won’t need extensive logic to control the mechanics. *Game logic* includes
    systems for interaction between in-game elements, events that result from the
    player’s actions, simulation of artificial intelligence in characters, and so
    on. Developing intricate game logic can be time-consuming, so for learning purposes,
    we’ll stick with basic principles, such as how to render graphics and animation,
    respond to user input, and play sounds.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用HTML、CSS和JavaScript开发一款完整的游戏。我们简单的泡泡射手游戏将展示一系列的开发技巧，但它不需要复杂的逻辑来控制游戏机制。*游戏逻辑*包括游戏元素之间的交互系统、由玩家的动作引发的事件、角色中的人工智能模拟等。开发复杂的游戏逻辑可能会很耗时，因此为了学习目的，我们将坚持使用一些基本原则，比如如何渲染图形和动画、响应用户输入以及播放声音。
- en: We’ll start with the user interface and page layout, then load scripts, and
    finally add some basic interaction. During development, we’ll also explore some
    browser tools that will prove helpful (especially when debugging), as well as
    Modernizr and jQuery—two main libraries that will speed up development. We’ll
    use Modernizr to load scripts and detect whether a user’s browser supports a given
    feature, and we’ll use jQuery when working with HTML and JavaScript together.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从用户界面和页面布局开始，然后加载脚本，最后添加一些基本的交互。在开发过程中，我们还将探索一些浏览器工具，这些工具在调试时非常有用，以及Modernizr和jQuery——这两个主要的库将加速开发。我们将使用Modernizr来加载脚本并检测用户浏览器是否支持某个特性，而在处理HTML和JavaScript时，我们将使用jQuery。
- en: If you’re experienced in web application development using HTML, CSS, JavaScript,
    and jQuery, much of the code in this chapter will be familiar to you. My aim is
    to demonstrate what you can achieve with relatively little code and how easy it
    is to create basic interactive elements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用HTML、CSS、JavaScript和jQuery进行Web应用程序开发方面有经验，本章中的大部分代码你应该会很熟悉。我的目标是展示你如何通过相对少量的代码实现功能，以及如何轻松创建基本的交互元素。
- en: How the Game Is Played
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏玩法
- en: If you’ve ever played *Puzzle Bobble*, *Bust-a-Move*, *Snood*, or any of the
    many mobile bubble-shooting games, you already know the basic mechanics of a bubble
    shooter. [Figure 1-1](ch01.html#screenshot_of_the_finished_bubble_shoote "Figure 1-1. A
    screenshot of the finished Bubble Shooter game") shows a screenshot of the finished
    game.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经玩过*泡泡龙*、*Bust-a-Move*、*Snood*或任何其他许多移动泡泡射击游戏，你已经知道了泡泡射手的基本机制。[图 1-1](ch01.html#screenshot_of_the_finished_bubble_shoote
    "图 1-1. 完成的泡泡射手游戏截图")展示了完成后的游戏截图。
- en: '![A screenshot of the finished Bubble Shooter game](httpatomoreillycomsourcenostarchimages2184491.png.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![完成的泡泡射手游戏截图](httpatomoreillycomsourcenostarchimages2184491.png.jpg)'
- en: Figure 1-1. A screenshot of the finished *Bubble Shooter* game
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1。完成的*泡泡射手*游戏截图
- en: The goal of the game is to clear all of the bubbles hanging from the top of
    the screen. The player aims with the mouse and clicks to fire a bubble from the
    bottom of the screen into the bubbles at the top, in hopes of forming groups of
    three or more bubbles of the same color. Once a matching color group of at least
    three bubbles is formed, all of the bubbles in the group burst, as shown in [Figure 1-2](ch01.html#blue_bubble_is_fired_at_the_groupcomma_c
    "Figure 1-2. The blue bubble is fired at the group, creating a match, and all
    of the highlighted bubbles will pop.").
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的目标是清除屏幕顶部悬挂的所有泡泡。玩家通过鼠标瞄准并点击，从屏幕底部发射泡泡，射向顶部的泡泡，试图形成三颗或更多相同颜色的泡泡组合。一旦形成至少三个相同颜色的泡泡组合，组合中的所有泡泡都会爆炸，如[图
    1-2](ch01.html#blue_bubble_is_fired_at_the_groupcomma_c "图 1-2. 蓝色泡泡射向组合，形成匹配，所有高亮的泡泡都会爆炸。")所示。
- en: If a bubble is fired and doesn’t form a group that matches by color, it is added
    to the display, as shown in [Figure 1-3](ch01.html#blue_bubble_fired_here_wonapostrophet_ca
    "Figure 1-3. The blue bubble fired here won’t cause the green group above it to
    pop. Instead, it will be added to the board.").
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发射的泡泡没有形成颜色匹配的组合，它将被添加到显示中，如[图 1-3](ch01.html#blue_bubble_fired_here_wonapostrophet_ca
    "图 1-3. 这里发射的蓝色泡泡不会使上方的绿色组合爆炸。相反，它将被添加到游戏板中。")所示。
- en: '![The blue bubble is fired at the group, creating a match, and all of the highlighted
    bubbles will pop.](httpatomoreillycomsourcenostarchimages2184493.png.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![蓝色泡泡射向组合，形成匹配，所有高亮的泡泡都会爆炸。](httpatomoreillycomsourcenostarchimages2184493.png.jpg)'
- en: Figure 1-2. The blue bubble is fired at the group, creating a match, and all
    of the highlighted bubbles will pop.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2。蓝色泡泡被发射到该组，形成配对，所有高亮显示的泡泡将会爆炸。
- en: '![The blue bubble fired here won’t cause the green group above it to pop. Instead,
    it will be added to the board.](httpatomoreillycomsourcenostarchimages2184495.png.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![这里发射的蓝色泡泡不会导致上方的绿色组爆炸。相反，它会被添加到棋盘上。](httpatomoreillycomsourcenostarchimages2184495.png.jpg)'
- en: Figure 1-3. The blue bubble fired here won’t cause the green group above it
    to pop. Instead, it will be added to the board.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-3。这里发射的蓝色泡泡不会导致上方的绿色组爆炸。相反，它会被添加到棋盘上。
- en: Fired bubbles that don’t form a matching group of three or more stick in the
    bubble grid. Because bubbles behave as if they’re all hanging from the top row,
    if a set of bubbles can’t trace a connection back to the top after a matching
    color group is created and removed, we need to remove those “orphaned” bubbles
    from the screen. An example of an orphaned bubble is shown [Figure 1-4](ch01.html#red_bubble_is_orphaneddot_we_donapostrop
    "Figure 1-4. The red bubble is orphaned. We don’t want to leave orphaned bubbles
    hanging, so we’ll need some logic to detect them and an animation to remove them
    from the screen.").
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 发射出的泡泡如果没有形成三个或更多的匹配组，就会卡在泡泡网格中。因为泡泡就像是都悬挂在最上排一样，如果一组泡泡在创建并移除一个匹配颜色的组后，无法找到回到顶部的连接，我们需要从屏幕上移除这些“孤立”泡泡。[图1-4](ch01.html#red_bubble_is_orphaneddot_we_donapostrop
    "图1-4。红色泡泡被孤立。我们不想让孤立的泡泡悬挂，所以我们需要一些逻辑来检测它们，并用动画把它们从屏幕上移除。")中展示了一个孤立泡泡的例子。
- en: '![The red bubble is orphaned. We don’t want to leave orphaned bubbles hanging,
    so we’ll need some logic to detect them and an animation to remove them from the
    screen.](httpatomoreillycomsourcenostarchimages2184497.png.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![红色泡泡被孤立。我们不想让孤立的泡泡悬挂，所以我们需要一些逻辑来检测它们，并用动画把它们从屏幕上移除。](httpatomoreillycomsourcenostarchimages2184497.png.jpg)'
- en: Figure 1-4. The red bubble is orphaned. We don’t want to leave orphaned bubbles
    hanging, so we’ll need some logic to detect them and an animation to remove them
    from the screen.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-4。红色泡泡被孤立。我们不想让孤立的泡泡悬挂，所以我们需要一些逻辑来检测它们，并用动画把它们从屏幕上移除。
- en: Players can fire only a limited number of bubbles ([Figure 1-1](ch01.html#screenshot_of_the_finished_bubble_shoote
    "Figure 1-1. A screenshot of the finished Bubble Shooter game") shows 70), and
    they must clear the board before they run out of bubbles to shoot. At the end
    of each level, the player scores points for popping bubbles and progresses to
    the next level. The game ends when the player fails to clear a level.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家只能发射有限数量的泡泡（[图1-1](ch01.html#screenshot_of_the_finished_bubble_shoote "图1-1。完成的Bubble
    Shooter游戏截图")显示为70个），他们必须在泡泡用完之前清除棋盘。每个关卡结束时，玩家根据爆破泡泡的数量得分，并进入下一关。游戏在玩家未能清除关卡时结束。
- en: Short of a couple of enhancements that we’ll add later, that’s the main flow
    of the game.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了稍后我们将添加的几个增强功能外，这就是游戏的主要流程。
- en: We’ll build the game mechanics using HTML, CSS, and JavaScript—core tools that
    are well suited to creating many simple games, especially two-dimensional games
    that don’t require detailed pixel manipulation. In *Bubble Shooter*, we’re essentially
    firing a circle (the bubble) into a grid of other circles (bubbles) and then either
    popping a group, as in [Figure 1-2](ch01.html#blue_bubble_is_fired_at_the_groupcomma_c
    "Figure 1-2. The blue bubble is fired at the group, creating a match, and all
    of the highlighted bubbles will pop."), or adding the bubble to the board, as
    in [Figure 1-3](ch01.html#blue_bubble_fired_here_wonapostrophet_ca "Figure 1-3. The
    blue bubble fired here won’t cause the green group above it to pop. Instead, it
    will be added to the board."). The demands of the game’s layout are fairly simple,
    and we can use CSS and JavaScript to perform all of the animation we’ll need.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用HTML、CSS和JavaScript构建游戏机制——这些是创建许多简单游戏的核心工具，尤其是那些不需要精细像素操作的二维游戏。在*Bubble
    Shooter*中，我们实际上是在把一个圆形（泡泡）发射到另一个圆形的网格中（其他泡泡），然后要么像[图1-2](ch01.html#blue_bubble_is_fired_at_the_groupcomma_c
    "图1-2。蓝色泡泡被发射到该组，形成配对，所有高亮显示的泡泡将会爆炸。")那样爆炸一个组，要么像[图1-3](ch01.html#blue_bubble_fired_here_wonapostrophet_ca
    "图1-3。这里发射的蓝色泡泡不会导致上方的绿色组爆炸。相反，它会被添加到棋盘上。")那样把泡泡添加到棋盘上。游戏布局的要求相当简单，我们可以使用CSS和JavaScript来执行所有需要的动画。
- en: We’ll build the user interface in HTML and CSS because like most HTML games,
    *Bubble Shooter* will take advantage of the tasks the browser can do well, such
    as laying out text and rendering simple graphics. In later chapters, we’ll explore
    using the `canvas` element to display the game area, but I’ll first demonstrate
    what you can achieve with regular Document Object Model (DOM)–based development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用HTML和CSS构建用户界面，因为像大多数HTML游戏一样，*气泡射手*将利用浏览器擅长的任务，例如布局文本和渲染简单图形。在后续章节中，我们将探索使用`canvas`元素来显示游戏区域，但我首先会演示使用常规文档对象模型（DOM）开发所能实现的效果。
- en: Building the Game
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建游戏
- en: 'Now that we have an idea of the game we want to create, let’s break it down
    into manageable tasks. We’ll need to solve a number of high-level challenges to
    create *Bubble Shooter*. Specifically, we need to do the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了要创建的游戏概念，让我们将其分解为可管理的任务。为了创建*气泡射手*，我们需要解决一些高级挑战。具体来说，我们需要完成以下任务：
- en: '**Randomize and render the game board**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机生成并渲染游戏棋盘**'
- en: The bubble grid must be randomly generated and drawn onscreen for each new level.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新关卡必须随机生成气泡网格并在屏幕上绘制出来。
- en: '**Calculate the firing angle and stopping point for a bubble**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算气泡的发射角度和停止点**'
- en: The player will fire bubbles by clicking on the screen. We’ll calculate the
    angle at which to fire the bubble, move it along that path, and either stop it
    when it hits something or let it continue.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家将通过点击屏幕发射气泡。我们将计算发射气泡的角度，沿着该路径移动气泡，并在它碰到某个物体时停止，或者让它继续前进。
- en: '**Resolve collisions**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决碰撞问题**'
- en: When the fired bubble hits another bubble and does not form a matching group
    of three or more, it will add itself to the board. Otherwise, when it does form
    a group of at least three bubbles of the same color, it will pop all bubbles of
    that color contiguous with the one it strikes. If the fired bubble does pop bubbles,
    we’ll check to see if we’ve created any orphaned bubbles, such as those shown
    in [Figure 1-4](ch01.html#red_bubble_is_orphaneddot_we_donapostrop "Figure 1-4. The
    red bubble is orphaned. We don’t want to leave orphaned bubbles hanging, so we’ll
    need some logic to detect them and an animation to remove them from the screen.").
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当发射的气泡击中另一个气泡且未形成至少三个相同颜色的组合时，它将加入到棋盘上。否则，当它形成至少三个相同颜色气泡的组合时，它将炸裂所有与其接触的相同颜色气泡。如果发射的气泡确实爆炸了气泡，我们将检查是否产生了孤立的气泡，例如在[图1-4](ch01.html#red_bubble_is_orphaneddot_we_donapostrop
    "图1-4：红色气泡是孤立的。我们不希望留下孤立气泡，所以我们需要一些逻辑来检测它们，并通过动画将它们从屏幕上移除。")中所示的那样。
- en: '**Keep track of score and levels**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**跟踪得分和关卡**'
- en: The game ends when all the bubbles are cleared. Because the player has only
    a limited number of bubbles to fire, we’ll track the number of bubbles fired.
    We’ll also add a scoring system to give the player a reason to play again (to
    beat a high score, for example).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏在所有气泡被清除时结束。由于玩家只有有限数量的气泡可以发射，我们会跟踪已发射的气泡数量。我们还将添加一个得分系统，给玩家一个再次挑战的理由（例如打破高分）。
- en: '**Handle the game’s end and new levels**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理游戏结束和新关卡**'
- en: If a player completes a level, we’ll indicate that (using certain interface
    elements) and give the player an option to progress to the next level. Changing
    levels clears the board and tidies up the internal game state, and then the game
    starts again.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家完成关卡，我们将通过某些界面元素标示出来，并给玩家一个选项继续进入下一关卡。切换关卡会清空棋盘并整理内部游戏状态，然后游戏重新开始。
- en: Development and Testing Environment
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发和测试环境
- en: Let’s set up our development environment and make sure we have the right tools
    to complete the game. To start developing games for the Web, you’ll need access
    to a range of browsers to test in and software that allows you to edit code. You’ll
    also need to set up a web server to view the game in development. Although you
    can run *Bubble Shooter* locally (simply by opening its *index.html* file), you
    should regularly test your games in situations that match those of your end users
    as closely as possible.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置开发环境，确保我们拥有完成游戏所需的正确工具。要开始为Web开发游戏，你需要访问多个浏览器进行测试，并且需要可以编辑代码的软件。你还需要设置一个Web服务器以查看正在开发中的游戏。尽管你可以在本地运行*气泡射手*（只需打开其*index.html*文件），但你应该定期在尽可能模拟最终用户使用情况的环境中测试你的游戏。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The process of setting up a server varies by operating system. The Apache
    web server (available at* [http://httpd.apache.org/](http://httpd.apache.org/)*)
    has good installation packages and instructions for setting up on most system
    configurations.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*设置服务器的过程因操作系统而异。Apache Web服务器（可在*[http://httpd.apache.org/](http://httpd.apache.org/)*下载）提供了良好的安装包和设置说明，适用于大多数系统配置。*'
- en: Web Browser Testing
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网页浏览器测试
- en: One rule of web development is to test on all browsers that you expect your
    target audience to use. Although this is essential for released software, while
    developing you can usually use a slightly smaller subset of browsers to identify
    most potential problems. The list of browsers you need to test on changes constantly,
    but when you release a game onto the Web, those discussed next are essential.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 网络开发的一个规则是要在你预期的目标用户会使用的所有浏览器上进行测试。尽管这是发布软件时必不可少的步骤，但在开发过程中，你通常可以使用较小的浏览器子集来识别大部分潜在问题。你需要测试的浏览器列表在不断变化，但当你将游戏发布到Web时，接下来讨论的这些浏览器是必不可少的。
- en: Desktop Browsers
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 桌面浏览器
- en: Users of a desktop PC or laptop could end up playing your game in various browsers
    on any operating system, so be sure to test at least the latest versions of Internet
    Explorer (IE), Firefox, Chrome, and Safari for Windows and OS X. Depending on
    your target audience, you may need to test earlier browser versions as well.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用桌面PC或笔记本电脑的用户可能会在任何操作系统上使用不同的浏览器玩你的游戏，因此请确保至少在Windows和OS X上的最新版本的Internet
    Explorer（IE）、Firefox、Chrome和Safari中进行测试。根据你的目标用户群，你可能还需要测试早期版本的浏览器。
- en: Not everyone updates their web browsers, so when coding for a mass web audience,
    be sure not to ignore users who might be using earlier versions. Some versions
    of IE do not play well together on the same operating system (due to IE’s tight
    integration with Windows), so when testing, you’ll need multiple Windows installations
    available, either on different PCs or on virtual machines. I strongly suggest
    you install and use virtual machine software, such as VMWare (*[http://www.vmware.com/](http://www.vmware.com/)*),
    VirtualBox (*[http://www.virtualbox.org/](http://www.virtualbox.org/)*), or Virtual
    PC (*[http://www.microsoft.com/download/](http://www.microsoft.com/download/)*;
    search in the Download Center). Virtual machines allow you to run operating systems
    within your regular operating system, essentially simulating an entire system
    from your desktop. Virtual machines preinstalled with different versions of IE
    can be downloaded from *[http://www.modern.ie/en-us/virtualization-tools/](http://www.modern.ie/en-us/virtualization-tools/)*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是每个人都会更新他们的网页浏览器，因此在为大量网页用户进行编码时，务必不要忽视可能使用早期版本的用户。一些版本的IE在同一操作系统中可能无法良好配合（由于IE与Windows的紧密集成），因此在进行测试时，你需要多个Windows安装环境，可以在不同的PC或虚拟机上进行。我强烈建议你安装并使用虚拟机软件，如VMWare（*[http://www.vmware.com/](http://www.vmware.com/)*）、VirtualBox（*[http://www.virtualbox.org/](http://www.virtualbox.org/)*）或Virtual
    PC（*[http://www.microsoft.com/download/](http://www.microsoft.com/download/)*；请在下载中心搜索）。虚拟机可以让你在常规操作系统内运行其他操作系统，实质上是在桌面上模拟一个完整的系统。预装了不同版本IE的虚拟机可以从*[http://www.modern.ie/en-us/virtualization-tools/](http://www.modern.ie/en-us/virtualization-tools/)*下载。
- en: Because Firefox now updates regularly, you should be able to safely test your
    games on the latest release. Earlier versions have patchy HTML5 support, but later
    versions rarely have major changes from one release to the next. Chrome updates
    automatically and regularly as well, so you don’t need to worry about versions;
    just make sure you’re running the latest one.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Firefox现在会定期更新，所以你应该能够安全地在最新版本上测试你的游戏。早期版本对HTML5的支持不稳定，但后续版本通常不会有大的变化。Chrome也会自动并定期更新，因此你不必担心版本问题，只需确保你使用的是最新版本。
- en: And, of course, you should also test your game on a Mac in at least one version
    of Safari. It’s also possible to run an OS X virtual machine within Windows, although
    the setup is slightly more complex than running Windows within Windows or Windows
    within OS X. Tutorials are available online for achieving this setup within the
    virtual machine applications listed earlier.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你还应该在Mac上至少测试一个版本的Safari浏览器。也可以在Windows中运行OS X虚拟机，尽管这种设置比在Windows内运行Windows或在OS
    X中运行Windows稍微复杂一些。有关在虚拟机应用程序中实现此设置的教程，可以在线找到。
- en: Mobile Browsers
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动浏览器
- en: If you’re deploying on mobile devices or tablets, testing on a wide range of
    devices (iOS, Android, and Windows mobile) and multiple browsers is more important
    than ever. For basic mobile development, access to one iOS device and one Android
    device may be sufficient for testing, but when you’re considering wider distribution,
    the plot thickens. Apple’s iOS versions vary in their behavior, and Android comes
    in so many flavors on so many devices with differing screen resolutions and hardware
    configurations that you should have access to multiple devices (perhaps through
    a limited beta testing group) for testing. We won’t be packaging *Bubble Shooter*
    for release in the Apple App Store or Google Play Store, but by virtue of writing
    the game using HTML5 and JavaScript, we’ll produce an app that’s playable on mobile
    devices without extra coding.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在移动设备或平板电脑上部署，测试范围广泛的设备（iOS、Android 和 Windows 移动设备）和多个浏览器比以往任何时候都更加重要。对于基本的移动开发，访问一台
    iOS 设备和一台 Android 设备可能足够进行测试，但当你考虑到更广泛的发布时，情况变得更加复杂。苹果的 iOS 版本在行为上有所不同，而 Android
    在如此多的设备上有着不同的屏幕分辨率和硬件配置，你应该能够访问多个设备（可能通过有限的 beta 测试小组）进行测试。我们不会将 *Bubble Shooter*
    打包发布到 Apple App Store 或 Google Play Store，但通过使用 HTML5 和 JavaScript 编写游戏，我们将制作一个可以在移动设备上玩的应用，无需额外的编码。
- en: Ultimately, due to the fragmentation of the Android platform, it’s impossible
    for a single developer to test on every device; therefore, you may find it more
    viable to use a third-party testing service. Testing on iOS devices is slightly
    simpler because Apple controls its operating system and device specifications,
    but iPhones and iPads can be costly. When you add Windows tablets into the mix
    and consider the growing range of tablets and other portable devices that can
    run a web browser, you’ll realize that the mobile testing battle is difficult
    to win.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，由于 Android 平台的碎片化，单个开发者无法在每个设备上进行测试；因此，你可能会发现使用第三方测试服务更加可行。在 iOS 设备上的测试稍微简单一些，因为
    Apple 控制其操作系统和设备规格，但 iPhone 和 iPad 的价格可能较高。当你将 Windows 平板电脑纳入考虑范围，并考虑到可以运行网页浏览器的平板电脑和其他便携设备的日益增加时，你会意识到，移动测试之战是难以取胜的。
- en: Debugging in the Web Browser
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在网页浏览器中调试
- en: With your test browsers set up, you can then use several developer tools to
    make debugging easy. Each browser has its own development tool set, but fortunately,
    they all operate along similar lines, provide ways to inspect HTML elements on
    the page, and add breakpoints and logging to JavaScript. Learn how to access your
    browser’s developer tools and experiment with them to become familiar with their
    capabilities.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好测试浏览器后，你可以使用多个开发者工具来简化调试。每个浏览器都有自己的开发工具集，但幸运的是，它们都遵循类似的工作方式，提供检查页面 HTML 元素、添加断点和日志记录
    JavaScript 的方法。学习如何访问你浏览器的开发者工具，并通过实验熟悉其功能。
- en: 'All browser debugging tools are useful, but you’ll likely use the JavaScript
    console the most during development. You’ll interact with your code through the
    console in two main ways:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有浏览器调试工具都很有用，但在开发过程中，你可能最常使用 JavaScript 控制台。你将通过控制台与代码进行两种主要的互动：
- en: '**Logging to the console with the `console.log` command**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 `console.log` 命令记录到控制台**'
- en: Call the **`console.log`** function, and the console should display the contents
    of whatever you pass into the function. For example, `console.log("Hello")` should
    display the string `Hello`. Even better, call `console.log` with a JavaScript
    object or array, and you’ll get a limited listing of the object’s contents that
    you can use to explore entire object trees.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 **`console.log`** 函数，控制台应显示你传递给该函数的内容。例如，`console.log("Hello")` 应该显示字符串 `Hello`。更好的是，当你使用
    JavaScript 对象或数组调用 `console.log` 时，你会得到该对象内容的简要列出，可以用来探索整个对象树。
- en: '**Running ad hoc code to interrogate variable states**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行临时代码以检查变量状态**'
- en: You can enter JavaScript code into the console to evaluate it immediately. Enter
    **`alert(1)`** into the console to see how it works. If your game code exposes
    object properties publicly, you can use this feature to examine properties or
    trigger methods. You can even paste in multiple lines of code to create and run
    entire functions in the context of the page.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 JavaScript 代码输入到控制台中立即评估。输入 **`alert(1)`** 到控制台看看它如何工作。如果你的游戏代码公开暴露了对象属性，你可以利用此功能检查属性或触发方法。你甚至可以粘贴多行代码，以创建并在页面上下文中运行整个函数。
- en: Now that we have some of the tools we need, let’s start building the game. We’ll
    begin by setting up the basic code and implementing the start screen user interface.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了一些工具，让我们开始构建游戏。我们将从设置基本代码并实现开始界面用户界面开始。
- en: Laying Out the Game Screen
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局游戏屏幕
- en: Before we can program the fun parts of animation and gameplay, we need to lay
    out the user interface. We’ll use HTML and CSS to place the main interface elements;
    the game screen will consist of three major areas, shown in [Figure 1-5](ch01.html#sections_of_the_game_screen
    "Figure 1-5. Sections of the game screen").
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写动画和游戏玩法的有趣部分之前，首先需要布局用户界面。我们将使用HTML和CSS来放置主要的界面元素；游戏屏幕将包含三个主要区域，如[图1-5](ch01.html#sections_of_the_game_screen
    "图1-5. 游戏屏幕的各个部分")所示。
- en: '![Sections of the game screen](httpatomoreillycomsourcenostarchimages2184499.png.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![游戏屏幕的各个部分](httpatomoreillycomsourcenostarchimages2184499.png.jpg)'
- en: Figure 1-5. Sections of the game screen
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-5. 游戏屏幕的各个部分
- en: At the top of the game screen, you can see the status bar ➊, which will show
    score and level information. The next (and largest) section contains the game
    area ➋, which will contain all the bubbles. The game area is also where the actual
    gameplay will happen. The footer ➌ at the bottom of the game screen frames the
    game area.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏屏幕的顶部，您可以看到状态栏 ➊，它将显示分数和关卡信息。接下来的部分（也是最大的部分）包含游戏区域 ➋，这里将包含所有气泡。游戏区域也是实际游戏玩法发生的地方。底部的页脚
    ➌ 框架环绕着游戏区域。
- en: Now, let’s lay out these three *Bubble Shooter* components.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们布局这三个*Bubble Shooter*组件。
- en: Creating Panels with HTML and CSS
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTML和CSS创建面板
- en: Using straightforward HTML and CSS to lay out the game screen is the easiest
    way to create the three panels and define where the action happens. The approach
    and techniques used here are identical to those used in building a regular website
    or web application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的HTML和CSS来布局游戏屏幕是创建这三个面板并定义游戏发生位置的最简单方法。这里使用的方法和技巧与构建常规网站或Web应用程序时使用的是一样的。
- en: 'We’ll start by creating a wrapper `div` for the entire page. Because the `div`
    tag has no semantic meaning, we’ll use it to denote a division on the page. Make
    a new folder in your web server’s root directory to build the game in and call
    it *bubbleshoot*. Every file needed to run the game will be stored in this folder
    or within a subdirectory of it. Next, create a new file called *index.html* and
    add the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为整个页面创建一个包装`div`。由于`div`标签没有语义意义，我们将其用作页面上的一个分区。首先，在您的Web服务器根目录下创建一个新的文件夹，用于构建游戏，并命名为*bubbleshoot*。游戏运行所需的每个文件都将存储在这个文件夹或其子目录中。接下来，创建一个名为*index.html*的新文件，并添加以下代码：
- en: '*index.html*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.html*'
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The entire game will run within this single HTML page, and the `"page" div`
    ➊ will constrain the area in which the game happens. If we ever need to center
    the game or move it to fit into unusual screen aspect ratios, we need only change
    the position of the wrapper element.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 整个游戏将在这个单一的HTML页面中运行，`"page" div` ➊将限制游戏发生的区域。如果我们需要将游戏居中或调整它以适应不规则的屏幕纵横比，只需要改变包装元素的位置。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Many HTML tags have been simplified in version 5, in contrast to the relative
    strictness in versions 3 to 4 and XHTML. For example, the doctype declaration
    is now vastly simplified because many tags are assigned a default type. The `<script>`
    tag actually defaults to JavaScript in HTML5, which is why we don’t need to specify
    `type="text/javascript"` or `language="javascript"` in our page.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多HTML标签在HTML5中已简化，相较于版本3到4和XHTML的严格性。例如，文档类型声明现在大大简化，因为许多标签都已分配默认类型。`<script>`标签实际上在HTML5中默认就是JavaScript，这就是为什么我们在页面中不需要指定`type="text/javascript"`或`language="javascript"`的原因。*'
- en: 'Next, we’ll create three new `div` elements, one for each of the three page
    sections, and place them inside our page `div`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建三个新的`div`元素，每个元素对应一个页面部分，并将它们放置在我们的页面`div`内：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we need to assign some CSS to our page and the three sections we just added.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为页面和刚才添加的三个部分分配一些CSS。
- en: 'Create a folder called *_css* in the game folder to contain all the style sheets
    we’ll use for the game. In the *_css* folder, make a new file called *main.css*
    that contains the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏文件夹中创建一个名为* _css *的文件夹，用于存放我们将用于游戏的所有样式表。在*_css*文件夹中，创建一个名为*main.css*的新文件，并包含以下代码：
- en: '*main.css*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.css*'
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’ll make the top banner 70 pixels high ➋ and the bottom one 48 pixels high
    ➎. We want the game to fit in a standard monitor size, so we set the total game
    area to be 620 pixels high ➌, resulting in a total page height of 738 pixels ➊,
    which should fit within a 1024×768 display and even allow for a browser taskbar.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将顶部横幅的高度设置为70像素 ➋，底部横幅的高度设置为48像素 ➎。我们希望游戏适配标准显示器尺寸，因此我们将整个游戏区域的高度设置为620像素
    ➌，使得总页面高度为738像素 ➊，这应该适配1024×768的显示分辨率，甚至还能容纳浏览器任务栏。
- en: 'Dimensions: Fluid vs. Fixed'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尺寸：流式布局 vs. 固定布局
- en: To keep the game simple, I used a fixed width of 1000 pixels in the CSS, which
    should provide a large screen area that fits within the majority of desktop and
    mobile displays. Typically, the screen dimension situation is more complex; mobile
    devices in particular have a wide range of pixel dimensions and aspect ratios.
    However, we want to concentrate on development principles rather than design decisions,
    and 1000 pixels should work well for a prototype game.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持游戏简单，我在CSS中使用了1000像素的固定宽度，这应该为大多数桌面和移动显示器提供足够的屏幕区域。通常，屏幕尺寸的情况更为复杂；尤其是移动设备的像素尺寸和长宽比有很大的差异。然而，我们希望专注于开发原则，而不是设计决策，1000像素应该足够用于原型游戏。
- en: These values set the size and position of the entire usable display area. Also,
    notice that `game` has `overflow:` set to `hidden` ➍, which means that the bubbles
    in the game will never accidentally display over the header or footer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值设置了整个可用显示区域的大小和位置。此外，请注意，`game`的`overflow:`设置为`hidden` ➍，这意味着游戏中的泡泡永远不会意外地显示在页眉或页脚上。
- en: 'To link up the CSS file, we’ll add a file link for *main.css* to the HTML header:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了链接CSS文件，我们将在HTML头部添加*main.css*的文件链接：
- en: '*index.html*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.html*'
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we’ve created the basic structure for *Bubble Shooter* with HTML and
    CSS, load the page in a browser and keep it open. There’s no interaction yet,
    so next we’ll add basic interactivity, such as a *start game* dialog, before we
    work on the game logic. The first step is to set up the coding structure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用HTML和CSS创建了*泡泡射手*的基本结构，接下来在浏览器中加载页面并保持打开状态。此时尚未有交互，因此接下来我们将添加基本的交互功能，比如*开始游戏*对话框，然后再处理游戏逻辑。第一步是设置代码结构。
- en: Code Structure
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码结构
- en: 'Let’s take a high-level look at the main concepts of the game and interface,
    which will guide how we’ll structure the code. With a number of significant elements
    to implement, we’ll structure the code in a way similar to the Model/View/Controller
    (MVC) principles that you may be familiar with from web application development.
    If MVC is new to you, here’s the basic setup:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从高层次了解一下游戏和界面的主要概念，这将指导我们如何结构化代码。由于需要实现多个重要元素，我们将以类似于你可能熟悉的Model/View/Controller（MVC）原则的方式结构化代码。如果MVC对你来说是新的，这里是基本的设置：
- en: The **Model** consists of data and maintains the state of the application. In
    a web application, this might be user’s details or shopping cart contents, for
    example.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**由数据组成，并维护应用程序的状态。在Web应用程序中，这可能是用户的详细信息或购物车内容等。'
- en: The **View** renders what’s on the screen and intercepts user input. For web
    applications, this is generally HTML output. For example, a view might read the
    contents of an online shopping cart from the *Model* and then display those items
    in a list.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**负责渲染屏幕上的内容并拦截用户输入。对于Web应用程序，这通常是HTML输出。例如，视图可能会从*模型*中读取在线购物车的内容，并将这些项目以列表的形式显示出来。'
- en: The **Controller** manages the logic and processing. For example, clicking an
    item in a *View* sends a message to the *Controller* to add a new item to a shopping
    cart *Model*.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**管理逻辑和处理。例如，点击*视图*中的某个项目时，会向*控制器*发送消息，要求其向购物车*模型*中添加新项目。'
- en: With some alterations, this MVC principle will work for structuring *Bubble
    Shooter*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些修改，这个MVC原则将适用于结构化*泡泡射手*。
- en: Game Controller
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏控制器
- en: The game controller will keep track of the game state and act as a director
    to determine outcomes in response to user actions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏控制器将跟踪游戏状态，并充当导演，响应用户操作并确定结果。
- en: The game controller is similar to a controller in the MVC system; it will run
    the game and manage all the functions. In a more complex game, a single controller
    would become too big and complicated to handle every task, because there would
    be too much code in one place and one set of code would have too many responsibilities,
    making the code more prone to bugs that would be harder to find. In that case,
    we’d probably need to subdivide the tasks further. Fortunately, because *Bubble
    Shooter* is so simple, using one controller to manage all tasks should work well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏控制器类似于 MVC 系统中的控制器；它将运行游戏并管理所有功能。在一个更复杂的游戏中，单一控制器会变得过于庞大和复杂，无法处理所有任务，因为代码会集中在一个地方，并且一组代码会有太多责任，导致代码更容易出现难以发现的
    bug。在这种情况下，我们可能需要进一步细分任务。幸运的是，*Bubble Shooter* 游戏非常简单，使用一个控制器来管理所有任务应该是可行的。
- en: User Interface Code
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户界面代码
- en: The game needs to display all kinds of information for the user, including score
    updates, level end screens, and so on. Instead of the game controller handling
    these tasks, it will instruct a set of user interface functions to control the
    way the user interface elements appear and disappear.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏需要为用户展示各种信息，包括得分更新、关卡结束画面等。游戏控制器不会处理这些任务，而是会指示一组用户界面函数来控制用户界面元素的显示和消失方式。
- en: You could put much of the UI code into the game controller, but you’ll often
    end up writing as much animation and UI code as game logic, so it’s best to separate
    the code for readability. Generally, if you’re not changing the state of the game
    in some way but instead are managing a function in the display, you should do
    that in the UI code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将大部分 UI 代码放入游戏控制器中，但你往往会写出与游戏逻辑一样多的动画和 UI 代码，因此最好将这些代码分开以提高可读性。通常，如果你没有以某种方式改变游戏的状态，而是管理显示中的某个功能，你应该在
    UI 代码中处理这些任务。
- en: Game Elements as Objects
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏元素作为对象
- en: We’ll code a few game elements as objects, including the bubbles and the game
    board. The reason is that we’ll have properties—*x*- and *y*-coordinates for the
    bubbles, for example—and methods to apply, such as bubbles popping. Following
    object-oriented programming convention, we’ll split those objects into separate
    classes so the code structure maps to the conceptual elements involved in making
    the game.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把一些游戏元素编写为对象，包括气泡和游戏板。原因是我们将有一些属性——例如气泡的 *x* 和 *y* 坐标——以及需要应用的方法，例如气泡爆炸。按照面向对象编程的惯例，我们会将这些对象拆分成不同的类，以便代码结构与制作游戏所涉及的概念元素相对应。
- en: The game’s objects will also align closely with the idea of a model in the MVC
    web pattern. Objects will have properties and state, but they really shouldn’t
    interact with the display or make significant gameplay decisions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的对象将与 MVC 网络模式中的模型概念紧密对齐。对象将具有属性和状态，但它们不应该与显示界面交互或做出重要的游戏决策。
- en: Adding the First Scripts
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加第一个脚本
- en: We’ll use *Modernizr*, a JavaScript library, to load in all of the JavaScript
    files the game will need, such as the game controller and the UI class mentioned
    earlier. Using Modernizr has some advantages over using conventional `<script>`
    tags, and I’ll explain those later in this chapter. Modernizr has other useful
    features as well, but we’ll start by loading in the script files we need.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用*Modernizr*，一个 JavaScript 库，来加载游戏所需的所有 JavaScript 文件，例如前面提到的游戏控制器和 UI 类。使用
    Modernizr 相较于使用常规的 `<script>` 标签有一些优势，我将在本章稍后解释这些优势。Modernizr 还有其他有用的功能，但我们将首先加载所需的脚本文件。
- en: The Modernizr and jQuery Libraries
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Modernizr 和 jQuery 库
- en: To short-cut some common tasks throughout the development of the game, we’ll
    rely heavily on two libraries. Both libraries solve many cross-browser problems
    and provide high-level functions in a simple and consistent instruction set.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在游戏开发过程中简化一些常见任务，我们将大量依赖两个库。这两个库解决了许多跨浏览器问题，并提供了一套简单且一致的高级功能。
- en: 'Modernizr will load scripts and detect whether a given feature is available
    in a browser. As an example, let’s write some code to detect whether the `canvas`
    element is supported. To code this by hand, you would create a `canvas` node within
    the DOM and then check whether or not it supports a given method. In this example,
    we’ll use the `canvas` element’s `getContext` method, which is supported everywhere
    that `canvas` is supported, although you could try any `canvas` method you like:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Modernizr 会加载脚本并检测浏览器中是否支持某个特定功能。例如，我们可以写一段代码来检测是否支持 `canvas` 元素。手动编码的话，你需要在
    DOM 中创建一个 `canvas` 节点，然后检查它是否支持某个特定方法。在这个例子中，我们将使用 `canvas` 元素的 `getContext` 方法，它在所有支持
    `canvas` 的地方都有支持，尽管你可以尝试任何你喜欢的 `canvas` 方法：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With Modernizr, we don’t have to do as much work. We can simply write:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Modernizr，我们不需要做太多工作。我们可以简单地写：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Modernizr object contains a set of properties whose values are set at load
    time to either `true` or `false`, depending on whether a particular feature is
    supported or not by the browser. As such, the variable `canvasSupported` should
    now contain either `true` or `false`, depending on the value of `Modernizr.canvas`.
    Using Modernizr to check for features is helpful because if a browser changes
    how it implements a feature, Modernizr will likely receive new detection routines
    faster than you can detect and implement the change within your codebase.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Modernizr 对象包含一组属性，这些属性的值在加载时被设置为 `true` 或 `false`，具体取决于浏览器是否支持某个特定功能。因此，变量
    `canvasSupported` 现在应该包含 `true` 或 `false`，取决于 `Modernizr.canvas` 的值。使用 Modernizr
    检测功能非常有帮助，因为如果浏览器改变了某个功能的实现方式，Modernizr 很可能会比你在代码中检测并实现更快地收到新的检测例程。
- en: jQuery also provides useful shorthand functions, but these largely involve detecting
    and responding to events, making Asynchronous JavaScript and XML (AJAX) requests
    to communicate with a server or accessing and manipulating HTML elements in the
    browser’s DOM.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 还提供了有用的简写函数，但这些主要涉及检测和响应事件，发起异步 JavaScript 和 XML (AJAX) 请求与服务器通信，或者访问并操作浏览器
    DOM 中的 HTML 元素。
- en: The DOM is the browser’s internal organization of an HTML document, and we’ll
    primarily use jQuery’s DOM access methods to simplify much of the animation code.
    The DOM provides a way for you to manipulate the structure of the HTML by exposing
    each element in the HTML as a DOM node. To manipulate the DOM, we first use JavaScript
    to select a node. We can then change one or more of its properties, which is possible
    and relatively straightforward with regular JavaScript. But using jQuery makes
    the code more likely to work as intended without writing code to handle browsers
    that implement individual features differently.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 是浏览器对 HTML 文档的内部组织结构，我们将主要使用 jQuery 的 DOM 访问方法来简化大部分动画代码。DOM 提供了一种方法，让你能够通过将
    HTML 中的每个元素暴露为 DOM 节点来操作 HTML 结构。为了操作 DOM，我们首先使用 JavaScript 选择一个节点。然后我们可以改变它的一个或多个属性，常规的
    JavaScript 使得这一步骤变得简单且直观。但是，使用 jQuery 可以使代码更容易按预期工作，而无需编写代码来处理那些实现各自功能不同的浏览器。
- en: The most trivial example of jQuery in action is selecting a DOM node with an
    ID, such as the `game div` we’ve created. In conventional JavaScript, we would
    write this as
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 最简单的应用例子是选择一个具有 ID 的 DOM 节点，比如我们创建的 `game div`。在常规 JavaScript 中，我们会这样写：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This line of code retrieves a single DOM element, which will have various properties,
    such as its CSS formatting and methods that allow it to be interrogated. For example,
    `element.getAttribute("id")` will return the string `game`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码获取一个单一的 DOM 元素，它将拥有各种属性，例如 CSS 格式和允许进行查询的方法。例如，`element.getAttribute("id")`
    将返回字符串 `game`。
- en: jQuery provides a way to wrap this functionality, and more, in a simpler, more
    compact syntax. To achieve the same result as the preceding code line with jQuery,
    we use jQuery selectors. *Selectors* are syntax for selecting a node or nodes
    within the DOM, and their format—including dot notation and using `#` to select
    unique elements—is borrowed from CSS selectors. The values returned from jQuery’s
    selectors aren’t DOM nodes but rather custom objects that contain a reference
    to the DOM nodes and add a range of other methods. The equivalent of `document.getElementById("game").getAttribute("id")`
    using a jQuery selector is `$("#game").attr("id")`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 提供了一种方法，将这些功能及更多的功能封装在更简洁、更紧凑的语法中。为了用 jQuery 实现与前面代码相同的结果，我们使用 jQuery
    选择器。*选择器*是用于选择 DOM 中节点的语法，其格式——包括点符号和使用 `#` 来选择唯一元素——借鉴了 CSS 选择器。jQuery 选择器返回的值不是
    DOM 节点，而是包含对 DOM 节点引用的自定义对象，并且附带了一系列其他方法。使用 jQuery 选择器实现 `document.getElementById("game").getAttribute("id")`
    的等效写法是 `$("#game").attr("id")`。
- en: 'Selectors are a core jQuery concept, and you’ll become very familiar with using
    them by the end of this book. Nearly all of jQuery is used to manipulate DOM elements,
    so calls to jQuery almost always specify which element or elements should be changed,
    and that’s where selectors come in. They let you choose an HTML node set using
    a range of factors, such as the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器是 jQuery 的核心概念，到本书结束时，你会非常熟悉如何使用它们。几乎所有的 jQuery 都是用来操作 DOM 元素的，因此 jQuery
    的调用几乎总是指定要更改的元素或元素集，这就是选择器的作用。它们让你能够根据一系列因素选择 HTML 节点集，例如以下几种：
- en: A unique ID for selecting single elements
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于选择单个元素的唯一 ID。
- en: A CSS class for selecting all the DOM elements with that class
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 CSS 类，用于选择所有具有该类的 DOM 元素。
- en: The tag that defines the node (`div`, `img`, `span`, and so on), which allows
    you, for example, to select all the images on a page
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义节点的标签（如 `div`、`img`、`span` 等），这可以让你例如选择页面上的所有图片。
- en: Many other options, including combinations of the previous items in this list,
    the element’s position in a list, parent-child relationships, or nearly any other
    way you can traverse a DOM
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多其他选项，包括前面列表中项的组合、元素在列表中的位置、父子关系，或者几乎任何你能用来遍历 DOM 的方式。
- en: The jQuery object that the call to `$` returns lets you manipulate the DOM object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `$` 返回的 jQuery 对象允许你操作 DOM 对象。
- en: So in jQuery, the `document.getElementById` call is shortened to
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 jQuery 中，`document.getElementById` 被简化为
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We require the `.get(0)` function call to retrieve the DOM object from within
    the jQuery object, although generally it’s more useful to work with jQuery objects
    than with DOM objects directly. This can be further shortened to
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调用 `.get(0)` 函数，从 jQuery 对象中获取 DOM 对象，尽管通常来说，操作 jQuery 对象比直接操作 DOM 对象更有用。这个调用可以进一步简化为
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The value `$` is defined as an alias to the `jQuery` function, which does one
    of several tasks based on what you pass into it. For a selector, we pass a string
    value (in this case, `"#game"`) to jQuery. As in CSS, the hash symbol tells jQuery
    that we want to select a single element by its ID. The value `$("#game")` returns
    the jQuery object containing a reference to the DOM node.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 值 `$` 被定义为 `jQuery` 函数的别名，根据传入的参数，它可以执行多个不同的任务。对于选择器，我们传递一个字符串值（在这个例子中是 `"#game"`）给
    jQuery。像在 CSS 中一样，井号符号告诉 jQuery 我们要通过 ID 选择单个元素。值 `$("#game")` 返回包含指向 DOM 节点引用的
    jQuery 对象。
- en: You can use jQuery selectors to retrieve multiple DOM nodes, which are stored
    internally as an array. If you want to access the DOM node, you can retrieve the
    *n*th element returned from a query by calling `.get(n)` on the jQuery object.
    Because we have only one element with the ID `game`, we want the first (zero index)
    element, which we can retrieve by adding `.get(0)` onto the end of `$("#game")`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 jQuery 选择器来检索多个 DOM 节点，这些节点内部会作为一个数组存储。如果你想访问某个 DOM 节点，可以通过在 jQuery 对象上调用
    `.get(n)` 来检索查询返回的第*n*个元素。由于我们只有一个 ID 为 `game` 的元素，我们需要获取第一个（零索引）元素，可以通过在 `$("#game")`
    后加上 `.get(0)` 来实现。
- en: We don’t save much coding in this simple case, but more important, we can use
    the objects that jQuery returns from selection queries with cross-browser methods
    that abstract away a lot of the hard work of DOM manipulation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们并没有节省太多的代码，但更重要的是，我们可以使用 jQuery 从选择查询返回的对象，通过跨浏览器的方法来简化 DOM 操作的繁琐工作。
- en: 'jQuery objects let us query the DOM node for various CSS properties, as in
    these examples:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 对象让我们可以查询 DOM 节点的各种 CSS 属性，以下是一些示例：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first two lines query the DOM node for the game `div`’s `top` position and
    width, respectively, and the last line is a selector that returns a jQuery object
    containing all the `div` tags on a page. jQuery is a powerful library, and although
    we’ll use quite a few of its features in the game, covering it in great detail
    is beyond the scope of this book. The jQuery documentation at *[http://api.jquery.com/](http://api.jquery.com/)*
    provides an in-depth look at how it works.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行分别查询游戏 `div` 的 `top` 位置和宽度，最后一行是一个选择器，返回一个包含页面所有 `div` 标签的 jQuery 对象。jQuery
    是一个强大的库，尽管我们在游戏中会用到它的许多功能，但本书的范围并不包括详细介绍它。jQuery 的文档可以在 *[http://api.jquery.com/](http://api.jquery.com/)*
    中找到，提供了对其工作原理的深入了解。
- en: Adding the Modernizr Library
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Modernizr 库
- en: 'To get started with Modernizr, download it from its official website (*[http://modernizr.com/download/](http://modernizr.com/download/)*).
    Modernizr lets you choose individual features to download so you don’t waste bandwidth
    on code that you’ll never use. We’ll need a few specific features, so make sure
    you select the following boxes on the download page to include them:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Modernizr，可以从其官方网站下载（*[http://modernizr.com/download/](http://modernizr.com/download/)*）。Modernizr
    允许你选择单独的功能进行下载，以避免浪费带宽下载那些你永远不会使用的代码。我们需要一些特定的功能，所以确保在下载页面选择以下选项：
- en: CSS Transitions (under CSS3)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS 过渡（在 CSS3 中）
- en: Canvas and HTML5 Audio (under HTML5)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canvas 和 HTML5 音频（在 HTML5 下）
- en: Modernizr.load (under Extra)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Modernizr.load（在额外功能下）
- en: Modernizr.prefixed (under Extensibility)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Modernizr.prefixed（在扩展性下）
- en: Then, click **Generate** and **Download**.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击 **生成** 和 **下载**。
- en: 'Create a new folder in the game folder called *_js* and save the file there
    as *modernizr.js*. Also add the file to the HTML document, as shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏文件夹中创建一个名为 *_js* 的新文件夹，并将文件保存为 *modernizr.js*。同时，将该文件添加到 HTML 文档中，如下所示：
- en: '*index.html*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.html*'
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we’ve added Modernizr with a `<script>` tag, we’ll use it to load the
    rest of the JavaScript game files.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经用 `<script>` 标签添加了 Modernizr，接下来将使用它来加载其余的 JavaScript 游戏文件。
- en: Loading Scripts with Modernizr
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Modernizr 加载脚本
- en: Rather than just adding `<script>` tags to the document, we use Modernizr to
    load scripts for two main reasons. First, we can trigger functions to run immediately
    after a script is loaded rather than waiting until the entire page, including
    HTML and images, has loaded. Second, Modernizr allows us to load scripts in on
    a conditional basis (for example, *if this condition is satisfied, load in this
    script*) without writing much code to do it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以不直接在文档中添加 `<script>` 标签，而是使用 Modernizr 加载脚本，主要有两个原因。首先，我们可以在脚本加载后立即触发函数运行，而不是等到整个页面（包括
    HTML 和图片）加载完成后才运行。第二，Modernizr 允许我们基于条件加载脚本（例如，*如果满足这个条件，加载这个脚本*），而不需要编写大量代码。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Modernizr actually uses another library called* yepnope.js *for its script-loading
    functionality. You can learn more about that library at* [http://yepnopejs.com](http://yepnopejs.com)*/*.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*Modernizr 实际上使用了另一个名为* yepnope.js *的库来实现其脚本加载功能。你可以在* [http://yepnopejs.com](http://yepnopejs.com)*/*
    了解更多关于这个库的信息。'
- en: A simple example of this is to load jQuery from Google’s Content Delivery Network
    (CDN) to expedite load times. The potential flaw with using a third-party CDN
    is that the CDN could be down or inaccessible, or, more likely, your own server
    could be unavailable. However, relying on a service that you can’t control is
    never a good idea. Fortunately, Modernizr lets you add a test during the loading
    process and then call a backup function if that test fails. As a result, we can
    attempt to load the file from the CDN, and if it doesn’t work, load a local version
    instead.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子是从谷歌的内容分发网络（CDN）加载 jQuery，以加速加载时间。使用第三方 CDN 的潜在缺陷在于，CDN 可能无法使用或无法访问，或者更可能的是，你自己的服务器可能无法使用。然而，依赖一个你无法控制的服务从来都不是一个好主意。幸运的是，Modernizr
    允许你在加载过程中添加测试，如果该测试失败，可以调用备份功能。因此，我们可以尝试从 CDN 加载文件，如果不行，再加载本地版本。
- en: Why Use Google’s Hosted jQuery?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用谷歌托管的 jQuery？
- en: Although it may seem odd to rely on someone else’s server to obtain a critical
    file, using Google’s version of jQuery offers a few advantages, and I don’t just
    mean saving money or using someone else’s bandwidth should you create a popular
    game.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管依赖他人的服务器获取关键文件可能看起来有些奇怪，但使用谷歌版的 jQuery 具有一些优势，我说的不仅仅是节省费用或在创建流行游戏时使用别人带宽的问题。
- en: One advantage is that because the file comes from Google’s Content Delivery
    Network, users will almost always download it from a server closer to them than
    your server.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优点是，由于该文件来自 Google 的内容分发网络，用户几乎总是从比你的服务器更接近他们的服务器下载该文件。
- en: Another advantage is that, because the file comes from a server other than the
    one your game is hosted on, users can actually download it faster. Browsers often
    limit the number of connections they’ll open to a single server, so files wait
    in a queue to be downloaded, even if plenty of bandwidth is available. By hosting
    files on a different server, you increase the number of files that are downloaded
    in parallel and decrease the download time.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是，由于该文件来自与你的游戏托管服务器不同的服务器，用户实际上可以更快地下载它。浏览器通常会限制单个服务器的连接数量，因此即使带宽充足，文件也需要排队等待下载。通过将文件托管在不同的服务器上，可以增加并行下载的文件数量，从而减少下载时间。
- en: An additional advantage is that other sites are using the same copy of jQuery;
    therefore, if users have visited any of them recently, they’ll most likely have
    a copy of the file in their browser cache and won’t have to download the file
    at all!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是，其他网站也在使用相同的 jQuery 副本；因此，如果用户最近访问过这些网站，他们很可能已经将该文件缓存到浏览器中，根本不需要重新下载文件！
- en: Download the latest jQuery build from *[http://jquery.com/download/](http://jquery.com/download/)*
    and place it in the *_js* folder. Then add the following code block in bold just
    before the closing `</head>` tag. Be sure to change the version of jQuery in the
    URLs to match the version that you’ve downloaded.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[http://jquery.com/download/](http://jquery.com/download/)* 下载最新的 jQuery
    版本并将其放入 *_js* 文件夹。然后，在关闭 `</head>` 标签之前，添加以下加粗的代码块。确保将 URL 中的 jQuery 版本号更改为你下载的版本。
- en: '*index.html*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.html*'
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example shows the compact script loading Modernizr provides. In short,
    it attempts to load jQuery from the Google CDN ➊. When loading is finished ➋ (either
    when the file has loaded or the script returns from a failure to load), the `complete`
    property’s function call checks for the existence of `window.jQuery` ➌, and if
    that object doesn’t exist, loads the jQuery library from the local folder ➍.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了 Modernizr 提供的紧凑型脚本加载方式。简而言之，它会尝试从 Google CDN ➊ 加载 jQuery。当加载完成后 ➋（无论文件是否成功加载或脚本加载失败），`complete`
    属性的函数调用会检查 `window.jQuery` ➌ 是否存在，如果该对象不存在，则从本地文件夹加载 jQuery 库 ➍。
- en: 'The reason that `Modernizr.load` is called with two different sets of parameters
    is that the file can accept the following types of arguments: a single file (as
    a string), an object with name/value pairs, or an array containing a set of either
    strings or objects. Consequently, we can load in multiple files with a single
    `Modernizr.load` call. In the first call ➊, we pass in an object with `load` and
    `complete` properties. (The Modernizr website documents other properties available
    to use.) At the second call ➍, we only pass in a string. This line'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Modernizr.load` 时使用两种不同参数集的原因是，该文件可以接受以下几种类型的参数：一个文件（作为字符串），一个包含名称/值对的对象，或者一个包含字符串或对象集合的数组。因此，我们可以通过一次
    `Modernizr.load` 调用加载多个文件。在第一次调用 ➊ 中，我们传入一个包含 `load` 和 `complete` 属性的对象。（Modernizr
    网站文档中记录了其他可以使用的属性。）在第二次调用 ➍ 中，我们只传入一个字符串。此行
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: is equivalent to writing
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于编写
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first version uses the filename string as a convenient shorthand for loading
    just that file without any other configuration options.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个版本使用文件名字符串作为便捷的简写，用于仅加载该文件，而无需其他配置选项。
- en: 'We also want to load in the game scripts with Modernizr. Create a new file
    called *game.js* in the *_js* folder. To add the new file to `.load`, wrap the
    first `Modernizr.load` call in array brackets and add a new entry, shown here
    in bold:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望通过 Modernizr 加载游戏脚本。在 *_js* 文件夹中创建一个名为 *game.js* 的新文件。要将新文件添加到 `.load`
    中，请将第一个 `Modernizr.load` 调用用数组括起来，并添加一个新条目，如下所示（加粗）：
- en: '*index.html*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.html*'
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can continue adding new files to the `Modernizr.load` call as new elements
    in the array at any point before we load *game.js*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何时候继续将新文件添加到 `Modernizr.load` 调用中，作为数组中的新元素，直到加载 *game.js* 为止。
- en: Modernizr will load *game.js*, but the file doesn’t contain any code yet. The
    next task is to set up the main game controller class and run it when loading
    is complete.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Modernizr 将加载 *game.js*，但该文件目前没有任何代码。下一步是设置主游戏控制器类，并在加载完成后运行它。
- en: Modular JavaScript
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化 JavaScript
- en: 'To minimize global variables and the potential for duplicate variable name
    conflicts, we’ll use a modular approach for the JavaScript code. Using a *module*
    is a way of wrapping all the objects and variables of the game within a single
    containing namespace. The namespace will be called *BubbleShoot*. A class named
    `Game` will be contained within the module `BubbleShoot.Game` and can be accessed
    from anywhere else in the application by writing `BubbleShoot.Game`. This namespace
    is a safeguard: If we add another JavaScript library later in development that
    also has a variable named `Game`, both can exist simultaneously without conflict.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化全局变量以及潜在的变量名冲突问题，我们将采用模块化的方法来编写 JavaScript 代码。使用 *模块* 是一种将游戏的所有对象和变量封装在一个包含命名空间中的方式。这个命名空间将被命名为
    *BubbleShoot*。一个名为 `Game` 的类将被包含在 `BubbleShoot.Game` 模块中，并可以在应用程序的任何地方通过写 `BubbleShoot.Game`
    来访问。这个命名空间是一个保障：如果我们在开发后期添加了另一个 JavaScript 库，该库也有一个名为 `Game` 的变量，它们将能够同时存在而不会发生冲突。
- en: 'We’ll start with the game module, which will run much of the game. Enter the
    following code into *game.js*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从游戏模块开始，它将运行游戏的大部分功能。将以下代码输入到 *game.js* 中：
- en: '*game.js*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we check to see whether the object `BubbleShoot` exists ➊. Naming our
    code `BubbleShoot.Game` is roughly equivalent to using a namespace in languages
    such as Java or C#. All of the classes will be properties of the `BubbleShoot`
    object. Naming collisions aren’t likely to happen in small games like *Bubble
    Shooter* but can become a problem with larger projects. If `window.BubbleShoot`
    doesn’t exist, it will be created as an empty object. We’ll include this line
    at the top of every class file so we don’t have to think about the order in which
    scripts are loaded.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查对象 `BubbleShoot` 是否存在 ➊。将代码命名为 `BubbleShoot.Game` 大致相当于在 Java 或 C# 等语言中使用命名空间。所有的类都将作为
    `BubbleShoot` 对象的属性。像 *Bubble Shooter* 这样的小型游戏中命名冲突的可能性不大，但在更大的项目中可能会成为问题。如果 `window.BubbleShoot`
    不存在，它将被创建为空对象。我们将在每个类文件的顶部包含这行代码，这样就不需要考虑脚本加载的顺序。
- en: The next code line defines `BubbleShoot.Game` ➋. This structure—a function inside
    brackets—may look strange if you’re not familiar with it, but it’s a common approach
    to use when you’re writing JavaScript modules.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码定义了 `BubbleShoot.Game` ➋。这种结构——一个括号内的函数——如果你不熟悉它，可能会觉得有些奇怪，但它是编写 JavaScript
    模块时常用的一种方法。
- en: The structure uses an *Immediately Invoked Function Expression (IIFE)*, which
    is a piece of code that creates a function and runs it immediately. Usually, you
    will assign the returned results to a variable. The benefit is that the function
    block creates a variable scope within JavaScript, meaning that any variables created
    inside it won’t pollute the global scope.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构使用了 *立即执行函数表达式（IIFE）*，它是一段创建并立即运行的函数代码。通常，你会将返回的结果赋值给一个变量。它的好处是，这个函数块在 JavaScript
    中创建了一个变量作用域，这意味着任何在其中创建的变量都不会污染全局作用域。
- en: The variable declaration contains a function definition followed by parentheses
    ➎. The function is created, run, and instantly destroyed, but not before returning
    its contents ➍, which will be the object `Game` created at ➌. The bracket-wrapped
    function call ➋ is inside the new scope. Once this function has run, we can access
    the `Game` class from the global scope as `BubbleShoot.Game`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明包含一个函数定义，后面跟着圆括号 ➎。函数被创建、运行并立即销毁，但在销毁之前会返回它的内容 ➍，这些内容将是第 ➌ 步创建的 `Game` 对象。用括号包裹的函数调用
    ➋ 位于新作用域内。一旦这个函数执行完毕，我们可以从全局作用域访问 `Game` 类，形式为 `BubbleShoot.Game`。
- en: 'Now we have a stub of a class, so we need to add some useful code to run. Let’s
    start by hooking up a New Game button. Add the following to *index.html* inside
    the page `div`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个类的框架，需要添加一些有用的代码来运行。我们从连接一个“新游戏”按钮开始。在 *index.html* 页面 `div` 中添加以下内容：
- en: '*index.html*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.html*'
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The new `div` elements will create a dialog that displays information to players
    before they start the game ➊. The dialog will contain a heading with a message
    ➋ and a New Game button ➌. We still need to add some styling for them to the end
    of *main.css*, so let’s do that now.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `div` 元素将创建一个对话框，在玩家开始游戏之前显示信息 ➊。对话框将包含一个带有消息的标题 ➋ 和一个“新游戏”按钮 ➌。我们仍然需要为它们在
    *main.css* 的末尾添加一些样式，现在就来做吧。
- en: '*main.css*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.css*'
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this styling in place in *main.css*, reload the page to see the dialog.
    But note that there’s no way for the player to remove it yet. This will happen
    inside the `Game` class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *main.css* 中设置好样式后，重新加载页面以查看对话框。但请注意，目前玩家还无法移除它。这个功能将在 `Game` 类中实现。
- en: 'Next, we need some code to run when the page has finished loading so we can
    attach an event handler to the New Game button. One function will initialize the
    objects and set up the game after the page has loaded, and another will run every
    time a new game starts. Make the following changes to *game.js*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在页面加载完成后运行一些代码，以便为“新游戏”按钮绑定事件处理程序。一个函数将在页面加载后初始化对象并设置游戏，另一个函数将在每次开始新游戏时执行。请对*game.js*进行以下更改：
- en: '*game.js*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This new code sets up one public method, called `init` ➊, and one private method,
    called `startGame` ➌. The `init` method is public because it’s attached as a property
    of the `Game` object. Inside `init`, we add a jQuery event handler called `bind`
    to the New Game button ➋, which will call the `startGame` function whenever the
    button is clicked.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码设置了一个公共方法，叫做`init` ➊，以及一个私有方法，叫做`startGame` ➌。`init`方法是公共的，因为它作为`Game`对象的属性进行附加。在`init`内部，我们为“新游戏”按钮
    ➋ 添加了一个叫做`bind`的jQuery事件处理程序，当按钮被点击时，它将调用`startGame`函数。
- en: We know the IIFE has a short life and isn’t attached as a property of any object,
    and yet the `startGame` function can be called here. The reason is due to a JavaScript
    feature called *closure*. Closure means that a variable exists within the code
    block that defined it and persists inside that code block. Therefore, the `startGame`
    function can be used within other functions inside `Game`, including `init`, but
    can’t be accessed by any JavaScript outside of this scope.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道IIFE的生命周期很短，并且它不会作为任何对象的属性附加，然而`startGame`函数可以在这里被调用。原因在于JavaScript中的一个特性，叫做*闭包*。闭包意味着一个变量存在于定义它的代码块中，并且在该代码块内部持续存在。因此，`startGame`函数可以在`Game`中的其他函数内使用，包括`init`，但不能被该作用域外的任何JavaScript访问。
- en: 'We want to call `init` after the page has loaded, so back in *index.html* we’ll
    add a `complete` call in `Modernizr.load` once *game.js* has finished loading:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在页面加载后调用`init`，因此在*index.html*中，我们将在`Modernizr.load`中添加一个`complete`回调，当*game.js*加载完成后调用：
- en: '*index.html*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.html*'
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Recall that the `$` function ➊ is shorthand for the `jQuery` function, which
    can do one of several tasks based on what you pass into it. Previously, we’ve
    passed in a string (`#game`), which jQuery interpreted as a selector. In this
    case, we’re passing in a function, which jQuery stores to run once the DOM is
    ready to be manipulated.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，`$`函数 ➊ 是`jQuery`函数的简写，它可以根据传入的内容执行多种任务。之前，我们传入了一个字符串（`#game`），jQuery将其解释为一个选择器。在这种情况下，我们传入的是一个函数，jQuery会将其存储，并在DOM准备好可以被操作时执行。
- en: This bit of jQuery functionality is incredibly useful, especially for a game,
    because from this point we know that we can safely manipulate the DOM with JavaScript
    even if all of the game’s other assets (such as images and sounds) haven’t finished
    loading. Traditionally, client-side interaction has been triggered by waiting
    for a `window.onload` event to fire from within JavaScript, which signifies that
    the HTML has loaded, the DOM is ready, and all of the images are loaded. However,
    waiting for the images can leave users staring at screens they can’t interact
    with for too long. The preferable alternative is to allow users to interact with
    the application as soon as the DOM is ready without waiting for the images to
    load, which produces more responsive interfaces. But determining when the DOM
    is ready often involves code unique to each browser vendor and frequently changes
    from one version of a browser to the next. jQuery’s `$` function smoothes over
    any browser inconsistencies and lets you achieve that responsiveness without having
    to determine exactly when the DOM is ready.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这段jQuery功能非常有用，特别是对于一个游戏，因为从这一点开始我们知道即使游戏的其他资源（如图像和声音）尚未加载完毕，我们也可以安全地使用JavaScript操作DOM。传统上，客户端交互是通过等待`window.onload`事件触发来实现的，这表明HTML已经加载，DOM已经准备好，所有的图像也已加载。然而，等待图像加载完成可能会导致用户长时间无法与页面进行交互。更好的选择是让用户在DOM准备好后就能与应用程序进行交互，而无需等待图像加载，这样可以提供更响应式的界面。但确定DOM何时准备好通常涉及每个浏览器厂商独特的代码，并且从一个浏览器版本到另一个版本可能会有所变化。jQuery的`$`函数解决了浏览器之间的差异，让你在不必精确确定DOM何时准备好的情况下实现这种响应性。
- en: Look back at the `$` function. Inside it we created an instance of the `Game`
    class ➋ and then called the public `init` method ➌ of that class. Based on what
    we know about the `$` function, anything we do inside `init` should happen after
    jQuery has loaded and the DOM is ready for us to work with it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下`$`函数。在它内部，我们创建了一个`Game`类的实例 ➋，然后调用了该类的公共`init`方法 ➌。根据我们对`$`函数的了解，我们在`init`中做的任何事情都应该在
    jQuery 加载完毕且 DOM 准备好后执行。
- en: Now we have an instance of `Game` that binds its `startGame` function to the
    New Game button. However, the `startGame` function still doesn’t do anything.
    Let’s change that!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个`Game`的实例，将它的`startGame`函数绑定到新游戏按钮上。然而，`startGame`函数仍然什么也不做。让我们改进一下！
- en: Introducing Closure
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 引入闭包
- en: One of JavaScript’s most powerful features, *closure* means that variables that
    have been defined within a function are stored in the function’s scope. These
    variables persist within the scope even when the function has exited, so long
    as the JavaScript interpreter determines that it still has to make use of them.
    Reasons for persisting in the scope could include an event handler that requires
    one of the values when it is triggered or a `setTimeout` call that will need access
    to a variable at some time in the future. A simple example will help to explain
    how this works, but it’s worth reading up on closure in order to better make use
    of it within your own functions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 最强大的功能之一，*闭包*意味着在函数内定义的变量会存储在函数的作用域中。这些变量即使在函数退出后仍然存在于作用域内，只要 JavaScript
    解释器认为它们仍然需要使用它们。保持在作用域中的原因可能包括事件处理程序在触发时需要某个值，或者是一个`setTimeout`调用在未来某个时刻需要访问某个变量。一个简单的例子可以帮助解释这一点，但为了更好地在自己的函数中使用闭包，值得深入了解这一概念。
- en: 'The following example shows how scope works in JavaScript (and many other languages).
    The three `alert` calls in this example should display alerts of 1, 2, and 1 respectively,
    because the value of `myVar` inside the function does not overwrite the value
    in the parent scope. You can run this code from the JavaScript console:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了作用域在 JavaScript（以及许多其他语言）中的工作原理。此示例中的三个`alert`调用应该分别显示1、2和1，因为函数内部的`myVar`值不会覆盖父作用域中的值。你可以从
    JavaScript 控制台运行以下代码：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To demonstrate how the scope is retained even when a function is executed,
    we can add a timeout inside the `innerMyVar` function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示即使在函数执行时作用域依然保持不变，我们可以在`innerMyVar`函数内添加一个定时器：
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code should display alerts of 1, 1, and 3\. The scope of `innerMyVar` retains
    the value of `myVar` defined inside it, including the increment that occurs after
    the timeout has been defined.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该显示 1、1 和 3 的警告框。`innerMyVar`的作用域保留了其中定义的`myVar`值，包括在定时器定义之后发生的增量。
- en: You can read more about scope at *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures/](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures/)*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures/](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures/)*
    阅读更多关于作用域的内容。
- en: User Interface and Display Scripts
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户界面和显示脚本
- en: 'Let’s create a class to handle the user interface and some of the other page
    display functionality. Create a new file called *ui.js* in the *_js* folder and
    add the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个类来处理用户界面和其他页面显示功能。在`_js`文件夹中创建一个名为*ui.js*的新文件，并添加以下代码：
- en: '*ui.js*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*ui.js*'
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Although not much is in this code, notice that the UI object follows the same
    pattern as the previous `Game` class. The `hideDialog` function ➋ contains a simple
    bit of jQuery that fades out any HTML element with the CSS class `dialog` ➌. The
    structural difference that `ui` has from the `Game` class pattern is that rather
    than making a `ui` class, we’re just creating a single object ➊ and attaching
    methods to it. This structure is similar to the way static classes are used in
    other languages.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码内容不多，但请注意，UI 对象遵循与之前的`Game`类相同的模式。`hideDialog`函数 ➋ 包含一段简单的 jQuery 代码，能够使任何带有
    CSS 类`dialog`的 HTML 元素渐隐 ➌。`ui`与`Game`类模式的结构性不同之处在于，`ui`并没有创建一个类，而是直接创建了一个单一对象
    ➊ 并将方法附加到该对象上。这种结构类似于其他语言中使用静态类的方式。
- en: 'The call to `fadeOut` takes a parameter that specifies the number of milliseconds
    to fade out the dialog. We use a value of 300, which is fast enough to not slow
    down users but not so fast that they won’t notice it. The `fadeOut` method is
    built into jQuery, but other ways are available to combine selectors and manipulate
    DOM elements. For now, let’s quickly run through what jQuery actually does in
    the `fadeOut` call:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`fadeOut`时需要一个参数，指定淡出对话框所需的毫秒数。我们使用300的值，这足够快，不会拖慢用户体验，同时也不会太快，以至于用户无法注意到。`fadeOut`方法内建于jQuery中，但也有其他方式可以组合选择器并操作DOM元素。现在，我们快速回顾一下jQuery在`fadeOut`调用中实际做了什么：
- en: Reduces the CSS opacity by a small, fixed amount and repeats in a loop for 300
    milliseconds. At the end of this time, the opacity should be zero.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将CSS透明度减少一个小的固定值，并在300毫秒内循环执行。此时结束时，透明度应为零。
- en: Sets the `display` CSS property of the element to `none`.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将元素的`display` CSS属性设置为`none`。
- en: We could have created this effect by hand by stringing together some `setTimeout`
    calls, but jQuery handles it for us with `fadeOut`. Using jQuery saves us a lot
    of code here because, as with many CSS properties, manipulating opacity is not
    straightforward across browsers (earlier versions of IE use a filter instead of
    the `opacity` property, for example).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以通过手动串联一些`setTimeout`调用来创建这个效果，但jQuery用`fadeOut`为我们处理了这个问题。使用jQuery在这里为我们节省了大量代码，因为像很多CSS属性一样，操作透明度在不同浏览器之间并不简单（例如，早期版本的IE使用滤镜而不是`opacity`属性）。
- en: Note that at the moment we’re not doing anything particular to CSS3 or HTML5\.
    We’re using old HTML tags and manipulating relatively old CSS properties through
    JavaScript loops. Later in this book, you’ll learn whether you should do this
    in a more modern way, but for now, the code does the job well. As you develop
    games, you’ll realize that a lot of code runs just as well on earlier browsers
    as it does on later ones and that, unless you’re exclusively rendering to the
    canvas, your HTML5 games look similar to regular web applications.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目前我们并没有做任何特别的CSS3或HTML5相关的事情。我们正在使用旧的HTML标签，并通过JavaScript循环操作相对较旧的CSS属性。书中的后续内容将教你是否应该以更现代的方式来做，但目前这些代码已经很好地完成了工作。在开发游戏时，你会意识到，很多代码在较早的浏览器中运行得和在较新的浏览器中一样好，除非你专门为Canvas渲染，否则HTML5游戏看起来和普通的Web应用程序类似。
- en: 'Now we need to load our newly created UI file into *index.html* by adding it
    to the `Modernizr.load` call:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要通过将其添加到`Modernizr.load`调用中，将新创建的UI文件加载到*index.html*中：
- en: '*index.html*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.html*'
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To add a new *.js* file to the load call ➊, simply add the URL to your script
    file as an extra array item after *ui.js* but before loading *game.js*. We’ll
    need to add each new script file we create to *index.html*, so remember this process.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个新的*.js*文件添加到加载调用➊中，只需将你的脚本文件的URL作为额外的数组项添加到*ui.js*之后，*game.js*之前。我们需要将每个新创建的脚本文件添加到*index.html*，所以记住这个过程。
- en: 'To call `hideDialog` when we click the New Game button, add the following lines
    in bold to *game.js*:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要在点击“新游戏”按钮时调用`hideDialog`，请在*game.js*中添加以下**行**：
- en: '*game.js*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*game.js*'
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using the `bind` method in jQuery ➊ is a cross-browser way to add event handlers.
    This method binds a function to an object that triggers when an event occurs.
    In this game application, the trigger occurs when the user clicks the New Game
    button, which calls the `startGame` function.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在jQuery中使用`bind`方法➊是一种跨浏览器的添加事件处理程序的方式。这个方法将一个函数绑定到一个对象，当事件发生时触发。在这个游戏应用中，当用户点击“新游戏”按钮时，触发该事件，进而调用`startGame`函数。
- en: Note that we unbind the event ➋ when the button is clicked to prevent double-clicks
    from being registered while the button is fading out and trying to start a game
    twice. If you reload the page and click the New Game button, the dialog should
    disappear due to the `hideDialog` function ➌.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在按钮点击时解绑事件➋，以防止在按钮淡出时注册双击事件，从而导致尝试启动两次游戏。如果你重新加载页面并点击“新游戏”按钮，`hideDialog`函数➌会使对话框消失。
- en: The *Bubble Shooter* game still doesn’t do much, but at least now we have some
    structure to add code to.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bubble Shooter*游戏目前功能较少，但至少现在我们已经有了一些结构，可以在其中添加代码。'
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We now have the foundation in place to start building the game. Modernizr is
    loading in files, and we can easily add to this task when we create more classes
    and functions. An instance of the `Game` class is created when the DOM has finished
    loading, and clicking on a button starts the game.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了构建游戏的基础。Modernizr正在加载文件，我们可以轻松地在创建更多类和函数时继续添加任务。当DOM加载完成时，会创建`Game`类的实例，点击按钮即可开始游戏。
- en: In the next chapter, we’ll create our first sprites for the bubble object, forming
    the core of the game, and you’ll learn how to animate the sprites on the screen.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为气泡对象创建第一个精灵，构成游戏的核心，并学习如何在屏幕上为精灵添加动画效果。
- en: Further Practice
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步练习
- en: The dialog is being hidden with a jQuery `fadeOut` function, but you can apply
    other effects to remove the dialog from the screen. Try using `slideUp` or `hide`
    instead of `fadeOut`, for example. Alternatively, start the dialog offscreen and
    move it into place with an `animate` call.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对话框是通过jQuery的`fadeOut`函数隐藏的，但你可以应用其他效果将对话框从屏幕中移除。例如，可以尝试使用`slideUp`或`hide`代替`fadeOut`。或者，可以先将对话框放在屏幕外，再通过`animate`函数将其移入屏幕。
- en: The colors and styling of the dialogs and the header and footer are quite simple.
    Change the colors in those areas (or even experiment with graphics) until you
    find a combination you like.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对话框以及头部和脚部的颜色和样式非常简单。可以改变这些区域的颜色（甚至可以尝试使用图形），直到找到自己喜欢的组合。
- en: Learn how to use your browser’s debugging tools. It’s likely you’ll have access
    to breakpoints, watch variables, and the variable stack, so read about and experiment
    with them. Learning your way around the tools now can be quite a time-saver when
    you’re debugging later. Try adding breakpoints within the `init` and `startGame`
    functions in *game.js* and trace the code as it runs.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学会使用浏览器的调试工具。你很可能可以访问断点、监视变量和变量堆栈，因此请阅读相关内容并进行实验。现在熟悉这些工具，未来在调试时能节省很多时间。尝试在*game.js*中的`init`和`startGame`函数内添加断点，并在代码运行时进行追踪。
