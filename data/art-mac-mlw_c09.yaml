- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Anti-Analysis
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 反分析
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In the previous chapters, we leveraged both static and dynamic analysis methods
    to uncover malware’s persistence mechanisms, core capabilities, and most closely
    held secrets. Of course, malware authors are not happy about their creations being
    laid bare for the world to see. Thus, they often seek to complicate analysis by
    writing anti-analysis logic or other protection schemes. In order to successfully
    analyze such malware, we must first identify these protections and then circumvent
    them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们利用了静态和动态分析方法来揭示恶意软件的持久化机制、核心功能以及最为隐秘的秘密。当然，恶意软件作者并不希望他们的创作被公之于众。因此，他们经常通过编写反分析逻辑或其他保护方案来复杂化分析。为了成功分析这类恶意软件，我们必须首先识别这些保护措施，然后绕过它们。
- en: 'In this chapter we’ll discuss anti-analysis approaches common among macOS malware
    authors. Generally speaking, there are two kinds of anti-analysis measures: those
    that aim to thwart static analysis and those that seek to thwart dynamic analysis.
    Let’s take a look at both.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论在macOS恶意软件作者中常见的反分析方法。一般来说，反分析措施分为两类：旨在阻止静态分析的措施和旨在阻止动态分析的措施。让我们看看这两种措施。
- en: Anti-Static-Analysis Approaches
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反静态分析方法
- en: 'Malware authors use several common approaches to complicate static analysis
    efforts:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者使用几种常见的方法来复杂化静态分析工作：
- en: '**String-based obfuscation/encryption**: During analysis, malware analysts
    are often trying to answer questions such as “How does the malware persist?” or
    “What is the address of its command and control server?” Malware that contains
    plaintext strings related to its persistence, like filepaths or the URL of its
    command and control server, makes analysis almost too easy. As such, malware authors
    often obfuscate or encrypt these sensitive strings.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于字符串的混淆/加密**：在分析过程中，恶意软件分析师通常试图回答诸如“恶意软件如何持久化？”或“它的命令与控制服务器的地址是什么？”之类的问题。如果恶意软件包含与其持久化相关的明文字符串，如文件路径或命令与控制服务器的URL，分析几乎变得太容易了。因此，恶意软件作者通常会对这些敏感字符串进行混淆或加密。'
- en: '**Code obfuscation**: In order to complicate the static analysis of their code
    (and sometimes dynamic analysis as well), malware authors can obfuscate the code
    itself. Various obfuscator tools are available for nonbinary malware specimens
    like scripts. For Mach-O binaries, malware authors can use executable packers
    or encryptors to protect the binary’s code.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码混淆**：为了复杂化代码的静态分析（有时也包括动态分析），恶意软件作者可以对代码本身进行混淆。对于像脚本这样的非二进制恶意软件样本，有各种混淆工具可以使用。对于Mach-O二进制文件，恶意软件作者可以使用可执行打包器或加密器来保护二进制文件的代码。'
- en: Let’s look at a few examples of anti-static-analysis methods and then discuss
    how to bypass them. As you’ll see, it’s often easier to overcome anti-static-analysis
    approaches with dynamic analysis techniques. In some cases, the opposite holds
    as well; static analysis techniques can reveal anti-dynamic-analysis tactics.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些反静态分析方法的例子，然后讨论如何绕过它们。正如你所看到的，通常使用动态分析技术比反静态分析方法更容易克服。在某些情况下，反过来也成立；静态分析技术可以揭示反动态分析策略。
- en: Sensitive Strings Disguised as Constants
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 敏感字符串伪装为常量
- en: 'One of the most basic string-based obfuscations involves splitting sensitive
    strings into chunks so that they are inlined directly into assembly instructions
    as constants. Depending on the chunk size, the `strings` command may miss these
    strings, while a disassembler, by default, will rather unhelpfully display the
    chunks as hexadecimal numbers. We find an example of this string obfuscation in
    Dacls ([Listing 9-1](#listing9-1)):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的基于字符串的混淆技术之一是将敏感字符串拆分为多个部分，然后将它们作为常量直接内联到汇编指令中。根据每个部分的大小，`strings`命令可能会错过这些字符串，而反汇编器默认情况下则会以十六进制数字形式显示这些部分，这并不特别有用。我们在Dacls中发现了这种字符串混淆的例子（[列表9-1](#listing9-1)）：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 9-1: Basic string obfuscation (Dacls)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-1：基本的字符串混淆（Dacls）
- en: 'As you can see, six 64-bit values are moved first into the `RCX` register,
    then into adjacent stack-based variables. The astute reader will notice that each
    byte of these values falls within the range of printable ASCII characters. We
    can overcome this basic obfuscation using a disassembler. Simply instruct the
    disassembler to decode the constants as characters instead of the default, hexadecimal.
    In the Hopper disassembler, you can simply CTRL-click the constant and select
    **Characters** to use the shift-r keyboard shortcut ([Listing 9-2](#listing9-2)):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，六个64位的值首先被移动到`RCX`寄存器，然后移动到相邻的基于栈的变量。敏锐的读者会注意到，这些值的每个字节都落在可打印的ASCII字符范围内。我们可以使用反汇编工具克服这种基本的混淆。只需指示反汇编工具将常量解码为字符，而不是默认的十六进制格式。在Hopper反汇编工具中，你可以简单地CTRL点击常量，然后选择**字符**来使用shift-r快捷键（[清单9-2](#listing9-2)）：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-2: Deobfuscated strings (Dacls)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-2：去混淆的字符串（Dacls）
- en: 'If we reconstitute the split string (noting the slight overlap of the first
    two string components), this deobfuscated disassembly now reveals the path of
    the malware’s persistent launch item: */Library/LaunchAgents/com.aex-loop.agent.plist*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新组合被拆分的字符串（注意前两个字符串组件的轻微重叠），这个去混淆后的反汇编现在揭示了恶意软件持久启动项的路径：*/Library/LaunchAgents/com.aex-loop.agent.plist*。
- en: Encrypted Strings
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密字符串
- en: In previous chapters, we looked at several more complex examples of string-based
    obfuscations. For example, in Chapter 7 we noted that WindTail contains various
    embedded base64-encoded and AES-encrypted strings, including the address of its
    command and control server. The encryption key needed to decrypt the string is
    hardcoded within the malware, meaning it would be possible to manually decode
    and decrypt the server’s address. However, this would involve some legwork, such
    as finding (or scripting up) an AES decryptor. Moreover, if the malware used a
    custom (or nonstandard) algorithm to encrypt the strings, even more work would
    be involved. Of course, at some point the malware will have to decode and decrypt
    the protected strings so that it can use them, such as to connect to a command
    and control server for tasking. As such, it’s often far more efficient to simply
    allow the malware to run, which should trigger the decryption of its strings.
    If you’re monitoring the execution of the malware, the decrypted strings can be
    easily recovered.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们查看了几个更复杂的基于字符串的混淆示例。例如，在第7章中我们提到，WindTail包含了各种嵌入的base64编码和AES加密的字符串，其中包括它的命令和控制服务器的地址。解密这些字符串所需的密钥被硬编码在恶意软件中，这意味着我们可以手动解码并解密服务器的地址。然而，这将涉及一些工作，例如找到（或编写）一个AES解密器。此外，如果恶意软件使用了自定义（或非标准的）算法来加密字符串，还需要做更多的工作。当然，在某个时刻，恶意软件必须解码并解密受保护的字符串，以便使用它们，例如连接到命令和控制服务器执行任务。因此，通常更高效的做法是直接让恶意软件运行，这样它会触发字符串的解密。如果你正在监控恶意软件的执行，解密后的字符串就可以轻松恢复。
- en: 'In Chapter 7, I showed one technique for doing this: using a network monitor,
    which allowed us to passively recover the (previously encrypted) address of the
    malware’s command and control server as the malware beaconed out for tasking.
    We can accomplish the same thing using a debugger, as you’ll see here. First,
    we locate WindTail’s decryption logic, a method named `yoop:`. (In a subsequent
    section, I’ll describe how to locate such methods.) Looking at cross-references
    to this method, we can see it’s invoked any time the malware needs to decrypt
    one of its strings prior to use. For example, [Listing 9-3](#listing9-3) shows
    a snippet of disassembly that invokes the `yoop:` method 1 to decrypt the malware’s
    primary command and control server.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章，我展示了一个实现方法：使用网络监控工具，这使我们能够被动地恢复（之前加密的）恶意软件命令和控制服务器的地址，因为恶意软件在进行任务指派时会发送信号。我们也可以使用调试器完成相同的操作，正如你将在这里看到的那样。首先，我们定位到WindTail的解密逻辑，一个名为`yoop:`的方法。（在后续的章节中，我会描述如何定位这类方法。）通过查看该方法的交叉引用，我们可以看到每当恶意软件需要在使用之前解密其字符串时，都会调用这个方法。例如，[清单9-3](#listing9-3)展示了一段反汇编代码，调用`yoop:`方法1来解密恶意软件的主要命令和控制服务器。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 9-3: Decryption of a command and control server (WindTail)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-3：命令和控制服务器的解密（WindTail）
- en: 'We can set a debugger breakpoint at `0x100002048`, which is the address of
    the instruction immediately after the call to `yoop:` 2. Because the `yoop:` method
    returns a plaintext string, we can print this string when we hit this breakpoint.
    (Recall that a method’s return value can be found in the `RAX` register.) This
    reveals the malware’s primary command and control server, *flux2key.com*, as shown
    in [Listing 9-4](#listing9-4):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `0x100002048` 处设置调试器断点，这是调用 `yoop:` 后立即执行的指令地址。因为 `yoop:` 方法返回明文字符串，所以当我们命中这个断点时，我们可以打印出这个字符串。
    （请记住，方法的返回值可以在 `RAX` 寄存器中找到。）这将显示恶意软件的主要命令和控制服务器 *flux2key.com*，如 [列表 9-4](#listing9-4)
    所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-4: A decrypted command and control address (WindTail)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-4：一个解密的命令和控制地址（WindTail）
- en: It’s worth noting that you could also set a breakpoint on the return instruction
    (`retn`) within the decryption function. When the breakpoint is hit, you’ll once
    again find the decrypted string in the `RAX` register. A benefit of this approach
    is that you only have to set a single breakpoint, instead of several at the locations
    from which the decryption method is invoked. This means that any time the malware
    decrypts, not just its command and control server but any string, you’ll be able
    to recover the plaintext of that as well. However, it would become rather tedious
    to manually manage this breakpoint, as it will be invoked many times to decrypt
    each of the malware’s strings. A more efficient approach would be to add additional
    debugger commands (via `breakpoint command add`) to the breakpoint. Then, once
    the breakpoint is hit, your breakpoint commands will be automatically executed
    and could just print out the register holding the decrypted string and then allow
    the process to automatically continue. If you’re interested in the caller, perhaps
    to locate where a specific decrypted string is used, consider printing out the
    stack backtrace as well.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，您还可以在解密函数中的返回指令（`retn`）上设置断点。当断点命中时，您将再次在 `RAX` 寄存器中找到解密后的字符串。这种方法的好处是您只需要设置一个断点，而不是在调用解密方法的多个位置设置多个断点。这意味着每当恶意软件解密时，不仅能恢复其命令和控制服务器而且任何字符串的明文。然而，手动管理这个断点将变得非常乏味，因为它将被多次调用以解密恶意软件的每个字符串。更有效的方法是通过
    `breakpoint command add` 添加附加的调试器命令到断点。然后，一旦断点命中，您的断点命令将自动执行，并且可以只需打印出保存解密字符串的寄存器，然后允许进程继续自动执行。如果您对调用者感兴趣，也许是为了定位特定解密字符串使用的位置，则考虑打印出堆栈回溯。
- en: Note that this breakpoint-based approach can be applied to most string obfuscation
    or encryption methods, as it is agnostic to the algorithm used. That is to say,
    it generally does not matter what technique the malware is using to protect strings
    or data. If you’re able to locate the deobfuscation or decryption routine during
    static analysis, all you’ll need in order to read the string is a well-placed
    debugger breakpoint.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种基于断点的方法适用于大多数字符串混淆或加密方法，因为它对使用的算法不加区分。换句话说，通常不重要恶意软件使用何种技术来保护字符串或数据。如果您能够在静态分析期间找到去混淆或解密例程，则在阅读字符串时，您只需要一个适当放置的调试器断点。
- en: Locating Obfuscated Strings
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定位混淆字符串
- en: 'Of course, this begs the question: How can you determine that malware has obfuscated
    sensitive strings and data? And how can you locate the routines within the malware
    responsible for returning their plaintext values?'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这引出了一个问题：您如何确定恶意软件是否混淆了敏感字符串和数据？以及如何定位恶意软件内负责返回其明文值的例程？
- en: 'While there are no foolproof methods for the latter, it’s generally straightforward
    to ascertain if a malicious specimen has something to hide. Take, for example,
    the output of the `strings` command, which usually produces a significant number
    of extracted strings. If its output is rather limited or contains a large number
    of nonsensical strings (especially of significant length), this is a good indication
    that some type of string obfuscation is in play. For example, if we run `strings`
    on WindTail, we’ll find various plaintext strings alongside what appear to be
    obfuscated strings ([Listing 9-5](#listing9-5)):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然后者没有绝对可靠的方法，但通常很容易确定恶意标本是否有所隐瞒。例如，`strings` 命令的输出通常会产生大量提取出的字符串。如果其输出相对有限或包含大量毫无意义的字符串（尤其是长度显著的字符串），则这表明某种类型的字符串混淆正在发挥作用。例如，如果我们在
    WindTail 上运行 `strings`，我们将找到各种明文字符串以及看似混淆的字符串（[列表 9-5](#listing9-5)）：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 9-5: Obfuscated strings (WindTail)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-5：混淆字符串（WindTail）
- en: Of course, this method is not foolproof. For example, if the obfuscation method,
    such as an encryption algorithm, produces non-ASCII characters, the obfuscated
    content may not show up in the `strings` output.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种方法并非万无一失。例如，如果混淆方法（如加密算法）产生的是非ASCII字符，混淆内容可能不会出现在`strings`的输出中。
- en: However, poking around in a disassembler may reveal many or large chunks of
    obfuscated or high entropy data that are cross-referenced elsewhere in the binary
    code. For example, malware called NetWire (which installs a malicious application
    named *Finder.app*) contains what appears to be a blob of encrypted data near
    the start of the `__data` section ([Figure 9-1](#figure9-1)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在反汇编工具中翻阅时，可能会发现很多或较大块的混淆数据或高熵数据，这些数据可能会在二进制代码中被交叉引用。例如，名为NetWire的恶意软件（它安装了一个名为*Finder.app*的恶意应用程序）在`__data`段的开头附近包含了一块看起来像是加密数据的区域（见[图9-1](#figure9-1)）。
- en: '![NetWire contains a giant section of obfuscated data](image_fi/501942c09/f09001.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![NetWire包含一大块混淆数据](image_fi/501942c09/f09001.png)'
- en: 'Figure 9-1: Embedded obfuscated data (NetWire)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1：嵌入的混淆数据（NetWire）
- en: 'A continued triage of the malware’s `main` function reveals multiple calls
    to a function at `0x00009502`. Each call to this function passes in an address
    that falls within the block of encrypted data, which starts around `0x0000e2f0`
    in memory:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对恶意软件的`main`函数进行持续的分类分析时，发现多次调用了位于`0x00009502`的一个函数。每次调用该函数时，都会传入一个地址，该地址位于加密数据块内，而这个数据块大约从内存中的`0x0000e2f0`开始：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It seems reasonable to assume that this function is responsible for decrypting
    the contents of the blob of encrypted data. As noted previously, you can usually
    set a breakpoint after code that references the encrypted data and then dump the
    decrypted data. In the case of NetWire, we can set a breakpoint immediately after
    the final call to the decryption function, and then we can examine the decrypted
    data in memory. As it decrypts to a sequence of printable strings, we can display
    it via the `x/s` debugger command, as in [Listing 9-6](#listing9-6):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎合理假设，这个函数负责解密那块加密数据。正如前面提到的，通常可以在引用加密数据的代码后设置断点，然后转储解密后的数据。以NetWire为例，我们可以在最后一次调用解密函数之后立即设置断点，然后在内存中查看解密后的数据。随着数据解密为一串可打印的字符串，我们可以通过`x/s`调试命令来显示它，正如[列表9-6](#listing9-6)所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 9-6: Dumping now-decrypted configuration parameters (NetWire)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-6：转储现已解密的配置参数（NetWire）
- en: The contents turn out to be configuration parameters that include the address
    of the malware’s command and control server 1, as well as its installation path
    2. Recovering these configuration parameters greatly expedites our analysis.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容最终是一些配置参数，包括恶意软件的命令与控制服务器地址1，以及其安装路径2。恢复这些配置参数大大加快了我们的分析过程。
- en: Finding the Deobfuscation Code
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找解混淆代码
- en: When we encounter obfuscated or encrypted data in a malicious sample, it’s important
    to locate the code that deobfuscates or decrypts this data. Once we’ve done so,
    we can set a debugging breakpoint and recover the plaintext. This raises the question
    of how we can locate that code within the malware.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在恶意样本中遇到混淆或加密数据时，找到解混淆或解密该数据的代码非常重要。一旦我们找到了这些代码，就可以设置调试断点并恢复明文数据。这就引出了一个问题：我们如何在恶意软件中定位到这些代码？
- en: Usually, the best approach is to use a disassembler or decompiler to identify
    code that references the encrypted data. These references generally indicate either
    the code responsible for decryption or code that later references the data in
    a decrypted state.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好的方法是使用反汇编工具或反编译器，识别出引用加密数据的代码。这些引用通常指示要么是负责解密的代码，要么是后续引用解密后数据的代码。
- en: 'For example, in the case of WindTail, we noted various strings that appeared
    to be obfuscated. If we select one such string (`"BouCfWujdfbAUfCos/iIOg=="`),
    we find it is referenced in the following disassembly ([Listing 9-7](#listing9-7)):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在WindTail的案例中，我们注意到一些字符串似乎被混淆了。如果我们选择其中一个字符串（`"BouCfWujdfbAUfCos/iIOg=="`），我们发现它在以下反汇编中被引用（见[列表9-7](#listing9-7)）：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 9-7: Possible string deobfuscation (WindTail)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-7：可能的字符串解混淆（WindTail）
- en: Recall that the `objc_msgSend` function is used to invoke Objective-C methods,
    that the `RSI` register will hold the name of the method being invoked, and that
    the `RDI` register will hold its first parameter. From the disassembly that references
    the obfuscated string, we can see that the malware is invoking the `yoop:` method
    with the obfuscated string as its parameter. Enumerating cross-references to the
    `yoop:` selector (found at `0x100015448`) reveals that the method is invoked once
    for each string that needs to be decoded and decrypted ([Figure 9-2](#figure9-2)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`objc_msgSend`函数用于调用Objective-C方法，`RSI`寄存器将保存被调用方法的名称，而`RDI`寄存器将保存其第一个参数。从引用混淆字符串的反汇编中，我们可以看到恶意软件正在调用`yoop:`方法，并将混淆字符串作为其参数。枚举对`yoop:`选择器（位于`0x100015448`）的交叉引用表明，该方法会为每个需要解码和解密的字符串调用一次（[图
    9-2](#figure9-2)）。
- en: '![The cross-references to 0x100015448 contain multiple addresses, all of which
    have the Value “mov rsi, qword [0x100015448].”](image_fi/501942c09/f09002.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![0x100015448的交叉引用包含多个地址，所有这些地址的值为“mov rsi, qword [0x100015448]。”](image_fi/501942c09/f09002.png)'
- en: 'Figure 9-2: Cross-references to `@``selector(``yoop:)` (WindTail)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：`@``selector(``yoop:)`（WindTail）的交叉引用
- en: Taking a closer look at the actual `yoop:` method reveals calls to methods named
    `decode:` and `AESDecryptWithPassphrase:`, confirming it is indeed a decoding
    and decryption routine ([Listing 9-8](#listing9-8)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看实际的`yoop:`方法，发现调用了名为`decode:`和`AESDecryptWithPassphrase:`的方法，这证明它确实是一个解码和解密例程（[列表
    9-8](#listing9-8)）。
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 9-8: The `yoop:` method (WindTail)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-8：`yoop:`方法（WindTail）
- en: Another approach to locating decryption routines is to peruse the disassembly
    for calls into system crypto routines (like `CCCrypt`) and well-known crypto constants
    (such as AES’s `s-boxes`). In certain disassemblers, third-party plug-ins such
    as FindCrypt^([1](#c09-endnote-1)) can automate this crypto discovery process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种定位解密例程的方法是浏览反汇编代码，查找系统加密例程（如`CCCrypt`）和著名的加密常量（如AES的`s-boxes`）的调用。在某些反汇编器中，第三方插件如FindCrypt^([1](#c09-endnote-1))可以自动化这一加密发现过程。
- en: String Deobfuscation via a Hopper Script
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过Hopper脚本进行字符串去混淆
- en: The downside to the breakpoint-based approach is that it only allows you to
    recover specific decrypted strings. If an encrypted string is exclusively referenced
    in a block of code that isn’t executed, you’ll never encounter its decrypted value.
    A more comprehensive approach is to re-implement the malware’s decryption routine
    and then pass in all the malware’s encrypted strings to recover their plaintext
    values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基于断点的方法的缺点是，它仅允许你恢复特定的解密字符串。如果一个加密字符串仅在一个未执行的代码块中被引用，你将永远无法遇到它的解密值。一种更全面的方法是重新实现恶意软件的解密例程，然后传入所有恶意软件的加密字符串以恢复它们的明文值。
- en: In Chapter 6, we introduced disassemblers, highlighting how they can be leveraged
    to statically analyze compiled binaries. Such disassemblers also generally support
    external third-party scripts or plug-ins that can directly interact with a binary’s
    disassembly. This capability is extremely useful and can extend the functionality
    of a disassembler, especially in the context of overcoming malware’s anti-static-analysis
    efforts. As an example of this, we’ll create a Python-based Hopper script capable
    of decrypting all the embedded strings in a sophisticated malware sample.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在第六章中，我们介绍了反汇编器，并强调了如何利用它们对已编译的二进制文件进行静态分析。这些反汇编器通常还支持外部第三方脚本或插件，可以直接与二进制文件的反汇编进行交互。这个功能非常有用，能够扩展反汇编器的功能，特别是在克服恶意软件的反静态分析措施时。作为一个例子，我们将创建一个基于Python的Hopper脚本，能够解密复杂恶意软件样本中所有嵌入的字符串。
- en: DoubleFantasy is the notorious Equation APT Group’s first-stage implant, capable
    of surveying an infected host and installing a persistent second-stage implant
    on systems of interest. The majority of its strings are encrypted, and many remain
    encrypted even while the malware is executed unless certain prerequisites, such
    as specific tasking, are met. However, as the embedded string decryption algorithm
    is fairly simple, we can re-implement it in a Hopper Python script to decrypt
    all of the malware’s strings.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: DoubleFantasy是臭名昭著的Equation APT集团的第一阶段植入物，能够对感染的主机进行调查，并在目标系统上安装一个持久的第二阶段植入物。其大部分字符串都是加密的，许多字符串在恶意软件执行时仍然保持加密状态，除非满足某些前提条件，例如特定的任务。然而，由于嵌入的字符串解密算法相当简单，我们可以在Hopper
    Python脚本中重新实现它，以解密所有恶意软件的字符串。
- en: 'Looking at the disassembly of the DoubleFantasy malware, we can see what appears
    to be an encrypted string and its length (`0x38`) being stored to the stack prior
    to a call into an unnamed subroutine ([Listing 9-9](#listing9-9)):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察 DoubleFantasy 恶意软件的反汇编时，我们看到似乎是一个加密字符串及其长度（`0x38`）被存储到栈中，然后调用一个未命名的子程序（[列表
    9-9](#listing9-9)）：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 9-9: An encrypted string, and a call to a possible string-decryption
    function (DoubleFantasy)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-9：一个加密字符串，以及对可能的字符串解密函数（DoubleFantasy）的调用
- en: 'An examination of this subroutine reveals it decrypts a passed-in string by
    running it through a simple XOR algorithm. As shown in the following snippet of
    disassembly ([Listing 9-10](#listing9-10)), the algorithm uses two keys:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个子程序的检查表明，它通过运行一个简单的 XOR 算法来解密传入的字符串。如以下反汇编片段所示（[列表 9-10](#listing9-10)），该算法使用两个密钥：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 9-10: A simple string-decryption algorithm (DoubleFantasy)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-10：一个简单的字符串解密算法（DoubleFantasy）
- en: 'The first key is based on the values of the encrypted string itself 1, while
    the second is hardcoded to `0x47` 2. With this understanding of the malware’s
    string decryption algorithm, we can trivially re-implement it in Python ([Listing
    9-11](#listing9-11)):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个密钥基于加密字符串本身的值1，而第二个密钥硬编码为`0x47`2。了解了恶意软件的字符串解密算法后，我们可以轻松地在 Python 中重新实现它（[列表
    9-11](#listing9-11)）：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 9-11: A re-implementation of DoubleFantasy’s string decryption algorithm
    in Python'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-11：用 Python 重新实现 DoubleFantasy 的字符串解密算法
- en: In our Python re-implementation of the malware’s decryption routine, we first
    initialize both XOR keys 1. Then we simply iterate over each byte of the encrypted
    string, de-XORing each with both keys 2. The decrypted string is then returned
    3.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们用 Python 重新实现恶意软件解密例程时，我们首先初始化两个 XOR 密钥1。然后我们简单地遍历每个加密字符串的字节，使用两个密钥对其进行解
    XOR 操作2。最后，解密后的字符串被返回3。
- en: With the malware’s decryption algorithm re-implemented, we now need to invoke
    it on all of the malware’s embedded encrypted strings. Luckily, Hopper makes this
    fairly straightforward. DoubleFantasy’s encrypted strings are all stored in its
    `_cstring` segment. Using the Hopper APIs made available to any Hopper script,
    we programmatically iterate through this segment, invoking the re-implemented
    decryption algorithm on each string. We add the logic in [Listing 9-12](#listing9-12)
    to our Python code to accomplish this.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新实现恶意软件的解密算法后，我们现在需要在所有恶意软件嵌入的加密字符串上调用它。幸运的是，Hopper 使这项工作相对简单。DoubleFantasy
    的加密字符串都存储在其`_cstring`段中。通过 Hopper 提供给任何 Hopper 脚本的 API，我们可以通过编程方式遍历该段，并对每个字符串调用重新实现的解密算法。我们将[列表
    9-12](#listing9-12)中的逻辑添加到 Python 代码中来完成此任务。
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 9-12: Leveraging the Hopper API to decrypt embedded strings (DoubleFantasy)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-12：利用 Hopper API 解密嵌入字符串（DoubleFantasy）
- en: In this listing, we iterate through the `_cstring` segment and find any null-terminated
    items, which includes the malware’s embedded encrypted strings 1. For each of
    these items, we invoke our decryption function on it 2. Finally, we check if the
    item decrypted to a printable ASCII string 3. This check ensures we ignore other
    items found within the `_cstring` segment that are not encrypted strings. The
    decrypted string is then added as an inline comment directly into the disassembly,
    both at the location of the encrypted string and at any location where it is referenced
    in code to facilitate continuing analysis 4.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们遍历`_cstring`段并找到任何以空字符结尾的项，这些项包括恶意软件嵌入的加密字符串1。对于这些项，我们调用解密函数对其进行解密2。最后，我们检查该项是否解密为可打印的
    ASCII 字符串3。此检查确保我们忽略`_cstring`段中其他非加密字符串的项。解密后的字符串随后作为内联注释直接添加到反汇编中，既添加到加密字符串的位置，也添加到代码中任何引用它的地方，以便于继续分析4。
- en: After executing our decryption script in Hopper’s Script menu, the strings are
    decrypted and the disassembly is annotated. For example, as you can see in [Listing
    9-13](#listing9-13), the string `"\xDA\xB3\...\x14"` decrypts to */Library/Caches/com.apple.LaunchServices-02300.csstore*,
    which turns out to be the hardcoded path of the malware’s configuration file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hopper 的脚本菜单中执行我们的解密脚本后，字符串被解密，并且反汇编结果被注释。例如，如你在[列表 9-13](#listing9-13)中看到的，字符串`"\xDA\xB3\...\x14"`解密为*/Library/Caches/com.apple.LaunchServices-02300.csstore*，这实际上是恶意软件配置文件的硬编码路径。
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 9-13: Disassembly, now annotated with the decrypted string (DoubleFantasy)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-13：反汇编，现在已注释解密字符串（DoubleFantasy）
- en: Forcing the Malware to Execute Its Decryption Routine
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制恶意软件执行其解密例程
- en: Creating disassembly scripts to facilitate analysis is a powerful approach.
    However, in the context of string decryptions, it requires that you both fully
    understand the decryption algorithm and are capable of re-implementing it. This
    can often be a time-consuming endeavor. In this section we’ll look at a potentially
    more efficient approach, especially for samples that implement complex decryption
    algorithms.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建反汇编脚本以促进分析是一种强有力的方法。然而，在字符串解密的上下文中，这要求你不仅要完全理解解密算法，还要能够重新实现它。这通常是一项耗时的工作。在本节中，我们将讨论一种可能更高效的方法，尤其适用于那些实现了复杂解密算法的样本。
- en: A malware specimen is almost certainly designed to decrypt all its strings;
    we just need a way to convince the malware to do so. Turns out this isn’t too
    hard. In fact, if we create a dynamic library and inject it into the malware,
    this library can then directly invoke the malware’s string decryption routine
    for all encrypted strings, all without having to understand the internals of the
    decryption algorithm. Let’s walk through this process using the EvilQuest malware
    as our target.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件样本几乎肯定被设计为解密其所有字符串；我们只需要找到一种方法来说服恶意软件执行此操作。事实证明，这并不难。实际上，如果我们创建一个动态库并将其注入到恶意软件中，这个库就可以直接调用恶意软件的字符串解密例程来解密所有加密的字符串，而无需理解解密算法的内部实现。让我们通过以
    EvilQuest 恶意软件为目标，来演示这个过程。
- en: 'First, we note that EvilQuest’s binary, named *patch*, appears to contain many
    obfuscated strings ([Listing 9-14](#listing9-14)):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们注意到 EvilQuest 的二进制文件名为 *patch*，似乎包含了许多混淆的字符串（[清单 9-14](#listing9-14)）：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 9-14: Obfuscated strings (EvilQuest)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-14：混淆的字符串（EvilQuest）
- en: 'Statically analyzing EvilQuest for a function that takes the obfuscated strings
    as input quickly reveals the malware’s deobfuscation (decryption) logic, found
    in a function named `ei_str` ([Listing 9-15](#listing9-15)):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析 EvilQuest 中一个接受混淆字符串作为输入的函数，很容易揭示出恶意软件的去混淆（解密）逻辑，该逻辑位于名为 `ei_str` 的函数中（[清单
    9-15](#listing9-15)）：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 9-15: Invocation of a deobfuscation function, `ei_str` (EvilQuest)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-15：调用去混淆函数 `ei_str`（EvilQuest）
- en: The `ei_str` function is rather long and complicated, so instead of trying to
    decrypt the strings solely via a static analysis approach, we’ll opt for a dynamic
    approach. Moreover, as many of the strings are only deobfuscated at runtime under
    certain circumstances, such as when a specific command is received, we’ll inject
    a custom library into the code instead of leveraging a debugger.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ei_str` 函数相当长且复杂，因此我们不会仅通过静态分析方法来尝试解密这些字符串，而是选择动态方法。此外，由于许多字符串只有在运行时在特定情况下才会被去混淆，例如接收到特定命令时，我们将注入一个自定义库，而不是利用调试器。'
- en: Our custom injectable library will perform two tasks. First, within a running
    instance of the malware, it will resolve the address of the deobfuscation function,
    `ei_str`. Then it will invoke the `ei_str` function for all encrypted strings
    found embedded within the malware’s binary. Because we place this logic in the
    constructor of the dynamic library, it will be executed when the library is loaded,
    well before the malware’s own code is run.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自定义的可注入库将执行两个任务。首先，在运行中的恶意软件实例内，它将解析去混淆函数 `ei_str` 的地址。然后，它将调用 `ei_str` 函数来解密恶意软件二进制中嵌入的所有加密字符串。由于我们将此逻辑放在动态库的构造函数中，它将在库加载时执行，远早于恶意软件自身的代码运行。
- en: '[Listing 9-16](#listing9-16) shows the code we’ll write for the constructor
    of the injectable dynamic decryptor library:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-16](#listing9-16)展示了我们为注入的动态解密库的构造函数编写的代码：'
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 9-16: Our dynamic string deobfuscator library (EvilQuest)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-16：我们的动态字符串去混淆库（EvilQuest）
- en: 'The library code scans over the malware’s entire `__cstring` segment, which
    contains all the obfuscated strings. For each string, it invokes the malware’s
    own `ei_str` function to deobfuscate the string. Once it’s compiled (`% clang
    decryptor.m -dynamiclib -framework Foundation -o decryptor.dylib`), we can coerce
    the malware to load our decryptor library via the `DYLD_INSERT_LIBRARIES` environment
    variable. In the terminal of a virtual machine, we can execute the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该库代码扫描恶意软件的整个 `__cstring` 段，其中包含了所有混淆的字符串。对于每个字符串，它调用恶意软件自己的 `ei_str` 函数来去混淆该字符串。编译后（`%
    clang decryptor.m -dynamiclib -framework Foundation -o decryptor.dylib`），我们可以通过
    `DYLD_INSERT_LIBRARIES` 环境变量强制恶意软件加载我们的解密库。在虚拟机的终端中，我们可以执行以下命令：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once loaded, the library’s code is automatically invoked and coerces the malware
    to decrypt all its strings ([Listing 9-17](#listing9-17)):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载，库的代码会自动被调用并强迫恶意软件解密其所有字符串（[清单 9-17](#listing9-17)）：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 9-17: Deobfuscated strings (EvilQuest)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-17：去混淆的字符串（EvilQuest）
- en: The decrypted output (abridged) reveals informative strings that appear to show
    a potential command and control server, files of interest, and a template for
    launch item persistence.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 解密后的输出（简化版）揭示了信息性字符串，似乎显示了一个潜在的命令和控制服务器、感兴趣的文件以及启动项持久化的模板。
- en: 'If the malware is compiled with a hardened runtime, the dynamic loader will
    ignore the `DYLD_INSERT_LIBRARIES` variable and fail to load our deobfuscator.
    To bypass this protection, you can first disable System Integrity Protection (SIP)
    and then execute the following command to set the `amfi_get_out_of_my_way` boot
    argument and then reboot your analysis system (or virtual machine):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恶意软件使用加固的运行时进行编译，动态加载器将忽略 `DYLD_INSERT_LIBRARIES` 变量，无法加载我们的去混淆器。为了绕过这个保护，您可以首先禁用系统完整性保护（SIP），然后执行以下命令设置
    `amfi_get_out_of_my_way` 启动参数，并重新启动您的分析系统（或虚拟机）：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For more information on this topic, see “How to Inject Code into Mach-O Apps,
    Part II.”^([2](#c09-endnote-2))
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参见“如何将代码注入 Mach-O 应用程序，第二部分。”^([2](#c09-endnote-2))
- en: Code-Level Obfuscations
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码级混淆
- en: To further protect their creations from analysis, malware authors may also turn
    toward broader code-level obfuscations. For malicious scripts, which are otherwise
    easy to analyze, as they are not compiled into binary code, this sort of obfuscation
    is quite common. As we discussed in Chapter 4, we can often leverage tools such
    as beautifiers to improve the readability of obfuscated scripts. Obfuscated Mach-O
    binaries are somewhat less common, but we’ll look at several examples of this
    technique.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步保护其创作不被分析，恶意软件作者还可能采用更广泛的代码级混淆技术。对于那些容易分析的恶意脚本（因为它们并未被编译成二进制代码），这种混淆技术相当常见。正如我们在第
    4 章中讨论的那样，我们通常可以利用诸如美化工具之类的工具来提高混淆脚本的可读性。混淆的 Mach-O 二进制文件虽然稍微少见，但我们会看看这种技术的几个例子。
- en: 'One such obfuscation method involves adding *spurious*, or *garbage*, instructions
    at compile time. These instructions are essentially non-operations (NOPs) and
    have no impact on the core functionality of the malware. However, when spread
    effectively throughout the binary, they can mask the malware’s real instructions.
    The prolific Pirrit malware provides an example of such binary obfuscation. To
    hinder static analysis and hide other logic aimed at preventing dynamic analysis,
    its authors added large amounts of garbage instructions. In the case of Pirrit,
    these instructions make up either calls into system APIs (whose results are ignored),
    bogus control flow blocks, or inconsequential modifications to unused memory.
    The following is an example of the former, in which we see the `dlsym` API being
    invoked. This API is normally invoked to dynamically resolve the address of a
    function by name. In [Listing 9-18](#listing9-18), the decompiler has determined
    the results are unused:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一种混淆方法是在编译时添加*虚假*或*垃圾*指令。这些指令本质上是空操作（NOPs），对恶意软件的核心功能没有任何影响。然而，当它们有效地分布在二进制文件中时，可以掩盖恶意软件的真实指令。盛行的
    Pirrit 恶意软件就是这种二进制混淆的一个例子。为了阻碍静态分析并隐藏其他旨在防止动态分析的逻辑，它的作者添加了大量垃圾指令。以 Pirrit 为例，这些指令包括调用系统
    API（其结果被忽略）、虚假的控制流块，或对未使用的内存做出无关紧要的修改。以下是前者的一个例子，我们看到 `dlsym` API 被调用。这个 API 通常用于通过名称动态解析函数的地址。在
    [清单 9-18](#listing9-18) 中，反编译器已经确定结果没有被使用：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 9-18: Spurious function calls (Pirrit)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-18：虚假的函数调用（Pirrit）
- en: 'Elsewhere in Pirrit’s decompilation, we find spurious code control blocks whose
    logic is not relevant to the core functionality of the malware. Take, for instance,
    [Listing 9-19](#listing9-19), which contains several pointless comparisons of
    the `RAX` register. (The final check can only evaluate to true if `RAX` is equal
    to `0x6b1464f0`, so the first two checks are entirely unnecessary.) Following
    this is a large sequence of instructions that modify a section of the binary’s
    memory, which is otherwise unused:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pirrit 的反编译过程中，我们发现了虚假的代码控制块，其逻辑与恶意软件的核心功能无关。例如，参见 [清单 9-19](#listing9-19)，其中包含了对
    `RAX` 寄存器的几次毫无意义的比较。（最后的检查只有当 `RAX` 等于 `0x6b1464f0` 时才会为真，因此前两个检查完全没有必要。）接下来是一大段指令，它们修改了二进制文件中的一块内存区域，而这块内存本来并未被使用：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 9-19: Spurious instructions (Pirrit)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-19：虚假的指令（Pirrit）
- en: In almost every subroutine in Pirrit’s disassembly, we find massive amounts
    of such garbage instructions. Though they do slow down our analysis and initially
    mask the malware’s true logic, once we understand their purpose, we can simply
    ignore them and scroll past. For more information on this and other similar obfuscation
    schemes, you can read “Using LLVM to Obfuscate Your Code During Compilation.”^([3](#c09-endnote-3))
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pirrit的反汇编代码中的几乎每个子程序里，我们都能发现大量这样的垃圾指令。虽然这些指令确实会拖慢我们的分析过程，并且最初会掩盖恶意软件的真实逻辑，但一旦我们理解它们的用途，就可以忽略它们并快速跳过。有关此类混淆方案的更多信息，可以阅读《使用LLVM在编译期间混淆你的代码》。^([3](#c09-endnote-3))
- en: Bypassing Packed Binary Code
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绕过打包的二进制代码
- en: Another common way to obfuscate binary code is with a packer. In a nutshell,
    a *packer* compresses binary code to prevent its static analysis while also inserting
    a small unpacker stub at the entry point of the binary. As the unpacker stub is
    automatically executed when the packed program is launched, the original code
    is restored in memory and then executed, retaining the binary’s original functionality.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的二进制代码混淆方式是使用打包器。简而言之，*打包器*通过压缩二进制代码来防止其静态分析，同时在二进制文件的入口点插入一个小的解包程序存根。由于当打包程序启动时解包程序存根会自动执行，原始代码会被恢复到内存中并随后执行，从而保留二进制文件的原始功能。
- en: Packers are payload-agnostic and thus can generally pack any binary. This means
    that legitimate software can also be packed, as software developers occasionally
    seek to thwart analysis of their proprietary code. Thus, we can’t assume any packed
    binary is malicious without further analysis.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 打包器与有效载荷无关，因此通常可以打包任何二进制文件。这意味着合法的软件也可以被打包，因为软件开发者有时会寻求阻止对其专有代码的分析。因此，我们不能在没有进一步分析的情况下假设任何被打包的二进制文件都是恶意的。
- en: The well-known UPX packer is a favorite among both Windows and macOS malware
    authors.^([4](#c09-endnote-4)) Luckily, unpacking UPX-packed files is easy. You
    can simply execute UPX with the `-d` command line flag ([Listing 9-20](#listing9-20)).
    If you’d like to write the unpacked binary to a new file, use the `-o` flag as
    well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 广为人知的UPX打包器深受Windows和macOS恶意软件作者的喜爱。^([4](#c09-endnote-4)) 幸运的是，解包UPX打包的文件很简单。你只需要执行UPX并加上`-d`命令行标志（[Listing
    9-20](#listing9-20)）。如果你希望将解包后的二进制文件写入到一个新文件，可以同时使用`-o`标志。
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 9-20: Unpacking via UPX (ColdRoot)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-20：通过UPX解包（ColdRoot）
- en: 'As you can see, we’ve unpacked a UPX-packed variant: the malware known as ColdRoot.
    Once it’s unpacked and decompressed, we can commence static and dynamic analysis.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经解包了一个UPX压缩的变种：被称为ColdRoot的恶意软件。一旦解包并解压缩完毕，我们就可以开始静态和动态分析。
- en: 'Here is a valid question: How did we know the sample was packed? And how did
    we know it was packed with UPX specifically? One semiformal approach to figuring
    out which binaries are packed is to calculate the *entropy* (amount of randomness)
    of the binary to detect the packed segments, which will have a much higher level
    of randomness than normal binary instructions. I’ve added code to the Objective-See
    TaskExplorer utility to generically detect packed binaries in this manner.^([5](#c09-endnote-5))'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个合理的问题：我们怎么知道这个样本是被打包的？又怎么知道它是用UPX打包的呢？一种半正式的方法来判断哪些二进制文件是被打包的，就是计算二进制文件的*熵*（随机性大小），从而检测出打包的部分，这些部分的随机性远高于正常的二进制指令。我已经在Objective-See的TaskExplorer工具中加入了代码，能够以这种方式通用地检测被打包的二进制文件。^([5](#c09-endnote-5))
- en: 'A less formal approach is to leverage the `strings` command or load the binary
    in your disassembler of choice and peruse the code. With experience, you’ll be
    able to infer that a binary is packed if you observe the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一种不那么正式的方法是使用`strings`命令，或将二进制文件加载到你选择的反汇编工具中，浏览代码。凭借经验，你将能够推断出二进制文件是否被打包，如果你观察到以下内容：
- en: Unusual section names
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不寻常的段名
- en: A majority of strings obfuscated
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大部分字符串被混淆
- en: Large chunks of executable code that cannot be disassembled
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法反汇编的大块可执行代码
- en: A low number of imports (references to external APIs)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较少的导入（对外部API的引用）
- en: Unusual section names are an especially good indicator, as they can also help
    identify the packer used to compress the binary. For example, UPX adds a section
    named `__XHDR`, which you can see in the output of the `strings` command or in
    a Mach-O viewer ([Figure 9-3](#figure9-3)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不寻常的段名是一个特别好的指标，因为它们也有助于识别用于压缩二进制文件的打包工具。例如，UPX会添加一个名为`__XHDR`的段，你可以在`strings`命令的输出或在Mach-O查看器中看到它（[Figure
    9-3](#figure9-3)）。
- en: '![In com.apple.audio.driver, Executable (x86) contains Mach Header, Load Commands,
    Section (_XHDR,_xhdr), and Section (_TEXT,_text).](image_fi/501942c09/f09003.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![在 com.apple.audio.driver 中，执行文件（x86）包含 Mach Header、Load Commands、Section
    (_XHDR,_xhdr) 和 Section (_TEXT,_text)。](image_fi/501942c09/f09003.png)'
- en: 'Figure 9-3: UPX section header (ColdRoot)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：UPX 区段头（ColdRoot）
- en: 'It is worth noting that UPX is an exception among packers in the sense that
    it can unpack any UPX-packed binary. More sophisticated malware may leverage custom
    packers, which may mean that you have no unpacking utility available. Not to worry:
    if you encounter a packed binary and have no utility to unpack it, a debugger
    may be your best bet. The idea is simple: run the packed sample under the watchful
    eye of a debugger, and once the unpacker stub has executed, dump the unprotected
    binary from memory with the `memory read` LLDB command.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，UPX 在压缩工具中是一个例外，因为它可以解压任何 UPX 压缩的二进制文件。更复杂的恶意软件可能会利用定制的压缩工具，这可能意味着你没有可用的解压工具。别担心：如果你遇到一个压缩的二进制文件且没有解压工具，一个调试器可能是你最好的选择。这个方法很简单：在调试器的监控下运行压缩样本，一旦解压器存根执行完毕，就用
    `memory read` LLDB 命令从内存中提取未加密的二进制文件。
- en: For another thorough discussion of both analyzing other packers (such as MPRESS)
    and the process of dumping a packed binary from memory, see Pedro Vilaça’s informative
    2014 talk, “F*ck You HackingTeam.”^([6](#c09-endnote-6))
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有关分析其他压缩工具（如 MPRESS）和从内存中提取压缩二进制文件过程的详细讨论，请参见 Pedro Vilaça 2014 年的精彩讲座，“F*ck
    You HackingTeam”。^([6](#c09-endnote-6))
- en: Decrypting Encrypted Binaries
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解密加密的二进制文件
- en: Similar to packers are *binary encryptors*, which encrypt the original malware
    code at the binary level. To automatically decrypt the malware at runtime, the
    encryptor will often insert a decryptor stub and keying information at the start
    of the binary unless the operating system natively supports encrypted binaries,
    which macOS does. As noted, the infamous HackingTeam is fond of packers and encryptors.
    In the blog post “HackingTeam Reborn . . .” I noted that the installer for the
    HackingTeam’s macOS implant, RCS, leveraged Apple’s proprietary and undocumented
    Mach-O encryption scheme in an attempt to thwart static analysis.^([7](#c09-endnote-7))
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于压缩工具的是 *二进制加密器*，它在二进制级别加密原始恶意代码。为了在运行时自动解密恶意软件，加密器通常会在二进制文件的开头插入解密存根和密钥信息，除非操作系统本身支持加密的二进制文件，而
    macOS 就支持。如前所述，臭名昭著的 HackingTeam 喜欢使用压缩工具和加密器。在博客文章《HackingTeam 重生...》中，我提到 HackingTeam
    的 macOS 植入程序 RCS 的安装程序利用了 Apple 专有且未公开的 Mach-O 加密方案，试图阻止静态分析。^([7](#c09-endnote-7))
- en: Let’s take a closer look at how to decrypt binaries, such as HackingTeam’s installer,
    that have been protected via this method. In macOS’s open source Mach-O loader,
    we find an `LC_SEGMENT` flag value named `SG_PROTECTED_VERSION_1` whose value
    is `0x8`:^([8](#c09-endnote-8))
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看如何解密通过这种方法保护的二进制文件，例如 HackingTeam 的安装程序。在 macOS 开源的 Mach-O 加载器中，我们找到了一个名为
    `SG_PROTECTED_VERSION_1` 的 `LC_SEGMENT` 标志，其值为 `0x8`：^([8](#c09-endnote-8))
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Comments show that this flag specifies that a Mach-O segment is encrypted (or
    “protected,” in Apple parlance). Via `otool`, we can parse the embedded Mach-O
    loader commands in HackingTeam’s installer and note that, indeed, the flag’s value
    within the `__TEXT` segment (the segment that contains the binary’s executable
    instructions) is set to the value of `SG_PROTECTED_VERSION_1` ([Listing 9-21](#listing9-21)):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注释显示，这个标志指定了一个 Mach-O 区段是加密的（或者用 Apple 的术语来说是“受保护的”）。通过 `otool`，我们可以解析 HackingTeam
    安装程序中嵌入的 Mach-O 加载器命令，并注意到，确实，在 `__TEXT` 区段中（包含二进制执行指令的区段），该标志的值被设置为 `SG_PROTECTED_VERSION_1`
    的值（[Listing 9-21](#listing9-21)）：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 9-21: An encrypted installer; note that the `flags` field is set to
    `0x8`, `SG_PROTECTED_VERSION_1` (HackingTeam)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-21：一个加密的安装程序；注意 `flags` 字段被设置为 `0x8`，`SG_PROTECTED_VERSION_1`（HackingTeam）
- en: 'From the macOS loader’s source code, we can see that the `load_segment` function
    checks the value of this flag.^([9](#c09-endnote-9)) If the flag is set, the loader
    will invoke a function named `unprotect_dsmos_segment` to decrypt the segment,
    as in [Listing 9-22](#listing9-22):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从 macOS 加载器的源代码中，我们可以看到 `load_segment` 函数会检查这个标志的值。^([9](#c09-endnote-9)) 如果该标志被设置，加载器将调用一个名为
    `unprotect_dsmos_segment` 的函数来解密该段，如 [Listing 9-22](#listing9-22) 所示：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 9-22: macOS’s support of encrypted Mach-O binaries'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-22：macOS 对加密 Mach-O 二进制文件的支持
- en: Continued analysis reveals that the encryption scheme is symmetric (either Blowfish
    or AES) and uses a static key that is stored within the Mac’s System Management
    Controller. As such, we can write a utility to decrypt any binary protected in
    this manner. For more discussion of this macOS encryption scheme, see Erik Pistelli’s
    blog post “Creating undetected malware for OS X.”^([10](#c09-endnote-10))
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 继续分析发现，加密方案是对称的（使用Blowfish或AES），并且使用一个静态密钥，该密钥存储在Mac的系统管理控制器中。因此，我们可以编写一个工具来解密任何以这种方式保护的二进制文件。有关这个macOS加密方案的更多讨论，请参见Erik
    Pistelli的博客文章“为OS X创建未被检测的恶意软件”。^([10](#c09-endnote-10))
- en: 'Another option for recovering the malware’s unencrypted instructions is to
    dump the unprotected binary code from memory once the decryption code has executed.
    For this specific malware specimen, its unencrypted code can be found from address
    `0x7000` to `0xbffff`. The following debugger command will save its unencrypted
    code to disk for static analysis:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复恶意软件未加密指令的另一个方法是，在解密代码执行后，从内存中转储未保护的二进制代码。对于这个特定的恶意软件样本，其未加密的代码可以在地址`0x7000`到`0xbffff`之间找到。以下调试器命令将把未加密的代码保存到磁盘上，供静态分析使用：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that due to the large memory range, the `--force` flag must be specified
    as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于内存范围较大，必须指定`--force`标志。
- en: I’ve shown that dynamic analysis environments and tools are generally quite
    successful against anti-static-analysis approaches. As a result, malware authors
    also seek to detect and thwart dynamic analysis.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经展示了，动态分析环境和工具通常能够成功应对反静态分析方法。因此，恶意软件作者也会试图检测并阻止动态分析。
- en: Anti-Dynamic-Analysis Approaches
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反动态分析方法
- en: Malware authors are well aware that analysts often turn to dynamic analysis
    as an effective means to bypass anti-analysis logic. Thus, malware often contains
    code that attempts to detect whether it is executing in a dynamic analysis environment
    like a virtual machine or within a dynamic analysis tool like a debugger.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者深知，分析人员通常会利用动态分析作为绕过反分析逻辑的有效手段。因此，恶意软件常常包含一些代码，尝试检测它是否在动态分析环境中执行，比如虚拟机或调试工具。
- en: 'Malware may leverage several common approaches to detecting dynamic analysis
    environments and tools:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可能利用几种常见的方法来检测动态分析环境和工具：
- en: '**Virtual machine detection**: Often, malware analysts will execute the suspected
    malicious code within an isolated virtual machine in order to monitor it or perform
    dynamic analysis. Malware, therefore, is probably right to assume that if it finds
    itself executing within a virtual machine, it is likely being closely watched
    or dynamically analyzed. Thus, malware often seeks to detect if it’s running in
    a virtualized environment. Generally, if it detects such an environment, it simply
    exits.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟机检测**：通常，恶意软件分析人员会在一个隔离的虚拟机中执行可疑的恶意代码，以便监控它或进行动态分析。因此，恶意软件可能认为，如果它发现自己在虚拟机中执行，它可能正被密切监控或进行动态分析。因此，恶意软件常常试图检测自己是否在虚拟化环境中运行。一般来说，如果它检测到这种环境，它会直接退出。'
- en: '**Analysis tool detection/prevention**: Malware may query its execution environment
    in an attempt to detect dynamic analysis tools, such as a debugger. If a malware
    specimen detects itself running in a debugging session, it can conclude with a
    high likelihood that it is being closely analyzed by a malware analyst. In an
    attempt to prevent analysis, it will likely prematurely exit. Alternatively, it
    might attempt to prevent debugging in the first place.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析工具检测/防止**：恶意软件可能会查询其执行环境，试图检测动态分析工具，如调试器。如果一个恶意样本发现自己在调试会话中运行，它可能会高概率地判断自己正被恶意软件分析人员密切分析。为了防止分析，它可能会提前退出。或者，它可能会尝试从一开始就阻止调试。'
- en: How can we figure out whether a malicious specimen contains anti-analysis logic
    to thwart dynamic analysis? Well, if you’re attempting to dynamically analyze
    a malicious sample in a virtual machine or debugger, and the sample prematurely
    exits, this may be a sign that it implements anti-analysis logic. (Of course,
    there are other reasons malware might exit; for example, it might detect that
    its command and control server is offline.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎么知道一个恶意样本是否包含反分析逻辑来阻止动态分析呢？如果你在虚拟机或调试器中尝试动态分析一个恶意样本，而该样本提前退出了，这可能是它实现了反分析逻辑的标志。（当然，恶意软件退出也可能有其他原因；例如，它可能检测到其指挥与控制服务器处于离线状态。）
- en: If you suspect that the malware contains such logic, the first goal should be
    to uncover the specific code that is responsible for this behavior. Once you’ve
    identified it, you can bypass this code by patching it out or simply skipping
    it in a debugger session. One effective way to uncover a sample’s anti-analysis
    code is using static analysis, which means you have to know what this anti-analysis
    logic might look like. The following sections describe various programmatic methods
    that malware can leverage to detect if it is executing within a virtual machine
    or a debugger. Recognizing these approaches is important, as many are widespread
    and found within unrelated Mac malware specimens.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑恶意软件包含这种逻辑，首要目标应该是揭示出负责这种行为的具体代码。一旦你识别出来，你可以通过修补代码或在调试会话中简单地跳过它来绕过这段代码。揭示样本反分析代码的一种有效方法是使用静态分析，这意味着你必须了解这种反分析逻辑可能的样子。以下部分将描述恶意软件可以利用的多种程序化方法，用于检测它是否在虚拟机或调试器中执行。识别这些方法非常重要，因为许多方法广泛存在，并且在无关的Mac恶意软件样本中也能找到。
- en: Checking the System Model Name
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查系统型号名称
- en: 'Malware may check if it’s running within a virtual machine by querying the
    machine’s name. The macOS ransomware named MacRansom performs such a check. Take
    a look at the following snippet of decompiled code, which corresponds to the malware’s
    anti-virtual-machine check. Here, after decoding a command, the malware invokes
    the `system` API to execute it. If the API returns a nonzero value, the malware
    will prematurely exit ([Listing 9-23](#listing9-23)):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可能通过查询机器的名称来检查它是否在虚拟机中运行。名为MacRansom的macOS勒索病毒就执行了这样的检查。请看一下下面的反编译代码片段，它对应于恶意软件的反虚拟机检查。在这里，恶意软件在解码一个命令后，调用`system`
    API来执行它。如果API返回一个非零值，恶意软件将提前退出（[清单 9-23](#listing9-23)）：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 9-23: Obfuscated anti-VM logic (MacRansom)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-23：混淆的反虚拟机逻辑（MacRansom）
- en: 'To uncover the command executed by the malware, we can leverage a debugger.
    Specifically, by setting a breakpoint on the `system` API function, we can dump
    the decoded command. As it is passed as an argument to `system`, as shown in the
    debugger output in [Listing 9-24](#listing9-24), this command can be found in
    the `RDI` register:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了揭示恶意软件执行的命令，我们可以利用调试器。具体来说，通过在`system` API函数上设置断点，我们可以转储解码后的命令。正如在[清单 9-24](#listing9-24)的调试器输出中所示，这个命令作为参数传递给`system`，可以在`RDI`寄存器中找到：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 9-24: Deobfuscated anti-VM command (MacRansom)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-24：去混淆的反虚拟机命令（MacRansom）
- en: 'Turns out the command 1 first retrieves the system’s model name from `hw.model`
    and then checks to see if it contains the string `Mac`. In a virtual machine,
    this command will return a nonzero value, as the value for `hw.model` will not
    contain `Mac` but rather something similar to `VMware7,1` ([Listing 9-25](#listing9-25)):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，命令1首先从`hw.model`检索系统的型号名称，然后检查它是否包含字符串`Mac`。在虚拟机中，这个命令将返回一个非零值，因为`hw.model`的值将不包含`Mac`，而是类似于`VMware7,1`的内容（[清单
    9-25](#listing9-25)）：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 9-25: System’s hardware model (in a virtual machine)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-25：系统的硬件型号（在虚拟机中）
- en: 'On native hardware (outside of a virtual machine), the `sysctl hw.model` command
    will return a string containing `Mac` and the malware will not exit ([Listing
    9-26](#listing9-26)):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地硬件上（虚拟机外），`sysctl hw.model`命令将返回一个包含`Mac`的字符串，恶意软件将不会退出（[清单 9-26](#listing9-26)）：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 9-26: System’s hardware model (on native hardware)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-26：系统的硬件型号（在本地硬件上）
- en: Counting the System’s Logical and Physical CPUs
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 统计系统的逻辑和物理CPU数量
- en: 'MacRansom contains another check to see if it is running in a virtual machine.
    Again, the malware decodes a command, executes it via the `system` API, and prematurely
    exits if the return value is nonzero. Here is the command it executes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: MacRansom包含另一个检查，看看它是否在虚拟机中运行。再次，恶意软件解码一个命令，通过`system` API执行它，并在返回值非零时提前退出。它执行的命令如下：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This command checks the number of logical CPUs divided by the number of physical
    CPUs on the system where the malware is executing. On a virtual machine, this
    value is often just `1`. If it isn’t `2`, the malware will exit. On native hardware,
    dividing the number of logical CPUs by the number of physical CPUs will often
    (but not always!) result in a value of 2, in which case the malware will happily
    continue executing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令检查恶意软件执行所在系统的逻辑CPU数量与物理CPU数量的比值。在虚拟机中，这个值通常为`1`。如果不是`2`，恶意软件将退出。在本地硬件上，逻辑CPU数量与物理CPU数量的比值通常（但不总是！）为2，这时恶意软件会愉快地继续执行。
- en: Checking the System’s MAC Address
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查系统的MAC地址
- en: Another Mac malware sample that contains code to detect if it is running in
    a virtual machine is Mughthesec, which masquerades as an Adobe Flash installer.
    If it detects that it is running within a virtual machine, the installer doesn’t
    do anything malicious; it merely installs a legitimate copy of Flash. Security
    researcher Thomas Reed noted that this virtual machine detection is done by examining
    the system’s MAC address.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个包含用于检测是否在虚拟机中运行的代码的 macOS 恶意软件样本是 Mughthesec，它伪装成 Adobe Flash 安装程序。如果检测到它正在虚拟机中运行，安装程序不会执行任何恶意操作；它只会安装一个合法的
    Flash 版本。安全研究人员 Thomas Reed 指出，这种虚拟机检测是通过检查系统的 MAC 地址完成的。
- en: 'If we disassemble the malicious installer, we find the snippet of code responsible
    for retrieving the system’s MAC address via the I/O registry ([Listing 9-27](#listing9-27)):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们反汇编恶意安装程序，我们会找到负责通过 I/O 注册表检索系统 MAC 地址的代码片段（[列表 9-27](#listing9-27)）。
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 9-27: Retrieving the primary MAC address (Mughthesec)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 9-27: 检索主要 MAC 地址 (Mughthesec)'
- en: The malware first creates an iterator containing the primary Ethernet interface
    by invoking APIs such as `IOServiceMatching` with the string `"IOEthernetInterface"`
    1. Using this iterator, it then retrieves the MAC address 2. Note that this code
    is rather similar to Apple’s “GetPrimaryMACAddress” sample code, which demonstrates
    how to programmatically retrieve the device’s primary MAC address.^([11](#c09-endnote-11))
    This is not surprising, as malware authors often consult (or even copy and paste)
    Apple’s sample code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先通过调用 `IOServiceMatching` API 并使用字符串 `"IOEthernetInterface"` 来创建一个包含主要以太网接口的迭代器。通过这个迭代器，它然后检索
    MAC 地址。注意，这段代码与苹果的“GetPrimaryMACAddress”示例代码非常相似，该示例演示了如何以编程方式检索设备的主要 MAC 地址。^([11](#c09-endnote-11))
    这并不奇怪，因为恶意软件作者经常参考（甚至复制粘贴）苹果的示例代码。
- en: 'MAC addresses contain an *organizationally unique identifier (OUI)* that maps
    to a specific vendor. If malware detects a MAC address with an OUI matching a
    virtual machine vendor such as VMware, it knows it is running within a virtual
    machine. Vendors’ OUIs can be found online, such as on company websites. For example,
    online documentation found at [https://docs.vmware.com/](https://docs.vmware.com/)
    notes that VMware’s OUI ranges include `00:50:56` and `00:0C:29`, meaning that
    for the former, VMware VMs will contain MAC addresses in the following format:
    `00:50:56:XX:YY:ZZ`.^([12](#c09-endnote-12))'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: MAC 地址包含一个 *组织唯一标识符 (OUI)*，它映射到特定的供应商。如果恶意软件检测到具有与虚拟机供应商（如 VMware）匹配的 OUI 的
    MAC 地址，则知道它正在虚拟机中运行。供应商的 OUI 可以在网上找到，例如在公司的网站上。例如，在 [https://docs.vmware.com/](https://docs.vmware.com/)
    找到的在线文档指出，VMware 的 OUI 范围包括 `00:50:56` 和 `00:0C:29`，这意味着对于前者，VMware VM 的 MAC 地址将具有以下格式：`00:50:56:XX:YY:ZZ`。^([12](#c09-endnote-12))
- en: 'Of course, there are a myriad of other ways for malware to programmatically
    detect if it is executing within a virtual machine. For a fairly comprehensive
    list of such methods, see “Evasions: macOS.”^([13](#c09-endnote-13))'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '当然，恶意软件还有很多其他方法可以编程性地检测它是否在虚拟机中执行。有关这些方法的相当全面列表，请参见“逃避: macOS”。^([13](#c09-endnote-13))'
- en: Checking System Integrity Protection Status
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查系统完整性保护状态
- en: Of course, not all analysis is done within virtual machines. Many malware analysts
    leverage dedicated analysis machines to dynamically analyze malicious code. In
    this scenario, as the analysis is performed on native hardware, anti-analysis
    logic that is based on detecting virtual machines is useless. Instead, malware
    must look for other indicators to determine if it’s running within an analysis
    environment. One such approach is to check the status of *System Integrity Protection
    (SIP)*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非所有分析都在虚拟机中进行。许多恶意软件分析人员利用专用分析机动态分析恶意代码。在这种情况下，由于分析是在本机硬件上执行的，基于检测虚拟机的反分析逻辑是无效的。相反，恶意软件必须寻找其他指标来确定它是否在分析环境中运行。其中一种方法是检查
    *系统完整性保护 (SIP)* 的状态。
- en: 'SIP is a built-in macOS protection mechanism that, among other things, may
    prevent the debugging of processes. Malware analysts, who often require the ability
    to debug any and all processes, will often disable SIP on their analysis machines.
    The prolific Pirrit malware leverages this fact to check whether it’s likely running
    on an analysis system. Specifically, it will execute macOS’s `csrutil` command
    to determine the status of SIP. We can observe this passively via a process monitor,
    or more directly in a debugger. In the case of the latter, we can break on a call
    to the `NSConcreteTask`’s `launch` method and dump the launch path and arguments
    of the task object (found in the `RDI` register), as shown in [Listing 9-28](#listing9-28):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: SIP 是 macOS 内建的保护机制，其中之一是可能阻止进程调试。恶意软件分析师通常需要能够调试所有进程，因此他们常常会在分析机器上禁用 SIP。广泛传播的
    Pirrit 恶意软件利用这一点来检查它是否可能在分析系统上运行。具体来说，它会执行 macOS 的 `csrutil` 命令来确定 SIP 的状态。我们可以通过进程监视器被动地观察到这一点，或者通过调试器更直接地观察到。在后者的情况下，我们可以在调用
    `NSConcreteTask` 的 `launch` 方法时设置断点，并转储任务对象的启动路径和参数（可以在 `RDI` 寄存器中找到），如 [Listing
    9-28](#listing9-28) 所示：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 9-28: Retrieving the System Integrity Protection status (Pirrit)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-28：检索系统完整性保护状态（Pirrit）
- en: From the debugger output, we can confirm that indeed the malware is executing
    the `csrutil` command (via the shell, `/bin/sh`) with the `status` flag. The output
    of this command is passed to `grep` to check if SIP is still enabled. If SIP has
    been disabled, the malware will prematurely exit in an attempt to prevent continued
    dynamic analysis.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从调试器的输出中，我们可以确认恶意软件确实在执行 `csrutil` 命令（通过 shell，`/bin/sh`）并带有 `status` 标志。该命令的输出被传递给
    `grep` 以检查 SIP 是否仍然启用。如果 SIP 被禁用，恶意软件将提前退出，试图阻止持续的动态分析。
- en: Detecting or Killing Specific Tools
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测或终止特定工具
- en: Malware might also contain anti-analysis code to detect and thwart dynamic analysis
    tools. As you’ll see, this code usually focuses on debugger detection, but some
    malware specimens will also take into account other analysis or security tools
    that might detect the malware and alert the user, which is something malware often
    seeks to avoid at all costs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件也可能包含反分析代码来检测并阻止动态分析工具。如你所见，这段代码通常专注于调试器检测，但某些恶意软件样本还会考虑到其他可能检测到恶意软件并提醒用户的分析或安全工具，这是恶意软件往往会竭尽全力避免的事情。
- en: 'A variant of the malware known as Proton looks for specific security tools.
    When executed, the Proton installer will query the system to see if any third-party
    firewall products are installed. If any are found, the malware chooses not to
    infect the system and simply exits. This is illustrated in the following snippet
    of decompiled code extracted from the installer ([Listing 9-29](#listing9-29)):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一种被称为 Proton 的恶意软件变种会查找特定的安全工具。当执行时，Proton 安装程序会查询系统，看看是否安装了任何第三方防火墙产品。如果发现有，恶意软件会选择不感染系统并直接退出。以下是从安装程序中提取的反编译代码片段（见
    [Listing 9-29](#listing9-29)）：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 9-29: Basic firewall detection (Proton)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-29：基本防火墙检测（Proton）
- en: 'The installer first extracts a filepath from a decrypted array 1. Dynamic analysis
    reveals that this extracted path points to the kernel extension of Little Snitch,
    a popular third-party firewall: */Library/Extensions/LittleSnitch.kext*. If this
    file is found on the system the malware is about to infect, installation is aborted
    2.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序首先从解密的数组中提取文件路径 1。动态分析揭示，该路径指向 Little Snitch 的内核扩展，一个流行的第三方防火墙：*/Library/Extensions/LittleSnitch.kext*。如果在系统中找到这个文件，恶意软件的安装过程将被中止
    2。
- en: The Proton installer has other tricks up its sleeve. For example, in an attempt
    to thwart dynamic analysis, it will terminate tools such as the macOS’s log message
    collector (the Console application) and the popular network monitor Wireshark.
    To terminate these applications, it simply invokes the built-in macOS utility,
    `killall`. Though rather primitive and quite noticeable, this technique will prevent
    the analysis tools from running alongside the malware. (Of course, the tools can
    simply be restarted, or even just renamed.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Proton 安装程序还有其他手段。例如，为了阻止动态分析，它会终止一些工具，如 macOS 的日志信息收集器（Console 应用）和流行的网络监视器
    Wireshark。为了终止这些应用程序，它只需调用内建的 macOS 工具 `killall`。虽然这种方法相当原始且容易察觉，但它能防止分析工具与恶意软件同时运行。（当然，这些工具可以简单地重新启动，甚至只是重命名。）
- en: Detecting a Debugger
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测调试器
- en: 'The debugger is arguably the most powerful tool in the malware analyst’s arsenal,
    so most malware that contains anti-analysis code seeks to detect whether it is
    running in a debugger session. The most common way for a program to determine
    if it is being debugged is to simply ask the system. As described in Apple’s developer
    documentation, a process should first invoke the `sysctl` API with `CTL_KERN`,
    `KERN_PROC`, `KERN_PROC_PID`, and its process identifier (`pid`), as parameters.
    Also, a `kinfo_proc` structure should be provided.^([14](#c09-endnote-14)) The
    `sysctl` function will then populate the structure with information about the
    process, including a `P_TRACED` flag. If set, this flag means the process is currently
    being debugged. [Listing 9-30](#listing9-30), taken directly from Apple’s documentation,
    checks for the presence of a debugger in this manner:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器可以说是恶意软件分析师最强大的工具，因此大多数包含反分析代码的恶意软件都试图检测自己是否正在调试会话中运行。程序确定是否正在被调试的最常见方法是直接询问系统。根据苹果的开发者文档，进程应首先调用`sysctl`
    API，使用`CTL_KERN`、`KERN_PROC`、`KERN_PROC_PID`和其进程标识符（`pid`）作为参数。此外，还应提供一个`kinfo_proc`结构体^([14](#c09-endnote-14))。然后，`sysctl`函数将用关于进程的信息填充该结构体，其中包括`P_TRACED`标志。如果该标志被设置，则意味着该进程正在被调试。[Listing
    9-30](#listing9-30)，直接来自苹果文档，采用这种方式检查是否存在调试器：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 9-30: Debugger detection (via the `P_TRACED` flag)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-30：调试器检测（通过`P_TRACED`标志）
- en: 'Malware will often use this same technique, in some cases copying Apple’s code
    verbatim. This was the case with the Russian malware known as Komplex. Looking
    at a decompilation of Komplex’s main function, you can see that it invokes a function
    named `AmIBeingDebugged` ([Listing 9-31](#listing9-31)):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件通常会使用这种相同的技术，在某些情况下甚至会逐字复制苹果的代码。这正是俄罗斯恶意软件Komplex的情况。通过查看Komplex主函数的反编译版本，你可以看到它调用了一个名为`AmIBeingDebugged`的函数（[Listing
    9-31](#listing9-31)）：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 9-31: Debugger detection (Komplex)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-31：调试器检测（Komplex）
- en: If the `AmIBeingDebugged` function returns a nonzero value, the malware will
    execute the logic in the `else` block, which causes the malware to delete itself
    in an attempt to prevent continued analysis. And as expected, if we examine the
    code of the malware’s `AmIBeingDebugged` function, it is logically equivalent
    to Apple’s debugger detection function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`AmIBeingDebugged`函数返回一个非零值，恶意软件将执行`else`代码块中的逻辑，这会导致恶意软件自我删除，试图阻止进一步的分析。正如预期的那样，如果我们检查恶意软件的`AmIBeingDebugged`函数的代码，它在逻辑上等同于苹果的调试器检测函数。
- en: Preventing Debugging with ptrace
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ptrace防止调试
- en: 'Another anti-debugging approach is attempting to prevent debugging altogether.
    Malware can accomplish this by invoking the `ptrace` system call with the `PT_DENY_ATTACH`
    flag. This Apple-specific flag prevents a debugger from attaching and tracing
    the malware. Attempting to debug a process that invokes `ptrace` with the `PT_DENY_ATTACH`
    flag will fail ([Listing 9-32](#listing9-32)):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种反调试方法是尝试完全阻止调试。恶意软件可以通过调用带有`PT_DENY_ATTACH`标志的`ptrace`系统调用来实现这一点。这个苹果特有的标志会阻止调试器附加到恶意软件并进行跟踪。尝试调试一个调用了带有`PT_DENY_ATTACH`标志的`ptrace`的进程将会失败（[Listing
    9-32](#listing9-32)）：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 9-32: A premature exit due to `ptrace` with the `PT_DENY_ATTACH` flag
    (Proton)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-32：由于`ptrace`调用了`PT_DENY_ATTACH`标志而提前退出（Proton）
- en: You can tell the malware has the `PT_DENY_ATTACH` flag set because it prematurely
    exits with a status of `45`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过恶意软件提前退出并返回状态`45`来判断它是否设置了`PT_DENY_ATTACH`标志。
- en: 'Calls to the `ptrace` function with the `PT_DENY_ATTACH` flag are fairly easy
    to spot (for example, by examining the binary’s imports). Thus, malware may attempt
    to obfuscate the `ptrace` call. For example, Proton dynamically resolves the `ptrace`
    function by name, preventing it from showing up as an import, as you can see in
    the following snippet ([Listing 9-33](#listing9-33)):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对带有`PT_DENY_ATTACH`标志的`ptrace`函数调用相对容易发现（例如，通过检查二进制文件的导入）。因此，恶意软件可能会尝试模糊化`ptrace`调用。例如，Proton通过名称动态解析`ptrace`函数，防止它作为导入项出现，正如你在以下代码片段中看到的那样（[Listing
    9-33](#listing9-33)）：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 9-33: Obfuscated anti-debugger logic via `ptrace`, `PT_DENY_ATTACH`
    (Proton)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-33：通过`ptrace`和`PT_DENY_ATTACH`模糊化的反调试逻辑（Proton）
- en: After invoking the `dlopen` function 1, the malware calls `dlsym` 2 to dynamically
    resolve the address of the `ptrace` function. As the `dlsym` function takes a
    pointer to the string of the function to resolve, such as `[ptrace]`, that function
    won’t show up as a dependency of the binary. The return value from `dlsym`, stored
    in the `RAX` register, is the address of `ptrace`. Once the address is resolved,
    the malware promptly invokes it, passing in `0x1F`, which is the hexadecimal value
    of `PT_DENY_ATTACH` 3. If the malware is being debugged, the call to `ptrace`
    will cause the debugging session to forcefully terminate and the malware to exit.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `dlopen` 函数 1 后，恶意软件调用 `dlsym` 2 动态解析 `ptrace` 函数的地址。由于 `dlsym` 函数接收指向要解析的函数名的字符串指针，例如
    `[ptrace]`，因此该函数不会作为二进制文件的依赖项出现。`dlsym` 的返回值存储在 `RAX` 寄存器中，是 `ptrace` 的地址。一旦地址解析完毕，恶意软件立即调用该地址，传入
    `0x1F`，这是 `PT_DENY_ATTACH` 的十六进制值 3。如果恶意软件正在被调试，调用 `ptrace` 会导致调试会话强制终止，并使恶意软件退出。
- en: Bypassing Anti-Dynamic-Analysis Logic
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过反动态分析逻辑
- en: 'Luckily, the anti-dynamic-analysis methods covered thus far are all fairly
    trivial to bypass. Overcoming most of these tactics involves two steps: identifying
    the location of the anti-analysis logic and then preventing its execution. Of
    these two steps, the first is usually the most challenging, but it becomes far
    easier once you’re familiar with the anti-analysis methods discussed in this chapter.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，到目前为止所介绍的反动态分析方法都比较容易绕过。克服大多数这些策略通常需要两个步骤：识别反分析逻辑的位置，然后防止其执行。在这两个步骤中，第一个通常是最具挑战性的，但一旦熟悉了本章讨论的反分析方法，它就会变得容易得多。
- en: It’s wise to first statically triage a binary before diving into a full-blown
    debugging session. During this triage, keep an eye out for telltale signs that
    may reveal dynamic-analysis-thwarting logic. For example, if a binary imports
    the `ptrace` API, there is a good chance it will attempt to prevent debugging
    with the `PT_DENY_ATTACH` flag.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始全面调试会话之前，最好先对二进制文件进行静态筛查。在筛查过程中，留意可能揭示动态分析阻止逻辑的线索。例如，如果一个二进制文件导入了`ptrace`
    API，那么它很可能会尝试通过 `PT_DENY_ATTACH` 标志来防止调试。
- en: 'Strings or function and method names may also reveal a malware’s distaste for
    analysis. For example, running the `nm` command, used to dump symbols, against
    EvilQuest reveals functions named `is_debugging` and `is_virtual_mchn` ([Listing
    9-34](#listing9-34)):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串或函数和方法名称也可能揭示恶意软件对分析的反感。例如，运行 `nm` 命令（用于转储符号）针对 EvilQuest 会显示名为 `is_debugging`
    和 `is_virtual_mchn` 的函数（[列表 9-34](#listing9-34)）：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 9-34: Anti-analysis functions? (EvilQuest)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-34：反分析函数？（EvilQuest）
- en: 'Unsurprisingly, continued analysis reveals that both functions are related
    to the malware’s anti-analysis logic. For example, examining the code that invokes
    the `is_debugging` function reveals that EvilQuest will prematurely exit if the
    function returns a nonzero value; that is, if a debugger is detected ([Listing
    9-35](#listing9-35)):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，持续分析揭示这两个函数都与恶意软件的反分析逻辑相关。例如，检查调用 `is_debugging` 函数的代码可以发现，如果该函数返回非零值，EvilQuest
    将提前退出；也就是说，如果检测到调试器（[列表 9-35](#listing9-35)）：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 9-35: Anti-debugging logic (EvilQuest)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-35：反调试逻辑（EvilQuest）
- en: However, if the malware also implements anti-static-analysis logic, such as
    string or code obfuscation, locating logic that seeks to detect a virtual machine
    or a debugger may be difficult to accomplish with static analysis methods. In
    this case, you can use a methodical debugging session, starting at the entry point
    of the malware (or any initialization routines). Specifically, you can single-step
    through to the code, observing API and system calls that may be related to the
    anti-analysis logic. If you step over a function and the malware immediately exits,
    it’s likely that some anti-analysis logic was triggered. If this occurs, simply
    restart the debugging session and step into the function to examine the code more
    closely.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果恶意软件还实现了反静态分析逻辑，例如字符串或代码混淆，定位旨在检测虚拟机或调试器的逻辑可能通过静态分析方法很难完成。在这种情况下，你可以使用系统化的调试会话，从恶意软件的入口点（或任何初始化程序）开始。具体来说，你可以逐步跟踪代码，观察可能与反分析逻辑相关的
    API 和系统调用。如果你跳过了某个函数，且恶意软件立即退出，那么很可能是某些反分析逻辑被触发了。如果发生这种情况，只需重新启动调试会话，并进入该函数以更仔细地检查代码。
- en: 'This trial and error approach could be conducted in the following manner:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反复试验的方法可以通过以下方式进行：
- en: Start a debugger session that executes the malicious sample. It is important
    to start the debugging session at the very beginning rather than attaching it
    to the already running process. This ensures that the malware has not had a chance
    to execute any of its anti-analysis logic.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个调试会话来执行恶意样本。重要的是从一开始就启动调试会话，而不是附加到已经在运行的进程上。这可以确保恶意软件没有机会执行任何反分析逻辑。
- en: Set breakpoints on APIs that may be invoked by the malware to detect a virtual
    machine or debugging session. Examples include `sysctl` and `ptrace`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在恶意软件可能调用的API上设置断点，以检测虚拟机或调试会话。示例包括`sysctl`和`ptrace`。
- en: Instead of allowing the malware to run uninhibited, manually step through its
    code, perhaps stepping over any function calls. If any of the breakpoints are
    hit, examine their arguments to ascertain if they are being invoked for anti-analysis
    reasons. For example, check for `ptrace` invoked with the `PT_DENY_ATTACH` flag,
    or perhaps `sysctl` attempting to retrieve the number of CPUs or setting the `P_TRACED`
    flag. A backtrace should reveal the address of the code within the malware that
    invoked these APIs.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要让恶意软件不受限制地运行，而是手动逐步执行它的代码，可能跳过任何函数调用。如果遇到断点，检查它们的参数，以确定它们是否出于反分析的原因被调用。例如，检查是否调用了带有`PT_DENY_ATTACH`标志的`ptrace`，或者是否调用了`sysctl`来获取CPU数量或设置`P_TRACED`标志。回溯信息应该能够揭示调用这些API的恶意软件内代码地址。
- en: If stepping over a function call causes the malware to exit (a sign it likely
    detected either the virtual machine or the debugger), restart the debugging session
    and, this time, step into this function. Repeat this process until you’ve identified
    the location of the anti-analysis logic.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果跳过一个函数调用导致恶意软件退出（这通常表示它可能检测到了虚拟机或调试器），则重新启动调试会话，并这次进入该函数。重复此过程，直到确定反分析逻辑的位置。
- en: Armed with the locations of the anti-analysis logic, you can now bypass it by
    modifying the execution environment, patching the on-disk binary image, modifying
    program control flow in a debugger, or modifying the register or variable value
    in a debugger. Let’s briefly look at each of these methods.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握反分析逻辑的位置，现在可以通过修改执行环境、修补磁盘上的二进制镜像、在调试器中修改程序控制流，或在调试器中修改寄存器或变量的值来绕过它。让我们简要看一下每种方法。
- en: Modifying the Execution Environment
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改执行环境
- en: It may be possible to modify the execution environment such that the anti-analysis
    logic no longer triggers. Recall that Mughthesec contains logic to detect if it’s
    running within a virtual machine by examining the system’s MAC address. If the
    malware detects a MAC address with an OUI matching a virtual machine vendor such
    as VMware, it won’t execute. Luckily, we can modify our MAC address in the virtual
    machine’s settings, choosing an address that falls outside the range of any virtual
    machine provider’s OUI. For example, set it to the OUI of your base macOS machine,
    like `F0:18:98`, which belongs to Apple. Once the MAC address has been changed,
    Mughthesec will no longer detect the environment as a virtual machine and so will
    happily execute its malicious logic, allowing our dynamic analysis to continue.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 可能通过修改执行环境，使反分析逻辑不再触发。回想一下，Mughthesec包含一段逻辑，用于通过检查系统的MAC地址来检测它是否在虚拟机中运行。如果恶意软件检测到一个与虚拟机厂商（如VMware）匹配的OUI，它将不会执行。幸运的是，我们可以在虚拟机的设置中修改MAC地址，选择一个不属于任何虚拟机提供商OUI范围的地址。例如，将其设置为基础macOS机器的OUI，如`F0:18:98`，这是Apple的OUI。一旦MAC地址更改，Mughthesec将不再将环境识别为虚拟机，因此它将愉快地执行其恶意逻辑，从而允许我们的动态分析继续进行。
- en: Patching the Binary Image
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修补二进制镜像
- en: Another more permanent approach to bypassing anti-analysis logic involves patching
    the malware’s on-disk binary image. The Mac ransomware KeRanger is a good candidate
    for this approach, as it may sleep for several days before executing its malicious
    payload, perhaps in an effort to impede automated or dynamic analysis.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更持久的方法来绕过反分析逻辑是修补恶意软件的磁盘上二进制镜像。Mac勒索病毒KeRanger是这一方法的一个良好候选，它可能会在执行恶意载荷之前休眠几天，可能是为了阻碍自动化或动态分析。
- en: 'Though the malware is packed, it leverages the UPX packer, which we can fully
    unpack using the `upx -d` command. Next, static analysis can identify the function
    aptly named `waitOrExit` that is responsible for implementing the wait delay.
    It is invoked by the `startEncrypt` function, which begins the process of ransoming
    users’ files:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管恶意软件被压缩，但它使用的是UPX压缩器，我们可以通过`upx -d`命令完全解包它。接下来，静态分析可以识别出名为`waitOrExit`的函数，它负责实现等待延迟。该函数由`startEncrypt`函数调用，而`startEncrypt`函数会开始勒索用户文件的过程：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To bypass the delay logic so that the malware will immediately continue execution,
    we can modify the malware’s binary code to skip the call to the `waitOrExit` function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过延迟逻辑，使恶意软件立即继续执行，我们可以修改恶意软件的二进制代码，跳过对`waitOrExit`函数的调用。
- en: 'In a hex editor, we change the bytes of the malware’s executable instructions
    from a `call` to a `nop`. Short for “no operation,” a `nop` is an instruction
    (`0x90` on Intel platforms) that instructs the CPU to do, well, nothing. It is
    useful when patching out anti-analysis logic in malware, overwriting the problematic
    instructions with benign ones. We also `nop`-out the instructions that would cause
    the malware to terminate if the overwritten call failed ([Listing 9-36](#listing9-36)):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在十六进制编辑器中，我们将恶意软件可执行指令的字节从`call`修改为`nop`。`nop`是“无操作”的缩写，它是一条指令（在Intel平台上为`0x90`），指示CPU什么都不做。当需要绕过恶意软件中的反分析逻辑时，`nop`指令非常有用，它将有问题的指令覆盖为无害的指令。我们还会将那些如果被覆盖的`call`失败时可能导致恶意软件终止的指令替换为`nop`（[清单9-36](#listing9-36)）：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 9-36: Anti-analysis logic, now `nop`’d out (KeRanger)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-36：反分析逻辑，现已被`nop`替换（KeRanger）
- en: Now whenever this modified version of KeRanger is executed, the `nop` instructions
    will do nothing and the malware will happily continue executing, allowing our
    dynamic analysis session to progress.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当这个修改过的KeRanger版本被执行时，`nop`指令将不会执行任何操作，恶意软件将愉快地继续执行，从而使我们的动态分析会话得以进行。
- en: Though patching the malware’s on-disk binary image is a permanent solution,
    it may not always be the best approach. First, if the malware is packed with a
    non-UPX packer that is difficult to unpack, it may not be possible to patch the
    target instructions, as they are only unpacked or decrypted in memory. Moreover,
    on-disk patches involve more work than less permanent methods, such as modifications
    to the malware’s in-memory code during a debugging session. Finally, any modification
    to a binary will invalidate any of its cryptographic signatures. This could prevent
    the malware from executing successfully. Thus, it’s more common for malware analysts
    to use a debugger or other runtime method, such as injecting a custom library,
    to circumvent anti-dynamic-analysis logic.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管修改恶意软件的磁盘上二进制镜像是一个永久解决方案，但它并不总是最佳方法。首先，如果恶意软件使用了难以解包的非UPX压缩器，可能无法修补目标指令，因为它们仅在内存中解包或解密。此外，磁盘上的补丁涉及的工作量比不那么永久的方法更多，比如在调试会话期间修改恶意软件的内存代码。最后，任何二进制文件的修改都会使其加密签名失效，这可能会阻止恶意软件成功执行。因此，恶意软件分析师更常使用调试器或其他运行时方法，如注入自定义库，来绕过反动态分析逻辑。
- en: Modifying the Malware’s Instruction Pointer
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改恶意软件的指令指针
- en: One of the more powerful capabilities of a debugger is its ability to directly
    modify the entire state of the malware. This capability proves especially useful
    when you need to bypass dynamic-analysis-thwarting logic.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器最强大的功能之一就是能够直接修改恶意软件的整个状态。当你需要绕过动态分析阻止逻辑时，这一能力尤为有用。
- en: Perhaps the simplest way to do so involves manipulating the program’s instruction
    pointer, which points to the next instruction that the CPU will execute. This
    value is stored in the program counter register, which on 64-bit Intel systems
    is the `RIP` register. You can set a breakpoint on the anti-analysis logic, and
    when the breakpoint is hit, modify the instruction pointer to, for example, skip
    over problematic logic. If done correctly, the malware will be none the wiser.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 或许最简单的方法是操控程序的指令指针，它指向CPU将要执行的下一条指令。这个值保存在程序计数器寄存器中，在64位Intel系统上是`RIP`寄存器。你可以在反分析逻辑处设置断点，当断点被触发时，修改指令指针，举例来说，跳过有问题的逻辑。如果操作正确，恶意软件将无法察觉。
- en: Let’s return to KeRanger. After setting a breakpoint on the call instruction
    that invokes the function that sleeps for three days, we can allow the malware
    to continue until that breakpoint is hit. At this point, we can simply modify
    the instruction pointer to point to the instructions after the call. As the function
    call is never made, the malware never sleeps, and our dynamic analysis session
    can continue.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到KeRanger。通过在调用执行三天休眠函数的指令上设置断点，我们可以允许恶意软件继续执行，直到该断点被触发。此时，我们可以简单地修改指令指针，指向调用之后的指令。由于该函数调用从未执行，恶意软件永远不会进入休眠状态，我们的动态分析会话可以继续进行。
- en: Recall that in a debugger session, you can change the value of any register
    via the `reg write` debugger command. To specifically modify the value of the
    instruction pointer, execute this command on the `RIP` register.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在调试会话中，你可以通过`reg write`调试命令更改任何寄存器的值。要专门修改指令指针的值，可以在`RIP`寄存器上执行此命令。
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s walk through another example. The EvilQuest malware contains a function
    named `prevent_trace` that invokes the `ptrace` API with the `PT_DENY_ATTACH`
    flag. Code at address `0x000000010000b8b2` invokes this function. If we allow
    this function to execute during a debugging session, the system will detect the
    debugger and immediately terminate the session. To bypass this logic, we can avoid
    the call to `prevent_trace` altogether by setting a breakpoint at `0x000000010000b8b2`.
    Once the breakpoint is hit, we modify the value of the instruction pointer to
    skip the call, as in [Listing 9-37](#listing9-37):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。EvilQuest恶意软件包含一个名为`prevent_trace`的函数，它调用`ptrace` API并传入`PT_DENY_ATTACH`标志。地址`0x000000010000b8b2`处的代码调用了此函数。如果我们允许此函数在调试会话期间执行，系统将检测到调试器并立即终止会话。为了绕过这一逻辑，我们可以通过在`0x000000010000b8b2`处设置断点来避免调用`prevent_trace`。一旦断点被触发，我们修改指令指针的值来跳过该调用，正如在[列表
    9-37](#listing9-37)中所示：
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 9-37: Skipping anti-debugger logic (EvilQuest)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-37：跳过反调试逻辑（EvilQuest）
- en: Now the `prevent_trace` function is never invoked, and our debugging session
    can continue.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`prevent_trace`函数从未被调用，我们的调试会话可以继续进行。
- en: Note that manipulating the instruction pointer of a program can have serious
    side effects if not done correctly. For example, if a manipulation causes an unbalanced
    or misaligned stack, that program may crash. Sometimes, a simpler approach can
    be taken to avoid manipulating the instruction pointer and modify other registers
    instead.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，操控程序的指令指针如果不正确，可能会产生严重副作用。例如，如果操作导致栈不平衡或未对齐，程序可能会崩溃。有时，可以采取更简单的方法避免修改指令指针，而是修改其他寄存器。
- en: Modifying a Register Value
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改寄存器值
- en: Note that EvilQuest contains a function named `is_debugging`. Recall that the
    function returns a nonzero value if it detects a debugging session, which will
    cause the malware to abruptly terminate. Of course, if no debugging session is
    detected because `is_debugging` returns zero, the malware will happily continue.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，EvilQuest包含一个名为`is_debugging`的函数。回想一下，该函数如果检测到调试会话会返回非零值，这将导致恶意软件突然终止。当然，如果没有检测到调试会话（因为`is_debugging`返回零），恶意软件会继续正常运行。
- en: 'Instead of manipulating the instruction pointer, we can set a breakpoint on
    the instruction that performs the check of the value returned by the `is_debugging`
    function. Once this breakpoint is hit, the `EAX` register will contain a nonzero
    value, as the malware will have detected our debugger. However, via the debugger,
    we can surreptitiously toggle the value in `EAX` to 0 ([Listing 9-38](#listing9-38)):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不操作指令指针，而是在执行检查`is_debugging`函数返回值的指令上设置断点。断点被触发时，`EAX`寄存器将包含一个非零值，因为恶意软件已检测到我们的调试器。然而，通过调试器，我们可以悄悄地将`EAX`中的值切换为0（[列表
    9-38](#listing9-38)）：
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 9-38: Modifying register values to bypass anti-debugging logic'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-38：修改寄存器值以绕过反调试逻辑
- en: Changing the value of the `EAX` register to 0 (via `reg write $eax 0`) ensures
    the comparison instruction will now result in the zero flag being set. Thus, the
    `je` instruction will take the branch to address `0x10000b8b2`, avoiding the call
    to `exit` at `0x10000b8ad`. Note that we only needed to modify the lower 32 bits
    of the `RAX` register (`EAX`), as this is all that is checked by the compare instruction
    (`cmp`).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 将`EAX`寄存器的值更改为0（通过`reg write $eax 0`）确保比较指令现在会导致零标志被设置。因此，`je`指令将跳转到地址`0x10000b8b2`，避开`0x10000b8ad`处的`exit`调用。请注意，我们只需要修改`RAX`寄存器（`EAX`）的低32位，因为这正是比较指令（`cmp`）所检查的内容。
- en: 'A Remaining Challenge: Environmentally Generated Keys'
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个剩余的挑战：环境生成的密钥
- en: At this point, it may seem that malware analysts have the upper hand; after
    all, no anti-analysis measures can stop us, right? Not so fast. Sophisticated
    malware authors employ protection encryption schemes that use *environmentally
    generated keys*. These keys are generated on the victim’s system and are thus
    unique to a specific instance of an infection.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，可能看起来恶意软件分析师占了上风；毕竟，没什么反分析措施能阻止我们，不是吗？但别急。复杂的恶意软件作者使用保护加密方案，这些方案使用*环境生成的密钥*。这些密钥是在受害者的系统上生成的，因此对特定感染实例是唯一的。
- en: The implications of this are rather profound. If the malware finds itself outside
    the environment for which it was keyed, it will be unable to decrypt itself. This
    also means that attempts to analyze the malware will likely fail, as it will remain
    encrypted. If this environmental protection mechanism is implemented correctly
    and the keying information is not externally recoverable, the only way to analyze
    the malware is either by performing the analysis directly on the infected system
    or by performing it on a memory dump of the malware captured on the infected system.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来的影响相当深远。如果恶意软件发现自己处于不同于其密钥环境的地方，它将无法解密自身。这也意味着分析恶意软件的尝试很可能会失败，因为它将保持加密状态。如果这个环境保护机制实施得当，并且密钥信息无法从外部恢复，那么分析恶意软件的唯一方法就是直接在感染系统上进行分析，或者在感染系统中捕获的恶意软件内存转储上进行分析。
- en: We’ve seen this protection mechanism in Windows malware written by the infamous
    Equation Group, as well as more recently on macOS by the Lazarus Group.^([15](#c09-endnote-15))
    The latter encrypted all second-stage payloads with the serial number of the infected
    systems. For more on the intriguing topic of environmental key generation, see
    my 2015 Black Hat talk “Writing Bad @$$ Malware for OS X.”^([16](#c09-endnote-16))
    Also check out James Riordan and Bruce Schneier’s seminal paper on the topic,
    “Environmental Key Generation Towards Clueless Agents.”^([17](#c09-endnote-17))
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在由臭名昭著的方程组（Equation Group）编写的 Windows 恶意软件中见过这种保护机制，最近在 Lazarus Group 针对 macOS
    的恶意软件中也见过这种机制。^([15](#c09-endnote-15)) 后者使用感染系统的序列号加密了所有第二阶段的有效载荷。有关环境密钥生成这一有趣话题的更多内容，请参阅我2015年在
    Black Hat 上的演讲《为 OS X 编写厉害的恶意软件》^([16](#c09-endnote-16))。还可以查阅 James Riordan 和
    Bruce Schneier 关于这个话题的开创性论文《环境密钥生成：面向无知代理》。^([17](#c09-endnote-17))
- en: Up Next
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来
- en: In this chapter, we discussed common anti-analysis approaches that malware may
    leverage in an attempt to thwart our analysis efforts. After discussing how to
    identify this logic, I illustrated how to use static and dynamic approaches in
    order to bypass it. Armed with the knowledge presented in this book thus far,
    you’re now ready to analyze a sophisticated piece of Mac malware. In the next
    chapter we’ll uncover the malware’s viral infection capabilities, persistence
    mechanism, and goals.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了恶意软件可能利用的常见反分析方法，试图阻碍我们的分析工作。在讨论如何识别这些逻辑后，我演示了如何使用静态和动态方法绕过它们。掌握了本书至此所讲的知识，你现在已经准备好分析一款复杂的
    Mac 恶意软件。在下一章，我们将揭示该恶意软件的病毒传播能力、持久性机制和目的。
- en: Endnotes
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
