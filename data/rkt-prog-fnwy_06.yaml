- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: DATA
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: 'This chapter is all about data: reading it, writing it, visualizing it, and
    analyzing it. We’ll begin with a discussion of input and output using Racket ports
    (an essential tool we’ll use throughout this chapter).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲述的是数据：如何读取它、写入它、可视化它以及分析它。我们将从使用 Racket 端口进行输入和输出的讨论开始（这是我们在本章中将使用的一个重要工具）。
- en: I/O, I/O, It’s Off to Work We Go
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I/O，I/O，我们开始工作了
- en: 'Data is transferred in Racket via ports: data flows into an input port and
    out of output ports. The general process of transferring data to or from an external
    source (such a text file or database server) is referred to as *I/O*. Let’s look
    at some examples of ports.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Racket 中，数据通过端口进行传输：数据流入输入端口并流出输出端口。将数据从外部源（如文本文件或数据库服务器）传输到 Racket，或从 Racket
    传输到外部源的过程被称为 *I/O*。让我们来看一些端口的例子。
- en: '***File I/O Ports***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文件 I/O 端口***'
- en: Ports can be used for writing and reading data to a file, as the following dialog
    illustrates.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 端口可以用于写入和读取文件中的数据，如下对话所示。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we attempt to open a port to a file that already exists, we get an error.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试打开一个已存在的文件端口，就会出现错误。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The default mode of operation for `open-output-file` is to create a new file.
    Since we can’t create a new file twice, we need to declare how we intend to handle
    an existing file. This is managed via the `#:exists` keyword: we can append to
    the existing file by specifying ’`append` as its value, blow away the file and
    create a new file with ’`replace`, or keep the file but delete the contents with
    ’`truncate` (the default for value for `#:exists` is ’`error`, which means to
    generate an error if the file exists). We exercise a few of these options below.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`open-output-file` 的默认操作模式是创建一个新文件。由于我们不能两次创建新文件，因此需要声明如何处理现有文件。这是通过 `#:exists`
    关键字来管理的：通过指定 `append` 作为值，我们可以将数据附加到现有文件中，使用 `replace` 会删除文件并创建一个新文件，或者使用 `truncate`
    保留文件但删除其内容（`#:exists` 的默认值是 `error`，即如果文件已存在则生成错误）。我们在下面演示了一些选项。'
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once the end of the file is reached, `read-line` returns an end of file object;
    this prints as `#<eof>` but is defined as `eof` in Racket. This value can be tested
    for with the `eof-object?` predicate.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦到达文件的末尾，`read-line` 会返回一个文件结束对象；它显示为`#<eof>`，但在 Racket 中定义为 `eof`。可以通过 `eof-object?`
    谓词来测试这个值。
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Every time a port is opened, you must remember to close it when the data transfer
    is complete. The closing can be performed automatically by using either `call-with-output-file`
    or `call-with-input-file` (depending on which way the data is flowing). These
    procedures work by supplying them with a function that does the actual data transfer.
    Here are some examples using this approach.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每次打开端口时，必须记得在数据传输完成后关闭端口。可以通过使用 `call-with-output-file` 或 `call-with-input-file`
    自动执行关闭操作（具体取决于数据流的方向）。这些过程通过提供一个执行实际数据传输的函数来工作。下面是一些使用这种方法的示例。
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ll explore file ports in greater detail a bit later in the chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章稍后部分更详细地探讨文件端口。
- en: '***String Ports***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符串端口***'
- en: 'Ports can be opened against strings. This can be handy when trying to build
    a string where different components of the string will be appended at various
    times within a procedure. We’ll put string ports to good use in [Chapter 10](ch10.xhtml)
    when we build string representations of algebraic expressions. Some simple examples
    are provided here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 端口可以与字符串一起打开。当你尝试构建一个字符串时，这会非常方便，因为字符串的不同部分将在过程中的不同时间被附加。我们将在[第10章](ch10.xhtml)中通过构建代数表达式的字符串表示来充分利用字符串端口。这里提供了一些简单的例子：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unlike file ports, string ports don’t have to be explicitly closed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件端口不同，字符串端口不需要显式关闭。
- en: '***Computer-to-Computer Ports***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算机对计算机端口***'
- en: Ports can be set up to allow two computers to communicate with each other. This
    type of communication uses the TCP/IP protocol. To establish the connections,
    the first computer (called the *server*) establishes itself as a listener with
    the `tcp-listen` command. This command accepts an unsigned integer as a port number
    (this is a TCP/IP port number). Note that a Racket port is a different entity
    from the TCP port specified by the port number. The server then calls `tcp-accept`,
    which returns two values—an input port and an output port—to permit two-way communication
    between the computers. The following session illustrates setting up a server and
    the server waiting for a query from a client computer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 端口可以设置以允许两台计算机相互通信。这种类型的通信使用TCP/IP协议。为了建立连接，第一台计算机（称为*服务器*）通过`tcp-listen`命令将自己设置为监听者。此命令接受一个无符号整数作为端口号（这是一个TCP/IP端口号）。请注意，Racket端口与端口号指定的TCP端口是不同的实体。然后，服务器调用`tcp-accept`，该命令返回两个值——一个输入端口和一个输出端口——以便两台计算机之间进行双向通信。以下会话演示了设置服务器并等待来自客户端计算机的查询。
- en: '**Computer 1** – The Server'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算机 1** – 服务器'
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The string `"Hello there!"` is sent from the client. This is the result of executing
    the line `(read-line comp1-in)`, after which the server responds with `"Got it,
    bro!"`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`"Hello there!"`从客户端发送。这是执行`(read-line comp1-in)`这一行后的结果，之后服务器响应`"Got it,
    bro!"`。
- en: The client establishes its communication link by a using `tcp-connect`. The
    `tcp-connect` command takes the server computer name and the port number established
    by the server as arguments. It then initiates the dialog by sending `(displayln
    "Hello there!\n" comp2-out)` over the output port and waiting for a response from
    the server with `(read-line comp2-in)`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过使用`tcp-connect`建立通信连接。`tcp-connect`命令接受服务器计算机名称和服务器建立的端口号作为参数。然后，它通过输出端口发送`(displayln
    "Hello there!\n" comp2-out)`启动对话，并使用`(read-line comp2-in)`等待来自服务器的响应。
- en: '**Computer 2** – The Client'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算机 2** – 客户端'
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is just a simple example; there are of course a number of nuances to setting
    up successful communication channels between computers. Consult the Racket Documentation
    for additional details.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的示例；当然，在建立成功的计算机间通信通道时有许多细节。有关更多详细信息，请查阅Racket文档。
- en: Introduction to Security
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全性简介
- en: 'Now that we’ve explored ports, let’s see how we can use them to enhance our
    security. No, not computer security. In this section, we’ll take a look at a type
    of security that virtually everyone is interested in: money. In particular we’ll
    be exploring securities such as stocks and bonds. The specific data we’re going
    to look at is price over time. There are a number of ways to look at prices: stock
    prices of individual corporations, average prices over an industry or group of
    institutions, or prices of index funds.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了端口的知识，接下来看看如何利用它们来增强我们的安全性。不，这不是计算机安全。在本节中，我们将探讨一种几乎每个人都感兴趣的安全性：金钱。特别地，我们将研究证券，如股票和债券。我们将要查看的具体数据是价格随时间的变化。有许多方式可以查看价格：单个公司的股票价格、行业或机构集团的平均价格，或是指数基金的价格。
- en: '[Table 6-1](ch06.xhtml#ch6tab1) lists the various entities we’ll be investigating.
    In the remainder of the chapter, we’ll refer to these entities as *assets*. The
    Symbol column indicates the stock market symbol that’s used to look up price information.
    Definitions for entries in the Type column are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-1](ch06.xhtml#ch6tab1)列出了我们将要研究的各种实体。在本章的其余部分，我们将这些实体称为*资产*。符号列显示了用于查找价格信息的股票市场符号。类型列中条目的定义如下：'
- en: '**Corp** An individual corporation. Most of these should be reasonably familiar.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**公司** 一个独立的公司。大多数这些应该是相对熟悉的。'
- en: '**Index** A market index—just an indicator and not something you actually invest
    in. The Dow Jones Industrial Average is the weighted average consisting of 30
    large publicly traded institutions. The S&P 500 (Standard and Poor’s 500) is similar
    but consists of 500 large publicly traded institutions.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**指数** 一个市场指数——只是一个指标，而不是你实际投资的东西。道琼斯工业平均指数是由30家大型上市公司组成的加权平均数。标准普尔500指数（S&P
    500）类似，但由500家大型上市公司组成。'
- en: '**Index Fund** An index fund, unlike an index, *can* be invested in. An index
    fund is typically composed of some mix of stocks or bonds. The Vanguard Total
    Bond Market fund is composed of a mix of long-term and short-term and both corporate
    and government bonds. The idea of index funds is that investing in a range of
    institutions minimized risk since the poor performance of one investment will
    be mitigated when averaged in with the remaining investments.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**指数基金** 与指数不同，*可以*进行投资。指数基金通常由一些股票或债券的混合组成。Vanguard Total Bond Market 基金由长期和短期以及公司债券和政府债券的混合组成。指数基金的理念是，通过投资于多个机构来最小化风险，因为一个投资表现不佳时，其影响会在其他投资中得到缓解。'
- en: '**Table 6-1**: A Selection of Securities'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-1**：证券选集'
- en: '| **Name** | **Symbol** | **Type** |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **符号** | **类型** |'
- en: '| --- | --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Amazon | AMZN | Corp |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Amazon | AMZN | 公司 |'
- en: '| Apple | AAPL | Corp |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| Apple | AAPL | 公司 |'
- en: '| Bank of America | BAC | Corp |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| Bank of America | BAC | 公司 |'
- en: '| Dow Jones | ^DJI | Index |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| Dow Jones | ^DJI | 指数 |'
- en: '| ExxonMobil | XOM | Corp |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| ExxonMobil | XOM | 公司 |'
- en: '| Ford | F | Corp |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| Ford | F | 公司 |'
- en: '| Microsoft | MSFT | Corp |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| Microsoft | MSFT | 公司 |'
- en: '| S&P 500 | ^GSPC | Index |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| S&P 500 | ^GSPC | 指数 |'
- en: '| Vanguard Total Bond Market | VBMFX | Index Fund |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| Vanguard Total Bond Market | VBMFX | 指数基金 |'
- en: The data we’re going to examine was downloaded from the Yahoo! Finance website.
    This data is in the form of *comma-separated value (CSV)* files. What this means
    is that each value in the file is separated by a comma, and each record occupies
    a single line. Here’s an example from a file containing the Dow Jones Industrial
    Average for the first few days of the year 2007 (we’ve lopped off a few decimal
    places from the prices to keep the listing from extending off the page).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要检查的数据是从 Yahoo! Finance 网站下载的。数据格式为*逗号分隔值（CSV）*文件。这意味着文件中的每个值都由逗号分隔，每条记录占用一行。下面是一个包含2007年初几天道琼斯工业平均指数的文件示例（我们已将价格的小数位去掉，以防止列表超出页面）。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first row gives a short description of each data value in the succeeding
    rows. [Table 6-2](ch06.xhtml#ch6tab2) gives a more detailed description.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行简要描述了后续各行中的数据值。[表6-2](ch06.xhtml#ch6tab2)提供了更详细的描述。
- en: '**Table 6-2**: CSV File Format'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-2**：CSV 文件格式'
- en: '| **Value** | **Description** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **值** | **描述** |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Date | Date of transactions (year-month-day) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| Date | 交易日期（年-月-日） |'
- en: '| Open | Price when market opened |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| Open | 市场开盘时的价格 |'
- en: '| High | Highest traded price for the day |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| High | 当日最高交易价格 |'
- en: '| Low | Lowest traded price for the day |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| Low | 当日最低交易价格 |'
- en: '| Close | Price when the market closed |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| Close | 市场关闭时的价格 |'
- en: '| Adj Close | Adjusted closing price |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| Adj Close | 调整后的收盘价 |'
- en: '| Volume | Number of trades for the day |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| Volume | 当日交易量 |'
- en: The adjusted close reflects any adjustments based on dividends or stock splits
    (the term *split* means if you owned a single stock share selling for $100, you’d
    own two shares at $50 after the split).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 调整后的收盘价反映了基于股息或股票拆分的任何调整（“拆分”一词意味着，如果你拥有一股售价为100美元的股票，那么拆分后你将拥有两股，每股50美元）。
- en: Getting Data into Racket
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据导入Racket
- en: The first order of business is to get the CSV data into a form that will be
    useful within Racket. We’ll use a `hist` structure to contain the data for a single
    record from the CSV file. This struct has the following form.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是将CSV数据转化为在Racket中有用的形式。我们将使用一个`hist`结构来存储CSV文件中的单条记录数据。该结构具有以下形式。
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The field names should need no explanation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 字段名称无需额外解释。
- en: The following function will take a file port and return a `hist` structure populated
    with the data values from the current import record (the next unread line in the
    file) with each price entry converted to a numeric value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将接受一个文件端口并返回一个`hist`结构，结构内填充了当前导入记录中的数据值（文件中的下一行未读取行），每个价格条目都会被转换为数字值。
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we’ve taken the opportunity to exercise another of Racket’s hidden treasures,
    pattern matching. *Pattern matching* uses the `match` form ➊ included in the *racket/match*
    library (not to worry; this library is automatically included with the *racket*
    library).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有机会使用Racket的另一个隐藏宝藏——模式匹配。*模式匹配*使用`match`形式 ➊（包含在*racket/match*库中，别担心；这个库会自动包含在*racket*库中）。
- en: 'A `match` expression looks a bit like a `cond` expression, but instead of having
    to use a complex Boolean expression, we simply provide the data structure we want
    to match against. It’s possible to use a number of different structures as patterns
    to match against, including literal values, but we’ll simply use a list for this
    exercise ➋. The split `rec` values are bound to the identifiers `date`, `open`,
    and so on. If a match is found, then a `hist` structure is returned ➌. A single
    underscore (`_`) serves as a wildcard that matches anything ➍ (for example if
    the number of values in the split list did not match the number of items in the
    binding list, an `error` exception would be raised). With this in place, the following
    code reads in a few values (in the following code segments, the reader should
    substitute their own data path where paths starting with `StockHistory/` are used):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`表达式看起来有点像`cond`表达式，但我们不需要使用复杂的布尔表达式，而是简单地提供我们要匹配的数据结构。可以使用多种不同的结构作为匹配模式，包括字面值，但在本练习中，我们将仅使用一个列表➋。拆分后的`rec`值被绑定到标识符`date`、`open`等。如果找到匹配项，则返回一个`hist`结构➌。单个下划线（`_`）充当通配符，匹配任何内容➍（例如，如果拆分列表中的值数量与绑定列表中的项数不匹配，则会引发`error`异常）。在此基础上，以下代码读取一些值（在接下来的代码片段中，读者应将以`StockHistory/`开头的路径替换为自己的数据路径）：'
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first `hist` structure produced contains false values because the header
    strings in the first line of the CSV file couldn’t be converted to numbers by
    `import-record`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的第一个`hist`结构包含错误值，因为CSV文件第一行的头部字符串无法通过`import-record`转换为数字。
- en: 'For display purposes, we often want to uniformly format the history records
    to display each value as a string right-aligned and with a certain precision.
    The following function performs this service:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示的目的，我们通常希望统一格式化历史记录，将每个值以字符串形式右对齐并具有一定的精度。以下函数执行此操作：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `width` parameter specifies the overall width of each value, and the `prec`
    parameter specifies the precision. Applying this function to the first few rows
    of the ExxonMobil data results in the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`width`参数指定每个值的整体宽度，`prec`参数指定精度。将此函数应用于ExxonMobil数据的前几行，结果如下：'
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that some of the output values are padded with spaces because the numbers
    are less than six characters wide when formatted with two decimal places.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于数字格式化为两位小数时宽度小于六个字符，因此一些输出值使用了空格进行填充。
- en: 'Since we’ll sometimes want to display the data in tabular form, we’ll take
    advantage of the `text-table` package. Unfortunately, this package isn’t included
    with the default Racket install, so it’ll need to be installed via either Racket’s
    package manager or the `raco` command line tool (see [Chapter 2](ch02.xhtml) on
    `infix` for an example of how to install packages). Once the `text-table` package
    is installed, the following command must be included in your definition file or
    executed in the interactive window:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有时需要以表格形式显示数据，因此我们将利用`text-table`包。不幸的是，这个包并未包含在默认的Racket安装中，因此需要通过Racket的包管理器或`raco`命令行工具进行安装（有关如何安装包的示例，请参见[第2章](ch02.xhtml)的`infix`部分）。一旦安装了`text-table`包，以下命令必须包含在定义文件中或在交互窗口中执行：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `text-table` package defines the `table->string` function, which takes a
    list of lists, where each sublist represents a row in the table. Here’s a simple
    example of how it can be used.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`text-table`包定义了`table->string`函数，该函数接受一个列表的列表，每个子列表表示表中的一行。以下是它的一个简单使用示例。'
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The data that we’re going to be querying against has a file structure similar
    to the one shown in [Figure 6-1](ch06.xhtml#ch6fig1). The files have records (one
    record for each day, month, or week) for years 1980 through the end of 2016 (where
    available).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查询的数据具有类似于[图 6-1](ch06.xhtml#ch6fig1)所示的文件结构。这些文件包含1980年至2016年底（如果有的话）之间的记录（每个记录代表一天、一个月或一周）。
- en: '![Image](../images/06fig02.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig02.jpg)'
- en: '*Figure 6-1: Stock history file structure*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：股票历史文件结构*'
- en: The following code will display rows of stock history when given the stock symbol
    and time period (either `"Daily"`, `"Monthly"`, or `"Weekly"`—files for each period
    are stored in a corresponding folder). In addition, a filter must be specified.
    The filter is a function that accepts a `hist` structure and returns `#t` or `#f`
    depending on what’s being searched for.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将在给定股票符号和时间周期（“每日”，“每月”或“每周”——每个周期的文件存储在相应的文件夹中）时显示股票历史记录的行。此外，必须指定一个过滤器。过滤器是一个接受`hist`结构并根据搜索内容返回`#t`或`#f`的函数。
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once the input file is opened and we’ve skipped past the header line, the code
    line `(let* ([recs` ➊ binds two variables: `recs` and `tbl-list` ➑. Note that
    `recs` is used to initialize `tbl-list` ➑, which simply adds a header for the
    data contained in `recs`. Then the final output is generated ➒.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输入文件被打开并且我们跳过了标题行，代码行`(let* ([recs` ➊绑定了两个变量：`recs`和`tbl-list` ➑。请注意，`recs`用于初始化`tbl-list`
    ➑，它仅仅为`recs`中包含的数据添加了一个标题。然后生成最终输出 ➒。
- en: In the main body of code, we set up a function called `loop` ➋ to recursively
    extract the data from the input file (the `reverse` just prior to this is needed
    since the recursive call builds up the data in the reverse order). Note that `rec-list`
    is initialized with an empty list. The identifier `rec` ➌ is populated with a
    single row from the input file. Once the end of the file is reached, we output
    the compiled `rec-list`, but until then we use the filter to search for records
    that meet our criteria ➍. When such a record is found, we bind a local version
    of `rec` using our previously defined `format-rec` code ➎. Since we’re in a `let*`
    form, we bind a new local version of `rec` on the next line with data extracted
    from the imported record. Having done this, we add this to the previously imported
    data ➏ and recursively call `loop`. If the filter’s criteria are not met, we simply
    trigger the reading of the next row of data from the import file with the existing
    data ➐.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的主体部分，我们设置了一个名为`loop` ➋的函数，用于递归提取输入文件中的数据（在此之前的`reverse`是必需的，因为递归调用会反向构建数据）。请注意，`rec-list`初始化为空列表。标识符`rec`
    ➌被填充为输入文件中的一行记录。一旦文件末尾被达到，我们将输出编译后的`rec-list`，但在此之前，我们使用过滤器搜索符合条件的记录 ➍。当找到这样的记录时，我们使用之前定义的`format-rec`代码
    ➎将`rec`的本地版本绑定。由于我们在`let*`形式中，因此我们将在下一行绑定一个新的本地版本的`rec`，并从导入的记录中提取数据。完成此操作后，我们将其添加到之前导入的数据中
    ➏，并递归调用`loop`。如果过滤器的条件不符合，我们只需触发读取导入文件中的下一行数据，并保留现有数据 ➐。
- en: Let’s take a look at the year 2008 when things started to go horribly wrong
    in the financial sector. (The `substring` function is used to pull the year out
    of the date field and display only records where the year is equal to 2008.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下2008年，当时金融部门开始出现严重问题。（`substring`函数用于从日期字段中提取年份，并仅显示年份等于2008的记录。）
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: During that year, the Dow swung from a high of 13,279.54 in January to a low
    of 7,449.38 in November. A swing of 5,380 points, or a 44 percent drop!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在那一年，道琼斯指数从1月的13,279.54点跌至11月的7,449.38点。下跌幅度达到5,380点，或44%的跌幅！
- en: A year earlier, Microsoft had been averaging around $30 a share, but it dropped
    below $19 a few times in 2008\. Let’s see when that happened.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一年前，微软的股票平均价格约为每股$30，但在2008年几次跌破$19。我们来看一下那时发生了什么。
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A Database Detour
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库绕行
- en: This section is entirely optional since the rest of the chapter isn’t dependent
    on the ideas presented here. But we do want to present some information on random
    file access that could be useful in various scenarios. *Random file access* is
    a key component for efficient data queries. In particular, random file access
    is a critical component in any database. A database is mainly just a predefined
    collection of tables, with each table potentially containing multiple records.
    So far, to locate a particular record in a table, we’ve scanned a file, record
    by record, until the desired entry was located. On average half the records have
    to be checked, and in the worst case, all the records are checked. This is clearly
    not very efficient.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是完全可选的，因为本章的其余部分不依赖于这里介绍的思想。但我们确实想要介绍一些随机文件访问的信息，这在各种场景中可能会很有用。*随机文件访问*是高效数据查询的关键组件。特别是，随机文件访问是任何数据库中的一个关键组件。数据库主要是一个预定义的表格集合，每个表可能包含多个记录。到目前为止，为了在一个表中找到特定的记录，我们需要逐条扫描文件，直到找到所需的条目。平均而言，必须检查一半的记录，在最坏的情况下，所有记录都要检查。这显然不是很高效。
- en: 'Normally, we’re looking for a particular date, and the fact that the records
    are in date order suggests that a binary search might be applicable (if you don’t
    know what a binary search is, we’ll delve into the details shortly); but there
    is a problem. In CSV files, the records are packed together with a variable number
    of characters in each record, so there is no way to accurately get positioned
    on a particular record without reading through the file starting from the beginning.
    The key is to allocate slots for each record where each slot is a fixed size,
    but large enough to hold the largest record. To facilitate this, we’ll define
    the following function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们是在查找特定日期，而记录是按日期顺序排列的，这表明可能适用二分查找（如果你不知道什么是二分查找，稍后我们会详细介绍）；但是有一个问题。在CSV文件中，记录是以可变长度的字符数打包在一起的，因此无法通过不从文件开头逐行读取的方式准确定位到特定记录。关键是为每条记录分配固定大小的槽，每个槽的大小足以容纳最大的记录。为方便起见，我们将定义以下函数：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This function scans the input file to determine the number of records in the
    file and the maximum record size.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数扫描输入文件，以确定文件中的记录数量和最大记录大小。
- en: 'With the information returned from `file-info`, we can construct an appropriately
    formatted data file. This file reserves the first slot to hold the information
    returned from `file-info` since this will be useful when we get around to actually
    searching the file. The remaining slots are populated with values from the source
    file by using the `file-position` function to set the location the values are
    written to (by calling `display`). Unused space at the end of a record is filled
    with zero (0) bytes. To actually create the file, we define a function called
    `csv->db`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 `file-info` 返回的信息，我们可以构建一个适当格式的数据文件。这个文件保留第一个槽来存放 `file-info` 返回的信息，因为这在我们实际搜索文件时会非常有用。其余槽将通过使用
    `file-position` 函数设置位置来填充源文件中的值（通过调用 `display`）。记录末尾的未使用空间将填充零（0）字节。为了实际创建文件，我们定义了一个名为
    `csv->db` 的函数：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This function creates a data file in the same folder as the source file, with
    the same name, except that the output file ➊ has *.db* as a file extension instead
    of *.csv*. Next, we set the file position to the end of the file ➋ and write a
    dummy record ➌. This is an efficiency step to keep the operating system from constantly
    enlarging the file every time a record is written. We write the number of records
    and slot size to the first record in the file ➍ ➎. For each record in the input
    file, we then position the output file pointer ➏ and write out the record ➐.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会在与源文件相同的文件夹中创建一个数据文件，文件名相同，只是输出文件 ➊ 的扩展名为 *.db*，而不是 *.csv*。接下来，我们将文件位置设置到文件末尾
    ➋ 并写入一个虚拟记录 ➌。这个步骤是为了提高效率，防止操作系统每次写入记录时都不断扩展文件大小。我们将记录数量和槽大小写入文件的第一条记录 ➍ ➎。然后，对于输入文件中的每条记录，我们设置输出文件指针
    ➏ 并写出记录 ➐。
- en: 'Having thus created a searchable data file, we can now create a routine to
    perform a binary search to efficiently find a record for a particular date. (For
    more detailed information on binary searches in general, see the Wikipedia article:
    [*http://en.wikipedia.org/wiki/Binary_search_algorithm*](http://en.wikipedia.org/wiki/Binary_search_algorithm).)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样创建了一个可搜索的数据文件后，我们现在可以创建一个例程，执行二分查找以高效地找到特定日期的记录。（有关二分查找的更详细信息，请参阅维基百科文章：[
    *http://en.wikipedia.org/wiki/Binary_search_algorithm* ](http://en.wikipedia.org/wiki/Binary_search_algorithm)。）
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we perform some basic initialization ➊ ➋. After opening the input file,
    we read the first record (which contains the number of records and slot size)
    and bind `recs` and `slot-size` to the appropriate values. Next, we define a couple
    of helper functions to simplify retrieving data for the current record ➌ ➍. The
    remainder of the code is a straightforward implementation of a binary search routine,
    the main body consisting of a loop (via recursive function `loop`). The search
    begins by testing whether any records remain to be checked ➎. If `(> min max)`
    is true, all records have been checked and no match has been found, so the function
    returns `#f`. Next, we compare the date of the middle element of the file with
    the target date ➏. If the target date matches the middle element, the current
    record is returned ➑. If the target date is less than or greater than the date
    of the current element, the search continues by narrowing down the range of the
    file by resetting `min` ➏ and `max` ➐ as needed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们执行一些基本的初始化 ➊ ➋。打开输入文件后，我们读取第一条记录（其中包含记录数和槽大小），并将 `recs` 和 `slot-size` 绑定到相应的值。接下来，我们定义几个辅助函数，以简化检索当前记录数据的过程
    ➌ ➍。其余代码是二分查找常规的直观实现，主要部分由一个循环组成（通过递归函数 `loop`）。搜索首先通过测试是否还有记录待检查 ➎。如果 `(> min
    max)` 为真，则表示所有记录都已检查过且未找到匹配项，因此函数返回 `#f`。接下来，我们将文件中间元素的日期与目标日期进行比较 ➏。如果目标日期与中间元素匹配，则返回当前记录
    ➑。如果目标日期小于或大于当前元素的日期，则通过根据需要重置 `min` ➏ 和 `max` ➐ 来缩小文件范围，继续进行搜索。
- en: 'We test our creation by first forming a searchable data file for Microsoft
    stock prices with the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过首先使用以下内容创建一个可搜索的微软股票价格数据文件来测试我们的创建：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we’re then interested in retrieving the stock price record for March 13,
    1992, we do it like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们接下来想要检索1992年3月13日的股票价格记录，我们可以这样做：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The Microsoft file has 7,768 records. On average, a linear search would have
    to examine 3,884 records. The worst-case performance of a binary search is given
    by the following expression, where *t* is the number of checks that need to be
    performed and *n* is the number of records:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 文件有7,768条记录。平均而言，线性搜索需要检查3,884条记录。二分查找的最坏情况性能由以下公式给出，其中 *t* 是需要执行的检查次数，*n*
    是记录的数量：
- en: '*t* = ⌊log[2](n + 1)⌋'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*t* = ⌊log[2](n + 1)⌋'
- en: This means that searching the Microsoft data would only require the following
    checks. Examining 12 records is a lot better than examining 3,884.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着搜索微软数据只需要进行以下检查。检查12条记录远比检查3,884条要好得多。
- en: '![Image](../images/p0158-1.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0158-1.jpg)'
- en: Data Visualization
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据可视化
- en: 'A picture is worth a thousand dollars, er . . . a thousand words. So far we’ve
    been looking at data. Now we want to look at information. The difference is this:
    data is just a raw assemblage of numbers, dates, and strings; information says
    how these things are related. Just perusing a list of numbers doesn’t provide
    much insight into their meaning, but often a visual representation invokes an
    epiphany. In light of this, we turn to the topic of data visualization. In this
    section we’ll look at financial data in two different ways: value over time and
    frequency analysis via histograms.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一张图片胜过千言万语，呃…千字。到目前为止，我们一直在查看数据。现在我们想要查看信息。两者的区别在于：数据只是数字、日期和字符串的原始集合；而信息则说明这些事物如何相互关联。仅仅浏览数字列表并不会提供太多对其含义的洞察，但往往一个视觉化的表现能够带来顿悟。考虑到这一点，我们转向数据可视化的主题。在本节中，我们将从两个不同的角度来看待财务数据：随时间变化的价值和通过直方图的频率分析。
- en: To ensure that we have everything we need, we start from scratch with the following
    definitions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保我们拥有所需的一切，我们从以下定义开始。
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Most of this should be self-explanatory. As a reminder, the `text-table` package
    isn’t part of the default Racket setup (see [“Getting Data into Racket” on page
    150](ch06.xhtml#ch00lev1sec_36) for more info). We use `data-path` to keep from
    hardcoding the file paths in the body of various functions. To differentiate multiple
    assets on plots, they’re assigned unique colors in `symbol-color` and line styles
    in `symbol-style`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 其中大部分应该不言自明。提醒一下，`text-table` 包并不是默认的 Racket 设置的一部分（更多信息请参见第150页的[“将数据导入Racket”](ch06.xhtml#ch00lev1sec_36)）。我们使用
    `data-path` 来避免在各种函数体内硬编码文件路径。为了区分图表上的多个资产，它们在 `symbol-color` 中被分配了独特的颜色，在 `symbol-style`
    中分配了线条样式。
- en: We’ll again make use of `import-record`, which is reproduced here.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用 `import-record`，如下所示。
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While this function extracts everything in the record, for the remainder of
    the chapter we’ll primarily be interested in the date and closing price.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个函数提取了记录中的所有内容，但在本章剩余部分，我们将主要关注日期和收盘价。
- en: 'Since we’ll be plotting time-varying values, we need to convert the date string
    from each record into a numeric value. We can do this with the following vector
    and function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将绘制随时间变化的值，我们需要将每个记录中的日期字符串转换为数值。我们可以通过以下向量和函数来完成：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `month-days` vector provides the number of elapsed days in the year for
    the first day of any given month (the month number is the index; for example,
    February is represented by index 2). For example the entry with index 2 is 31,
    indicating that on February 1, 31 days have elapsed. Months after February have
    an extra quarter-day to account for leap years. The date conversion happens in
    `date->number` where the year forms the integer portion of the date, and the month
    and day provide the fractional portion. The fact that February can have 28 or
    29 days is handled by an approximation that should be sufficient for our purpose.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`month-days` 向量提供了年份中每个月第一天经过的天数（月份编号是索引；例如，二月的索引是2）。例如，索引为2的条目是31，表示2月1日已经过去了31天。2月之后的月份有额外的四分之一天来考虑闰年。日期转换发生在
    `date->number` 函数中，年份构成日期的整数部分，而月份和日期则提供小数部分。2月可能有28天或29天的问题通过近似值来处理，这对于我们的目的应该足够。'
- en: '***Plotting for Success***'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***成功绘图***'
- en: 'As you saw in the [Chapter 4](ch04.xhtml), Racket plots a sequence of line
    segments by using a `lines` form that takes a list of vectors as its argument.
    Each vector specifies the *x* (date) and *y* (close price) coordinates of a segment
    end point. To construct this list, we use the `get-coords` function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第4章](ch04.xhtml)中看到的，Racket 通过使用 `lines` 形式来绘制一系列线段，该形式以一个向量列表作为参数。每个向量指定了一个线段的
    *x*（日期）和 *y*（收盘价）坐标。为了构建这个列表，我们使用 `get-coords` 函数：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As with other examples, this function takes the stock symbol, time period type,
    and a filter function as arguments. Since the assets we’re examining can have
    widely differing values, to enable showing them on the same plot we provide the
    ability to normalize the values with an extra parameter. What this means is that
    instead of plotting the actual value, we plot the ratio of the first value in
    the time period to the actual value ➊. This way all the assets start out with
    a value of 1, but we still see how the relative values vary over time. A few examples
    will make this clear shortly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他示例一样，这个函数接受股票符号、时间段类型和一个过滤函数作为参数。由于我们正在检查的资产可能有很大的价值差异，为了能在同一图表上显示它们，我们提供了通过额外参数规范化值的功能。这意味着我们不会绘制实际的值，而是绘制时间段内第一个值与实际值的比率
    ➊。这样，所有资产的起始值都是1，但我们仍然可以看到它们随时间变化的相对值。稍后通过几个示例会更加清晰。
- en: The routine that does the plotting is quite simple.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 执行绘图的例程非常简单。
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This time we provide it with a list of stock symbols (to allow multiple assets
    to be plotted at the same time), a time period type, and a filter function as
    arguments. We also have the option to specify whether or not the plot normalizes
    the data with the optional `normalize` parameter, which defaults to `#f`. Since
    plotted values can occur on just about any portion of the plot, we allow the user
    to specify where the legend is positioned with the optional `anchor` parameter.
    In addition we allow the user to override the default range of *y* values.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们为它提供了一组股票符号（以允许同时绘制多个资产），一个时间段类型，以及一个过滤函数作为参数。我们还可以选择是否使用可选的 `normalize`
    参数来规范化数据，默认为 `#f`。由于绘制的值几乎可以出现在图表的任何部分，我们允许用户通过可选的 `anchor` 参数指定图例的位置。此外，我们还允许用户覆盖
    *y* 值的默认范围。
- en: Since we’re primarily going to be plotting data for some range of years or dates,
    we’ll define a couple of function factories that create query functions by specifying
    the range of dates we’re interested in.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们主要会绘制某个年份或日期范围的数据，我们将定义几个函数工厂，通过指定我们感兴趣的日期范围来创建查询函数。
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Having established the prerequisites, we’re ready to generate some plots. Let’s
    begin by plotting Dow Jones data for 2007 and 2008 (see [Figure 6-2](ch06.xhtml#ch6fig2)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了先决条件后，我们准备生成一些图表。让我们从绘制2007年和2008年的道琼斯数据开始（见[图6-2](ch06.xhtml#ch6fig2)）。
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Image](../images/06fig03.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig03.jpg)'
- en: '*Figure 6-2: Dow Jones daily close price 2007–2008*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：道琼斯2007–2008年每日收盘价*'
- en: Now we can actually *see* the precipitous drop that occurred in October of 2008\.
    Next, let’s look at a few other institutions to see how they fared (see [Figure
    6-3](ch06.xhtml#ch6fig3)).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实际*看到* 2008 年 10 月发生的急剧下跌了。接下来，让我们看看其他一些机构的表现如何（见 [图 6-3](ch06.xhtml#ch6fig3)）。
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Image](../images/06fig04.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig04.jpg)'
- en: '*Figure 6-3: Multiple daily close prices*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：多个日度收盘价格*'
- en: Unfortunately, the Dow numbers are so large, they’ve swamped everybody else.
    Now let’s see what happens when we normalize the numbers (see [Figure 6-4](ch06.xhtml#ch6fig4)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，道琼斯指数的数字太大，它已经淹没了其他所有指标。现在让我们来看一下当我们对数字进行标准化时会发生什么（见 [图 6-4](ch06.xhtml#ch6fig4)）。
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![Image](../images/06fig05.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig05.jpg)'
- en: '*Figure 6-4: Normalized daily close prices*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：标准化的日度收盘价格*'
- en: It’s clear that the Dow and S&P 500 general market indices track fairly close
    to each other. Apple is all over the map. The bond fund stayed steady throughout
    the mayhem.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，道琼斯指数和标准普尔 500 指数整体市场走势非常接近。苹果的走势则波动较大。债券基金在这场混乱中保持稳定。
- en: What have we learned? Well, it would be foolish to make too many assumptions
    based on a few plots. It’s fairly clear, though, that at least for this time period,
    bonds barely wiggled, the market as a whole (represented by the index indicators
    S&P 500 and the Dow) had some turbulence, but not as much as Apple.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了什么？嗯，基于几个图表做出太多假设是愚蠢的。不过，至少在这个时间段内，债券几乎没有波动，整个市场（由标准普尔 500 指数和道琼斯指数代表）有些波动，但不如苹果股价波动那么大。
- en: Let’s take a longer view and see what comes up in [Figure 6-5](ch06.xhtml#ch6fig5).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更长远的角度来看一下，看看 [图 6-5](ch06.xhtml#ch6fig5) 展现了什么。
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Image](../images/p0165-01.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0165-01.jpg)'
- en: '*Figure 6-5: Monthly close prices 1981–2016*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：1981-2016 年月度收盘价格*'
- en: 'So around 2005-ish, Apple went off the chart (more about that a bit latter).
    Let’s examine ExxonMobil in a bit more detail. Since this is a normalized chart,
    we’re seeing the relative difference in the prices; this means that at the end
    of 2016, ExxonMobil stock was worth roughly 18 times what it was worth at the
    beginning of 1981\. Sounds like a lot, but is it really? We can get some idea
    of the average annual return this represents by using the compound interest formula
    given by the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所以大约在 2005 年左右，苹果股价突破了图表（稍后会详细讲解）。让我们更详细地研究一下埃克森美孚。由于这是一个标准化的图表，我们看到的是价格的相对差异；这意味着在
    2016 年底，埃克森美孚的股票大约是 1981 年初价格的 18 倍。听起来很多，但真的是这样吗？我们可以通过使用复利公式来大致了解这代表的年平均回报率：
- en: '![Image](../images/p0165-02.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0165-02.jpg)'
- en: 'In this formula, *V* is the current value, *P* is the initial principal, *i*
    is the annual interest rate, *n* is the number of compounding periods per year
    (we’re going to assume monthly compounding, so this will be 12), and *t* is the
    number of periods (so *nt* is 12 times the number of years). We want to know the
    annual interest *i*, so after a bit of algebra (we won’t bore you with the details),
    we get this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，*V* 是当前价值，*P* 是初始本金，*i* 是年利率，*n* 是每年的复利周期数（我们假设为按月复利，因此这里是 12），*t* 是周期数（所以
    *nt* 是 12 乘以年份数）。我们想要知道年利率 *i*，所以经过一点代数运算（我们不在此赘述细节），得到这个公式：
- en: '![Image](../images/p0165-03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0165-03.jpg)'
- en: 'The following function will calculate this value for us:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将为我们计算这个值：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So over 35 years, $1 invested in ExxonMobil stock would yield an interest rate
    of . . .
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 35 年的时间里，投资 1 美元在埃克森美孚股票上将获得的利率是……
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Or around 8 percent, which is quite respectable given that ExxonMobil also pays
    quarterly dividends, which sweetens the pot even more.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 或者约 8%，考虑到埃克森美孚也每季度支付股息，这无疑让投资回报更具吸引力。
- en: But what about that wild stallion, Apple? Well, let’s adjust our range a bit
    and see what develops.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 那么那匹狂野的独角兽——苹果呢？让我们稍微调整一下范围，看看会发生什么。
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![Image](../images/06fig07.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig07.jpg)'
- en: '*Figure 6-6: Monthly close prices up to $300*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：月度收盘价格最高达 300 美元*'
- en: Wow, a dollar invested in 1981 (after a long dry spell) would be worth about
    $225 at the end of 2016\. Who knew? Let’s see what the effective interest rate
    is.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，1981 年投资的一美元（经过长时间的低迷期）到 2016 年底将值约 225 美元。谁能想到？让我们看看实际的利率是多少。
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Almost 16 percent—not too shabby. Is Apple a good investment? Well, any (honest)
    financial advisor will tell you this repeatedly: past performance is not a guarantee
    of future results.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎 16%——不错吧。苹果是一个好的投资吗？嗯，任何（诚实的）财务顾问都会反复告诉你这一点：过去的表现并不能保证未来的结果。
- en: '***Lumping Things Together***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将事物合并在一起***'
- en: 'One thing besides the outrageous return on investment (ROI) of Apple stands
    out: its value is very erratic. Let’s look at ExxonMobil and Apple during the
    period of time before things got really crazy in 2008 (see [Figure 6-7](ch06.xhtml#ch6fig7)).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了苹果的投资回报率（ROI）令人瞠目结舌外，还有一点特别突出：它的股价波动非常大。让我们来看一下2008年事情变得疯狂之前，埃克森美孚和苹果的股价（参见[图6-7](ch06.xhtml#ch6fig7)）。
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![Image](../images/06fig08.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig08.jpg)'
- en: '*Figure 6-7: Apple and ExxonMobil before the crash*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-7：苹果与埃克森美孚在崩盘前的情况*'
- en: It’s clear that even over this short interval of time, the value of Apple from
    one day to the next would not be easy to predict. If someone isn’t interested
    in the specific value of a stock, but rather how variable it is, one way to visualize
    the variability is with a histogram. A *histogram* represents data by showing
    how often values fall into certain ranges. We call these ranges *bins*. To aid
    in our analysis, we’ll supplement each histogram with a table that gives the range
    of values and counts for each bin.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，即使是在这段短暂的时间内，苹果从一天到另一天的股价也很难预测。如果某人对股票的具体数值不感兴趣，而是对其波动性更感兴趣，一种可视化波动性的方法是使用直方图。*直方图*通过显示数据值如何分布在某些区间中来表示数据。我们将这些区间称为*箱子*。为了帮助我们的分析，我们将每个直方图与一个表格一起展示，表格中显示每个箱子的数值范围和各箱子中的数值数量。
- en: To begin, we define a function that extracts a particular data field for an
    investment given the stock symbol, period, filter function, and the corresponding
    `hist` structure field.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个函数，它根据股票符号、时间段、过滤函数和相应的`hist`结构字段提取投资的特定数据字段。
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For example if we wanted the maximum stock cost for Microsoft in 1999 (a pretty
    good year for Microsoft) in the monthly data, we could get it this way:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要查看1999年微软（对微软来说是一个相当不错的年份）在每月数据中的最大股价，我们可以通过以下方式获取：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The following function compiles the data (a list of values) and populates bins
    with the proper count of values.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数会汇总数据（数值列表）并将正确数量的值填入箱子中。
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This function first sets an overall range of values that are 60 percent below
    and 60 percent above the average value. Within this range, data values will be
    compiled into the `bin` vector. At the end of the process, the function returns
    the overall minimum and maximum range of the bins as well as categorized values
    contained in `bin`. Each vector in `bin` contains the bin index and the number
    of values in the bin (it has to be formatted this way to work with Racket’s `discrete-histogram`
    function).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先设置一个整体值范围，这个范围低于平均值60%并且高于平均值60%。在这个范围内，数据值将被汇总到`bin`向量中。在处理的最后，函数返回这些箱子的最小值和最大值范围，以及`bin`中包含的分类值。`bin`中的每个向量包含箱子索引和箱子中的数据值数量（它必须以这种方式格式化才能与Racket的`discrete-histogram`函数一起使用）。
- en: To display the data in tabular form, we define `bin-table`, which will display
    the bin index along with the range of values for the bin and the number of values
    in each bin.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以表格形式显示数据，我们定义了`bin-table`，它将显示箱子索引、箱子的数值范围以及每个箱子中的数据数量。
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: After we’ve laid the groundwork, creating a function to generate the output
    is quite simple.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们打好基础后，创建一个函数来生成输出是相当简单的。
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let’s see what this tells us about Apple and ExxonMobil (see [Figures 6-8](ch06.xhtml#ch6fig8)
    and [6-9](ch06.xhtml#ch6fig9)).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这对苹果和埃克森美孚告诉了我们什么（参见[图6-8](ch06.xhtml#ch6fig8)和[图6-9](ch06.xhtml#ch6fig9)）。
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![Image](../images/06fig09.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig09.jpg)'
- en: '*Figure 6-8: Apple histogram*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-8：苹果直方图*'
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![Image](../images/06fig09.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig09.jpg)'
- en: '*Figure 6-9: ExxonMobil histogram*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-9：埃克森美孚直方图*'
- en: It’s clear from the histograms that values for Apple are dispersed over a wider
    range of values than the data for ExxonMobil for the same time period. This higher
    volatility is the price Apple investors pay for the possibility of getting larger
    returns.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从直方图可以清楚地看出，苹果的数据值在同一时间段内比埃克森美孚的数据值分布范围更广。这种更高的波动性是苹果投资者为可能获得更大回报而付出的代价。
- en: A Bit of Statistics
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一点统计学
- en: We demonstrated in the previous section that the old truism that a picture is
    worth a thousand words makes a bit of sense, at least in terms of analyzing investment
    data. But it’s also true that a single number is worth, well, at least one picture.
    So far our analysis has primarily been qualitative, where we used a number of
    techniques to visualize our data. We now turn to a couple of standard statistical
    tools that are widely used for quantitative analysis.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中展示了这样一个老生常谈的道理：一张图片胜过千言万语，这至少在分析投资数据时是有一定道理的。但同样正确的是，一个数字也至少值得上一张图片。到目前为止，我们的分析主要是定性的，我们使用了多种技巧来可视化我们的数据。现在我们转向一些广泛用于定量分析的标准统计工具。
- en: '***Standard Deviation***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***标准差***'
- en: 'In the last section, we looked at using histograms to get some idea of how
    widely dispersed stock values were over some period of time. This type of information
    can be summed up in a single number called the *standard deviation*. For a given
    set of numbers, the standard deviation indicates how much individual numbers deviate
    from the overall average of the set. You might think of it as the average amount
    of deviation. Standard deviation is defined by the following formula:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用直方图来了解某一时间段内股价的分布情况。这类信息可以用一个数字来总结，这个数字就是*标准差*。对于一组给定的数字，标准差表示个别数字偏离该组数据总体平均值的程度。你可以将它视为偏差的平均值。标准差的定义如下公式：
- en: '![Image](../images/p0172-02.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0172-02.jpg)'
- en: In this equation, *n* is the number of values, the Greek letter mu (*μ*) represents
    the mean or average of all the data values, and the *x*[*i*] represents the individual
    numbers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，*n*是数据值的数量，希腊字母mu（*μ*）表示所有数据值的均值或平均值，*x*[*i*]表示单个数据值。
- en: 'Closely related to standard deviation is the statistical concept of *variance*,
    which is simply the square of the standard deviation:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准差密切相关的统计概念是*方差*，它实际上是标准差的平方：
- en: '![Image](../images/p0173-01.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0173-01.jpg)'
- en: We shall see a bit later that variance is useful in regression analysis where
    we attempt to determine how data is trending.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看到，方差在回归分析中非常有用，回归分析旨在确定数据的趋势。
- en: 'We wrap the standard deviation formula in a Racket function as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将标准差公式封装到一个Racket函数中，如下所示：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We can now compute numerical values with which we can analyze the deviation
    of different assets. Let’s take a look at the data we generated histograms for.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以计算数值，从而分析不同资产的偏差。让我们来看一下我们生成的直方图数据。
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This *seems* to indicate that Apple actually had less deviation than ExxonMobil.
    This is where the proper interpretation of data is crucial. The histogram data
    showed us the spread of data within ± 60% of the *average* value. To make sense
    of the deviation data, let’s get the average value of these stocks.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这*似乎*表明苹果的偏差实际上小于埃克森美孚。这时，数据的正确解释至关重要。直方图数据向我们展示了数据在±60%的*平均*值范围内的分布情况。为了更好地理解偏差数据，我们来计算一下这些股票的平均值。
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: From this we can now see that Apple typically deviated almost 24 percent from
    its average price during that period whereas ExxonMobil only deviated about 7.5
    percent.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以看出，在那段时间内，苹果的价格偏离其平均价格大约24%，而埃克森美孚仅偏离约7.5%。
- en: While here we’re strictly looking at the standard deviation of the close price,
    this is *not* how deviation is normally evaluated in a financial sense. What is
    of most interest in that regard is deviation of *returns*. A stock that has a
    steady 10 percent annual return would clearly have some price deviation, but it
    would have almost no deviation based on returns. Another consideration is that
    change in stock price alone is not necessarily an indication of returns since
    dividends (for those stocks that pay dividends) come into play as well.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里严格地看的是收盘价的标准差，但这*不是*通常在金融领域评估偏差的方式。更为关注的是*收益*的偏差。一个年回报率稳定为10%的股票显然会有一些价格偏差，但根据收益来看的话，它几乎没有偏差。另一个需要考虑的因素是，单纯的股价变化并不一定能反映出收益，因为股息（对于那些支付股息的股票）也会影响结果。
- en: '***Regression***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***回归分析***'
- en: 'In our analysis of various financial assets, we’ve mentioned the adage that
    past performance is not a guarantee of future results, which is true, but past
    performance might suggest future results. Given a disparate set of data points,
    it’s often of interest to determine whether or not they suggest a trend. The statistical
    tool called *regression analysis* attempts to make just such a determination.
    Regression analysis fits a straight line to a set of data points (since we’re
    only fitting our data to a straight line, this is technically called *linear regression*)
    where *x* is called the *independent predictor* or *predictor variable*, and *y*
    is called the *dependent response*. The desired outcome is this *regression* or
    *prediction* line:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对各种金融资产的分析中，我们提到过“过去的表现不能保证未来的结果”这句格言，这是正确的，但过去的表现可能暗示未来的结果。给定一组不同的数据点，常常需要确定它们是否暗示着某种趋势。名为
    *回归分析* 的统计工具旨在做出这种判断。回归分析将一条直线拟合到一组数据点（由于我们只是将数据拟合到直线，这技术上称为 *线性回归*），其中 *x* 称为
    *独立预测变量* 或 *预测变量*，*y* 称为 *依赖响应*。期望的结果是这个 *回归* 或 *预测* 直线：
- en: '*y* = *a + bx*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = *a + bx*'
- en: 'The idea is that given this line and some *x*-value, we can compute an estimated
    value for *y*. The parameters *a* and *b* are defined in such a way as to minimize
    the total distance of the *y* data values from the line. Specifically, if (*x*[*i*],
    *y*[*i*]) are the actual data points, we let *ŷ*[*i*] = *a* + *bx*[*i*] (this
    is the estimated value of *y* at *x*[*i*]), in which case regression analysis
    seeks to minimize the *sum of squares errors* given by the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 其思想是，给定这条直线和某个 *x* 值，我们可以计算出 *y* 的估计值。*a* 和 *b* 参数的定义方式是最小化 *y* 数据值与回归线之间的总距离。具体而言，如果
    (*x*[*i*], *y*[*i*]) 是实际的数据点，我们让 *ŷ*[*i*] = *a* + *bx*[*i*]（这是 *x*[*i*] 处的 *y*
    估计值），在这种情况下，回归分析的目标是最小化以下公式所给出的 *平方和误差*：
- en: '![Image](../images/06eqa01.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06eqa01.jpg)'
- en: 'If ![Image](../images/x-bar.jpg) is the mean, or average, of all the *x* values
    and ![Image](../images/y-bar.jpg) is the mean of all the *y* values, it can be
    shown that the *a* and *b* parameters of the regression line are given by the
    following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ![Image](../images/x-bar.jpg) 是所有 *x* 值的均值，或平均值，而 ![Image](../images/y-bar.jpg)
    是所有 *y* 值的均值，那么可以证明，回归线的 *a* 和 *b* 参数由以下公式给出：
- en: '![Image](../images/p0174-04.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0174-04.jpg)'
- en: 'The formidable-looking Equation (6.1) is actually the ratio of two simpler
    formulas: the *covariance* of *x* and *y* and the variance of *x*. We’ve already
    seen that the variance of *x* is given by the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 看似复杂的方程（6.1）实际上是两个更简单公式的比率：*x* 和 *y* 的 *协方差* 以及 *x* 的方差。我们已经看到，*x* 的方差由以下公式给出：
- en: '![Image](../images/p0174-01.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0174-01.jpg)'
- en: 'The covariance of *x* and *y* is defined by the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* 和 *y* 的协方差由以下公式给出：'
- en: '![Image](../images/p0174-02.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0174-02.jpg)'
- en: Covariance is a measure of the joint variability of two random variables (in
    our case the *x*[*i*] and *y*[*i*]). We make use of the following slightly altered
    form of these last two equations, along with a couple of others, to develop a
    method to determine how well our regression line actually fits the data.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 协方差是衡量两个随机变量联合变化的度量（在我们的案例中是 *x*[*i*] 和 *y*[*i*]）。我们利用这两个方程的略微调整形式，以及其他一些方程，来开发一种方法，确定我们的回归线在多大程度上真实地拟合数据。
- en: '![Image](../images/p0174-03.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0174-03.jpg)'
- en: 'We see that SS[*xx*] is just a slightly tweaked version of ![Image](../images/p174.jpg)
    and SS[*xy*] is likewise a tweaked version of Cov(*x*, *y*). The last equation,
    sum of squares regression, represents the sum of the squares of the distance of
    the estimated *ŷ*’s from the mean of the *y*-values to the regression line (the
    line that minimizes this distance will give us the best fit to the data). We saw
    in Equation (6.1) that the slope of the regression line is given by the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，SS[*xx*] 只是 ![Image](../images/p174.jpg) 的略微调整版本，而 SS[*xy*] 同样是 Cov(*x*,
    *y*) 的调整版本。最后一个方程，平方和回归，表示的是估计的 *ŷ* 从 *y* 值的均值到回归线的距离的平方和（最小化这个距离的回归线将给出最佳的拟合数据）。我们在方程（6.1）中看到，回归线的斜率由以下公式给出：
- en: '![Image](../images/06eqa03.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06eqa03.jpg)'
- en: 'But the following can also be shown:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 但是也可以证明：
- en: '![Image](../images/p0175-01.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/p0175-01.jpg)'
- en: The last equation is called the *squared correlation* or *coefficient of determination*.
    This number can vary between 0 and 1\. A value of 1 indicates the data points
    perfectly fit the regression line, and a value of 0 indicates there’s no correlation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一方程称为*平方相关*或*决定系数*。这个数值在0和1之间变化。值为1表示数据点完全拟合回归线，值为0表示没有任何相关性。
- en: 'The regression line parameters can be computed with the following Racket function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 回归线的参数可以通过以下Racket函数计算：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is a straightforward adaption of Equations (6.1) and (6.2). Let’s see what
    this tells us about Bank of America when it was in its downward spiral during
    the 2008 financial crisis.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对方程（6.1）和（6.2）的直接改编。让我们看看这对在2008年金融危机期间陷入下行漩涡的美国银行有什么启示。
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The second value is the slope of the regression line, which indicates that during
    that period, it was losing an average of $27 per year (over half its value in
    July of 2007). Ouch.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个值是回归线的斜率，它表示在那个时期，平均每年损失27美元（相当于2007年7月其价值的一半）。哎呀。
- en: We now define a plot routine that accepts a single asset symbol, but that plots
    the data points instead of lines and includes the corresponding regression line.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义一个绘图例程，接受单一资产符号，但绘制数据点而不是线条，并包括相应的回归线。
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can see Bank of America’s distress in graphic detail in [Figure 6-10](ch06.xhtml#ch6fig10).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[图 6-10](ch06.xhtml#ch6fig10)中详细查看美国银行的困境。
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![Image](../images/06fig10.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig10.jpg)'
- en: '*Figure 6-10: Regression line plotted on Bank of America data*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-10：美国银行数据上的回归线*'
- en: 'To determine how well the regression line fits the data, we define a `correlation`
    function:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定回归线与数据的拟合程度，我们定义一个`correlation`函数：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is also just a direct implementation of the definition of *R*² given above.
    With this we can test the fit of the Bank of America least squares line to the
    data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是对上述*R*²定义的直接实现。通过这个，我们可以测试美国银行最小二乘回归线与数据的拟合情况。
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This indicates a fairly good fit. But in many cases the data doesn’t provide
    a good fit with a straight line. For instance if we include the start of the recovery
    phase, we wind up with a plot such as the following in [Figure 6-11](ch06.xhtml#ch6fig11).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示拟合得相当不错。但在许多情况下，数据并不能很好地与直线拟合。例如，如果我们包括恢复阶段的开始，最终得到的图像就像[图 6-11](ch06.xhtml#ch6fig11)中所示。
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![Image](../images/06fig11.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig11.jpg)'
- en: '*Figure 6-11: Poorly fitting regression line*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-11：拟合不好的回归线*'
- en: 'And this indicates some degree of correlation, but not as good as what we had
    before:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示一定程度的相关性，但不如之前的拟合效果好：
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at various ways of accessing and analyzing data using
    Racket and DrRacket. We began by introducing the mechanics of how to import and
    export data to and from Racket ports. Once we had mastered this bit of technology,
    we leveraged it to look at securities in the form of raw historical stock market
    values. We then took a slight detour and explored binary search using random file
    access. Having defined a mechanism to access and parse our stock market data,
    we then looked at qualitative methods to analyze our data using various visualization
    techniques. Finally, we bit the bullet and introduced a bit of mathematics, which
    allowed us to do some statistical quantitative analysis.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用Racket和DrRacket访问和分析数据的各种方法。我们首先介绍了如何将数据导入和导出到Racket端口的机制。一旦掌握了这一技术，我们就利用它来查看证券数据，即原始历史股市数据。接着，我们稍微绕了一下，探索了使用随机文件访问的二分查找。在定义了访问和解析股市数据的机制之后，我们又通过各种可视化技术来分析数据的定性方法。最后，我们鼓起勇气引入了一些数学内容，使我们能够进行一些统计量化分析。
- en: Next up, we see how we can use some sophisticated search algorithms to solve
    some classical problems in recreational mathematics.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何使用一些复杂的搜索算法来解决一些经典的 recreational mathematics（娱乐数学）问题。
