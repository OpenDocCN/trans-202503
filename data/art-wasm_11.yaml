- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: AssemblyScript
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: AssemblyScript is a high-level language explicitly designed to compile to WebAssembly
    or WAT. AssemblyScript is more expressive than WAT but can compile to it. When
    you use AssemblyScript, you lose some of the fine optimization control that you
    have with WAT, but it’s much faster to write.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript 是一种高级语言，专门设计用于编译成 WebAssembly 或 WAT。AssemblyScript 比 WAT 更具表现力，但仍然可以编译成
    WAT。当你使用 AssemblyScript 时，你失去了一些使用 WAT 时可以进行的细致优化控制，但编写起来要快得多。
- en: We’ll begin this chapter by creating a simple `AddInt``s` function, like the
    `AddInt` one we created in Chapter 1. We’ll write an AssemblyScript hello world
    app and compile it into WAT to see the WebAssembly that the AssemblyScript compiler
    generates. We’ll examine AssemblyScript’s use of length-prefixed strings, and
    then install the AssemblyScript loader to see how it can make it easier to transfer
    strings between AssemblyScript and JavaScript. We’ll pass strings into AssemblyScript
    by writing a string concatenation app. We’ll also explore OOP in AssemblyScript.
    We’ll create a couple of classes to demonstrate class inheritance and discuss
    `private` attributes that prevent AssemblyScript from exporting attributes to
    the embedding environment. Next, we’ll write JavaScript that allows us to create
    `public`, `private`, and `protected`members directly, as well as use the AssemblyScript
    loader. Then we’ll compare the performance of direct and loader function calls.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将通过创建一个简单的 `AddInt``s` 函数开始，类似于我们在第 1 章中创建的 `AddInt`。我们将编写一个 AssemblyScript
    的 Hello World 应用，并将其编译成 WAT，查看 AssemblyScript 编译器生成的 WebAssembly。我们将研究 AssemblyScript
    如何使用长度前缀字符串，然后安装 AssemblyScript 加载器，看看它如何简化在 AssemblyScript 和 JavaScript 之间传递字符串。我们将通过编写一个字符串连接应用来将字符串传入
    AssemblyScript。我们还将探索 AssemblyScript 中的面向对象编程（OOP）。我们将创建几个类来演示类继承，并讨论 `private`
    属性，这些属性可以防止 AssemblyScript 将属性导出到嵌入环境。接下来，我们将编写 JavaScript，使我们能够直接创建 `public`、`private`
    和 `protected` 成员，并使用 AssemblyScript 加载器。然后，我们将比较直接调用与加载器函数调用的性能。
- en: The AssemblyScript team designed it to be similar to TypeScript and JavaScript.
    Unlike WAT, AssemblyScript is a high-level language with features such as classes,
    strings, and arrays. Along with high-level features, AssemblyScript allows users
    to code with low-level WAT-like memory commands. AssemblyScript has a *Command
    Line Interface (CLI)* that can compile AssemblyScript into a WebAssembly module
    for use from within JavaScript applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript 团队设计时参考了 TypeScript 和 JavaScript。与 WAT 不同，AssemblyScript 是一种具有类、字符串和数组等特性的高级语言。除了高级特性外，AssemblyScript
    还允许用户使用类似 WAT 的低级内存命令进行编程。AssemblyScript 提供了一个*命令行界面 (CLI)*，可以将 AssemblyScript
    编译成 WebAssembly 模块，并在 JavaScript 应用程序中使用。
- en: For JavaScript developers interested in using WebAssembly to improve the performance
    of their JavaScript applications, AssemblyScript is a great tool. Unfortunately,
    as with everything in WebAssembly, merely tweaking your TypeScript until it compiles
    with the AssemblyScript compiler might not result in a considerable performance
    boost. Understanding what AssemblyScript does under the hood allows you to write
    code in a language that looks like JavaScript but runs like C++. To gain this
    understanding, we’ll compile AssemblyScript code to WAT to explore the AssemblyScript
    compiler’s output.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于希望使用 WebAssembly 来提高 JavaScript 应用程序性能的 JavaScript 开发者来说，AssemblyScript 是一个很好的工具。不幸的是，正如
    WebAssembly 中的所有内容一样，仅仅调整 TypeScript 直到它能够通过 AssemblyScript 编译器编译，并不一定会带来显著的性能提升。了解
    AssemblyScript 在幕后是如何工作的，可以让你用看似 JavaScript 的语言编写代码，但运行时表现得像 C++。为了获得这种理解，我们将把
    AssemblyScript 代码编译成 WAT，以探索 AssemblyScript 编译器的输出。
- en: AssemblyScript CLI
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AssemblyScript CLI
- en: 'Install AssemblyScript using the following command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装 AssemblyScript：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `npm` command installs AssemblyScript globally, which allows you to use
    the AssemblyScript compiler `asc` command from the command line. Running `asc
    -h` provides a list of compiler command examples and options.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm` 命令全局安装 AssemblyScript，允许你从命令行使用 AssemblyScript 编译器 `asc` 命令。运行 `asc -h`
    会提供编译器命令示例和选项的列表。'
- en: I won’t explain all the command line arguments but will mention a few that are
    useful. The `-O` option optimizes in the same way as `wasm-opt` in Chapter 9.
    You follow `-O` with a number 0 to 3, s, or z, instructing the compiler to optimize
    for size or performance and how much optimization to apply. The `-o` flag when
    followed by the name of a *.wat* file will generate WAT code from the AssemblyScript,
    and when followed by the name of a *.wasm* file will generate a binary WebAssembly
    module. The `--sourceMap` flag creates a source map file to help you debug your
    AssemblyScript from the browser.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会解释所有的命令行参数，但会提到一些有用的参数。`-O`选项与第9章中的`wasm-opt`优化方式相同。你在`-O`后跟一个数字0至3、s或z，指示编译器进行优化，优化目标是大小还是性能，以及应用多少优化。`-o`标志后跟*.wat*文件的名称时，会从AssemblyScript生成WAT代码；而后跟*.wasm*文件的名称时，会生成WebAssembly二进制模块。`--sourceMap`标志创建一个源映射文件，帮助你从浏览器调试AssemblyScript。
- en: We’ll first create a simple AssemblyScript module. Create the file *as_add.ts*
    and add the code in [Listing 11-1](#listing11-1). This is a much simpler version
    of the `AddInt` function in Chapter 1.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个简单的AssemblyScript模块。创建文件*as_add.ts*并添加[清单11-1](#listing11-1)中的代码。这是第一章中`AddInt`函数的一个简化版本。
- en: '**as_add.ts**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**as_add.ts**'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 11-1: Adding two integers'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-1：两个整数相加
- en: We make the `function` available to the embedding JavaScript using the `export`
    1 keyword. It takes two `i32` parameters `a` 2 and `b` 3, and returns `a + b`
    4 as an `i32`. Compile *as_add.ts* using the command in [Listing 11-2](#listing11-2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`export` 1关键字将`function`暴露给嵌入的JavaScript。它接受两个`i32`类型的参数`a` 2和`b` 3，并返回`a
    + b` 4，作为`i32`类型。使用[清单11-2](#listing11-2)中的命令编译 *as_add.ts*。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 11-2: Compiling `AddInt``s` to WAT'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-2：将`AddInt`s`编译为WAT
- en: The `-Oz` flag makes the size of the output binary as small as possible. The
    final flag, `-o` `as_add.wat`, tells the compiler to output WAT. Alternatively,
    we could have compiled a *.wasm* file, such as *as_add.wasm*, which would output
    a WebAssembly binary. When we look at the *as_add.wat* file that is output, we
    see the WAT code in [Listing 11-3](#listing11-3).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Oz`标志使输出的二进制文件尽可能小。最后一个标志`-o` `as_add.wat`告诉编译器输出WAT代码。或者，我们也可以编译一个*.wasm*文件，比如*as_add.wasm*，它将输出WebAssembly二进制文件。当我们查看输出的*as_add.wat*文件时，会看到[清单11-3](#listing11-3)中的WAT代码。'
- en: '**as_add.wat**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**as_add.wat**'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 11-3: AssemblyScript `AddInts` function compiled to WAT'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-3：编译为WAT的AssemblyScript `AddInts`函数
- en: Writing code in AssemblyScript is much easier than writing code directly in
    WAT. This code produces the `AddInts` 1 function that exports a function 2 that
    takes two `i32` parameters and returns an `i32`. The output function uses a `local.get`
    to retrieve the first 3 and second 4 parameters, and uses an `i32.add`5 to add
    those two values.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在AssemblyScript中编写代码比直接在WAT中编写代码要容易得多。这段代码生成了`AddInts` 1函数，它导出了一个接受两个`i32`参数并返回一个`i32`的函数。输出函数使用`local.get`来获取第一个3和第二个4参数，并使用`i32.add`5来将这两个值相加。
- en: AssemblyScript is a beautiful little language that is relatively easy to learn
    for anyone familiar with TypeScript or JavaScript. Understanding WAT is a great
    way to get the most from your AssemblyScript or whichever high-level language
    you choose for WebAssembly development.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript是一种美丽的小语言，对于熟悉TypeScript或JavaScript的人来说，相对容易学习。理解WAT是从你的AssemblyScript或你选择的任何高级语言中获取最大收益的好方法，尤其是用于WebAssembly开发时。
- en: Hello World AssemblyScript
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello World AssemblyScript
- en: Next, we’ll build an AssemblyScript version of the WAT hello world application
    from Chapter 2. Create a new AssemblyScript file named *as_hello.ts* and add the
    code in [Listing 11-4](#listing11-4).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个AssemblyScript版本的WAT Hello World应用程序，参考第二章的示例。创建一个名为*as_hello.ts*的新AssemblyScript文件，并添加[清单11-4](#listing11-4)中的代码。
- en: '**as_hello.ts**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**as_hello.ts**'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 11-4: A hello world AssemblyScript app'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-4：一个Hello World的AssemblyScript应用
- en: The function declaration in AssemblyScript must correspond with a JavaScript
    function passed into the WebAssembly module. So we’ll need to pass in a function
    through the `importObject` that logs our string to the console. The `declare`
    `function` 1 imports the `console_log` function from the JavaScript. This function
    will pass a string from the AssemblyScript back to the calling JavaScript app.
    We create an `export` `function` called `HelloWorld` 2 that calls the imported
    `console_log` 3 function, passing in the string `"hello world!"`. Before we compile
    this into a WebAssembly module, we’ll use `asc` to compile a WAT file so we can
    look at the WebAssembly created ([Listing 11-5](#listing11-5)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript 中的函数声明必须与传入 WebAssembly 模块的 JavaScript 函数相对应。因此，我们需要通过 `importObject`
    传入一个将字符串记录到控制台的函数。`declare` `function` 1 从 JavaScript 导入了 `console_log` 函数。这个函数将把一个字符串从
    AssemblyScript 传回调用的 JavaScript 应用程序。我们创建了一个 `export` `function`，名为 `HelloWorld`
    2，它调用导入的 `console_log` 3 函数，并传入字符串 `"hello world!"`。在将其编译成 WebAssembly 模块之前，我们将使用
    `asc` 编译一个 WAT 文件，这样我们就可以查看创建的 WebAssembly（[列表 11-5](#listing11-5)）。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 11-5: Compile the *as_hello.ts* AssemblyScript file into *as_hello.wat*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-5：将 *as_hello.ts* AssemblyScript 文件编译为 *as_hello.wat*。
- en: Then we can open *as_hello.wat* in [Listing 11-6](#listing11-6) to see the WebAssembly
    that AssemblyScript generated.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以打开 *as_hello.wat* 文件，在 [列表 11-6](#listing11-6) 中查看 AssemblyScript 生成的
    WebAssembly。
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 11-6: The *as_hello.wat* file generated from the *as_hello.ts* AssemblyScript'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-6：从 *as_hello.ts* AssemblyScript 生成的 *as_hello.wat* 文件。
- en: I’ve added comments to clarify the code 1. This module imports `console_log`
    2 wrapped in the object `as_hello`, the name of our AssemblyScript file without
    the *.ts* extension. This is the naming convention AssemblyScript uses for its
    `importObject`; when you write your JavaScript, you must name your object inside
    the imported object accordingly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我已添加注释以澄清代码 1。这个模块导入了 `console_log` 2，并将其包装在对象 `as_hello` 中，这是我们 AssemblyScript
    文件的名称（不包括 *.ts* 扩展名）。这是 AssemblyScript 对 `importObject` 使用的命名约定；当你编写 JavaScript
    时，必须在导入的对象中相应地命名你的对象。
- en: AssemblyScript creates a `memory` 3 expression to hold the string data. The
    string has a prefixed header that includes the length of the string, which AssemblyScript
    uses to manipulate the data from within WebAssembly. The string `data` 4 uses
    two bytes per character, and because AssemblyScript uses UTF-16, every character
    in this example is separated by a null byte `\00`. UTF-16 is the 16-bit version
    of the Unicode character set that allows for many additional characters not available
    in ASCII.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript 创建了一个 `memory` 3 表达式来存储字符串数据。字符串有一个前缀头部，包含了字符串的长度，AssemblyScript
    使用它来在 WebAssembly 内部操作数据。字符串 `data` 4 每个字符使用两个字节，因为 AssemblyScript 使用的是 UTF-16
    编码，在这个例子中，每个字符之间由一个空字节 `\00` 分隔。UTF-16 是 Unicode 字符集的 16 位版本，允许使用许多 ASCII 中不可用的附加字符。
- en: After the data expression, the WAT exports 5 the function with the name we gave
    it in the AssemblyScript, prefixed with the `$` character and excluding the *.ts*
    extension. The `HelloWorld` 6function calls `console_log` 8, passing in the location
    of the first character in our `hello world!` string in linear memory, which is
    `32` 7.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据表达式之后，WAT 导出了 5 个函数，函数的名称是我们在 AssemblyScript 中为其指定的，前面加上了 `$` 字符，并去掉了 *.ts*
    扩展名。`HelloWorld` 6 函数调用了 `console_log` 8，传入了我们 `hello world!` 字符串在线性内存中的第一个字符的位置，即
    `32` 7。
- en: With our WAT file compiled, we can use the `asc` command in [Listing 11-7](#listing11-7)
    to compile our WebAssembly module.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们编译好的 WAT 文件，我们可以在 [列表 11-7](#listing11-7) 中使用 `asc` 命令来编译我们的 WebAssembly
    模块。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 11-7: Compiling our AssemblyScript to WebAssembly binary'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-7：将我们的 AssemblyScript 编译为 WebAssembly 二进制文件。
- en: Next, we create our JavaScript.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写我们的 JavaScript。
- en: JavaScript for Our Hello World App
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的 Hello World 应用的 JavaScript
- en: Currently, we have a WebAssembly module named *as_hello.wasm*. Next, we’ll write
    a Node.js app that will load and run this module. In this section, we’ll decode
    the string data the way we did in Chapter 5 to understand how AssemblyScript transfers
    strings to JavaScript. Then we’ll use the AssemblyScript loader tool to do much
    of this work for us.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，我们有一个名为 *as_hello.wasm* 的 WebAssembly 模块。接下来，我们将编写一个 Node.js 应用程序来加载并运行这个模块。在本节中，我们将像在第
    5 章中那样解码字符串数据，以了解 AssemblyScript 如何将字符串传输到 JavaScript。然后，我们将使用 AssemblyScript
    加载工具为我们完成这项工作。
- en: First, we’ll write a function to pull the string out of linear memory using
    the index passed from the WebAssembly module. AssemblyScript places the length
    of the string in the four bytes immediately preceding the string data. We can
    use `Uint32Array` to obtain the string length integer and use that length to create
    our string in JavaScript. Create a file named *as_hello.js* and add the code in
    [Listing 11-8](#listing11-8).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个函数，通过 WebAssembly 模块传递的索引从线性内存中提取字符串数据。AssemblyScript 将字符串的长度存储在字符串数据之前的四个字节中。我们可以使用
    `Uint32Array` 获取字符串长度的整数，并利用该长度在 JavaScript 中创建我们的字符串。创建一个名为 *as_hello.js* 的文件，并添加
    [清单 11-8](#listing11-8) 中的代码。
- en: '**as_hello.js**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**as_hello.js**'
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: // module's file name without extension is used as the outer object name
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: // 模块的文件名（不带扩展名）用作外部对象名称
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 11-8: Calling the AssemblyScript `HelloWorld` from JavaScript'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-8：从 JavaScript 调用 AssemblyScript 的 `HelloWorld`
- en: WebAssembly modules that AssemblyScript generates always create and export their
    own memory unless they’re compiled with the `--importMemory` flag. By default,
    AssemblyScript creates its own linear memory in the WebAssembly module. Therefore,
    in the JavaScript, we don’t create a linear memory object. Instead, we create
    a `var` called `memory` 1, which we’ll later set to the linear memory object that
    the WebAssembly module exports.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript 生成的 WebAssembly 模块总是会创建并导出它自己的内存，除非使用 `--importMemory` 标志进行编译。默认情况下，AssemblyScript
    会在 WebAssembly 模块中创建自己的线性内存。因此，在 JavaScript 中，我们不创建线性内存对象。相反，我们创建一个名为 `memory`
    1 的 `var`，稍后我们会将其设置为 WebAssembly 模块导出的线性内存对象。
- en: 'Inside `importObject`, the object that holds the data for import must have
    the same name as the AssemblyScript file importing it: `as_hello` 2 for our AssemblyScript
    file *as_hello.ts*. Inside `as_hello` is `console_log` 3, which is passed a string
    parameter when called from the AssemblyScript. When the WebAssembly module calls
    `as_hello`, the JavaScript function receives just a single numeric index into
    WebAssembly linear memory, which is the location of the string data portion of
    the length prefixed string that AssemblyScript uses to define its string type.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `importObject` 中，持有导入数据的对象必须与导入它的 AssemblyScript 文件同名：对于我们的 AssemblyScript
    文件 *as_hello.ts*，就是 `as_hello` 2。在 `as_hello` 中是 `console_log` 3，当从 AssemblyScript
    调用时会传递一个字符串参数。当 WebAssembly 模块调用 `as_hello` 时，JavaScript 函数只接收到一个指向 WebAssembly
    线性内存的数字索引，该索引是字符串数据部分（包含长度前缀的字符串）的位置，这是 AssemblyScript 用来定义其字符串类型的方式。
- en: The length is a 32-bit integer in the four bytes that precede the `index`. To
    get the index of the length integer, we subtract four from the string index. We
    use the value for the length located in linear memory by creating a new `Uint32Array`,
    passing in the `memory.buffer`, the `len_index` 4, and a value of `4` for the
    number of bytes. Because `Uint32Array` 5 is an array of 32-bit integers, we need
    to get the first and only item in the array using `[0]`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 长度是一个 32 位整数，位于 `index` 前的四个字节中。为了获取长度整数的索引，我们从字符串索引中减去四。通过创建新的 `Uint32Array`，传入
    `memory.buffer`、`len_index` 4 和字节数 `4`，我们可以使用线性内存中存储的长度值。由于 `Uint32Array` 5 是一个
    32 位整数数组，我们需要使用 `[0]` 获取数组中的第一个也是唯一的项。
- en: We retrieve the string byte data from linear memory using `new Uint16Array`
    6 and convert that byte array into a JavaScript string by using a new `TextDecoder`
    that decodes for `utf-16` text data. The code calls the `TextDecoder` 7 `decode`
    function, passing in the string data, which returns a JavaScript string we then
    log to the console. We use an IIFE to instantiate the AssemblyScript WebAssembly
    module. Note that we must set the `memory` 8 object to the memory object exported
    from the WebAssembly module before calling the `HelloWorld` 9 function. The `console_log`
    function uses the `memory` object, and if it isn’t set, calling `HelloWorld` will
    do nothing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `new Uint16Array` 6 从线性内存中获取字符串字节数据，并通过使用新的 `TextDecoder` 将字节数组转换为 JavaScript
    字符串，该解码器用于解码 `utf-16` 文本数据。代码调用 `TextDecoder` 7 的 `decode` 函数，传入字符串数据，返回的 JavaScript
    字符串随后被打印到控制台。我们使用一个立即执行函数表达式（IIFE）来实例化 AssemblyScript 的 WebAssembly 模块。请注意，在调用
    `HelloWorld` 9 函数之前，我们必须将 `memory` 8 对象设置为从 WebAssembly 模块导出的内存对象。`console_log`
    函数使用 `memory` 对象，如果没有设置，调用 `HelloWorld` 将不会产生任何效果。
- en: Fortunately, there is an easier way to move string data between AssemblyScript
    and JavaScript, which is by using the AssemblyScript loader. This code is provided
    by the AssemblyScript team. In the “Performance of Loader vs. Direct WebAssembly
    Calls*”* section, we’ll see whether we can improve the performance of the AssemblyScript
    loader with code we’ve written.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种更简单的方法可以在 AssemblyScript 和 JavaScript 之间传递字符串数据，那就是使用 AssemblyScript
    加载器。这个代码是由 AssemblyScript 团队提供的。在“加载器与直接 WebAssembly 调用的性能对比”*部分，我们将看到是否能通过我们编写的代码来提升
    AssemblyScript 加载器的性能。
- en: Hello World with the AssemblyScript Loader
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 AssemblyScript 加载器的 Hello World
- en: The AssemblyScript loader is a set of helper functions from the AssemblyScript
    team designed to make it easier to make calls to AssemblyScript from JavaScript.
    We’ll compare the code we wrote earlier with code written using the AssemblyScript
    loader. Initially, we’ll consider ease of use and later look into the performance
    implications of using or not using the loader.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript 加载器是一组来自 AssemblyScript 团队的助手函数，旨在简化从 JavaScript 调用 AssemblyScript
    的过程。我们将比较之前编写的代码与使用 AssemblyScript 加载器编写的代码。最初，我们将考虑易用性，之后再探讨使用或不使用加载器的性能影响。
- en: 'We use the AssemblyScript loader to send a string back to the JavaScript from
    the AssemblyScript. The loader helper function converts the index coming from
    WebAssembly into a JavaScript string. Now we will install the loader using `npm`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 AssemblyScript 加载器将一个字符串从 AssemblyScript 传回 JavaScript。加载器助手函数将来自 WebAssembly
    的索引转换为 JavaScript 字符串。现在，我们将使用 `npm` 安装加载器：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we’ll create a JavaScript file to load and run our WebAssembly module. Create
    a file named *as_hello_loader.js* and add the code in [Listing 11-9](#listing11-9).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 JavaScript 文件来加载和运行我们的 WebAssembly 模块。创建一个名为 *as_hello_loader.js*
    的文件，并添加 [Listing 11-9](#listing11-9) 中的代码。
- en: '**as_hello_loader.js**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**as_hello_loader.js**'
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 11-9: Using the AssemblyScript loader to call the WebAssembly module'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-9: 使用 AssemblyScript 加载器调用 WebAssembly 模块'
- en: This JavaScript function first requires 1 the AssemblyScript loader. We use
    this loader object to load the `module` 2 object, which we declare globally. The
    `module` object is an AssemblyScript loader module that includes additional AssemblyScript
    loader helper functions. Inside the `importObject` is a child object with the
    `as_hello` 3 name of our AssemblyScript module. That is where the AssemblyScript
    code expects to locate the imported functions. Inside the `as_hello` object is
    `console_log` 4, which takes the string index `str_index` as its only parameter.
    This function uses the `__getString` 5 function on the `module` object created
    by the loader. When given the string index, the `__getString` function retrieves
    a JavaScript string from linear memory. This string is printed to the console
    with `console.log`. The IIFE function loads an AssemblyScript module using the
    AssemblyScript `loader` 6 object. Finally, the IIFE calls the `HelloWorld` 7 function.
    When you run this JavaScript file using `node`, you’ll see the output in [Listing
    11-10](#listing11-10).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JavaScript 函数首先需要 1 个 AssemblyScript 加载器。我们使用这个加载器对象来加载声明为全局的 `module` 2
    对象。`module` 对象是一个 AssemblyScript 加载器模块，其中包含额外的 AssemblyScript 加载器助手函数。在 `importObject`
    中是一个子对象，命名为 `as_hello` 3，代表我们的 AssemblyScript 模块。这里是 AssemblyScript 代码期望找到导入函数的位置。在
    `as_hello` 对象中有一个 `console_log` 4 函数，它将字符串索引 `str_index` 作为唯一参数。这个函数使用由加载器创建的
    `module` 对象上的 `__getString` 5 函数。当传入字符串索引时，`__getString` 函数从线性内存中检索一个 JavaScript
    字符串。这个字符串通过 `console.log` 打印到控制台。IIFE 函数使用 AssemblyScript `loader` 6 对象加载一个 AssemblyScript
    模块。最后，IIFE 调用 `HelloWorld` 7 函数。当你使用 `node` 运行这个 JavaScript 文件时，你会在 [Listing 11-10](#listing11-10)
    中看到输出。
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 11-10: Output from the AssemblyScript hello world app'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-10: AssemblyScript hello world 应用的输出'
- en: Using the AssemblyScript loader makes the JavaScript code significantly simpler.
    Later, in the “Performance of Loader vs. Direct WebAssembly Calls” section, we’ll
    explore the performance implications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AssemblyScript 加载器使得 JavaScript 代码显著简化。稍后，在“加载器与直接 WebAssembly 调用的性能对比”部分，我们将探讨性能影响。
- en: AssemblyScript String Concatenation
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AssemblyScript 字符串拼接
- en: Now that we know how to receive strings from AssemblyScript, we’ll send a string
    to an AssemblyScript module. This next function concatenates two strings separated
    by a pipe character (`|`). We’ll use the loader to make it easier to write the
    code on the JavaScript side. String concatenation is the kind of functionality
    that is challenging to implement directly in WAT but is very simple in AssemblyScript.
    Create a new file named *as_concat.ts* and add the code in [Listing 11-11](#listing11-11).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何从AssemblyScript接收字符串，接下来我们将把一个字符串发送到AssemblyScript模块。这个函数将两个字符串用管道符号(`|`)连接起来。我们将使用加载器来简化JavaScript端的代码编写。字符串连接是WAT中很难直接实现的功能，但在AssemblyScript中非常简单。创建一个名为*as_concat.ts*的新文件，并在其中添加[列表
    11-11](#listing11-11)中的代码。
- en: '**as_concat.ts**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**as_concat.ts**'
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 11-11: Concatenating strings using AssemblyScript'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-11：使用AssemblyScript连接字符串
- en: We export 1 `cat`, which takes two string parameters and returns a string. This
    function concatenates 2 the string with a pipe character (`|`) separating them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导出一个`cat`函数，它接收两个字符串参数并返回一个字符串。此函数将两个字符串连接在一起，中间用管道符号(`|`)分隔。
- en: Now we can compile *as_concat.ts* using the `asc` command in [Listing 11-12](#listing11-12).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用[列表 11-12](#listing11-12)中的`asc`命令编译*as_concat.ts*。
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 11-12: Compiling the *as_concat.ts* file using `asc`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-12：使用`asc`编译*as_concat.ts*文件
- en: 'We pass the `--exportRuntime` flag, which is necessary for passing strings
    into the WebAssembly module. Compiling with `--exportRuntime` adds code that allows
    you to call the `__allocString` function from JavaScript. If we fail to export
    the runtime, the following error occurs when the application executes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递了`--exportRuntime`标志，这对于将字符串传递到WebAssembly模块中是必需的。使用`--exportRuntime`进行编译时，会添加允许你从JavaScript调用`__allocString`函数的代码。如果我们未能导出运行时，应用执行时会出现以下错误：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When you compile *as_concat.ts* into WAT, notice that the WAT file is much larger
    than our *as_hello.ts* file. The reason is that the runtime adds several string
    functions that perform necessary tasks, such as copy memory, concatenate strings,
    and get/set string length methods.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将*as_concat.ts*编译成WAT时，会注意到WAT文件比我们的*as_hello.ts*文件大得多。原因在于运行时添加了几个字符串函数，这些函数执行必要的任务，例如复制内存、连接字符串以及获取/设置字符串长度方法。
- en: Now we can write our JavaScript app. The code in [Listing 11-13](#listing11-13)
    creates two strings in linear memory and calls the WebAssembly function `cat`.
    Create a new JavaScript file named *as_concat.js* and add the code in [Listing
    11-13](#listing11-13).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写我们的JavaScript应用了。[列表 11-13](#listing11-13)中的代码会在线性内存中创建两个字符串，并调用WebAssembly函数`cat`。创建一个名为*as_concat.js*的新JavaScript文件，并在其中添加[列表
    11-13](#listing11-13)中的代码。
- en: '**as_concat.js**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**as_concat.js**'
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 11-13: JavaScript uses the AssemblyScript loader to call the `cat`
    AssemblyScript function.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-13：JavaScript使用AssemblyScript加载器调用`cat` AssemblyScript函数。
- en: The `cat` function we defined in the WebAssembly module doesn’t take a string
    as a parameter directly, so it needs an index into linear memory for the string
    location. The `module.exports.__newString` loader helper function takes a JavaScript
    string, copies it into linear memory, and returns an index to pass into `module.cat`.
    We call `module.exports.__newString` twice, passing `"first string"` 1 and then
    passing `"second string"` 2. Each of these calls returns an index that we store
    in `first_str_index` and `second_str_index`. Next, we call `module.exports.cat`,
    passing in these indexes, from which we receive a JavaScript string index that
    we store in `cat_str_index` 3. Then we call `module.exports.__getString` 4, passing
    in `cat_str_index`, and storing that string in `cat_string` 5, which we log to
    the console.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在WebAssembly模块中定义的`cat`函数并不直接接收字符串作为参数，因此需要一个线性内存中的索引来获取字符串位置。`module.exports.__newString`加载器助手函数接收一个JavaScript字符串，将其复制到线性内存中，并返回一个索引供`module.cat`使用。我们调用`module.exports.__newString`两次，第一次传入`"first
    string"` 1，然后传入`"second string"` 2。每次调用都会返回一个索引，我们将其分别存储在`first_str_index`和`second_str_index`中。接下来，我们调用`module.exports.cat`，传入这些索引，并返回一个JavaScript字符串索引，我们将其存储在`cat_str_index`
    3中。然后，我们调用`module.exports.__getString` 4，传入`cat_str_index`，并将获取到的字符串存储在`cat_string`
    5中，最后输出到控制台。
- en: 'Now that we have our JavaScript and WebAssembly, we can run our application
    using `node`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了JavaScript和WebAssembly，我们可以使用`node`运行我们的应用：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And here’s the output to your console:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出到控制台的内容：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is a lot more to AssemblyScript to explore. As you can see, it’s much
    simpler to write code that works with strings in AssemblyScript than it is in
    WAT. That doesn’t necessarily tell you when you should work with string data in
    WebAssembly, but it exposes it as an option. AssemblyScript, like WebAssembly
    more broadly, is a quickly developing project. Taking the time to learn more about
    it from the project home page at [assemblyscript.org](http://assemblyscript.org)
    is worth the time spent.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: AssemblyScript还有很多内容值得探索。如你所见，AssemblyScript在处理字符串时比WAT更加简单。虽然这并不能直接告诉你何时应该在WebAssembly中处理字符串数据，但它提供了这一选项。AssemblyScript，像WebAssembly一样，是一个快速发展的项目。花时间从项目主页[assemblyscript.org](http://assemblyscript.org)了解更多内容是值得的。
- en: Object Oriented Programming in AssemblyScript
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在AssemblyScript中使用面向对象编程（OOP）
- en: OOP is almost impossible to use in WAT format, but because AssemblyScript is
    modeled on TypeScript, it offers significantly more options for OOP. In this section,
    we’ll cover some of the basics of OOP in AssemblyScript, as well as some of its
    limitations, which might no longer apply in future releases.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在WAT格式中几乎不可能使用OOP，但由于AssemblyScript是基于TypeScript的，它提供了更多的OOP选项。在本节中，我们将介绍AssemblyScript中OOP的一些基础知识，以及一些它的限制，这些限制可能会在未来的版本中不再适用。
- en: Let’s begin by creating a new AssemblyScript file named *vector.ts*. Right now,
    AssemblyScript is piggybacking on top of TypeScript file formatting, which works
    in most cases.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建一个名为*vector.ts*的AssemblyScript文件开始。目前，AssemblyScript是基于TypeScript文件格式的，这在大多数情况下都能正常工作。
- en: Saule Cabrera has created an AssemblyScript language server plug-in for VS Code,
    which is available at [https://marketplace.visualstudio.com/items?itemName=saulecabrera.asls.](https://marketplace.visualstudio.com/items?itemName=saulecabrera.asls.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Saule Cabrera为VS Code创建了一个AssemblyScript语言服务器插件，插件可通过[https://marketplace.visualstudio.com/items?itemName=saulecabrera.asls.](https://marketplace.visualstudio.com/items?itemName=saulecabrera.asls.)下载。
- en: Next, we’ll write an AssemblyScript `Vector2D` class to hold the coordinates
    of the collider objects that are similar to what we wrote for the collision detection
    app in Chapter 8. We’ll compile the code to WAT so we can explore the output of
    the AssemblyScript compiler. Gaining a better understanding of the compiler and
    its output can be extremely beneficial when optimizing WebAssembly code. Add [Listing
    11-14](#listing11-14) to your file to create the class `Vector2D`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个AssemblyScript的`Vector2D`类，用于存储类似于第8章碰撞检测应用程序中所写的碰撞器对象的坐标。我们将代码编译成WAT，以便查看AssemblyScript编译器的输出。更好地理解编译器及其输出，在优化WebAssembly代码时非常有帮助。将[清单11-14](#listing11-14)添加到你的文件中，以创建`Vector2D`类。
- en: '**vector.ts**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**vector.ts**'
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 11-14: Creating a vector class in AssemblyScript'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 清单11-14：在AssemblyScript中创建一个向量类
- en: We export a class called `Vector2D` 1 that has two attributes, `x` 2 and `y`
    3. It also has a `constructor` 4 that creates a new `Vector2D` object from the
    `x` and `y` parameters. The `Magnitude` 5 method calculates the magnitude of the
    vector by summing the squares of `x` and `y` and taking the square root of that
    sum.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导出了一个名为`Vector2D`的类，它有两个属性，`x`和`y`。它还有一个`constructor`，用于从`x`和`y`参数创建一个新的`Vector2D`对象。`Magnitude`方法通过对`x`和`y`的平方求和并对该和取平方根来计算向量的大小。
- en: If you’re familiar with TypeScript, you’ll notice that this code looks just
    like the `class` structures in TypeScript. However, rather than using the TypeScript
    `number` type, we’re using `f32` types for 32-bit floating-point numbers. If you
    use the `number` type in your AssemblyScript, it’s the same as using an `f64`
    64-bit floating-point, which has the poorest performance of the WebAssembly types
    in most circumstances.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉TypeScript，你会注意到这段代码看起来与TypeScript中的`class`结构非常相似。然而，我们并没有使用TypeScript中的`number`类型，而是使用了`f32`类型来表示32位浮动点数。如果你在AssemblyScript中使用`number`类型，它实际上相当于使用`f64`类型的64位浮动点数，而在大多数情况下，`f64`的性能是WebAssembly类型中最差的。
- en: 'The following command compiles *vector.ts* into a WAT file using `asc`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令使用`asc`将*vector.ts*编译成WAT文件：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This creates a WAT file we can examine in VS Code. To `asc` we pass the name
    of the AssemblyScript file and then we pass the `-o`flag with the filename for
    the output file, `vector.wat`. The extension determines whether the output will
    be WAT or the WebAssembly binary file. Open *vector.wat* and scroll down a bit
    until you get to the exports shown in [Listing 11-15](#listing11-15).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个我们可以在 VS Code 中查看的 WAT 文件。要进行 `asc` 编译，我们传递 AssemblyScript 文件的名称，然后传递
    `-o` 标志并指定输出文件的文件名 `vector.wat`。扩展名决定了输出是 WAT 文件还是 WebAssembly 二进制文件。打开 *vector.wat*
    文件并稍微向下滚动，直到看到在 [清单 11-15](#listing11-15) 中显示的导出内容。
- en: '**vector.wat**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**vector.wat**'
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 11-15: The exported functions in our WAT file'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-15：我们 WAT 文件中导出的函数
- en: Notice how the compiler generated `get` 1 and `set` 2 accessor functions for
    the `x` 2 and `y` 3 attributes, and exported them so you can access them from
    the embedding environment. This indicates that when the user sets an object attribute
    using the loader, it calls a function in the WebAssembly module. One implication
    of this is that if you’re setting several attributes at once, you might want to
    consider creating a function to do this all at once for performance reasons. That
    way, you’re not making multiple function calls to the WebAssembly module. You
    can also see that the WebAssembly module exported the `constructor` 4 and `Magnitude`
    5 functions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意编译器如何为 `x` 2 和 `y` 3 属性生成 `get` 1 和 `set` 2 访问函数，并将它们导出，以便你可以从嵌入环境访问它们。这表明，当用户通过加载器设置对象属性时，它会调用
    WebAssembly 模块中的一个函数。这意味着，如果你一次设置多个属性，可能需要考虑创建一个函数来一次性完成这一操作，以提高性能。这样，你就不需要多次调用
    WebAssembly 模块的函数。你还可以看到 WebAssembly 模块导出了 `constructor` 4 和 `Magnitude` 5 函数。
- en: The naming conventions are important to understand if you want to call functions
    in the WebAssembly module from JavaScript. The methods are all prefixed with the
    name of the class and a hash mark (`#`) character (`Vector2D#`). The `set` and
    `get` methods have a suffix that indicates which attribute they’re setting and
    getting, such as `:x` or `:y`. To access these functions and attributes from our
    JavaScript without using the AssemblyScript loader, we need to use this naming
    convention.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从 JavaScript 中调用 WebAssembly 模块的函数，命名约定是非常重要的。所有方法都以类名和哈希符号（`#`）作为前缀（`Vector2D#`）。`set`
    和 `get` 方法有一个后缀，表示它们设置或获取的属性，例如 `:x` 或 `:y`。要在不使用 AssemblyScript 加载器的情况下从 JavaScript
    访问这些函数和属性，我们需要遵循这种命名约定。
- en: Using Private Attributes
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用私有属性
- en: If you don’t want to export all the attributes to the embedding environment,
    you need to use the `private` keyword before the `x` and `y` attributes. Do that
    now in your AssemblyScript and recompile with the `asc` command. [Listing 11-16](#listing11-16)
    shows the new version.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想将所有属性导出到嵌入环境中，需要在 `x` 和 `y` 属性前使用 `private` 关键字。现在在你的 AssemblyScript 中进行此操作，并使用
    `asc` 命令重新编译。[清单 11-16](#listing11-16) 显示了新版本。
- en: '**vector.ts**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**vector.ts**'
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 11-16: Creating private functions in AssemblyScript'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-16：在 AssemblyScript 中创建私有函数
- en: The `private` 1 modifier before `x` 1 and `y` 2 tells the AssemblyScript compiler
    that these attributes shouldn’t be publicly accessible. Recompile the WebAssembly
    module, which no longer exports the accessor methods that set and get the `x`
    and `y` variables to the embedding environment, as shown in [Listing 11-17](#listing11-17).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `x` 1 和 `y` 2 前面的 `private` 修饰符告诉 AssemblyScript 编译器，这些属性不应该对外部公开访问。重新编译 WebAssembly
    模块，该模块不再导出设置和获取 `x` 和 `y` 变量的访问方法到嵌入环境，如 [清单 11-17](#listing11-17) 所示。
- en: '**vector.wat**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**vector.wat**'
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 11-17: Exports in the WAT file'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-17：WAT 文件中的导出
- en: TypeScript has three modifiers, `public`, `private`, and `protected`, to define
    how attributes can be accessed. These modifiers behave a little differently in
    AssemblyScript than in other languages, such as TypeScript. In most languages,
    protected attributes are available to classes that extend the class but cannot
    be accessed outside the parent or child class. The `protected`method in AssemblyScript
    isn’t implemented fully and behaves the same as the `public` modifier. For now,
    you should avoid using it to prevent confusion. The keywords may eventually work
    as they do in TypeScript, but be aware that these limitations still exist in AssemblyScript
    version 0.17.7\.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 有三个修饰符，`public`、`private` 和 `protected`，用来定义属性的访问方式。这些修饰符在 AssemblyScript
    中的行为与其他语言（如 TypeScript）有所不同。在大多数语言中，protected 属性可以被继承该类的子类访问，但不能在父类或子类之外访问。而在
    AssemblyScript 中，`protected` 方法没有完全实现，其行为与 `public` 修饰符相同。目前，建议避免使用它以免造成混淆。尽管这些关键字未来可能会像在
    TypeScript 中那样工作，但需要注意这些限制仍然存在于 AssemblyScript 版本 0.17.7 中。
- en: The `private` modifier prevents AssemblyScript from exporting the `get` and
    `set` methods when it compiles the module.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`private` 修饰符阻止 AssemblyScript 在编译模块时导出 `get` 和 `set` 方法。'
- en: Unlike in other OOP languages, the `private` modifier in AssemblyScript doesn’t
    prevent classes that extend the original from accessing that attribute.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他面向对象编程语言不同，AssemblyScript 中的 `private` 修饰符并不会阻止继承原始类的类访问该属性。
- en: 'Let’s use the following command to compile our AssemblyScript into a WebAssembly
    module so we can call it from our JavaScript:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令将我们的 AssemblyScript 编译成 WebAssembly 模块，这样我们就可以从 JavaScript 中调用它：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When we change the `-o` flag to *vector.wasm*, we tell the `asc` compiler to
    output a WebAssembly binary file. That will allow us to load and run the module
    from a JavaScript embedding environment. Next, let’s look at how to load and call
    WebAssembly functions using Node.js.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `-o` 标志改为 *vector.wasm* 时，我们告诉 `asc` 编译器输出 WebAssembly 二进制文件。这将允许我们从 JavaScript
    嵌入环境加载并运行该模块。接下来，让我们看看如何使用 Node.js 加载和调用 WebAssembly 函数。
- en: JavaScript Embedding Environment
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript 嵌入环境
- en: We’ll use Node.js to load and execute the WebAssembly module. If we instead
    use a browser, the JavaScript would use `WebAssembly.instantiateStreaming` [PRE25]
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Node.js 来加载和执行 WebAssembly 模块。如果改用浏览器，JavaScript 会使用 `WebAssembly.instantiateStreaming`
    [PRE25]
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
