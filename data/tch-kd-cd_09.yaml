- en: 'Chapter 9. User Interaction: Get into the Game'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 用户交互：进入游戏
- en: 'In [Chapter 8](ch08.html "Chapter 8. Timers and Animation: What Would Disney
    Do?"), we used some of the Pygame library’s features to draw shapes and images
    on the screen. We were also able to create animation by drawing shapes in different
    locations over time. Unfortunately, we weren’t able to *interact* with our animated
    objects like we might in a game; we expect to be able to click, drag, move, hit,
    or pop objects on the screen to affect or control the elements of a game while
    it runs.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章 定时器和动画：迪士尼会怎么做？")中，我们使用了Pygame库的一些功能在屏幕上绘制形状和图像。我们还能够通过在不同的位置随时间绘制形状来创建动画。不幸的是，我们无法像在游戏中那样*与*动画对象进行交互；我们希望能够点击、拖动、移动、击打或弹出屏幕上的对象，从而影响或控制游戏的元素。
- en: 'Interactive programs give us this sense of control in an app or game, because
    we can move or interact with a character or other object in the program. That’s
    exactly what you’ll learn to do in this chapter: we’ll use Pygame’s ability to
    handle user interaction from the mouse to make our programs more interactive and
    more engaging for the user.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式程序给我们带来了在应用或游戏中控制的感觉，因为我们可以移动或与程序中的角色或其他对象互动。这正是你将在本章中学到的内容：我们将利用Pygame处理来自鼠标的用户交互，使我们的程序更加互动，更具吸引力。
- en: 'Adding Interaction: Click and Drag'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加交互：点击和拖动
- en: Let’s add user interaction by developing two programs that will allow the user
    to draw interactively on the screen. First, we’ll build on our Pygame foundation
    to handle events like mouse-button clicks and to enable the user to draw dots
    on the screen. Then, we’ll add logic to handle mouse-button presses and releases
    separately and let the user drag the mouse with the button pressed to draw, like
    in a paint program.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过开发两个程序来添加用户交互，允许用户在屏幕上进行互动绘制。首先，我们将在Pygame基础上构建程序，处理鼠标按钮点击等事件，并让用户在屏幕上绘制点。然后，我们将添加逻辑，单独处理鼠标按钮的按下和释放，并让用户在按住按钮的情况下拖动鼠标进行绘制，类似于绘图程序。
- en: Clicking for Dots
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点击绘制点
- en: We’ll build our *ClickDots.py* program using the same steps as in *ShowPic.py*
    ([Exiting the Program](ch08.html#exiting_the_program "Exiting the Program")) with
    a setup, a game loop, and an exit. Pay extra attention to the event-handling portion
    of the game loop, since that’s where we’ll add the `if` statement that will process
    mouse clicks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与*ShowPic.py*相同的步骤来构建*ClickDots.py*程序（[退出程序](ch08.html#exiting_the_program
    "退出程序")），包括设置、游戏循环和退出。请特别注意游戏循环中的事件处理部分，因为我们将在其中添加`if`语句来处理鼠标点击。
- en: Setup
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: Here are our first few lines of setup. Start a new file and save it as *ClickDots.py*
    (the final program is shown in [Putting It All Together](ch09.html#putting_it_all_together-id00022
    "Putting It All Together")).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们设置的前几行代码。创建一个新文件，并将其保存为*ClickDots.py*（最终程序见[将所有内容整合](ch09.html#putting_it_all_together-id00022
    "将所有内容整合")）。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our setup begins with `import pygame` and `pygame.init()` as usual, and then
    we create a `screen` object as our drawing window display. This time, though,
    we’ve added a title, or *caption*, to the window with `pygame.display.set_caption()`.
    This lets the user know what the program is. The argument we pass to `set_caption()`
    is a string of text that will appear on the title bar of the window, as shown
    at the top of [Figure 9-1](ch09.html#title_bar_at_the_top_of_clickdotsdotpy_t
    "Figure 9-1. The title bar at the top of ClickDots.py tells the user, “Click to
    draw.”").
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设置首先是像往常一样`import pygame`和`pygame.init()`，然后我们创建一个`screen`对象作为我们的绘图窗口显示。这一次，我们给窗口添加了一个标题或*字幕*，使用了`pygame.display.set_caption()`。这可以让用户知道这个程序是什么。我们传递给`set_caption()`的参数是一个字符串，显示在窗口的标题栏上，如[图9-1](ch09.html#title_bar_at_the_top_of_clickdotsdotpy_t
    "图9-1. ClickDots.py顶部的标题栏告诉用户“点击以绘制”。")所示。
- en: '![The title bar at the top of ClickDots.py tells the user, “Click to draw.”](httpatomoreillycomsourcenostarchimages2189011.png.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![ClickDots.py顶部的标题栏告诉用户，“点击以绘制。”](httpatomoreillycomsourcenostarchimages2189011.png.jpg)'
- en: Figure 9-1. The title bar at the top of *ClickDots.py* tells the user, “Click
    to draw.”
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1. *ClickDots.py*顶部的标题栏告诉用户，“点击以绘制。”
- en: 'The rest of our setup creates our game loop variable, `keep_going`; sets a
    color constant (we’ll draw in red for this program); and creates a radius for
    our drawing dots:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的其余设置将创建我们的游戏循环变量`keep_going`，设置一个颜色常量（我们将在本程序中用红色绘制），并为我们的绘图点创建一个半径：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now let’s move on to our game loop.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续我们的游戏循环。
- en: 'Game Loop: Handling Mouse Clicks'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏循环：处理鼠标点击
- en: 'In our game loop, we need to tell the program when to quit and how to handle
    mouse-button presses:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏循环中，我们需要告诉程序何时退出以及如何处理鼠标按钮按下事件：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At ➊, we handle the `pygame.QUIT` event by setting our loop variable `keep_going`
    to `False`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们通过将循环变量`keep_going`设置为`False`来处理`pygame.QUIT`事件。
- en: 'The second `if` statement, at ➋, handles a new event type: the `pygame.MOUSEBUTTONDOWN`
    event that tells us that the user has pressed one of the mouse buttons. Whenever
    the user presses a mouse button, this event will appear in the list of events
    that our program gets from `pygame.event.get()`, and we can use an `if` statement
    both to check for the event and to tell the program what to do when the event
    occurs. At ➌, we create a variable called `spot` to hold the x- and y-coordinates
    of the mouse’s position. We can get the location of the mouse-click event with
    `event.pos`; `event` is the current event in our `for` loop. Our `if` statement
    has just verified that this particular `event` is of type `pygame.MOUSEBUTTONDOWN`,
    and mouse events have a `pos` attribute (in this case, `event.pos`) that stores
    the (*x*, *y*) coordinate pair telling us where the mouse event occurred.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`if`语句，在➋处，处理了一种新的事件类型：`pygame.MOUSEBUTTONDOWN`事件，它告诉我们用户按下了鼠标按钮中的一个。每当用户按下鼠标按钮时，这个事件将出现在我们通过`pygame.event.get()`获取的事件列表中，我们可以使用`if`语句来检查事件并告诉程序在事件发生时该做什么。在➌处，我们创建了一个名为`spot`的变量，用来存储鼠标位置的x和y坐标。我们可以通过`event.pos`获取鼠标点击事件的位置；`event`是我们`for`循环中的当前事件。我们的`if`语句已经验证了这个特定的`event`是`pygame.MOUSEBUTTONDOWN`类型，而鼠标事件有一个`pos`属性（在本例中为`event.pos`），它存储了告诉我们鼠标事件发生位置的(*x*,
    *y*)坐标对。
- en: Once we know the location on the screen where the user clicked the mouse button,
    at ➍ we tell the program to draw a filled circle on the `screen` surface, in the
    `RED` color from our setup, at the location `spot`, with the `radius` of 15 we
    specified in our setup.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道用户点击鼠标按钮时屏幕上的位置，在➍处我们告诉程序在`screen`表面上，以我们设置中的`RED`颜色，在`spot`位置绘制一个填充圆圈，半径为我们设置中指定的15。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189013.png.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图像](httpatomoreillycomsourcenostarchimages2189013.png.jpg)'
- en: Putting It All Together
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 综合起来
- en: The only thing left to do is update the display and tell our program what to
    do when it’s time to exit. Here’s the full program for *ClickDots.py*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下要做的就是更新显示并告诉我们的程序在退出时应该做什么。下面是*ClickDots.py*的完整程序。
- en: ClickDots.py
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ClickDots.py
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This program is short but enables the user to draw pictures one dot at a time,
    as shown back in [Figure 9-1](ch09.html#title_bar_at_the_top_of_clickdotsdotpy_t
    "Figure 9-1. The title bar at the top of ClickDots.py tells the user, “Click to
    draw.”"). If we want to draw continuously as we drag the mouse with the button
    pressed, we just need to handle one more type of mouse event, `pygame.MOUSEBUTTONUP`.
    Let’s give that a try.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序很简短，但它允许用户一笔一画地绘制图片，正如[图9-1](ch09.html#title_bar_at_the_top_of_clickdotsdotpy_t
    "图9-1。ClickDots.py顶部的标题栏告诉用户：“点击以绘制。”")中所示。如果我们希望在按住鼠标按钮时拖动鼠标时连续绘制，我们只需要处理一种新的鼠标事件，即`pygame.MOUSEBUTTONUP`。让我们试试看。
- en: Dragging to Paint
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拖动绘画
- en: Now let’s create a more natural drawing program, *DragDots.py*, that lets the
    user click and drag to draw smoothly, as with a paintbrush. We’ll get a smooth,
    interactive drawing app, as shown in [Figure 9-2](ch09.html#our_dragdotsdotpy_program_is_a_fun_way_t
    "Figure 9-2. Our DragDots.py program is a fun way to paint!").
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个更自然的绘画程序，*DragDots.py*，它允许用户点击并拖动以平滑地绘制，就像使用画笔一样。我们将得到一个平滑的互动绘画应用，如[图9-2](ch09.html#our_dragdotsdotpy_program_is_a_fun_way_t
    "图9-2。我们的DragDots.py程序是一个有趣的绘画方式！")所示。
- en: '![Our DragDots.py program is a fun way to paint!](httpatomoreillycomsourcenostarchimages2189015.png.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![我们的DragDots.py程序是一个有趣的绘画方式！](httpatomoreillycomsourcenostarchimages2189015.png.jpg)'
- en: Figure 9-2. Our *DragDots.py* program is a fun way to paint!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-2。我们的*DragDots.py*程序是一个有趣的绘画方式！
- en: To create this effect, we need to change the logic of our program. In *ClickDots.py*,
    we handled `MOUSEBUTTONDOWN` events by just drawing a circle at the location of
    the mouse button click event. To draw continuously, we need to recognize both
    the `MOUSEBUTTONDOWN` and `MOUSEBUTTONUP` events; in other words, we want to separate
    mouse button clicks into *presses* and *releases* so that we know when the mouse
    is being *dragged* (with the button down) versus just being moved with the button
    up.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个效果，我们需要修改程序的逻辑。在*ClickDots.py*中，我们通过在鼠标按下事件的位置绘制一个圆圈来处理`MOUSEBUTTONDOWN`事件。为了实现连续绘制，我们需要同时识别`MOUSEBUTTONDOWN`和`MOUSEBUTTONUP`事件；换句话说，我们需要将鼠标点击事件分为*按下*和*释放*，以便知道鼠标何时在*拖动*（按下按钮）以及仅在按钮弹起时被移动。
- en: One way to accomplish this is with another Boolean flag variable. We can set
    a Boolean called `mousedown` to `True` whenever the user presses the mouse button
    and to `False` whenever the user releases the mouse button. In our game loop,
    if the mouse button is down (in other words, when `mousedown` is `True`), we can
    get the mouse’s location and draw a circle on the screen. If the program is fast
    enough, the drawing should be smooth like in a paintbrush app.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一种实现方法是使用另一个布尔标志变量。我们可以在用户按下鼠标按钮时将名为`mousedown`的布尔值设置为`True`，而在用户释放鼠标按钮时将其设置为`False`。在我们的游戏循环中，如果鼠标按钮被按下（换句话说，当`mousedown`为`True`时），我们可以获取鼠标的位置并在屏幕上绘制圆圈。如果程序足够快，绘制应该像画笔应用程序那样流畅。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189017.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2189017.png.jpg)'
- en: Setup
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: 'Make the setup section of your code look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的代码设置部分看起来像这样：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The setup portion of our app looks like *ClickDots.py*, except for the different
    window caption ➊, the `YELLOW` color we’ll be drawing with ➋, and the very last
    line ➌. The Boolean variable `mousedown` will be our flag variable to signal to
    the program that the mouse button is down, or pressed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的设置部分看起来像*ClickDots.py*，除了不同的窗口标题 ➊，我们将使用的`YELLOW`颜色 ➋，以及最后一行 ➌。布尔变量`mousedown`将作为标志变量，告诉程序鼠标按钮已按下或被按住。
- en: Next, we’ll add event handlers to our game loop. These event handlers will set
    `mousedown` to `True` if the user is holding down the mouse and `False` if not.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在游戏循环中添加事件处理程序。这些事件处理程序将在用户按住鼠标时将`mousedown`设置为`True`，而在没有按住时将其设置为`False`。
- en: 'Game Loop: Handling Mouse Presses and Releases'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏循环：处理鼠标按下和释放
- en: 'Make your game loop look like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的游戏循环看起来像这样：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The game loop starts just like our other Pygame apps, but at ➊, when we check
    to see whether the user has pressed one of the mouse buttons, instead of drawing
    immediately, we set our `mousedown` variable to `True` ➋. This will be the signal
    our program needs to begin drawing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环开始就像我们其他的Pygame应用程序一样，但在 ➊ 处，当我们检查用户是否按下了鼠标按钮时，程序不会立即绘制，而是将`mousedown`变量设置为`True`
    ➋。这将是程序开始绘制所需的信号。
- en: The next `if` statement at ➌ checks whether the user has *released* the mouse
    button. If so, the line at ➍ changes `mousedown` back to `False`. This will let
    our game loop know to stop drawing whenever the mouse button is up.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个在 ➌ 处的`if`语句检查用户是否已*释放*鼠标按钮。如果是，那么 ➍ 处的代码将`mousedown`重置为`False`。这将让我们的游戏循环知道，当鼠标按钮弹起时停止绘制。
- en: At ➎, our `for` loop is over (as we can see by the indentation), and our game
    loop continues by checking whether the mouse button is currently pressed (that
    is, if `mousedown` is `True`). If the mouse button is down, the mouse is currently
    being dragged, so we want to allow the user to draw on the `screen`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➎ 处，我们的`for`循环结束（如缩进所示），然后我们的游戏循环继续，通过检查鼠标按钮是否当前被按下（也就是说，`mousedown`是否为`True`）。如果鼠标按钮被按下，说明鼠标正在被拖动，我们希望允许用户在`screen`上绘制。
- en: At ➏, we get the current location of the mouse directly, with `spot = pygame.mouse.get_pos()`,
    rather than pulling the position of the last click, because we want to draw wherever
    the user is dragging the mouse, not just at the location where they first pressed
    the button. At ➐, we draw the current circle on the `screen` surface, in the color
    specified by `YELLOW`, at the (*x*, *y*) location `spot` where the mouse is currently
    being dragged, with the `radius` of 15 that we specified in the setup section
    of our code. Finally, we finish the game loop at ➑ by updating the display window
    with `pygame.display.update()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➏，我们直接获取鼠标的当前位置，使用 `spot = pygame.mouse.get_pos()`，而不是获取最后一次点击的位置，因为我们希望在用户拖动鼠标的任何位置绘制，而不仅仅是在他们第一次按下按钮的位置。在
    ➐，我们在 `screen` 表面上绘制当前的圆圈，颜色由 `YELLOW` 指定，位于鼠标当前被拖动的 (*x*, *y*) 位置 `spot`，半径为
    15，这是我们在代码设置部分指定的。最后，在 ➑，我们通过 `pygame.display.update()` 更新显示窗口来结束游戏循环。
- en: Putting It All Together
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 综合起来
- en: The last step is to end the program with `pygame.quit()` as usual. Here’s the
    full program.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是像往常一样使用 `pygame.quit()` 结束程序。下面是完整的程序。
- en: DragDots.py
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DragDots.py
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The *DragDots.py* app is so fast and responsive that it almost feels like we’re
    painting with a continuous brush instead of a series of dots; we have to drag
    the mouse pretty quickly to see the dots drawn separately. Pygame allows us to
    build much faster and more fluid games and animation than the turtle graphics
    we drew in previous chapters.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*DragDots.py* 应用程序非常快速且响应灵敏，以至于它几乎让我们感觉是在用连续的画笔而不是一系列点进行绘制；我们需要快速拖动鼠标才能看到点被单独绘制出来。Pygame
    使我们能够比前几章中绘制的海龟图形构建更快速、更流畅的游戏和动画。'
- en: Even though the `for` loop handles every event during every pass through the
    `while` loop that keeps our app open, Pygame is efficient enough to do this dozens
    or even hundreds of times per second. This gives the illusion of instantaneous
    motion and reaction to our every movement and command—an important consideration
    as we build animations and interactive games. Pygame is up to the challenge and
    is the right toolkit for our graphics-intensive needs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `for` 循环在每次通过保持应用程序打开的 `while` 循环时处理每一个事件，Pygame 的效率足够高，能够每秒执行几十次甚至几百次。这产生了即时运动和对我们每个动作和命令反应的错觉——这是我们构建动画和互动游戏时的重要考虑因素。Pygame
    能够应对这一挑战，是满足我们图形密集型需求的正确工具包。
- en: 'Advanced Interaction: Smiley Explosion'
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级互动：笑脸爆炸
- en: One fun animation that my students and my sons enjoy building is a scaled-up
    version of *SmileyBounce2.py* called *SmileyExplosion.py*. It takes the bouncing
    smiley to a fun new level by allowing the user to click and drag to create hundreds
    of bouncing smiley faces of random sizes that travel in random directions at random
    speeds. The effect looks like [Figure 9-3](ch09.html#our_next_app_looks_like_an_explosion_of
    "Figure 9-3. Our next app looks like an explosion of smiley face balloons bouncing
    all over the screen."). We’ll build this program step by step; the final version
    is in [Putting It All Together](ch09.html#putting_it_all_together-id00025 "Putting
    It All Together").
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我的学生和儿子们喜欢构建的一个有趣动画是 *SmileyBounce2.py* 的放大版，名为 *SmileyExplosion.py*。它通过允许用户点击并拖动，创建出数百个大小随机、运动方向随机、速度随机的笑脸气球，将弹跳的笑脸提升到了一个有趣的新层次。这个效果就像是
    [图 9-3](ch09.html#our_next_app_looks_like_an_explosion_of "图 9-3. 我们的下一个应用程序看起来像一场笑脸气球的爆炸，在屏幕上四处弹跳。")。我们将一步步构建这个程序；最终版本在
    [综合起来](ch09.html#putting_it_all_together-id00025 "综合起来") 中。
- en: '![Our next app looks like an explosion of smiley face balloons bouncing all
    over the screen.](httpatomoreillycomsourcenostarchimages2189019.png.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![我们的下一个应用程序看起来像一场笑脸气球的爆炸，在屏幕上四处弹跳。](httpatomoreillycomsourcenostarchimages2189019.png.jpg)'
- en: Figure 9-3. Our next app looks like an explosion of smiley face balloons bouncing
    all over the screen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3. 我们的下一个应用程序看起来像一场笑脸气球的爆炸，在屏幕上四处弹跳。
- en: 'As you can see, we will have dozens to hundreds of smiley balloons bouncing
    all over the screen at any given time, so we’re going to need to draw graphics
    quickly and smoothly for hundreds of objects per frame. To achieve this, we’re
    going to add one more tool to our toolkit: sprite graphics.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们将有几十到上百个笑脸气球在任何时候在屏幕上四处弹跳，因此我们需要快速且平滑地为每一帧上的数百个物体绘制图形。为此，我们将向工具包中添加一个新工具：精灵图形。
- en: Smiley Sprites
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 笑脸精灵
- en: The term *sprite* goes back to the early days of video games. Moving graphical
    objects on the screen were called sprites because they floated over the background,
    like the imaginary fairy sprites they were named after. These light, fast sprite
    graphics enabled the quick, smooth animation that made video games so popular.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*精灵*这个术语可以追溯到视频游戏的早期。屏幕上移动的图形对象被称为精灵，因为它们像命名源于的幻想精灵一样漂浮在背景之上。这些轻巧、快速的精灵图形使得快速、流畅的动画成为可能，从而让视频游戏变得如此受欢迎。'
- en: 'Pygame includes support for sprite graphics through its `pygame.sprite.Sprite`
    class. Remember from [Chapter 8](ch08.html "Chapter 8. Timers and Animation: What
    Would Disney Do?") that a class is like a template that can be used to create
    reusable objects, each with its own full set of functions and properties. In [SmileyMove.py](ch08.html#smileymovedotpy
    "SmileyMove.py"), we used the `Clock` class, along with its `tick()` method, to
    make our animations smooth and predictable. In the smiley explosion app, we’ll
    use a few handy Pygame classes, and we’ll build a class of our own to keep track
    of each individual smiley face as it moves around the screen.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame通过其`pygame.sprite.Sprite`类支持精灵图形。请记住，在[第8章](ch08.html "第8章：定时器与动画：迪士尼会怎么做？")中，类就像一个模板，可以用来创建可重用的对象，每个对象都有自己完整的功能和属性。在[SmileyMove.py](ch08.html#smileymovedotpy
    "SmileyMove.py")中，我们使用了`Clock`类及其`tick()`方法，使我们的动画变得平滑和可预测。在笑脸爆炸应用程序中，我们将使用几个方便的Pygame类，并创建一个自己的类来跟踪每个笑脸在屏幕上的移动。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189021.png.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages2189021.png.jpg)'
- en: More on Classes and Objects
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多关于类和对象的内容
- en: 'In [Chapter 8](ch08.html "Chapter 8. Timers and Animation: What Would Disney
    Do?") you learned that classes are like cookie cutters, and objects are like the
    cookies we create using a particular cookie cutter. Whenever we need several items
    with similar functions and characteristics (like moving smiley face images with
    various sizes and locations), and especially when we need each item to contain
    different information (like the size, location, and speed of each smiley), a class
    can provide the template to create as many objects of that type as we need. We
    say that objects are *instances* of a particular class.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章：定时器与动画：迪士尼会怎么做？")中，你学到了类就像饼干模具，对象就像用特定模具做出的饼干。每当我们需要几个具有相似功能和特征的项目（如具有不同大小和位置的移动笑脸图像），尤其是当我们需要每个项目包含不同信息（如每个笑脸的大小、位置和速度）时，类可以提供模板，帮助我们创建任意数量的该类型对象。我们说对象是某一特定类的*实例*。
- en: 'The Pygame library has dozens of reusable classes, and each class has its own
    *methods* (what we call a class’s functions) and *attributes* or *data*, the variables
    and values stored in each object. In the `Clock` class in [Chapter 8](ch08.html
    "Chapter 8. Timers and Animation: What Would Disney Do?"), the `tick()` method
    was our function for making animation happen at a certain frame rate. For the
    floating smiley `Sprite` objects in this app, the attributes we care about are
    each smiley’s location on the screen, its size, and the speed it’s moving in the
    x- and y-directions, so we’ll create a `Smiley` class with those attributes. We
    can create our own classes whenever we need a reusable template.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame库有几十个可重用的类，每个类都有自己的*方法*（我们称之为类的函数）和*属性*或*数据*，即存储在每个对象中的变量和值。在[第8章](ch08.html
    "第8章：定时器与动画：迪士尼会怎么做？")中的`Clock`类，`tick()`方法是我们用来使动画以特定帧率发生的函数。在这个应用程序中，针对浮动的笑脸`Sprite`对象，我们关心的属性包括每个笑脸在屏幕上的位置、它的大小，以及它在x轴和y轴方向上的移动速度，因此我们将创建一个具有这些属性的`Smiley`类。我们可以随时创建自己的类来作为可重用的模板。
- en: Breaking a problem or program down into objects, and then building classes that
    create those objects, is the foundation of *object-oriented programming*. Object-oriented
    programming is a way of solving problems using objects. It is one of the most
    popular approaches used in software development, and one reason for that popularity
    is the concept of code reuse. *Reusability* means that once we write a useful
    class for one programming project, we can often reuse that class in another program
    instead of starting from scratch. For example, a game company can write a `Card`
    class to represent the cards in a standard deck. Then, every time the company
    programs a new game—like Blackjack, War, Poker, Go Fish, and so on—it can reuse
    that `Card` class, saving time and money by using the same code in future apps.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将问题或程序拆解成对象，然后构建创建这些对象的类，是*面向对象编程*的基础。面向对象编程是一种利用对象解决问题的方法。它是软件开发中最流行的编程方式之一，流行的原因之一是代码重用的概念。*重用性*意味着一旦我们为一个编程项目编写了一个有用的类，我们通常可以在另一个程序中重用该类，而无需从头开始。例如，一个游戏公司可以编写一个`Card`类来表示标准扑克牌中的卡片。然后，每次公司编写一个新游戏——比如二十一点、战争、扑克、鱼来来等——它都可以重用这个`Card`类，通过在未来的应用程序中使用相同的代码来节省时间和金钱。
- en: The `Sprite` class in Pygame is a great example. The Pygame team wrote the `Sprite`
    class to contain many of the features we need when we program a game object, from
    a running character to a spaceship to a floating smiley face. By using the `Sprite`
    class, programmers like us no longer need to write all the basic code to draw
    an object on the screen, detect when objects collide with one another, and so
    on. The `Sprite` class handles many of those functions for us, and we can focus
    on building the unique qualities of our app on top of that foundation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame中的`Sprite`类是一个很好的例子。Pygame团队编写了`Sprite`类，包含了我们在编程游戏对象时需要的许多功能，从跑步角色到宇宙飞船，再到漂浮的微笑表情。通过使用`Sprite`类，我们这些程序员不再需要编写所有基本代码来在屏幕上绘制一个对象、检测对象之间的碰撞等。`Sprite`类为我们处理了这些功能，我们可以专注于在这个基础上构建应用的独特特性。
- en: Another handy Pygame class we’ll use is the `Group` class. `Group` is a *container*
    class that lets us store `Sprite` objects together as a group. The `Group` class
    helps us keep all our sprites together in one place (accessible through a single
    `Group` object), and that’s important when we have dozens or possibly hundreds
    of sprites floating around the screen. The `Group` class also has convenient methods
    for updating all the sprites in a group (such as moving the `Sprite` objects to
    each of their new locations each frame), adding new `Sprite` objects, removing
    `Sprite` objects from the `Group`, and so on. Let’s see how we can use these classes
    to build our smiley explosion app.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方便的Pygame类是`Group`类。`Group`是一个*容器*类，它让我们将多个`Sprite`对象作为一个组存储在一起。`Group`类帮助我们将所有精灵保存在一个地方（通过一个`Group`对象访问），当我们有数十个甚至数百个精灵在屏幕上漂浮时，这一点非常重要。`Group`类还提供了方便的方法，用于更新组内所有精灵（例如将`Sprite`对象移动到它们的新位置），添加新的`Sprite`对象，从`Group`中删除`Sprite`对象，等等。让我们看看如何利用这些类来构建我们的微笑爆炸应用。
- en: Using classes to Build our app
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类来构建我们的应用
- en: 'We’re going to create `Sprite` objects for our smiley face balloons that take
    advantage of the `Sprite` class’s properties to produce quick animation around
    the screen, even when hundreds of sprites are being moved in the same frame. I
    mentioned that Pygame also has support for groups of sprites that can all be drawn
    and handled as a collection; this group of sprites will be of type `pygame.sprite.Group()`.
    Let’s look at the setup section of our app:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的微笑气球创建`Sprite`对象，利用`Sprite`类的属性在屏幕上实现快速动画，即使成百上千的精灵在同一帧中被移动。我提到过，Pygame
    也支持精灵组，所有精灵可以作为一个集合一起绘制和处理；这个精灵组的类型是`pygame.sprite.Group()`。让我们来看看应用的设置部分：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The setup looks like *SmileyBounce2.py*, but we’re adding a variable called
    `sprite_list` at ➊ that will contain our group of smiley face sprites. Storing
    the sprites in a `Group` will make it faster and easier to do things like draw
    all the smileys on the screen every frame, move all the smileys for each step
    of the animation, and even check to see if the smiley sprites are colliding with
    objects or with one another.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 设置看起来像*SmileyBounce2.py*，但我们在➊添加了一个名为`sprite_list`的变量，它将包含我们的微笑表情精灵组。将精灵存储在`Group`中将使得执行类似于每帧绘制所有微笑、每步动画移动所有微笑，甚至检查微笑精灵是否与物体或彼此碰撞的操作更加快捷和容易。
- en: 'To create sprite objects for complex animations and games, we will create our
    own `Sprite` class that *extends*, or builds on, Pygame’s `Sprite` class, adding
    the variables and functions that we want for our custom sprites. We’ll name our
    sprite class `Smiley`, and we’ll add variables for the position of each smiley
    (`pos`), its x- and y-velocity (`xvel` and `yvel`; remember *velocity* is another
    word for speed), and its *scale*, or how big each smiley will be (`scale`):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建用于复杂动画和游戏的精灵对象，我们将创建我们自己的`Sprite`类，它*扩展*了Pygame的`Sprite`类，添加我们为自定义精灵所需要的变量和函数。我们将命名我们的精灵类为`Smiley`，并添加变量来表示每个笑脸的位置（`pos`）、其x和y速度（`xvel`和`yvel`，记住*速度*是指速度的另一个词），以及其*缩放*，即每个笑脸的大小（`scale`）：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our `Smiley` class definition starts with the keyword `class`, followed by the
    name we want for our class, plus the type we’re extending (`pygame.sprite.Sprite`).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Smiley`类定义以`class`关键字开始，后跟我们为类命名的名称，以及我们要扩展的类型（`pygame.sprite.Sprite`）。
- en: Setting Up Sprites
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置精灵
- en: The next step after starting our `Smiley` class and listing the data variables
    that we’d like each smiley sprite object to remember is called *initialization*,
    sometimes also referred to as the *constructor* for our class. This will be a
    special function that is called every time a new object of our `Smiley` class
    is created, or *constructed*, in our program. Just like initializing a variable
    gives it a starting value, the *initialization function*, `__init__()`, in our
    `Smiley` class will set up all the starting values we need in our sprite object.
    The two underscores on either side of the `__init__()` function name have special
    meaning in Python. In this case, `__init__()` is the special function name that
    is used to initialize a class. We tell Python how each `Smiley` object should
    be initialized in this function, and every time we create a `Smiley`, this special
    `__init__()` function does its job behind the scenes, setting up variables and
    more for each `Smiley` object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始我们的`Smiley`类并列出我们希望每个笑脸精灵对象记住的数据变量后，接下来的步骤称为*初始化*，有时也称为我们类的*构造函数*。这将是一个特殊的函数，每次在程序中创建一个新的`Smiley`类对象时都会被调用，或者说是*构造*。就像初始化变量会给它一个起始值一样，`Smiley`类中的*初始化函数*`__init__()`将为我们的精灵对象设置所有所需的起始值。`__init__()`函数名两边的两个下划线在Python中有特殊含义。在这个情况下，`__init__()`是用于初始化类的特殊函数名称。我们在这个函数中告诉Python每个`Smiley`对象应该如何初始化，每次我们创建一个`Smiley`时，这个特殊的`__init__()`函数都会在后台执行其任务，为每个`Smiley`对象设置变量等。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189023.png.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages2189023.png.jpg)'
- en: 'There are a number of items we need to set up in our `__init__()` function.
    First, we’ll determine what parameters we need to pass to our `__init__()` function.
    For our random smiley faces, we might pass in a position and the starting x- and
    y-velocities. Because our `Smiley` is a class and all our smiley face sprites
    will be objects of the `Smiley` type, the first parameter in all the functions
    in the class will be the smiley sprite object itself. We label this parameter
    `self`, because it connects `__init__()` and the other functions to the object’s
    own data. Look at the code for our `__init__()` function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`__init__()`函数中设置多个项目。首先，我们需要确定传递给`__init__()`函数的参数。对于我们的随机笑脸，我们可能会传递一个位置和起始的x和y速度。因为我们的`Smiley`是一个类，所有的笑脸精灵都会是`Smiley`类型的对象，所以类中所有函数的第一个参数都会是笑脸精灵对象本身。我们把这个参数命名为`self`，因为它将`__init__()`和其他函数与对象自身的数据连接起来。请看一下我们的`__init__()`函数的代码：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The four parameters for our `__init__()` function are the object itself, `self`;
    the position where we want the smiley to appear, `pos`; and `xvel` and `yvel`,
    its horizontal and vertical speed values. Next, at ➊, we call the initialization
    function for the main `Sprite` class so that our object can take advantage of
    the properties of sprite graphics without coding them from scratch. At ➋, we set
    the image of the sprite object (`self.image`) to the `pic` graphic that we loaded
    from disk (*CrazySmile.bmp*—you’ll need to make sure that file is still in the
    same folder as this new program), and we get the dimensions of the rectangle that
    contains the 100×100 picture.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`__init__()`函数有四个参数，分别是对象本身`self`、我们希望笑脸出现的位置`pos`，以及`xvel`和`yvel`，即其水平和垂直的速度值。接下来，在➊处，我们调用主`Sprite`类的初始化函数，这样我们的对象就可以利用精灵图形的属性，而无需从头开始编写这些属性。在➋处，我们将精灵对象的图像（`self.image`）设置为从磁盘加载的`pic`图形（*CrazySmile.bmp*——你需要确保该文件仍然与这个新程序在同一个文件夹中），然后我们获取包含100×100图片的矩形的尺寸。
- en: At ➌, the statement `self.pos = pos` stores the position that was passed into
    the `__init__()` function in the object’s own `pos` variable. Then, at ➍, we set
    the x- and y-coordinates of the sprite’s drawing rectangle to the x- and y-coordinates
    stored in `pos`, shifted by half the size of the image (`self.scale/2`) so that
    the smiley is centered on the spot the user clicked with the mouse. Finally, we
    store the x- and y-velocities that were passed to the `__init__()` function in
    the object’s `xvel` and `yvel` variables (`self.xvel` and `self.yvel`) at ➎.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处，语句`self.pos = pos`将传递给`__init__()`函数的位置存储在对象自己的`pos`变量中。然后，在➍处，我们将精灵绘制矩形的x和y坐标设置为存储在`pos`中的x和y坐标，并将它们按图像大小的一半（`self.scale/2`）进行偏移，以便使笑脸在用户点击的地方居中。最后，在➎处，我们将传递给`__init__()`函数的x和y速度值存储在对象的`xvel`和`yvel`变量中（`self.xvel`和`self.yvel`）。
- en: This `__init__()` constructor function will set up everything we need for drawing
    each smiley face on the screen, but it doesn’t handle the animation needed to
    move our sprites around the screen. For that, we’ll add another handy function
    for our sprites, `update()`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`__init__()`构造函数将设置我们在屏幕上绘制每个笑脸所需的一切，但它并没有处理需要将精灵移动到屏幕上所需的动画。为此，我们将为我们的精灵添加另一个有用的函数，`update()`。
- en: Updating Sprites
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新精灵
- en: Sprites are built for animation, and we’ve learned that animation means updating
    the location of a graphic each frame (each time we pass through the game loop).
    Pygame sprites have an `update()` function built in, and we can *override*, or
    customize, this function to program the behavior that we want from our custom
    sprites.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵是为动画设计的，我们已经了解到，动画意味着每一帧（每次通过游戏循环时）更新图形的位置。Pygame的精灵自带一个`update()`函数，我们可以*重写*或自定义这个函数，以编写我们希望从自定义精灵中获得的行为。
- en: 'Our `update()` function is pretty simple; the only updates to our bouncing
    smiley sprites for each frame are changing the position of each sprite according
    to its speed and checking to see whether it has collided with the edge of the
    screen:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`update()`函数相当简单；每帧更新我们弹跳的笑脸精灵的唯一方式就是根据其速度更改精灵的位置，并检查它是否与屏幕边缘发生碰撞：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `update()` function takes one parameter—the sprite object itself, `self`—and
    the code for moving the sprite looks a lot like our animation code from *SmileyBounce2.py*.
    The only real difference is that we refer to the sprite’s (*x*, *y*) location
    with `self.rect.x` and `self.rect.y`, and the x- and y-velocities as `self.xvel`
    and `self.yvel`. Our collision detections for the boundaries of the screen also
    make use of `screen.get_width()` and `screen.get_height()` so they can function
    for any size window.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`函数有一个参数——精灵对象本身`self`——并且移动精灵的代码看起来很像我们在*SmileyBounce2.py*中的动画代码。唯一的真正区别是，我们通过`self.rect.x`和`self.rect.y`引用精灵的（*x*，*y*）位置，将x和y的速度分别称为`self.xvel`和`self.yvel`。我们的屏幕边界碰撞检测也使用了`screen.get_width()`和`screen.get_height()`，因此它们可以适用于任何大小的窗口。'
- en: Bigger and Smaller Smileys
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更大和更小的笑脸
- en: 'The last feature we’ll add to this first version of the app is changing the
    *scale*, or size, of the image. We’ll make this modification to our `__init__()`
    function right after setting `self.image` to `pic`. First, we’ll change our object’s
    `scale` variable to a random number between 10 and 100 (for a finished smiley
    sprite that measures between 10×10 and 100×100 pixels in size). We’ll apply this
    change in scale, also known as a *transformation*, by using the `pygame.transform.scale()`
    function, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个应用程序的第一个版本添加的最后一个功能是改变图像的*比例*，即大小。我们将在设置`self.image`为`pic`后，修改`__init__()`函数。首先，我们将对象的`scale`变量更改为10到100之间的随机数（用于生成一个大小在10×10到100×100像素之间的完整笑脸精灵）。我们将使用`pygame.transform.scale()`函数应用这一比例变换（也称为*转换*），代码如下：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Pygame’s `transform.scale()` function takes an image (our `self.image` of the
    smiley graphic) and the new dimensions (our new random `self.scale` value as the
    width and height of the transformed image), and it returns the scaled (up or down,
    bigger or smaller) image, which we’re storing as the new `self.image`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame的`transform.scale()`函数接受一个图像（我们的笑脸图像`self.image`）和新的尺寸（我们新的随机`self.scale`值作为图像的宽度和高度），并返回缩放后的（放大或缩小）图像，我们将其存储为新的`self.image`。
- en: With this last change, we should now be able to use our `Smiley` sprite class
    to draw smiley faces of random sizes and speeds all over our screen with drawing
    code similar to our *DragDots.py* drawing app, plus a few changes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个最后的修改，我们现在应该能够使用我们的`Smiley`精灵类在屏幕上绘制不同大小和速度的笑脸，绘制代码与我们的*DragDots.py*绘图应用类似，并做了一些修改。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189025.png.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2189025.png.jpg)'
- en: Putting It All Together
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 综合总结
- en: 'Here’s our full *SmileyExplosion.py* app:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的完整*SmileyExplosion.py*应用：
- en: SmileyExplosion.py
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SmileyExplosion.py
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code for the game loop in *SmileyExplosion.py* is similar to our drawing
    app *DragDots.py*, with a few notable changes. At ➊, we’re calling the `update()`
    function on the list of smiley sprites stored in `sprite_list`; this single line
    will call the update function to move every smiley face on the screen and check
    for edge bounces. Similarly, the code at ➋ will draw every smiley face on the
    screen in its proper location. It takes only two lines of code to animate and
    draw potentially hundreds of sprites—that’s a huge time savings, and it’s just
    part of the power of sprite graphics in Pygame.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*SmileyExplosion.py*中的游戏循环代码与我们的绘图应用*DragDots.py*相似，但有一些显著的变化。在➊处，我们对存储在`sprite_list`中的笑脸精灵列表调用`update()`函数；这一行代码将调用更新函数，移动每个屏幕上的笑脸并检查边缘反弹。类似地，➋处的代码将在屏幕上按正确位置绘制每个笑脸。只需两行代码就可以对数百个精灵进行动画处理和绘制——这节省了大量时间，也是Pygame精灵图形强大功能的一部分。'
- en: In our `mousedown` drawing code, we generate a random `speedx` and `speedy`
    for the horizontal and vertical speed of each new smiley face, and at ➌, we create
    a new smiley face, `newSmiley`, by calling the constructor for our class `Smiley`.
    Notice that we don’t have to use the function name `__init__()`; rather, we use
    the name of the class, `Smiley`, whenever we’re constructing or creating a new
    object of the `Smiley` class or type. We pass the constructor function the position
    of the mouse, along with the random speed we just created. Finally, at ➍, we take
    our newly created smiley face sprite, `newSmiley`, and add it to our `Group` of
    sprites called `sprite_list`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`mousedown`绘图代码中，我们为每个新笑脸生成一个随机的`speedx`和`speedy`，用于控制笑脸在水平和垂直方向的速度，在➌处，我们通过调用`Smiley`类的构造函数来创建一个新的笑脸`newSmiley`。注意，我们不需要使用函数名`__init__()`；相反，我们在构造或创建新的`Smiley`类或类型对象时，直接使用类名`Smiley`。我们将鼠标的位置和刚刚创建的随机速度传递给构造函数。最后，在➍处，我们将新创建的笑脸精灵`newSmiley`添加到我们的精灵组`
    sprite_list`中。
- en: We’ve just created a fast, fluid, interactive animation for dozens or even hundreds
    of smiley face sprite graphics, floating around the screen like balloons of various
    sizes, traveling at random speeds in every direction. In the final upgrade to
    this app, we’ll see an even more impressive and powerful feature of sprite graphics
    that handles detecting collisions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个快速、流畅、互动的动画，可以展示数十个甚至数百个笑脸精灵图形，它们像气球一样在屏幕上漂浮，大小不一，随机速度四处移动。在这个应用程序的最后一次升级中，我们将看到一个更令人印象深刻、更强大的精灵图形功能，它能处理碰撞检测。
- en: SmileyPop, Version 1.0
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SmileyPop，第1.0版
- en: 'For our closing example, we’ll add one crucial bit of fun to the *SmileyExplosion.py*
    program: the ability to “pop” the smiley balloons/bubbles by clicking the right
    mouse button (or by pressing the CONTROL key and clicking on a Mac). The effect
    is like a balloonpopping game or Ant Smasher, Whack-a-Mole, and so on. We’ll be
    able to create smiley balloons by dragging the left mouse button, and we’ll pop
    them (that is, remove them from the screen) by clicking the right mouse button
    over one or more of the smiley sprites.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的结尾示例，我们将在 *SmileyExplosion.py* 程序中添加一个重要的有趣功能：通过点击右键（或者在 Mac 上按住 CONTROL
    键并点击）来“爆破”笑脸气球/泡泡。这个效果类似于气球爆破游戏、蚂蚁打击、打地鼠等。我们可以通过拖动左键创建笑脸气球，然后通过右键点击一个或多个笑脸精灵来将其“爆破”（即从屏幕上移除）。
- en: Detecting Collisions and Removing Sprites
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测碰撞并移除精灵
- en: The great news is that the `Sprite` class in Pygame comes with collision detection
    built in. We can use the function `pygame.sprite.collide_rect()` to check whether
    the rectangles holding two sprites have collided; we can use the `collide_circle()`
    function to check whether two round sprites are touching; and if we’re just checking
    to see whether a sprite has collided with a single point (like the pixel where
    the user just clicked the mouse), we can use a sprite’s `rect.collidepoint()`
    function to check whether a sprite overlaps, or collides with, that point on the
    screen.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Pygame 中的 `Sprite` 类内置了碰撞检测功能。我们可以使用 `pygame.sprite.collide_rect()` 函数检查两个精灵的矩形是否相撞；我们可以使用
    `collide_circle()` 函数检查两个圆形精灵是否接触；如果我们只是检查一个精灵是否与一个单一的点（例如用户刚刚点击的鼠标像素）发生碰撞，我们可以使用精灵的
    `rect.collidepoint()` 函数来检查精灵是否与该点重叠或碰撞。
- en: 'If we’ve determined that the user clicked a point that touches one or more
    sprites, we can remove each of those sprites from our `sprite_list` group by calling
    the `remove()` function. We can handle all the logic for popping smiley balloons
    in our `MOUSEBUTTONDOWN` event handler code. To turn *SmileyExplosion.py* into
    *SmileyPop.py*, we’ll just replace these two lines:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经确定用户点击了一个触及一个或多个精灵的点，我们可以通过调用 `remove()` 函数将这些精灵从我们的 `sprite_list` 组中移除。我们可以在
    `MOUSEBUTTONDOWN` 事件处理程序代码中处理所有爆破笑脸气球的逻辑。为了将 *SmileyExplosion.py* 转变为 *SmileyPop.py*，我们只需替换这两行：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'with the following seven lines of code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下七行代码：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `if` statement for `MOUSEBUTTONDOWN` events remains the same, but now, we’re
    interested in *which* button was pressed. At ➊, we check to see if the *left*
    mouse button was pressed (the first button, at index `[0]`); if so, we turn on
    the `mousedown` Boolean flag, and the game loop will draw new smiley faces. At
    ➋, we see if the *right* mouse button is pressed, beginning the logic to check
    whether the mouse was clicked over one or more smileys in our `sprite_list`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOUSEBUTTONDOWN` 事件的 `if` 语句保持不变，但现在我们关心的是*哪个*按钮被按下。在 ➊ 处，我们检查是否按下了*左*鼠标按钮（第一个按钮，索引为
    `[0]`）；如果是，我们启用 `mousedown` 布尔标志，游戏循环将绘制新的笑脸。在 ➋ 处，我们检查是否按下了*右*鼠标按钮，这开始了检查鼠标是否点击了我们
    `sprite_list` 中一个或多个笑脸的逻辑。'
- en: First, at ➌, we get the mouse’s location and store it in the variable `pos`.
    At ➍, we use a programming shortcut to generate a list of sprites from `sprite_list`
    that collide with, or overlap, the point the user clicked at `pos`. If a sprite
    `s` in the group `sprite_list` has a rectangle that collides with the point `pos`,
    group it together as a list `[s]` and store the list as `clicked_smileys`. That
    ability to create one list, collection, or array from another based on an `if`
    condition is a powerful feature of Python, and it makes our code much shorter
    for this app.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 ➌ 处，我们获取鼠标的位置并将其存储在变量`pos`中。在 ➍ 处，我们使用编程快捷方式生成一个来自 `sprite_list` 的精灵列表，这些精灵与用户点击的位置
    `pos` 相交或重叠。如果 `sprite_list` 中的某个精灵 `s` 的矩形与 `pos` 点相交，则将其组合为一个列表 `[s]` 并将该列表存储为
    `clicked_smileys`。根据 `if` 条件从另一个列表、集合或数组中创建一个列表的能力是 Python 的一个强大特性，它使得我们的代码在这个应用中变得更加简洁。
- en: Finally, at ➎, we call the handy `remove()` function on our `Group` of sprites
    called `sprite_list`. This `remove()` function is different from Python’s regular
    `remove()` function, which removes a single item from a list or collection. The
    `pygame.sprite.Group.remove()` function will remove any number of sprites from
    a list. In this case, it will remove all the sprites from our `sprite_list` that
    collide with the point the user clicked on the screen. Once these sprites are
    removed from `sprite_list`, when `sprite_list` is drawn to the screen in our game
    loop, the clicked sprites are no longer in the list, so they don’t get drawn.
    It’s like they’ve disappeared—or we’ve popped them like balloons or bubbles!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 ➎ 处，我们调用了我们精灵列表 `sprite_list` 上的便捷 `remove()` 函数。这个 `remove()` 函数不同于 Python
    的常规 `remove()` 函数，后者从列表或集合中移除一个单独的项。而 `pygame.sprite.Group.remove()` 函数可以从列表中移除任意数量的精灵。在这种情况下，它将移除所有与用户点击屏幕的点发生碰撞的精灵。一旦这些精灵从
    `sprite_list` 中移除，当 `sprite_list` 在游戏循环中绘制到屏幕上时，被点击的精灵将不再出现在列表中，因此不会被绘制出来。就像它们消失了一样——或者我们像气球或泡泡一样把它们“弹出”！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189027.png.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图像](httpatomoreillycomsourcenostarchimages2189027.png.jpg)'
- en: Putting It All Together
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 综合起来
- en: Here’s the complete *SmileyPop.py* code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的 *SmileyPop.py* 代码。
- en: SmileyPop.py
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SmileyPop.py
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Remember that you’ll have to have the *CrazySmile.bmp* image file stored in
    the same folder or directory as the code to make it work. Once it does work, this
    program is so much fun to play with, it’s almost addictive! In the next chapter,
    we’ll learn about the elements of game design that make games fun, and we’ll build
    a complete game from scratch!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你需要将 *CrazySmile.bmp* 图像文件与代码存储在同一个文件夹或目录中才能使其正常工作。一旦它正常工作，这个程序玩起来非常有趣，几乎让人上瘾！在下一章中，我们将学习使游戏有趣的游戏设计元素，并从零开始制作一个完整的游戏！
- en: What You Learned
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: In this chapter, we combined user interaction with animation to create an explosion
    of smileys on the screen, and we used sprite graphics to make even hundreds of
    smiley images easy and fast to animate. We learned how to build our own `Sprite`
    class so that we could customize sprites with the features and behaviors we wanted,
    including data variables, an initialization function, and a custom update function.
    We also learned how to scale images in Pygame so that our smileys could come in
    all different shapes and sizes, and we learned the advantages of using `pygame.sprite.Group()`
    to store all our sprites for quick updating and drawing on the screen.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将用户交互与动画结合起来，在屏幕上创造了一个笑脸的爆炸效果，并使用精灵图形使得成百上千个笑脸图像的动画制作变得轻松而快速。我们学习了如何构建自己的
    `Sprite` 类，以便自定义精灵的特性和行为，包括数据变量、初始化函数和自定义更新函数。我们还学习了如何在 Pygame 中缩放图像，以便我们的笑脸可以有各种不同的形状和大小，并学习了使用
    `pygame.sprite.Group()` 来存储所有精灵，以便快速更新和绘制到屏幕上的优势。
- en: In our closing example, we added sprite-based collision detection to see whether
    the user right-clicked the mouse over one or more smiley sprites. We saw how to
    check for events on the left mouse button separately from the right mouse button.
    We learned that Python has powerful features for selecting items out of a list
    based on an `if` condition, and we saw how to remove sprites from a `Group` using
    the `remove()` function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的结束示例中，我们添加了基于精灵的碰撞检测，看看用户是否在一个或多个笑脸精灵上右键单击了鼠标。我们展示了如何分别检测鼠标左键和右键的事件。我们还学会了
    Python 在根据 `if` 条件从列表中选择项目时的强大功能，并展示了如何使用 `remove()` 函数从 `Group` 中移除精灵。
- en: 'We created fun apps in this chapter, topped off by a SmileyPop app that we’ll
    make even more game-like in [Chapter 10](ch10.html "Chapter 10. Game Programming:
    Coding for Fun"). Pygame has given us the final skills we need to program awesome
    games!'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了有趣的应用程序，最后制作了一个 SmileyPop 应用程序，在[第 10 章](ch10.html "第 10 章. 游戏编程：编写有趣的代码")中我们将把它变得更加像游戏。Pygame
    给我们提供了编写超酷游戏所需的最终技能！
- en: 'Programming the cool apps in this chapter has given us the skills to do the
    following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中编写的酷应用程序赋予了我们以下技能：
- en: Use sprite graphics by customizing the `pygame.sprite.Sprite()` class.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过自定义 `pygame.sprite.Sprite()` 类使用精灵图形。
- en: Access, modify, update, and draw a list of sprites using `pygame.sprite.Group()`
    and its functions.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pygame.sprite.Group()` 及其函数访问、修改、更新并绘制精灵列表。
- en: Transform an image by applying the `pygame.trasform.scale()` function to increase
    or decrease the image’s size in pixels.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用 `pygame.trasform.scale()` 函数来转换图像，增加或减少图像的像素大小。
- en: Detect sprite collisions using `rect.collidepoint()` and similar functions from
    the `Sprite` class.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `rect.collidepoint()` 和 `Sprite` 类的类似函数来检测精灵碰撞。
- en: Remove sprites from a `Group` using the `remove()` function.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `remove()` 函数从 `Group` 中移除精灵。
- en: Programming Challenges
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 编程挑战
- en: Here are three challenge problems to extend the skills developed in this chapter.
    For sample answers to these challenges, go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个挑战问题，可以扩展本章所开发的技能。对于这些挑战的示例答案，请访问 *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*。
- en: '**#1: RANDOMLY COLORED DOTS**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1: 随机颜色的点**'
- en: Start by choosing your own color triplet to use in the *DragDots.py* program.
    Then modify the program to draw randomly colored dots by creating a triplet of
    three random numbers between 0 and 255 to use as your colors. Call your new creation
    *RandomPaint.py*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从选择你自己的颜色三元组开始，用于 *DragDots.py* 程序。然后修改程序，创建一个由三个在 0 到 255 之间的随机数字组成的三元组作为颜色，来绘制随机颜色的点。将你新创作的程序命名为
    *RandomPaint.py*。
- en: '**#2: PAINTING IN COLORS**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**#2: 用颜色绘画**'
- en: 'Let the user draw in two or more consistent colors using any of the following
    options:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让用户使用以下任意选项，在两种或更多种一致的颜色中绘制：
- en: Change the current drawing color each time the user presses a key, either to
    a random color each time or to a specific color for certain keys (like red for
    R, blue for B, and so on).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当用户按下一个键时，更改当前的绘图颜色，可以是每次随机颜色，或者对于某些特定的按键（如 R 为红色，B 为蓝色，等等），将颜色更改为特定颜色。
- en: Draw with different colors for each of the mouse buttons (red for the left mouse
    button, green for the middle button, and blue for the right mouse button, for
    example).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据不同的鼠标按钮使用不同的颜色进行绘画（例如，左键为红色，中键为绿色，右键为蓝色）。
- en: Add some colored rectangles to the bottom or side of the screen, and modify
    the program so that if the user clicks in a rectangle, the drawing color changes
    to the same color as the rectangle.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕底部或侧面添加一些彩色矩形，并修改程序，使得如果用户点击某个矩形，绘图颜色就会改变为该矩形的颜色。
- en: Try one approach, or all three, and save your new file as *ColorPaint.py*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一种方法，或者三种方法都尝试，并将你的新文件保存为 *ColorPaint.py*。
- en: '**#3: THROWING SMILEYS**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**#3: 扔笑脸**'
- en: Pygame has a function called `pygame.mouse.get_rel()` that will return the amount
    of *relative* motion, or how much the mouse’s position has changed in pixels since
    the last call to `get_rel()`, in the x- and y-directions. Modify your *SmileyExplosion.py*
    file to use the amount of relative mouse motion in the x- and y-directions as
    the horizontal and vertical speeds of each smiley (instead of generating a pair
    of random `speedx` and `speedy` values). This will look like the user is throwing
    smileys because they will speed off in the direction the user is dragging the
    mouse!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame 有一个名为 `pygame.mouse.get_rel()` 的函数，它会返回 *相对* 移动的量，或者说自上次调用 `get_rel()`
    以来，鼠标位置在 x 轴和 y 轴方向上变化的像素数。修改你的 *SmileyExplosion.py* 文件，使用相对鼠标移动的量作为每个笑脸的水平和垂直速度（而不是生成一对随机的
    `speedx` 和 `speedy` 值）。这看起来像是用户正在扔笑脸，因为它们会朝着用户拖动鼠标的方向飞速移动！
- en: To add another realistic effect, slow the smileys slightly by multiplying `xvel`
    and `yvel` by a number smaller than 1.0 (like 0.95) in the `update(self)` section
    every time the smileys bounce off an edge of the screen. The smileys will slow
    down over time, as if friction from each wall bounce is making them move slower
    and slower. Save your new app as *SmileyThrow.py*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加另一个现实效果，通过将 `xvel` 和 `yvel` 乘以小于 1.0 的数字（如 0.95），使得每次笑脸碰到屏幕边缘时，笑脸的速度稍微变慢。笑脸会随着时间的推移而变慢，就像每次碰到墙壁的摩擦力让它们的速度逐渐减慢一样。将你新制作的应用保存为
    *SmileyThrow.py*。
