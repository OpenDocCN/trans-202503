- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: HIGHER-ORDER FUNCTIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common.jpg)'
- en: Higher-order functions are central to functional programming and flow naturally
    from the idea that functions should be “first-class objects” in a language, with
    all of the rights and privileges that numbers or lists have. A *higher-order function*
    is one that accepts a function as input and/or returns a function as output. Many
    things we want the computer to do for us find a natural expression as a higher-order
    function.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是函数式编程的核心，它自然地源自于函数应该是语言中的“第一类对象”的思想，拥有数字或列表的所有权利和特权。*高阶函数*是接受一个函数作为输入和/或返回一个函数作为输出的函数。许多我们希望计算机为我们做的事情可以自然地表达为高阶函数。
- en: In this chapter, we’ll first look at higher-order functions that produce functions
    as output. We’ll see that these higher-order functions can be viewed as having
    one input, or alternatively, as having multiple inputs. From there, we’ll consider
    mapping, the idea of applying a function to every element of a list and producing
    a list of the results. We’ll then show how we can use the higher-order function
    `iterate`, another function that takes a function as input, to do our iteration.
    After looking at anonymous higher-order functions and operators, we’ll look at
    predicate-based higher-order functions. Finally, we’ll look in detail at numerical
    integration, a central tool in physics that has a natural expression as a higher-order
    function.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将首先讨论产生函数作为输出的高阶函数。我们将看到，这些高阶函数可以被视为具有一个输入，或者作为具有多个输入。接着，我们将讨论映射，即将一个函数应用于列表的每个元素并生成结果列表的概念。然后，我们将展示如何使用高阶函数`iterate`，另一个接受函数作为输入的函数，来进行迭代。查看匿名高阶函数和操作符之后，我们将讨论基于谓词的高阶函数。最后，我们将详细探讨数值积分，这是物理学中的一个核心工具，它作为高阶函数有着自然的表达。
- en: How to Think About Functions with Parameters
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何理解具有参数的函数
- en: Consider the force of a linear spring with a spring constant *k*. We usually
    write this as
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个线性弹簧的力，弹簧常数为*k*。我们通常将其表示为
- en: '*F*[spring] = –*kx*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*F*[spring] = –*kx*'
- en: where the minus sign indicates that the force acts in the direction opposite
    the displacement.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 其中负号表示力的方向与位移方向相反。
- en: 'Suppose we wish to write a Haskell function to give the force in Newtons produced
    by a spring with a spring constant of 5,500 N/m. We could write the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望编写一个Haskell函数，计算一个弹簧常数为5500 N/m的弹簧产生的牛顿力。我们可以写如下代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a fine function, but it handles only the force produced by a spring
    with a spring constant of 5500 N/m. It would be nicer to have a function that
    could handle a spring with any spring constant.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不错的函数，但它仅处理具有5500 N/m弹簧常数的弹簧产生的力。最好有一个能够处理任何弹簧常数的函数。
- en: Note that as usual, we are using the type synonym
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，和往常一样，我们使用了类型同义词
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: because we like to think of these numbers as real numbers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们喜欢将这些数字看作是实数。
- en: 'Now consider the following function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下函数：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Because arrows between types associate to the right, `springForce`’s type, `R
    -> R -> R`, is equivalent to `R -> (R -> R)`, meaning that if we send the `spring`
    `Force` function an `R` (the spring constant), it will return to us a *function*
    with type `R -> R`. This latter function wants an `R` as input (the displacement)
    and will give an `R` as output (the force).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因为类型之间的箭头是向右关联的，`springForce`的类型`R -> R -> R`等价于`R -> (R -> R)`，意味着如果我们将`spring`的`Force`函数传递给一个`R`（弹簧常数），它将返回给我们一个类型为`R
    -> R`的*函数*。这个后续函数希望输入一个`R`（位移），并将输出一个`R`（力）。
- en: 'We can look at the types of these functions using GHCi’s :type command (abbreviated
    `:t`):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用GHCi的:type命令（缩写为`t`）来查看这些函数的类型：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, let’s look at the function `springForce 2200`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看`springForce 2200`函数：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The function `springForce 2200` represents the force function (input: displacement,
    output: force) for a spring with a spring constant of 2200 N/m. It has the same
    type and plays the same role as the springForce5500 function above. However, it
    looks funny because it is a function made up of two parts: the springForce part
    and the 2200 part.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`springForce 2200`表示一个弹簧力函数（输入：位移，输出：力），用于具有2200 N/m弹簧常数的弹簧。它与上面的springForce5500函数具有相同的类型并发挥相同的作用。然而，它看起来有些奇怪，因为它是由两个部分组成的：springForce部分和2200部分。
- en: 'Finally, look at the type of `springForce 2200 0.4`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，看看`springForce 2200 0.4`的类型：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is not a function but just a number representing the force exerted by a
    spring with a spring constant of 2200 N/m when extended by a distance of 0.4 m.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个函数，而只是一个数字，表示当弹簧常数为2200 N/m时，弹簧被拉伸0.4米所施加的力。
- en: 'A function that takes another function as input or returns another function
    as a result is called a higher-order function. The function `springForce` is a
    higher-order function because it returns a function as its result. [Figure 6-1](ch06.xhtml#ch6fig1)
    shows that the `springForce` function takes a number as input (the spring constant
    `k :: R`) and returns a function as output (`springForce k :: R -> R`). The function
    `springForce k` then takes a number as input (the displacement `x :: R`) and returns
    a number as output (the force `springForce k x :: R`).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '一个接受另一个函数作为输入或返回另一个函数作为结果的函数被称为高阶函数。函数`springForce`是一个高阶函数，因为它返回一个函数作为结果。[图
    6-1](ch06.xhtml#ch6fig1)显示了`springForce`函数接受一个数字作为输入（弹簧常数`k :: R`），并返回一个函数作为输出（`springForce
    k :: R -> R`）。然后，函数`springForce k`接受一个数字作为输入（位移`x :: R`），并返回一个数字作为输出（力`springForce
    k x :: R`）。'
- en: '![Image](Images/071fig01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/071fig01.jpg)'
- en: '*Figure 6-1:* The higher-order function springForce takes a number as input
    and returns the function springForce k as output. The function springForce k then
    takes a number as input and returns a number as output.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：* 高阶函数`springForce`接受一个数字作为输入，并返回函数`springForce k`作为输出。函数`springForce
    k`然后接受一个数字作为输入并返回一个数字作为输出。'
- en: Higher-order functions give us a convenient way to define a function that takes
    one or more parameters (like the spring constant) in addition to its “actual”
    input (like the displacement). [Table 6-1](ch06.xhtml#ch6tab1) shows some higher-order
    functions from the Prelude that return a function as output.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数为我们提供了一种方便的方式来定义一个函数，它除了“实际”输入（如位移）外，还接受一个或多个参数（如弹簧常数）作为输入。[表 6-1](ch06.xhtml#ch6tab1)展示了Prelude中一些返回函数作为输出的高阶函数。
- en: '**Table 6-1:** Some Higher-Order Functions from the Prelude That Produce a
    Function as Output'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-1：** Prelude 中一些返回函数作为输出的高阶函数'
- en: '| **Function** |  | **Type** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **函数** |  | **类型** |'
- en: '| --- | --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `take` | `::` | `Int -> [a] -> [a]` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `take` | `::` | `Int -> [a] -> [a]` |'
- en: '| `drop` | `::` | `Int -> [a] -> [a]` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `drop` | `::` | `Int -> [a] -> [a]` |'
- en: '| `replicate` | `::` | `Int -> a -> [a]` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `replicate` | `::` | `Int -> a -> [a]` |'
- en: Consider the higher-order function `take`. The `take` function produces a list
    by taking a given number of elements from a given list. [Table 6-2](ch06.xhtml#ch6tab2)
    shows some examples of its use.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑高阶函数`take`。`take`函数通过从给定列表中取出指定数量的元素来生成一个新列表。[表 6-2](ch06.xhtml#ch6tab2)展示了它的一些使用示例。
- en: '**Table 6-2:** Examples of the Use of take'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-2：** `take` 使用示例'
- en: '| **Expression** |  | **Evaluates to** |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **求值结果** |'
- en: '| --- | --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `take 3 [9,7,5,3,17]` | ⇝ | `[9,7,5]` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `take 3 [9,7,5,3,17]` | ⇝ | `[9,7,5]` |'
- en: '| `take 3 [3,2]` | ⇝ | `[3,2]` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `take 3 [3,2]` | ⇝ | `[3,2]` |'
- en: '| `take 4 [1..]` | ⇝ | `[1,2,3,4]` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `take 4 [1..]` | ⇝ | `[1,2,3,4]` |'
- en: '| `take 4 [-10.0,-9.5..10]` | ⇝ | `[-10.0,-9.5,-9.0,-8.5]` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `take 4 [-10.0,-9.5..10]` | ⇝ | `[-10.0,-9.5,-9.0,-8.5]` |'
- en: 'Let’s look at the type of `take`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`take`的类型：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: According to the type of `take`, when given an `Int`, it should return a function
    with type `[a] -> [a]`. What function should `take` return? If we give the integer
    *n* to `take`, the returned function will accept a list as input and return a
    list of the first *n* elements of the input list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`take`的类型，当传入一个`Int`时，它应该返回一个类型为`[a] -> [a]`的函数。那么`take`应该返回什么样的函数呢？如果我们将整数*n*传给`take`，返回的函数将接受一个列表作为输入，并返回输入列表的前*n*个元素。
- en: There are two ways to think about the higher-order function `take` (and others
    like it that return a function as output), as shown in [Table 6-3](ch06.xhtml#ch6tab3).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式来理解高阶函数`take`（以及其他类似的返回函数作为输出的函数），如[表 6-3](ch06.xhtml#ch6tab3)所示。
- en: '**Table 6-3:** Two Ways of Thinking About the Higher-Order Function take'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-3：** 理解高阶函数`take`的两种思维方式'
- en: '| **Way of thinking** | **Input to `take`** | **Output from `take`** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **思考方式** | **传给 `take` 的输入** | **`take` 的输出** |'
- en: '| --- | --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| One-input thinking | `Int` | `[a] -> [a]` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 单输入思维 | `Int` | `[a] -> [a]` |'
- en: '| Two-input thinking | `Int and then [a]` | `[a]` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 双输入思维 | `Int 和 [a]` | `[a]` |'
- en: We have already described, with `springForce`, the “one-input thinking” in which
    we read the type signature of `take` as expecting a single `Int` as input and
    producing a `[a] -> [a]` (read “list of `a` to list of `a`”) as output. [Figure
    6-2](ch06.xhtml#ch6fig2) shows the one-input picture of `take`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过`springForce`描述了“单输入思维”，即将`take`的类型签名理解为期望一个`Int`作为输入，并产生一个`[a] -> [a]`（可以读作“a
    类型的列表到 a 类型的列表”）作为输出。[图 6-2](ch06.xhtml#ch6fig2)展示了`take`的单输入图。
- en: '![Image](Images/072fig01.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/072fig01.jpg)'
- en: '*Figure 6-2:* One-input thinking about the higher-order function take'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：* 以单个输入的方式理解高阶函数 `take`'
- en: An alternative way to think about the type signature `Int -> [a] -> [a]` is
    that the function expects two inputs, the first of type `Int` and the second of
    type `[a]`, and produces an output of type `[a]`. [Figure 6-3](ch06.xhtml#ch6fig3)
    shows the two-input picture of `take`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种理解类型签名`Int -> [a] -> [a]`的方法是，函数期望接收两个输入，第一个是类型为`Int`，第二个是类型为`[a]`，并返回一个类型为`[a]`的输出。[图
    6-3](ch06.xhtml#ch6fig3)展示了`take`的两个输入图。
- en: '![Image](Images/072fig02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/072fig02.jpg)'
- en: '*Figure 6-3:* Two-input thinking about the higher-order function take'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：* 以两个输入的方式理解高阶函数 `take`'
- en: As readers and writers of higher-order functions, we have a choice in how to
    think about them. Sometimes it is convenient to think of a higher-order function
    as accepting multiple inputs, but it can also be very useful to think of every
    function, higher-order functions included, as accepting exactly one input. The
    Haskell compiler regards every function as having exactly one input.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为高阶函数的读者和编写者，我们可以选择不同的方式来理解它们。有时，将高阶函数理解为接受多个输入会很方便，但同样，考虑每个函数（包括高阶函数）只接受一个输入也是非常有用的。Haskell
    编译器将每个函数视为具有一个输入。
- en: Like `take`, the higher-order function `drop` is another everyday tool for working
    with lists. The function `drop` produces a list by discarding a given number of
    elements from a given list. [Table 6-4](ch06.xhtml#ch6tab4) shows some examples
    of its use.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 像`take`一样，`drop`这个高阶函数是操作列表的另一种常用工具。`drop`函数通过丢弃给定列表中的若干个元素来生成一个新的列表。[表 6-4](ch06.xhtml#ch6tab4)展示了它的一些使用示例。
- en: '**Table 6-4:** Examples of the Use of drop'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-4：** `drop`函数使用示例'
- en: '| **Expression** |  | **Evaluates to** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **计算结果** |'
- en: '| --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `drop 3 [9,7,5,10,17]` | ⇝ | `[10,17]` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `drop 3 [9,7,5,10,17]` | ⇝ | `[10,17]` |'
- en: '| `drop 3 [4,2]` | ⇝ | `[]` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `drop 3 [4,2]` | ⇝ | `[]` |'
- en: '| `drop 37 [-10.0,-9.5..10]` | ⇝ | `[8.5,9.0,9.5,10.0]` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `drop 37 [-10.0,-9.5..10]` | ⇝ | `[8.5,9.0,9.5,10.0]` |'
- en: The function `replicate` produces a list by repeating one item a given number
    of times. [Table 6-5](ch06.xhtml#ch6tab5) shows some examples of its use.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`replicate`函数通过重复某一项若干次来生成一个列表。[表 6-5](ch06.xhtml#ch6tab5)展示了它的一些使用示例。'
- en: '**Table 6-5:** Examples of the Use of replicate'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-5：** `replicate`函数使用示例'
- en: '| **Expression** |  | **Evaluates to** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **计算结果** |'
- en: '| --- | --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `replicate 2 False` | ⇝ | `[False,False]` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `replicate 2 False` | ⇝ | `[False,False]` |'
- en: '| `replicate 3 "ho"` | ⇝ | `["ho","ho","ho"]` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `replicate 3 "ho"` | ⇝ | `["ho","ho","ho"]` |'
- en: '| `replicate 4 5` | ⇝ | `[5,5,5,5]` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `replicate 4 5` | ⇝ | `[5,5,5,5]` |'
- en: '| `replicate 3 ''x''` | ⇝ | `"xxx"` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `replicate 3 ''x''` | ⇝ | `"xxx"` |'
- en: In this section, we’ve focused on higher-order functions that return functions
    as output. Now let’s take a look at a higher-order function that takes a function
    as input.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们关注的是返回函数作为输出的高阶函数。接下来，我们将介绍一个接受函数作为输入的高阶函数。
- en: Mapping a Function Over a List
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对列表应用函数
- en: '[Table 6-6](ch06.xhtml#ch6tab6) shows some higher-order Prelude functions that
    take other functions as input.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-6](ch06.xhtml#ch6tab6)展示了一些接受其他函数作为输入的高阶 Prelude 函数。'
- en: '**Table 6-6:** Some Higher-Order Functions from the Prelude That Accept a Function
    as Input'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-6：** 一些接受函数作为输入的 Prelude 高阶函数'
- en: '| **Function** |  | **Type** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **函数** |  | **类型** |'
- en: '| --- | --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `map` | `::` | `(a -> b) -> [a] -> [b]` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `map` | `::` | `(a -> b) -> [a] -> [b]` |'
- en: '| `iterate` | `::` | `(a -> a) -> a -> [a]` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `iterate` | `::` | `(a -> a) -> a -> [a]` |'
- en: '| `flip` | `::` | `(a -> b -> c) -> b -> a -> c` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `flip` | `::` | `(a -> b -> c) -> b -> a -> c` |'
- en: The Prelude function `map` is a nice example of a higher-order function that
    takes another function as input. The function `map` will apply the function you
    give to every element of the list you give. [Table 6-7](ch06.xhtml#ch6tab7) shows
    some examples of the use of `map`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Prelude 中的`map`函数是一个很好的高阶函数示例，它接受另一个函数作为输入。`map`函数会将你提供的函数应用于你提供的列表中的每个元素。[表
    6-7](ch06.xhtml#ch6tab7)展示了`map`的一些使用示例。
- en: '**Table 6-7:** Examples of the Use of map'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-7：** `map`函数使用示例'
- en: '| **Expression** |  | **Evaluates to** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **计算结果** |'
- en: '| --- | --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `map sqrt [1,4,9]` | ⇝ | `[1.0,2.0,3.0]` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `map sqrt [1,4,9]` | ⇝ | `[1.0,2.0,3.0]` |'
- en: '| `map length ["Four","score","and"]` | ⇝ | `[4,5,3]` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `map length ["Four","score","and"]` | ⇝ | `[4,5,3]` |'
- en: '| `map (logBase 2) [1,64,1024]` | ⇝ | `[0.0,6.0,10.0]` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `map (logBase 2) [1,64,1024]` | ⇝ | `[0.0,6.0,10.0]` |'
- en: '| `map reverse ["Four","score"]` | ⇝ | `["ruoF","erocs"]` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `map reverse ["Four","score"]` | ⇝ | `["ruoF","erocs"]` |'
- en: In the first example listed in [Table 6-7](ch06.xhtml#ch6tab7), we say that
    the function `sqrt` gets “mapped” over the list, meaning that it gets applied
    to each element of the list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 6-7](ch06.xhtml#ch6tab7)中列出的第一个示例中，我们说函数 `sqrt` 被“映射”到列表上，这意味着它会应用于列表中的每个元素。
- en: Note that the parentheses around the function type `a -> b` in the type signature
    for `map` are essential. The type `a -> b -> [a] -> [b]`, in which no parentheses
    appear, is an entirely different type. This latter type would take as input a
    value of type `a`, a value of type `b`, and a list of type `[a]` and produce a
    list of type `[b]` as output. This latter type is short for `a -> (b -> ([a] ->
    [b]))` because arrows associate to the right.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数类型 `a -> b` 在 `map` 的类型签名中的括号是至关重要的。类型 `a -> b -> [a] -> [b]`（其中没有括号）是完全不同的类型。这个类型将输入一个类型为
    `a` 的值，一个类型为 `b` 的值，以及一个类型为 `[a]` 的列表，输出一个类型为 `[b]` 的列表。后者类型是 `a -> (b -> ([a]
    -> [b]))` 的简写，因为箭头是从右向左关联的。
- en: A list comprehension can do the work of `map`. Whether you choose `map` or a
    list comprehension is a matter of style.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导可以完成 `map` 的工作。选择 `map` 还是列表推导，取决于个人风格。
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The idea of mapping a function over a structure actually extends past the structure
    of a list to other structures like trees. Haskell has a function `fmap` for this,
    although we will not have occasion to use it in this book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数映射到结构上的概念实际上不仅限于列表结构，还可以扩展到树等其他结构。Haskell 有一个 `fmap` 函数可以实现这一点，尽管在本书中我们不会使用它。
- en: Iteration and Recursion
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代与递归
- en: Iteration is an essential feature in any programming language. The ability to
    do things over and over again is one of the chief sources of power that computers
    have. How do people express the idea of iteration in a programming language?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代是任何编程语言中的一个基本特性。能够反复执行某些操作是计算机强大功能的主要来源之一。那么人们如何在编程语言中表达迭代的概念呢？
- en: Imperative programming languages provide ways to write *loops*, which are instructions
    to do something over and over, either a fixed number of times or until some condition
    is reached.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程语言提供了编写*循环*的方式，循环指令用于反复执行某些操作，循环的次数可以是固定的，也可以是直到满足某个条件为止。
- en: Functional programming languages have a different way to express iteration.
    The most popular way to achieve iteration among functional programmers is to write
    *recursive functions*, that is, functions that call themselves. Recursive functions
    are very powerful, but it takes a person approaching recursive functions for the
    first time some time and effort to comprehend how to write them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程语言有不同的方式来表达迭代。函数式程序员最常用的迭代方法是编写*递归函数*，即调用自身的函数。递归函数非常强大，但对于初次接触递归函数的人来说，理解如何编写递归函数需要一些时间和精力。
- en: The Haskell Prelude has many built-in recursive functions that we can use without
    needing to write our own explicitly. In this book, we’ll avoid writing *explicitly*
    recursive functions, meaning that you can see from the function definition that
    the function calls itself. We will write functions using the built-in recursive
    functions from the Prelude, and these functions that we write may legitimately
    be called recursive because their behavior is recursive in that something is calling
    itself under the hood. However, the functions we write are not *explicitly* recursive
    because they will not call themselves.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell Prelude 中有许多内建的递归函数，我们可以直接使用，而无需显式编写自己的递归函数。在本书中，我们将避免编写*显式的*递归函数，意味着你可以从函数定义中看出该函数会调用自身。我们将使用
    Prelude 中的内建递归函数编写函数，这些我们编写的函数可以被称为递归的，因为它们的行为是递归的，即在底层某个地方会调用自身。然而，我们编写的函数不是*显式的*递归函数，因为它们不会直接调用自身。
- en: We can understand and explain most of the recursive functions in the Prelude
    by their behavior through examples without needing to understand how they achieve
    this behavior through the power of recursion. Recursion is certainly very interesting,
    and I encourage you to look into it if you have the time. I learned recursion
    from *The Little Schemer* [**[4](bib.xhtml#bib4)**], a book using the Scheme language
    that I enthusiastically recommend. The book *Learn You a Haskell for Great Good!*
    [**[1](bib.xhtml#bib1)**], deals with recursion in its [Chapter 4](ch04.xhtml),
    showing how to write Prelude functions like `take`, `reverse`, `replicate`, and
    `repeat`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过示例来理解和解释 Prelude 中大多数递归函数的行为，而无需了解它们是如何通过递归的力量实现这一行为的。递归确实非常有趣，如果你有时间，我鼓励你深入了解。我从《The
    Little Schemer》一书中学到了递归，推荐这本使用 Scheme 语言的书。[**[4](bib.xhtml#bib4)**]。书籍《Learn
    You a Haskell for Great Good!》[**[1](bib.xhtml#bib1)**]在[第 4 章](ch04.xhtml)中讨论了递归，展示了如何编写像
    `take`、`reverse`、`replicate` 和 `repeat` 这样的 Prelude 函数。
- en: How will we achieve iteration in Haskell without writing explicitly recursive
    functions? We’ll use the Prelude function `iterate`. Rather than thinking imperatively
    about what we want the computer to *do*, we will think functionally about what
    we want to *have* and arrange to have these things in a list. “Lists instead of
    loops” is the functional programming slogan we might apply here.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在 Haskell 中实现迭代，而不写显式的递归函数呢？我们将使用 Prelude 函数`iterate`。我们不会以命令式的方式思考我们希望计算机*做*什么，而是以函数式的方式思考我们希望*拥有*什么，并安排这些内容以列表的形式出现。在这里，我们可以使用“列表代替循环”作为函数式编程的口号。
- en: 'The Prelude function `iterate`, whose type is given in [Table 6-6](ch06.xhtml#ch6tab6),
    is a higher-order function that takes a function as input. Iteration and the `iterate`
    function will be important when we solve Newton’s second law in [Part II](part02.xhtml).
    The function `iterate` produces an infinite list as follows: if `f :: a -> a`
    and `x :: a` (read “`f` has type `a` to `a`” and “`x` has type `a`”), then `iterate
    f x` produces this infinite list:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 'Prelude 函数`iterate`，其类型在[表 6-6](ch06.xhtml#ch6tab6)中给出，是一个高阶函数，接受一个函数作为输入。迭代和`iterate`函数在我们解决[第二部分](part02.xhtml)中的牛顿第二定律时非常重要。函数`iterate`生成一个无限列表，如下所示：如果
    `f :: a -> a` 且 `x :: a`（读作 "`f` 的类型是 `a` 到 `a`" 和 "`x` 的类型是 `a`"），那么`iterate
    f x` 会生成这个无限列表：'
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In other words, the result is a list with `f` applied zero times, once, twice,
    three times, and so on. [Table 6-8](ch06.xhtml#ch6tab8) shows some examples of
    the use of `iterate`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，结果是一个列表，其中 `f` 被应用零次、一次、两次、三次，依此类推。[表 6-8](ch06.xhtml#ch6tab8)展示了 `iterate`
    的一些使用示例。
- en: '**Table 6-8:** Examples of the Use of iterate'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-8：** 使用 iterate 的示例'
- en: '| **Expression** |  | **Evaluates to** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **计算结果** |'
- en: '| --- | --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `iterate (\n -> 2*n) 1` | ⇝ | `[1,2,4,8,...]` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `iterate (\n -> 2*n) 1` | ⇝ | `[1,2,4,8,...]` |'
- en: '| `iterate (\n -> n*n) 1` | ⇝ | `[1,1,1,1,...]` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `iterate (\n -> n*n) 1` | ⇝ | `[1,1,1,1,...]` |'
- en: '| `iterate (\n -> n*n) 2` | ⇝ | `[2,4,16,256,...]` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `iterate (\n -> n*n) 2` | ⇝ | `[2,4,16,256,...]` |'
- en: '| `iterate (\v -> v - 9.8*0.1) 4` | ⇝ | `[4.0,3.02,2.04,1.06,...]` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `iterate (\v -> v - 9.8*0.1) 4` | ⇝ | `[4.0,3.02,2.04,1.06,...]` |'
- en: '[Figure 6-4](ch06.xhtml#ch6fig4) shows how iterate f applies the function f
    to its input zero times, one time, two times, and so on, and collects the results
    in a list.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-4](ch06.xhtml#ch6fig4)展示了 iterate f 如何将函数 f 应用到它的输入零次、一次、两次，依此类推，并将结果收集在一个列表中。'
- en: '![Image](Images/076fig01.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/076fig01.jpg)'
- en: '*Figure 6-4: The function iterate f applies the function f to the input zero,
    one, two, three, and more times and collects the results in an infinite list.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：函数 iterate f 将函数 f 应用到输入的零次、一次、两次、三次及更多次，并将结果收集在一个无限列表中。*'
- en: Anonymous Higher-Order Functions
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匿名高阶函数
- en: In [Chapter 2](ch02.xhtml), we discussed anonymous functions as a way to describe
    a function without giving it a name. We can do the same thing for higher-order
    functions, describing them without giving them a name.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](ch02.xhtml)中，我们讨论了匿名函数，作为描述一个没有名字的函数的方式。我们也可以对高阶函数做同样的事情，不给它们命名，而是直接描述它们。
- en: Let’s return to the function `springForce` discussed earlier. How could we write
    `springForce` without naming it? There are actually two ways to write this function
    as an anonymous function, corresponding to the one-input thinking and two-input
    thinking we described in “How to Think About Functions with Parameters.” In one-input
    thinking, we regard the input to `springForce` as being a number (`R`) and the
    output as being a function `R -> R`. The anonymous function for one-input thinking
    is shown in the first row of [Table 6-9](ch06.xhtml#ch6tab9). We can see from
    the form of that function that it returns a function, namely `\x -> -k*x`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到之前讨论的函数 `springForce`。我们如何在不命名它的情况下编写 `springForce` 呢？实际上，有两种方式可以将此函数编写为匿名函数，对应我们在《如何思考带有参数的函数》中描述的单输入思维和双输入思维。在单输入思维中，我们把
    `springForce` 的输入看作一个数字（`R`），输出则是一个函数 `R -> R`。单输入思维的匿名函数在[表 6-9](ch06.xhtml#ch6tab9)的第一行中显示。从该函数的形式来看，它返回的是一个函数，即
    `\x -> -k*x`。
- en: '**Table 6-9:** Two Ways of Writing the springForce Function as an Anonymous
    Function'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-9：** 以匿名函数形式编写 springForce 函数的两种方式'
- en: '| **Way of thinking** | **Anonymous function** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **思考方式** | **匿名函数** |'
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| One-input thinking | `\k -> \x -> -k*x` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 单输入思维 | `\k -> \x -> -k*x` |'
- en: '| Two-input thinking | `\k x -> -k*x` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 双输入思维 | `\k x -> -k*x` |'
- en: In two-input thinking, we regard the inputs to `springForce` as an `R` for the
    spring constant and a second `R` for the position and the output as being simply
    an `R`. The anonymous function for two-input thinking is shown in the second row
    of [Table 6-9](ch06.xhtml#ch6tab9). The form of the anonymous function shows us
    that it returns a number. Either form is completely legitimate. In fact, the two
    forms describe the same function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在双输入思维中，我们将 `springForce` 的输入视为弹簧常数 `R` 和第二个 `R` 作为位置，输出则是一个简单的 `R`。双输入思维的匿名函数在[表
    6-9](ch06.xhtml#ch6tab9)的第二行中显示。该匿名函数的形式表明它返回的是一个数字。无论哪种形式都是完全合法的，事实上，这两种形式描述的是相同的函数。
- en: Operators as Higher-Order Functions
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运算符作为高阶函数
- en: In [Chapter 1](ch01.xhtml), we introduced several infix operators in [Table
    1-2](ch01.xhtml#ch1tab2). Any infix operator can be converted into a higher-order
    function by enclosing it in parentheses. [Table 6-10](ch06.xhtml#ch6tab10) shows
    examples of how infix operators may be written as higher-order functions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](ch01.xhtml)中，我们介绍了[表 1-2](ch01.xhtml#ch1tab2)中的几个中缀运算符。任何中缀运算符都可以通过将其用括号包围转化为高阶函数。[表
    6-10](ch06.xhtml#ch6tab10)展示了如何将中缀运算符写成高阶函数的例子。
- en: '**Table 6-10:** Infix Operators Transformed into Prefix Functions by Enclosing
    in Parentheses'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-10：** 通过括号包围将中缀运算符转化为前缀函数'
- en: '| **Infix expression** | **Equivalent prefix expression** |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **中缀表达式** | **等效前缀表达式** |'
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `f . g` | `(.) f g` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `f . g` | `(.) f g` |'
- en: '| `''A'':"moral"` | `(:) ''A'' "moral"` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `''A'':"moral"` | `(:) ''A'' "moral"` |'
- en: '| `[3,9] ++ [6,7]` | `(++) [3,9] [6,7]` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `[3,9] ++ [6,7]` | `(++) [3,9] [6,7]` |'
- en: '| `True && False` | `(&&) True False` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `True && False` | `(&&) True False` |'
- en: '| `log . sqrt $ 10` | `($) (log . sqrt) 10` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `log . sqrt $ 10` | `($) (log . sqrt) 10` |'
- en: '[Table 6-11](ch06.xhtml#ch6tab11) shows the types of some higher-order functions
    obtained from operators. If you want to ask GHCi for the type of an operator,
    you must enclose the operator in parentheses when using the GHCi `:t` command.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-11](ch06.xhtml#ch6tab11)展示了通过运算符得到的某些高阶函数类型。如果你想查询一个运算符的类型，必须在使用 GHCi
    的 `:t` 命令时，将运算符用括号括起来。'
- en: '**Table 6-11:** Infix Operators Viewed as Higher-Order Functions'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-11：** 将中缀运算符视为高阶函数'
- en: '| **Function** |  | **Type** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **函数** |  | **类型** |'
- en: '| --- | --- | --- |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `(.)` | `::` | `(b -> c) -> (a -> b) -> a -> c` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `(.)` | `::` | `(b -> c) -> (a -> b) -> a -> c` |'
- en: '| `(:)` | `::` | `a -> [a] -> [a]` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `(:)` | `::` | `a -> [a] -> [a]` |'
- en: '| `(++)` | `::` | `[a] -> [a] -> [a]` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `(++)` | `::` | `[a] -> [a] -> [a]` |'
- en: '| `(&&)` | `::` | `Bool -> Bool -> Bool` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `(&&)` | `::` | `Bool -> Bool -> Bool` |'
- en: '| `(&#124;&#124;)` | `::` | `Bool -> Bool -> Bool` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `(&#124;&#124;)` | `::` | `Bool -> Bool -> Bool` |'
- en: '| `($)` | `::` | `(a -> b) -> a -> b` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `($)` | `::` | `(a -> b) -> a -> b` |'
- en: In [Chapter 5](ch05.xhtml), we discussed a type error that occurred when trying
    to concatenate lists with different types. Now that we know the type of `(++)`,
    we are in a better position to understand type errors more generally. A type error
    comes from trying to apply a function that expects input of one type to an expression
    that actually has a different type. When we apply the concatenation function `(++)`
    to the expression `physicists`,
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.xhtml)中，我们讨论了尝试连接不同类型的列表时发生的类型错误。现在，我们已经知道了`(++)`的类型，更容易一般性地理解类型错误。类型错误来自于尝试将一个期望特定类型输入的函数应用于一个实际上具有不同类型的表达式。当我们将连接函数`(++)`应用于表达式`physicists`时，
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'we obtain a function `(++) physicists`, which has type `[String] -> [String]`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个函数`(++) physicists`，其类型是`[String] -> [String]`：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The concatenation function accepts a list of any type `a`. When given a list
    of strings, the concrete type `String` is substituted for all occurrences of the
    type variable `a` so that the function `(++) physicists` has type `[String] ->
    [String]`. This function `(++) physicists` expects an input with type `[String]`,
    so if we give it something with a different type instead, we get a type error.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 连接函数接受任何类型`a`的列表。当给定一个字符串列表时，具体类型`String`会替代所有出现的类型变量`a`，使得函数`(++) physicists`的类型变为`[String]
    -> [String]`。这个函数`(++) physicists`期望的输入类型是`[String]`，因此如果我们给它一个不同类型的输入，就会得到类型错误。
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In GHCi, we get:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在GHCi中，我们得到：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The “Expected type” `[String]` is the type expected as input by the function
    `(++) physicists`, while the “Actual type” `[R]` is the type of the list `velocities`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: “预期类型”`[String]`是函数`(++) physicists`期望的输入类型，而“实际类型”`[R]`是列表`velocities`的类型。
- en: A class of functions and operators known as *combinators* that can be thought
    of as standard connectors can make it easier to use higher-order functions. We
    turn to these next.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一类被称为*组合子*的函数和运算符，可以被视为标准连接器，它们可以使得使用高阶函数变得更容易。我们接下来将讨论这些。
- en: Combinators
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合子
- en: Combinators, in the broad sense of the term, are functions that combine things.
    They are often functions that have very general applicability, and their types
    show this by being full of type variables. They tend not to be specific to numbers,
    lists, Booleans, or any particular basic type. They are standard plumbing fixtures
    that make it easier to work with and connect higher-order functions. [Table 6-12](ch06.xhtml#ch6tab12)
    gives a short list of Haskell functions that are considered to be combinators.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 组合子，从广义上讲，是将事物组合起来的函数。它们通常是具有非常广泛适用性的函数，且它们的类型通过充满类型变量来展示这一点。它们往往不特定于数字、列表、布尔值或任何特定的基本类型。它们是标准的连接组件，使得处理和连接高阶函数变得更容易。[表
    6-12](ch06.xhtml#ch6tab12)列出了一些被认为是组合子的 Haskell 函数。
- en: '**Table 6-12:** Some Haskell Functions Regarded as Combinators'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-12：** 一些被认为是组合子的 Haskell 函数'
- en: '| **Function** |  | **Type** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **函数** |  | **类型** |'
- en: '| --- | --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `id` | `::` | `a -> a` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `id` | `::` | `a -> a` |'
- en: '| `const` | `::` | `a -> b -> a` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `const` | `::` | `a -> b -> a` |'
- en: '| `flip` | `::` | `(a -> b -> c) -> b -> a -> c` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `flip` | `::` | `(a -> b -> c) -> b -> a -> c` |'
- en: '| `(.)` | `::` | `(b -> c) -> (a -> b) -> a -> c` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `(.)` | `::` | `(b -> c) -> (a -> b) -> a -> c` |'
- en: '| `($)` | `::` | `(a -> b) -> a -> b` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `($)` | `::` | `(a -> b) -> a -> b` |'
- en: The identity function `id` seems at first to be a silly function, because when
    I apply it to some value, I get that same value back. So what purpose does the
    identity function serve? The relevance of the identity function, like the anonymous
    functions we studied in [Chapter 2](ch02.xhtml), lies in its use as an input to
    a higher-order function. In [Chapter 22](ch22.xhtml), we will write a higher-order
    function to display vector fields. One of the inputs to this function will be
    a scaling function that accepts one number and returns another. The most trivial
    scaling is achieved by using the identity function, which leaves every input unchanged.
    The higher-order function requires *some* scaling function to be given, and the
    identity function `id` can be given when no scaling is desired.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 身份函数`id`乍一看似乎是一个无意义的函数，因为当我将其应用于某个值时，我得到的还是那个值。那么，身份函数有什么用呢？身份函数的意义，就像我们在[第2章](ch02.xhtml)中研究的匿名函数一样，体现在它作为高阶函数的输入。在[第22章](ch22.xhtml)中，我们将编写一个高阶函数来展示向量场。该函数的一个输入将是一个接受一个数字并返回另一个数字的缩放函数。最简单的缩放可以通过使用身份函数实现，它不改变任何输入。高阶函数要求提供*某种*缩放函数，当不需要缩放时，可以提供身份函数`id`。
- en: The combinator `const` turns a value into a constant function that returns that
    value. For example, `const 3` is the function that returns `3` regardless of its
    input. So, `const 3 7` evaluates to `3`, `const 3 5` evaluates to `3`, and `const
    3 "Hi"` evaluates to `3`. In [Chapter 14](ch14.xhtml), we will write a function
    to solve mechanics problems that takes a list of forces as input. The forces are
    functions that depend on inputs like velocity, so if we want to specify a constant
    force, we can use the `const` combinator. In [Chapter 23](ch23.xhtml), we will
    write surfaces like hemispheres and spheres. Our surfaces will be specified with
    two parameters that take values over some range. The limits for the parameters
    are allowed to be functions, so we can write, for example, a triangular surface.
    If we want a constant function, again we can use `const`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`组合子将一个值转化为一个常量函数，该函数返回该值。例如，`const 3`是一个无论输入是什么都会返回`3`的函数。所以，`const
    3 7`的结果是`3`，`const 3 5`的结果是`3`，`const 3 "Hi"`的结果也是`3`。在[第14章](ch14.xhtml)中，我们将编写一个函数来解决力学问题，该函数接受一个力的列表作为输入。力是依赖于速度等输入的函数，因此，如果我们想指定一个常量力，可以使用`const`组合子。在[第23章](ch23.xhtml)中，我们将编写半球体和球体等表面。我们的表面将通过两个参数来指定，这些参数的取值范围可以是函数，因此我们可以写出例如一个三角形表面。如果我们想要一个常量函数，再次可以使用`const`。'
- en: 'The `flip` combinator takes a higher-order function and exchanges the positions
    of its inputs. It is often used in conjunction with point-free style. For example,
    the exponentiation function `(**)` takes two inputs: the base and the exponent.
    If we provide the first input but not the second, as in `(**) 2`, we get the “two
    to the power of” function. What if we want the function that cubes its input?
    We would need to fix the second input of `(**)` at `3` while leaving the first
    open to be the input to the cubing function. We could do this with an anonymous
    function, as `\x -> x ** 3`. We could also do it with flip, as `flip (**) 3`.
    Either of these is an expression for the cubing function.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`flip`组合子接受一个高阶函数，并交换其输入的位置。它通常与点自由风格一起使用。例如，指数函数`(**)`接受两个输入：底数和指数。如果我们提供第一个输入而不提供第二个输入，如`(**)
    2`，我们得到“二的幂”函数。假设我们想要一个将输入值立方的函数，我们需要将`(**)`的第二个输入固定为`3`，同时将第一个输入留空，作为立方函数的输入。我们可以用匿名函数`
    \x -> x ** 3`来实现这一点，也可以使用`flip`，如`flip (**) 3`。这两种方式都是立方函数的表达式。'
- en: The composition combinator was listed in [Table 1-2](ch01.xhtml#ch1tab2) and
    discussed in [Chapter 2](ch02.xhtml). We will use it in [Chapter 16](ch16.xhtml)
    when we solve mechanics problems by passing information through a sequence of
    functions. The full solution is given as a composition of the functions in the
    sequence.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 组合子`composition`已在[表1-2](ch01.xhtml#ch1tab2)中列出，并在[第2章](ch02.xhtml)中讨论过。我们将在[第16章](ch16.xhtml)中使用它来通过一系列函数传递信息来解决力学问题。最终的解决方案是将这些函数按顺序组合起来的结果。
- en: The function application combinator was listed in [Table 1-2](ch01.xhtml#ch1tab2)
    and discussed in [Chapter 1](ch01.xhtml) . It seems like a silly and useless operator
    until we realize that its precedence allows it to act like parentheses.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应用组合子已在[表1-2](ch01.xhtml#ch1tab2)中列出，并在[第1章](ch01.xhtml)中讨论过。它看起来是一个无用的操作符，直到我们意识到它的优先级允许它像括号一样作用。
- en: The next section discusses a class of higher-order functions used to classify
    data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节讨论了一类用于分类数据的高阶函数。
- en: Predicate-Based Higher-Order Functions
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于谓词的高阶函数
- en: A *predicate* is a function with type `a -> Bool`, where `a` is any valid Haskell
    type. (For example, `a` could be a concrete type like `Int` or `R -> R`, a type
    variable like `a`, or a type that contains type variables like `[a]` or even `a
    -> [b]`.) A predicate expresses a property that an element of type `a` may or
    may not have. For example, the property of an integer being greater than or equal
    to 7 is a predicate. We can define such a predicate in Haskell.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*谓词*是一个类型为`a -> Bool`的函数，其中`a`是任何有效的 Haskell 类型。（例如，`a`可以是像`Int`或`R -> R`这样的具体类型，也可以是像`a`这样的类型变量，或者是包含类型变量的类型，如`[a]`，甚至是`a
    -> [b]`。）谓词表达了类型`a`的元素可能具有或不具有的某个属性。例如，整数大于或等于7的属性就是一个谓词。我们可以在 Haskell 中定义这样的谓词。'
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Table 6-13](ch06.xhtml#ch6tab13) shows a few higher-order functions that take
    a predicate as the first argument.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[表6-13](ch06.xhtml#ch6tab13)展示了几个将谓词作为第一个参数的高阶函数。'
- en: '**Table 6-13:** Some Predicate-Based Higher-Order Functions from the Prelude'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-13：** 一些基于谓词的高阶函数来自Prelude'
- en: '| **Function** |  | **Type** |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| **函数** |  | **类型** |'
- en: '| --- | --- | --- |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `filter` | `::` | `(a -> Bool) -> [a] -> [a]` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `filter` | `::` | `(a -> Bool) -> [a] -> [a]` |'
- en: '| `takeWhile` | `::` | `(a -> Bool) -> [a] -> [a]` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `takeWhile` | `::` | `(a -> Bool) -> [a] -> [a]` |'
- en: '| `dropWhile` | `::` | `(a -> Bool) -> [a] -> [a]` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `dropWhile` | `::` | `(a -> Bool) -> [a] -> [a]` |'
- en: 'Let’s examine the use of these functions. Suppose we define the following “less
    than 10” predicate:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些函数的使用。假设我们定义了以下的“小于 10”谓词：
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Table 6-14](ch06.xhtml#ch6tab14) shows examples of how to use the higher-order
    functions in [Table 6-13](ch06.xhtml#ch6tab13).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[表6-14](ch06.xhtml#ch6tab14) 显示了如何使用[表6-13](ch06.xhtml#ch6tab13)中的高阶函数的示例。'
- en: '**Table 6-14:** Examples of the Use of Some Predicate-Based Higher-Order Functions'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-14：** 一些基于谓词的高阶函数的使用示例'
- en: '| **Expression** |  | **Evaluates to** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **计算结果** |'
- en: '| --- | --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `filter lt10 [6,4,8,13,7]` | ⇝ | `[6,4,8,7]` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `filter lt10 [6,4,8,13,7]` | ⇝ | `[6,4,8,7]` |'
- en: '| `takeWhile lt10 [6,4,8,13,7]` | ⇝ | `[6,4,8]` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `takeWhile lt10 [6,4,8,13,7]` | ⇝ | `[6,4,8]` |'
- en: '| `dropWhile lt10 [6,4,8,13,7]` | ⇝ | `[13,7]` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `dropWhile lt10 [6,4,8,13,7]` | ⇝ | `[13,7]` |'
- en: '| `any lt10 [6,4,8,13,7]` | ⇝ | `True` |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `any lt10 [6,4,8,13,7]` | ⇝ | `True` |'
- en: '| `all lt10 [6,4,8,13,7]` | ⇝ | `False` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `all lt10 [6,4,8,13,7]` | ⇝ | `False` |'
- en: Let’s go through the functions in this table. The `filter` function returns
    all elements in a list that satisfy the predicate, regardless of where they occur
    in the list. The `takeWhile` function returns elements of a list that satisfy
    the predicate *until* it finds one that fails to satisfy the predicate, and it
    returns the initial list of satisfying elements. Elements in the input list that
    occur after the first non-satisfying element are not even considered for inclusion
    in the result list. The `dropWhile` function returns a list that begins with the
    first non-satisfying element of the input list and includes every element from
    that point on, regardless of whether it satisfies the predicate. The `any` function
    returns `True` if one or more elements of the input list satisfy the predicate
    and returns `False` otherwise. The `all` function returns `True` if all elements
    of the input list satisfy the predicate, and it returns `False` otherwise.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一讲解表格中的函数。`filter` 函数返回列表中所有满足谓词的元素，无论它们在列表中的位置如何。`takeWhile` 函数返回满足谓词的元素，*直到*它找到一个不满足谓词的元素为止，并返回满足谓词的元素的初始列表。在输入列表中，第一次遇到不满足谓词的元素之后的元素将不会被考虑在结果列表中。`dropWhile`
    函数返回一个列表，该列表从输入列表中的第一个不满足谓词的元素开始，并包含从该点起的每个元素，无论它是否满足谓词。`any` 函数如果输入列表中有一个或多个元素满足谓词，则返回
    `True`，否则返回 `False`。`all` 函数如果输入列表中的所有元素都满足谓词，则返回 `True`，否则返回 `False`。
- en: A list comprehension can also do the work of `filter`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导也可以完成 `filter` 的工作。
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To filter a list using a list comprehension, include a Boolean expression (`x
    < 10` in the example above) after a comma on the right side of the list comprehension.
    Such an expression is called a *guard*. Only terms that satisfy the Boolean guard
    will be included in the resulting list.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用列表推导来过滤列表，可以在列表推导的右侧的逗号后面包含一个布尔表达式（例如上面的 `x < 10`）。这样的表达式被称为 *guard*（保护条件）。只有满足该布尔保护条件的项才会被包括在结果列表中。
- en: Numerical Integration
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值积分
- en: Acceleration is the rate at which velocity changes. If we know how velocity
    depends on time, we can use a derivative to find acceleration, as we did in [Chapter
    4](ch04.xhtml). What about the converse problem? What if we know how acceleration
    depends on time and we want to know velocity? This is the purpose of integration
    in calculus. Integrating is the opposite of differentiating (or taking the derivative);
    this claim is the content of the fundamental theorem of calculus.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度是速度变化的速率。如果我们知道速度如何依赖于时间，我们可以使用导数来求得加速度，就像我们在[第4章](ch04.xhtml)中做的那样。那么反过来怎么办呢？如果我们知道加速度如何依赖于时间，并且我们想知道速度，应该怎么做呢？这正是微积分中积分的目的。积分是求导的逆操作；这个命题是微积分基本定理的内容。
- en: Introducing Integrators
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 引入积分器
- en: If *a*(*t*) is the acceleration of an object at time *t*, the velocity *v*(*t*)
    of the object can be found by integrating
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *a*(*t*) 是物体在时间 *t* 时的加速度，物体的速度 *v*(*t*) 可以通过积分来求得：
- en: '![Image](Images/081equ01.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/081equ01.jpg)'
- en: where *v*(0) is the velocity of the object at time 0.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *v*(0) 是物体在时间 0 时的速度。
- en: If we are integrating and the variable of integration is time, we can imagine
    a device that takes as input the value of acceleration at time *t* and produces
    as output the value of velocity at time *t*. Let’s call such a device an *integrator*,
    and we can picture it as in [Figure 6-5](ch06.xhtml#ch6fig5).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在进行积分，并且积分变量是时间，我们可以想象一个设备，它以时间*t*的加速度值为输入，输出时间*t*的速度值。我们可以将这样的设备称为*积分器*，并可以像在[图6-5](ch06.xhtml#ch6fig5)中所示那样进行想象。
- en: '![Image](Images/081fig01.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/081fig01.jpg)'
- en: '*Figure 6-5: An integrator is continuous and stateful. The continuously changing
    output at the right depends on the continuously changing input at the left in
    addition to some stored state.*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：积分器是连续的且有状态的。右侧持续变化的输出依赖于左侧持续变化的输入以及某些存储的状态。*'
- en: The input to the integrator describes the rate at which the output is to change.
    For example, the input could be the volume flow rate of water from a faucet into
    a tub in gallons per minute. The output is the volume of water in the tub in gallons.
    Or the input could be the current flowing into a capacitor, and the output the
    charge on a capacitor plate. The current flowing into the capacitor describes
    the rate at which charge is deposited on the capacitor plate. [Table 6-15](ch06.xhtml#ch6tab15)
    shows some physical quantities related by integration.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 积分器的输入描述了输出变化的速率。例如，输入可以是水龙头向水箱中流入的水流量（以加仑/分钟为单位）。输出是水箱中的水量（以加仑为单位）。或者，输入可以是流入电容器的电流，输出则是电容器板上的电荷。流入电容器的电流描述了电荷在电容器板上积累的速率。[表6-15](ch06.xhtml#ch6tab15)展示了通过积分关联的物理量。
- en: '**Table 6-15:** Physical Quantities Related by Integration'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-15：** 通过积分关联的物理量'
- en: '| **Input to integrator** | **Output of integrator** |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **积分器的输入** | **积分器的输出** |'
- en: '| --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Acceleration | Velocity |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 加速度 | 速度 |'
- en: '| Velocity | Position |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 速度 | 位置 |'
- en: '| Flow rate | Volume |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 流量 | 体积 |'
- en: '| Capacitor current | Capacitor charge |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 电容器电流 | 电容器电荷 |'
- en: The integrator is continuous and stateful. By *continuous*, I mean that the
    input is ever-present and the output is continuously changing. *Stateful* means
    that the integrator must maintain some internal information; that is, the output
    is not a pure function of the input. For the integrator to output the volume of
    water in the tub from the flow rate, it needs to maintain a value of the volume
    that will be updated by the flow rate. Similarly, for the integrator to output
    the charge on the capacitor from the current, it needs to maintain a value of
    the charge that will be updated by the input current.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 积分器是连续的和有状态的。这里的*连续*是指输入始终存在，输出持续变化。*有状态*意味着积分器必须保持一些内部信息；也就是说，输出不是输入的纯函数。为了让积分器根据流量输出水箱中的水量，它需要保持一个水量的数值，并且这个数值会根据流量不断更新。类似地，为了让积分器根据电流输出电容器的电荷量，它需要保持一个电荷值，并且这个值会根据输入电流不断更新。
- en: Digital Integration
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数字积分
- en: We’d like to be able to teach Haskell how to integrate. Unfortunately, while
    nature supplies us with many good candidates for integrators, digital computation
    does not. The integrator is an analog continuous device. To model the integrator,
    we switch from continuous to discrete and work in time steps that are smaller
    than any time scales of interest in our problem.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够教Haskell进行积分。不幸的是，虽然自然界提供了许多适合做积分器的好例子，但数字计算却没有。积分器是一个模拟的连续设备。为了建模积分器，我们将从连续转为离散，并在小于我们问题中任何时间尺度的时间步长下进行工作。
- en: '[Figure 6-6](ch06.xhtml#ch6fig6) shows how we can model an integrator.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-6](ch06.xhtml#ch6fig6)展示了我们如何建模一个积分器。'
- en: '![Image](Images/082fig01.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/082fig01.jpg)'
- en: '*Figure 6-6: Model of an integrator that is discrete and stateful*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：离散且有状态的积分器模型*'
- en: The model is intended to be used in a discrete way. At instants of time separated
    by Δ*t*, we sample the input, multiply it by Δ*t*, and then add it to the current
    value of the output to produce a new output. If Δ*t* is small compared with time
    scales on which the input changes, this discrete model will emulate the continuous
    integrator very well.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型旨在以离散方式使用。在由Δ*t*隔开的时间瞬间，我们对输入进行采样，将其乘以Δ*t*，然后将结果加到当前输出值中以生成新的输出。如果Δ*t*相对于输入变化的时间尺度非常小，这个离散模型将能够很好地模拟连续积分器。
- en: The model in [Figure 6-6](ch06.xhtml#ch6fig6) forms the basis for a method of
    numerical integration. To integrate a function, choose a small time step Δ*t*,
    sample the values the function produces at discrete times, multiply each function
    output by Δ*t*, and sum the results.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-6](ch06.xhtml#ch6fig6)中的模型构成了数值积分方法的基础。为了积分一个函数，选择一个小的时间步长Δ*t*，在离散时间点上采样函数的值，将每个函数输出乘以Δ*t*，然后将结果求和。'
- en: If we unwrap the stateful integrator in [Figure 6-6](ch06.xhtml#ch6fig6), we
    obtain the state-free integrator in [Figure 6-7](ch06.xhtml#ch6fig7), which is
    shown for the case in which we are integrating acceleration to obtain velocity.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们展开[图6-6](ch06.xhtml#ch6fig6)中的有状态积分器，就会得到[图6-7](ch06.xhtml#ch6fig7)中的无状态积分器，如图所示，这里我们是通过积分加速度来得到速度。
- en: '![Image](Images/083fig01.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/083fig01.jpg)'
- en: '*Figure 6-7: A functional model of an integrator that is discrete and state
    free. This integrator uses the midpoint rule.*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-7：一个离散且无状态的积分器的功能模型。这个积分器使用中点法则。*'
- en: All of the rectangles are purely functional operations (addition and multiplication);
    the state contained in the circular integrator now exists only in the wires between
    pure functions. To approximate the velocity at time Δ*t*, we sample the acceleration
    at time Δ*t*/2, multiply it by Δ*t*, and add that to the velocity at time 0\.
    Sampling at Δ*t*/2 is called the *midpoint rule* for numerical integration. If
    Δ*t* is small compared with the important time scales for the situation, we will
    get a good approximation from this method. [Figure 6-7](ch06.xhtml#ch6fig7) shows
    four samples of the acceleration function; usually we will ask the computer to
    do many more.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的矩形都是纯粹的功能性操作（加法和乘法）；现在，圆形积分器中包含的状态仅存在于纯函数之间的线路中。为了逼近在时间Δ*t*时的速度，我们在时间Δ*t*/2时采样加速度，将其乘以Δ*t*，然后将结果加到时间0时的速度上。时间Δ*t*/2的采样被称为数值积分的*中点法则*。如果Δ*t*相较于该情境下的重要时间尺度很小，那么我们可以从这种方法中获得一个良好的近似值。[图6-7](ch06.xhtml#ch6fig7)展示了加速度函数的四个样本；通常我们会要求计算机做更多的采样。
- en: 'What we would like to be able to do is to give the computer a function *f*,
    give the computer limits *a* and *b*, and ask it to compute the number:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够做的是，给计算机一个函数*f*，给计算机提供上下限*a*和*b*，然后让它计算这个数字：
- en: '![Image](Images/083equ01.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/083equ01.jpg)'
- en: Viewed in this way, `Integration` is a function that takes a function `R ->
    R` as input, along with two limits, and gives a number as output.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，`Integration`是一个接受一个函数`R -> R`作为输入，并接受两个上下限，最终输出一个数字的函数。
- en: '[PRE16]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Integration is often thought of as finding the area under the curve. The midpoint
    rule for numerical integration samples the function at the midpoint of each interval
    of the independent variable, as shown in [Figure 6-8](ch06.xhtml#ch6fig8).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 积分通常被认为是求曲线下的面积。数值积分的中点法则在自变量的每个区间的中点处对函数进行采样，如[图6-8](ch06.xhtml#ch6fig8)所示。
- en: '![Image](Images/084equ01.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/084equ01.jpg)'
- en: '*Figure 6-8: Numerical integration using the midpoint rule,* Δ*t = 0.5*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-8：使用中点法则的数值积分，* Δ*t = 0.5*'
- en: 'Here is the Haskell code for a numerical integrator that uses the midpoint
    rule:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用中点法则的数值积分器的Haskell代码：
- en: '[PRE17]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first argument to the function is a step size to use for the numerical integration.
    We have been speaking as though the independent variable is time, but in mathematics
    it could be anything. The second argument to `integral` is the function to be
    integrated. Note how we use a single identifier (`f`) to name the function that
    the user of `integral` passes in. Also, we don’t need to define the function `f`;
    what we are doing here is *naming* the function that the user of `integral` is
    sending in.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给函数的第一个参数是用于数值积分的步长。我们之前假设自变量是时间，但在数学中它可以是任何东西。`integral`函数的第二个参数是需要积分的函数。注意，我们使用单一标识符（`f`）来命名传递给`integral`的函数。此外，我们不需要定义函数`f`；我们在这里做的是*命名*用户传递给`integral`的函数。
- en: We use an arithmetic sequence to specify the times at which we want to sample
    the function. We use a list comprehension to give back a list of the same size
    that contains the products of the values the function returns with the step size.
    These products are the areas of the rectangles in [Figure 6-8](ch06.xhtml#ch6fig8).
    All that remains is to add up these areas with the `sum` function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用算术序列来指定采样函数的时间点。我们使用列表推导式返回一个相同大小的列表，包含函数返回值与步长的乘积。这些乘积就是[图6-8](ch06.xhtml#ch6fig8)中矩形的面积。剩下的就是使用`sum`函数将这些面积加起来。
- en: Let’s test out our integral function.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下我们的积分函数。
- en: '[PRE18]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here we use an anonymous function to specify the function that squares its
    input because it’s easier than writing a function definition to name that function.
    In [Chapter 2](ch02.xhtml), we mentioned that anonymous functions would be useful
    as inputs to higher-order functions, and now we see an example of that. The exact
    value of this definite integral is 1/3, as shown here:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用匿名函数来指定一个将输入平方的函数，因为它比写一个函数定义来命名该函数更方便。在[第二章](ch02.xhtml)中，我们提到过匿名函数将在作为高阶函数的输入时非常有用，现在我们看到一个实例。这个定积分的确切值是1/3，如此处所示：
- en: '![Image](Images/085equ01.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/085equ01.jpg)'
- en: Implementing Antiderivatives
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现反导数
- en: The type synonym `Integration` corresponds to the idea of a definite integral,
    where one has a function and two limits and expects to get a number as output,
    as in Expression 6.2\. However, there is a second way of thinking about integration
    in which one integrates a function to obtain another function. In Equation 6.1,
    for example, we integrate an acceleration function to obtain a velocity function.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 类型同义词`Integration`对应于定积分的概念，其中有一个函数和两个极限，并且期望得到一个数字作为输出，正如在表达式6.2中所示。然而，还有第二种思考积分的方式，即将一个函数积分得到另一个函数。例如，在方程6.1中，我们将加速度函数积分得到速度函数。
- en: In calculus, a distinction is often made between a definite integral on one
    hand and an indefinite integral, or *antiderivative*, on the other. The antiderivative
    wants to be the inverse function to the derivative, but there is a catch, because
    functions like `sin` and `\x -> sin x + 7` have the same derivative, namely `cos`.
    Thus, the derivative, as a higher-order function from functions to functions,
    does not have a well-defined inverse function. An antiderivative of a function
    *f* is any function *F* whose derivative is *f* . In other words, *F* is an antiderivative
    of *f* exactly when *DF* = *f*. If *F* is an antiderivative of *f*, we write
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在微积分中，通常会区分定积分和不定积分，或者称为*反导数*。反导数想要成为导数的反函数，但这里有一个问题，因为像`sin`和`\x -> sin x +
    7`这样的函数具有相同的导数，即`cos`。因此，导数作为从函数到函数的高阶函数，并没有一个明确的反函数。一个函数*f*的反导数是任何一个其导数为*f*的函数*F*。换句话说，当*DF*
    = *f*时，*F*是*f*的反导数。如果*F*是*f*的反导数，我们写作
- en: '![Image](Images/085equ02.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/085equ02.jpg)'
- en: using the indefinite integral symbol without limits and the constant of integration
    *C*. For example, we write
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用没有限制的积分符号和积分常数*C*。例如，我们写作
- en: '![Image](Images/085equ03.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/085equ03.jpg)'
- en: where *C* is an undetermined constant of integration. There is a relationship
    between a definite integral and an indefinite integral. The fundamental theorem
    of calculus claims that if *F* is any antiderivative of *f*, then
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*C*是一个未确定的积分常数。定积分与不定积分之间存在关系。微积分的基本定理声称，如果*F*是*f*的任何一个反导数，那么
- en: '![Image](Images/085equ04.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/085equ04.jpg)'
- en: Renaming variables and rearranging terms, we obtain an expression that allows
    us to relate the constant of integration to an initial value of *F*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重命名变量和重新排列项，我们得到一个表达式，使我们能够将积分常数与*F*的初始值相关联。
- en: '![Image](Images/085equ05.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/085equ05.jpg)'
- en: For any real number *a*, an antiderivative *F* is a function whose value *F*(*x*)
    at *x* is the sum of its “initial” value *F*(*a*) at *a* and the definite integral
    of *f* from *a* to *x*. If we associate the indefinite integral *∫ f* (*x*)*dx*
    of Equation 6.3 with the definite integral ![Image](Images/e0085-06.jpg) of Equation
    6.4, we can associate the initial value *F*(*a*) in Equation 6.4 with – *C*, where
    *C* is the constant of integration in Equation 6.3\. In this sense, constants
    of integration are related to initial values.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何实数*a*，反导数*F*是一个函数，其值*F*(*x*)在*x*处是它在*a*处的“初始”值*F*(*a*)和*f*从*a*到*x*的定积分之和。如果我们将方程6.3中的不定积分*∫
    f* (*x*)*dx*与方程6.4中的定积分![Image](Images/e0085-06.jpg)关联起来，我们可以将方程6.4中的初始值*F*(*a*)与–*C*相关联，其中*C*是方程6.3中的积分常数。从这个意义上讲，积分常数与初始值是相关的。
- en: 'A typical function has many functions that can serve as its antiderivative.
    How can we select one function in particular? There are two ways: we can specify
    a lower limit or we can specify an initial value. Specifying a lower limit corresponds
    to the definite integral `Integration` that we explored earlier. Specifying an
    initial value leads to the `AntiDerivative` we explore below.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的函数有很多可以作为其反导数的函数。我们如何选择其中一个特定的函数呢？有两种方法：我们可以指定一个下限，或者指定一个初始值。指定下限对应于我们之前探索的定积分`Integration`，指定初始值则导致我们下面要探讨的`AntiDerivative`。
- en: Let’s call an antiderivative a function that takes an initial value (such as
    *v*(0) in Equation 6.1) and a function (such as *a*) and returns a function (such
    as *v*).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称反导数为一个函数，它接受一个初始值（例如方程式6.1中的*v*(0)）和一个函数（例如*a*），并返回一个函数（例如*v*）。
- en: '[PRE19]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The idea of the antiderivative is closely related to the idea of the integral.
    We can define a function `antiDerivative` in terms of the `integral` we have already
    defined.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 反导数的概念与积分的概念密切相关。我们可以通过我们已经定义的`integral`来定义一个`antiDerivative`函数。
- en: '[PRE20]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Chapter 4](ch04.xhtml) showed how to implement Equations 4.5 and 4.12 as the
    functions `velFromPos` and `accFromVel`. Now let’s implement Equation 6.1 in Haskell.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](ch04.xhtml)展示了如何将方程式4.5和4.12实现为`velFromPos`和`accFromVel`函数。现在让我们在Haskell中实现方程式6.1。'
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We see that finding a velocity function from an acceleration function is nothing
    other than the antiderivative.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，从加速度函数中求得速度函数其实就是反导数。
- en: How about finding a position function from a velocity function?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从速度函数中求得位置函数怎么样？
- en: '![Image](Images/086equ01.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/086equ01.jpg)'
- en: 'In Haskell, this is:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中，这样表示：
- en: '[PRE22]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Again, nothing but the antiderivative. Here we use point-free style to show
    an alternative way of writing the function and to emphasize the equality of the
    two functions. The functions `velFromAcc` and `posFromVel` from earlier are the
    same, and each is the same as `antiDerivative`. Both integrate a given function
    from 0 to *t* and add on an initial value.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然是反导数。这里我们使用无点风格来展示另一种编写函数的方式，并强调这两个函数的等价性。之前的`velFromAcc`和`posFromVel`函数是相同的，每一个都等同于`antiDerivative`。它们都从0到*t*对给定函数进行积分，并加上初始值。
- en: Type synonyms show that time, velocity, and acceleration are all treated as
    numbers.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 类型同义词表明时间、速度和加速度都被视为数字。
- en: '[PRE23]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Perhaps you’d rather provide your numerical integrator with the number of steps
    to take from the lower limit to the upper limit rather than the step size. This
    is not hard to do.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你宁愿为你的数值积分器提供从下限到上限的步数，而不是步长。这并不难实现。
- en: '[PRE24]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `let` keyword introduces local variables and/or functions that can be used
    in the body after the `in` keyword. The variable dt is a local variable defined
    inside the function `integralN`. This dt is not visible outside of the definition
    of integralN. Any dt we use outside of this function has an independent meaning
    separate from this. Local variables are particularly useful to define if they
    are used more than once in the remainder of the definition. In this case, we use
    `dt` only once, so we could have inserted the definition of `dt` directly in the
    final line.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`关键字引入了局部变量和/或函数，这些变量和函数可以在`in`关键字之后的主体中使用。变量`dt`是一个局部变量，在函数`integralN`内部定义。这个`dt`在`integralN`的定义外部不可见。我们在函数外部使用的任何`dt`都有一个独立的意义，和这个函数内部的`dt`不同。局部变量尤其在它们在定义的其余部分中使用多次时非常有用。在这种情况下，我们只使用一次`dt`，因此我们本可以直接在最后一行插入`dt`的定义。'
- en: '[PRE25]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using the local variable `dt` saves us a set of parentheses and makes the code
    easier to read because the name `dt` has meaning to us as a step size. I encourage
    you to define local variables with `let` whenever you can think of a name that
    has meaning. It will help readers of the code, including the writer.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用局部变量`dt`节省了一组括号，并且使代码更易于阅读，因为`dt`这个名字在我们看来是有意义的，表示步长。每当你能想到有意义的名字时，我鼓励你使用`let`定义局部变量。这将有助于代码的读者，包括编写者。
- en: The division operator (`/`) can be used only between numbers of the same type.
    Since `b - a` has type `R` and `n` has type `Int`, we can’t directly divide one
    by the other. The solution is to transform `n` into something with type `R`, and
    `fromIntegral` does the trick.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 除法运算符（`/`）只能在相同类型的数字之间使用。由于`b - a`的类型是`R`而`n`的类型是`Int`，我们不能直接进行除法运算。解决方法是将`n`转换为`R`类型，`fromIntegral`可以完成这个转换。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: A higher-order function takes another function as input and/or produces a function
    as output. Higher-order functions that produce functions as output can be thought
    of as taking multiple inputs. Numerical integration is a key example of a higher-order
    function that takes a function as input. The lambda notation for writing anonymous
    functions can be used for higher-order functions as well. Mapping a function over
    a list is an example of a higher-order function that takes another function as
    input and is similar to a list comprehension. We can make binary infix operators
    into higher-order functions by enclosing them in parentheses. Haskell can achieve
    iteration via the higher-order function `iterate`, which takes a function and
    a starting value and repeatedly applies the function to form an infinite list.
    Some higher-order functions, such as `filter`, take a predicate as input. We can
    also achieve filtering through list comprehensions. In the next chapter, we introduce
    a library that allows us to plot functions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数接受另一个函数作为输入和/或产生一个函数作为输出。产生函数作为输出的高阶函数可以看作是接受多个输入的函数。数值积分是一个典型的高阶函数示例，它接受一个函数作为输入。用于编写匿名函数的λ符号也可以用于高阶函数。将一个函数映射到一个列表上是一个高阶函数的例子，它接受另一个函数作为输入，并且类似于列表推导。我们可以通过将二元中缀操作符括起来，来将其转化为高阶函数。Haskell通过高阶函数`iterate`实现迭代，该函数接受一个函数和一个起始值，并重复应用该函数来生成一个无限列表。一些高阶函数，如`filter`，接受一个谓词作为输入。我们也可以通过列表推导来实现过滤功能。在下一章中，我们将介绍一个允许我们绘制函数的库。
- en: Exercises
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习题
- en: '**Exercise 6.1.** Let us return to the example of throwing a rock straight
    upward. Perhaps we don’t want to throw it upward at 30 m/s but would like to be
    able to throw it upward with whatever initial velocity we choose. Write a function'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 6.1.** 让我们回到投掷石块向上的例子。也许我们不希望以30米每秒的速度向上投掷，而是希望能够根据我们选择的初速度投掷。编写一个函数'
- en: '[PRE26]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: that takes as input an initial velocity and returns as output a function that
    takes as input a time and returns as output a height. Also, write a function
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个初速度作为输入，并返回一个以时间为输入、高度为输出的函数。同时，编写一个函数
- en: '[PRE27]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: that takes as input an initial velocity and returns as output a function that
    takes as input a time and returns as output a velocity.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个初速度作为输入，并返回一个以时间为输入、速度为输出的函数。
- en: '**Exercise 6.2.** Give the type of `take 4`.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 6.2.** 给出`take 4`的类型。'
- en: '**Exercise 6.3.** The function `map` has type `(a -> b) -> [a] -> [b]`. This
    means that `map` is expecting a function with type `a -> b` as its first argument.
    The function `not` has type `Bool -> Bool`. Can `not` be the first argument to
    `map`? If so, what is the type of `map not`? Show how, starting from the types
    of `map` and `not`, you can figure out the type of `map not`.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 6.3.** 函数`map`的类型是`(a -> b) -> [a] -> [b]`。这意味着`map`期望第一个参数是类型为`a -> b`的函数。函数`not`的类型是`Bool
    -> Bool`。`not`能作为`map`的第一个参数吗？如果可以，`map not`的类型是什么？请展示如何从`map`和`not`的类型出发，推导出`map
    not`的类型。'
- en: '**Exercise 6.4.** Write a function'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 6.4.** 编写一个函数'
- en: '[PRE28]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'that does the same thing as `greaterThanOrEq7` but doesn’t use an `if-then-else`
    construction. (Hint: look at the function `lt10`.)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 它完成与`greaterThanOrEq7`相同的功能，但不使用`if-then-else`结构。（提示：查看函数`lt10`。）
- en: '**Exercise 6.5.** Write a function with type `Int -> String -> Bool` and describe
    in words what it does.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 6.5.** 编写一个类型为`Int -> String -> Bool`的函数，并用文字描述它的功能。'
- en: '**Exercise 6.6.** Write a predicate expressing the property “has more than
    six elements” that takes a list as input. Include a type signature with your predicate
    definition.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 6.6.** 编写一个谓词表达式，用于表示“元素超过六个”的属性，该谓词接受一个列表作为输入。请在谓词定义中包含类型签名。'
- en: '**Exercise 6.7.** [Table 6-5](ch06.xhtml#ch6tab5) gives examples of the use
    of the `replicate` function. In the first three examples, a list is created with
    the requested length of the requested item. In the last case, a string is created.
    This seems different. Explain what is going on here.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 6.7.** [表6-5](ch06.xhtml#ch6tab5)展示了`replicate`函数的使用示例。在前三个示例中，创建了一个具有请求长度的请求项的列表。在最后一个示例中，创建了一个字符串。这似乎有所不同。解释这里发生了什么。'
- en: '**Exercise 6.8.** Make a list of the first 1,000 squares. Don’t print the list;
    just print your definition. You could print the first 10 squares to see if your
    method is working.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 6.8.** 创建一个包含前1,000个平方数的列表。不要打印列表，只打印你的定义。你可以先打印前10个平方数来检查你的方法是否有效。'
- en: '**Exercise 6.9.** Use `iterate` to define a function `repeat''` that does the
    same thing as the Prelude function `repeat`.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 6.9.** 使用`iterate`定义一个函数`repeat''`，它与Prelude中的`repeat`函数执行相同的操作。'
- en: '**Exercise 6.10.** Use `take` and `repeat` to define a function `replicate''`
    that does the same thing as the Prelude function `replicate`.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 6.10.** 使用`take`和`repeat`定义一个函数`replicate''`，它与Prelude中的`replicate`函数执行相同的操作。'
- en: '**Exercise 6.11.** A car starts from rest and accelerates at 5 m/s² on a straight,
    level highway. Use `iterate` to make an infinite list of velocities for this car,
    with one velocity every second. (The list should look like [0,5,10,15,...]. Use
    the `take` function to see the first several elements of your infinite list.)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 6.11.** 一辆汽车从静止开始，在一条平坦的高速公路上以 5 m/s² 的加速度加速。使用`iterate`生成一个包含该车每秒速度的无限列表。（该列表应类似于[0,5,10,15,...]。使用`take`函数查看无限列表中的前几个元素。）'
- en: '**Exercise 6.12.** List comprehensions can be used as an alternative to the
    `map` function. To prove this, write a function'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 6.12.** 列表推导式可以作为`map`函数的替代。为了证明这一点，编写一个函数。'
- en: '[PRE29]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: that does the same thing as `map`. Use a list comprehension to write your definition.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 它的功能与`map`相同。使用列表推导式编写你的定义。
- en: '**Exercise 6.13.** List comprehensions can be used as an alternative to the
    `filter` function. To prove this, write a function'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 6.13.** 列表推导式可以作为`filter`函数的替代。为了证明这一点，编写一个函数。'
- en: '[PRE30]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: that does the same thing as `filter`. Use a list comprehension to write your
    definition.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 它的功能与`filter`相同。使用列表推导式编写你的定义。
- en: '**Exercise 6.14.** Write a function'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 6.14.** 编写一个函数。'
- en: '[PRE31]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: that finds the average of a list of numbers. You can assume the list has at
    least one number. You may want to use the `fromIntegral` function.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一个数字列表的平均值。你可以假设列表至少包含一个数字。你可能需要使用`fromIntegral`函数。
- en: '**Exercise 6.15.** Produce one-input and two-input pictures, similar to [Figures
    6-2](ch06.xhtml#ch6fig2) and [6-3](ch06.xhtml#ch6fig3), for the higher-order function
    `drop`. Do the same thing for the higher-order function `replicate`.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 6.15.** 生成一输入和二输入的图形，类似于[图 6-2](ch06.xhtml#ch6fig2)和[6-3](ch06.xhtml#ch6fig3)，用于高阶函数`drop`。对高阶函数`replicate`做同样的操作。'
- en: '**Exercise 6.16.** An alternative rule to the midpoint rule for numerical integration
    is the trapezoidal rule. In the trapezoidal rule, we approximate the area under
    a curve by the sum of the areas of a bunch of trapezoids, as shown in [Figure
    6-9](ch06.xhtml#ch6fig9).'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 6.16.** 作为数值积分的中点法的替代规则，梯形规则也可以使用。在梯形规则中，我们通过一系列梯形的面积之和来近似曲线下的面积，如[图 6-9](ch06.xhtml#ch6fig9)所示。'
- en: '![Image](Images/090fig01.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/090fig01.jpg)'
- en: '*Figure 6-9: The trapezoidal rule*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-9：梯形规则*'
- en: For the example, in [Figure 6-9](ch06.xhtml#ch6fig9), the area of the first
    trapezoid is
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于例子，参见[图 6-9](ch06.xhtml#ch6fig9)，第一个梯形的面积是：
- en: '![Image](Images/090equ01.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/090equ01.jpg)'
- en: and the area of all four trapezoids in the figure is
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图中所有四个梯形的面积之和是：
- en: '![Image](Images/090equ02.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/090equ02.jpg)'
- en: Write a definition for the function
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为函数编写定义。
- en: '[PRE32]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'that takes a number of trapezoids, a function, and two limits as its arguments
    and gives back (an approximation to) the definite integral, using the trapezoidal
    rule. Test your integrator on the following integrals and see how close you can
    get to the correct values:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受若干个梯形数、一个函数和两个限制作为参数，并返回（近似）定积分的值，使用梯形规则。测试你的积分器在以下积分上的表现，并查看它能接近正确值多少：
- en: '![Image](Images/090equ03.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/090equ03.jpg)'
