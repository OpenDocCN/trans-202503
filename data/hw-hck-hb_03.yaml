- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: 'Casing the Joint: Identifying Components and Gathering Information'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 查探目标：识别组件和收集信息
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Frank Herbert wrote in *Dune*, “A beginning is a very delicate time.” As you
    likely know, the way you begin a project sets the tone for its success. Operating
    on false assumptions or overlooking a small bit of information can derail a project
    and burn precious time. Thus, with any reverse engineering or research project
    (hardware being no different), gathering and reviewing as much information as
    possible in the early phases of your investigation into a target system is critical.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 弗兰克·赫伯特在《沙丘》中写道：“开始是一个非常微妙的时刻。”正如你可能知道的，项目的开始方式为其成功奠定了基调。基于错误假设进行操作或忽视一些小信息，可能会使项目偏离轨道并浪费宝贵的时间。因此，无论是进行逆向工程还是研究项目（硬件项目也不例外），在调查目标系统的早期阶段收集并审查尽可能多的信息至关重要。
- en: Most hardware-based projects start with a curiosity and fact-gathering stage,
    and this chapter is meant to assist with that phase. If you’re performing a target
    system review without design files, specifications, or a bill of materials (BOM),
    you naturally start by opening the device and seeing what’s inside. That’s the
    fun part! This chapter outlines techniques for identifying interesting components
    or interfaces and shares ideas for gathering information and specifications for
    a device and its components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于硬件的项目都从好奇心和事实收集阶段开始，本章旨在帮助这一阶段。如果你在没有设计文件、规格说明书或物料清单（BOM）的情况下进行目标系统审查，你自然会从拆开设备并查看里面的内容开始。这就是最有趣的部分！本章概述了识别有趣组件或接口的技术，并分享了收集设备及其组件信息和规格的想法。
- en: This information-gathering phase isn’t linear. You’ll find a variety of puzzle
    pieces. In this chapter, we show ways to find the pieces, and it’s up to you to
    put them together, in whatever order, to make the picture sufficiently complete.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信息收集阶段并非线性进行。你会发现各种各样的拼图碎片。在本章中，我们展示了找到这些碎片的方法，而将它们以任何顺序拼凑起来，使得图像足够完整，就由你自己决定了。
- en: Information Gathering
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息收集
- en: '*Info gathering*, *doxing*, *recon*, *getting developer Joe to spill the beans*—however
    you express it, this is an important time-saving step. Plenty of information is
    available if you know where to look. We begin with the least effort, which is
    at the keyboard, and later we’ll reach for the screwdriver and other tools.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*信息收集*、*个人信息搜集*、*侦察*、*让开发者Joe泄密*——无论你怎么表达，这都是一个节省时间的重要步骤。如果你知道该去哪里找，很多信息是可以获取的。我们从最简单的方式开始，也就是在键盘前，之后我们将使用螺丝刀和其他工具。'
- en: Before delving into the deeper recesses of the internet, you might consider
    just searching for the given product name along with the keyword *teardown*. It’s
    common to have teardowns of popular products posted in numerous sources; the iFixit
    website([https://www.ifixit.com/](https://www.ifixit.com/)), for example, has
    many popular teardowns, including detailed annotations of the products. For consumer
    goods, watch for multiple generations of the products. The Nest Protect smart
    smoke alarm second-generation device is very different internally from the first-generation
    device, for example. It’s common that companies won’t actually differentiate such
    generations, as they simply stop selling the older generation devices, so you
    may need to figure that out from model numbers or similar.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入网络的更深处之前，你或许可以先搜索给定产品名称加上关键词*拆解*。常常会在多个来源中找到热门产品的拆解；例如，iFixit网站([https://www.ifixit.com/](https://www.ifixit.com/))上就有许多流行产品的拆解，并附有详细的产品注释。对于消费品，注意查看产品的多个代际版本。例如，Nest
    Protect智能烟雾报警器第二代设备在内部结构上与第一代设备有很大不同。公司通常不会区分这些代际产品，因为他们会停止销售旧一代设备，所以你可能需要通过型号或类似的信息来判断。
- en: Federal Communications Commission Filings
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 美国联邦通信委员会档案
- en: The *Federal Communications Commission (FCC)* is a US government agency responsible
    for everything from imposing fines for exposing specific body parts on TV to ensuring
    that the latest high-speed wireless devices don’t interfere with each other. It
    sets regulations that manufacturers of any digital device sold in the US must
    follow. These regulations are designed to ensure that a given device doesn’t generate
    excessive amounts of interference (for example, your whiz-bang 5000 causing your
    neighbor’s TV reception to drop out) and continues to operate even in the presence
    of some level of electromagnetic (EM) interference.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*联邦通信委员会 (FCC)* 是美国的一个政府机构，负责从对电视上暴露特定身体部位罚款到确保最新的高速无线设备不会相互干扰等一切事务。它制定了美国市场上任何数字设备制造商必须遵守的规定。这些规定旨在确保设备不会产生过量的干扰（例如，你那款超炫的
    5000 型设备导致邻居电视信号中断），并能在一定程度的电磁（EM）干扰下继续正常工作。'
- en: Other countries have similar agencies and rules. The FCC is interesting because
    the US is such a large market, so most products have been designed and/or tested
    to meet FCC rules, and the FCC makes the database of filed information publicly
    available.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 其他国家也有类似的机构和规定。FCC 特别有趣的是，因为美国是一个非常大的市场，所以大多数产品都是为了符合 FCC 规定而设计和/或测试的，并且 FCC
    将备案信息数据库公开提供。
- en: About FCC Filings
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于 FCC 备案
- en: Any digital device that emits radio waves, known as an intentional radiator,
    requires testing. The FCC requires manufacturers to test their devices’ emissions
    carefully and provide documentation proving devices meet FCC rules. It’s a very
    expensive process, and the FCC needs to ensure that it is easy for the public
    to check compliance. This is why, for instance, the open source flash-drive-sized
    computer called the *USB armory Mk I* is labeled as a development platform that
    “may cause interference to electrical or electronic devices in close proximity.”
    Proving that this label may be unjustified is expensive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 任何发射无线电波的数字设备，称为有意辐射源，都需要进行测试。FCC 要求制造商仔细测试设备的辐射，并提供文档证明设备符合 FCC 规定。这是一个非常昂贵的过程，FCC
    需要确保公众能够轻松检查合规性。因此，像 *USB armory Mk I* 这样的开源闪存驱动器大小的计算机，标明它是一个开发平台，“可能会对附近的电气或电子设备造成干扰。”证明该标签可能不合理是非常昂贵的。
- en: For compliance checking by the public, an intentional radiator must publish
    something known as its *FCC ID*, which is printed on the device’s label. You can
    search for this ID on the FCC website and confirm that the device did indeed pass
    compliance testing. This also means detecting fake FCC labels is easy because
    anybody can check the status, not just FCC agents.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让公众进行合规性检查，有意辐射源必须公布一个称为 *FCC ID* 的标识，印在设备标签上。你可以在 FCC 网站上搜索该 ID，并确认该设备确实通过了合规性测试。这也意味着检测假冒
    FCC 标签变得很容易，因为任何人都可以检查状态，而不仅仅是 FCC 的工作人员。
- en: A device’s FCC label may be inside a battery cover. [Figure 3-1](#figure3-1)
    shows an example of the label on a D-Link router.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的 FCC 标签可能位于电池盖内部。[图 3-1](#figure3-1) 显示了 D-Link 路由器标签的一个例子。
- en: '![f03001](image_fi/278748c03/f03001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![f03001](image_fi/278748c03/f03001.png)'
- en: 'Figure 3-1: D-Link FCC label'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：D-Link FCC 标签
- en: If a device isn’t an intentional radiator, it still must have the FCC compliance
    logo, but it won’t have an FCC ID. These unintentional radiators have less strict
    reporting requirements, and the test documentation is often not available.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备不是有意辐射源，它仍然必须有 FCC 合规标志，但不会有 FCC ID。这些无意辐射源的报告要求较少，测试文档通常也不公开。
- en: Finding FCC Filings
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找 FCC 备案
- en: 'As an example, the wireless router’s label in [Figure 3-1](#figure3-1) shows
    that the FCC ID is KA2IR818LA1, which you can find on the FCC ID Search website.
    The search tool separates the ID into two parts: the grantee code and the product
    code. The FCC assigns the grantee code, and it’s always the same for a given company.
    This code was previously only the first three characters of the FCC ID, but as
    of May 1, 2013, it can be either three or five characters. The company assigns
    the product code, which can be anything from 1 to 14 characters.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，[图 3-1](#figure3-1) 中无线电路由器的标签显示 FCC ID 为 KA2IR818LA1，你可以在 FCC ID 搜索网站上找到该
    ID。搜索工具将该 ID 分为两部分：授权代码和产品代码。FCC 分配授权代码，并且对于某个特定公司来说，这个代码始终是相同的。此前，该代码只有 FCC ID
    的前三个字符，但自 2013 年 5 月 1 日起，它可以是三位或五位字符。公司分配产品代码，长度可以从 1 到 14 个字符不等。
- en: Going back to the router, the grantee code is KA2, and the product code is IR818LA1\.
    Entering this information into the search box gives the results shown in . This
    device has three filings, because it has multiple frequency bands in which it
    can operate. The Detail link provides reports and letters, including external
    and internal product photos—normally photos of the board(s) as well as details
    about the integrated circuits.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 回到路由器，授权代码是KA2，产品代码是IR818LA1。将这些信息输入搜索框后，会显示出如图所示的结果。该设备有三个备案，因为它可以在多个频段中工作。点击详细链接可查看报告和信函，包括外部和内部产品照片——通常是电路板的照片以及集成电路的详细信息。
- en: Pulling up the internal photos based on the FCC ID KA2IR818LA1, you should easily
    be able to identify the main processor as an RTL8881AB. You can also see some
    sort of header, which is most likely serial-based, as it has around four pins
    and a number of test points on the printed circuit board (PCB). You’ve found all
    of this information without even touching a screwdriver.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 基于FCC ID KA2IR818LA1调出内部照片后，你应该能轻松识别出主处理器是RTL8881AB。你还可以看到某种类型的头针，这很可能是串行接口，因为它有大约四个引脚，并且电路板（PCB）上有多个测试点。你在没有动用螺丝刀的情况下就找到了所有这些信息。
- en: '![f03002](image_fi/278748c03/f03002.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![f03002](image_fi/278748c03/f03002.png)'
- en: 'Figure 3-2: FCC ID search results'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-2：FCC ID搜索结果
- en: FCC Equivalents
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: FCC 等效项
- en: The Nest doorbell in [Figure 3-3](#figure3-3) shows no FCC ID. Why? Colin bought
    this device, and he’s located in Canada, so the device doesn’t require an FCC
    ID. Instead, it’s marked only with the Industry Canada (IC) code, which allows
    you to search the Industry Canada “Radio Equipment List (REL)” database for a
    matching “certification number.”
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3中的Nest门铃没有显示FCC ID。为什么？Colin购买了这款设备，并且他位于加拿大，所以该设备不需要FCC ID。相反，它只标有加拿大工业（IC）代码，这允许你在加拿大工业“无线设备列表（REL）”数据库中搜索匹配的“认证号”。
- en: '![f03003](image_fi/278748c03/f03003.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![f03003](image_fi/278748c03/f03003.png)'
- en: 'Figure 3-3: Nest doorbell'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3：Nest门铃
- en: Searching the IC REL database for 9754A-NC51 provides more information, but
    no detailed internal photos are available on the public website. The product code
    part of the reference (NC51) is shared between the FCC ID and the IC designator,
    so a quick way to find more information is to do a partial search at [https://FCCID.io/](https://FCCID.io/)
    for NC51\. We found that the FCC ID is ZQANC51, which allowed us to find the internal
    photos.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在IC REL数据库中搜索9754A-NC51会提供更多信息，但公共网站上没有详细的内部照片。参考资料中的产品代码部分（NC51）在FCC ID和IC设计标识符之间是共享的，因此快速查找更多信息的方法是到[https://FCCID.io/](https://FCCID.io/)进行部分搜索，查找NC51。我们发现FCC
    ID是ZQANC51，这让我们找到了内部照片。
- en: Patents
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 专利
- en: Patents are effectively licenses given to product developers to sue companies
    who sell a product that copies the well-defined operation of the original product,
    in a specific geographic area, for a limited period of time. Patents, in theory,
    are issued only if that well-defined operation is something novel. The goal is
    to protect inventions, and since this chapter is about information gathering and
    not politics, we’ll leave it at that.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 专利实际上是授予产品开发者的许可证，使其能够起诉在特定地理区域内销售复制原始产品运行方式的产品的公司，且在有限的时间内有效。理论上，专利只有在该明确的操作是新颖的情况下才会被授予。专利的目标是保护发明，由于本章讨论的是信息收集而非政治，我们就此打住。
- en: 'Most companies like patents since they can use them to stop a competitor from
    releasing a product using some new technology or design. But there is a catch:
    patents must explain how that new technology works. The idea is that in exchange
    for giving away precious details about the new technology, the legal system can
    stop anyone else from using those details to compete with the inventor for that
    limited period of time.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数公司喜欢专利，因为他们可以利用专利来阻止竞争对手发布使用某种新技术或设计的产品。但有一个前提：专利必须解释该新技术如何运作。其背后的理念是，作为交换，为了透露关于新技术的宝贵细节，法律系统可以阻止任何人使用这些细节与发明者在有限的时间内进行竞争。
- en: Finding Patents
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找专利
- en: When researching a device, you might find that patents provide useful information
    about how security or other aspects of the design were handled. For example, in
    researching a password-protected hard drive, we found a patent that describes
    a method of securing hard drives by scrambling the partition table.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究设备时，你可能会发现专利提供了关于如何处理设计中安全性或其他方面的有用信息。例如，在研究一个密码保护的硬盘时，我们找到了一项专利，描述了一种通过打乱分区表来保护硬盘的方法。
- en: Products or manuals might be stamped with some sort of statement like “Protected
    by US Patent 7,324,123.” You can easily look up this patent number on the United
    States Patent and Trademark Office (USPTO) website or on a third-party website,
    such as Google Patents. We recommend Google Patents, as it searches multiple databases
    and also contains an easily navigated search tool for general-purpose use.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 产品或手册上可能会有类似“受美国专利7,324,123保护”的声明。你可以轻松地在美国专利商标局（USPTO）网站或第三方网站（如Google Patents）上查找该专利号。我们推荐使用Google
    Patents，因为它可以搜索多个数据库，并且包含一个易于导航的通用搜索工具。
- en: Often products are labeled “Patent Pending,” or you may find only references
    to patents in the product literature. This normally means the company has simply
    applied for a patent; it might not even be publicly viewable yet. In that case,
    the only reasonable method of searching for those patents is by company name.
    Determine to whom the patent is likely assigned; for example, a patent might be
    owned by the manufacturer of a chip inside the device and not the manufacturer
    of the device itself. Often you can find related patents issued to the company
    and then search by the company’s law firm or even patents by other related inventors.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 产品上常常标有“专利申请中”字样，或者你可能只会在产品文献中找到专利的引用。这通常意味着公司已经提交了专利申请，但该专利可能尚未公开。在这种情况下，搜索这些专利的唯一合理方法是通过公司名称来查找。确定专利可能归属的公司；例如，一个专利可能属于设备内部芯片的制造商，而不是设备本身的制造商。通常你可以找到授予该公司相关专利，并进一步通过该公司的律师事务所或其他相关发明人的专利进行搜索。
- en: If you find a patent (or patent application), the actual published application
    isn’t all the information you can use. A system called the USPTO Public PAIR allows
    you to review almost all correspondence between the USPTO and patent applicant.
    Those documents are not indexed by search engines, so you won’t find them without
    using the USPTO Public PAIR system. You can see, for example, if the USPTO has
    been fighting against an application in cases where patents are pending, or you
    can find supporting documentation that applicants may have uploaded. Sometimes
    you can find earlier versions of a patent or an applicant’s arguments, including
    additional information you won’t find on Google Patents.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找到了一项专利（或专利申请），实际发布的申请并不是你可以使用的所有信息。有一个名为USPTO Public PAIR的系统，可以让你查看几乎所有USPTO与专利申请人之间的通信。这些文件不会被搜索引擎索引，所以如果不使用USPTO
    Public PAIR系统，你是找不到这些文件的。例如，你可以看到USPTO是否在专利待审的情况下与申请人争论，或者你可以找到申请人可能上传的支持文档。有时你还可以找到专利的早期版本或申请人的论点，其中包含一些在Google
    Patents上找不到的额外信息。
- en: 'Some examples of interesting uses of patents for reverse engineering include
    the Thangrycat attack by Red Balloon Security, detailed in a DEF CON presentation
    titled “100 Seconds of Solitude: Defeating Cisco Trust Anchor with FPGA Bitstream
    Shenanigans.” In this attack, Red Balloon Security defeated the Cisco root of
    trust, which used an electronic component called a *field-programmable gate array
    (FPGA)*. Details of the architecture were helpfully explained in US Patent 9,830,456,
    which provided insights that otherwise would have required considerable effort
    to reverse engineer.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '一些有趣的专利逆向工程应用案例包括Red Balloon Security的Thangrycat攻击，详细内容见DEF CON报告《100 Seconds
    of Solitude: 利用FPGA比特流恶作剧突破思科信任锚》。在这次攻击中，Red Balloon Security突破了思科的信任根，它使用了一种名为*现场可编程门阵列（FPGA）*的电子组件。美国专利9,830,456详细解释了架构，这些信息原本需要大量的逆向工程工作才能获得。'
- en: 'Another example where patents were useful for hardware hackers is a presentation
    at Black Hat USA titled “GOD MODE UNLOCKED: Hardware Backdoors in x86 CPUs,” by
    Christopher Domas. Here, US Patent 8,296,528 explained how a separate processor
    could be connected to the main x86 core and hinted at details that resulted in
    a complete compromise of the core’s security mechanism.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个专利对硬件黑客有用的例子是在Black Hat USA上的一个报告，标题为“GOD MODE UNLOCKED: x86 CPU中的硬件后门”，由Christopher
    Domas主讲。在这里，美国专利8,296,528解释了如何将一个独立的处理器连接到主x86核心，并暗示了一些细节，这些细节最终导致了核心安全机制的完全被攻破。'
- en: Patents may even list details about secure devices. For example, a Square credit
    card reader contains an anti-tamper “mesh” integrated into a plastic cover for
    the secure section of the microcontroller. [Figure 3-4](#figure3-4) shows the
    four large square pads (we’ll talk more about PCB features later in this chapter)
    with oval sections that will connect to the tamper mesh cover.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 专利甚至可能列出关于安全设备的详细信息。例如，Square信用卡读卡器包含一个集成在微控制器安全部分塑料外壳中的防篡改“网格”。[图3-4](#figure3-4)显示了四个大方形垫片（我们将在本章后面讨论更多PCB特征），这些垫片上有椭圆形区域，能够与防篡改网格外壳连接。
- en: '[Figure 3-5](#figure3-5) shows the underside of the tamper mesh cover that
    mates to the PCB shown in [Figure 3-4](#figure3-4).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-5](#figure3-5)显示了与[图3-4](#figure3-4)中所示的PCB连接的防篡改网格外壳的底部。'
- en: '![f03004](image_fi/278748c03/f03004.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![f03004](image_fi/278748c03/f03004.png)'
- en: 'Figure 3-4: The Square credit card reader internals with four tamper shield
    connectors near each corner'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-4：Square信用卡读卡器内部结构，四个防篡改保护连接器位于每个角落附近
- en: '![f03005](image_fi/278748c03/f03005.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![f03005](image_fi/278748c03/f03005.png)'
- en: 'Figure 3-5: The Square reader’s tamper shield; the exposed connections will
    mate with the PCB shown in [Figure 3-4](#figure3-4)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-5：Square读卡器的防篡改保护罩；暴露的连接将与[图3-4](#figure3-4)中显示的PCB连接。
- en: When you remove the mesh, the device will stop working, so reverse engineering
    the device quickly becomes expensive. If you search Google Patents for US10251260B1,
    however, you’ll find details about how the mesh works. Try that now and see if
    you can match the photos from Figures 3-4 and 3-5 to patent figures. If you haven’t
    worked with PCBs before, come back to these figures again after you finish this
    chapter, as we’ll explain some of the PCB features you can see here.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你移除网格时，设备将停止工作，因此对设备进行逆向工程会迅速变得非常昂贵。然而，如果你在Google专利中搜索US10251260B1，你会找到有关网格工作原理的详细信息。现在试试，看看能否将图3-4和图3-5的照片与专利图纸进行匹配。如果你以前没有接触过PCB，等你完成本章后再回来看这些图，我们会解释一些你可以在这里看到的PCB特征。
- en: Datasheets and Schematics
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Datasheet 和原理图
- en: Manufacturers publish datasheets (either publicly or under NDA) so designers
    can learn how to use their components, but they usually don’t publish complete
    schematics. Instead, you usually can find publicly shared *logical* designs that
    show how components are interconnected. For instance, a PCB layout shows the physical
    design—that is, where all components are placed and how the wires are routed,
    but it’s usually not publicly available.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 制造商发布datasheet（无论是公开的还是在保密协议下）以便设计师了解如何使用他们的组件，但他们通常不发布完整的原理图。相反，你通常可以找到公开共享的*逻辑*设计，展示组件如何互联。例如，PCB布局展示了物理设计——即所有组件的放置位置以及电线如何布置，但它通常不会公开。
- en: Try finding a datasheet online for your favorite device or development board,
    such as for a Raspberry Pi computer module or an Intel 8086 processor, or a random
    datasheet for flash or DRAM memory. Or, if you want to go analog, find a level-shifter
    datasheet. Usually, you just need to do a simple internet search for product IDs
    or other identifiers, as mentioned earlier. Websites like findchips ([https://www.findchips.com/](https://www.findchips.com/))
    also are helpful for locating current products.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在线查找你最喜欢的设备或开发板的datasheet，例如树莓派计算模块或英特尔8086处理器，或者随机查找闪存或DRAM内存的datasheet。或者，如果你想了解模拟电路，可以找一个电平转换器的datasheet。通常，你只需要根据前面提到的产品ID或其他标识符进行简单的互联网搜索。像findchips这样的网页([https://www.findchips.com/](https://www.findchips.com/))也有助于定位当前产品。
- en: 'Datasheets for a specific part may be a bit harder to find. For components,
    first determine the part number (see the “Identifying ICs on the Board” section
    on page 86). The part number often appears to be a random-looking collection of
    letters and numbers, but they encode the available various configurations of a
    part. For instance, the datasheet for the MT29F4G08AAAWP breaks the part number
    down as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 查找特定零件的 datasheet 可能会有些困难。对于组件，首先确定零件号（请参见第86页的“识别电路板上的IC”部分）。零件号通常看起来像是随机的字母和数字组合，但它们编码了零件的各种配置。例如，MT29F4G08AAAWP的datasheet将零件号分解如下：
- en: MT stands for Micron Technology.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MT代表美光科技。
- en: 29F is the product family of NAND flash memory.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29F是NAND闪存的产品系列。
- en: 4G indicates a 4GB storage capacity.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4G表示4GB存储容量。
- en: 08 indicates an 8-bit device.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 08表示一个8位设备。
- en: First “A” means one die, one command pin, and one device status pin.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个“A”表示一个芯片，一个命令引脚和一个设备状态引脚。
- en: Second “A” indicates an operating voltage of 3.3 V.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个“A”表示工作电压为3.3V。
- en: Third “A” is a listed feature set.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个“A”是列出的特性集。
- en: WP indicates that the component is a 48-pin thin small outline package (TSOP).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WP表示该组件是一个48引脚薄小型外形封装（TSOP）。
- en: When searching, simply type in any part number you find on the die. If you can’t
    find the exact number, trim off some of the last characters and search again or
    allow your search engine to suggest some nearly matching names.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索时，只需输入你在芯片上找到的任何零件编号。如果找不到精确的编号，可以去掉一些最后的字符再试，或者让你的搜索引擎建议一些相似的名称。
- en: Oftentimes you’ll have too many matches, because on very small parts, a full
    part number isn’t printed, but only a shorter *marking code*. Unfortunately, searching
    the marking code will return hundreds of unrelated matches. For example, a particular
    part on a board may simply be labeled *UP9*, which is almost unsearchable. If
    you search the marking code along with the package type, you will often get more
    useful hits. In this example, we had identified the package as being an SOT-353
    package type (we discuss package types later in this chapter). For marking codes
    specifically, you can find SMD (surface-mount device) marking code databases,
    such as [https://smd.yooneed.one/](https://smd.yooneed.one/) and [http://www.s-manuals.com/smd/](http://www.s-manuals.com/smd/),
    which, combined with your knowledge of the package, can lead you to the device
    (in this case, a Diodes, Inc., 74LVC1G14SE).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会遇到过多的匹配结果，因为在一些非常小的元件上，完整的零件编号没有打印出来，只有一个较短的*标记代码*。不幸的是，搜索标记代码时，可能会返回成百上千个不相关的结果。例如，某个板上的特定元件可能仅仅标记为*UP9*，这几乎无法搜索。如果你将标记代码与封装类型一起搜索，通常会得到更有用的结果。在这个例子中，我们已经确认该封装为SOT-353封装类型（我们将在本章后面讨论封装类型）。针对标记代码，您可以找到SMD（表面贴装设备）标记代码数据库，例如[https://smd.yooneed.one/](https://smd.yooneed.one/)和[http://www.s-manuals.com/smd/](http://www.s-manuals.com/smd/)，结合您对封装的了解，能够帮助你找到该设备（在此案例中是Diodes,
    Inc.的74LVC1G14SE）。
- en: 'After looking at a few datasheets, you’ll find they have something in common.
    They seldom contain interesting information from a security viewpoint. We’re mainly
    concerned with interacting with a device, which means discovering how it works
    and how to connect to it. The introductory blurb will contain the functionality:
    it’s a CPU, a flash device, or whatever. To connect to it, we look for the pinout
    and any parameters describing the pins, such as functionality, protocol, or voltage
    levels. You’ll almost certainly find some of the interfaces discussed in Chapter
    2.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在查阅了几个数据手册后，你会发现它们有一些共同点。它们很少包含从安全角度有趣的信息。我们主要关心的是如何与设备互动，这意味着要了解它如何工作以及如何连接到它。引言部分会包含功能说明：它是一个CPU、闪存设备或其他什么设备。要连接到它，我们需要查看引脚排列图以及任何描述引脚的参数，例如功能、协议或电压等级。你几乎肯定会找到一些在第二章中讨论的接口。
- en: 'Information Search Example: The USB Armory Device'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信息搜索示例：USB Armory设备
- en: 'Let’s look for information on the USB armory Mk I device from Inverse Path
    (acquired by F-Secure) as an example. It’s an open source piece of hardware, so
    we’ll be able to access plenty of detail. Before reading all the spoilers here,
    try researching it yourself. Go find the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Inverse Path（被F-Secure收购）的USB Armory Mk I设备为例来查找信息。它是一个开源硬件，因此我们可以访问很多细节。在阅读这里的所有内容之前，尝试自己进行研究。去查找以下内容：
- en: The manufacturer and part number of the main System-on-Chip (SoC), as well as
    the datasheet for it.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主系统芯片（SoC）的制造商、零件编号，以及其数据手册。
- en: The GPIO and UART on the PCB.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCB上的GPIO和UART。
- en: Any JTAG ports exposed on the board.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 板上暴露的任何JTAG端口。
- en: The power supply wires and voltage on the PCB.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCB上的电源线和电压。
- en: The external clock crystal wires and frequency.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部时钟晶体线和频率。
- en: Where the I2C interface from the main SoC connects to another IC, and what the
    protocol is.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主SoC上的I2C接口连接到另一个IC的位置以及该协议。
- en: The boot configuration pins on the SoC, where they are connected on the PCB,
    and what boot mode and configurations this selects.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SoC上的启动配置引脚，它们在PCB上的连接方式，以及选择的启动模式和配置。
- en: Manufacturer, Part Number, and Datasheet
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 制造商、零件编号和数据手册
- en: 'From the USB armory GitHub pages and wiki ([https://inversepath.com/usbarmory_mark-one.html](https://inversepath.com/usbarmory_mark-one.html)),
    we can see that the USB armory is based on an NXP i.MX53 ARM Cortex-A8\. The datasheet
    is called *IMX53IEC.pdf* and is available in several places. When searching for
    “imx53 vulnerability,” we found a known X.509 vulnerability on the Quarkslab blog.
    If you dig further, you may be able to find an advisory titled “Security Advisory:
    High Assurance Boot (HABv4) Bypass,” which notes these vulnerabilities are not
    present in the Mk II.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '从 USB armory 的 GitHub 页面和 Wiki（[https://inversepath.com/usbarmory_mark-one.html](https://inversepath.com/usbarmory_mark-one.html)）上，我们可以看到
    USB armory 基于 NXP i.MX53 ARM Cortex-A8。数据表名为 *IMX53IEC.pdf*，可以在多个地方找到。当搜索“imx53
    vulnerability”时，我们在 Quarkslab 博客上找到了已知的 X.509 漏洞。如果继续深入查找，可能会找到一份名为“Security Advisory:
    High Assurance Boot (HABv4) Bypass”的公告，指出这些漏洞在 Mk II 中不存在。'
- en: The GPIO and UART on the PCB
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PCB 上的 GPIO 和 UART
- en: Searching for “USB armory GPIO,” we arrive at its GitHub wiki ([https://github.com/f-secure-foundry/usbarmory/wiki/GPIOs/](https://github.com/f-secure-foundry/usbarmory/wiki/GPIOs/)),
    which provides the GPIO detail. In the datasheet sourced in the previous section,
    we can find all of the i.MX53’s GPIO, UART, I2C, and SPI pins. Any of those communications
    ports would be interesting to monitor; they will surely transport console or debug
    output.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索“USB armory GPIO”，我们找到了其 GitHub Wiki（[https://github.com/f-secure-foundry/usbarmory/wiki/GPIOs/](https://github.com/f-secure-foundry/usbarmory/wiki/GPIOs/)），该页面提供了
    GPIO 的详细信息。在前一节中提到的数据表中，我们可以找到所有 i.MX53 的 GPIO、UART、I2C 和 SPI 引脚。任何一个通信端口都很有趣，值得监控；它们肯定会传输控制台或调试输出。
- en: JTAG Ports
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JTAG 端口
- en: JTAG, if not locked down, should provide low-level access to the chip via ARM’s
    debugging facilities, so we want information about any JTAG ports exposed on the
    board. Exploring the GitHub pages a bit more yields the JTAG page specific for
    the Mk I ([https://github.com/f-secure-foundry/usbarmory/wiki/JTAG-(Mk-I)/](https://github.com/f-secure-foundry/usbarmory/wiki/JTAG-(Mk-I)/)),
    which includes a PCB photo (see [Figure 3-6](#figure3-6)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有被锁定，JTAG 应该能够通过 ARM 的调试功能提供对芯片的低级访问，因此我们需要了解任何暴露在板上的 JTAG 端口。进一步探索 GitHub
    页面可以找到专门针对 Mk I 的 JTAG 页面（[https://github.com/f-secure-foundry/usbarmory/wiki/JTAG-(Mk-I)/](https://github.com/f-secure-foundry/usbarmory/wiki/JTAG-(Mk-I)/)），该页面包含了
    PCB 照片（见 [图 3-6](#figure3-6)）。
- en: '![f03006](image_fi/278748c03/f03006.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![f03006](image_fi/278748c03/f03006.png)'
- en: 'Figure 3-6: USB armory JTAG connector pins'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-6：USB armory JTAG 连接器引脚
- en: '[Figure 3-6](#figure3-6) shows the standard TCK, TMS, TDI, TDO, nTRST, and
    GND (ground) JTAG connections. The 2v8 pad provides a 2.8 V supply, but what about
    the MOD pad? The datasheet is not very clear about that. The JTAG_MOD/sjc_MOD
    is in the i.MX53 pinout list, but there’s no explanation of its meaning. A bit
    of searching for related products yields an explanation on the i.MX6 computer
    module datasheet (search for “IMX6DQ6SDLHDG.pdf”; the original NXP site requires
    a sign-in, but the PDF is mirrored in other places). This datasheet explains that
    *low* adds all system test access ports (TAPs) to the chain, whereas *high* makes
    it IEEE1149.1- compliant (only useful for boundary scan, which we’ll discuss in
    the section “Using the JTAG Boundary Scan for Mapping” on page 106). Reading the
    schematic at the bottom of the Mk I JTAG page, you’re advised to tie it to ground
    via a pulldown resistor; this pulls it *low* to enable system TAPs. As you can
    see, sometimes synthesizing different information sources completes the picture.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-6](#figure3-6) 显示了标准的 TCK、TMS、TDI、TDO、nTRST 和 GND（地）JTAG 连接。2v8 引脚提供 2.8V
    电源，但 MOD 引脚怎么样呢？数据表对此没有明确说明。JTAG_MOD/sjc_MOD 在 i.MX53 引脚分配表中有列出，但并没有解释其含义。通过搜索相关产品，我们在
    i.MX6 计算机模块的数据表中找到了一个解释（搜索“IMX6DQ6SDLHDG.pdf”；原 NXP 网站需要登录，但该 PDF 在其他地方有镜像）。该数据表解释了
    *low* 将所有系统测试访问端口（TAP）加入链中，而 *high* 使其符合 IEEE1149.1 标准（仅对边界扫描有用，边界扫描的使用将在第 106
    页的“使用 JTAG 边界扫描进行映射”一节中讨论）。查看 Mk I JTAG 页面底部的原理图，建议通过下拉电阻将其接地；这样可以将其 *low* 拉低，以启用系统
    TAPs。正如你所看到的，有时综合不同的信息来源可以补全全貌。'
- en: Power Supply and Voltage
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电源和电压
- en: For the power supply wires and voltage on the PCB, we go to the datasheet we
    sourced previously. Search for “power,” “Vcc,” “Vdd,” “Vcore,” “Vfuse,” and “ground/Vss.”
    You’ll discover that a modern SoC includes many repeated instances of those terms,
    each one representing a pin. Various subsystems on the power planes have multiple
    input voltages, which is one reason for this abundance of pins. For example, the
    flash memory may have a higher voltage than the core voltage. You may also find
    multiple I/O voltages that support a variety of standards.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 PCB 上的电源线和电压，我们可以查阅之前获取的数据表。搜索“power”、“Vcc”、“Vdd”、“Vcore”、“Vfuse” 和“ground/Vss”。你会发现现代
    SoC 包括多个重复的这些术语实例，每个都代表一个针脚。电源层的各种子系统具有多个输入电压，这也是为什么有如此众多的针脚的原因之一。例如，闪存存储器可能具有比核心电压更高的电压。你还可能会发现支持多种标准的多个
    I/O 电压。
- en: A second reason for the many pins is that they are often duplicated, sometimes
    several times over. This helps keep power and ground pins physically close to
    each other, reducing inductance to help deliver fast power transients to the chip.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个针脚数量众多的原因是它们经常会重复，有时甚至会多次重复。这有助于将电源和地针物理上靠近彼此，减少电感，帮助快速传递电源瞬变给芯片。
- en: The datasheet certainly includes many power pins, which in this chip are denoted
    as VCC (peripheral core voltage) and VDDGP (ARM core voltage), among other designations.
    We look for power pins to find ways to inject faults and do power analysis, which
    are techniques you’ll learn about in the next few chapters. For instance, if you
    want to listen in on crypto on the ARM core, you’d try to probe VDDGP. If you
    want to glitch L1 cache (VDDAL1), JTAG access control (NVCC_JTAG), or fuse writes
    (NVCC_FUSE), you’d try to control those.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表中当然包含许多电源针脚，在此芯片中标记为 VCC（外围核心电压）和 VDDGP（ARM 核心电压），以及其他设计ations。我们寻找电源针脚以找到注入故障和进行电力分析的方法，这些技术将在接下来的几章中学习。例如，如果你想监听
    ARM 核心上的加密内容，你可以尝试探测 VDDGP。如果你想干扰 L1 缓存（VDDAL1）、JTAG 访问控制（NVCC_JTAG）或熔断写入（NVCC_FUSE），你可以尝试控制这些针脚。
- en: A schematic is really helpful to learn how these power pins are connected on
    the circuit board. We found one in the GitHub hardware repository as *armory.pdf*
    ([https://raw.githubusercontent.com/inversepath/usbarmory/b42036e7c3460b6eb515b608b3e8338f408bcb22/hardware/mark-one/armory.pdf](https://raw.githubusercontent.com/inversepath/usbarmory/b42036e7c3460b6eb515b608b3e8338f408bcb22/hardware/mark-one/armory.pdf)).
    Page 3 of this PDF lists the power connections to the SoC. If you follow the PCB
    traces from these power connections, you’ll see a bunch of decoupling capacitors
    (marked C48, C49, and so on), which are used for de-noising the power supply.
    You’ll also notice that the connection names end in labels like PMIC_SW1_VDDGP
    and PMIC_SW2_VCC. *PMIC* stands for power management IC—a chip dedicated to supplying
    the right voltages. Page 2 of the PDF shows how the main power source (USB_VBUS)
    feeds into the main power plane (5V_MAIN) and into the PMIC, which in turn feeds
    the variety of regulated voltages to the SoC.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的原理图对于学习这些电源针脚如何在电路板上连接非常有帮助。我们在 GitHub 硬件库中找到了一份名为 *armory.pdf* 的原理图（[https://raw.githubusercontent.com/inversepath/usbarmory/b42036e7c3460b6eb515b608b3e8338f408bcb22/hardware/mark-one/armory.pdf](https://raw.githubusercontent.com/inversepath/usbarmory/b42036e7c3460b6eb515b608b3e8338f408bcb22/hardware/mark-one/armory.pdf)）。PDF
    的第三页列出了与 SoC 的电源连接。如果你跟随这些电源连接的 PCB 追踪线路，你会看到一堆去噪电容器（标记为 C48、C49 等），这些电容器用于去除电源噪声。你还会注意到连接名称以
    PMIC_SW1_VDDGP 和 PMIC_SW2_VCC 等标签结尾。*PMIC* 意为电源管理 IC，专用于提供正确的电压。PDF 的第二页显示了主要电源（USB_VBUS）如何进入主要电源层（5V_MAIN），然后进入
    PMIC，进而向 SoC 提供各种稳定电压。
- en: This tells us logically how everything is connected, but it doesn’t yet tell
    us where these wires are on the PCB. For that, we need to open the PCB’s layout
    files, found in the KiCAD design files.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们逻辑上一切是如何连接的，但还没有告诉我们这些线路在 PCB 上的具体位置。为此，我们需要打开 KiCAD 设计文件中的 PCB 布局文件。
- en: KiCAD is open source software for designing PCBs. We’re only using one percent
    of its functionality here to check out the PCB layout. We opened the *armory.kicad_pcb*
    design file with KiCAD’s `pcbnew` command. A PCB might include several layers
    of conductive tracks/traces, where each of those layers is shown on the right
    side of the program window, with checkboxes to enable and disable them. Disable
    them all first to see only the pads on the PCB. You’ll see the “U2” (main SoC’s
    ball grid) in the center, the “U1”/PMIC to the left, and the “U4”/DRAM chip to
    the right.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: KiCAD 是用于设计 PCB 的开源软件。在这里，我们只使用它的百分之一功能来检查 PCB 布局。我们通过 KiCAD 的 `pcbnew` 命令打开了
    *armory.kicad_pcb* 设计文件。一个 PCB 可能包括多层导电轨迹/走线，这些层会显示在程序窗口的右侧，并带有复选框用于启用和禁用它们。首先禁用所有层，只显示
    PCB 上的焊盘。你会看到“U2”（主 SoC 的球阵列）位于中间，“U1”/PMIC 在左侧，“U4”/DRAM 芯片在右侧。
- en: KiCAD has a nice tool to highlight a net, appropriately called *highlight net*,
    that allows you to click anywhere and follow the connection. Say we want to play
    around with the power to JTAG. Zoom in to the SoC until you see the ball names
    and find the NVCC_JTAG ball, which according to the datasheet is G9\. You’ll see
    what is shown in [Figure 3-7](#figure3-7).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: KiCAD 有一个很好的工具叫做 *highlight net*，可以让你点击任意位置并跟踪连接。假设我们想玩弄 JTAG 电源。缩放到 SoC，直到看到球名称，并找到
    NVCC_JTAG 球，根据数据表它位于 G9\。你会看到如 [图 3-7](#figure3-7) 所示的内容。
- en: 'Remember the JTAG pads? It seems that NVCC_JTAG is connected to the 2v8 pad
    used for JTAG power. However, near the PMIC, you’ll also see some wires highlighted.
    They are part of the same net; we just can’t see that part because we’ve switched
    off all the layers. Clicking all layers on and off, we find one layer that connects
    them: GND_POWER_1(see [Figure 3-8](#figure3-8)).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 记得 JTAG 焊盘吗？看起来 NVCC_JTAG 连接到了用于 JTAG 电源的 2v8 焊盘。不过，在 PMIC 附近，你还会看到一些高亮显示的线。这些线属于同一网络，只是我们看不见这一部分，因为我们已关闭了所有层。通过逐个启用和禁用各层，我们发现有一层连接了它们：GND_POWER_1（见
    [图 3-8](#figure3-8)）。
- en: The white dots are *vias*, which are small plated holes connecting a trace on
    one layer to a trace on another layer. One via is on the left connection to the
    PMIC, and then a power plane connects to the via on the right, which connects
    to the wire that goes to NVCC_JTAG. If we wanted to control the power on *NVCC_JTAG*
    for fault injection or power analysis, we could physically cut the trace to the
    PMIC and provide our own 2.8 V by soldering a wire to the 2v8 pad.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 白色圆点是 *vias*，即连接一层走线与另一层走线的小镀孔。一个 via 位于与 PMIC 连接的左侧，另一侧通过电源平面连接到右侧的 via，然后连接到通往
    NVCC_JTAG 的线。如果我们想控制 *NVCC_JTAG* 的电源进行故障注入或电源分析，我们可以物理切断与 PMIC 的走线，并通过焊接一根线到 2v8
    焊盘来提供自己的 2.8 V 电压。
- en: '![f03007](image_fi/278748c03/f03007.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![f03007](image_fi/278748c03/f03007.png)'
- en: 'Figure 3-7: Using KiCAD to highlight an interconnection network'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-7：使用 KiCAD 高亮显示一个互连网络
- en: '![f03008](image_fi/278748c03/f03008.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![f03008](image_fi/278748c03/f03008.png)'
- en: 'Figure 3-8: Highlighting the GND_POWER_1 layer'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-8：高亮显示 GND_POWER_1 层
- en: Clock Crystal and Frequency
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 时钟晶体与频率
- en: 'To identify the external clock crystal wires and the frequency clocks, we again
    refer to the datasheet we sourced a previously. Search for “clock/CLK/XTAL,” and
    you’ll discover four interesting external oscillator pins: XTAL and CKIL (and
    their complementary inputs EXTAL and ECKIL), and two general-purpose inputs, CKIH1
    and CKIH2\. Searching for those inputs, we find the “i.MX53 System Development
    User’s Guide” as *MX53UG.pdf*. The section on these inputs, in turn, refers to
    the “i.MX53 Reference Manual,” which we find as *iMX53RM.pdf*. According to the
    reference manual, you program the latter inputs to supply a clock to various peripherals,
    such as the CAN network and SPDIF port. Looking at the board schematics, we find
    that (E)XTAL is connected to a 24 MHz oscillator, (E)CKIL is connected to a 32,768
    Hz oscillator, and CKIH1 and CKIH2 are pulled to ground. The USB armory schematics
    show that those pins are connected to two sets of pads, which correspond to two
    oscillators. Those oscillators are the rather huge components in [Figure 3-9](#figure3-9).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别外部时钟晶体线和频率时钟，我们再次参考之前获取的数据手册。搜索“clock/CLK/XTAL”，你将发现四个有趣的外部振荡器引脚：XTAL 和 CKIL（及其互补输入
    EXTAL 和 ECKIL），以及两个通用输入 CKIH1 和 CKIH2。通过搜索这些输入，我们找到了“i.MX53 系统开发用户指南”，文件名为 *MX53UG.pdf*。该部分内容提到的输入，再次引用了“i.MX53
    参考手册”，我们找到的文件是 *iMX53RM.pdf*。根据参考手册，你可以编程这些输入，为各种外设提供时钟，如 CAN 网络和 SPDIF 端口。查看板子原理图，我们发现（E）XTAL
    连接到一个 24 MHz 的振荡器，（E）CKIL 连接到一个 32,768 Hz 的振荡器，而 CKIH1 和 CKIH2 被拉到地面。USB armory
    原理图显示这些引脚连接到两组焊盘，对应两个振荡器。这些振荡器就是[图 3-9](#figure3-9)中非常大的组件。
- en: '![f03009](image_fi/278748c03/f03009.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![f03009](image_fi/278748c03/f03009.png)'
- en: 'Figure 3-9: Oscillators have a white silkscreen box around them.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-9：振荡器周围有白色丝印框。
- en: 'Clock control is significant for two main purposes: synchronizing side-channel
    measurements to the device clock and facilitating clock fault-injection experiments.
    In this case, the EXTAL input goes through a frequency multiplier, which then
    clocks the ARM core. Here, the PLLs (phase-locked loops) that turn the external
    frequency into an internal clock may eat up any weirdness in your clock, so clock
    fault injection may be a no-go, but we can still insert our own clock into these
    pins to provide more precise clock synchronization to count clock cycles. If you
    are going for clock synchronization, you don’t even need to remove the crystal
    on the board. You can feed in a clock to the crystal circuit, and it will force
    the crystal oscillator circuit to run on the clock pulses that you will inject.
    (See Chapter 4 for more on clock fault injection.)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟控制对两个主要目的至关重要：同步设备时钟的侧信道测量，以及促进时钟故障注入实验。在这种情况下，EXTAL 输入通过一个频率倍增器，然后为 ARM 核提供时钟。这里的
    PLL（锁相环）将外部频率转换为内部时钟，可能会消除时钟中的任何异常，因此时钟故障注入可能无法进行，但我们仍然可以将自己的时钟注入到这些引脚中，以提供更精确的时钟同步来计数时钟周期。如果你要进行时钟同步，甚至不需要移除板上的晶体。你可以将时钟信号输入到晶体电路中，它将迫使晶体振荡器电路按照你注入的时钟脉冲运行。（更多关于时钟故障注入的内容，请参见第
    4 章。）
- en: The I2C Interface
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: I2C 接口
- en: We need to determine where the I2C interface from the main SoC connects to another
    integrated circuit (IC) and what the protocol on that interface is. The USB armory
    schematics show that pins 30 and 31 are I2C, and the i.MX53 datasheet shows three
    I2C controllers. We can trace the layout to find a connection to V3, which is
    named EIM_D21 and is one of the GPIOs. EIM_D21 is either SPI or I2C-1\. This is
    an example of a multiplexed pin; the SoC itself can be configured to talk various
    low-level protocols on the pin.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确定主 SoC 的 I2C 接口连接到另一个集成电路（IC）的位置，并且确定该接口上的协议是什么。USB armory 原理图显示第 30 和
    31 引脚是 I2C，i.MX53 数据手册显示有三个 I2C 控制器。我们可以追踪布局，找到连接到 V3 的线，该接口名为 EIM_D21，是 GPIO
    之一。EIM_D21 要么是 SPI，要么是 I2C-1。这是一个多路复用引脚的例子；SoC 本身可以配置为在该引脚上执行各种低级协议。
- en: As for the high-level protocol, we have to dig a little deeper—specifically,
    into the PMIC datasheet. The PMIC is identified as an LTC3589 in the PCB schematic,
    and the datasheet is called *3589fh.pdf*. In the “I2C Operation” section, the
    datasheet precisely defines the protocol.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 至于高级协议，我们需要深入挖掘——具体来说，是查看 PMIC 数据手册。PMIC 在 PCB 原理图中标识为 LTC3589，数据手册名为 *3589fh.pdf*。在
    “I2C 操作”部分，数据手册详细定义了该协议。
- en: The Boot Configuration Pins
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动配置引脚
- en: Knowing where the boot configuration pins are, where they are connected on the
    PCB, and what boot mode and configurations the pins select is really helpful.
    For now, we’re providing an example of how to find data; don’t worry about understanding
    the technicalities.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 了解引导配置引脚的位置、它们在PCB上的连接方式，以及这些引脚选择的引导模式和配置是非常有帮助的。目前，我们提供了一个如何查找数据的示例；无需担心理解技术细节。
- en: The i.MX53 datasheet (*IMX53IEC.pdf*) mentions various BOOT_MODE and BOOT_CFG
    pins, but it does not define what they do. In the schematics for the Mk I, we
    find that BOOT_MODE pins (C18 and B20) are not connected to power or ground on
    the PCB.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: i.MX53的数据手册（*IMX53IEC.pdf*）提到各种BOOT_MODE和BOOT_CFG引脚，但没有定义它们的功能。在Mk I的原理图中，我们发现BOOT_MODE引脚（C18和B20）没有连接到电源或地线。
- en: Let’s first find out what it means that BOOT_MODE is not connected. The i.MX53
    datasheet has a table that claims for BOOT_MODE0 and BOOT_MODE1, the “config.
    value” is 100 kΩ PD. PD stands for *pulldown*, so if the pin is not connected,
    it is internally pulled down to ground. This means that the BOOT_MODE0 and BOOT_MODE1
    pins are at logical 0 when not connected. The datasheet mentions nothing more,
    but the i.MX53 reference manual (*iMX53RM.pdf*, which is 5,100 pages of goodness)
    gives the high-level boot sequence and shows that BOOT_MODE[1:0]=0b00 means *internal
    boot*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先弄清楚BOOT_MODE未连接意味着什么。i.MX53的数据手册中有一张表格，声明对于BOOT_MODE0和BOOT_MODE1，"配置值"为100
    kΩ下拉电阻。PD代表*下拉*，因此如果引脚未连接，它会被内部下拉到地。这意味着当引脚未连接时，BOOT_MODE0和BOOT_MODE1引脚的逻辑值为0。数据手册没有提及更多信息，但i.MX53参考手册（*iMX53RM.pdf*，这是一本5100页的好资料）提供了高级引导序列，显示BOOT_MODE[1:0]=0b00表示*内部引导*。
- en: Now, for BOOT_CFG, the i.MX53 datasheet shows that all of these BOOT_CFG pins
    are connected to pins starting with EIM_, such as EIM_A21\. Keep in mind this
    is a pin name, not a coordinate. If you keep searching the datasheet, you’ll see
    that EIM_A21 is a name of the pin at location AA4 (this AA4 is a location on the
    chip, a BGA ball). With that information, we can look at the Mk I schematic to
    see how these pins are connected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于BOOT_CFG，i.MX53的数据手册显示，所有这些BOOT_CFG引脚都连接到以EIM_开头的引脚，例如EIM_A21\。请记住，这只是引脚的名称，而不是坐标。如果继续查找数据手册，你会发现EIM_A21是位于AA4位置的引脚名称（这个AA4是芯片上的位置，指的是BGA焊球）。有了这些信息，我们可以查看Mk
    I原理图，看看这些引脚是如何连接的。
- en: It turns out that all BOOT_CFG pins are grounded, with the exception of BOOT_CFG2[5]/EIM_DA0/Y8
    and BOOT_CFG1[6]/EIM_A21/AA4, which are pulled up to 3.3 V through a resistor.
    These bits are set to 1, whereas all other BOOT_CFG bits are set to 0\. Searching
    for BOOT_CFG in the reference manual, we find Table 7-8, “Boot Device Selection,”
    which has a line specifying that BOOT_CFG1[7:4] set to 0100 or 0101 means to boot
    from the SD card (written in the table as 010X). The effect of setting BOOT_CFG2[5]
    seems to depend on the boot mode selected. Since we just found out it’s booting
    from the SD card, Table 7-15, “ESDHC Boot eFUSE Descriptions,” is relevant. It
    indicates that BOOT_CFG2[5]=1 means we are using a 4-bit bus width on the SD card.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，除了BOOT_CFG2[5]/EIM_DA0/Y8和BOOT_CFG1[6]/EIM_A21/AA4这两个引脚外，所有BOOT_CFG引脚都接地。BOOT_CFG2[5]和BOOT_CFG1[6]通过一个电阻上拉到3.3V。这些位被设置为1，而所有其他BOOT_CFG位被设置为0。在参考手册中查找BOOT_CFG，我们找到了第7-8表，“引导设备选择”，其中有一行指定BOOT_CFG1[7:4]设置为0100或0101表示从SD卡引导（在表中写为010X）。设置BOOT_CFG2[5]的效果似乎取决于所选择的引导模式。既然我们刚刚发现是从SD卡引导，那么第7-15表，“ESDHC引导eFUSE描述”，是相关的。它指出BOOT_CFG2[5]=1表示我们使用的是SD卡的4位总线宽度。
- en: And remember that MOD pin for which we couldn’t find proper information? That
    reference manual has everything you want to know about it and more, under the
    sjc_mod pin, which also confirms the information we found before. Don’t despair
    if you can’t find what you need at first.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得那个我们找不到相关信息的MOD引脚吗？参考手册中有你想知道的所有信息，甚至更多，关于sjc_mod引脚的描述也确认了我们之前找到的信息。如果你一开始找不到需要的信息，别灰心。
- en: Those are just a few examples of the kinds of questions you can answer from
    various sources of documentation. Datasheets are usually easy to find; schematics
    and PCB layouts and/or reference designs are rare. However, you can reverse engineer
    information as well, as you’ll see in the next section, “Opening the Case.”
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是你可以从不同文档来源回答的一些问题的例子。数据手册通常很容易找到；而原理图、PCB布局和/或参考设计比较少见。不过，你也可以通过逆向工程来获取信息，正如你将在下一节“打开外壳”中看到的那样。
- en: Opening the Case
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开外壳
- en: As with any reverse engineering task, your objective is to get into the system
    designer’s head. Through research, clues, and a little guesswork, the idea is
    to understand just enough to complete your task. We are not reverse engineering
    for the purpose of cloning or fully extracting schematics; we just want to know
    how to modify and/or attach to a PCB in order to reach our goal. If you are lucky,
    someone has looked at this device (or a similar device) before, and as mentioned
    earlier, you can try to find teardowns of the products already posted.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何逆向工程任务一样，你的目标是进入系统设计者的思维。通过研究、线索和一点猜测，目的是理解足够的信息以完成任务。我们进行逆向工程的目的不是为了克隆或完整提取电路图，而是希望知道如何修改和/或连接到PCB，从而实现我们的目标。如果幸运的话，可能有人已经研究过这个设备（或类似设备），如前所述，你可以尝试查找已有的拆解报告。
- en: What starts out as a collection of IC serial numbers, a handful of external
    ports, and a seemingly infinite number of resistors and capacitors will turn into
    an understanding of the system. And with a bit of luck, you can find a test point
    or debug port that will provide even more access.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能只有一堆集成电路的序列号、少量外部端口，以及看似无穷无尽的电阻和电容，但随着时间的推移，你将逐渐理解系统的工作原理。如果运气好，你还可以找到一个测试点或调试端口，进一步获得更多的访问权限。
- en: Identifying ICs on the Board
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别电路板上的集成电路
- en: We don’t use one specific device to demonstrate the technique for identifying
    ICs, so if you want to follow along, find a cheap IoT (internet of things) or
    similar device that you won’t mind ripping open.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有使用特定的设备来演示识别IC的技巧，因此，如果你想跟着做，可以找一款便宜的物联网（IoT）设备或类似设备，确保你不介意将其拆开。
- en: Most PCBs you’ll encounter in modern electronics are mounted on the PCB’s surface,
    in contrast with the through-hole mounting of times past. This is called *surface-mount
    technology (SMT)*, and any device on it is called a *surface-mount device (SMD)*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你在现代电子设备中遇到的大多数印刷电路板（PCB）都是表面贴装的，与过去的通孔插装方式不同。这种技术叫做*表面贴装技术（SMT）*，其上任何元件都叫做*表面贴装元件（SMD）*。
- en: Once you’ve opened a device, you’ll usually see a single PCB with a bunch of
    components (check the front and back of the PCB), the largest of which will likely
    be the main SoC, DRAM, and external flash storage, as shown in [Figure 3-10](#figure3-10).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你打开设备，通常会看到一块单独的PCB，上面有许多组件（检查PCB的正反面），其中最大的组件可能是主SoC、DRAM和外部闪存存储，如[图 3-10](#figure3-10)所示。
- en: In the top center of [Figure 3-10](#figure3-10) is a DSPGroup DVF97187AA2ANC
    main SoC 1. To the left of that is an EtronTech EM63A165TS-6G SDRAM in a TSSOP
    package 2, and above the SDRAM is Winbond 25Q128JVSQ flash memory in an SOIC-8
    package 3. In addition, there is a Realtek RTL8304MB Ethernet controller 4. This
    particular device is a very low-cost IP phone, which might explain why the SoC
    and SDRAM are brands you’ve likely not heard of before.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 3-10](#figure3-10)的顶部中央位置，是一款DSPGroup DVF97187AA2ANC主SoC 1。其左侧是EtronTech
    EM63A165TS-6G SDRAM，采用TSSOP封装 2，SDRAM上方是Winbond 25Q128JVSQ闪存，采用SOIC-8封装 3。除此之外，还有一款Realtek
    RTL8304MB以太网控制器 4。这款设备是一个非常低成本的IP电话，这或许能解释为何其SoC和SDRAM是你可能从未听说过的品牌。
- en: The first step is to read the die markings on the chips. You can usually get
    pretty far with a phone camera. [Figure 3-11](#figure3-11) shows photos of another
    device, an HDMI RCA audio splitter, taken with a regular phone camera and microscope
    app.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是读取芯片上的标记。你通常可以通过手机摄像头得到相当清晰的图像。[图 3-11](#figure3-11)展示了另一款设备——HDMI RCA 音频分配器的照片，这些照片是用普通手机摄像头和显微镜应用程序拍摄的。
- en: '![f03010](image_fi/278748c03/f03010.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![f03010](image_fi/278748c03/f03010.png)'
- en: 'Figure 3-10: Identifying ICs on the board'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-10：识别电路板上的集成电路（IC）
- en: '![f03011](image_fi/278748c03/f03011.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![f03011](image_fi/278748c03/f03011.png)'
- en: 'Figure 3-11: Die markings: on the left, with flash and a good angle; in the
    middle, with flash and bad angle; on the right, with natural light'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-11：芯片标记：左侧为闪光灯和良好角度；中间为闪光灯和不良角度；右侧为自然光
- en: As you can see, playing with different angles and with the flashlight on or
    off, you should be able to take a suitable photo for reading die markings. Alternatively,
    cheap USB microscope cameras will do the job; see Appendix A for hardware information.
    The photos in [Figure 3-12](#figure3-12) were taken with such a camera.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过改变拍摄角度并开关手电筒，你应该能拍出适合读取芯片标记的照片。另一种选择是使用便宜的USB显微镜摄像头；有关硬件信息，请参见附录A。[图
    3-12](#figure3-12)中的照片就是用这种相机拍摄的。
- en: '![f03012](image_fi/278748c03/f03012.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![f03012](image_fi/278748c03/f03012.png)'
- en: 'Figure 3-12: Photos taken with a USB microscope camera'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-12：使用USB显微镜摄像头拍摄的照片
- en: Once you have the die markings, employ your reconnaissance skills to dig up
    information on the part. Especially if you’re doing this for the first time, try
    to identify all of the ICs and their datasheets. Even though most of the smaller
    components may be insignificant from a security point of view, you’ll learn a
    bit about all that’s needed to make a device tick. We’ve learned much about voltage
    regulators and other funny little ICs this way.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了芯片上的标记，就可以运用你的侦察技能来挖掘该部件的信息。尤其是如果这是你第一次做这件事，试着识别所有的 IC 及其数据手册。即使大多数较小的组件从安全角度来看可能并不重要，你也会了解一些让设备正常工作的必要内容。我们通过这种方式学到了很多关于电压调节器和其他一些有趣的小
    IC 的知识。
- en: For some chips, it’s a little trickier to get to the main IC because of a heatsink
    or protective potting. You can remove heatsinks relatively easily, either by unscrewing
    them or gently pulling them off the IC. If the heatsink is stuck on (typical with
    small devices), a twisting motion will help remove it instead of trying to pry
    or pull it up directly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些芯片，由于散热片或保护性封装，接触主芯片会有些棘手。你可以通过拆卸散热片，通常是旋开螺丝或轻轻拉起它来轻松去除。如果散热片卡住了（这种情况常见于小型设备），可以通过扭动的方式来去除，而不是直接撬或拉起它。
- en: You’ll encounter protective potting in higher-security systems where the manufacturer
    wants to avoid access to the IC. Simply chipping away at it may be unsuccessful,
    but you’ll likely find heating it up with a heat gun nicely softens the epoxy,
    and you can then remove it with a tool such as a dental pick. If you want to remove
    the epoxy completely, try a chemical such as Xylene or paint removers (available
    in hardware stores).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在高安全性的系统中，你会遇到保护性封装，制造商希望避免对芯片的访问。简单地剥离它可能不会成功，但你很可能会发现，用热风枪加热后可以很好地软化环氧树脂，然后可以用牙科小工具等工具将其去除。如果你想完全去除环氧树脂，可以尝试使用像二甲苯或去漆剂这样的化学品（这些在五金店有售）。
- en: 'Small Leaded Packages: SOIC, SOP, and QFP'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小型引脚封装：SOIC、SOP 和 QFP
- en: In your quest for IC identification, you’ll encounter various types of beasts.
    Identifying the packages is useful for several reasons for the hardware hacker.
    First, you can find this information useful when searching for datasheets. Second,
    the type of package can actually affect what attacks you can perform. Some of
    the very tiny packages provide almost chip-level access, and probes we’ll discuss
    in later chapters are easier to use on these tiny packages. [Figure 3-13](#figure3-13)
    shows some of the main small leaded packages you’ll find.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在你进行 IC 识别时，你会遇到各种类型的封装。识别这些封装对硬件黑客有几个方面的用途。首先，你可以在搜索数据手册时用到这些信息。其次，封装类型实际上会影响你能够执行的攻击。有些非常小的封装提供了几乎芯片级的访问权限，我们将在后续章节中讨论的探针在这些小封装上也更易于使用。[图
    3-13](#figure3-13) 显示了你可能遇到的一些主要小型引脚封装。
- en: '![f03013](image_fi/278748c03/f03013.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![f03013](image_fi/278748c03/f03013.png)'
- en: 'Figure 3-13: Small leaded packages: SOIC, TSSOP, and TQFP styles'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-13：小型引脚封装：SOIC、TSSOP 和 TQFP 样式
- en: All of the packages in [Figure 3-13](#figure3-13) have leads on them; the difference
    is the relative size between leads (pitch) and the leads’ locations. Many variants
    exist within these families that we also won’t go into here, because for our purposes,
    they are equivalent. For example, you might see references to both *thin quad
    flat pack (TQFP)* and *plastic quad flat pack (PQFP**)*, which look almost identical
    and have similar pin pitch, counts, and package sizes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-13](#figure3-13) 中的所有封装都有引脚；区别在于引脚之间的相对大小（间距）和引脚的位置。这个系列中有许多不同的变种，我们在这里不深入讨论，因为对于我们的目的来说，它们是等效的。例如，你可能会看到
    *薄型四方扁平封装（TQFP）* 和 *塑料四方扁平封装（PQFP）* 的提及，它们几乎是一样的，并且具有相似的引脚间距、引脚数量和封装尺寸。'
- en: The largest is the *small outline integrated circuit (SOIC)*, which has pins
    on two sides of the package and typically has a pin-to-pin spacing of 1.27 mm.
    This package is nice because you can fit grabber clips on it. Often SPI flash
    memory chips are in 8- or 16-pin wide SOIC packages.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的是 *小型外形集成电路（SOIC）*，它在封装的两侧都有引脚，通常引脚间距为 1.27 毫米。这个封装很好，因为你可以在上面夹取抓取夹。通常，SPI
    闪存芯片采用 8 引脚或 16 引脚宽的 SOIC 封装。
- en: A smaller version of the SOIC is the *small outline package (SOP**)*, often
    in the thin SOP (TSOP) or thin-shrink SOP (TSSOP) variant. All of these also have
    pins only on two edges, but with pin pitches typically in the 0.4 mm to 0.8 mm
    range. Wide TSOP packages with 48 pins, as shown in [Figure 3-14](#figure3-14),
    are almost certain to be parallel flash memory chips.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: SOIC的一个更小版本是*小外形封装（SOP）*，通常为薄型SOP（TSOP）或薄缩型SOP（TSSOP）。这些封装也仅在两个边缘有引脚，且引脚间距通常在0.4
    mm到0.8 mm之间。宽型TSOP封装（如[图 3-14](#figure3-14)所示的48引脚封装）几乎肯定是并行闪存芯片。
- en: '![f03014](image_fi/278748c03/f03014.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![f03014](image_fi/278748c03/f03014.png)'
- en: 'Figure 3-14: A 48-pin TSOP package'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-14：48引脚TSOP封装
- en: Finally, the *quad flat pack (QFP)* package has legs on all four edges and is
    often seen in the *thin QFP (TQFP)* or *plastic QFP (PQFP)* package. These have
    small changes in material or thickness, but the general form factor is the same.
    Pin pitch typically varies within the 0.4 mm to 0.8 mm range.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*四方扁平封装（QFP）*的封装在四个边缘都有引脚，通常见于*薄型QFP（TQFP）*或*塑料QFP（PQFP）*封装。这些封装在材料或厚度上有小的变化，但整体外形保持不变。引脚间距通常在0.4
    mm到0.8 mm之间。
- en: The TQFP’s internal construction basically has a small central IC die, which
    is connected to a *leadframe*. If you sand off sections of the IC, you can see
    the relative sizes, as shown in [Figure 3-15](#figure3-15) for a TQFP-64 package.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: TQFP的内部结构基本上包含一个小的中央IC芯片，它通过*引线框*与引脚连接。如果你打磨掉IC的一部分，你可以看到它的相对大小，如[图 3-15](#figure3-15)所示，这是一个TQFP-64封装。
- en: If you want to keep things more intact, you can also use acid decapsulation,
    but sandpaper is something almost everyone can safely use.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想保持物品更完好无损，你也可以使用酸性脱封装方法，但砂纸是几乎每个人都能安全使用的工具。
- en: '[Figure 3-16](#figure3-16) is a simple diagram of the SOIC/SOP/TQFP’s internal
    construction and shows the bonding wires connecting the chip to the leads. What
    was clearly removed in [Figure 3-15](#figure3-15) was any hint of bonding wires
    when the chip was sanded from the top down.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-16](#figure3-16)是SOIC/SOP/TQFP内部结构的简易示意图，展示了连接芯片和引脚的键合线。在[图 3-15](#figure3-15)中，显然移除了芯片从顶部往下打磨时所有的键合线痕迹。'
- en: '![f03015](image_fi/278748c03/f03015.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![f03015](image_fi/278748c03/f03015.png)'
- en: 'Figure 3-15: QFP package; from left to right: top sanded off, cross-section,
    and unharmed'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-15：QFP封装；从左到右：顶部打磨掉、截面图和完好无损
- en: '![f03016](image_fi/278748c03/f03016.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![f03016](image_fi/278748c03/f03016.png)'
- en: 'Figure 3-16: Internal construction of an SOIC/SOP/TQFP package'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-16：SOIC/SOP/TQFP封装的内部结构
- en: 'No-Lead Packages: SO and QFN'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无引脚封装：SO和QFN
- en: No-lead packages are similar to the previous SOIC/QFP packages, but instead
    of leads, a pad underneath the chip is soldered onto the PCB. This pad often (but
    not always) extends just to the edge of the device, so you’ll normally see a small
    protruding solder joint on the edge of the chip with those packages. [Figure 3-17](#figure3-17)
    is a simple diagram of these no-lead devices.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 无引脚封装与之前的SOIC/QFP封装类似，但不使用引脚，而是将芯片下方的焊盘焊接到PCB上。这个焊盘通常（但并不总是）延伸到设备的边缘，所以你通常会看到芯片边缘有一个小的凸起焊点。
    [图 3-17](#figure3-17)是这些无引脚设备的简易示意图。
- en: '![f03017](image_fi/278748c03/f03017.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![f03017](image_fi/278748c03/f03017.png)'
- en: 'Figure 3-17: No-lead package'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-17：无引脚封装
- en: The *small outline no-lead (SON)* package has connections on only two edges.
    These devices have typical pitches in the 0.4 mm to 0.8 mm range. As in other
    packages, many variants exist, such as *thin SON (TSON)*. You may also see various
    custom pin layouts where pads are missing. The SON package almost always has a
    central thermal pad underneath it that is also soldered to the PCB, meaning you
    will likely need hot air to solder or remove this package. Because you can’t reach
    the large hidden central pad with a soldering iron, you need some method of heating
    it indirectly, through either the device package or the PCB.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*小外形无引脚（SON）*封装仅在两个边缘有连接。此类设备的典型引脚间距在0.4 mm到0.8 mm之间。和其他封装一样，也有许多变体，例如*薄型SON（TSON）*。你也可能会看到各种定制的引脚布局，其中一些焊盘可能缺失。SON封装几乎总是有一个中央热焊盘，焊盘下方通常会焊接到PCB上，这意味着你很可能需要使用热风来焊接或拆卸这个封装。由于你无法用焊接铁触及到隐藏的中央焊盘，你需要通过某种方法间接加热它，可以通过设备封装或PCB进行加热。'
- en: Also, pay attention to the WSON package type, which officially seems to be called
    both *very-very thin SON* and *wide SON*. This package is much wider than normal
    and often has a 1.27 mm pitch. It’s frequently used for SPI flash memory chips.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意WSON封装类型，官方似乎同时称其为*超薄SON*和*宽型SON*。该封装比普通的SON封装宽，通常具有1.27 mm的引脚间距，常用于SPI闪存芯片。
- en: The *quad flat no-lead (QFN)* package has connections on four edges. These devices
    have typical pitches in the 0.4 mm to 0.8 mm range. Again, you will almost always
    see a thermal pad in the center of these devices. They are widely used and can
    be anything from the main microcontroller to a power-switching regulator.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*四边无引脚封装（QFN）* 包含四个边缘的连接。这些设备的典型引脚间距在 0.4 毫米到 0.8 毫米之间。同样，你几乎总能看到这些设备中央有一个热垫。它们广泛应用，可以是从主微控制器到电源开关稳压器的任何设备。'
- en: Ball Grid Array
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 球栅阵列
- en: '*Ball grid array (BGA)* packages have balls on the bottom of the chip, as shown
    in [Figure 3-18](#figure3-18), and you won’t be able to see them from the top.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*球栅阵列（BGA）* 封装的芯片底部有焊球，如[图 3-18](#figure3-18)所示，你从顶部无法看到它们。'
- en: '![f03018](image_fi/278748c03/f03018.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![f03018](image_fi/278748c03/f03018.png)'
- en: 'Figure 3-18: BGA package'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-18：BGA 封装
- en: You can see the edge balls if you can get the angle right, as shown in [Figure
    3-19](#figure3-19), where you can also see that there is actually a smaller *carrier
    PCB*. The BGA chip itself is composed of a smaller PCB with the chip mounted onto
    it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能调整好角度，就能看到边缘焊球，如[图 3-19](#figure3-19)所示，在那里你还可以看到其实有一个更小的*载体 PCB*。BGA 芯片本身由一个更小的
    PCB 组成，芯片被安装在其上。
- en: '![f03019](image_fi/278748c03/f03019.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![f03019](image_fi/278748c03/f03019.png)'
- en: 'Figure 3-19: View of edge balls'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-19：边缘焊球视图
- en: BGA parts are frequently used for the main processor or SoC. Some eMMC and flash
    devices will also use a BGA package, and smaller BGAs hanging off the side of
    the main processor are often DRAM chips in more complex systems.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: BGA 元件常用于主处理器或 SoC。一些 eMMC 和闪存设备也会使用 BGA 封装，而在更复杂的系统中，挂在主处理器旁边的较小 BGA 通常是 DRAM
    芯片。
- en: There are actually several variants of BGA devices, which can be important for
    power analysis and fault injection, so we’ll detail that construction difference
    here. Vendors use slightly different names, but we keep with the Fujitsu naming
    process here (*a810000114e-en.pdf*), which typically maps to names other vendors
    use.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，BGA 设备有几个变体，这对功率分析和故障注入可能很重要，因此我们将在此详细说明它们的构造差异。供应商使用略有不同的名称，但我们在这里遵循富士通的命名方式（*a810000114e-en.pdf*），这通常与其他供应商使用的名称相对应。
- en: Plastic BGA and Fine Pitch BGA
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 塑料 BGA 和精细引脚 BGA
- en: '*Plastic BGA (PBGA)* devices typically have a 0.8 mm to 1.0 mm pitch (see [Figure
    3-20](#figure3-20)). The chip is internally bonded to a carrier board that has
    the solder balls on it.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*塑料 BGA（PBGA）* 设备的引脚间距通常为 0.8 毫米到 1.0 毫米（见[图 3-20](#figure3-20)）。芯片与载体板内部连接，载体板上有焊球。'
- en: '![f03020](image_fi/278748c03/f03020.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![f03020](image_fi/278748c03/f03020.png)'
- en: 'Figure 3-20: Plastic BGA'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-20：塑料 BGA
- en: '*Fine pitch BGAs (FPBGAs)* are similar to PBGAs, but with a finer grid (typically
    0.4 mm to 0.8 mm). Again, the device is mounted on a carrier PCB.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*精细引脚间距 BGA（FPBGA）* 与 PBGAs 相似，但其网格更精细（通常为 0.4 毫米到 0.8 毫米）。同样，该设备安装在载体 PCB
    上。'
- en: Thermally Enhanced Ball Grid Array
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 热增强型球栅阵列
- en: The *thermally enhanced ball grid array (TEBGA)* shown in [Figure 3-21](#figure3-21)
    has a noticeable metal area on the BGA itself.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*热增强型球栅阵列（TEBGA）* 如[图 3-21](#figure3-21)所示，BGA 本身具有明显的金属区域。'
- en: '![f03021](image_fi/278748c03/f03021.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![f03021](image_fi/278748c03/f03021.png)'
- en: 'Figure 3-21: Thermally enhanced ball grid array'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-21：热增强型球栅阵列
- en: This metal area is part of an integrated heat spreader, which helps provide
    a better thermal connection to both the bottom solder balls and a heatsink mounted
    on top of the package.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个金属区域是集成热扩散器的一部分，有助于提供更好的热连接，既连接到底部的焊球，又连接到封装顶部的散热器。
- en: Flip-Chip Ball Grid Array
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 翻转芯片球栅阵列（Flip-Chip BGA）
- en: '*Flip-chip BGAs (FC-BGAs)*, as shown in [Figure 3-22](#figure3-22), do away
    with the internal bond wires. Instead, the chip itself is effectively a much smaller
    BGA (which would be difficult to work with) that is soldered on to the carrier
    PCB. The difference here is that the internal “LSI chip” is *upside down* compared
    to the previous BGA devices.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*翻转芯片 BGA（FC-BGA）* 如[图 3-22](#figure3-22)所示，去除了内部的连接线。相反，芯片本身实际上是一个更小的 BGA（这会很难操作），并被焊接到载体
    PCB 上。这里的区别在于，与之前的 BGA 设备相比，内部的“LSI 芯片”是*倒置的*。'
- en: '![f03022](image_fi/278748c03/f03022.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![f03022](image_fi/278748c03/f03022.png)'
- en: 'Figure 3-22: Flip-chip ball grid array'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-22：翻转芯片球栅阵列
- en: On other packages, such as PBGA/FBGA/TEBGA, internal bond-wires touch the “top
    metal” layer of the internal LSI chip. On the FC-BGAs, that top metal layer is
    on the bottom, with very small solder balls mounted on it. This type of package
    also may have small integrated passives, such as decoupling capacitors. With FC-BGAs,
    it may be possible to remove the heat spreader or “lid” to get closer to the actual
    chip for fault injection or side-channel analysis.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他封装中，如PBGA/FBGA/TEBGA，内部的引线会接触到内部LSI芯片的“顶部金属”层。在FC-BGA中，该金属层位于底部，上面装有非常小的焊球。这种封装类型还可能包含小型的集成无源元件，例如去耦电容。对于FC-BGA封装，可能可以去除散热器或“盖子”，以更接近实际芯片进行故障注入或侧信道分析。
- en: Chip Scale Packaging
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 芯片级封装
- en: '*Chip scale packaging (CSP)* is effectively where you are given a piece of
    the sawed-off chip wafer. In the internal structure shown in [Figure 3-23](#figure3-23),
    there is no encapsulant on the top side.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*芯片级封装 (CSP)* 本质上是将切割下来的芯片晶圆的一部分提供给你。在[图3-23](#figure3-23)所示的内部结构中，顶部没有封装材料。'
- en: '![f03023](image_fi/278748c03/f03023.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![f03023](image_fi/278748c03/f03023.png)'
- en: 'Figure 3-23: CSP internal structure'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-23：CSP内部结构
- en: The provided device is almost no bigger than it physically needs to be, and
    typically some very fine-pitch balls on the bottom of the CSP provide the connection
    to the PCB. The name CSP may have modifiers, such as the *wafer-level CSP (WLCSP)*.
    Think of CSPs as the LSI chip part of the flip-chip BGA. They have a very small
    pitch (0.4 mm or finer typically). You can often easily spot these devices, as
    the surface will look noticeably different from a regular BGA.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的设备几乎只有它物理上所需要的大小，通常CSP底部会有一些非常细小的球状连接焊点，用于连接到PCB。CSP这个名称可能有一些修饰词，如 *晶圆级CSP
    (WLCSP)*。可以将CSP视为翻转芯片BGA的LSI芯片部分。它们的引脚间距非常小（通常为0.4毫米或更细）。你通常可以很容易地识别这些设备，因为其表面与常规BGA有明显的不同。
- en: DIP, Through-Hole, and Others
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DIP、穿孔封装及其他
- en: The oldestpackages are through-hole, and you aren’t too likely to run into them
    on real products, especially for ICs. You *will* encounter the DIP package in
    hobby or kit products (such as an Arduino).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最早的封装是穿孔封装，尤其是IC封装中，现实产品中不太可能遇到它们。你*会*在爱好或套件产品（例如Arduino）中遇到DIP封装。
- en: Another relatively outdated technology is *plastic leaded chip carrier (PLCC)*,
    which can be either soldered directly to a PCB or placed in a socket. These devices
    were often used for microcontrollers, and if you are looking at an old product
    using an 8051 microcontroller, you may well run into one.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种相对过时的技术是 *塑料引脚芯片载体 (PLCC)*，它可以直接焊接到PCB上，或者插入插座中。这些设备常用于微控制器，如果你在查看一款使用8051微控制器的老旧产品，可能会遇到这种封装。
- en: Sample IC Packages on PCBs
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PCB上的示例IC封装
- en: Rather than provide a bunch of photos of parts by themselves, we thought it
    would be more useful to show what they look like in-circuit. Let’s look at four
    sample boards pulled from real products. [Figure 3-24](#figure3-24) shows a communications
    daughterboard from a smart lock.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有单独提供大量零件的照片，而是认为展示它们在电路板中的实际样子更为有用。让我们来看一下从实际产品中取出的四块样本板。[图3-24](#figure3-24)展示了一块来自智能锁的通信子板。
- en: '![f03024](image_fi/278748c03/f03024.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![f03024](image_fi/278748c03/f03024.png)'
- en: 'Figure 3-24: Example IC packages from a smart lock'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-24：智能锁的示例IC封装
- en: 'The three packages marked in [Figure 3-24](#figure3-24) are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-24](#figure3-24) 中标出的三个封装类型如下：'
- en: '**QFN package**: The main microcontroller on this device (EM3587).'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**QFN封装**：该设备的主要微控制器（EM3587）。'
- en: '**WSON package**: SPI flash chip (this package size is frequently used for
    SPI flash).'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**WSON封装**：SPI闪存芯片（这种封装尺寸常用于SPI闪存）。'
- en: '**BGA package**: We can’t see any edge connections, so it’s likely a small
    BGA.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**BGA封装**：我们无法看到任何边缘连接，因此很可能是一个小型BGA。'
- en: Let’s take a different smart lock device and see what we can find (see [Figure
    3-25](#figure3-25)).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们换一个不同的智能锁设备，看看能发现什么（见 [图3-25](#figure3-25)）。
- en: '![f03025](image_fi/278748c03/f03025.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![f03025](image_fi/278748c03/f03025.png)'
- en: 'Figure 3-25: IC package examples from another smart lock'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-25：另一款智能锁的IC封装示例
- en: '[Figure 3-25](#figure3-25) shows the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-25](#figure3-25) 显示了以下内容：'
- en: '**Eight-pin SOIC**: This might be SPI flash based on an eight-pin SOIC (the
    part number confirms it’s SPI flash).'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**八引脚SOIC**：这可能是基于八引脚SOIC的SPI闪存（零件编号确认它是SPI闪存）。'
- en: '**TQFP package**: The main microcontroller for this device.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**TQFP封装**：该设备的主要微控制器。'
- en: '**QFN package**: The co-processor chip (in this case, for audio).'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**QFN封装**：协处理器芯片（在这种情况下用于音频）。'
- en: '**Eight-pin wide SOIC package**: This is certainly SPI flash due to the wide
    package.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**八脚宽SOIC封装**：这肯定是SPI闪存，因为封装很宽。'
- en: '**TSOP/TSSOP package**: Unknown IC.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**TSOP/TSSOP封装**：未知IC。'
- en: '**TSON package**: Unknown IC.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**TSON封装**：未知IC。'
- en: Continuing with our consumer electronics examples, next let’s look at a board
    from a smart doorbell (see [Figure 3-26](#figure3-26)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 继续以我们消费电子的例子为例，接下来让我们看看智能门铃的一个电路板（见[图3-26](#figure3-26)）。
- en: '![f03026](image_fi/278748c03/f03026.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![f03026](image_fi/278748c03/f03026.png)'
- en: 'Figure 3-26: IC package examples from a smart doorbell'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-26：智能门铃的IC封装示例
- en: '[Figure 3-26](#figure3-26) shows the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-26](#figure3-26)展示了以下内容：'
- en: '**A very small BGA**: Unknown IC.'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非常小的BGA**：未知IC。'
- en: '**TSON-style very small device (pins on two sides only)**: Unknown IC.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**TSON风格的非常小设备（仅两侧有引脚）**：未知IC。'
- en: '**QFN-style very small device (pins on all four sides)**: Unknown IC.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**QFN风格的非常小设备（四面都有引脚）**：未知IC。'
- en: '**CSP package with an almost mirror-like finish**: The main microcontroller,
    BCM4354KKUBG. Underneath this device are 395 balls with 0.2 mm spacing (we told
    you CSP is small).'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CSP封装，几乎具有镜面般的光泽**：主要微控制器，BCM4354KKUBG。在这个设备下方有395个间距为0.2毫米的焊球（我们告诉过你，CSP很小）。'
- en: As a final example, [Figure 3-27](#figure3-27) shows a board from an automotive
    electronic control unit (ECU).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个例子，[图3-27](#figure3-27)展示了一块来自汽车电子控制单元（ECU）的电路板。
- en: '![f03027](image_fi/278748c03/f03027.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![f03027](image_fi/278748c03/f03027.png)'
- en: 'Figure 3-27: IC packages from an automotive ECU'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-27：汽车ECU的IC封装
- en: '[Figure 3-27](#figure3-27) shows the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-27](#figure3-27)展示了以下内容：'
- en: '**BGA package**: The main processor for this device.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**BGA封装**：该设备的主要处理器。'
- en: '**TSSOP package**: Digital flip-flop.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**TSSOP封装**：数字触发器。'
- en: '**QFP package (only the edge is visible here)**: Unknown IC.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**QFP封装（这里只显示边缘）**：未知IC。'
- en: '**SOIC package**: Digital logic gate.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SOIC封装**：数字逻辑门。'
- en: '**TSSOP package**: Two unknown ICs.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**TSSOP封装**：两个未知IC。'
- en: Identifying Other Components on the Board
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别电路板上的其他组件
- en: Now that you’ve looked at the main ICs, let’s explore some other components.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看过了主要的IC，让我们来看看其他一些组件。
- en: Ports
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 端口
- en: Ports are a good starting point for making connections to a device and understanding
    the function of the various components they interconnect. The ports for digital
    I/O are the most interesting, as they may be used for normal device communication
    or provide debugging interfaces.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 端口是连接设备并理解它们互联的各种组件功能的一个很好的起点。数字I/O端口最为有趣，因为它们可能用于常规设备通信，或者提供调试接口。
- en: Once you identify the port type based on its appearance, you typically find
    the type of protocol used on the port. (See Chapter 2 for a refresher on various
    port protocols.) If you can’t identify the port based on appearance alone, hook
    up an oscilloscope to measure voltages and recognize data patterns. Note the high
    and low voltages, as well as the duration of the shortest pulse you see. The shortest
    pulse will give you the *bitrate*, such as an 8.68 microsecond pulse, which translates
    into an 115,200 bitrate on a UART. The bitrate is typically the rate of toggling
    of a single bit; the shortest pulse normally indicates a 0 or 1\. We get the rate
    by taking the inverse. In this case, 1 / 0.00000868 = 115,207, and we round it
    to a standard baud rate of 115,200.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你基于外观识别了端口类型，你通常会找到端口上使用的协议类型。（请参见第2章，回顾各种端口协议。）如果仅凭外观无法识别端口，可以连接示波器来测量电压并识别数据模式。注意高电压和低电压，以及你看到的最短脉冲的持续时间。最短脉冲将告诉你*比特率*，例如一个8.68微秒的脉冲，这对应于UART上的115,200比特率。比特率通常是单个比特的翻转速率；最短脉冲通常表示0或1。我们通过取倒数来得到比特率。在这个例子中，1
    / 0.00000868 = 115,207，我们将其四舍五入为标准波特率115,200。
- en: Alternatively, trace the PCB lines from the port to an IC and then use information
    from the IC’s pinout to identify the port type.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以从端口追踪PCB线路到IC，然后利用IC的引脚分配信息来识别端口类型。
- en: Headers
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接头
- en: '*Headers* are basically internal ports and therefore are interesting to look
    at because they may expose some functionality that’s not intended for normal users
    but instead is included in the design for debugging, manufacturing, or repair.
    You may find, among others, JTAG, UART, and SPI/I2C ports internally. Sometimes
    headers are not actually installed on the PCB, but their solder pads are still
    there, so some easy soldering can provide access. [Figure 3-28](#figure3-28) shows
    an example of several surface-mount headers.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*头针*基本上是内部端口，因此它们很有趣，因为它们可能暴露出一些功能，这些功能并不是为普通用户设计的，而是为了调试、制造或维修而包含在设计中的。你可能会找到内部的JTAG、UART和SPI/I2C端口。有时，头针并没有实际安装在PCB上，但它们的焊盘仍然存在，因此通过一些简单的焊接即可提供访问。[图3-28](#figure3-28)展示了几个表面贴装头针的例子。'
- en: '![f03028](image_fi/278748c03/f03028.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![f03028](image_fi/278748c03/f03028.png)'
- en: 'Figure 3-28: PCB headers'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-28：PCB头针
- en: The middle header is marked JTAG. This header wasn’t mounted, but we soldered
    it onto the pads, which provided JTAG access to the main IC, as the IC did not
    have any memory read-out protection enabled. This particular header was an Ember
    Packet Trace Port Connector. See Appendix B for several handy header pinouts.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的头针标记为JTAG。这个头针并未安装，但我们将其焊接到焊盘上，从而为主IC提供了JTAG访问，因为该IC没有启用任何内存读取保护。这个特别的头针是Ember数据包跟踪端口连接器。有关更多实用的头针引脚排列，请参见附录B。
- en: Through-hole headers are easier to probe, but small devices probably need a
    surface-mount header. [Figure 3-29](#figure3-29) shows a classic UART header inside
    a device.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 穿孔头针更容易探测，但小型设备可能需要表面贴装头针。[图3-29](#figure3-29)展示了设备内部的经典UART头针。
- en: '![f03029](image_fi/278748c03/f03029.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![f03029](image_fi/278748c03/f03029.png)'
- en: 'Figure 3-29: A UART header in a device'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-29：设备中的UART头针
- en: The header is the four pins in a row marked with “J404” on the board (note that
    J404 is upside down in the figure). There is no “standard” pinout for this header.
    You’ll need to perform some reverse engineering of it. The pin on the left can
    be visually seen to connect to the larger “ground plane,” and you could confirm
    this with a multimeter. We’ll cover this later in the section “Mapping the PCB”
    on page 102.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 头针是电路板上标有“J404”的四个排针（请注意，图中的J404是倒置的）。这个头针没有“标准”引脚排列，你需要进行一些反向工程来确定它的引脚配置。左边的引脚可以通过肉眼看到连接到较大的“接地平面”，你可以用万用表确认这一点。我们将在后面“映射PCB”部分中详细讨论这个内容，见第102页。
- en: Analog Electronics
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟电子学
- en: Most of the small components you find are analog electronics (resistors and
    capacitors), although you can also find inductors, oscillators, transistors, and
    diodes as SMDs. Capacitors and resistors have specific characteristics pertinent
    to this book. The PCB shown in [Figure 3-30](#figure3-30) has many of them.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数你找到的小型组件都是模拟电子元件（电阻器和电容器），虽然你也可以找到作为表面贴装元件（SMD）存在的电感器、振荡器、晶体管和二极管。电容器和电阻器具有与本书相关的特定特性。[图3-30](#figure3-30)中的PCB上有许多这样的元件。
- en: Capacitors (like C31 in [Figure 3-30](#figure3-30)) can store and release little
    bits of charge, and they’re often used to filter a signal. Capacitors are like
    very fast and small rechargeable batteries. They can charge and discharge millions
    of times per second, which means any fast voltage swings are counteracted either
    by charging or discharging the capacitor. The effect is that of a “low-pass filter.”
    This is one of the reasons you’ll see a lot of capacitors around ICs, connected
    between the power supply and ground. In this function, they are called *decoupling
    capacitors*, and their role is to provide a localized source of power for the
    IC, which prevents electrical noise from being injected into the power line. They
    also help keep noise from other areas from reaching the IC. We discuss *voltage
    fault injection (VFI)* more in Chapter 5, but imagine that if VFI relies on fast
    changes in supply voltage, decoupling capacitors undo the effects of VFI. Therefore,
    we first remove as many decoupling capacitors as we can without letting the system
    become unstable.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 电容器（如[图3-30](#figure3-30)中的C31）可以储存和释放少量电荷，常用于过滤信号。电容器就像非常快速且小型的可充电电池。它们可以每秒充放电数百万次，这意味着任何快速的电压波动都会通过充电或放电电容器来抵消其影响。其效果类似于“低通滤波器”。这也是你会看到许多电容器出现在集成电路（IC）周围，连接在电源与接地之间的原因之一。在这种功能下，它们被称为*去耦电容器*，它们的作用是为IC提供局部的电源，以防止电噪声注入电源线。它们还帮助阻止其他区域的噪声影响到IC。如果电压故障注入（VFI）依赖于电源电压的快速变化，去耦电容器能够抵消VFI的影响，我们将在第5章进一步讨论*电压故障注入（VFI）*，但可以想象，如果VFI依赖于电压快速变化，去耦电容器则能够消除VFI的影响。因此，我们首先去除尽可能多的去耦电容器，而不让系统变得不稳定。
- en: '![f03030](image_fi/278748c03/f03030.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![f03030](image_fi/278748c03/f03030.png)'
- en: 'Figure 3-30: Surface-mount resistors and capacitors'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-30：表面贴装电阻和电容
- en: Resistors (like R26 in [Figure 3-30](#figure3-30)), as the name implies, resist
    the flow of current, and for our purposes, the most interesting functions are
    that of a shunt resistor, a pullup/pulldown resistor (explained in Chapter 2),
    and a zero-ohm resistor. Shunt resistors measure the current through an IC when
    doing side-channel analysis (see Chapter 8 for more details). Surface-mount resistors
    typically have a number printed on them that indicates the resistance value; for
    example, abc refers to ab × 10^c ohm resistance.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻器（如 [图 3-30](#figure3-30) 中的 R26），顾名思义，抵抗电流的流动，在我们的应用中，最有趣的功能是作为分流电阻、上拉/下拉电阻（见第二章解释）和零欧姆电阻。分流电阻用于在进行旁路分析时测量
    IC 的电流（有关更多细节，请参见第八章）。表面贴装电阻器通常在其上印有一个数字，表示电阻值；例如，abc 表示 ab × 10^c 欧姆电阻。
- en: 'Finally, zero-ohm resistors (like R29 in [Figure 3-30](#figure3-30)) may seem
    a bit mysterious because they offer no resistance; they are basically wires. Their
    raison d’être is allowing configuration of a board at manufacturing time: zero-ohm
    resistors can be installed using the same manufacturing techniques as other resistors.
    By placing them, or not placing them, an electrical circuit can be open or closed,
    which can be used, for instance, as a configuration input to ICs. (As an example,
    recall the section “The Boot Configuration Pins,” on page 85, regarding the BOOT_MODE
    of the NXP i.MX53.) A manufacturer can choose to have the same PCB design for
    debug and production boards but then use a zero-ohm resistor on the relevant pins
    to select between the boot modes of those boards. That’s why zero-ohm resistors
    are interesting to look for; they can change security-sensitive configurations
    because they are easily removed or created. A solder blob across nearby pads is
    sufficient to simulate a zero-ohm resistor.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，零欧姆电阻器（如 [图 3-30](#figure3-30) 中的 R29）可能看起来有些神秘，因为它们不提供任何电阻；它们基本上就是导线。它们的存在意义在于允许在制造时配置电路板：零欧姆电阻可以采用与其他电阻相同的制造技术进行安装。通过放置或不放置它们，可以将电路打开或关闭，这可以用于例如作为配置输入给
    IC。（举个例子，回想一下“引导配置引脚”部分，第 85 页，关于 NXP i.MX53 的 BOOT_MODE。）制造商可以选择使用相同的 PCB 设计用于调试板和生产板，但随后在相关引脚上使用零欧姆电阻来选择这些板的引导模式。这就是为什么零欧姆电阻特别值得关注；它们可以改变安全敏感的配置，因为它们容易被移除或创建。只需在相邻的焊盘之间放置一个焊锡球，就足以模拟一个零欧姆电阻。
- en: You also may encounter package size markings, such as *0603*. This refers to
    the rough physical size of the resistor or capacitor; for instance, 0603 is about
    0.6 × 0.3 mm. SMT components may go down to 0201, although that continues to be
    pushed smaller as technology improves and consumer devices get smaller.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可能会遇到封装尺寸标记，例如*0603*。这表示电阻或电容的物理尺寸；例如，0603大约是 0.6 × 0.3 毫米。表面贴装元件的尺寸可以小到 0201，尽管随着技术的进步和消费设备的变小，尺寸仍然在不断变小。
- en: PCB Features
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PCB 特性
- en: Other interesting features we see on top of PCBs include jumpers and test points.
    *Jumpers*(sometimes called *straps*) are used for configuring a PCB by opening
    or closing them as a particular circuit is open or closed. They perform exactly
    the same function as zero-ohm resistors, except they’re easily inserted or disconnected.
    They typically look like headers with two or three pins that have a small removable
    connector on them, which is used, for example, as an input to configure particular
    ICs (see BOOT_MODE described earlier for the NXP i.MX53). Jumpers are particularly
    interesting, as they may provide access to security-sensitive configurations.
    [Figure 3-31](#figure3-31) shows the pads where a jumper header labeled JP1 could
    be installed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 PCB 上看到的其他有趣特性包括跳线和测试点。*跳线*（有时称为*跳带*）用于通过开关它们来配置 PCB，随着特定电路的开闭，它们也会开闭。它们与零欧姆电阻的功能完全相同，只是它们更容易插入或断开。它们通常看起来像带有两到三个引脚的插头，这些引脚上有一个小的可拆卸连接器，用于例如配置特定的
    IC（请参见之前提到的 NXP i.MX53 的 BOOT_MODE）。跳线尤其有趣，因为它们可能提供访问安全敏感配置的途径。[图 3-31](#figure3-31)
    显示了可以安装标记为 JP1 的跳线插头的焊盘。
- en: '![f03031](image_fi/278748c03/f03031.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![f03031](image_fi/278748c03/f03031.png)'
- en: 'Figure 3-31: Jumper header pads'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-31：跳线插头焊盘
- en: '*Test points* are used during manufacturing, repair, or debugging to provide
    access to particular PCB traces. Test points can be as minimal as a pad on the
    PCB, which can be connected to using a pogo pin, full-blown header, or connector.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试点* 在制造、修复或调试过程中用于提供对特定PCB走线的访问。测试点可以非常简单，只有PCB上的一个焊盘，可以通过弹簧针、完整的连接器或插头进行连接。'
- en: '[Figure 3-32](#figure3-32) shows the exposed traces that can be used for probing.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-32](#figure3-32) 显示了可用于探测的暴露线路。'
- en: As you can see in the photo, test points can also be small, exposed metal components
    that an oscilloscope probe can touch.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，测试点也可以是小型的裸露金属组件，示波器探头可以接触到这些组件。
- en: '![f03032](image_fi/278748c03/f03032.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![f03032](image_fi/278748c03/f03032.png)'
- en: 'Figure 3-32: Test points'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-32：测试点
- en: Mapping the PCB
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制PCB地图
- en: 'Now let’s look at the PCB itself. The process of sleuthing the circuit design
    from the PCB is known as *reverse engineering*. In the section “Datasheets and
    Schematics” on page 77, we introduced schematics and layouts and how to read them.
    The board layout (encoded in a Gerber file) is sent to manufacturing facilities
    for production. It’s rare we’d have access to this (we cheated in the earlier
    example by using an open source product). We’re actually interested in the reverse
    process: from a physical product, we want to get back to (the security sensitive
    part of) the schematic.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下PCB本身。从PCB中推理电路设计的过程称为 *逆向工程*。在第77页的“数据表和原理图”一节中，我们介绍了原理图和布局以及如何阅读它们。板的布局（编码在Gerber文件中）会发送到制造工厂进行生产。我们很少能接触到这个文件（在之前的示例中，我们通过使用开源产品来“作弊”）。实际上，我们更感兴趣的是反向过程：从物理产品回推到（安全敏感部分的）原理图。
- en: This exercise is useful, as we often know there are certain signals on an IC
    we want to access, such as some of those boot mode pins we identified before.
    Or, we often know there is a debug or serial header on the IC, and we want to
    figure out the pinout of the header on the PCB.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程非常有用，因为我们通常知道某个IC上有我们想要访问的特定信号，比如之前我们标识的启动模式引脚。或者，我们通常知道IC上有一个调试或串行连接器，我们想要弄清楚PCB上该连接器的引脚排列。
- en: For the topics of fault injection and power analysis, we often need to target
    a certain power supply net. In this case, we might have one IC that is the power
    management IC, and we want to see which other ICs it is powering. For this purpose,
    we need to follow the power supply traces from one IC to another.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于故障注入和电源分析等主题，我们通常需要针对某个特定的电源网进行测试。在这种情况下，我们可能有一个电源管理IC，我们希望看到它供电的其他IC。为此，我们需要沿着电源走线从一个IC连接到另一个IC。
- en: The PCB exists to transport power and signals between its components (such as
    our IC and header that we just mentioned). It’s basically a sandwich of conductive
    material, isolating material, and components. The PCB consists of a couple to
    dozens of layers, each electrically isolated from each other. The *traces* look
    like lines on the PCB, and the *vias*look like holes in the PCB at the end of
    a trace (see [Figure 3-33](#figure3-33)). The vias connect to further traces on
    other layers inside or on the PCB. Typically, components are located on the front
    and back of the PCB.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: PCB的作用是传输电力和信号到其组件（比如我们刚提到的集成电路和连接器）。它本质上是由导电材料、隔离材料和组件组成的三明治结构。PCB通常由几层到几十层构成，每一层彼此电气隔离。*走线*
    看起来像是PCB上的线，而 *通孔* 则像是走线末端的孔（参见 [图 3-33](#figure3-33)）。这些通孔连接着其他层上的走线，位于PCB内层或表面。通常，组件位于PCB的正面和背面。
- en: '![f03033](image_fi/278748c03/f03033.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![f03033](image_fi/278748c03/f03033.png)'
- en: 'Figure 3-33: Traces and vias; vias may be covered (*tented*), as in this photo,
    or exposed (*untented*)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-33：走线与通孔；通孔可能被覆盖（*封闭*），如本照片所示，或暴露（*未封闭*）
- en: A PCB’s outer sides have printed markings that identify components as well as
    company logos, PCB part numbers, and other artwork. These markings are called
    the *silkscreen*, which can be helpful when relating a PCB schematic to an actual
    PCB. Also, it can be hours of fun trying to find resistor R33 in the sea of other
    labeled components. All the text and lines on the PCB shown in [Figure 3-30](#figure3-30)
    are part of the silkscreen.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: PCB的外侧有印刷标记，用于标识组件、公司标志、PCB零件号以及其他图案。这些标记被称为 *丝网印刷*，在将PCB原理图与实际PCB对照时非常有用。此外，在成千上万的标注组件中寻找电阻R33也是一种乐趣。所有在
    [图 3-30](#figure3-30) 中显示的文本和线条都属于丝网印刷的一部分。
- en: When you’re mapping IC pinouts to a board, it’s good to know that pin 1 of a
    chip is usually identified on the silkscreen (and on the IC package itself) as
    a dot.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将集成电路（IC）引脚图映射到电路板时，通常在芯片的丝印层（以及IC封装上）会标注一个点，表示引脚1。
- en: 'The following reference designators are helpful to memorize, although you also
    may find other designators for these components:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下参考设计符号值得记忆，尽管你也可能会找到这些元件的其他设计符号：
- en: C = capacitor
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C = 电容器
- en: R = resistor
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R = 电阻器
- en: JP = jumper
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JP = 跳线
- en: TP = test point
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TP = 测试点
- en: U = IC
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: U = 集成电路（IC）
- en: VR = voltage regulator
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VR = 电压调节器
- en: XTAL or Y = oscillator (crystal)
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XTAL 或 Y = 振荡器（晶体）
- en: You can try to follow PCB traces visually, but doing so quickly becomes tricky,
    so the most common way is to grab your favorite multimeter and set it to measure
    resistance (remember, it’s nice to have a multimeter that beeps, so you don’t
    need to watch it the entire time). Before you start measuring, it’s important
    to know that all traces are covered in a *solder mask*, which is the layer that
    makes the PCB green, red, black, or other color. The solder mask prevents corrosion
    and accidental solder bridges during manufacturing. A solder mask is nonconducting,
    so you can’t use your multimeter to get to the trace. However, you can scrape
    off the solder mask pretty easily, even with the tip of your multimeter probe,
    to expose the copper of the trace.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试通过视觉跟踪PCB的电路走向，但这样做很快会变得棘手，因此最常见的方法是拿起你最喜欢的万用表，将其设置为测量电阻（记住，最好选择具有蜂鸣功能的万用表，这样你就不需要一直看着它）。在开始测量之前，了解所有的电路走线都覆盖着*焊接掩膜*是很重要的，焊接掩膜是使PCB呈现绿色、红色、黑色或其他颜色的层。焊接掩膜可以防止在制造过程中发生腐蚀和意外的焊接桥接。焊接掩膜是非导电的，因此你不能使用万用表直接接触到电路走线。然而，你可以很容易地刮掉焊接掩膜，甚至可以用万用表探针的尖端来暴露铜质走线。
- en: The multimeter measures resistance by applying a small current across the probes
    and measuring the voltage across the probes for the given test current. This is
    simply solving Ohm’s law (*V* = *I* × *R*) for resistance. Because of this, you
    can only use the multimeter on unpowered circuits. Any voltage present in the
    circuit will at best confuse and at worst damage the multimeter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 万用表通过在探针之间施加微小电流并测量给定测试电流下的探针电压来测量电阻。这实际上是通过欧姆定律（*V* = *I* × *R*）来计算电阻。因此，你只能在无电源的电路上使用万用表。电路中存在的任何电压，充其量会干扰测量，最坏的情况下会损坏万用表。
- en: The traces carry I/O signals, like JTAG, I2C, or DRAM bus signals, and they
    can also form power and ground planes. Signals usually go between two ICs, or
    between an IC and a port or header. If you’re using a multimeter as we suggest,
    be aware that certain types of parts can still confuse the multimeter. Large capacitors
    will often look like shorts, as the small test current is very slowly charging
    the capacitor, which gives a reading similar to a low resistance. Semiconductor
    components may also read as a low resistance one way, so if you are seeing a signal
    that appears to be connected to nonsensical areas, be suspicious about your measurement.
    Normally, a direct short (0 Ω, where your meter and probe resistance could measure
    in the 0 to 10 Ω range) is a “real” connection; any higher resistance values may
    be artifacts of the circuit elements.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这些走线传输输入/输出信号，如JTAG、I2C或DRAM总线信号，它们也可以形成电源和地面平面。信号通常在两个IC之间，或者在IC和端口或接头之间传递。如果你像我们建议的那样使用万用表，请注意，某些类型的元件仍然可能干扰万用表的测量。大型电容器通常看起来像是短路，因为微小的测试电流正在非常缓慢地给电容器充电，这会给出类似低电阻的读数。半导体元件可能也会在一个方向上读作低电阻，因此如果你看到一个信号似乎连接到了不合理的区域，请对你的测量结果保持怀疑。通常，直接短路（0
    Ω，万用表和探针的电阻可能会测量在0到10 Ω之间）是“真实”的连接；任何更高的电阻值可能是电路元件的伪影。
- en: From the IC pins, it’s common to see pullup or pulldown resistors connected
    to the IC pins. These are normally not the “final destination” of the net, so
    you will want to probe further in most cases. If you see a lot of connections,
    it may be the ground net; a single ground plane usually goes everywhere on the
    PCB. Each IC has at least one ground pin. Metal casings of ports are typically
    ground, and any connector is certain to have ground connected to at least one
    of its pins. Bigger ICs can have dozens of ground pins in order to divide the
    current load over multiple pins. ICs may also have separate analog and digital
    ground pins. The large voltage differentials caused by digital switching on digital
    lines causes a lot of noise on ground traces, so they can be isolated from analog
    circuitry by having a separate ground. At some point, the PCB connects these digital
    and analog grounds together. You can usually find ground at metal cases on ports
    or marked by the text *GND* on the silkscreen.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 从IC引脚上，常见会看到上拉或下拉电阻连接到IC引脚。这些通常不是网络的“最终目的地”，所以在大多数情况下你需要进一步探查。如果你看到很多连接，可能是接地网络；通常，单一的接地平面会贯穿整个PCB。每个IC至少有一个接地引脚。端口的金属外壳通常是接地的，任何连接器肯定会有接地连接到至少一个引脚。较大的IC可能有数十个接地引脚，以便将电流负载分布到多个引脚上。IC还可能有独立的模拟和数字接地引脚。数字线路上的开关动作会在地线引起较大的电压差，产生大量噪声，因此可以通过使用独立接地来将其与模拟电路隔离。在某些情况下，PCB会将这些数字和模拟接地连接起来。你通常可以在端口的金属外壳处找到接地，或通过丝印上的文字*GND*标识接地。
- en: Sometimes the metal cases on ports (normally called the shield) don’t connect
    directly to the digital ground, so always do a quick sanity check between some
    potential ground points before you dive too far in.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有时端口上的金属外壳（通常称为屏蔽）不会直接连接到数字接地，因此在深入研究之前，始终需要对一些潜在的接地点进行快速检查。
- en: The PCB can have one or many power planes, each typically providing different
    voltages to components, particularly to the larger ICs. Common voltages that may
    be identified by text on the silkscreen are 5 V, 3.3 V, 1.8 V, and 1.2 V.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: PCB可以有一个或多个电源平面，每个平面通常为组件，特别是较大的IC提供不同的电压。常见的电压可以通过丝印上的文字识别，如5 V、3.3 V、1.8 V和1.2
    V。
- en: The various voltages are generated by *voltage regulators* or *power management
    ICs (PMICs)*. Voltage regulators are dumb components that convert the basic raw
    voltage connected to the PCB into a wide range of stable voltages. For instance,
    the LD1117 takes in a raw voltage of anything between 4 V and 15 V and converts
    it to 3.3 V. PMICs are found in more complex devices like mobile phones. They
    provide the various voltages, but they can be externally instructed to switch
    various voltages on or off. They may communicate with the SoC that they are powering
    via a protocol such as I2C so that if the OS in the SoC needs to run faster, it
    can instruct the PMIC to increase the supply voltage. Voltage drops may occur
    along traces when conducting high currents, so feedback circuitry to the PMICs
    can verify the voltage arriving at the components, allowing the PMIC to adjust
    the voltage where necessary.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 各种电压由*电压调节器*或*电源管理IC（PMIC）*生成。电压调节器是简单的组件，它们将连接到PCB的基础原始电压转换为多种稳定的电压。例如，LD1117接受4V到15V之间的原始电压，并将其转换为3.3V。PMIC通常用于更复杂的设备，如手机。它们提供各种电压，并且可以通过外部指令开关各种电压的开关。它们可能通过诸如I2C等协议与它们所供电的SoC进行通信，这样如果SoC中的操作系统需要更快运行，它可以指示PMIC增加供电电压。当导电大电流时，电压可能会沿着走线发生下降，因此PMIC的反馈电路可以验证到达组件的电压，允许PMIC在必要时调整电压。
- en: Sometimes you want to bypass the PMIC and provide your own power source (for
    instance, for fault injection). At first, it may seem tricky, as the PMIC may
    go through complex voltage sequencing during boot and operation, but in practice
    we’ve rarely seen an issue with just supplying a constant voltage. Our guess is
    that this sequencing is all to save battery power, and the IC’s operation doesn’t
    seem to suffer if you don’t do this. Further, when providing your own power, you
    want to keep the feedback loop intact. So, substitute your own independent power
    supply only to the IC you are investigating. You want the PMIC to stay happy,
    because it may be holding the main IC in reset until it sees a stable output voltage.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能想绕过 PMIC，并提供自己的电源（例如用于故障注入）。起初，这可能看起来很棘手，因为 PMIC 在启动和操作过程中可能经过复杂的电压序列，但实际上我们很少见到只提供恒定电压会出现问题。我们猜测这些电压序列的目的是为了节省电池电量，如果你不执行这些操作，IC
    的工作似乎不会受到影响。此外，当提供自有电源时，你需要保持反馈回路的完整性。因此，只向你正在调查的 IC 提供自己的独立电源。你希望 PMIC 保持正常，因为它可能在看到稳定的输出电压之前会将主
    IC 保持在复位状态。
- en: 'With these basics, you can start determining the answers to the following questions:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些基础后，你可以开始回答以下问题：
- en: At what voltage level is the IC or I/O channel running? Power on the device
    and measure the steady voltage between ground and the relevant IC pin or on the
    PCB trace nearby.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IC 或 I/O 通道运行在什么电压水平？为设备通电，测量接地与相关 IC 引脚之间的稳态电压或附近 PCB 线路上的电压。
- en: What is the ground plane connected to? The metal casing of any port is going
    to be ground. You can use that as a reference, and after removing power from the
    device, identify all other ground points, on IC pins and connectors, by performing
    the beep test described earlier.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接地平面连接到哪里？任何端口的金属外壳都将连接到地。你可以将其作为参考，在断开设备电源后，通过之前描述的蜂鸣测试识别所有其他接地点，无论是在 IC 引脚还是连接器上。
- en: How is power distributed on the PCB? You can either measure voltages on all
    pins, as before, or use the beep test to identify all points connected to the
    same power plane.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电源是如何在 PCB 上分布的？你可以像以前一样测量所有引脚上的电压，或者使用蜂鸣测试来识别所有连接到相同电源平面的点。
- en: What are the JTAG pins connected to? Let’s say you’ve identified the JTAG pins
    of the IC, but you want to know to which header or test point they are connected.
    Use the beep test between a JTAG IC pin and all “suspect” points on the board.
    If you really want to go pro, take a wire and fray one of the ends into a “fan,”
    as shown in [Figure 3-34](#figure3-34). Connect one of your probe pins to the
    wire and “sweep” the board, which is much more efficient than having to touch
    every point manually. If you want to get fancy, you can also buy small metal brushes
    to accomplish the same goal.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JTAG 引脚连接到哪里？假设你已经识别了 IC 的 JTAG 引脚，但你想知道它们连接到了哪个接头或测试点。使用蜂鸣测试，在 JTAG IC 引脚和所有“可疑”点之间进行测试。如果你真的想更专业，可以取一根导线，将一端剥成“风扇”形状，如[图
    3-34](#figure3-34)所示。将探针的一端连接到导线上，并“扫过”电路板，这比手动接触每个点要高效得多。如果你想更精致一点，也可以购买小型金属刷来实现相同的目的。
- en: '![f03034](image_fi/278748c03/f03034.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![f03034](image_fi/278748c03/f03034.png)'
- en: 'Figure 3-34: Continuity sweeper'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-34：连通性测试仪
- en: 'For more information on reverse engineering a PCB, take a look at Joe Grand’s
    “Printed Circuit Board Deconstruction Techniques” USENIX paper. If you’d like
    to dig deeper on the design side, the book *Printed Circuit Board Designer’s Reference:
    Basics* (Prentice Hall, 2003), by Christopher T. Robertson, explains how PCBs
    are physically made. For more reverse engineering techniques, see Ng Keng Tiong’s
    *PCB-RE: Tools & Techniques* (CreateSpace Independent Publishing, 2017).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '想了解更多关于 PCB 反向工程的信息，可以参考 Joe Grand 的《Printed Circuit Board Deconstruction Techniques》USENIX
    论文。如果你想深入了解设计方面的内容，Christopher T. Robertson 编写的《Printed Circuit Board Designer’s
    Reference: Basics》（普伦蒂斯·霍尔出版社，2003年）一书解释了 PCB 的物理制作过程。有关更多反向工程技术，可以参阅 Ng Keng
    Tiong 的《PCB-RE: Tools & Techniques》（CreateSpace 独立出版，2017年）。'
- en: Using the JTAG Boundary Scan for Mapping
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 JTAG 边界扫描进行映射
- en: So far, we’ve mostly discussed passive methods of reverse engineering the connections
    on a PCB. In the previous chapter, we mentioned the existence of the JTAG boundary
    scan mode. With boundary scan, we can use a chip to drive a signal on the board
    and use measurement equipment to find out where that signal is routed. Boundary
    scan can also be used to sense signals on a chip’s pin, which means we can drive
    a signal on the board and figure out to which pin it is routed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要讨论了反向工程中用于识别PCB连接的被动方法。在上一章中，我们提到过JTAG边界扫描模式的存在。通过边界扫描，我们可以使用芯片驱动板上的信号，并使用测量设备查明该信号的走向。边界扫描还可以用来感应芯片引脚上的信号，这意味着我们可以在板上驱动信号，并找出该信号连接到哪个引脚。
- en: Boundary scan requires us to power up the board as part of the reverse engineering.
    It also requires a little bit of information first. We need a JTAG header to run
    this! Typically, using JTAG boundary scan will be a step after we’ve done some
    basic reverse engineering. It also requires us to have a JTAG Boundary Scan Description
    Language (BSDL) file for the device in question, and the device itself to have
    JTAG boundary scan enabled (not everything will).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 边界扫描要求我们在反向工程过程中为板子提供电源。它还需要一些初步信息。我们需要一个JTAG头来执行这个过程！通常，使用JTAG边界扫描是我们在完成一些基本的反向工程工作之后的一个步骤。它还要求我们为相关设备准备一个JTAG边界扫描描述语言（BSDL）文件，并且该设备必须启用JTAG边界扫描（并非所有设备都支持）。
- en: Let’s take an example of an automotive ECU. The E82 ECU uses an NXP MPC5676R
    device. We can find a BSDL file for the MPC5676R chip with a simple online search,
    which means it’s worth trying to get a JTAG interface connected to it. Inspecting
    the board shows an unmounted 14-pin header that’s suspiciously like the 14-pin
    JTAG commonly used by these devices. We mount a header to this and connect a JTAG
    adapter (see [Figure 3-35](#figure3-35)).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以汽车ECU为例。E82 ECU使用NXP MPC5676R芯片。我们可以通过简单的在线搜索找到MPC5676R芯片的BSDL文件，这意味着尝试连接JTAG接口是值得的。检查板子时，发现一个未安装的14引脚头，其外形与这些设备常用的14引脚JTAG接口非常相似。我们将一个头插到这个位置，并连接一个JTAG适配器（见[图3-35](#figure3-35)）。
- en: '![f03035](image_fi/278748c03/f03035.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![f03035](image_fi/278748c03/f03035.png)'
- en: 'Figure 3-35: JTAG header and adapter connected to E82 ECU; a 1 kΩ resistor
    is used to drive a 1 Hz square wave into test points'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-35：JTAG头和适配器连接到E82 ECU；使用1 kΩ电阻将1 Hz方波信号输入到测试点
- en: Next, we use TopJTAG software to load the BSDL file and put the chip in *EXTEST*
    mode. In this mode, we have complete control of the chip I/O pins. Some risk is
    involved because you may cause havoc by just flipping random pins (for instance,
    accidentally signaling a power supply to turn on or off). There is also *SAMPLE*
    mode, which means the chip is still running; it may be driving outputs high or
    low, preventing effective mapping. We’ll stick to *EXTEST*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用TopJTAG软件加载BSDL文件，并将芯片置于*EXTEST*模式。在此模式下，我们可以完全控制芯片的I/O引脚。由于您可能会通过随意翻转引脚（例如，意外地发出开关电源的信号）而引起混乱，因此存在一定的风险。还有*SAMPLE*模式，这意味着芯片仍在运行，它可能会驱动输出为高或低，从而阻止有效的映射。我们将坚持使用*EXTEST*模式。
- en: TopJTAG shows JTAG boundary scan connectivity; that’s good news for our ease
    of reverse engineering. We end up with a screen in the software like [Figure 3-36](#figure3-36).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: TopJTAG显示JTAG边界扫描连接性；这对我们的反向工程非常有利。最后我们将在软件中看到像[图3-36](#figure3-36)这样的屏幕。
- en: '![f03036](image_fi/278748c03/f03036.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![f03036](image_fi/278748c03/f03036.png)'
- en: 'Figure 3-36: The TopJTAG software uses a BSDL file to show a graphical view
    of the pin state.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-36：TopJTAG软件使用BSDL文件显示引脚状态的图形视图。
- en: In [Figure 3-36](#figure3-36), you can see the state of each pin on the device.
    This is a “live” view, so if the external voltage on the pin changes, we can see
    the color change in this picture or the I/O value change in the table.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图3-36](#figure3-36)中，您可以看到设备上每个引脚的状态。这是一个“实时”视图，因此如果引脚上的外部电压发生变化，我们可以在这张图中看到颜色变化，或者在表格中看到I/O值的变化。
- en: To map a test point to a pin, we can drive a square wave on the test point using
    a signal generator. You can see this in [Figure 3-35](#figure3-35), where a 1
    kΩ resistor is used to drive a low-current square wave onto the board. We should
    see the associated pin toggling on the TopJTAG screen. If you don’t have a signal
    generator, you can also connect one end of a 1 kΩ resistor to a VCC point on the
    board and tap the other end on the test point.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要将测试点映射到引脚，我们可以使用信号发生器在测试点上驱动方波。您可以在[图3-35](#figure3-35)中看到，使用1 kΩ电阻将低电流方波信号输入到板上。我们应该能在TopJTAG屏幕上看到相应引脚的切换。如果没有信号发生器，您还可以将1
    kΩ电阻的一端连接到板上的VCC点，另一端轻触测试点。
- en: 'Using the software, you could also do the opposite: by toggling a signal from
    a particular pin, you can measure in various places on the board to find out where
    that pin is connected. Unfortunately, there is no feature in the software to generate
    a waveform, but with the CTRL-T hotkey, you can do this manually (or find some
    keypress-injection software). We’ll discuss the tools you require to perform this
    type of work in Appendix A. Joe Grand’s JTAGulator can be used to automatically
    map test points to boundary scan bits, for example.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该软件，你也可以做相反的操作：通过切换来自特定引脚的信号，你可以在电路板的不同位置测量，找出该引脚连接的位置。不幸的是，软件中没有生成波形的功能，但你可以使用CTRL-T快捷键手动完成此操作（或者找到一些按键注入软件）。我们将在附录A中讨论执行这种类型工作的工具。例如，Joe
    Grand的JTAGulator可以用于自动将测试点映射到边界扫描位。
- en: Information Extraction from the Firmware
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从固件中提取信息
- en: Firmware images contain most of the code running on a device, so taking a peek
    at them is usually very interesting in order to find a point of attack. So far,
    we’ve mostly been discussing information we can see with our eyes or simple electrical
    tests. We’re now going to take a quantum leap in complexity and detail how you
    can actually work with firmware. At first glance, this looks like a major departure
    from the nitty-gritty details of the PCB, but if you think back to our overall
    goal of information gathering, analyzing the firmware is a critical step (and
    in many cases, the most important step). In the rest of the book, we discuss many
    operations that depend on firmware. Understanding how to find cryptographic signatures,
    for example, is an important part of knowing where you can apply fault injection;
    seeing code that could be referencing a signature is a good sign that you can
    find the location of the signature check routine.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 固件镜像包含了设备上运行的大部分代码，因此查看它们通常是非常有趣的，可以帮助找到攻击点。到目前为止，我们主要讨论的是可以通过眼睛看到的信息或简单的电气测试。现在我们将跨越一个巨大的复杂性鸿沟，详细介绍如何实际操作固件。乍一看，这似乎是从PCB的琐碎细节上大大偏离了，但如果你回想一下我们收集信息的整体目标，分析固件是一个至关重要的步骤（在许多情况下，甚至是最重要的步骤）。在本书的其余部分，我们将讨论许多依赖固件的操作。例如，了解如何找到加密签名，是知道何时可以应用故障注入的一个重要部分；看到可能引用签名的代码，是你能够找到签名检查例程位置的一个良好迹象。
- en: Obtaining the Firmware Image
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取固件镜像
- en: With the device physically in front of you, and fresh off a discussion of JTAG,
    you might assume we’re going to extract the firmware image from the device. But
    taking the path of least resistance, we first check whether we can obtain the
    firmware image by downloading it from an update website or, if the device has
    Linux support, checking the */lib/firmware* directory.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备实际摆在你面前，并且刚刚讨论完JTAG后，你可能会认为我们接下来要从设备中提取固件镜像。但考虑到最小阻力的路径，我们首先检查是否可以通过从更新网站下载固件镜像，或者如果设备支持Linux，检查*/lib/firmware*目录来获取固件镜像。
- en: The image may be available as a separate file for download or embedded in an
    installer package. In case of the former, skip to the next section; in case of
    the latter, use your software reverse engineering skills to find the update file
    in the installation directory. One trick is to do a plain string search for a
    known string that the device prints out, although firmware images may often be
    compressed, and you won’t find the plain string. You can use the binwalk tool
    to find LZMA files or deflate (zlib/gzip) compressed images inside files. In fact,
    we’ll use binwalk later to carve up the firmware image itself to analyze further.
    Alternatively, you can perform the update and then sniff the image off the communication
    channel during a firmware update with a tool like Wireshark for Ethernet connections
    or socat for Linux.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 固件镜像可能作为一个单独的文件提供下载，也可能嵌入在安装包中。如果是前者，请跳到下一节；如果是后者，使用你的软件逆向工程技巧在安装目录中找到更新文件。一种技巧是进行普通字符串搜索，查找设备打印出的已知字符串，尽管固件镜像通常是压缩的，你可能找不到原始字符串。你可以使用binwalk工具在文件中查找LZMA文件或deflate（zlib/gzip）压缩镜像。事实上，我们稍后将使用binwalk来切割固件镜像并进一步分析。另一种方法是执行更新，然后在固件更新过程中，通过Wireshark（用于以太网连接）或socat（用于Linux）等工具嗅探通信通道中的镜像。
- en: Some devices support the USB Direct Firmware Update (DFU) standard, which is
    used for downloading and uploading firmware images to and from a device. If the
    target supports it, it will typically be enabled as an alternative boot mode.
    For instance, a mode could be set through a jumper, or a mode may be automatically
    chosen if the onboard firmware image is corrupted. You may be able to corrupt
    the image-loading process by a fault injection, which could be as simple as shorting
    out a data line, causing corrupted data to be loaded. Once you have DFU mode,
    you may be able to upload (extract) the firmware image. The dfu-util tool can
    perform this if it supports the device and if the device supports uploading.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设备支持USB直接固件更新（DFU）标准，该标准用于将固件映像下载和上传到设备中。如果目标设备支持此标准，它通常会作为一种可选的启动模式启用。例如，可以通过跳线设置此模式，或者如果板载固件映像损坏，可能会自动选择该模式。你可能通过故障注入来破坏映像加载过程，这可能仅仅是通过短接数据线，导致加载损坏的数据。一旦进入DFU模式，你可能能够上传（提取）固件映像。如果设备支持上传并且dfu-util工具支持该设备，它可以执行此操作。
- en: The device may also support its own proprietary protocol that is also called
    DFU mode, and it may have more than one recovery mode. For example, iPhones and
    iPads typically have a “recovery mode” that allows you to reflash the device over
    USB and run firmware that Apple can update. In addition, a separate “DFU mode”
    runs immutable ROM code that allows you to reflash the device over USB. The “DFU
    Mode” is a proprietary protocol and does not implement the USB standard DFU mode.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备还可能支持其专有协议，称为DFU模式，并且可能有多个恢复模式。例如，iPhone和iPad通常具有“恢复模式”，允许通过USB重新刷新设备并运行Apple可以更新的固件。此外，单独的“DFU模式”运行不可更改的ROM代码，允许通过USB重新刷新设备。“DFU模式”是一个专有协议，不符合USB标准的DFU模式。
- en: If you’ve exhausted the software means of obtaining an image or just are in
    the mood for a hardware attack, you can attempt to extract the firmware from a
    flash chip. This is only *simply* done on an external flash chip. Some SoCs have
    an internal flash, which is accessible only through chip-level reverse engineering
    and microprobing after decapping, and therefore is beyond the scope of this book.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经用尽了获取映像的软件方法，或者只是想尝试硬件攻击，你可以尝试从闪存芯片中提取固件。这对于外部闪存芯片来说是*简单*的做法。一些SoC有内部闪存，仅通过芯片级逆向工程和去封装后的微探针可访问，因此超出了本书的范围。
- en: To get the flash chip off the board, you need to desolder it, which isn’t as
    hard as it sounds, but it does require a hot-air working station. The off-the-shelf
    method for obtaining the image is to purchase a memory reader. If you want minimal
    fuss, something from the FlashcatUSB series is a good bet. Models from this company
    support both SPI and parallel flash chips, and they range from low to medium cost.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要将闪存芯片从电路板上取下，你需要对其进行除焊，这并不像听起来那么难，但确实需要一个热风工作站。获取映像的现成方法是购买一个内存读卡器。如果你希望尽量减少麻烦，FlashcatUSB系列的产品是一个不错的选择。该公司生产的型号支持SPI和并行闪存芯片，价格从低到中等不等。
- en: You’ll see all sorts of other methods of reading SPI flash memory as well. Solutions
    have been made with Arduino Teensy devices and Raspberry Pis. Jeong Wook (Matt)
    Oh’s “Reverse Engineering Flash Memory for Fun and Benefit,” from Black Hat 2014,
    describes a DIY approach to getting the image and is a great way to learn about
    creating hardware to interface with flash chips and flash chip memory encodings.
    It walks through the process of attaching a chip and reading it by bit-banging
    through an FTDI FT2232H.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到各种读取SPI闪存的其他方法。解决方案已经通过Arduino Teensy设备和树莓派制作出来。Jeong Wook（Matt）Oh的《逆向工程闪存内存以获取乐趣和利益》（2014年Black
    Hat会议）描述了一种DIY方式来获取映像，是学习如何创建硬件与闪存芯片和闪存芯片内存编码进行交互的绝佳方法。它详细介绍了通过FTDI FT2232H进行bit-banging连接芯片并读取它的过程。
- en: Speaking of reading flash memory onboard, we should also mention how you can
    read eMMC chips. These chips are basically SD cards in chip form, as mentioned
    in Chapter 2. Thanks to some nice backward compatibility, you can run them in
    1-bit mode (meaning you need only GND, CLK, CMD, and D0). [Figure 3-37](#figure3-37)
    shows an example of an SD card interposer connected to read out eMMC memory.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 说到读取板载闪存，我们还应该提到如何读取eMMC芯片。这些芯片基本上是芯片形式的SD卡，正如第二章所述。得益于一些很好的向后兼容性，你可以在1位模式下运行它们（这意味着你只需要GND、CLK、CMD和D0）。[图3-37](#figure3-37)展示了一个连接的SD卡插接器的例子，用于读取eMMC内存。
- en: '![f03037](image_fi/278748c03/f03037.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![f03037](image_fi/278748c03/f03037.png)'
- en: 'Figure 3-37: On this board, the eMMC flash connections (on the bottom of the
    board, not visible) were accessible on several pads onto which we could mount
    pin headers.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-37：在此板上，eMMC闪存连接（位于板底部，不可见）可通过多个焊盘访问，您可以将引脚头插入这些焊盘。
- en: In this example, we’re holding the target processor in reset by grounding the
    nRST pin, so we can then plug the SD card into the USB SD card reader. Holding
    the target processor in reset is needed, as otherwise it would attempt to toggle
    the I/O lines at the same time. We can then mount the filesystem on the SD card
    on our computer. In this example, it was a standard filesystem readable in Linux.
    The talk “Hardware Hacking with a $10 SD Card Reader” by Amir “Zenofex” Etemadieh,
    CJ “cj_000” Heres, and Khoa “maximus64” Hoang, at Black Hat 2017 and the Exploitee.rs
    Wiki, is a valuable resource.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们通过接地nRST引脚将目标处理器保持在复位状态，然后插入SD卡到USB SD卡读卡器中。保持目标处理器在复位状态是必要的，否则它会尝试同时切换I/O线路。接下来，我们可以将SD卡上的文件系统挂载到计算机上。在此示例中，这是一个在Linux中可读取的标准文件系统。由Amir
    “Zenofex” Etemadieh、CJ “cj_000” Heres和Khoa “maximus64” Hoang于2017年Black Hat会议上发表的讲座《使用$10
    SD卡读卡器进行硬件黑客攻击》以及Exploitee.rs Wiki是一个宝贵的资源。
- en: Analyzing the Firmware Image
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析固件映像
- en: The next task is to analyze the firmware image. It will have multiple blocks
    for different functional components—for example, various stages of the bootloader,
    digital signatures, key slots, and a filesystem image. The first step is to dissect
    the image into its components. Each component may be plaintext, compressed, encrypted,
    and/or signed. Binwalk is a useful tool for finding all components in a firmware
    image. It recognizes different sections by matching them against the “magic” bytes
    that encode different file types.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的任务是分析固件映像。它将包含多个块，代表不同的功能组件——例如，启动加载器的各个阶段、数字签名、密钥槽和文件系统映像。第一步是将映像分解成其组件。每个组件可能是明文的、压缩的、加密的和/或签名的。Binwalk是一个有用的工具，用于查找固件映像中的所有组件。它通过与编码不同文件类型的“魔术”字节匹配来识别不同的部分。
- en: For encrypted data, you first need to figure out the encryption used and the
    key. Your best bet is to do side-channel analysis (see Chapters 8–12). Common
    options are AES-128 or AES-256 in CTR or CBC mode, although we’ve also seen ECB
    and GCM used. Once you have the key, you can decrypt the image for further analysis.
    For how to deal with digital signatures, see the “Signatures” section on page
    116.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加密数据，您首先需要弄清楚使用的加密方式和密钥。最好的方法是进行旁道分析（参见第8到12章）。常见的选项是AES-128或AES-256，使用CTR或CBC模式，虽然我们也见过使用ECB和GCM模式。一旦获得密钥，就可以解密映像进行进一步分析。关于如何处理数字签名，请参见第116页的“签名”部分。
- en: 'Once you have an image with plaintext or compressed blocks, binwalk can help
    with the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得包含明文或压缩块的映像，binwalk可以帮助完成以下任务：
- en: Detecting various files, filesystems, and compression methods within the image,
    using the `--signature` option.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--signature`选项检测映像中的各种文件、文件系统和压缩方法。
- en: Extracting the different components with the `--carve`, `--extract`, or `--dd`
    option. If you specify `--matryoshka`, this will be done recursively.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--carve`、`--extract`或`--dd`选项提取不同的组件。如果指定`--matryoshka`，则会递归执行此操作。
- en: Detecting CPU architecture by analyzing opcodes in a file using `--opcode` or
    `--disasm`.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--opcode`或`--disasm`分析文件中的操作码来检测CPU架构。
- en: Searching for a fixed string using `--raw`.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--raw`搜索固定字符串。
- en: Analyzing and graphing the Shannon entropy of a file using `--entropy` or the
    zlib compression ratio with the `--fast` option. Use `--save` to save the entropy
    plot to a file.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--entropy`分析文件的Shannon熵或使用`--fast`选项分析zlib压缩比。使用`--save`将熵图保存到文件中。
- en: Doing a hexdump and diffing binary files with `--hexdump`.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--hexdump`进行十六进制转储并比较二进制文件。
- en: Finding compressed data with missing headers by brute force, using `--deflate`
    or `--lzma`.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--deflate`或`--lzma`通过暴力破解找到缺少头部的压缩数据。
- en: 'As an example, let’s take a brief look at some device firmware we can easily
    download (in this case, firmware for the TP-Link TD-W8980 router). We’re looking
    at version TD-W8980_V1_150514 (found as *TD-W8980_V1_150514.zip*). Unzip it and
    then run binwalk like so:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们简要查看一些可以轻松下载的设备固件（在本例中为TP-Link TD-W8980路由器的固件）。我们查看的是版本TD-W8980_V1_150514（找到为*TD-W8980_V1_150514.zip*）。解压缩文件后，像这样运行binwalk：
- en: '[PRE0]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output (formatted for readability) reveals some interesting information:
    a u-boot bootloader image 1, firmware for GPHY 2, and a Squashfs filesystem (Linux)
    3. If you run binwalk with `--extract` and `--matryoshka`, you’ll get all these
    blocks as separate files, with compressed and decompressed versions of components,
    and the Squashfs filesystem unpacked.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（为了可读性进行格式化）揭示了一些有趣的信息：一个 u-boot 启动加载程序镜像 1，一个 GPHY 固件 2，以及一个 Squashfs 文件系统（Linux）
    3。如果你使用 `--extract` 和 `--matryoshka` 选项运行 binwalk，你将得到这些块作为单独的文件，包含组件的压缩和解压版本，以及解包后的
    Squashfs 文件系统。
- en: We’re focusing on hardware attacks on embedded systems, but one feature of software
    reverse engineering you may need is to identify encrypted blocks and signatures.
    Later chapters assume you have figured that out already, so we’ll walk through
    a sample analysis. Now, what we’ll find if we modify a file on the Squashfs filesystem
    (such as */etc/passwd* or */etc/vsftpd_passwd*) is that the router doesn’t accept
    the new firmware image. This is because an RSA-1024 signature is used to verify
    the image’s authenticity. The signature isn’t indicated in the binwalk output,
    because signatures are often just sequences of random-looking bytes as specific
    offsets. You can find those offsets through entropy analysis.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要关注嵌入式系统的硬件攻击，但软件逆向工程中你可能需要的一个功能是识别加密块和签名。后续章节假设你已经弄清楚了这一点，因此我们将通过一个示例分析来说明。现在，如果我们修改
    Squashfs 文件系统中的一个文件（例如 */etc/passwd* 或 */etc/vsftpd_passwd*），我们会发现路由器无法接受新的固件镜像。这是因为使用了
    RSA-1024 签名来验证镜像的真实性。binwalk 输出中没有显示签名，因为签名通常只是一些看似随机的字节序列，存在于特定的偏移量位置。你可以通过熵分析找到这些偏移量。
- en: Entropy Analysis
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 熵分析
- en: '*Entropy* is used in computer science as a measure of information density.
    For our purposes, we use 8-bit entropy. An entropy of 0 means a block of data
    contains a single byte value, and an entropy of 1 means a block contains equal
    amounts of every byte value from 0 to 255\. Entropy close to 1 is indicative of
    crypto keys, ciphertexts, or compressed data.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*熵* 在计算机科学中用于度量信息密度。为了我们的目的，我们使用的是 8 位熵。熵为 0 意味着一个数据块包含单一的字节值，而熵为 1 意味着一个数据块包含从
    0 到 255 每个字节值的相同数量。接近 1 的熵值通常表示加密密钥、密文或压缩数据。'
- en: 'Full of hope and excitement, we run binwalk again with the `--nplot` and `--entropy`
    options:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 满怀希望和兴奋，我们再次运行 binwalk，使用 `--nplot` 和 `--entropy` 选项：
- en: '[PRE1]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The binwalk tool calculates the entropy for each block and determines block
    boundaries by looking for large changes in entropy. This usually works by finding
    contiguous blocks of compressed or encrypted data and sometimes even works for
    finding key material. In this case, we’re looking for an RSA-1024 signature (which
    is 128 bytes), and there’s no such block.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: binwalk 工具计算每个块的熵，并通过查找熵的大幅变化来确定块的边界。这通常通过找到连续的压缩或加密数据块来实现，有时甚至能帮助找到密钥材料。在这个例子中，我们正在寻找一个
    RSA-1024 签名（128 字节），但没有找到这样的块。
- en: If you run binwalk again, omitting the `--nplot` option, it produces the graph
    shown in [Figure 3-38](#figure3-38).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行 binwalk，省略 `--nplot` 选项，它会生成如图 [Figure 3-38](#figure3-38) 所示的图表。
- en: '![f03038](image_fi/278748c03/f03038.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![f03038](image_fi/278748c03/f03038.png)'
- en: 'Figure 3-38: Entropy output from binwalk using default settings'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-38：使用默认设置的 binwalk 熵输出
- en: The graph doesn’t show the 1,024-bit/128-byte signature we are looking for either.
    Although this signature may be embedded in one of those blocks, we already shot
    ourselves in the foot. The way we are using binwalk will never show a 128-byte
    peak. Remember how entropy is calculated over a block of data? This means binwalk
    chops the file into blocks of data and calculates the entropy over those blocks.
    By default, the block size appears to be 0x1000, or 4,096 bytes. If our 128 random
    bytes are embedded in a 4,096-byte block, the entropy is only marginally affected.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图表也没有显示我们要寻找的 1,024 位/128 字节签名。虽然这个签名可能嵌入在某个块中，但我们已经自作自受。我们使用 binwalk 的方式永远不会显示一个
    128 字节的熵峰。还记得熵是如何计算的么？这意味着 binwalk 会将文件切割成数据块，并计算这些块的熵值。默认情况下，块大小似乎是 0x1000，或者
    4,096 字节。如果我们的 128 个随机字节嵌入在一个 4,096 字节的块中，那么熵值的影响就微乎其微。
- en: This is why binwalk has the `--block` option. It’s tempting to use a block size
    of 128 bytes now, but we’d still not have a nice entropy peak if the signature
    isn’t stored exactly within a single block. So, to be safe, we tend to use a block
    size of 16.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 binwalk 有 `--block` 选项的原因。现在，虽然很有诱惑使用 128 字节的块大小，但如果签名并不恰好存储在一个块内，我们仍然无法得到清晰的熵峰。因此，为了安全起见，我们倾向于使用
    16 字节的块大小。
- en: 'Now, we encounter another issue: execution is very slow. The output shows only
    the following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们遇到了另一个问题：执行非常慢。输出仅显示以下内容：
- en: '[PRE2]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That’s not very useful, as no blocks are identified at all. The output graph
    in [Figure 3-39](#figure3-39) also doesn’t show what we want.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太有用，因为根本没有识别出任何块。输出图表在[图3-39](#figure3-39)中也没有显示我们想要的内容。
- en: '![f03039](image_fi/278748c03/f03039.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![f03039](image_fi/278748c03/f03039.png)'
- en: 'Figure 3-39: Entropy output using 16-byte block size'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-39：使用16字节块大小的熵输出
- en: The reason is the calculation of entropy. It’s important to understand that
    for blocks smaller than 256 bytes, by definition, the entropy cannot be 1\. Actually,
    an entropy of 1 is achieved only when each byte value has the same frequency in
    the block. If a block is smaller than 256 bytes, it’s impossible to have a frequency
    of 1 or more for each byte value; therefore, the entropy cannot be 1\. In fact,
    the entropy is maximally 0.5 at a block length of 16.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 其原因是熵的计算。重要的是要理解，对于小于256字节的块，根据定义，熵不可能是1。实际上，熵为1仅在每个字节值在块中具有相同的频率时才能实现。如果一个块小于256字节，就不可能为每个字节值具有1或更高的频率；因此，熵不可能是1。事实上，当块长度为16时，熵最大为0.5。
- en: Since binwalk does edge-detection for entropy, we need to tune the thresholds
    for a rising and falling edge. If the maximum entropy is 0.5, you can set, for
    example, `--high=0.45` and `--low=0.40`. Alternatively, you can find your own
    entropy “peaks” using the `--verbose` option, which just outputs the entropy for
    each block.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 由于binwalk进行熵的边缘检测，我们需要调整上升和下降边缘的阈值。如果最大熵为0.5，你可以设置例如`--high=0.45`和`--low=0.40`。或者，你可以使用`--verbose`选项查找你自己的熵“峰值”，该选项会输出每个块的熵值。
- en: Of course, the edge detection doesn’t work. We get more than 2,000 edges. The
    reason is the calculation of entropy, again. Can you guess what the entropy is
    of *Glib jocks quiz nymph to vex dwarf*? With 16-byte blocks, the first block
    has an entropy of 0.447\. This is because the smaller the block size, the higher
    the likelihood that a nonrandom sequence of bytes accidentally has only unique
    bytes, and therefore the highest entropy possible (in other words, we get false
    positives).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，边缘检测不起作用。我们得到了超过2000个边缘。原因再次是熵的计算。你能猜出*Glib jocks quiz nymph to vex dwarf*的熵是多少吗？使用16字节的块，第一个块的熵为0.447。这是因为块大小越小，非随机字节序列偶然只包含唯一字节的可能性越高，因此熵达到最大（换句话说，我们得到了假阳性）。
- en: 'Let’s apply a bit of common sense. If we were to store a signature in an image,
    where would we do that? Likely it would be just before or just after the block
    we are protecting. Let’s take a look at the first 0x400 bytes:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运用一点常识。如果我们要把一个签名存储在图像中，我们会把它放在哪里呢？很可能我们会把它放在我们要保护的块之前或之后。让我们看看前0x400个字节：
- en: '[PRE3]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It seems there are two high-entropy sections: 16 bytes at `0x40` 1 and 128
    bytes at `0xD0` 2. The 128-byte block is clearly visible in the entropy plot in
    [Figure 3-40](#figure3-40).'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有两个高熵区域：`0x40`处的16字节1和`0xD0`处的128字节2。128字节块在[图3-40](#figure3-40)中的熵图上明显可见。
- en: 'If you employ the skills described earlier in this chapter, you’ll have found
    the [https://github.com/xdarklight/mktplinkfw3/](https://github.com/xdarklight/mktplinkfw3/)project
    page, which documents the header format for this particular firmware image. You
    guessed it: 0xD0 is the RSA signature (and 0x40 is an MD5 sum).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你采用本章早些时候描述的技巧，你应该已经找到了[https://github.com/xdarklight/mktplinkfw3/](https://github.com/xdarklight/mktplinkfw3/)项目页面，那里文档化了该固件映像的头部格式。你猜对了：0xD0是RSA签名（而0x40是MD5校验和）。
- en: '![f03040](image_fi/278748c03/f03040.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![f03040](image_fi/278748c03/f03040.png)'
- en: 'Figure 3-40: A more detailed entropy analysis, concentrating on areas of interest'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-40：更详细的熵分析，集中在感兴趣的区域
- en: Signatures
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 签名
- en: For signed data, you’ll need the signing key or a way to bypass signature verification
    in order to load modified firmware (we discuss ways to bypass signature verification
    in Chapter 6).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对于签名数据，你需要签名密钥或绕过签名验证的方法，以便加载修改过的固件（我们将在第6章讨论如何绕过签名验证）。
- en: 'Back to our firmware image: to check for data signing, modify a byte in the
    firmware image that wouldn’t cause execution to fail (for example, in a string
    constant such as a debugging or error message). If the device fails to boot with
    this image, it’s likely doing a signature verification or checksum. It’ll take
    some reverse engineering to find out which, although it may not be trivial. The
    code verifying at least the first firmware boot stage will be located in ROM,
    outside your view.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的固件镜像：要检查数据签名，请修改固件镜像中的一个字节，这个修改不会导致执行失败（例如，在一个字符串常量中，如调试或错误信息）。如果设备在此镜像下无法启动，那么它很可能正在进行签名验证或校验和。需要一些逆向工程来确定是哪种验证方式，尽管这可能不简单。至少验证第一个固件启动阶段的代码将位于ROM中，不在你的视野范围内。
- en: One thing you can look for is an RSA or elliptic curve cryptography (ECC) signature
    in the image, both of which are sequences of high-entropy bytes. An RSA-2048 signature
    will be 2,048 bits (256 bytes) long, and an ECDSA signature, for example, on the
    curve *prime256v1*, will have 256 × 2 = 512 bits of signature (64 bytes). Entropy
    spikes at the end or start of a block in the firmware may indicate a signature.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以寻找图像中的RSA或椭圆曲线密码学（ECC）签名，这两者都是高熵字节的序列。一个RSA-2048签名将会是2,048位（256字节）长，而例如在曲线*prime256v1*上的ECDSA签名将会有256
    × 2 = 512位的签名（64字节）。固件块的开始或结束处的熵峰可能表示一个签名。
- en: 'In addition, check the difference between two side-channel traces: one where
    you boot with a correct signature and one where you boot with a corrupted signature.
    This test allows you to pinpoint when the execution path diverges during the boot,
    which typically (but not necessarily) happens right after a signature verification.
    This information is also useful when you want to bypass signature verification
    using fault injection.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，检查两个旁路信道痕迹之间的差异：一个是在正确签名下启动，另一个是在损坏签名下启动。此测试可以帮助你准确找出启动过程中执行路径何时分叉，这通常（但不一定）发生在签名验证之后。这些信息在你希望通过故障注入绕过签名验证时也很有用。
- en: 'Finally, the image actually may be shipped with the public key used to verify
    its integrity, because space in ROM (or fuses) is limited and public keys (especially
    RSA) are rather large. This means you can search the firmware image for high-entropy
    sections that are a public key. For RSA-2048, the public key is the modulus of
    2,048 bits and the public exponent. Very often, this exponent is 65,537 (or 0x10001).
    Finding 0x10001 next to a high-entropy section indicates an RSA public key. For
    ECC, public keys are points on the curve. There are a few ways to encode this—for
    example, in affine (x,y) coordinates, in which case the curve prime256v1 has 256
    bits for x and y, or a total of 512 bits. A compressed encoding uses the fact
    that elliptic curves have only two possible values for y, given the curve and
    the point’s x coordinate, so a compressed notation for a point on prime256v1 has
    the full x coordinate (256 bits) and 1 bit of y, for a total of 257 bits. The
    “Standards for Efficient Cryptography, SEC 1: Elliptic Curve Cryptography” specifies
    a common encoding: a point is prefixed with 0x04 if it is uncompressed, and if
    it is compressed, it’s prefixed with 0x02 or 0x03, depending on the 1 bit for
    y.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，图像实际上可能会随带用于验证其完整性的公钥，因为ROM（或熔断器）的空间有限，而公钥（特别是RSA）相当大。这意味着你可以在固件镜像中查找高熵部分，这些部分就是公钥。对于RSA-2048，公钥是2,048位的模数和公钥指数。通常，这个指数是65,537（或0x10001）。在高熵部分旁边找到0x10001通常表示RSA公钥。对于ECC，公钥是曲线上的点。有几种方式来编码这一点——例如，在仿射（x,y）坐标中，prime256v1曲线的x和y各占256位，总共是512位。压缩编码利用了椭圆曲线有两个可能的y值这一特性，给定曲线和点的x坐标，所以prime256v1上点的压缩表示只包含完整的x坐标（256位）和1位y坐标，总共257位。“高效密码学标准，SEC
    1：椭圆曲线密码学”规定了一种常见的编码方式：如果点是未压缩的，它会以0x04为前缀；如果是压缩的，则以0x02或0x03为前缀，具体取决于y的1位值。
- en: You may be thinking, how is embedding a verification key with the object to
    verify secure? That could be easily forged! And you’d be right. To save space,
    the public key’s hash is typically stored in fuses. This means during boot, first
    the public key’s hash is verified against the stored hash and only then is it
    used to verify the image. This sequence gives attackers a second point for fault
    injection. They could create an image that embeds their own public key and sign
    the image with that key. Next, fault injection can be used to skip the key verification.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，如何将验证密钥嵌入到对象中以进行安全验证？这很容易被伪造啊！你说得对。为了节省空间，公钥的哈希值通常会存储在保险丝中。这意味着在启动时，首先会验证公钥的哈希值是否与存储的哈希值一致，只有通过验证后，公钥才会用来验证固件镜像。这一过程为攻击者提供了第二个故障注入的切入点。攻击者可以创建一个固件镜像，嵌入他们自己的公钥，并用这个密钥签署固件镜像。接下来，可以通过故障注入绕过密钥验证。
- en: 'Less common ways of signing a firmware image are with hash-based message authentication
    code (HMAC) or cipher-based message authentication code (CMAC). These authentication
    codes require distributing a symmetric key, which means either you have a “root
    key” programmed into each device (capable of verifying and signing arbitrary images)
    or you’re diversifying the symmetric keys per device but then need to encrypt
    each firmware image with a device-specific key. The first option is foolish; the
    second option is costly. The first option is also exactly what happened with the
    Philips Hue attack (see “IoT Goes Nuclear: Creating a ZigBee Chain Reaction” by
    Eyal Ronen et al.), so don’t always assume that you can rule something out because
    *surely no serious product would do it that way*.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '固件镜像的签名方式较少见的包括基于哈希的消息认证码（HMAC）或基于密码的消息认证码（CMAC）。这些认证码要求分发对称密钥，这意味着要么你在每个设备中都编程了一个“根密钥”（能够验证并签署任意固件镜像），要么你为每个设备分配不同的对称密钥，但这样就需要用设备专用的密钥加密每个固件镜像。第一种选择是愚蠢的；第二种选择则成本高昂。第一种选择也正是菲利普Hue攻击的发生方式（参见Eyal
    Ronen等人撰写的《IoT Goes Nuclear: Creating a ZigBee Chain Reaction》），因此不要总是认为你可以排除某种方式，因为*肯定没有哪个严肃的产品会这么做*。'
- en: Summary
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored how to collect useful information for hardware
    hacking attacks, which typically will be all you need. Devices often don’t have
    firmware encryption, for example, and once you have the ability to dump the firmware
    with JTAG, you can learn enough to exploit the device.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何收集硬件黑客攻击所需的有用信息，这通常就是你所需要的一切。例如，许多设备并没有固件加密，一旦你有能力通过JTAG提取固件，你就能学到足够的知识来利用该设备。
- en: With any luck, we can learn enough to exploit a system directly, and if we are
    forced to use more advanced attacks, we understand how they might apply to our
    system. Since this book is about advanced attacks, we’ll assume they’re needed
    and dive head-first into how they work. We’ll combine the information-discovering
    techniques described here with the interfacing skills outlined in Chapter 2 to
    test a system for fault injection weaknesses in the next chapter.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运气好的话，我们可以直接学到足够的知识来利用系统，如果我们被迫使用更高级的攻击手段，我们也能理解这些攻击如何应用到我们的系统上。由于本书讨论的是高级攻击方法，我们假设这些方法是必需的，并将直接深入探讨它们的工作原理。我们将结合本章中描述的信息发现技巧和第二章中概述的接口技能，在下一章中测试系统的故障注入弱点。
