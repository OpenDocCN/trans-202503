- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">REFERENCE
    AND VALUE PARAMETERS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">引用参数和值参数</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: In this chapter, we’ll look at how method parameters and arguments relate to
    reference and value types. We’ll revisit the idea that all variables have a value,
    regardless of their type, and see how to pass values of different types *by value*
    or *by reference* as arguments for methods.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将讨论方法参数和实参如何与引用类型和值类型相关。我们将重温所有变量都有值这一概念，无论它们的类型如何，并探讨如何将不同类型的值以*值传递*或*引用传递*的方式作为方法的实参。
- en: 'We’ll explore the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索以下内容：
- en: How *reference* and *by reference* differ in meaning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何*引用*和*按引用传递*的含义有所不同
- en: Why aliasing and mutability are so closely related
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么别名和可变性如此紧密相关
- en: How avoiding side effects can make our code clearer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何避免副作用可以使我们的代码更加清晰
- en: When to pass values by reference as an optimization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时将值按引用传递作为优化
- en: Passing method parameters by value or by reference isn’t the same as those parameters
    being value or reference types. In other words, the parameter’s type (value or
    reference) differs from how the method uses that parameter (by value or by reference).
    *Passing* in this context refers to the mechanism for supplying values to a method’s
    parameters and receiving the result the method returns.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 按值或按引用传递方法参数与这些参数是值类型还是引用类型不同。换句话说，参数的类型（值类型或引用类型）与方法如何使用该参数（按值传递或按引用传递）是不同的。这里的*传递*指的是将值提供给方法的参数并接收方法返回结果的机制。
- en: Before we get into those distinctions in detail, let’s look at how method parameters
    and arguments work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论这些区别之前，先来看看方法参数和实参是如何工作的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Method Parameters and Arguments</samp>
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">方法参数和实参</samp>
- en: As explained in [Chapter 2](chapter2.xhtml), method parameters are a particular
    kind of variable. A parameter variable is declared with a name and explicit type
    in the method’s definition and goes out of scope when the method ends. If the
    method is defined in a generic type or the method itself is generic, the parameter
    type can be generic. When we call the method, we pass arguments to each parameter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第2章](chapter2.xhtml)中解释的那样，方法参数是一种特殊的变量。参数变量在方法定义中声明一个名称和显式类型，并在方法结束时超出作用域。如果方法定义在泛型类型中，或方法本身是泛型的，那么参数类型也可以是泛型的。当我们调用方法时，我们将实参传递给每个参数。
- en: 'C# has four kinds of method parameters:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C# 有四种方法参数类型：
- en: '**Value parameters**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**值参数**'
- en: The most common kind of parameter, value parameters, behave as if they’re local
    variables in the method. A value parameter is initialized with the value of the
    argument passed to it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的参数类型——值参数——表现得就像是方法中的局部变量。值参数通过传递给它的实参的值进行初始化。
- en: '**Reference parameters**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**引用参数**'
- en: These parameters take the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier, signifying that they’re passed by reference. The arguments passed also
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier to reinforce
    that the argument and the parameter both refer to the same memory location.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 修饰符，表示它们是按引用传递的。传递的实参也使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 修饰符，以确保实参和参数都指向相同的内存位置。
- en: '**Output parameters**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出参数**'
- en: These are parameters that use the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifier, meaning they’re given a new value by the method. Output parameters are
    also passed by reference. As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier for reference parameters, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifier for both the argument being passed and the parameter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 修饰符的参数，意味着它们在方法中会被赋予一个新值。输出参数也是按引用传递的。与引用参数的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 修饰符一样，我们对传递的实参和参数都使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 修饰符。
- en: '**Input parameters**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入参数**'
- en: This special kind of reference parameter uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier to indicate that its value doesn’t change within the method. Unlike <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters, the argument passed to an input parameter doesn’t require the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier, because <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    is designed to be transparent to calling code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特殊类型的引用参数使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 修饰符来表示它的值在方法内部不会改变。与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    参数不同，传递给输入参数的实参不需要 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 修饰符，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 设计时是为了对调用代码透明的。
- en: Reference, output, and input parameters are special variables in that they indicate
    a level of indirection to an actual variable. They are known collectively as *by-reference
    parameters*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 引用、输出和输入参数是特殊的变量，因为它们表示指向实际变量的间接层级。它们统称为*通过引用传递的参数*。
- en: When we call a method, the arguments we pass populate the parameters we’ve declared
    for that method. When the parameter is a value parameter, our argument for it
    is passed by value. When the parameter is any of the by-reference parameters,
    our argument is passed by reference.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用一个方法时，传递的参数会填充我们为该方法声明的参数。如果参数是值参数，那么我们的实参是通过值传递的。如果参数是任何一种通过引用传递的参数，则我们的实参是通过引用传递的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reference Types vs.
    By-Reference Parameters</samp>
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">引用类型与通过引用传递的参数</samp>
- en: 'By-reference parameters are sometimes confused with reference type variables,
    in part because the phrase *pass by reference* is often used along with its companion,
    *pass by value*, to describe how reference types differ from value types. Consider
    Microsoft’s guide to framework design ([*http://<wbr>msdn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/library<wbr>/ms229017<wbr>.aspx*](http://msdn.microsoft.com/en-us/library/ms229017.aspx)),
    which includes the following statement:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用传递的参数有时会与引用类型变量混淆，部分原因是因为“*通过引用传递*”这一短语常与其搭档“*通过值传递*”一起使用，用来描述引用类型与值类型的区别。参考微软的框架设计指南（[*http://<wbr>msdn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/library<wbr>/ms229017<wbr>.aspx*](http://msdn.microsoft.com/en-us/library/ms229017.aspx)），其中包括以下内容：
- en: Reference types are passed by reference, whereas value types are passed by value.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 引用类型通过引用传递，而值类型通过值传递。
- en: This is a not-quite-accurate description of the mechanics of passing by reference.
    To say that reference types are passed by reference is conflating the concepts
    of type and passing. Arguments for by-reference parameters are passed by reference,
    no matter the argument’s type. Put another way, arguments of either reference
    or value type may be passed either by reference or by value, according to the
    presence or absence of a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier for the method’s parameters. A by-reference parameter is not itself a
    reference, but the variable it refers to might be. Terminology is fun, isn’t it?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这对通过引用传递的机制描述并不完全准确。说引用类型是通过引用传递的，将类型与传递方式的概念混淆了。无论实参的类型如何，传递给通过引用传递的参数的实参都会通过引用传递。换句话说，无论是引用类型还是值类型的实参，都可以根据方法参数是否包含
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 修饰符来决定是通过引用传递还是通过值传递。一个通过引用传递的参数本身不是引用，但它所指向的变量可能是。术语有趣吧？
- en: 'In [Chapter 2](chapter2.xhtml), we explored how reference types and value types
    have different copy semantics, and passing arguments and copying variable values
    are related ideas. In particular, when we pass an argument by value, we make a
    copy of its value. The Microsoft documentation article quoted earlier goes on
    to say this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](chapter2.xhtml)中，我们探讨了引用类型和值类型在复制语义上的不同，以及传递参数和复制变量值是如何相关的。特别是，当我们通过值传递参数时，我们是对其值进行了复制。前面引用的微软文档文章继续这样写道：
- en: Changes to an instance of a reference type affect all references pointing to
    the instance. [...] When an instance of a value type is changed, it of course
    does not affect any of its copies.
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对引用类型实例的修改会影响所有指向该实例的引用。[...] 当修改一个值类型实例时，当然不会影响其任何副本。
- en: The operative word here is *instance*. We can have multiple references to a
    single instance of a reference type. Copying a reference doesn’t make a copy of
    the *instance*, just a copy of the reference’s value. By contrast, a copy of a
    value type variable is a new instance, independent of the original value. The
    value *is* the instance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键词是 *实例*。我们可以对引用类型的单个实例有多个引用。复制一个引用并不会复制 *实例*，而只是复制引用的值。相比之下，值类型变量的复制是一个新的实例，它独立于原始值。值
    *就是* 实例。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value Types and Parameters</samp>
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">值类型与参数</samp>
- en: A *value type variable* directly contains the data represented by the member
    fields of the type. This is true whether the variable is a local instance, a field
    stored in another object, or a parameter for a method. Consider the simple value
    type in [Listing 3-1](#list3-1) representing a two-dimensional coordinate.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*值类型变量* 直接包含由该类型成员字段表示的数据。无论变量是本地实例、存储在其他对象中的字段，还是方法的参数，这一点都是成立的。考虑 [列表 3-1](#list3-1)
    中表示二维坐标的简单值类型。'
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-1: A simple Coordinate
    value type</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-1：一个简单的坐标值类型</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> type has
    two <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> fields, each of which
    takes up a single location in memory. A variable of this type, such as the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">position</samp> variable in [Listing 3-1](#list3-1),
    will directly contain the entire instance. The memory used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp>
    variable would look more or less like [Figure 3-1](#fig3-1).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> 类型有两个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 字段，每个字段占用内存中的一个位置。像 [列表 3-1](#list3-1)
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> 变量这样的该类型变量，会直接包含整个实例。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">position</samp> 变量所使用的内存大致类似于 [图 3-1](#fig3-1)
    中的表示。
- en: '![](../images/Figure3-1.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: Memory representation
    of a simple value</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-1：简单值的内存表示</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> variable doesn’t
    refer to the data in memory but rather stores the contents of each field of a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> directly in place.
    If a type has multiple fields, those fields are stored in consecutive locations.
    If we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> into
    another variable, each field’s value in the new variable is an independent copy
    of the corresponding field’s value in the original <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp>
    variable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> 变量并不引用内存中的数据，而是直接存储一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> 类型每个字段的内容。如果一个类型有多个字段，这些字段会存储在连续的位置。如果我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> 复制到另一个变量中，新变量中每个字段的值将是原始
    <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> 变量对应字段值的独立副本。
- en: If we pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    value as an argument to a method’s value parameter, the whole value is copied
    into the parameter. In [Listing 3-2](#list3-2), we have a method, <samp class="SANS_TheSansMonoCd_W5Regular_11">Difference</samp>,
    with two <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> value
    parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">end</samp>, and we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp>
    variable as an argument to both parameters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> 值作为参数传递给方法的值参数，整个值将被复制到参数中。在
    [列表 3-2](#list3-2) 中，我们有一个方法 <samp class="SANS_TheSansMonoCd_W5Regular_11">Difference</samp>，它有两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> 值参数，<samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp>
    变量作为参数传递给这两个参数。
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-2: A method with
    two value parameters</samp>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-2：一个带有两个值参数的方法</samp>
- en: Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Difference</samp>
    method’s parameters are both taken by value, each parameter receives its own copy
    that’s independent of the original value. The result looks something like [Figure
    3-2](#fig3-2) in memory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Difference</samp> 方法的参数都是按值传递的，每个参数都会接收到它自己的副本，且与原始值是独立的。结果在内存中的表现类似于[图
    3-2](#fig3-2)。
- en: '![](../images/Figure3-2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: Memory representation
    of a copied value</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-2：复制值的内存表示</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>
    parameters are initialized with the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp>
    argument passed to them, and each has its own copy within the method itself.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>
    参数被初始化为传递给它们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">position</samp> 参数的值，并且它们各自拥有该值的副本，在方法内部独立存在。
- en: When we assign one value to another or pass a value type instance as an argument
    by value, we copy the value. Two value type variables are always independent instances.
    This is the essence of *copy-by-value* semantics.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个值赋给另一个值，或者按值传递一个值类型实例作为参数时，我们是在复制该值。两个值类型变量总是独立的实例。这就是 *按值复制* 语义的本质。
- en: Reference type variables behave differently because their value is a reference.
    A reference’s value is used to identify an instance of the type on the heap or
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型变量的行为不同，因为它们的值是一个引用。引用的值用于标识堆上某类型的实例，或者是 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Value of a Reference</samp>
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">引用的值</samp>
- en: 'When we create an instance of a reference type, memory is allocated on the
    heap, and a reference identifying the location of that memory is stored in the
    variable. Syntactically, it appears that the type of a reference variable is the
    type of the instance to which it refers, as illustrated here with a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    variable:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个引用类型的实例时，内存会在堆上分配，并且一个标识该内存位置的引用会存储在变量中。从语法上来看，引用变量的类型似乎是它所引用的实例的类型，如这里所示的一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 变量：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’d normally refer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    variable as a string. However, that’s not completely accurate. It’s more precise
    to say that <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> is a variable
    whose *type* is <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> and
    whose *value* is a *reference* to an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    type. The type of a reference variable need not exactly match the type of the
    instance. For example, we can use a base class reference variable, such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, to refer to a more specific
    reference type instance, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会将 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 变量称为一个字符串。然而，这并不完全准确。更精确的说法是，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 是一个 *类型* 为 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    的变量，而它的 *值* 是一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    类型实例的 *引用*。引用变量的类型不一定需要与实例的类型完全匹配。例如，我们可以使用基类引用变量，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>，来引用一个更具体的引用类型实例，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>。
- en: A reference’s value is an opaque handle used by the Common Language Runtime
    (CLR) to identify an object. We’re not really interested in what the value of
    a reference is; references are just the mechanism by which we access and manipulate
    instances of a reference type, as illustrated in [Figure 3-3](#fig3-3).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 引用的值是一个不透明的句柄，供公共语言运行时（CLR）用来标识一个对象。我们其实并不关心引用值是什么；引用只是我们访问和操作引用类型实例的机制，如[图
    3-3](#fig3-3)所示。
- en: '![](../images/Figure3-3.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: Memory representation
    of a string reference</samp>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-3：字符串引用的内存表示</samp>
- en: In [Figure 3-3](#fig3-3), <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    is a variable whose value is a reference. A reference does not itself have a distinct
    type (certainly not one we can name), but it does have a value. The value of a
    non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference is a handle
    to an area of memory allocated on the heap that contains the instance of a reference
    type.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 3-3](#fig3-3)中，<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>是一个值为引用的变量。引用本身并没有独立的类型（当然，我们无法为它命名），但它有一个值。一个非<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>引用的值是指向堆上分配内存区域的句柄，该区域包含一个引用类型的实例。
- en: 'This precision matters because when we’re talking about passing or copying
    variables, we really mean passing or copying *values*. For value types, this distinction
    doesn’t exist: the value of a struct variable *is* the instance. However, reference
    variables are distinct from the instances they refer to—when we copy a reference
    variable’s value, we’re making a copy of the reference, not the instance.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种精确度非常重要，因为当我们谈论传递或复制变量时，实际上是指传递或复制*值*。对于值类型而言，这种区别不存在：结构体变量的值*就是*实例。然而，引用变量与它们所指向的实例是不同的——当我们复制一个引用变量的值时，实际上是在复制引用，而不是实例。
- en: Some languages use pointers to objects in memory, but a reference isn’t quite
    the same as a pointer. References can’t be used for just anything in memory. They’re
    specifically used to access reference type objects on the heap and to track those
    objects when they move around as a result of garbage collection and memory compaction.
    The details of those processes are hidden from us and handled automatically as
    part of the memory management for reference types.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言使用指针来访问内存中的对象，但引用与指针略有不同。引用不能像指针一样用于内存中的任何位置。它们专门用于访问堆上的引用类型对象，并在垃圾回收和内存压缩时跟踪这些对象的移动。我们不需要关心这些过程的细节，它们作为引用类型内存管理的一部分被自动处理。
- en: We can think of the value of a reference as being a kind of address. In this
    respect, a reference value behaves very much like a value type instance. Like
    a value type variable, a reference type variable directly contains its value (an
    address) and lives within the scope of its parent, which might be the stack frame
    for the local variables of a method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将引用的值看作是一种地址。在这方面，引用值的行为与值类型实例非常相似。像值类型变量一样，引用类型变量直接包含它的值（一个地址），并且存在于其父作用域内，可能是方法的局部变量栈帧。
- en: 'With that in mind, consider this: *all* variables, whether they represent reference
    or value types, have values that may be copied. More than that, by default, all
    variable values are copied—and passed—*by value*.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，考虑一下：*所有*变量，无论是表示引用类型还是值类型，都有可能被复制。更重要的是，默认情况下，所有变量值都是按值*复制*并传递的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reference Variables
    and Aliasing</samp>
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">引用变量与别名</samp>
- en: '*Aliasing* refers to accessing a single memory location via multiple variables.
    As you’ve seen, when we copy one reference to another, such as when we pass a
    reference as an argument to a method, we create two aliasing references—the argument
    variable and the parameter variable—to the same object in memory.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*别名*指的是通过多个变量访问同一内存位置。正如你所见，当我们将一个引用复制到另一个引用时，例如将引用作为参数传递给方法时，我们就创建了两个指向同一内存对象的别名引用——参数变量和参数对应的变量。'
- en: In contrast, when we pass a value type instance as an argument, the argument
    variable and parameter variable are identical but independent copies of each other.
    The difference between reference types and values in this respect is most significant
    when the instances are mutable (that is, their state can be altered).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，当我们将值类型实例作为参数传递时，参数变量和参数对应的变量是完全相同但独立的副本。参考类型和值类型在这方面的区别在实例是可变时最为显著（即它们的状态可以改变）。
- en: Aliasing can be intentional and useful, such as when we want changes to an object
    to be observable by all references to it, wherever they might be. For example,
    see the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> classes in [Listing 3-3](#list3-3);
    we create an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    type by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp>
    method of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>, and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> object stores
    a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    instance used to create the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    instance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 别名化可以是有意为之且有用的，比如当我们希望对某个对象的更改能被所有引用该对象的地方观察到时。例如，请参阅[示例 3-3](#list3-3)中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    类；我们通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp> 方法来创建一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    类型的实例，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> 对象保存了对用于创建
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> 实例的 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    实例的引用。
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-3: Storing a reference
    to a DataStore as a property of Command</samp>'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-3：将 DataStore 的引用作为 Command
    的属性保存</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp> method
    returns a reference to the newly created <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    object, with its reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    instance. We can *mutate*—change the state of—the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    object by using its <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> methods, and whether
    we use a local <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    variable or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Connection</samp>
    property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> object
    returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp>,
    we’ll update the same <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    instance because both references are aliases for the same object, as demonstrated
    in [Listing 3-4](#list3-4).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp> 方法返回对新创建的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> 对象的引用，该对象持有对 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> 实例的引用。我们可以通过使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Open</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp>
    方法来*修改*（更改状态）<samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> 对象，无论我们使用本地的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> 变量，还是使用从 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateCommand</samp> 返回的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    对象的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Connection</samp> 属性，我们都会更新相同的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> 实例，因为这两个引用都是指向同一个对象的别名，如[示例
    3-4](#list3-4)所示。
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-4: Mutating the DataStore
    instance via an alias</samp>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-4：通过别名修改 DataStore 实例</samp>
- en: We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp> method
    by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Connection</samp> property
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp> variable and
    test that the state of the local variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">store</samp>
    has been changed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp> 变量的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Connection</samp> 属性来调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp>
    方法，并测试名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">store</samp> 的本地变量的状态是否已被更改。
- en: 'Value type variables are never aliases for a single instance, so changes to
    an instance are visible only in the variable used to make the change. Value type
    instances are copied by value, so each copy is an independent instance. This process
    is analogous to me sending you a document as an email attachment: we both have
    our own copy of the document, so if I change my copy, your copy is unaffected,
    and vice versa.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型变量从不是单一实例的别名，因此对实例的更改只对用于进行更改的变量可见。值类型实例是按值复制的，因此每个副本都是独立的实例。这个过程类似于我将文档作为电子邮件附件发送给你：我们每个人都有文档的副本，因此如果我更改了我的副本，你的副本不会受到影响，反之亦然。
- en: However, if I instead send a link to a shared document that we can both edit,
    any change either of us makes will be visible to us both via that link. The link
    is similar to a reference; it’s a kind of address for the document, but it’s not
    the document itself. The link represents a level of indirection to the real document.
    In exactly the same way, a reference variable doesn’t contain an object but instead
    a reference, and the object’s instance is accessed indirectly via that reference.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我发送一个我们都可以编辑的共享文档的链接，那么我们双方所做的任何更改都将通过该链接对我们两个人可见。这个链接类似于一个引用；它是文档的地址，但它不是文档本身。这个链接代表了指向真实文档的间接层次。完全同样地，引用变量并不包含对象，而是一个引用，通过该引用间接访问对象的实例。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Mutable By-Reference Parameters</samp>
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">可变的按引用传递参数</samp>
- en: By default, method parameters are value parameters, meaning that arguments passed
    to them are passed by value, regardless of the argument’s type. In this section,
    we’ll look at the *mutable by-reference parameters*, <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>, which cause arguments
    to be passed instead by reference.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，方法参数是值参数，这意味着传递给它们的参数是按值传递的，无论参数的类型如何。在本节中，我们将讨论*可变的按引用传递参数*，即<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">out</samp>，它们使得参数按引用传递。
- en: Value type instances and references can both be passed by reference by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifiers, so it’s important to understand that by-reference parameters are different
    from reference type *value* parameters. When we pass a reference as an argument
    to a reference type value parameter, the same object instance is referenced by
    both the argument and parameter variables, and any change to the instance is visible
    via either variable. A by-reference parameter, in contrast, is an alias for the
    value of the argument variable, whether that value is a reference or value type
    instance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型的实例和引用都可以通过使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">out</samp>修饰符按引用传递，因此理解按引用传递的参数与引用类型的*值*参数不同是很重要的。当我们将引用作为参数传递给引用类型值参数时，参数和引用变量都指向相同的对象实例，对实例所做的任何更改都可以通过任一变量看到。相比之下，按引用传递的参数是参数变量值的别名，无论该值是引用类型还是值类型实例。
- en: The presence of a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> modifier on a parameter
    means that when we call the method, the address of the argument’s value is passed
    rather than a copy of the value. This extra level of indirection means that regardless
    of the argument’s type, both the caller and the method directly access the same
    value. If the argument’s value is a reference, we can change it to refer to a
    new instance or assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    to it, and that change is visible via both the argument and the parameter variables.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数上使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>修饰符意味着，当我们调用方法时，传递的是参数值的地址，而不是值的副本。这个额外的间接层次意味着无论参数的类型如何，调用者和方法都能直接访问相同的值。如果参数的值是引用类型，我们可以将它更改为指向一个新实例，或者将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>赋给它，这一变化通过参数和参数变量都能看到。
- en: To illustrate the difference between reference variables and by-reference parameters,
    consider [Listing 3-5](#list3-5), where we pass a reference by value to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method that attempts
    to change its <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> parameter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明引用变量和按引用传递的参数之间的区别，考虑[列表 3-5](#list3-5)，其中我们通过值传递一个引用给尝试更改其<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>参数的<code>AutoAppend</code>方法。
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-5: Creating a new
    instance versus changing an instance</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-5：创建新实例与更改实例</samp>
- en: This test fails, even though <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    is a reference type. Although the <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>
    operator appears as though it’s mutating the string, it actually creates a new
    string with the updated contents and returns a new reference to it. The new reference
    and instance are visible within the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>
    method but not outside it. The original string is unchanged.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 即使<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>是引用类型，这个测试仍然会失败。尽管<samp
    class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>操作符看起来像是在修改字符串，实际上它创建了一个包含更新内容的新字符串，并返回一个新的引用指向它。新的引用和实例在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>方法中可见，但在方法外部不可见。原始字符串没有变化。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method isn’t
    changing the shared <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    instance, but rather the *value* of its <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    parameter. Calling <samp class="SANS_TheSansMonoCd_W5Regular_11">+=</samp> here
    changes the reference to refer to a new, different instance. The <samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>
    variable used as an argument for <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>
    still refers to the original, unchanged instance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>方法并没有改变共享的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp>实例，而是改变了其<samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>参数的*值*。在这里调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>会改变引用，使其指向一个新的、不同的实例。用作<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>参数的<samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>变量仍然指向原始的、未改变的实例。
- en: This demonstrates clearly that when we pass a reference as an argument, it is,
    by default, passed by value. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>
    method in [Listing 3-5](#list3-5) to work as expected, we need to pass the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp> reference by reference
    so that when the method alters the value of the reference *variable*, the change
    is visible to the calling code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地证明了，当我们按引用传递一个参数时，默认情况下它是按值传递的。为了使[清单 3-5](#list3-5)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>方法按预期工作，我们需要按引用传递<samp
    class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>引用，这样当方法更改引用*变量*的值时，变化能被调用代码看到。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing References
    by Reference</samp>
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">按引用传递引用</samp>
- en: The most direct way to make our test in [Listing 3-5](#list3-5) pass is to use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier to make
    <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> a by-reference parameter.
    [Listing 3-6](#list3-6) shows the same <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>
    method as [Listing 3-5](#list3-5), except in this version we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    parameter by reference by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier on it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们在[清单 3-5](#list3-5)中的测试通过的最直接方法是使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>修饰符，将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp>参数改为引用类型。[清单 3-6](#list3-6)展示了与[清单
    3-5](#list3-5)相同的<samp class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>方法，不同之处在于，在这个版本中，我们通过在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">name</samp>参数上使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>修饰符，使其通过引用传递。
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-6: Using the ref
    modifier to pass name by reference</samp>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 3-6：使用ref修饰符按引用传递name</samp>
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier
    on both the method’s parameter and the argument we pass to it because we’re passing
    a reference to a variable. The test now passes because the changes that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp> method makes to the
    value of the reference variable are visible via the <samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>
    variable in the calling code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在方法的参数和传递给它的参数上都使用了<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>修饰符，因为我们是按引用传递变量。现在测试通过了，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AutoAppend</samp>方法对引用变量值所做的更改可以通过调用代码中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>变量看到。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> parameter is,
    in effect, an alias for the <samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp>
    variable, as illustrated in [Figure 3-4](#fig3-4).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>参数实际上是<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">saveName</samp></sup>变量的别名，如[图
    3-4](#fig3-4)所示。
- en: '![](../images/Figure3-4.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: A by-reference
    parameter aliases a variable.</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-4：按引用传递的参数作为变量的别名。</samp>
- en: The consequence of using a by-reference parameter is that the argument and the
    parameter variables don’t just refer to the same instance—they’re effectively
    the same reference. We can still use the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    parameter to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    instance (for example, to access properties or call methods), and the compiler
    hides the extra level of indirection afforded by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier on the parameter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用按引用传递的参数的结果是，参数变量和实参变量不仅指向相同的实例——它们实际上是相同的引用。我们仍然可以使用<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp></sup>参数访问<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp></sup>实例（例如，访问属性或调用方法），而编译器隐藏了通过参数上的<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp></sup>修饰符提供的额外间接层。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing Values by
    Reference</samp>
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">按引用传递值</samp>
- en: We can pass value type variables by reference too. Keep in mind that passing
    arguments by reference doesn’t imply that the parameter is a reference variable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过引用传递值类型变量。请记住，通过引用传递参数并不意味着该参数是引用变量。
- en: When we pass a value type instance as an argument to a method, the method normally
    gets a copy of the instance because of the copy-by-value semantics of value types.
    As you’ve seen previously, any changes made to the fields of the instance inside
    the method aren’t visible to the calling code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个值类型实例作为参数传递给方法时，方法通常会获得该实例的副本，因为值类型的语义是按值传递。如你之前所见，方法内对实例字段的任何修改在调用代码中是不可见的。
- en: If we require those changes to be visible outside the method, we need to pass
    the value by reference. In [Listing 3-7](#list3-7), we introduce an <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    method that takes a mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value type parameter by reference and changes its value. Value types like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> should almost always be immutable,
    and you’ll see in “Mutation vs. Creation” on [page 89](#sec22) how to express
    this differently. This example merely demonstrates that the mechanism for passing
    value types by reference is identical to passing references by reference.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望这些更改在方法外部可见，就需要通过引用传递值。在[列表 3-7](#list3-7)中，我们引入了一个名为<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp></sup>的方法，该方法通过引用传递一个可变的<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp></sup>值类型参数并更改其值。像<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp></sup>这样的值类型几乎总是应该是不可变的，你将在《突变与创建》一章中（见[第89页](#sec22)）了解如何以不同的方式表达这一点。这个例子只是为了演示按引用传递值类型的机制与按引用传递引用类型是相同的。
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-7: Value type by-reference
    parameters</samp>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-7：按引用传递值类型参数</samp>
- en: When we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    method, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> modifier
    to pass the argument for the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>
    parameter by reference, just as we did for the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    parameter in [Listing 3-6](#list3-6). As a result, the change to <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property
    within <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> is visible
    to the calling code, as shown in [Listing 3-8](#list3-8).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp></sup>方法时，我们使用<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp></sup>修饰符按引用传递<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp></sup>参数的值，就像在[列表
    3-6](#list3-6)中对<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp></sup>参数所做的那样。因此，在<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp></sup>方法中对<sup><samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp></sup>的<sup><samp
    class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp></sup>属性的更改对调用代码是可见的，正如在[列表
    3-8](#list3-8)中所示。
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-8: Using the ref
    modifier to pass speed by reference</samp>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 3-8：使用ref修饰符通过引用传递speed</samp>
- en: Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> variable
    is passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> by
    reference, <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> is aliased
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> method.
    Both the calling code and <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    are effectively using the same variable, so any changes to the value of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">initial</samp> parameter are visible within
    both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> method
    and the code that calls it. The test shows that we’re expecting the value to be
    changed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>变量通过引用传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>，因此<samp
    class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>在<samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>方法中被别名化。调用代码和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>方法实际上使用的是同一个变量，因此对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>参数值的任何更改在<samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>方法和调用它的代码中都可见。测试表明，我们期望该值被更改。
- en: '> <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '> <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>'
- en: '*To reiterate, by-reference parameters aren’t the same as reference type variables.
    A* reference type variable *refers to an instance of a reference type, whereas
    a* by-reference parameter *refers to a variable, which can be either a reference
    type or a value type.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*再强调一次，通过引用传递的参数与引用类型变量不同。一个*引用类型变量*是指向一个引用类型实例的，而一个*通过引用传递的参数*是指向一个变量，该变量可以是引用类型或值类型。*'
- en: References can refer only to an object on the heap. If we assign a reference
    type variable to an instance of a value type, the value is boxed onto the heap,
    and the variable refers to the boxed copy. A by-reference parameter adds an extra
    level of indirection to a variable’s value. When we pass a value type instance
    by reference, the value is neither boxed nor copied.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 引用只能引用堆上的对象。如果我们将引用类型变量分配给值类型实例，则该值会被装箱到堆上，变量会引用装箱的副本。通过引用传递的参数为变量的值添加了一个额外的间接层。当我们通过引用传递值类型实例时，值既没有被装箱也没有被复制。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Working with Output
    Parameters</samp>
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">处理输出参数</samp>
- en: '*Output parameters*, designated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifier, are mutable by-reference parameters and are usually used when we require
    a method to create a new instance of an object for that parameter variable. They’re
    similar to reference parameters in that they, too, alias the variable used as
    the argument. The argument we pass to the method is usually uninitialized, and
    the method will initialize it by assigning a value to populate the output parameter
    variable.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出参数*，由<samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>修饰符指定，是通过引用传递的可变参数，通常在需要方法为该参数变量创建新实例时使用。它们与引用参数类似，因为它们也别名化用作参数的变量。我们传递给方法的参数通常未初始化，方法将通过为输出参数变量赋值来初始化它。'
- en: More formally, the difference between a reference parameter and an output parameter
    is that a reference argument must be definitely assigned before it’s passed, whereas
    an output argument may or may not be initialized when it’s passed, but the parameter
    must be assigned a value within the method either way.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，引用参数和输出参数之间的区别在于，引用参数在传递之前必须被明确赋值，而输出参数在传递时可以已初始化也可以未初始化，但无论如何，参数必须在方法中被赋值。
- en: Output parameters are typically used when acquiring a new instance of an object
    could fail without the failure being a fatal or even serious problem. Examples
    include parsing a string for a specifically formatted value, connecting to an
    unreliable service, and reading a value from a shared resource such as a queue,
    which could be empty. In cases like these, we often want a way to attempt the
    process and be able to either ignore a failure or retry the operation. If the
    operation succeeds, we receive a valid object as a result.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输出参数通常用于当获取新对象实例可能失败，但失败不会是致命的或严重问题的情况。例子包括解析字符串以获取特定格式的值、连接到不可靠的服务以及从共享资源（如队列）中读取值，该资源可能为空。在这种情况下，我们通常希望能够尝试该过程，并能够忽略失败或重试操作。如果操作成功，我们将获得一个有效的对象作为结果。
- en: The common approach to this use case is to define a method that takes at least
    one output parameter and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>
    indicating success or failure. If the method succeeds, the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter is initialized with a new object, and the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>,
    indicating that the argument passed has been successfully initialized. If the
    operation is unsuccessful, the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>,
    indicating to the caller that the output argument’s value should be ignored. This
    is a common technique in C# known as <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此使用案例的常见方法是定义一个方法，该方法至少接受一个输出参数，并返回一个表示成功或失败的 <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>。如果方法成功，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 参数将被初始化为一个新对象，方法返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>，表示传递的参数已成功初始化。如果操作失败，方法返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>，指示调用者忽略输出参数的值。这是 C#
    中一种常见的技术，称为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using the TryXXX Idiom</samp>
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使用 TryXXX 习语</samp>
- en: The Standard Library has several examples of using <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> to parse a string
    for a specific kind of value, such as a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    object. The <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.TryParse</samp>
    method takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> parameter
    and an output parameter for a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    value. If the parse fails, the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
    If the parse succeeds, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    value will contain the date parsed from the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>.
    [Listing 3-9](#list3-9) demonstrates how we might use this idiom.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中有多个示例，演示了如何使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> 来解析字符串，查找特定类型的值，例如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> 对象。<samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.TryParse</samp>
    方法接受一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 参数和一个用于输出 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> 值的输出参数。如果解析失败，该方法返回 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp>。如果解析成功，<samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    值将包含从 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 解析出的日期。[清单 3-9](#list3-9)
    演示了我们如何使用这个习语。
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-9: The Try</samp>XXX
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">idiom</samp>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 3-9：Try</samp>XXX <samp class="SANS_Futura_Std_Book_Oblique_I_11">习语</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">logTime</samp> variable passed
    as an argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp>
    may come from an unreliable source, such as user input or a file. Incorrectly
    formatted dates are an error but shouldn’t be considered an exceptional case.
    A successful call to <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp>
    means the <samp class="SANS_TheSansMonoCd_W5Regular_11">timeStamp</samp> variable
    is a valid <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> instance.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp> returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">timeStamp</samp>
    variable is default-initialized instead.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参数传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp> 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">logTime</samp> 变量可能来自不可靠的来源，例如用户输入或文件。格式错误的日期是一个错误，但不应视为异常情况。成功调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp> 表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">timeStamp</samp>
    变量是一个有效的 <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> 实例。如果 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp> 返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>，则
    <samp class="SANS_TheSansMonoCd_W5Regular_11">timeStamp</samp> 变量将被默认初始化。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The documentation for DateTime specifies that the failure case initializes
    the variable to the value of the MinValue property, but that’s equivalent to a
    default DateTime.*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*DateTime 的文档中指定，当解析失败时，变量将初始化为 MinValue 属性的值，但这等同于一个默认的 DateTime。*'
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    methods often have a companion version that *will* throw an exception when the
    operation fails. The exception version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.TryParse</samp>
    method, for example, is <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.Parse</samp>,
    which returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    value upon success and throws a <samp class="SANS_TheSansMonoCd_W5Regular_11">FormatException</samp>
    error upon failure. Handling exceptions can be intrusive, and failing to parse
    a string for a valid <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    is the kind of error we’d probably want to handle as soon as it occurs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    方法通常有一个伴随版本，在操作失败时*会*抛出异常。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.TryParse</samp>
    方法的异常版本是 <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime.Parse</samp>，该方法在成功时返回一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> 值，并在失败时抛出 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FormatException</samp> 错误。处理异常可能会有干扰，并且无法将字符串解析为有效的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> 是我们通常希望尽快处理的错误。
- en: 'If we had used the plain <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp>
    method, we might have wrapped the call in a <samp class="SANS_TheSansMonoCd_W5Regular_11">try…catch</samp>
    block, but this could become cumbersome if we had several strings to parse: to
    catch a failure on any one value, we’d have to wrap *each call* in its own <samp
    class="SANS_TheSansMonoCd_W5Regular_11">try</samp> block. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp>
    instead is more direct and less verbose.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用普通的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> 方法，我们可能会将调用包装在一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">try…catch</samp> 块中，但如果需要解析多个字符串，这可能会变得繁琐：为了捕获某一个值的失败，我们必须将*每个调用*都放入自己的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> 块中。相反，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">TryParse</samp>
    更直接且不那么冗长。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Making a Definite Assignment</samp>
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">进行明确的赋值</samp>
- en: 'The underlying mechanism for <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters is identical
    in the CIL, which has native support for by-reference parameters and arguments.
    They differ in the semantics imposed by the compiler: a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameter is considered initially assigned within the method, meaning a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> argument must be definitely
    assigned before being passed; an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter, on the other hand, is considered initially unassigned within the method,
    regardless of whether it had been assigned a value before the call. We must therefore
    definitely assign all <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters before the method returns. Not doing so results in a compile-time failure,
    as shown by this method, which attempts to return before the <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    parameter has been assigned:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    参数的底层机制在 CIL 中是相同的，CIL 本身对引用参数和参数有原生支持。它们在编译器强加的语义上有所不同：<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    参数在方法中被视为初始已赋值，这意味着在传递之前，<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    参数必须已被明确赋值；而 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 参数则被视为方法中未赋值，无论调用之前它是否已被赋值。因此，我们必须在方法返回之前明确赋值所有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 参数。不这样做会导致编译时失败，如下所示：该方法尝试在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> 参数尚未赋值之前返回：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We receive this error:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到这个错误：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The most straightforward way to avoid the error in this example would be to
    preemptively assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> parameter
    before returning <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>. By
    convention, an argument passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    method should be considered to have a valid value in the calling code only if
    the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 避免此示例中的错误最直接的方法是预先将 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    赋值给 <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> 参数，然后返回 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp>。根据惯例，传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> 方法的 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    参数应该仅在方法返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> 时，才在调用代码中被视为具有有效值。
- en: The target <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> variables
    in the calling code are considered definitely assigned only after a *normal* return
    from a method. It’s possible for control to leave the method *abnormally* by throwing
    an exception before all of its <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters have been assigned. If the method exits with an exception, the variables
    used as <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> arguments that
    weren’t definitely assigned prior to the method call remain not definitely assigned.
    Any arguments that were already definitely assigned before the call remain definitely
    assigned, although they may still have been given a new value within the method
    before the exception was thrown.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 调用代码中的目标 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 变量只有在方法正常返回之后才被视为已确定赋值。在所有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 参数赋值之前，控制可能通过抛出异常以*非正常*方式离开方法。如果方法以异常退出，则在方法调用之前没有明确赋值的作为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 参数的变量将保持未明确赋值。任何在调用之前已明确赋值的参数将继续保持已明确赋值，尽管它们可能在抛出异常之前仍在方法内被赋予了新值。
- en: However, we’d usually use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> idiom to *avoid* exceptions,
    as most users will expect such methods to not throw any exceptions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们通常会使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    习惯用法来*避免*异常，因为大多数用户期望此类方法不会抛出任何异常。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Selecting Operations</samp>
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">选择操作</samp>
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    idiom with an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter,
    like that shown in [Listing 3-9](#list3-9), is appealing because the method can
    be used inline in a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement to test the return value and capture the required output argument’s
    value all in one place. In [Listing 3-10](#list3-10), we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    method to determine how to obtain a list of results, using the ternary conditional
    operator <samp class="SANS_TheSansMonoCd_W5Regular_11">?:</samp> rather than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp> blocks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    output variable is declared inline in the argument list for the method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    习惯用法与 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 参数一起使用，如 [示例 3-9](#list3-9)
    中所示，具有吸引力，因为该方法可以在简单的 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句中内联使用，测试返回值并捕获所需输出参数的值。在 [示例 3-10](#list3-10) 中，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    方法来确定如何获取结果列表，使用三元条件运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">?:</samp>
    而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp> 块。<samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    输出变量在方法的参数列表中内联声明。
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-10: Using a simple
    out parameter</samp>'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-10：使用简单的 out 参数</samp>
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, the branch following <samp
    class="SANS_TheSansMonoCd_W5Regular_11">?</samp> is taken, and we can use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> output variable
    in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>.
    If the method returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>,
    indicating the connection to the remote resource failed, our code takes the branch
    following the <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> and loads
    the results from a cache instead.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> 返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>，则执行
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> 后面的分支，我们可以在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    时使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> 输出变量。如果方法返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>，表示连接到远程资源失败，我们的代码将执行
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> 后面的分支，并从缓存中加载结果。
- en: Note that we can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    to declare the type of the inline <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    argument, in which case the compiler will determine its type according to the
    type of the parameter in the method’s definition. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    method allows us to handle the failure to connect without the extra cost and complexity
    of handling an exception, and to attempt a different approach to obtain the list
    of results.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> 来声明内联 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> 参数的类型，在这种情况下，编译器将根据方法定义中参数的类型来确定其类型。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> 方法使我们能够处理连接失败的情况，而无需额外的成本和复杂的异常处理，并尝试不同的方法来获取结果列表。
- en: 'We can think of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> method as returning
    multiple values: a <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> to
    indicate the success or failure of attempting to obtain a resource, and the resource
    itself when its acquisition succeeds.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    方法视为返回多个值：一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> 值，用于指示获取资源是否成功，以及在获取成功时返回的资源本身。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Limitations of By-Reference Parameters</samp>
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">按引用传递参数的限制</samp>
- en: While methods with by-reference parameters are well suited for certain situations,
    such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    technique, by-reference parameters are not appropriate for every case, and the
    rules around definite assignment can sometimes require a different approach. Other
    restrictions can also affect where we can use these parameters. We’ll look at
    these restrictions in this section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然带有按引用传递参数的方法非常适合某些情况，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> 技巧，但按引用传递的参数并不适用于所有情况，且关于明确赋值的规则有时可能需要采用不同的方法。其他限制也可能影响我们可以使用这些参数的地方。我们将在本节中探讨这些限制。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Property Values</samp>
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">属性值</samp>
- en: The result of getting a property or indexer value can’t be used directly as
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    argument. In [Listing 3-11](#list3-11), we attempt to pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> instance
    as an argument to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 获取属性或索引器值的结果不能直接作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 参数使用。在 [列表 3-11](#list3-11)
    中，我们尝试将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> 实例的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 属性作为参数传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    参数。
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-11: Passing properties
    to ref parameters</samp>'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-11：将属性传递给 ref 参数</samp>
- en: 'The compiler rejects this code with the following error:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器拒绝了这段代码，并显示以下错误：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The compiler doesn’t allow this code because a property result is a value and
    not a variable. In [Chapter 2](chapter2.xhtml), you saw how variables can be assigned
    to, but values can’t. Accessing a property is exactly the same as reading the
    return value from a method call—something we look at in detail in [Chapter 4](chapter4.xhtml)—and
    methods return values, not variables. We usually use a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameter when we expect the called method to modify its argument, but because
    a property isn’t a variable, it *can’t* be modified.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不允许此代码，因为属性结果是值，而不是变量。在[第2章](chapter2.xhtml)中，您看到过变量可以被赋值，但值不能。访问属性与读取方法调用的返回值完全相同——这是我们在[第4章](chapter4.xhtml)中详细讨论的内容——而方法返回的是值，而不是变量。我们通常使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>参数，当我们期望被调用的方法修改其参数时，但因为属性不是变量，所以它*不能*被修改。
- en: It makes no difference whether <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    is a reference type or a value type. Passing a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> argument is essentially
    passing the address of the argument, and we can’t pass the address of a nonvariable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 无论<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>是引用类型还是值类型，都没有区别。传递<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>参数本质上是传递参数的地址，而我们不能传递一个非变量的地址。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overloading on By-Reference
    Parameters</samp>
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">基于引用参数的重载</samp>
- en: By-reference parameter modifiers are part of the signature of a method. A reference
    or output parameter is effectively a different type than its value parameter equivalent.
    If we have a method that takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameter, we can overload it with a method that takes that parameter by value.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用的参数修饰符是方法签名的一部分。引用参数或输出参数实际上是不同于其值参数等价物的类型。如果我们有一个接受<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>参数的方法，我们可以通过一个接受该参数按值传递的方法进行重载。
- en: Method overloads can have different return types, so we can write a method that
    takes its parameters by value and returns a new object, and overload it with a
    version taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter
    that modifies the object in place, as shown in [Listing 3-12](#list3-12).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重载可以具有不同的返回类型，因此我们可以编写一个按值传递参数并返回一个新对象的方法，并通过一个版本进行重载，该版本接受一个<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>参数来修改对象本身，如[列表
    3-12](#list3-12)所示。
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-12: Overloading on
    by-reference modifiers</samp>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-12：基于引用修饰符的重载</samp>
- en: When we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    method, the compiler selects the correct overload based on whether we modify the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> argument with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> keyword to pass it by reference
    or omit the modifier to call the version with a value parameter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用<samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>方法时，编译器会根据是否使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>关键字通过引用传递<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>参数，或者省略修饰符来调用带值参数的版本，从而选择正确的重载方法。
- en: We can’t, however, overload a method when the only difference is the kind of
    by-reference modifier for its parameters, as we try to do in [Listing 3-13](#list3-13).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能仅通过参数的引用修饰符类型不同来重载方法，就像我们在[列表 3-13](#list3-13)中尝试做的那样。
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-13: Overloading on
    different modifiers</samp>'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-13：基于不同修饰符的重载</samp>
- en: This might seem an arbitrary restriction. After all, calling code must differentiate
    between passing a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> argument
    and passing an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> argument.
    However, the compiler rejects this overload because the Common Language Infrastructure
    (CLI) has no way to distinguish between <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> in the method signature.
    Both are just by-reference parameters, so the two overloads have the same signature,
    as far as the CLI is concerned, resulting in ambiguity.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一个随意的限制。毕竟，调用代码必须区分传递一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    参数和传递一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 参数。然而，编译器拒绝这个重载，因为公共语言基础设施（CLI）无法区分方法签名中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>。两者都是通过引用的参数，因此从
    CLI 的角度来看，这两个重载具有相同的签名，导致了歧义。
- en: The same restriction applies with <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters, which we cover in “Read-Only References and Returning by Reference”
    on [page 92](#sec24). As with <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter is simply another
    kind of by- reference parameter, as far as the CLI is concerned.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的限制适用于 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 参数，详情请参见“只读引用和按引用返回”一节，见
    [第92页](#sec24)。与 <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 参数一样，<samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    参数对于 CLI 来说仅仅是另一种通过引用的参数。
- en: Overloading a method based purely on whether one or more parameters is taken
    by reference or by value is probably best avoided in any case. Anyone calling
    such a method needs a thorough knowledge of this somewhat arcane corner of overloading
    rules, so such code could easily be confusing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 基于参数是通过引用传递还是按值传递来重载方法，最好避免在任何情况下使用。调用这种方法的人需要对这种略显晦涩的重载规则角落有透彻的了解，因此这类代码可能会很容易让人困惑。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Fields</samp>
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用字段</samp>
- en: Making a field a by-reference variable is impossible. Again, this might seem
    arbitrary, but otherwise a by-reference field could become a *dangling* reference—that
    is, it could refer to an object that no longer exists.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将字段设置为通过引用的变量是不可能的。再次强调，这可能看起来很随意，但否则一个通过引用的字段可能会变成一个 *悬空* 引用——即它可能指向一个已不存在的对象。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*As of C# v11.0, by-reference fields are permitted within ref struct types,
    which are specialized value types intended for high-performance applications.
    Numerous restrictions on ref struct types make them less suitable for most general-purpose
    code, so we don’t cover them in this book.*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*从 C# v11.0 开始，允许在 ref 结构类型中使用通过引用的字段，这些类型是为高性能应用程序设计的专用值类型。由于 ref 结构类型有许多限制，使它们不太适合大多数通用代码，因此我们在本书中不涉及它们。*'
- en: Consider a class like <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp>
    in [Listing 3-14](#list3-14), which attempts to store a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameter in a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> field.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下像 [清单 3-14](#list3-14) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp>
    类，它尝试将一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 参数存储在一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 字段中。
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-14: A hypothetical
    Reminder class that stores a field by reference</samp>'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 3-14：一个假设的 Reminder 类，它通过引用存储一个字段</samp>
- en: Although this approach might seem attractive in principle—say, if we want the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp> class to deliberately
    alias the argument to its constructor, or we want to avoid copying the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    instance—this code doesn’t compile. The compiler rejects it as simply invalid
    syntax because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp>
    instance could be used after the referenced <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    variable has gone out of scope, meaning the field would become a reference to
    memory that no longer exists or, perhaps worse, memory that has been allocated
    to something else. The <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    field would be a dangling reference, something the rules of C# go to great lengths
    to prevent.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法在原则上看起来很有吸引力——比如，如果我们希望让 <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp>
    类故意别名化其构造函数的参数，或者我们希望避免复制 <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    实例——但是这段代码无法编译。编译器会拒绝它，认为它只是无效的语法，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Reminder</samp>
    实例可能在引用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp> 变量已经超出作用域后仍被使用，这意味着该字段将变成指向不再存在的内存的引用，或者更糟的是，指向已分配给其他内容的内存。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">time</samp> 字段将是一个悬空引用，这是 C# 规则极力避免的。
- en: Although reference types have different lifetimes and enjoy automatic memory
    management, allowing <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    fields only for reference types would indeed be arbitrary and a source of potential
    confusion and error. This capability would also serve little purpose because reference
    variables already exhibit aliasing behavior, and by-reference variables are the
    same size as references for the purposes of copying, so the compiler forbids it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管引用类型具有不同的生命周期并享有自动内存管理，但仅允许对引用类型使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    字段确实显得武断，并且可能引发混淆和错误。这种能力也几乎没有实际意义，因为引用变量本身就具有别名行为，且按引用传递的变量在复制时与引用的大小相同，因此编译器禁止这么做。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Closures</samp>
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">闭包</samp>
- en: The prohibition of <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> fields is also the
    reason we can’t use a by-reference parameter inside a closure. A *closure* is
    a method that encapsulates behavior along with its *context*—that is, the state
    of any variables declared outside the method’s own scope but used within its implementation.
    Those external variables are said to have been *closed over* by the method, hence
    the term *closure*. [Listing 3-15](#list3-15) shows a method trying to use a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter inside a lambda expression.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 禁止使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    字段也是我们无法在闭包中使用按引用参数的原因。*闭包* 是一种方法，它将行为与其 *上下文* 封装在一起——即，方法外部声明的但在实现中使用的任何变量的状态。这些外部变量被称为已被方法
    *闭合*，因此称为 *闭包*。[列表 3-15](#list3-15) 显示了一个方法尝试在 lambda 表达式中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    参数的示例。
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-15: Anonymous closure
    capturing a ref parameter</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-15: 匿名闭包捕获 ref 参数</samp>'
- en: 'The compiler rejects the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp>
    method, giving us the following error:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器拒绝了 <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp>
    方法，给出了以下错误：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The closure in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp>
    method is the lambda expression used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Where</samp>
    method. The lambda is an anonymous method that uses the captured <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    parameter, which belongs to the scope of <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp>.
    Closure functions are implemented by the compiler as a small, unnamable class
    with fields for each of the closed-over variables. In this example, the variable
    being captured is a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter,
    which, as you saw in [Listing 3-14](#list3-14), isn’t a valid field.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp> 方法中的闭包是由
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Where</samp> 方法使用的 lambda 表达式。该
    lambda 是一个匿名方法，使用了捕获的 <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    参数，后者属于 <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAppointment</samp> 的作用域。闭包函数由编译器实现为一个小型的、不可命名的类，并为每个被闭包捕获的变量创建字段。在此示例中，捕获的变量是一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 参数，正如你在 [清单 3-14](#list3-14)
    中看到的，它不是一个有效的字段。
- en: 'As the error message indicates, the same problem applies equally to nested
    local functions and anonymous methods, which can also capture the outer method’s
    variables, including its parameters. Anonymous methods, lambda expressions, and
    local functions are all implemented the same way: using a hidden class synthesized
    by the compiler. Any captured variables become fields of that class.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如错误信息所示，同样的问题也适用于嵌套的局部函数和匿名方法，这些方法也可以捕获外部方法的变量，包括其参数。匿名方法、lambda 表达式和局部函数的实现方式是相同的：使用编译器合成的隐藏类。任何被捕获的变量都成为该类的字段。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Iterator Blocks</samp>
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">迭代器块</samp>
- en: An *iterator block* is a compiler-generated class that implements the standard
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable< T ></samp> interface
    to iterate over the elements of a sequence, such as an array or a <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T ></samp>, using deferred execution. Also known as *lazy enumeration*, *deferred
    execution* means that the next element is obtained from the sequence only when
    the user requests it; the sequence is produced on demand and theoretically may
    even be infinite.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*迭代器块* 是编译器生成的类，它实现了标准的 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable<
    T ></samp> 接口，用于通过延迟执行遍历序列中的元素，例如数组或 <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T ></samp>。它也被称为 *懒惰枚举*，*延迟执行* 意味着只有当用户请求时，才会从序列中获取下一个元素；序列是按需生成的，理论上甚至可能是无限的。'
- en: An iterator block is created whenever we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">yield</samp>
    statement, as shown in [Listing 3-16](#list3-16). However, the compiler rejects
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">AppointmentsForDay</samp> method
    because it has a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">yield</samp> 语句时，就会创建一个迭代器块，如
    [清单 3-16](#list3-16) 所示。然而，编译器拒绝了 <samp class="SANS_TheSansMonoCd_W5Regular_11">AppointmentsForDay</samp>
    方法，因为它有一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 参数。
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-16: A ref parameter
    in an iterator</samp>'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 3-16：迭代器中的 ref 参数</samp>
- en: 'Here the <samp class="SANS_TheSansMonoCd_W5Regular_11">AppointmentsForDay</samp>
    method is attempting to filter the <samp class="SANS_TheSansMonoCd_W5Regular_11">items</samp>
    sequence passed as a parameter for elements that match the <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    parameter. However, like closures, methods that use iterator blocks can’t have
    by-reference parameters, so the method in [Listing 3-16](#list3-16) fails to compile,
    with this error:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 <samp class="SANS_TheSansMonoCd_W5Regular_11">AppointmentsForDay</samp>
    方法试图过滤作为参数传递的 <samp class="SANS_TheSansMonoCd_W5Regular_11">items</samp> 序列，以匹配
    <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp> 参数。然而，像闭包一样，使用迭代器块的方法不能有按引用传递的参数，因此
    [清单 3-16](#list3-16) 中的方法无法编译，出现以下错误：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each time the method yields a value, control returns to the calling code. When
    the next item is requested, the method must continue at the statement following
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">yield</samp> and must do so
    with the same state. The compiler transforms the <samp class="SANS_TheSansMonoCd_W5Regular_11">yield</samp>
    statement to return an instance of the iterator block class that captures the
    state between requests for each element, similar to the way closures work.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每当方法生成一个值时，控制权会返回到调用代码。当请求下一个项时，方法必须从`<samp class="SANS_TheSansMonoCd_W5Regular_11">yield</samp>`语句后的语句继续执行，并且必须在相同的状态下进行。编译器将`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">yield</samp>`语句转换为返回一个迭代器块类的实例，该类在每次请求元素时捕获状态，这与闭包的工作原理类似。
- en: The compiler-generated class needs to capture *all* the method parameters and
    any local variables as fields to preserve the method’s state between each request
    for a value, which is why iterator methods can’t have by-reference parameters.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成的类需要捕获*所有*方法参数和任何局部变量作为字段，以在每次请求值时保存方法的状态，这也是迭代器方法不能使用传引用参数的原因。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Asynchronous Methods</samp>
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">异步方法</samp>
- en: Lastly, and for exactly the same reason as closures and iterator blocks, we
    can’t declare by-reference parameters for <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>
    methods like the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryGetResponse</samp>
    method in [Listing 3-17](#list3-17).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如闭包和迭代器块的原因一样，我们不能为`<samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp>`方法声明传引用参数，比如[示例
    3-17](#list3-17)中的`<samp class="SANS_TheSansMonoCd_W5Regular_11">TryGetResponse</samp>`方法。
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-17: An out parameter
    in an asynchronous method</samp>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-17: 异步方法中的 `out` 参数</samp>'
- en: 'This method fails to compile with the following error:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法未能编译，出现以下错误：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this instance, the compiler synthesizes a hidden class to manage the asynchronous
    invocation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Task.Run</samp>
    method. Asynchronous methods return control to their caller when the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    statement is reached, and so, like iterator blocks, they must preserve the state
    of *all* their variables. The compiler-generated class captures all local variables
    and parameters as fields, so by-reference parameters aren’t allowed for any method
    that has the <samp class="SANS_TheSansMonoCd_W5Regular_11">async</samp> modifier.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，编译器合成了一个隐藏的类来管理异步调用`<samp class="SANS_TheSansMonoCd_W5Regular_11">Task.Run</samp>`方法。当执行到`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">await</samp>`语句时，异步方法将控制权返回给调用者，因此，像迭代器块一样，它们必须保存*所有*变量的状态。编译器生成的类将所有局部变量和参数作为字段捕获，因此任何带有`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">async</samp>`修饰符的方法都不允许使用传引用参数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extension Methods</samp>
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">扩展方法</samp>
- en: We can use by-reference parameters in any method that doesn’t use a closure,
    an iterator block, or asynchronous operations using the <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>
    keyword. However, caveats exist for *extension methods*, static methods that extend
    the interface of another type. The first parameter of an extension method is of
    the type being extended and uses the special <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    modifier. Extension methods have some restrictions on using by-reference parameters
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter. First,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter of an
    extension method can’t be an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter, as demonstrated by [Listing 3-18](#list3-18).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在不使用闭包、迭代器块或使用`<samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp>`关键字的异步操作的任何方法中使用传引用参数。然而，*扩展方法*（静态方法，用于扩展其他类型的接口）存在一些注意事项。扩展方法的第一个参数是被扩展类型，并使用特殊的`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">this</samp>`修饰符。扩展方法对`<samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>`参数使用传引用参数有一些限制。首先，扩展方法的`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">this</samp>`参数不能是`<samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>`参数，正如[示例
    3-18](#list3-18)中所示。
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-18: Extension method
    using an out parameter</samp>'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-18: 使用 `out` 参数的扩展方法</samp>'
- en: 'This code produces the following error message:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会生成以下错误信息：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If this syntax were permitted, code using the <samp class="SANS_TheSansMonoCd_W5Regular_11">FormatConnection</samp>
    method could *appear* to call a method using an uninitialized variable, like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许这种语法，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">FormatConnection</samp>
    方法的代码可能会*看起来*像是在使用未初始化的变量调用方法，如下所示：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Most users would probably find this code confusing because using an uninitialized
    variable to invoke a method isn’t allowed in any other circumstances. In any case,
    we have much better alternatives to achieve the same result, and the syntax for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameters is also an
    error. We can use an <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifier with any of the other parameters, just as we can with any regular method,
    but we can’t make <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> an
    output parameter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户可能会发现这段代码令人困惑，因为在其他任何情况下都不允许使用未初始化的变量来调用方法。无论如何，我们有更好的替代方案来实现相同的结果，而 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">this</samp> 参数的语法也是错误的。我们可以像使用任何常规方法一样，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 修饰符来修饰其他参数，但不能将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">this</samp> 作为输出参数。
- en: 'Using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter is permitted if
    the parameter is a value type, but not if it’s a reference type. This restriction
    might also seem unreasonable at first glance, but it’s intended to explicitly
    prohibit code like the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> 参数是值类型，使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 是允许的，但如果它是引用类型，则不允许。这一限制乍一看可能显得不合理，但它旨在明确禁止如下代码：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The compiler rejects the <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullify</samp>
    method with the following error:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器拒绝了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullify</samp> 方法，并报告了以下错误：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If this code were permitted, the variable used to call the method could refer
    to a different variable, or—as in this example—be set to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    after the method returned. Most users would likely be surprised by such behavior,
    so, once again, the compiler forbids it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许这种代码，调用该方法的变量可能会引用不同的变量，或者—如本例所示—在方法返回后被设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>。大多数用户可能会对这种行为感到惊讶，因此，编译器再次禁止了这种做法。
- en: We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> parameter when the parameter
    is a value type, which avoids copying the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    argument’s value. While there’s no benefit to avoiding the copy of a reference,
    copying a large value might be relatively expensive. A value type variable can’t
    be assigned the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    but the method can assign a new value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref
    this</samp> parameter, thus changing the argument’s value. Again, doing so would
    likely surprise most users of the method, so even though the syntax is legal,
    we should avoid using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref this</samp>
    parameters. If we really want to avoid copying the argument for a <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    parameter, then instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>,
    we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier
    to make <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> a read-only
    reference parameter, as discussed in more detail in “Read-Only References and
    Returning by Reference” on [page 92](#sec24).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> 参数为值类型时使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>，这样可以避免复制 <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    参数的值。虽然避免复制引用类型没有实际好处，但复制一个大的值类型可能会相对昂贵。值类型变量不能赋值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，但是方法可以为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref this</samp> 参数赋予新值，从而改变参数的值。同样，这种做法很可能会让大多数方法用户感到惊讶，因此，尽管语法合法，我们应避免使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref this</samp> 参数。如果我们确实希望避免复制
    <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> 参数的值，那么我们可以使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 修饰符来使 <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    成为只读引用参数，正如在《只读引用与按引用返回》中 [第92页](#sec24) 所详细讨论的那样。
- en: In spite of their limitations, by-reference parameters are a core part of C#,
    and understanding their semantics is important. None of these restrictions is
    particularly onerous, not least because the use cases for these parameters are
    limited. The use of <samp class="SANS_TheSansMonoCd_W5Regular_11">ref this</samp>
    value type parameters in extension methods would be considered unusual by most
    programmers and is a niche-enough feature that it’s probably best avoided in any
    case.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管按引用参数有其局限性，但它们是 C# 的核心部分，理解它们的语义非常重要。没有这些限制特别繁重，主要是因为这些参数的使用场景有限。大多数程序员会认为，在扩展方法中使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref this</samp> 值类型参数是不常见的，而且这是一个足够小众的特性，通常最好避免使用。
- en: Fields *must* be real variables, and C# provides no way to store a by-reference
    variable as a field of a general-purpose type. Every other example in this section
    can be expressed differently to achieve the same result.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 字段*必须*是实际变量，并且 C# 不提供将按引用变量存储为通用类型字段的方式。本节中的其他所有示例可以用不同的方式表达，以达到相同的结果。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Side Effects and Direct Effects</samp>
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">副作用和直接效果</samp>
- en: Methods with by-reference parameters intentionally alias variables in the calling
    code, and therefore changes made to those parameters within the method are visible
    outside the method’s scope. Altering the state of an aliased object is an example
    of a *side effect*, which is more generally defined as any change of state that’s
    visible to code outside the scope where the change occurs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 带有按引用参数的方法故意将调用代码中的变量进行别名化，因此在方法内部对这些参数的修改在方法的作用域外是可见的。修改别名对象的状态是*副作用*的一个例子，副作用通常定义为任何在发生更改的作用域之外可见的状态变化。
- en: Side effects aren’t intrinsically bad, but programs that depend on them heavily
    can be more difficult to follow than those that rely only on direct effects. The
    *direct effect* of a method is whatever it returns, normally referred to as the
    method’s output, with the inputs being the method’s formal parameters. By-reference
    parameters, especially <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters, blur the distinction between the inputs and outputs of a method, since
    side effects may alter state that is unrelated to the method’s direct effect.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用本身并不坏，但过度依赖副作用的程序可能比仅依赖直接效果的程序更难理解。方法的*直接效果*是其返回值，通常称为方法的输出，而输入是方法的形式参数。按引用参数，特别是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 参数，模糊了方法输入和输出之间的区别，因为副作用可能会改变与方法直接效果无关的状态。
- en: Consider how <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    methods are commonly used to initialize variables, as shown in [Listing 3-19](#list3-19).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑如何使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    方法来初始化变量，如[示例 3-19](#list3-19)所示。
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-19 Using TryRemote
    with an output parameter to initialize the connection variable</samp>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-19 使用带有输出参数的 TryRemote
    来初始化连接变量</samp>
- en: The direct effect of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    method is the <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> return
    value indicating the success or failure of initializing its output parameter.
    We use the return value to determine whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    variable has been initialized; in other words, the direct effect tells us whether
    the side effect was successful. In this case, a connection exists between the
    side and direct effects of <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>,
    but, as with other <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp> methods, the direct
    effect seems secondary to the side effect!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> 方法的直接效果是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> 返回值，指示初始化其输出参数的成功或失败。我们使用返回值来判断
    <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp> 变量是否已初始化；换句话说，直接效果告诉我们副作用是否成功。在这种情况下，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> 的副作用和直接效果之间存在联系，但与其他
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Try</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">XXX</samp>
    方法一样，直接效果似乎是副作用的附带效果！
- en: Methods with by-reference parameters, and more generally those that rely substantially
    on operating by side effect, often result in very procedural code comprising a
    set of logical steps or instructions to accomplish a task. Procedural solutions
    are described as *imperative code* because they’re an explicit sequence of instructions
    to be processed to achieve a result. The contrasting approach is *declarative
    code*, which emphasizes outcomes over specific implementation. A more declarative
    approach pulls the focus away from *how* things get done and allows us to concentrate
    instead on the outcomes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 带有引用参数的方法，通常来说，依赖副作用的操作，往往会导致非常程序化的代码，这些代码由一组逻辑步骤或指令组成，用以完成某项任务。程序化解决方案被描述为*命令式代码*，因为它们是为了实现结果而执行的一系列明确的指令。与之对立的方法是*声明式代码*，它强调结果而非具体实现。声明式方法将焦点从*如何*完成任务转移到*什么*被完成上，从而让我们可以专注于结果。
- en: One aspect of a declarative style is that we attach more importance to the direct
    effect of a method and make a clear separation between a method’s inputs and its
    output.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式风格的一个方面是，我们更加注重方法的直接效果，并明确区分方法的输入和输出。
- en: We could make our <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    method in [Listing 3-19](#list3-19) more declarative by removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameter and returning the required <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    reference directly; since <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    is a reference type, we can return <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    if the <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> method fails.
    However, the side effects associated with by-reference parameters aren’t really
    an issue when those parameters are reference types. Reference types are often
    mutable—by design, and for good reason—and the fact that multiple variables can
    refer to a single instance is often desirable behavior, as you saw in “Reference
    Variables and Aliasing” on [page 74](#sec5). The benefits of declarative code
    are much more important when we’re using value types, which should be immutable.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过去掉 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 参数，并直接返回所需的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> 引用，使得 [Listing
    3-19](#list3-19) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp>
    方法更加声明式；由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp> 是引用类型，我们可以在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TryRemote</samp> 方法失败时返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>。然而，当这些参数是引用类型时，与引用参数相关的副作用并不是问题。引用类型通常是可变的——这是有设计上的原因的——并且多个变量引用同一个实例通常是期望的行为，正如你在“引用变量与别名”一节中看到的
    [第74页](#sec5)。当我们使用值类型时，声明式代码的好处更加重要，因为值类型应该是不可变的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mutation vs. Creation</samp>
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">变异与创建</samp>
- en: 'A method that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters is giving
    a strong signal that those parameters will change within the method. Since such
    parameters are aliases for the variables passed as arguments to them, we need
    to pay attention to which variables may be changed. Unexpected modifications to
    variables can cause errors that are hard to identify, especially in code that
    uses multiple threads. If we follow the common advice to make our own value types
    immutable, we reduce the likelihood of such problems occurring, which means we
    should also avoid mutable by-reference parameters of value type. Then, there’s
    only one way that a value type variable can change: by assignment.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    参数的方法强烈表明这些参数在方法中会发生变化。由于这些参数是传入它们的变量的别名，我们需要注意哪些变量可能会被修改。对变量的意外修改可能会导致很难识别的错误，特别是在使用多线程的代码中。如果我们遵循常见的建议，使我们的值类型不可变，我们就能减少这种问题发生的可能性，这也意味着我们应该避免使用值类型的可变引用参数。这样，值类型变量唯一能改变的方式就是通过赋值。
- en: If we have an instance of a value and require an instance with different properties,
    we simply create a new one with the state we want, leaving the original unchanged.
    Compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> method
    in [Listing 3-20](#list3-20) with the similar <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>
    method in [Listing 3-7](#list3-7).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们拥有一个值的实例，并且需要一个具有不同属性的实例，我们只需创建一个具有所需状态的新实例，保持原始实例不变。将 [列表 3-20](#list3-20)
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> 方法与 [列表 3-7](#list3-7)
    中类似的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> 方法进行比较。
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-20: Creating a new
    value rather than mutating an existing variable</samp>'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-20：创建新值而不是修改现有变量</samp>
- en: We create and return a new instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    that’s initialized using the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property of a parameter variable, instead of altering the properties of a value
    that has been passed by reference. Note that the method name is <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>
    rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>. The
    name <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> is a direct
    verb and might imply that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    parameter was somehow being altered. In contrast, the name <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>
    is an adjective describing the result. Using adjectives for nonmutating methods
    is another indication that no state is being altered. Other examples of this naming
    convention include <samp class="SANS_TheSansMonoCd_W5Regular_11">Sorted</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UpperCased</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Rounded</samp>.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建并返回一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 实例，该实例使用参数变量的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> 属性初始化，而不是改变通过引用传递的值的属性。请注意，方法名称是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp>。名称
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Increment</samp> 是一个直接动词，可能暗示 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 参数在某种程度上被修改了。相比之下，名称 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> 是一个形容词，描述的是结果。使用形容词来命名不可变方法，进一步表明没有状态被更改。此命名惯例的其他示例包括
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Sorted</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">UpperCased</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Rounded</samp>。
- en: 'To call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>
    method, we pass an existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value along with a numeric amount by which to increment its value, as shown here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> 方法时，我们传递一个现有的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 值，以及一个用于增加其值的数值，如下所示：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> variable in the
    calling code isn’t changed; the <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>
    method returns a *new* <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance with the required value. We assign the new value to a different variable
    here, but we could have overwritten the original <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    variable with the new instance instead.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 调用代码中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> 变量没有被更改；<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> 方法返回一个具有所需值的*新* <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> 实例。我们将新值赋给一个不同的变量，但也可以用新实例覆盖原始的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> 变量。
- en: Not all objects are values, and sometimes it’s convenient for certain objects
    to be mutable; the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    object you saw earlier has mutable state that can be changed via its <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> methods.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有对象都是值类型，有时某些对象需要是可变的；你之前看到的 <samp class="SANS_TheSansMonoCd_W5Regular_11">DataStore</samp>
    对象具有可变状态，可以通过它的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Open</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Close</samp> 方法进行更改。
- en: Aliasing is useful when we require changes to an object to be visible via all
    *references* to that object, but the benefits of such side effects aren’t so clear
    for value types. Side effects aren’t limited to output parameters. They occur
    anytime we can modify the state of an object that’s visible outside the scope
    in which we make the change, including via a plain reference variable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 别名（Aliasing）在我们需要通过所有*引用*来查看对象变化时非常有用，但对于值类型，这种副作用的好处并不那么明显。副作用不仅限于输出参数。它们发生在任何时候，只要我们能修改对象的状态，而这个状态在我们进行修改的范围之外是可见的，包括通过普通的引用变量。
- en: Changing the state of any object requires special care and attention, especially
    in the presence of multiple threads, so if we limit the need to modify our objects,
    we reduce the potential for problems. If we make all value types immutable, we
    reduce the prevalence of side effects, which can be difficult to identify and
    sometimes make our logic less clear.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 改变任何对象的状态都需要特别小心，尤其是在多线程环境中，因此，如果我们限制修改对象的需求，就可以减少潜在的问题。如果我们让所有值类型都变成不可变的，就能减少副作用的发生，而副作用往往很难被识别，有时还会使我们的逻辑变得不那么清晰。
- en: An alternative approach to creating a new value based on the properties of an
    existing instance is to use the non-destructive mutation syntax, introduced in
    [Chapter 2](chapter2.xhtml). [Listing 3-21](#list3-21) uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>
    keyword to copy an existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    variable and provide a new value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Direction</samp>
    property of the copy.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 创建基于现有实例属性的新值的另一种方法是使用非破坏性变异语法，该语法在[第2章](chapter2.xhtml)中介绍。[示例3-21](#list3-21)使用了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">with</samp>关键字来复制一个现有的<samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>变量，并为该副本的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Direction</samp>属性提供一个新值。
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-21: Copying an instance
    as a template</samp>'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例3-21：将实例作为模板进行复制</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessors on each
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    type enable us to copy an instance and change selected properties for the new
    instance by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>
    keyword. Non-destructive mutation was introduced for record types in C# v9.0,
    and since C# v10.0, we can also use it with structs and record structs, and even
    anonymous types.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>类型上每个属性的<samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>访问器使我们能够复制一个实例，并通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">with</samp>关键字来改变新实例的选定属性。非破坏性变异是在C# v9.0中为记录类型引入的，自C#
    v10.0起，我们也可以在结构体、记录结构体，甚至匿名类型中使用它。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessor also
    allows us to give a property a value by using object initialization (as shown
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp> variable
    in [Listing 3-21](#list3-21)) or via a constructor, but once its value is set
    via <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>, the property is
    immutable. If we’d used <samp class="SANS_TheSansMonoCd_W5Regular_11">private
    set</samp> accessors for the properties instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>,
    the object initialization and non-destructive mutation syntax wouldn’t be possible.
    Non-destructive mutation and object initialization both require either a public
    <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> or public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>访问器还允许我们通过对象初始化（如[示例3-21](#list3-21)中对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp>变量的处理所示）或通过构造函数为属性赋值，但一旦通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">init</samp>设置了属性值，该属性就变得不可变。如果我们使用的是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">private set</samp>访问器，而不是<samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>，那么对象初始化和非破坏性变异语法将不可行。非破坏性变异和对象初始化都需要使用公共的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">init</samp>或公共的<samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>访问器。
- en: Copying selected properties of immutable values is another aspect of a declarative
    approach to problem-solving, and in some circumstances makes it simpler and more
    direct to create new values by using existing variables as a kind of template.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 复制不可变值的选定属性是声明式问题解决方法的另一个方面，在某些情况下，它通过使用现有变量作为模板来创建新值，使得这一过程更简单、直接。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declarative Code
    and Performance</samp>
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">声明式代码与性能</samp>
- en: Using a declarative style can lead to code that is clearer and more direct but
    often results in more copies of variables being created, adding storage expense.
    This is particularly relevant for value types for which the cost of copying large
    instances may impact a program’s performance. Up to this point, we have considered
    only quite small instances, which would be unlikely to negatively impact performance
    significantly. While reference variables are always all the same size, values
    can be any size. To an extent, size matters when we’re copying values around.
    A value type that simply wraps a single <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    field will be cheaper to copy than one that has lots of fields, which is why we’re
    often advised to keep value types small.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用声明式风格可以使代码更加清晰和直接，但通常会导致创建更多的变量副本，从而增加存储开销。这对于值类型尤其重要，因为复制大实例的成本可能会影响程序的性能。到目前为止，我们只考虑了非常小的实例，这些实例不太可能显著影响性能。虽然引用变量的大小始终相同，但值类型可以是任意大小。在复制值时，大小在一定程度上是重要的。一个简单封装了单个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>字段的值类型比具有多个字段的值类型复制时成本更低，这也是为什么我们通常建议保持值类型尽可能小的原因。
- en: The definition of *small* varies but is commonly between 16 and 24 bytes. Note
    that on a 64-bit architecture, references are 8 bytes each, so it’s not hard to
    imagine a useful value type that exceeds the recommended size limit. We’ll explore
    some of the performance characteristics of large value types in [Chapter 8](chapter8.xhtml).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*小*的定义有所不同，但通常在16到24字节之间。请注意，在64位架构中，引用占用8字节，因此很容易想象出一个有用的值类型，它的大小超出了推荐的大小限制。我们将在[第8章](chapter8.xhtml)中探讨一些大值类型的性能特征。'
- en: Nevertheless, the size of a value type shouldn’t be the primary motivation for
    choosing a class or record over a struct or record struct. If we want instances
    of a type to have value semantics, we should make it a value type, regardless
    of how large it might be. When we pass value type variables as arguments for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters, no copy of the instance is made because those arguments are passed
    by reference. Might the preference for returning values over using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters affect
    the efficiency of our code?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值类型的大小不应成为选择类或记录而不是结构或记录结构的主要动机。如果我们希望类型的实例具有值语义，那么无论它多大，我们都应该将其定义为值类型。当我们将值类型变量作为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>参数传递时，并不会创建实例的副本，因为这些参数是按引用传递的。那么，偏好返回值而不是使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>参数，是否会影响我们代码的效率呢？
- en: For values with several fields, avoiding the copying might well represent a
    net performance gain, but we should also consider the impact of our choices on
    *human* readers. It might seem attractive to use by-reference parameters to avoid
    copying large values, except that using a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter strongly
    implies that the argument passed is likely to change. If we want our code to be
    as self-documenting as possible, using <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    parameters as an *optimization* might be surprising.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有多个字段的值类型，避免复制可能带来净性能提升，但我们也应该考虑这种选择对*人类*读者的影响。使用按引用传递的参数以避免复制大值看起来可能很有吸引力，然而使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>参数强烈暗示传递的参数可能会发生变化。如果我们希望代码尽可能自我文档化，将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>参数作为*优化*来使用，可能会让人感到惊讶。
- en: Rather than using the mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> parameters, we can
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters, which
    are *immutable* by-reference parameters. Arguments for <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters are passed by reference in exactly the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> arguments, but an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter variable is
    read-only within the method. In the next section, we’ll explore how to avoid copying
    value type method arguments by using read-only reference parameters, as well as
    how to return values by reference.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用可变的 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    参数不同，我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 参数，它是 *不可变*
    的按引用传递参数。对于 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 参数，参数通过引用传递的方式与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    参数完全相同，但 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 参数变量在方法中是只读的。在下一节中，我们将探讨如何通过使用只读引用参数避免复制值类型方法参数，以及如何通过引用返回值。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Read-Only References and Returning by
    Reference</samp>
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">只读引用和按引用返回</samp>
- en: Read-only references and returning by reference are related concepts, and both
    can help us reduce the number of copies of value type instances in our code. First
    we’ll look at read-only reference parameters, which we denote using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword on a method parameter.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier, like the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    modifiers, makes a by-reference parameter, but, unlike <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, it prevents
    the value of the underlying variable from being changed. In other words, an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter variable is immutable.
    Using <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters when
    we’re passing large value type instances as arguments might be beneficial because
    we avoid copying the instance.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 只读引用和按引用返回是相关概念，两者都能帮助我们减少代码中值类型实例的复制次数。首先，我们将查看只读引用参数，这些参数通过在方法参数中使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 关键字来表示。<samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    修饰符，像 <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    修饰符一样，使参数按引用传递，但与 <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 参数不同，它禁止修改基础变量的值。换句话说，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 参数变量是不可变的。当我们传递大型值类型实例作为参数时，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 参数可能是有益的，因为这样可以避免复制实例。
- en: Technically, we can also pass a reference to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter, but there’s no reason to do so. Passing a reference by reference is
    useful only if we need to change the reference to refer to a new instance. For
    that to work, we need a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter. No performance
    benefit is associated with passing a reference by reference, as there may be with
    value types.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们也可以将引用传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 参数，但没有必要这么做。只有在需要改变引用指向一个新实例时，按引用传递引用才有意义。为了实现这一点，我们需要使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    参数。按引用传递引用不会带来性能上的好处，而值类型则可能带来一些。
- en: '[Listing 3-22](#list3-22) shows a simple expression-bodied method, <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>,
    that calculates a distance from its <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp> parameter values,
    both of which are value types.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-22](#list3-22) 展示了一个简单的表达式体方法 <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>，该方法根据
    <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">time</samp>
    参数值计算距离，这两个参数都是值类型。'
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-22: Read-only reference
    parameters</samp>'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 3-22：只读引用参数</samp>
- en: Both the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">time</samp> variables use the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier, making them read-only reference parameters in the <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>
    method. Since the parameter variables are read-only, the compiler will reject
    any attempt to set mutable properties, change public fields, or assign a new value
    to either of them.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`speed` 和 `time` 变量使用了 `in` 修饰符，使它们在 `DistanceInKm` 方法中成为只读引用参数。由于这些参数是只读的，编译器会拒绝任何试图设置可变属性、更改公共字段或为它们赋予新值的操作。'
- en: 'When we call a method that has a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter, we must
    also modify the argument we’re passing with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> keyword. By contrast,
    arguments passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters
    do *not* require the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> modifier,
    as shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用一个具有 `ref` 或 `out` 参数的方法时，我们必须使用 `ref` 或 `out` 关键字修改我们传递的参数。相比之下，传递给 `in`
    参数的参数则 *不* 需要 `in` 修饰符，如下所示：
- en: '[PRE34]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As with reference and output parameters, we can overload <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>
    with a version that has value parameters. The overload *without* modifiers takes
    precedence in overload resolution if we don’t specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier for the argument. We can explicitly use <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    for an argument passed to an input parameter to select the version taking its
    parameters by reference. As mentioned earlier in the chapter, overloading methods
    based solely on whether a parameter is passed by reference or by value is likely
    to be a source of confusion.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与引用和输出参数一样，我们可以重载 `DistanceInKm` 方法，使用一个具有值参数的版本。如果我们没有为参数指定 `in` 修饰符，那么没有修饰符的重载版本会优先选择。在传递给输入参数的参数上显式使用
    `in`，可以选择使用按引用传递参数的版本。正如本章前面提到的，仅根据参数是通过引用传递还是通过值传递来重载方法，可能会导致混淆。
- en: Read-only reference parameters are designed to be transparent in the calling
    code; that is, passing an argument to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter appears the same as passing an argument by value. One consequence is
    that a method may be modified to receive its parameters by read-only reference
    instead of by value, but without requiring changes to the calling code. Arguments
    that were previously passed by value would then be passed by reference. This matters
    only if the *argument* variables may change—perhaps within a different thread.
    Bear in mind that only the parameter variables within the method are read-only;
    the argument variables usually aren’t. Since the argument passed to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter is passed by reference, any change to the argument’s value will be reflected
    in the value of the parameter variable inside the method. [Listing 3-23](#list3-23)
    demonstrates that it’s possible to modify the value of an argument passed to an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter even without
    multiple threads.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 只读引用参数设计为在调用代码中是透明的；也就是说，传递给 `in` 参数的参数与传递值参数看起来是一样的。一个结果是，方法可以修改为接收按只读引用传递的参数，而不需要修改调用代码。以前通过值传递的参数，现在将通过引用传递。只有当
    *参数* 变量可能会改变时（可能是在不同的线程中），这才重要。请记住，方法中的只有参数变量是只读的；通常，传递的参数变量不是。由于传递给 `in` 参数的参数是按引用传递的，因此对参数值的任何更改都会反映在方法内部的参数变量值中。[Listing
    3-23](#list3-23) 演示了即使没有多个线程，也可以修改传递给 `in` 参数的参数的值。
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-23: Modifying a read-only
    parameter’s value via a callback delegate</samp>'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 3-23：通过回调委托修改只读参数的值</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp> method
    takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value by read-only
    reference and an <samp class="SANS_TheSansMonoCd_W5Regular_11">Action</samp> delegate.
    A *delegate* is a variable that refers to a method; here, we use the standard
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Action</samp> type for the delegate
    that represents a method with no parameters and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp>
    method, we copy the *value* of the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    parameter into a temporary variable ❶. Then we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">callback</samp>
    delegate before testing that the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    parameter’s value is now different from the value copied to <samp class="SANS_TheSansMonoCd_W5Regular_11">temp</samp>
    before we called the delegate ❷. When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp>,
    we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp> value along
    with a lambda for the <samp class="SANS_TheSansMonoCd_W5Regular_11">callback</samp>
    parameter. The lambda closes over the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>
    variable, whose value is changed by the lambda ❸.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp>` 方法通过只读引用传递一个
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>` 值和一个 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Action</samp>`
    委托。*委托* 是一个引用方法的变量；在这里，我们使用标准的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">Action</samp>`
    类型的委托，它表示一个没有参数并返回 `<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>`
    的方法。在 `<samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp>`
    方法内部，我们将 `<samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>` 参数的*值*复制到一个临时变量
    ❶ 中。然后我们调用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">callback</samp>` 委托，在测试
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>` 参数的值是否与调用委托之前复制到
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">temp</samp>` 的值不同之前 ❷。当我们调用 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp>` 时，我们传递 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">input</samp>` 值以及一个用于 `<samp class="SANS_TheSansMonoCd_W5Regular_11">callback</samp>`
    参数的 lambda 表达式。这个 lambda 捕获了 `<samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>`
    变量，并且它的值在 lambda 中发生变化 ❸。'
- en: The test within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp>
    method passes because the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    parameter is an alias to the calling code’s <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>
    variable. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>
    variable’s value changes inside the lambda, the <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    parameter’s value is also changed. We should therefore be cautious of methods
    that have both <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters
    and delegate parameters. More generally, we should be suspicious of code that
    changes the values of any variable passed as an argument to a method, especially
    if the method and calling code can run on different threads of execution. The
    potential errors caused by changing an apparently read-only variable could be
    difficult to track down.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<samp class="SANS_TheSansMonoCd_W5Regular_11">ModifyByCallback</samp>` 方法中的测试通过，是因为
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>` 参数是调用代码中 `<samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>`
    变量的别名。当 `<samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>` 变量的值在 lambda
    函数内部发生变化时， `<samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>` 参数的值也随之变化。因此，我们应该对同时具有
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>` 参数和委托参数的方法保持谨慎。更一般来说，我们应该对那些改变作为参数传递给方法的任何变量值的代码保持怀疑，特别是当方法和调用代码可能在不同的执行线程上运行时。改变一个看似只读的变量可能会引发难以追踪的错误。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Returning Values
    by Reference</samp>
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">通过引用返回值</samp>
- en: Although instances of value type aren’t generally copied by reference, we can
    return a value type instance by reference, and receive the returned reference
    by using a by-reference variable. This can be useful if we’re particularly sensitive
    to the cost of copying large instances, although the technique is sufficiently
    complex that we probably shouldn’t use it routinely. [Listing 3-24](#list3-24)
    shows a struct whose instances will be larger than a reference variable.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管值类型的实例通常不会按引用复制，但我们可以按引用返回值类型实例，并通过使用按引用的变量接收返回的引用。如果我们特别关注复制大实例的成本，这可能会很有用，尽管这种技术足够复杂，以至于我们可能不应该常规使用它。[示例
    3-24](#list3-24)展示了一个结构体，它的实例将比引用变量大。
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-24: An Address struct
    with multiple fields</samp>'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-24：包含多个字段的 Address 结构体</samp>
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp> struct has
    four <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> backing fields,
    so an instance of the struct is somewhat larger and more expensive to copy than
    a single reference. If huge numbers of instances were being copied around, we
    might want to address the cost of some of those copies. However, returning by
    reference isn’t guaranteed to be cheaper than returning even large values by value,
    and may even represent a performance cost. Even so, if careful performance analysis
    identified instance copying as an issue, returning values by reference might prove
    beneficial.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个<samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp>结构体有四个<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>字段，因此该结构体的实例比单一引用更大，复制成本也更高。如果需要复制大量实例，我们可能希望考虑这些复制的成本。然而，按引用返回并不一定比按值返回较大值更便宜，甚至可能代表一种性能成本。尽管如此，如果经过仔细的性能分析发现实例复制是一个问题，那么按引用返回值可能会证明是有益的。
- en: When we access a property, we inadvertently make a copy of the property’s value.
    We can avoid making this copy by returning the value by reference, known as a
    *reference return value*, or simply a *ref return*. We mark a value as being a
    ref return by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    keyword, as we do when modifying by-reference method parameters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>
    class in [Listing 3-25](#list3-25) has a <samp class="SANS_TheSansMonoCd_W5Regular_11">Destination</samp>
    property that returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field value by reference.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们访问一个属性时，我们会无意中复制该属性的值。我们可以通过按引用返回值来避免进行此复制，这称为*引用返回值*，或者简称为*ref返回*。我们通过添加<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>关键字来标记一个值为引用返回，就像我们在修改按引用传递的方法参数时所做的那样。[示例
    3-25](#list3-25)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>类有一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Destination</samp>属性，通过引用返回<samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>字段的值。
- en: '[PRE37]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-25: The Destination
    property returning the destination field value by reference</samp>'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-25：Destination 属性通过引用返回
    destination 字段值</samp>
- en: Note that we need to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    keyword to the property and to the variable being returned by reference.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要在属性和通过引用返回的变量上都添加<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>关键字。
- en: When we access a property that returns its value by reference, we can also receive
    that value by reference without copying it at all. A *by-reference variable*,
    or *ref local*, is a local variable that refers to the same variable as the ref
    return. This is best illustrated with a simple example. In [Listing 3-26](#list3-26),
    we receive the ref return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail.Destination</samp>
    by using a local reference variable.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们访问一个通过引用返回其值的属性时，我们也可以通过引用接收该值，而无需复制它。一个*按引用的变量*，或*引用局部变量*，是一个局部变量，它指向与`ref`返回相同的变量。通过一个简单的示例可以更好地说明这一点。在[示例
    3-26](#list3-26)中，我们使用局部引用变量接收来自<samp class="SANS_TheSansMonoCd_W5Regular_11">Mail.Destination</samp>的`ref`返回值。
- en: '[PRE38]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-26: Consuming a value
    returned by reference</samp>'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-26：通过引用返回的值的使用</samp>
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">local</samp> variable is
    an alias to the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field within the <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp> instance,
    not a copy of its value. Again, note that we have to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    modifier on both the target variable and the property access; if we forget either,
    the compiler will give us an error. If we omit both, we simply copy the property’s
    value by value into a normal variable.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">local</samp> 变量是对 <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp>
    实例中 <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp> 字段的别名，而不是其值的副本。同样，需要注意的是，我们必须在目标变量和属性访问中都使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> 修饰符；如果我们忘记其中任何一个，编译器会给我们一个错误。如果我们省略了这两个，编译器会将属性的值按值复制到一个普通变量中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Preventing Modifications
    to Data</samp>
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">防止对数据的修改</samp>
- en: Just as with by-reference parameters, ref return values and ref locals introduce
    an alias to a value. If we modify a value through such an alias, we need to make
    sure we know where those changes will be visible.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 就像通过引用传递的参数一样，ref 返回值和 ref 本地变量为一个值引入了一个别名。如果我们通过这个别名修改一个值，我们需要确保知道这些修改会在哪里可见。
- en: We can use the ref local reference to mutate the field in <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp>
    too, although in this example we can only assign it a completely new value, since
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp> is a read-only struct.
    [Listing 3-27](#list3-27) demonstrates that modifying the ref local also changes
    the field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp> variable.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 ref 本地引用来改变 <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp>
    中的字段，尽管在这个示例中我们只能为其分配一个全新的值，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp>
    是一个只读结构体。[列表 3-27](#list3-27) 展示了修改 ref 本地引用也会改变 <samp class="SANS_TheSansMonoCd_W5Regular_11">letter</samp>
    变量的字段。
- en: '[PRE39]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-27: Mutating a field
    by using a ref local variable</samp>'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-27：通过使用 ref 本地变量修改字段</samp>
- en: Being able to modify a *private* field of an instance in this way might not
    be desirable. First, it violates the encapsulation of the field in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>
    class, and second, as with any alias, directly altering an object would likely
    cause problems in multithreaded code. A *race condition* occurs whenever an object’s
    state can be altered by multiple threads simultaneously, or when one thread can
    read an object before another thread has finished changing it. The size of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Address</samp> type means that assigning
    a new value won’t be an atomic operation, meaning that a second thread could read
    a partly initialized instance.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式修改实例的 *private* 字段可能不是我们想要的。首先，这违反了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>
    类中字段的封装性；其次，和任何别名一样，直接改变对象可能会在多线程代码中引发问题。*竞争条件*发生在对象的状态可以被多个线程同时修改，或者当一个线程在另一个线程完成修改之前读取对象时。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Address</samp> 类型的大小意味着分配新值不会是一个原子操作，这意味着第二个线程可能会读取一个部分初始化的实例。
- en: 'One common approach to addressing race conditions is to protect access to a
    variable from multiple threads by using a lock. Locking access to the data within
    the property itself isn’t sufficient in this situation because the underlying
    data can be modified outside the property definition; we’d need to lock every
    use of the property, which would likely hamper our code’s performance. Fortunately,
    we have a less intrusive solution: we can simply make the property immutable.
    Sharing immutable state has none of the drawbacks associated with changing data
    from multiple threads.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 解决竞争条件的一种常见方法是通过使用锁来保护多个线程对变量的访问。在这种情况下，仅在属性本身内部锁定数据访问是不足够的，因为底层数据可以在属性定义之外被修改；我们需要锁定属性的每次使用，这可能会影响代码的性能。幸运的是，我们有一个更不具侵入性的方法：我们可以简单地使该属性变为不可变的。共享不可变的状态不会有多个线程修改数据所带来的缺点。
- en: To protect the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field in <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp> from modifications,
    we can change the <samp class="SANS_TheSansMonoCd_W5Regular_11">Destination</samp>
    property to return a read-only reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field. If we return such a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp>
    variable, the calling code needs to also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    keyword for the target variable, as [Listing 3-28](#list3-28) shows.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护<samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>中的<samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>字段不被修改，我们可以将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Destination</samp>属性更改为返回指向<samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>字段的只读引用。如果我们返回这样的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp>变量，则调用代码也需要为目标变量使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>关键字，如[清单 3-28](#list3-28)所示。
- en: '[PRE40]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-28: Preventing mutation
    of a ref return</samp>'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 3-28：防止 ref 返回值的变异</samp>
- en: 'The compiler won’t allow any modifications via the read-only <samp class="SANS_TheSansMonoCd_W5Regular_11">local</samp>
    reference variable. We’ve also made the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>
    field read-only in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>
    class. This means that we *must* use a read-only reference if we return a reference
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp> field.
    If we attempt to return a read-only field by reference without the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly
    ref</samp> modifier, the compiler gives us this error:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将不允许通过只读<samp class="SANS_TheSansMonoCd_W5Regular_11">local</samp>引用变量进行任何修改。我们还在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>类中将<samp class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>字段设为只读。这意味着如果我们返回指向<samp
    class="SANS_TheSansMonoCd_W5Regular_11">destination</samp>字段的引用，*必须*使用只读引用。如果我们试图在没有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">readonly ref</samp>修饰符的情况下返回只读字段的引用，编译器会给出以下错误：
- en: '[PRE41]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can assign one <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> variable
    to another by using the same syntax as assigning a ref local to the result of
    a property. Note that a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp>
    variable can be assigned from a non-read-only reference. An automatic and implicit
    conversion occurs from a plain—or *writable*—ref return or a ref local *to* a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> variable, but
    not in the other direction. A read-only reference can’t be assigned to a writable
    ref local. Doing so would break the immutability guarantees of a read-only reference.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与将 ref 局部变量分配给属性结果相同的语法，将一个<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>变量赋值给另一个。请注意，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp>变量可以从非只读引用中赋值。会发生从普通或*可写*的
    ref 返回值或 ref 局部变量*到* <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp>变量的自动隐式转换，但反向转换不会发生。只读引用不能分配给可写的
    ref 局部变量。这样做会破坏只读引用的不可变性保证。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Keeping By-Reference
    Variables Within Scope</samp>
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">保持按引用传递的变量在作用域内</samp>
- en: Methods can return values by reference too, and the syntax is the same as for
    properties. However, the lifetime of the variable returned by reference must be
    guaranteed to last at least as long as the reference’s lifetime. More formally,
    the scope of the variable being referenced must *include* the method or property
    that returns a reference to that variable.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也可以通过引用返回值，语法与属性相同。然而，通过引用返回的变量的生命周期必须至少与引用的生命周期一样长。更正式地说，被引用的变量的作用域必须*包括*返回指向该变量的引用的方法或属性。
- en: One implication of this rule is that we can’t return a reference to a local
    variable, because the variable will go out of scope as soon as the method or property
    implementation returns. This is most clearly apparent for value types. The lifetime
    of a value ends when the scope ends, so its lifetime is *shorter* than that of
    the reference. The method in [Listing 3-29](#list3-29) fails to compile because
    it’s attempting to return a reference to a local variable.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这一规则的一个含义是，我们不能返回一个指向局部变量的引用，因为该变量会在方法或属性实现返回后立即超出作用域。对于值类型，这一点最为明显。一个值的生命周期在作用域结束时就结束，因此它的生命周期比引用的生命周期*短*。[清单
    3-29](#list3-29)中的方法编译失败，因为它试图返回一个指向局部变量的引用。
- en: '[PRE42]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-29: Trying to return
    a reference to a local variable</samp>'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-29：尝试返回对局部变量的引用</samp>
- en: 'If we *could* return a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>
    variable, the code calling this method would get a reference to a value that no
    longer exists. The compiler prevents such a situation by refusing to compile the
    code, giving this error:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们*能够*返回对<samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>变量的引用，那么调用此方法的代码将获得对一个不再存在的值的引用。编译器通过拒绝编译代码来防止这种情况发生，给出以下错误：
- en: '[PRE43]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This rule applies regardless of whether the value of the local variable is a
    reference or an instance of a struct. The *variable* still goes out of scope,
    even when the *instance* exists on the heap. By-reference variables and by-reference
    returns are references to variables, not instances, in exactly the same way as
    by-reference parameters.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这一规则适用于无论局部变量的值是引用类型还是结构体实例的情况。即使*实例*存在于堆上，*变量*依然会超出作用域。按引用的变量和按引用返回的值实际上是对变量的引用，而不是实例，就像按引用传递的参数一样。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Instance Fields of Value Types</samp>
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">值类型的实例字段</samp>
- en: The compiler will prevent us from returning a variable by reference if it can’t
    guarantee that the variable will be valid for at least as long as any reference
    to it. A less obvious consequence of this rule is that a method or property of
    a value type can’t return a reference to one of that type’s instance fields. The
    code in [Listing 3-30](#list3-30), for instance, won’t compile.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器不能保证变量至少在与任何引用它的时间一样长的时间内保持有效，它将阻止我们通过引用返回变量。这个规则的一个不那么明显的后果是，值类型的方法或属性不能返回对该类型实例字段之一的引用。例如，[示例
    3-30](#list3-30)中的代码将无法编译。
- en: '[PRE44]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-30: Returning a struct
    field by reference</samp>'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-30：通过引用返回结构体字段</samp>
- en: 'The compiler gives us this error message:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器给出了以下错误信息：
- en: '[PRE45]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This operation is prohibited because the compiler can’t easily determine that
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance will outlive
    any reference to a field within it. [Listing 3-31](#list3-31) shows a pathological
    example to demonstrate why that might be a problem.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器无法轻易确定<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>实例会在任何对其内部字段的引用之前仍然存在，因此禁止此操作。[示例
    3-31](#list3-31)展示了一个病态示例，说明为什么这可能会成为问题。
- en: '[PRE46]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-31: Invalid code
    returning a reference to a struct’s field</samp>'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-31：返回结构体字段引用的无效代码</samp>
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct in
    [Listing 3-30](#list3-30) could legally return one of its fields by reference,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultRgb</samp> method in
    [Listing 3-31](#list3-31) would be returning a reference to a field of an object
    that has gone out of scope. This is a similar problem to returning a reference
    to a local variable, but this time the problem is directly related to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    being a struct. When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    variable goes out of scope, each of its fields goes out of scope too. The compiler
    forbids returning any instance field of a value type by reference to avoid even
    the possibility of this happening.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[示例 3-30](#list3-30)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>结构体能够合法地通过引用返回它的字段，那么[示例
    3-31](#list3-31)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultRgb</samp>方法将返回对一个已经超出作用域的对象字段的引用。这与返回对局部变量的引用是类似的问题，但这次问题与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>是一个结构体直接相关。当<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>变量超出作用域时，它的每个字段也都会超出作用域。编译器禁止通过引用返回值类型的任何实例字段，以避免这种情况的发生。
- en: 'Member methods and properties of a value type are also prevented from returning
    <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp> by reference. It’s disallowed
    for exactly the same reason as for instance fields: if it were permitted, we would
    be returning a reference to a local value—an instance of the type—that goes out
    of scope.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型的成员方法和属性也被禁止通过引用返回<samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>。这与实例字段的原因完全相同：如果允许这样做，我们将返回对一个局部值的引用——即该类型的实例——它已经超出了作用域。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">References to References</samp>
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">对引用的引用</samp>
- en: When a reference variable goes out of scope, the instance it represented still
    exists on the heap until it is garbage collected. We can, therefore, safely return
    a reference to an instance field from a property or method of a class or a record.
    In fact, holding such a by-reference variable *prevents* the instance from being
    garbage collected. In [Listing 3-32](#list3-32), we take a reference to an instance
    field of a local reference type object and return it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个引用变量超出作用域时，它所代表的实例仍然存在于堆中，直到被垃圾回收。因此，我们可以安全地从类或记录的属性或方法中返回对实例字段的引用。实际上，持有这种通过引用的变量*防止*该实例被垃圾回收。在[清单
    3-32](#list3-32)中，我们获取一个指向局部引用类型对象实例字段的引用并返回它。
- en: '[PRE47]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-32: Returning a reference
    to a field of a local object</samp>'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 3-32：返回指向局部对象字段的引用</samp>
- en: The compiler accepts this code, and it’s safe to use this method, although we
    should certainly be cautious because this technique relies on a somewhat esoteric
    feature of the garbage collector. When <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    returns, the <samp class="SANS_TheSansMonoCd_W5Regular_11">local</samp> variable
    goes out of scope, leaving no live reference variables directly to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>
    instance created inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>
    method. Normally, that instance would then become eligible for garbage collection,
    making the by-reference return value a dangling reference. However, the returned
    by-reference variable is enough to prevent the garbage collector from destroying
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp> instance, so holding
    a by-reference variable to one of its fields remains valid.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器接受这段代码，并且使用这种方法是安全的，尽管我们应该小心，因为这种技术依赖于垃圾回收器的一个相对深奥的特性。当<samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>返回时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">local</samp>变量超出作用域，不再直接有指向在<samp class="SANS_TheSansMonoCd_W5Regular_11">GetAddress</samp>方法内创建的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>实例的活跃引用变量。通常情况下，该实例将变为垃圾回收的候选对象，这使得通过引用返回值成为悬挂引用。然而，返回的通过引用变量足以防止垃圾回收器销毁<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mail</samp>实例，因此持有一个指向其字段的通过引用变量仍然有效。
- en: Behind the scenes, a by-reference variable or parameter to a field within a
    class or record instance represents a managed pointer. *Managed pointers* are
    an implementation detail of the CLR, but the takeaway here is that they’re tracked
    by the garbage collector and considered *object roots*—simply put, references
    or managed pointers to objects known to be live when the garbage collector runs.
    Those objects, in turn, may contain references to other objects on the heap, so
    the chain of references forms a graph of objects currently in use at the time
    the garbage collector runs.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，指向类或记录实例内字段的通过引用变量或参数表示一个托管指针。*托管指针*是CLR的一个实现细节，但关键点是它们由垃圾回收器追踪，并被视为*对象根*——简单来说，它们是对当前垃圾回收器运行时被认为是存活的对象的引用或托管指针。这些对象可能会包含对堆上其他对象的引用，因此引用链形成了当前垃圾回收器运行时在用对象的图。
- en: 'The garbage collector uses object roots to determine whether object instances
    can be collected: any instance it can’t reach from an object root by following
    the object graph is eligible for collection, and any object that *is* reachable
    survives. Storing a ref local variable is enough to keep the owning object from
    being garbage collected.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器使用对象根来确定对象实例是否可以被回收：任何它无法从对象根通过对象图访问到的实例都可以被回收，任何*可以*访问到的对象则会生存下来。存储一个引用局部变量足以防止拥有该对象的对象被垃圾回收。
- en: We can always safely return a by-reference parameter variable by reference because
    the variable aliased by the parameter must be in scope for the calling code. Strictly,
    the scope of the variable includes the method accepting the parameter by reference,
    as shown in [Listing 3-33](#list3-33).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们始终可以安全地通过引用返回一个通过引用的参数变量，因为该参数别名的变量必须在调用代码的作用域内。严格来说，变量的作用域包括接受通过引用参数的方法，如[清单
    3-33](#list3-33)所示。
- en: '[PRE48]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-33: Returning a ref
    parameter by reference</samp>'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 3-33：通过引用返回一个引用参数</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoveRed</samp> method’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp> parameter can be returned
    by reference because the reference can’t outlive the variable underlying it, since
    the scope of the <samp class="SANS_TheSansMonoCd_W5Regular_11">hasRed</samp> variable
    in the calling code *includes* <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoveRed</samp>.
    [Listing 3-34](#list3-34) shows that the same is true of <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters, even though they look like they’re returning a reference to a local
    variable.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoveRed</samp> 方法的 <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>
    参数可以通过引用返回，因为引用不能超出它所引用的变量的生命周期，因为在调用代码中，<samp class="SANS_TheSansMonoCd_W5Regular_11">hasRed</samp>
    变量的作用域 *包括* 了 <samp class="SANS_TheSansMonoCd_W5Regular_11">RemoveRed</samp>。
    [Listing 3-34](#list3-34) 显示，虽然看起来像是返回了对局部变量的引用，但同样的规则也适用于 <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    参数。
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-34: Returning an
    out parameter by reference</samp>'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-34: 通过引用返回一个 out
    参数</samp>'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> parameter in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateColor</samp> method is
    a reference to a variable in the calling code, whose scope also includes the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateColor</samp> method itself.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateColor</samp> 方法中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">result</samp> 参数是对调用代码中变量的引用，该变量的作用域同样包括了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateColor</samp> 方法本身。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Returning out parameters by reference is prohibited as of C# v11.0, although
    returning ref parameters by reference is still permitted.*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*从 C# v11.0 开始，禁止通过引用返回输出参数，但仍允许通过引用返回 `ref` 参数。*'
- en: 'We can also return <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters by reference, but they must be returned as <samp class="SANS_TheSansMonoCd_W5Regular_11">ref
    readonly</samp>, because an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter is immutable. If we forget to make the returned reference <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>,
    the compiler gives us a predictable error:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过引用返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 参数，但必须作为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> 返回，因为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 参数是不可变的。如果我们忘记将返回的引用标记为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>，编译器将给出一个可预见的错误：
- en: '[PRE50]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Given that the variable used to populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter must already be part of the calling code and we can’t modify it in any
    way, returning an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter
    by reference typically isn’t useful. We can pass the variable to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter to avoid copying it, but the method could just as easily return <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> because the calling code must
    already know about the variable, which could not be modified by the method.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于用于填充 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 参数的变量必须已经是调用代码的一部分，并且我们不能以任何方式修改它，因此通常不需要通过引用返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> 参数。我们可以将变量传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    参数以避免复制，但方法同样可以返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>，因为调用代码已经必须知道该变量，并且该变量不能被方法修改。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Mutable Immutable Properties</samp>
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">可变与不可变属性</samp>
- en: 'Properties that return by reference can’t have a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor and thus are apparently immutable. However, ref returns have a peculiarity:
    if we return by *writable* reference, as shown in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    property in [Listing 3-35](#list3-35), we can use the reference to mutate the
    underlying value, just as we would use a setter for the property.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用返回的属性不能具有 <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> 访问器，因此它们显得是不可变的。然而，引用返回有一个特殊之处：如果我们通过
    *可写* 引用返回，如 [Listing 3-35](#list3-35) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    属性所示，我们可以使用该引用修改底层值，就像使用属性的 setter 一样。
- en: '[PRE51]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-35: Setting a new
    value for a writable reference property</samp>'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-35: 设置可写引用属性的新值</samp>'
- en: It may look like we’re setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">brush</samp> variable
    to a new instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    but in fact we’re assigning a new value to the *field* in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    class directly, by reference. The semantic difference is somewhat subtle. Part
    of the purpose of a property is to *encapsulate* access to a value, but here we
    deliberately sidestep that encapsulation by returning a reference to the field.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们是在将<samp class="SANS_TheSansMonoCd_W5Regular_11">brush</samp>变量的<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>属性设置为一个新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>实例，但实际上我们是通过引用直接给<samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>类中的*字段*赋值。语义上的差别有些微妙。属性的部分目的就是*封装*对一个值的访问，但在这里我们故意绕过了这个封装，通过返回字段的引用。
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> property returned
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp>, this code
    wouldn’t compile because we’d be attempting to modify a read-only variable. A
    <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> property would enable us
    to change its value, but permitting a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor for something that is read-only seems perverse.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>属性返回一个<samp class="SANS_TheSansMonoCd_W5Regular_11">ref
    readonly</samp>，那么这段代码将无法编译，因为我们试图修改一个只读变量。为<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>属性添加一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">set</samp>访问器将允许我们修改其值，但允许对只读属性使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">set</samp>访问器似乎是违背常理的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Considering Performance
    vs. Simplicity</samp>
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">考虑性能与简洁性</samp>
- en: Ref returns, used in conjunction with ref locals, may be beneficial when we’d
    otherwise be copying large value type instances around, particularly if *many*
    copies would be generated. Ref locals and ref returns are a relatively complex
    optimization feature and need to be introduced with care. When the values are
    small, creating references to them carries no benefit and might even result in
    added cost due to the extra indirection required to access the value. We can use
    ref returns and ref locals for reference variables too, but, again, doing so provides
    no advantage; C# allows it just for the symmetry.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不使用值类型实例的副本，而是希望避免大量复制时，使用ref返回值与ref局部变量可能会带来好处，特别是在需要生成*多个*副本的情况下。ref局部变量和ref返回值是一种相对复杂的优化特性，需要谨慎使用。当值较小时，创建对它们的引用并没有带来好处，反而可能由于访问值所需的额外间接操作而增加成本。我们也可以对引用变量使用ref返回值和ref局部变量，但同样，这样做并没有优势；C#允许这样做只是为了保持对称性。
- en: We need to be aware of the costs of *all* by-reference variables, whether they’re
    parameters, return values, or locals. Any by-reference variable introduces extra
    indirection in order to obtain the *actual* underlying value.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意*所有*通过引用传递的变量的成本，无论它们是参数、返回值还是局部变量。任何通过引用传递的变量都会引入额外的间接访问，以获取*实际*的底层值。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Final Word on Mutable By-Reference Parameters</samp>
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">关于通过引用传递可变参数的最终意见</samp>
- en: As mentioned previously, using the mutable by-reference parameter types <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    often indicates very procedural code. In general, if we prefer a more declarative
    style, we make our code more self-describing and often more compact. However,
    output parameters have one use in modern C# that supports that same declarative
    approach. The term of art is *object deconstruction*, although the relevance of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters here may not
    be immediately obvious.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用可变的通过引用传递的参数类型<samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">out</samp>通常表示非常过程化的代码。一般来说，如果我们倾向于更具声明性的风格，我们的代码通常会更加自描述且更为简洁。然而，输出参数在现代C#中有一个用途，支持相同的声明性方法。这个术语是*对象析构*，尽管<samp
    class="SANS_TheSansMonoCd_W5Regular_11">out</samp>参数在这里的相关性可能并不显而易见。
- en: We begin with the value tuple, introduced in C# v7.0 to simplify the creation
    of lightweight aggregate types such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    variable in [Listing 3-36](#list3-36).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从值元组开始，它在 C# v7.0 中引入，用于简化轻量级聚合类型的创建，例如 [示例 3-36](#list3-36) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    变量。
- en: '[PRE52]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-36: A value tuple
    for a point</samp>'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-36：一个表示点的值元组</samp>
- en: 'This <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> variable is
    a *named tuple*, where we give a name to each component. The tests show how we
    use those names like properties to obtain their respective values. Value tuples
    support deconstruction: we can decompose the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    variable into individual variables with names unrelated to the names we gave the
    components. [Listing 3-37](#list3-37) uses the deconstruction syntax to assign
    two separate variables from the fields of the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    tuple from [Listing 3-36](#list3-36).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> 变量是一个 *命名元组*，我们为每个组成部分指定了名称。测试展示了我们如何像使用属性一样使用这些名称来获取它们的值。值元组支持解构：我们可以将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> 变量解构为独立的变量，这些变量的名称与我们为组成部分指定的名称无关。[示例
    3-37](#list3-37) 使用解构语法从 [示例 3-36](#list3-36) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    元组的字段中赋值给两个独立的变量。
- en: '[PRE53]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-37: Tuple deconstruction</samp>'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-37：元组解构</samp>
- en: In this code, the types of the <samp class="SANS_TheSansMonoCd_W5Regular_11">horizontal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">vertical</samp> variables are
    inferred from the components of the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    value tuple, and we use them individually without needing to refer to <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    at all. We can support this same syntax in our own types by writing a public <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp> method, which uses
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters to take all
    of its parameters by reference. [Listing 3-38](#list3-38) shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    struct type with such a method.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，<samp class="SANS_TheSansMonoCd_W5Regular_11">horizontal</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">vertical</samp> 变量的类型是从 <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>
    值元组的组成部分推断出来的，我们可以单独使用它们，而无需再提到 <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp>。通过编写一个公共的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp> 方法，我们可以在自己的类型中支持这种语法，该方法使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 参数按引用传递所有参数。[示例 3-38](#list3-38)
    展示了一个包含此方法的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> 结构体类型。
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-38: User-defined
    type deconstruction</samp>'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-38：用户定义的类型解构</samp>
- en: 'We can use identical syntax to that shown in [Listing 3-37](#list3-37) to deconstruct
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> value into individual
    variables:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与 [示例 3-37](#list3-37) 中相同的语法将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    值解构为独立的变量：
- en: '[PRE55]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The compiler translates this code to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp>
    method of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    struct, so the calling code has no mention of <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    arguments, or even a call to a method. The compiler’s support for object deconstruction
    allows the code using <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    to access its properties as individual variables in a compact and clear way.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将这段代码转换为调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    结构体的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp> 方法，因此调用代码中没有提到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> 参数，甚至没有方法调用。编译器对对象解构的支持使得使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> 的代码能够以简洁明了的方式访问其属性，作为独立的变量。
- en: The same syntax for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp>
    method is also supported for classes. The compiler generates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp>
    method for both records and record structs, saving us from having to define our
    own implementation of it.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp> 方法的相同语法也支持类。编译器为记录类型和记录结构体生成
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Deconstruct</samp> 方法，从而避免我们需要自己定义该方法的实现。
- en: Simple value types like <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">point</samp> value tuple
    are common in functional programs because they encapsulate simple abstractions
    with a minimum of syntactical overhead. They also present little or no performance
    overhead, allowing us to write expressive and efficient programs more simply.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的值类型，如<samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">point</samp>值元组，在函数式编程中很常见，因为它们用最少的语法开销封装了简单的抽象。它们也几乎不带有性能开销，让我们可以更简洁地编写表达力强且高效的程序。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">摘要</samp>
- en: '*How do we convince people that in programming simplicity and clarity [...]
    are not a dispensable luxury, but a crucial matter that decides between success
    and failure?*'
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我们如何说服人们相信，在编程中，简洁性和清晰性 [...] 不是可有可无的奢侈品，而是决定成功与失败的关键问题？*'
- en: ''
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '—Edsger W. Dijkstra, *Selected Writings on Computing: A Personal Perspective*'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —埃兹赫尔·W·戴克斯特拉，*《计算机的精选文献：个人视角》*
- en: The concept of pass-by-reference, and how it differs from pass-by-value, is
    much less straightforward than a first glance might suggest. The common explanation—that
    value types are passed by value and reference types by reference—is misleading.
    We don’t pass types around; we pass values. What’s more, by default all values
    are passed by value.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 引用传递的概念，以及它与值传递的区别，比表面看起来要复杂得多。常见的解释——即值类型按值传递，引用类型按引用传递——是误导性的。我们传递的不是类型，而是值。而且，默认情况下所有值都是按值传递的。
- en: Understanding what the value of a variable actually *is* helps us more precisely
    define what passing by reference really entails. Passing by value is merely the
    default; we have to actively choose to pass a value by reference. Reference and
    value types differ semantically because the value of a reference variable isn’t
    the same as the instance of the type it represents. For value type variables,
    however, the value and the instance are the same thing.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 理解变量的值到底是什么，有助于我们更精确地定义按引用传递到底意味着什么。按值传递仅仅是默认行为；我们必须主动选择按引用传递一个值。引用类型和值类型在语义上有所不同，因为引用变量的值与它所代表的类型实例不同。然而，对于值类型变量来说，值与实例是同一回事。
- en: Moreover, we can pass a variable by reference in several ways, each with different
    behavior and restrictions. We’ve looked at using by-reference method parameters
    to change variables in different ways, as well as at alternatives that can make
    our programs more direct and comprehensible by avoiding side effects and making
    values immutable. Immutability is an important aspect of avoiding problems associated
    with unwanted aliasing, even when by-reference variables are being used. If we
    use read-only properties and read-only structs judiciously, we can take advantage
    of some of the performance benefits of passing by reference, without suffering
    from the complications of managing access to shared mutable data.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过几种方式按引用传递一个变量，每种方式的行为和限制不同。我们已经探讨了使用按引用传递的方法参数以不同方式修改变量的情况，并且讨论了避免副作用并使值不可变的替代方案，这些替代方案可以让我们的程序更加直接和易于理解。不可变性是避免与不希望的别名相关的问题的一个重要方面，即使在使用按引用的变量时也是如此。如果我们谨慎地使用只读属性和只读结构体，就可以在不需要管理共享可变数据访问的复杂性的情况下，利用按引用传递的一些性能优势。
- en: When an immutable value is shared by several references, aliasing can never
    present a problem. This is the basic principle behind <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters and read-only local references, but it’s also a consideration when
    we want value semantics for a type but also want the benefits of reference semantics
    for performance.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个不可变值被多个引用共享时，别名问题永远不会成为问题。这是<samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>参数和只读局部引用背后的基本原理，但它也是我们在需要值语义同时希望为了性能获得引用语义的好处时需要考虑的问题。
- en: However, passing by reference isn’t without cost. Every access to a by-reference
    parameter involves an extra level of indirection. This cost is likely to be negligible
    but could adversely affect performance if the method is used in “hot paths” through
    the code. As with any performance optimization, we must measure the outcome to
    determine whether the optimization is worthwhile.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，按引用传递也不是没有代价的。每次访问一个按引用传递的参数都会涉及额外的间接层级。这种代价可能微不足道，但如果该方法在代码中的“热路径”中使用，可能会对性能产生不利影响。像所有性能优化一样，我们必须通过衡量结果来确定优化是否值得。
