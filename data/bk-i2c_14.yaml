- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Bare-Metal I²C Controller Programming
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 裸金属 I²C 控制器编程
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: To this point, most of the sample programs in this book have relied on some
    third-party library code to interface with the I²C hardware on the SBC. At the
    hardware level, I²C communication normally consists of reading and writing hardware-dependent
    registers on the microcontroller. Having library code that hides these low-level
    details from you is convenient, but if you’re the one tasked with writing that
    library code in the first place—or if you need better performance or features
    that the library doesn’t provide—you’ll have to learn to program low-level I²C
    operations yourself.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中的大多数示例程序依赖于一些第三方库代码与 SBC 上的 I²C 硬件接口。在硬件层面，I²C 通信通常包括读取和写入微控制器上依赖于硬件的寄存器。有一个隐藏这些底层细节的库代码非常方便，但如果你负责编写这个库代码——或者如果你需要更好的性能或库没有提供的功能——你就必须学会自己编写底层
    I²C 操作。
- en: Nearly every real-world MCU does things differently when it comes to low-level
    I²C programming, even if they share some common peripheral hardware. Fortunately,
    the I²C protocol isn’t *that* complex, so the basic programming ideas apply no
    matter what the underlying hardware. If you learn how to program a few different
    MCUs, those concepts should help you figure out how to deal with others. In this
    chapter, I’ll describe how to program I²C communications on a pair of MCUs at
    the register (hardware) level. In particular, this chapter will explore I²C programming
    on the Teensy 4.*x*’s NXP i.MX RT1062 MCU and the ATtiny84 MCU.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个真实世界中的 MCU 在处理底层 I²C 编程时都有不同的做法，即使它们共享一些常见的外设硬件。幸运的是，I²C 协议并不是*那么*复杂，因此基本的编程思路适用于任何底层硬件。如果你学会了如何编程几种不同的
    MCU，那么这些概念应该能帮助你弄清楚如何处理其他 MCU。在本章中，我将描述如何在寄存器（硬件）级别上编程两个 MCU 之间的 I²C 通信。特别地，本章将探讨在
    Teensy 4.*x* 的 NXP i.MX RT1062 MCU 和 ATtiny84 MCU 上进行 I²C 编程。
- en: For the programming examples in this chapter, I use the Teensy 4.*x* modules
    and the SparkFun Atto84\. The Teensy 4.0 and 4.1 modules share the same MCU IC,
    so their low-level I²C programming is identical; the SparkFun Atto84 is based
    on the ATtiny84 MCU. All are low cost and commonly available, and they are used
    by many makers and hobbyists.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的编程示例使用了 Teensy 4.*x* 模块和 SparkFun Atto84。Teensy 4.0 和 4.1 模块共享相同的 MCU IC，因此它们的底层
    I²C 编程是相同的；SparkFun Atto84 基于 ATtiny84 MCU。所有这些设备都价格低廉且常见，并且被许多创客和爱好者使用。
- en: 11.1 Teensy 4.*x* Controller Programming
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 Teensy 4.*x* 控制器编程
- en: The first example in this chapter will be I²C controller programming on the
    Teensy 4.*x* modules using a driver written primarily by Richard Gemmell, with
    portions by Paul Stoffregen of PJRC. The discussion begins with a description
    of the Teensy’s hardware registers that support I²C communications, followed by
    the code (based on Gemmell’s driver) that you’ll need to program these registers
    to implement Arduino-like I²C communication functions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一个示例将是使用由 Richard Gemmell 主要编写、Paul Stoffregen（PJRC）参与的驱动程序，在 Teensy 4.*x*
    模块上进行 I²C 控制器编程。讨论从描述 Teensy 支持 I²C 通信的硬件寄存器开始，然后是你需要的代码（基于 Gemmell 的驱动程序），通过这些代码，你可以编程这些寄存器，实现类似
    Arduino 的 I²C 通信功能。
- en: For more information on this driver and to download Gemmell’s code, visit his
    GitHub page at [https://github.com/Richard-Gemmell/teensy4_i2c](https://github.com/Richard-Gemmell/teensy4_i2c).
    Gemmell’s package includes both controller and peripheral code, but I’ll focus
    solely on the controller portion. See the online chapters (particularly Chapter
    18 at [https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com))
    for the corresponding discussion on programming the Teensy 4.*x* as an I²C peripheral
    device.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此驱动程序的更多信息以及下载 Gemmell 的代码，请访问他的 GitHub 页面 [https://github.com/Richard-Gemmell/teensy4_i2c](https://github.com/Richard-Gemmell/teensy4_i2c)。Gemmell
    的包包含了控制器和外设代码，但我将仅关注控制器部分。请参阅在线章节（特别是 [https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com)
    上的第 18 章），获取有关将 Teensy 4.*x* 编程为 I²C 外设设备的相关讨论。
- en: When you work with low-level hardware on an MCU, the MCU’s reference manual
    becomes an indispensable resource. See “For More Information” at the end of this
    chapter for the link to the NXP reference manual for the i.MX RT1060 MCU (which
    includes the i.MX RT1062) on the PJRC (Teensy) website. Chapter 47 in the manual
    describes the I²C interface.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 MCU 上与底层硬件打交道时，MCU 的参考手册成为了一个不可或缺的资源。请参阅本章末尾的“更多信息”部分，获取链接，访问 PJRC（Teensy）网站上的
    NXP i.MX RT1060 MCU（包括 i.MX RT1062）的参考手册。手册中的第 47 章描述了 I²C 接口。
- en: 11.1.1 i.MX RT1062 I²C Registers
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 i.MX RT1062 I²C 寄存器
- en: The Teensy 4.0 and 4.1 modules use an NXP i.MX RT1062 MCU with an ARM Cortex
    M7 core. The ARM Cortex M7 core is the CPU, while the i.MX RT1062 is the MCU that
    consists of the CPU plus all the associated peripheral devices.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Teensy 4.0 和 4.1 模块使用 NXP i.MX RT1062 MCU，配备 ARM Cortex M7 核心。ARM Cortex M7
    核心是 CPU，而 i.MX RT1062 是包含 CPU 及所有相关外设的 MCU。
- en: 'To understand the Teensy 4.*x* I²C code, you will need to learn about certain
    i.MX RT1062 registers, beginning with the I²C control register set. The *imx_rt1060.h*
    file that Gemmell’s code uses contains the following declarations (annotations
    mine):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 Teensy 4.*x* 的 I²C 代码，你需要了解一些 i.MX RT1062 寄存器，首先从 I²C 控制寄存器集开始。Gemmell 的代码使用的
    *imx_rt1060.h* 文件包含以下声明（注释为我加的）：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `#define` statements at the end of this listing define symbols that map
    this structure to different addresses in memory. Specifically, `LPI2C1` corresponds
    to the registers associated with the Teensy 4’s (SDA0, SCL0) pins, `LPI2C3` corresponds
    to the (SDA1, SCL1) pins, and `LPI2C4` corresponds to the (SCL2, SDA2) pins (note
    that the Teensy 4.*x* has only three I²C ports brought out). You can read about
    these pin definitions in section 47.4 of the NXP manual.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表末尾的 `#define` 语句定义了将该结构映射到内存中不同地址的符号。具体来说，`LPI2C1` 对应与 Teensy 4 的（SDA0, SCL0）引脚相关的寄存器，`LPI2C3`
    对应（SDA1, SCL1）引脚，`LPI2C4` 对应（SCL2, SDA2）引脚（请注意，Teensy 4.*x* 只有三个 I²C 端口）。你可以在
    NXP 手册的第 47.4 节中了解这些引脚定义。
- en: Although it’s beyond the scope of this book to describe the uses of all of these
    registers in detail, it is worthwhile to describe several of them to understand
    the code in the sections that follow. See Chapter 47 of the NXP manual for more
    detail on all other registers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书并不详细描述所有这些寄存器的用途，但描述其中的几个寄存器对于理解接下来的代码是非常有价值的。有关所有其他寄存器的更多详细信息，请参见 NXP 手册的第
    47 章。
- en: Because the i.MX RT1062 is a 32-bit CPU, the registers are all 32 bits wide.
    Unlike CPU registers, whose addresses the ARM core encodes into the instruction
    opcodes, peripheral registers appear as memory locations to the processor—that
    is, `LPI2C1` through `LPI2C4`. As the ARM supports byte, half-word (16-bit), and
    word (32-bit) memory accesses, you can access individual bytes or half-words in
    these peripheral registers (as well as in the whole 32-bit register, of course).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 i.MX RT1062 是一个 32 位的 CPU，因此所有寄存器都是 32 位宽。与 CPU 寄存器不同，ARM 核心将其地址编码到指令操作码中，而外设寄存器对处理器来说是内存位置——也就是说，`LPI2C1`
    到 `LPI2C4`。由于 ARM 支持字节、半字（16 位）和字（32 位）内存访问，因此你可以访问这些外设寄存器中的单个字节或半字（当然，也可以访问整个
    32 位寄存器）。
- en: The Master Control Register (MCR) The MCR is a collection of six flags (bits),
    spread out in the LO 10 bits of the register. Writing to these flags enables (1)
    or disables (0) I²C features. [Table 11-1](#table11-1) describes these flags.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主控制寄存器（MCR）MCR 是一个由六个标志（位）组成的集合，这些标志分布在寄存器的低 10 位中。写入这些标志可以启用（1）或禁用（0）I²C 功能。[表
    11-1](#table11-1) 描述了这些标志。
- en: 'Table 11-1: MCR Fields'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-1：MCR 字段
- en: '| **Bit** | **Description** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **描述** |'
- en: '| --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | MEN (master enable): Enables or disables the controller aspects for a
    particular I²C port. Set to 1 to use the I²C port as a controller. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 0 | MEN（主设备启用）：启用或禁用特定 I²C 端口的控制器功能。设置为 1 时将 I²C 端口用作控制器。 |'
- en: '| 1 | RST (software reset): A 1 in this bit resets the I²C controller. A 0
    in this bit allows normal operation. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 1 | RST（软件重置）：该位为 1 时重置 I²C 控制器。该位为 0 时允许正常操作。 |'
- en: '| 2 | DOZEN (doze mode enable): A 1 in this bit enables operation in low-power
    doze mode. A 0 in this bit disables controller in doze mode (for normal operation).
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 2 | DOZEN（低功耗模式启用）：该位为 1 时启用低功耗待机模式操作。该位为 0 时禁用控制器进入待机模式（以便正常操作）。 |'
- en: '| 3 | DBGEN (debug enable): A 1 in this bit enables controller operation in
    debug mode. A 0 puts the I²C port in normal operational mode. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 3 | DBGEN（调试启用）：该位为 1 时启用控制器的调试模式操作。该位为 0 时，I²C 端口处于正常操作模式。 |'
- en: '| 8 | RTF (reset transmit FIFO [First-In, First-Out]): Writing a 1 in this
    bit resets the transmission FIFO; writing a 0 has no effect. This bit is write-only
    and always returns 0 when read. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 8 | RTF（重置传输 FIFO [先进先出]）：将 1 写入该位会重置传输 FIFO；将 0 写入则没有效果。此位是只写的，读取时总是返回 0。
    |'
- en: '| 9 | RRF (reset receive FIFO): Writing a 1 in this bit resets the receive
    FIFO (writing a 0 does nothing). This bit is write-only and always returns 0 when
    read. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 9 | RRF（重置接收 FIFO）：将 1 写入该位会重置接收 FIFO（写入 0 不做任何操作）。此位是只写的，读取时总是返回 0。 |'
- en: The Master Status Register (MSR) The MSR is a collection of bits that specifies
    the current status of the I²C port. [Table 11-2](#table11-2) lists the fields
    in this register.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主状态寄存器（MSR） 主状态寄存器（MSR）是一组位，用于指定 I²C 端口的当前状态。[表 11-2](#table11-2) 列出了此寄存器中的各个字段。
- en: 'Table 11-2: MSR Fields'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-2：MSR 字段
- en: '| **Bit** | **Description** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **描述** |'
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | TDF (transmit data flag): Set whenever the number of bytes in the transmission
    FIFO is less than or equal to *TxWater*, the transmission low watermark.^([*](#c11-footnote-001))
    TxWater is set in the MFCR. The purpose of this flag (and its corresponding interrupt)
    is to notify the system that the transmission FIFO needs more data. See [Table
    11-6](#table11-6) later in this chapter to set the TxWater value. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 0 | TDF（传输数据标志）：每当传输 FIFO 中的字节数小于或等于 *TxWater*（传输低水位标志）时设置。^([*](#c11-footnote-001))
    TxWater 在 MFCR 中设置。此标志（及其对应的中断）用于通知系统传输 FIFO 需要更多数据。有关设置 TxWater 值的信息，请参见本章后面的[表
    11-6](#table11-6)。 |'
- en: '| 1 | RDF (receive data flag): Set whenever the number of bytes in the receive
    FIFO is greater than *RxWater*, the receive high watermark. RxWater is set in
    the MFCR. The purpose of this flag (and its corresponding interrupt) is to notify
    the system that it needs to remove data from the receive FIFO. See [Table 11-6](#table11-6)
    to set the RxWater value. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 1 | RDF（接收数据标志）：每当接收 FIFO 中的字节数大于 *RxWater*（接收高水位标志）时设置。RxWater 在 MFCR 中设置。此标志（及其对应的中断）用于通知系统需要从接收
    FIFO 中移除数据。有关设置 RxWater 值的信息，请参见[表 11-6](#table11-6)。 |'
- en: '| 8 | EPF (end packet flag): Set when a controller generates a *repeated* start
    condition or a stop condition (not set on the first start condition). Writing
    a 1 to this bit clears this flag. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 8 | EPF（结束包标志）：当控制器生成 *重复* 起始条件或停止条件时设置（不会在第一次起始条件时设置）。向此位写入 1 会清除此标志。 |'
- en: '| 9 | SDF (stop detected flag): Set when the controller generates a stop condition.
    Writing a 1 to this bit clears this flag. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 9 | SDF（停止检测标志）：当控制器生成停止条件时设置。向此位写入 1 会清除此标志。 |'
- en: '| 10 | NDF (NAK detected flag): Set when the controller detects a NAK when
    transmitting an address or data. When this bit is 1, the system will not generate
    a start condition until the flag is cleared. If a NAK is expected after an address
    transmission, the hardware will set this flag if a NAK is not generated. Writing
    a 1 to this bit clears this flag. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 10 | NDF（NAK 检测标志）：当控制器在传输地址或数据时检测到 NAK 时设置。当此位为 1 时，系统不会生成起始条件，直到清除此标志。如果预期在地址传输后会出现
    NAK，则如果没有生成 NAK，硬件会设置此标志。向此位写入 1 会清除此标志。 |'
- en: '| 11 | ALF (arbitration lost flag): The controller will set this flag if it
    loses an arbitration battle on the I²C bus. Once set, the system will not initiate
    a new start condition until this flag is cleared. Writing a 1 to this bit clears
    this flag. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 11 | ALF（仲裁丢失标志）：如果控制器在 I²C 总线上的仲裁中失败，则会设置此标志。一旦设置，系统将在此标志清除之前不会启动新的起始条件。向此位写入
    1 会清除此标志。 |'
- en: '| 12 | FEF (FIFO error flag): The controller sets this bit if it detects an
    attempt to transmit or receive data without a start, or repeated start, condition.
    Writing a 1 to this bit clears this flag. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 12 | FEF（FIFO 错误标志）：如果控制器检测到在没有起始或重复起始条件的情况下试图传输或接收数据，则会设置此标志。向此位写入 1 会清除此标志。
    |'
- en: '| 13 | PLTF (pin low timeout flag): Set if the controller detects that an SDA
    or SCL line is stuck low. Writing a 1 to this bit clears this flag, though it
    cannot be cleared as long as the low pin condition persists. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 13 | PLTF（引脚低超时标志）：如果控制器检测到 SDA 或 SCL 引脚被拉低，则设置此标志。向此位写入 1 会清除此标志，尽管只要低电平条件存在，它无法被清除。
    |'
- en: '| 14 | DMF (data match flag): Set if the controller determines that the received
    data has matched the MATCH0 or MATCH1 values (specified in MCFGR1). Writing a
    1 to this bit clears this flag. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 14 | DMF（数据匹配标志）：当控制器检测到接收到的数据与 MATCH0 或 MATCH1 的值（在 MCFGR1 中指定）匹配时设置。向此位写入
    1 会清除此标志。 |'
- en: '| 24 | MBF (master busy flag): Set while the controller is busy. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 24 | MBF（主设备忙碌标志）：当控制器忙碌时设置。 |'
- en: '| 25 | BBF (bus busy flag): Set while the I²C bus is busy. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 25 | BBF（总线忙碌标志）：当 I²C 总线忙碌时设置。 |'
- en: '| ^([*](#c11-footnoteref-001))A watermark is a point in the buffer where some
    event will occur (such as setting the TDF or RDF). |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| ^([*](#c11-footnoteref-001))水位线是缓冲区中的某个点，在此点上会发生某些事件（例如设置 TDF 或 RDF）。 |'
- en: The Master Interrupt Enable Register (MIER) The MIER allows you to enable or
    disable various I²C interrupts for a particular port. This is a collection of
    bits where a 1 indicates that the interrupt is enabled and a 0 indicates that
    the specific interrupt is disabled. [Table 11-3](#table11-3) lists the fields
    in this register.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主中断使能寄存器 (MIER) MIER 允许你为特定端口启用或禁用各种 I²C 中断。这是一个位域，其中 1 表示中断已启用，0 表示该中断已禁用。[表
    11-3](#table11-3) 列出了该寄存器中的字段。
- en: 'Table 11-3: MIER Fields'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-3: MIER 字段'
- en: '| **Bit** | **Description** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **描述** |'
- en: '| --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | TDIE: transmit data interrupt enable |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 0 | TDIE: 传输数据中断使能 |'
- en: '| 1 | RDIE: receive data interrupt enable |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 1 | RDIE: 接收数据中断使能 |'
- en: '| 8 | EPIE: end packet interrupt enable |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 8 | EPIE: 数据包结束中断使能 |'
- en: '| 9 | SDIE: stop detected interrupt enable |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 9 | SDIE: 停止检测中断使能 |'
- en: '| 10 | NDIE: NAK detected interrupt enable |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 10 | NDIE: 检测到 NAK 中断使能 |'
- en: '| 11 | ALIE: arbitration lost interrupt enable |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 11 | ALIE: 仲裁丢失中断使能 |'
- en: '| 12 | FEIE: FIFO error interrupt enable |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 12 | FEIE: FIFO 错误中断使能 |'
- en: '| 13 | PLTIE: pin low timeout interrupt enable |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 13 | PLTIE: 引脚低超时中断使能 |'
- en: '| 14 | DMIE: data match interrupt enable |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 14 | DMIE: 数据匹配中断使能 |'
- en: The Master Configuration Register 1 (MCFGR1) The Teensy I²C code uses only the
    LO 3 bits of the MCFGR1\. These 3 bits hold the clock prescaler value that divides
    the system clock by 2^(*n+1*), where *n* is the 3-bit number passed in MCFGR1\.
    For information on the other bits, see the NXP documentation.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主配置寄存器 1 (MCFGR1) Teensy I²C 代码仅使用 MCFGR1 的低 3 位。这 3 位存储时钟预分频器值，将系统时钟除以 2^(*n+1*)，其中
    *n* 是 MCFGR1 中传递的 3 位数字。有关其他位的信息，请参阅 NXP 文档。
- en: The Master Configuration Register 2 (MCFGR2) The MCFGR2 contains bus idle timeout
    and glitch filter constants for the I²C bus. [Table 11-4](#table11-4) describes
    the MCFGR2 fields.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主配置寄存器 2 (MCFGR2) MCFGR2 包含 I²C 总线的空闲超时和毛刺滤波常数。[表 11-4](#table11-4) 描述了 MCFGR2
    字段。
- en: 'Table 11-4: MCFGR2 Fields'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-4: MCFGR2 字段'
- en: '| **Bits** | **Description** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **描述** |'
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 to 11 | Bus idle timeout period in clock cycles. A 0 in this field disables
    bus idle checking. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 0 到 11 | 总线空闲超时周期，单位为时钟周期。该字段为 0 时，禁用总线空闲检查。 |'
- en: '| 16 to 19 | SCL glitch filter. A 0 in this field disables the filter. Otherwise,
    pulses less than or equal to this many clock cycles long will be ignored on the
    SCL line. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 16 到 19 | SCL 毛刺滤波器。该字段为 0 时，禁用滤波器。否则，长度小于或等于该时钟周期数的脉冲将在 SCL 线上被忽略。 |'
- en: '| 24 to 27 | SDA glitch filter. A 0 in this field disables the filter. Otherwise,
    pulses less than or equal to this many clock cycles long will be ignored on the
    SDA line. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 24 到 27 | SDA 毛刺滤波器。该字段为 0 时，禁用滤波器。否则，长度小于或等于该时钟周期数的脉冲将在 SDA 线上被忽略。 |'
- en: The Master Configuration Register 3 (MCFGR3) The MCFGR3 holds the pin low timeout
    value. Bits 8 to 19 hold the pin low timeout constant (in clock cycles, times
    256). Writing a 0 to these bits disables this feature. All other bits in MCFGR3
    must be 0.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主配置寄存器 3 (MCFGR3) MCFGR3 存储引脚低超时值。位 8 到 19 存储引脚低超时常数（以时钟周期为单位，乘以 256）。将 0 写入这些位将禁用此功能。MCFGR3
    中的所有其他位必须为 0。
- en: The Master Clock Configuration Register 0 (MCCR0) and 1 (MCCR1) The MCCR0 and
    MCCR1 specify various parameters concerning the I²C signal lines. [Table 11-5](#table11-5)
    lists the fields held within this register. MCCR1 is the same as MCCR0, but it
    is used when operating in I²C high-speed mode.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主时钟配置寄存器 0 (MCCR0) 和 1 (MCCR1) MCCR0 和 MCCR1 指定与 I²C 信号线相关的各种参数。[表 11-5](#table11-5)
    列出了该寄存器中的字段。MCCR1 与 MCCR0 相同，但用于 I²C 高速模式下的操作。
- en: 'Table 11-5: MCCR0 and MCCR1 Fields'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '表 11-5: MCCR0 和 MCCR1 字段'
- en: '| **Bits** | **Description** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **描述** |'
- en: '| --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 to 5 | CLKLO: Minimum number of cycles (minus 1) that the SCL clock is
    driven low by the hardware. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 0 到 5 | CLKLO: 硬件将 SCL 时钟拉低的最小周期数（减去 1）。 |'
- en: '| 8 to 13 | CLKHI: Minimum number of cycles (minus 1) that the SCL clock is
    driven high by the hardware. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 8 到 13 | CLKHI: 硬件将 SCL 时钟拉高的最小周期数（减去 1）。 |'
- en: '| 16 to 21 | SETHOLD: Minimum number of cycles (minus 1) used by the controller
    as the hold time for a start condition. It is also used as the setup and hold
    time for a repeated start condition, and as the setup time for a stop condition.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 16 到 21 | SETHOLD: 控制器用作起始条件保持时间的最小周期数（减去 1）。它还用作重复起始条件的设定和保持时间，以及停止条件的设定时间。
    |'
- en: '| 24 to 29 | DATAVD: Data valid delay. Minimum number of cycles (minus 1) used
    for the SDA data hold time. Must be less than CLKLO. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 24 到 29 | DATAVD：数据有效延迟。用于 SDA 数据保持时间的最小周期数（减去 1）。必须小于 CLKLO。 |'
- en: The Master FIFO Control Register (MFCR) The MFCR allows you to set the TxWater
    and RxWater watermarks. These are each 2-bit fields allowing you to set the watermark
    from 0 to 3 (the FIFOs hold 4 words each). The field positions appear in [Table
    11-6](#table11-6).
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主FIFO控制寄存器（MFCR）MFCR 允许你设置 TxWater 和 RxWater 水印。每个水印都是 2 位字段，允许你将水印设置为 0 到 3（FIFO
    每个包含 4 个字）。字段位置请参见[表 11-6](#table11-6)。
- en: 'Table 11-6: MFCR Fields'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-6：MFCR 字段
- en: '| **Bits** | **Description** |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **描述** |'
- en: '| --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 to 1 | TxWater |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 0 到 1 | TxWater |'
- en: '| 16 to 17 | RxWater |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 16 到 17 | RxWater |'
- en: The Master FIFO Status Register (MFSR) The MFSR holds the current number of
    words in the transmit and receive FIFOs. The fields appear in [Table 11-7](#table11-7).
    Although there are 3 bits associated with these fields, the FIFOs hold only four
    words.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主 FIFO 状态寄存器（MFSR）MFSR 保存传输和接收 FIFO 中当前的字数。字段如[表 11-7](#table11-7)所示。虽然这些字段与
    3 位相关，但 FIFO 仅存储四个字。
- en: 'Table 11-7: MFSR Fields'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-7：MFSR 字段
- en: '| **Bits** | **Description** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **描述** |'
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 to 2 | Number of words in transmit buffer |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 0 到 2 | 传输缓冲区中的字数 |'
- en: '| 16 to 18 | Number of words in receive buffer |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 16 到 18 | 接收缓冲区中的字数 |'
- en: The Master Transmit Data Register (MTDR) The MTDR accepts commands and data
    bytes to control writing data onto the I²C bus. It has two fields, shown in [Table
    11-8](#table11-8).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主传输数据寄存器（MTDR）MTDR 接受命令和数据字节，用于控制将数据写入 I²C 总线。它有两个字段，如[表 11-8](#table11-8)所示。
- en: 'Table 11-8: MTDR Fields'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-8：MTDR 字段
- en: '| **Bits** | **Field** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **字段** |'
- en: '| --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 to 7 | Data |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 0 到 7 | 数据 |'
- en: '| 8 to 10 | Command |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 8 到 10 | 命令 |'
- en: Any write to the LO 8 bits, be it by a byte write or a 16-bit (or 32-bit) write
    to this register, will insert the data byte at the end of the transmit FIFO and
    increment the FIFO pointer—assuming, of course, that the FIFO is not full. Also
    note that an 8-bit write to the LO 8 bits will zero-extend the write operation
    and write 0b000 to the command bits.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向低 8 位写入任何数据，无论是通过字节写入还是通过 16 位（或 32 位）写入到该寄存器，都将把数据字节插入到传输 FIFO 的末尾并递增 FIFO
    指针——前提是 FIFO 未满。另请注意，向低 8 位写入 8 位数据时，将会零扩展写入操作，并将 0b000 写入命令位。
- en: The command field is a 3-bit command code (see [Table 11-9](#table11-9)). Writing
    a single byte to bits 8 to 15 executes the command.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令字段是一个 3 位的命令代码（见[表 11-9](#table11-9)）。写入 8 到 15 位的一个字节即可执行命令。
- en: 'Table 11-9: MTDR Command Values'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-9：MTDR 命令值
- en: '| **Command bits** | **Command** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **命令位** | **命令** |'
- en: '| --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0b000 | Transmit data (found in bits 0 to 7). |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 0b000 | 传输数据（位于 0 到 7 位）。 |'
- en: '| 0b001 | Receive data. Bits 0 to 7 specify the number of bytes to receive
    (plus 1). |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 0b001 | 接收数据。位 0 到 7 指定要接收的字节数（加 1）。 |'
- en: '| 0b010 | Send stop condition. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 0b010 | 发送停止条件。 |'
- en: '| 0b011 | Receive and discard bytes. Bits 0 to 7 specify the number of bytes
    to receive (plus 1). |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 0b011 | 接收并丢弃字节。位 0 到 7 指定要接收的字节数（加 1）。 |'
- en: '| 0b100 | Generate (repeated) start condition and transmit address in bits
    0 to 7. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 0b100 | 生成（重复）启动条件并传输 0 到 7 位中的地址。 |'
- en: '| 0b101 | Generate (repeated) start condition and transmit address in bits
    0 to 7\. This transfer expects a NAK to be returned. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 0b101 | 生成（重复）启动条件并在 0 到 7 位中传输地址。此传输预期返回 NAK。 |'
- en: '| 0b110 | Generate (repeated) start condition and transmit address in bits
    0 to 7 using high-speed mode. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 0b110 | 生成（重复）启动条件并在高速度模式下传输 0 到 7 位中的地址。 |'
- en: '| 0b111 | Generate (repeated) start condition and transmit address in bits
    0 to 7 using high-speed mode. This transfer expects a NAK to be returned. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 0b111 | 生成（重复）启动条件并在高速度模式下传输 0 到 7 位中的地址。此传输预期返回 NAK。 |'
- en: Generally, the only command you’d write as a single byte (to bits 8 through
    15) would to be to send a stop condition. All other commands have data associated
    with them.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一般来说，作为单字节写入（到 8 到 15 位）的唯一命令是发送停止条件。所有其他命令都与数据相关。
- en: Note that the FIFO holds commands as well as data. Therefore, the hardware associates
    the particular command it executes with the data as it pulls items from the transmit
    FIFO.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，FIFO 存储的是命令和数据。因此，硬件将它执行的特定命令与从传输 FIFO 拉取的项目关联起来。
- en: The Master Receive Data Register (MRDR) Data received by the I²C hardware gets
    added to the receive FIFO. Reading the MRDR retrieves the next available byte
    from the FIFO (in bits 0 through 7). Bit 14 of the MRDR is set if the FIFO is
    empty. Note that you can also check to see if data is available in the FIFO by
    reading bits 16 through 18 in the MFSR.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主接收数据寄存器（MRDR）接收到的 I²C 硬件数据会被添加到接收 FIFO 中。读取 MRDR 会从 FIFO 中检索下一个可用的字节（在位 0 到
    7 之间）。如果 FIFO 为空，则 MRDR 的第 14 位会被设置。注意，您还可以通过读取 MFSR 中的第 16 到 18 位来检查 FIFO 中是否有可用数据。
- en: 11.1.2 Teensy 4.*x* Wire Code
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 Teensy 4.*x* Wire 代码
- en: The following sections describe the operations of Gemmell’s Teensy 4 code directly
    associated with the Arduino I²C functions. I won’t provide the usual DAC output
    demonstration program in this section, since you can easily test Gemmell’s code
    by downloading his library, including it in your Teensyduino IDE, and running
    the Arduino example in Listing 8-1 (don’t forget to replace `#include <Wire.h>`
    with `#include <i2c_driver_wire.h>`). The results should prove nearly identical
    with possible slight differences in timing, as Gemmell’s code is running on a
    much faster processor than the Teensy 3.2 I used to produce the oscilloscope output
    in Listing 8-1.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分描述了 Gemmell 的 Teensy 4 代码中与 Arduino I²C 函数直接相关的操作。由于您可以通过下载 Gemmell 的库并将其包含在
    Teensyduino IDE 中来轻松测试他的代码，我在本节中不提供常规的 DAC 输出演示程序，并运行清单 8-1 中的 Arduino 示例（别忘了将
    `#include <Wire.h>` 替换为 `#include <i2c_driver_wire.h>`）。结果应该几乎相同，只是由于 Gemmell
    的代码运行在比我用来生成清单 8-1 中示波器输出的 Teensy 3.2 更快的处理器上，可能会有轻微的时间差异。
- en: 'Gemmell’s library provides drop-in code for the following Arduino I²C functions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Gemmell 的库提供了以下 Arduino I²C 函数的即插即用代码：
- en: '`Wire.begin()`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wire.begin()`'
- en: '`Wire.beginTransmission()`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wire.beginTransmission()`'
- en: '`Wire.endTransmission()`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wire.endTransmission()`'
- en: '`Wire.write()`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wire.write()`'
- en: '`Wire.requestFrom()`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wire.requestFrom()`'
- en: '`Wire.read()`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wire.read()`'
- en: The next sections describe the implementation of each of these functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分将描述这些函数的实现。
- en: 'When you study Gemmell’s code, the best approach is to take a top-down look
    starting with the Arduino Wire objects. The *i2c_driver_wire.cpp* file declares
    the following three objects:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你学习 Gemmell 的代码时，最好的方法是从 Arduino Wire 对象开始，采用自上而下的方式查看。*i2c_driver_wire.cpp*
    文件声明了以下三个对象：
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Wire` object corresponds to the standard Arduino I²C Wire device and controls
    I²C communication on the Teensy SDA and SCL lines. The `Wire2` and `Wire3` objects
    are extensions of the original Arduino I²C library, supporting communication on
    the Teensy’s (SDA1, SCL1) and (SDA2, SCL2) lines.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wire` 对象对应于标准的 Arduino I²C Wire 设备，控制 Teensy 的 SDA 和 SCL 线路上的 I²C 通信。`Wire2`
    和 `Wire3` 对象是原始 Arduino I²C 库的扩展，支持 Teensy 的 (SDA1, SCL1) 和 (SDA2, SCL2) 线路上的通信。'
- en: The `Wire` objects support both master and slave devices. (Again, I use the
    archaic terms *master* and *slave* in this section only for consistency with ARM
    documentation and Gemmell’s code.) In this chapter I’ll focus just on the master
    component.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wire` 对象支持主设备和从设备。（再次声明，我在本节中使用过时的术语 *master* 和 *slave*，仅为与 ARM 文档和 Gemmell
    的代码保持一致。）在本章中，我将专注于主设备部分。'
- en: 11.1.2.1 The begin() Function
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.2.1 `begin()` 函数
- en: The `begin()` function replaces the standard Arduino `Wire.begin()` function.
    It is responsible for initializing the I²C hardware and software before calling
    other I²C functions. It initializes the appropriate Teensy pins for I²C communication,
    resets any existing I²C initialization, sets the I²C clock frequency, sets up
    interrupt vectors, and initializes the iMXRT 1062 registers as necessary.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin()` 函数替代了标准 Arduino 的 `Wire.begin()` 函数。它负责在调用其他 I²C 函数之前初始化 I²C 硬件和软件。它会为
    I²C 通信初始化适当的 Teensy 引脚，重置任何现有的 I²C 初始化，设置 I²C 时钟频率，设置中断向量，并根据需要初始化 iMXRT 1062
    寄存器。'
- en: 'The `Wire`, `Wire1`, and `Wire2` object declarations (in the *i2c_driver_wire.cpp*
    file) allocate storage but do little else. In the Arduino programming paradigm,
    object initialization does not take place in the constructor; instead, the initialization
    occurs during the call to the `I2CDriverWire::begin()` function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wire`、`Wire1` 和 `Wire2` 对象声明（在 *i2c_driver_wire.cpp* 文件中）分配了存储空间，但几乎没有做其他事情。在
    Arduino 编程范式中，对象的初始化不会发生在构造函数中；相反，初始化是在调用 `I2CDriverWire::begin()` 函数时进行的。'
- en: '[PRE2]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `begin()` function stops any current activity by calling the `end()` function
    and then punts on the task to the `I2CMaster` class constructor (the `master_frequency`
    parameter is the default I²C speed of 100 kHz). The `I2CMaster` class is just
    an abstract base class, overridden by the `IMX_RT1060_I2CMaster` class, which
    provides the actual code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin()`函数通过调用`end()`函数停止当前的任何活动，然后将任务推给`I2CMaster`类构造函数（`master_frequency`参数是默认的I²C速度100
    kHz）。`I2CMaster`类只是一个抽象基类，被`IMX_RT1060_I2CMaster`类重写，提供实际的代码。'
- en: 'Here is the overridden `begin()` function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重写的`begin()`函数：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Before I discuss individual statements in this function, note that the identifier
    `port` is a class variable pointing at the register set for the I²C port on which
    this function operates; `config` is also a class variable containing the port
    configuration.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论该函数中的各个语句之前，请注意标识符`port`是指向此函数操作的I²C端口的寄存器集的类变量；`config`也是包含端口配置的类变量。
- en: 'The call to `stop()` in the `begin()` function in the previous code shuts down
    any activity on the I²C port before this code initializes the system, which could
    happen, for example, if the programmer calls `begin()` twice. Here’s the code
    for `stop()`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中`begin()`函数中调用`stop()`函数会关闭I²C端口上的任何活动，在此代码初始化系统之前执行，例如如果程序员调用了两次`begin()`函数。以下是`stop()`函数的代码：
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Writing to the MCR using `port->MCR` ❶ does the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`port->MCR`❶写入MCR执行以下操作：
- en: '`LPI2C_MCR_RST` does a software reset of the controller.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LPI2C_MCR_RST`执行控制器的软件复位。'
- en: '`LPI2C_MCR_RRF` resets the receive FIFO memory buffer.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LPI2C_MCR_RRF`用于重置接收FIFO内存缓冲区。'
- en: '`LPI2C_MCR_RTF` resets the transmit FIFO.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LPI2C_MCR_RTF`用于重置发送FIFO。'
- en: The write to SCR (by storing into `port->SCR`) does the same thing for peripheral
    (slave) mode ❷. Finally, the `stop` function ❶ turns off and disconnects any interrupts
    (and interrupt service routines).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向`port->SCR`存储写入SCR完成了从设备（从设备）模式下的相同操作。最后，`stop`函数❶关闭并断开任何中断（和中断服务程序）。
- en: 'The call to `initialise_common()` in the `begin` function initializes hardware
    common to the controller (master) and peripheral (slave) modes. Here’s the code
    for that function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`begin`函数中调用`initialise_common()`函数初始化控制器（主控制器）和外围设备（从设备）的共同硬件。以下是该函数的代码：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`IMX_RT1060_I2CBase::Config` ❶ is a structure in the *imx_rt1060_i2c_driver.h*
    file (see the next box for its form). It defines Teensy pins and other information.
    `CCM_CSCDR2` ❷ is a hardware definition on the MCU, the CCM Serial Clock Divider
    Register 2\. The assignment to this hardware register sets up an internal clock
    divider needed to generate the I²C clock. The `PODF` field is the clock divider,
    and the `CCM_CSCDR2_LPI2C_CLK_SEL` constant specifies that the I²C clock gets
    derived from the system oscillator.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMX_RT1060_I2CBase::Config`❶是*imx_rt1060_i2c_driver.h*文件中的结构体（请参阅下一个框以获取其格式）。它定义了Teensy引脚和其他信息。`CCM_CSCDR2`❷是MCU上的硬件定义，CCM串行时钟分频器寄存器2。对此硬件寄存器的赋值设置了生成I²C时钟所需的内部时钟分频器。`PODF`字段是时钟分频器，`CCM_CSCDR2_LPI2C_CLK_SEL`常数指定I²C时钟来源于系统振荡器。'
- en: The assignment to `hardware.clock_gate_register` ❸ magically writes data to
    the CCM Clock Gating Register, because this variable overlays that register in
    the MCU’s memory map. Finally, the last two assignment statements in this function
    ❹ initialize the appropriate (depending on the port) SDA and SCL lines so that
    they are used for I²C communications, rather than as, for example, digital I/O
    lines.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对`hardware.clock_gate_register`❸的赋值通过变量覆盖了MCU内存映射中的CCM时钟门控寄存器，实现了向CCM时钟门控寄存器的神奇写入数据。最后，该函数中最后两个赋值语句❹根据端口的不同初始化了适当的SDA和SCL线，以便它们用于I²C通信，而不是例如数字I/O线。
- en: The assignment `port->MFCR` in the `begin()` function defines when an interrupt
    occurs. This particular statement sets the interrupts to occur when the transmit
    FIFO is completely empty or when the receive FIFO contains at least one word.
    In the Arduino environment, 0 (empty FIFO) is probably a good value to use. In
    a multithreaded environment, you might get better throughput on the I²C bus by
    setting the transmit value to 1 or some other nonzero value to keep the FIFO not
    empty as long as there is data to transmit.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin()`函数中的`port->MFCR`赋值定义了中断的发生时机。这个特定语句设置了当发送FIFO完全为空或接收FIFO至少包含一个字时发生中断。在Arduino环境中，0（空FIFO）可能是一个不错的值。在多线程环境中，通过将传输值设置为1或其他非零值，可以在I²C总线上获得更好的吞吐量，以保持FIFO非空，只要有数据要传输。'
- en: 'The call to `set_clock()` sets the I²C bus to the frequency passed as an argument
    to this code. The parameter should be 100,000, 400,000, or 1,000,000\. You must
    call `set_clock()` before calling the `begin()` function. Here’s the code for
    the `set_clock()` function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `set_clock()` 将 I²C 总线设置为此代码的参数传递的频率。参数应为 100,000、400,000 或 1,000,000。在调用
    `begin()` 函数之前，必须调用 `set_clock()`。以下是 `set_clock()` 函数的代码：
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `MCCR0` ❶ contains several bit fields filled in by the macros after the
    assignment. The `CLKLO` field specifies the minimum number of clock cycles the
    system uses for a low clock signal on the I²C bus. The `CLKHI` field is similar
    but specifies how long the clock must be high (this value must be less than `CLKLO`).
    The `DATAVD` field specifies the amount of time the data must remain valid on
    the SDA line. The `SETHOLD` field specifies the time for a start or stop condition.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`MCCR0` ❶ 包含多个位字段，在分配后由宏填充。`CLKLO` 字段指定系统在 I²C 总线上使用低时钟信号的最小时钟周期数。`CLKHI` 字段类似，但指定时钟必须保持高电平的时间（此值必须小于
    `CLKLO`）。`DATAVD` 字段指定数据在 SDA 线上必须保持有效的时间。`SETHOLD` 字段指定启动或停止条件的时间。'
- en: The `MCFGR1` ❷ controls several fields (see the NXP documentation). The main
    value being set here is the clock divisor. For 100 kHz the divisor is 2; for other
    frequencies the divisor is 1.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`MCFGR1` ❷ 控制多个字段（详见 NXP 文档）。此处设置的主要值是时钟除数。对于 100 kHz，除数为 2；对于其他频率，除数为 1。'
- en: 'The `MCFGR2` register ❸ determines:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`MCFGR2` 寄存器 ❸ 确定：'
- en: The number of cycles used for SDA glitch filtering (`LPI2C_MCFGR2_FILTSDA`)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 SDA 抖动滤波的周期数（`LPI2C_MCFGR2_FILTSDA`）
- en: The number of cycles used for SCL glitch filtering (`LPI2C_MCFGR2_FILTSCL`)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 SCL 抖动滤波的周期数（`LPI2C_MCFGR2_FILTSCL`）
- en: The number of cycles to determine when the bus has gone idle (`LPI2C_MCFGR2_BUSIDLE`)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于确定总线何时变为空闲的周期数（`LPI2C_MCFGR2_BUSIDLE`）
- en: The `MCCR1` register ❹ holds the clock configuration for I²C high-speed mode.
    See the discussion of `MCCR0` a few paragraphs earlier for more details as, other
    than speed, it behaves similarly to `MCCR1``.`
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`MCCR1` 寄存器 ❹ 包含 I²C 高速模式的时钟配置。关于速度以外的内容，请参阅前面几段关于 `MCCR0` 的讨论以获取更多细节，因为除了速度外，其行为类似于
    `MCCR1`。'
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
