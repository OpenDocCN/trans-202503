- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6'
- en: MACHINE LEARNING FEATURES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**机器学习特征**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'We’ve explored the two kinds of analysis required to understand an Android
    app: static and dynamic. We’ve also seen how a human security analyst can go back
    and forth between static and dynamic analysis to pinpoint the locations at which
    dangerous behavior occurs.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了理解Android应用所需的两种分析方法：静态分析和动态分析。我们还看到了人类安全分析师如何在静态分析和动态分析之间来回切换，以确定发生危险行为的位置。
- en: However, machine learning algorithms can’t perform the “back and forth” behavior
    of a human analyst. Because they can’t choose to explore one part of the code
    more than another part, they must associate a feature vector with each app, regardless
    of whether it is malicious or benign, and then use a previously trained model
    to make a prediction about it. This means they must determine in advance what
    to include in the feature vector.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，机器学习算法无法执行人类分析师的“来回”行为。因为它们无法选择优先探索代码的某一部分，而是必须为每个应用程序关联一个特征向量，无论它是恶意的还是良性的，然后使用之前训练的模型来对其进行预测。这意味着它们必须提前决定在特征向量中包括哪些内容。
- en: In this chapter, we first describe how to turn static and dynamic sources of
    information into input for machine learning algorithms, enabling us to scale our
    malware detection efforts to millions of APKs. Then we explore four novel types
    of features that are harder for attackers to evade or reverse engineer, yet robust
    enough to detect malware with high accuracy. These detection techniques take into
    account the fact that malware developers often understand the static and dynamic
    analysis methods used by security experts and can apply this knowledge to evade
    detection.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先描述如何将静态和动态信息源转化为机器学习算法的输入，从而使我们能够将恶意软件检测工作扩展到数百万个APK。然后，我们探索四种新型特征，这些特征对于攻击者来说更难以规避或逆向工程，但足够强大，能够以高准确率检测恶意软件。这些检测技术考虑到了这样一个事实：恶意软件开发者通常了解安全专家使用的静态和动态分析方法，并能利用这些知识来规避检测。
- en: '**Static Features**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**静态特征**'
- en: The first class of features we can associate with Android apps is based on a
    static analysis of the code. Unlike with data gleaned through human-based static
    analysis, software can easily extract their values. These features are immutable,
    in the sense that once we train a predictive model with a given set of features,
    we must stick with them when using the predictive model (however, new features
    can be added and old features removed when retraining).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以与Android应用程序关联的第一类特征是基于代码的静态分析。与通过人工静态分析获取的数据不同，软件可以轻松提取这些特征的值。这些特征是不可变的，从这个意义上讲，一旦我们使用给定的特征集训练了预测模型，在使用该模型时必须坚持这些特征（但是，在重新训练时，可以添加新特征并删除旧特征）。
- en: There are several files and folders inside an APK whose properties and content
    we can turn into machine learning features. One source of features is the *AndroidManifest.xml*
    file that every APK contains in its root directory. As discussed in [Chapter 3](ch03.xhtml),
    the manifest file defines the structure and metadata of the Android application,
    including the package name and app version. It might also include XML nodes that
    describe the app’s basic behavior, as well as the permissions requested by the
    application. [Listing 6-1](ch06.xhtml#ch6lis1) shows a snippet from the manifest
    file of a malware app, Fakebank *com.a* (v152, 0add), that references XML nodes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个APK文件中，有几个文件和文件夹的属性和内容可以转化为机器学习特征。特征的一个来源是每个APK根目录中包含的*AndroidManifest.xml*文件。正如在[第3章](ch03.xhtml)中讨论的，清单文件定义了Android应用程序的结构和元数据，包括包名和应用版本。它还可能包括描述应用程序基本行为的XML节点，以及应用程序请求的权限。[列表6-1](ch06.xhtml#ch6lis1)展示了来自恶意应用程序Fakebank
    *com.a*（v152，0add）清单文件的一个片段，引用了XML节点。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 6-1: XML nodes in the Android manifest associated with the Fakebank
    app*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-1：与Fakebank应用程序相关的Android清单中的XML节点*'
- en: 'We might also find features in the Java source code folder. In Java apps, this
    folder is part of the original code and is not present in the compiled APK file.
    Other folders of interest are *Res*, *lib*, and *assets*. The *Res* folder contains
    all non-code resources used by the application, such as XML layouts and images.
    The *lib* folder is tricky, as its purpose changes after compilation: in Android
    source code, it’s often used to store common files, utility classes, and imported
    dependencies associated with applications, while in compiled APK files it stores
    native code files used by the application. The *assets* folder might include a
    wide range of files, such as text, XML, fonts, music, and video. Another source
    of features is the *build.gradle* file, which includes build-related configurations.
    It is present only during development and not included in the final APK.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可能会在Java源代码文件夹中找到特征。在Java应用中，该文件夹是原始代码的一部分，在编译后的APK文件中并不存在。其他值得关注的文件夹有*Res*、*lib*和*assets*。*Res*文件夹包含应用程序使用的所有非代码资源，例如XML布局和图片。*lib*文件夹比较复杂，因为它的用途在编译后发生变化：在Android源代码中，它通常用于存储常用文件、工具类和与应用程序相关的依赖项，而在编译后的APK文件中，它存储应用程序使用的本地代码文件。*assets*文件夹可能包括各种各样的文件，如文本、XML、字体、音乐和视频。另一个特征来源是*build.gradle*文件，其中包含与构建相关的配置。该文件仅在开发过程中存在，并不包含在最终的APK中。
- en: 'We can define two versions of many features. A *binary* version of a feature
    is set to 0 or 1 depending upon whether the feature does or doesn’t occur. For
    instance, we might associate a feature with an API function call. If an app makes
    at least one call to that API in its code, we’d set the binary version of the
    feature to 1; otherwise, we’d set it to 0\. A *statistical* version of the same
    feature, on the other hand, might reflect the number of calls the app makes to
    the API. Alternatively, it might record the number of times the API function is
    invoked with certain inputs and return a statistical quantity, such as the mean,
    median, or standard deviation of the results. The following features commonly
    appear in the literature on machine learning–based malware detection:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为许多特征定义两个版本。特征的*二进制*版本根据该特征是否存在而设为0或1。例如，我们可能将特征与API函数调用相关联。如果应用在其代码中至少调用一次该API，我们将特征的二进制版本设置为1；否则，设置为0。另一方面，*统计*版本的特征可能反映应用对该API调用的次数。或者，它可能记录API函数使用特定输入时调用的次数，并返回一个统计量，如结果的均值、中位数或标准差。以下特征在基于机器学习的恶意软件检测文献中常见：
- en: '**Permissions**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**权限**'
- en: We can design a number of features related to the permissions that an application
    requests. We might, for example, create a binary feature for each permission.
    We could also define statistical features corresponding to the number of normal,
    signature, and dangerous permissions requested. According to the official Android
    developer site, dangerous permissions are those that either involve the private
    data of users or could possibly affect such private user data. For instance, we’ve
    already seen that the *com.bp.statis.bloodsugar* malware discussed in [Chapter
    3](ch03.xhtml) requests the `READ_CONTACTS` permission even though there is little
    reason to believe that a blood sugar monitoring app needs access to a user’s contacts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设计与应用请求的权限相关的多个特征。例如，我们可能为每个权限创建一个二进制特征。我们还可以定义与请求的正常权限、签名权限和危险权限的数量相对应的统计特征。根据官方Android开发者网站的说明，危险权限是指那些涉及用户私人数据或可能影响此类私人用户数据的权限。例如，我们已经看到，在[第3章](ch03.xhtml)中讨论的*com.bp.statis.bloodsugar*恶意软件请求了`READ_CONTACTS`权限，尽管几乎没有理由相信血糖监测应用需要访问用户的联系人。
- en: '**Activities**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动**'
- en: As discussed in [Chapter 3](ch03.xhtml), activities implement the visual interface
    of an Android app and are declared in the manifest file. We could create a set
    of binary features to indicate whether each activity is used or not. The total
    number of activities is also a potential feature.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第3章](ch03.xhtml)中讨论的，活动实现了Android应用的视觉界面，并在清单文件中声明。我们可以创建一组二进制特征来表示每个活动是否被使用。活动的总数也是一个潜在的特征。
- en: '**Services**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务**'
- en: Apps use services to implement long-running background operations that facilitate
    interactions with the system. As in the case of activities, we can define binary
    features indicating whether each service is used or not. Moreover, we can define
    simple counts and statistical features. For instance, in the case of the *com.bp.statis.bloodsugar.PE*
    service discussed in [Chapter 3](ch03.xhtml), we might set this value to 1, as
    there is little reason for a blood sugar app to listen to incoming notifications
    from all of the apps in the system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用通过服务实现长时间运行的后台操作，便于与系统进行交互。和活动一样，我们可以定义二进制特征，表示每个服务是否被使用。此外，我们还可以定义简单的计数和统计特征。例如，在
    [第 3 章](ch03.xhtml) 讨论的 *com.bp.statis.bloodsugar.PE* 服务中，我们可能会将该值设置为 1，因为血糖应用几乎没有理由接收系统中所有应用的来电通知。
- en: '**Content providers**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容提供者**'
- en: A content provider encapsulates data and gives it to other applications. For
    each content provider, we might have a feature set to 0 if it doesn’t exist and
    1 if it does exist in the app. We can also create a feature for the number of
    content providers the app uses.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 内容提供者封装了数据并将其提供给其他应用。对于每个内容提供者，如果它在应用中不存在，我们可能会设置特征值为 0，如果它存在，则设置为 1。我们还可以创建一个特征，表示应用使用的内容提供者的数量。
- en: '**Broadcast receivers**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**广播接收器**'
- en: The broadcast receiver component of an application enables it to receive broadcast
    messages from the system or other applications. As in the preceding cases, we
    can create binary features, counts, and statistical features for these receivers.
    However, while it is easy to find broadcast receivers declared in the manifest
    file, it is not always easy to find those declared at runtime, especially as they
    may be part of encrypted or obfuscated code. Moreover, some apps might want to
    register a `RECEIVE_SMS` receiver, which enables them to intercept incoming SMS
    traffic (for example, one-time passwords or alerts of suspicious activity).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的广播接收器组件使其能够接收来自系统或其他应用的广播消息。和前面的情况一样，我们可以为这些接收器创建二进制特征、计数和统计特征。然而，虽然很容易在清单文件中找到声明的广播接收器，但在运行时找到那些声明的广播接收器并不总是容易，尤其是它们可能是加密或混淆代码的一部分。此外，一些应用可能希望注册
    `RECEIVE_SMS` 接收器，这使得它们能够拦截传入的短信流量（例如，一次性密码或可疑活动警报）。
- en: '**Intent filters**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**意图过滤器**'
- en: Activities, services, and broadcast receivers can use intent filters to specify
    the kinds of operations to which they will respond. In the case of broadcast receivers,
    intents specify the types of broadcasts that they can handle. As in the preceding
    cases, we can define and extract binary features and statistical features for
    intents.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 活动、服务和广播接收器可以使用意图过滤器来指定它们将响应的操作类型。对于广播接收器，意图指定它们可以处理的广播类型。和之前的情况一样，我们可以为意图定义和提取二进制特征和统计特征。
- en: '**API calls**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**API 调用**'
- en: The Android platform provides a set of API packages that developers can use
    to build applications. We can create binary features for each API package (based
    on whether it is called or not) as well as for each class within those packages
    (based on whether the class is called or not). In addition, numeric features for
    an API package might track the number of times the app calls a class within a
    package or a function within a class. We’ll provide a detailed introduction to
    API features later in this chapter, as we can use them to generate more advanced
    features.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Android 平台提供了一套 API 包，开发者可以用来构建应用。我们可以为每个 API 包创建二进制特征（根据是否调用该包）以及该包内的每个类（根据该类是否被调用）。此外，API
    包的数值特征可能会跟踪应用调用包内某个类或类内某个函数的次数。我们将在本章稍后详细介绍 API 特征，因为我们可以利用它们生成更高级的特征。
- en: '**Network elements**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络元素**'
- en: An Android application’s source code may contain numerous network elements,
    such as IP addresses, URLs, and hostnames. We can collect these elements to generate
    binary features and statistical features (for example, the number of hostnames
    listed in the file). We may also want to use the number of external URLs referenced
    in the code as a feature.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Android 应用的源代码可能包含许多网络元素，如 IP 地址、URLs 和主机名。我们可以收集这些元素，生成二进制特征和统计特征（例如，文件中列出的主机名数量）。我们还可能希望使用代码中引用的外部
    URLs 数量作为一个特征。
- en: The malware author might try to make static analysis difficult through a variety
    of instruments. These could include using unintelligible names for variables,
    encrypting parts of the code, and using other obfuscation methods such as reflection
    (see [Chapter 3](ch03.xhtml)). We can also define static features to describe
    whether such phenomena exist in the app code, as well as their frequency of occurrence.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者可能通过各种手段来使静态分析变得困难。这些手段可能包括使用难以理解的变量名称、加密代码的部分内容以及使用其他混淆方法，如反射（见[第3章](ch03.xhtml)）。我们还可以定义静态特性来描述这些现象是否存在于应用程序代码中，以及它们的出现频率。
- en: '**Dynamic Features**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**动态特性**'
- en: We can turn the results of our dynamic analysis into machine learning features,
    too. As covered in [Chapter 4](ch04.xhtml), dynamic analysis focuses on observed
    runtime properties and behavior of applications. Consequently, the features derived
    from it describe events that were actually observed rather than the more speculative
    features derived from the static analysis of code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将动态分析的结果转化为机器学习特性。如[第4章](ch04.xhtml)中所述，动态分析关注的是应用程序的运行时属性和行为。因此，从动态分析中得出的特性描述的是实际观察到的事件，而不是从代码静态分析中推测的特性。
- en: To generate many of these features, we must feed some set of inputs to the app,
    such as interactions that the app has with the user (an example is the `monkey`
    command discussed in [Chapter 4](ch04.xhtml)). We might run the app using the
    first input and generate some results, then run it with the second input and generate
    more results, continuing the process until we’ve exhausted all inputs in the set.
    We can also extract features by analyzing the network traffic generated when the
    app is run through programs such as tcpdump and Wireshark.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成许多这些特性，我们必须向应用程序提供一些输入集，例如应用程序与用户的交互（一个例子是[第4章](ch04.xhtml)中讨论的`monkey`命令）。我们可以使用第一个输入运行应用程序并生成一些结果，然后使用第二个输入运行并生成更多结果，继续这个过程直到我们用尽所有输入集中的输入。我们还可以通过分析应用程序通过tcpdump和Wireshark等程序运行时生成的网络流量来提取特性。
- en: 'The following dynamic features for the Android platform have been widely discussed
    in the literature:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是安卓平台上已经在文献中广泛讨论的动态特性：
- en: '**Services**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务**'
- en: We can generate dynamic features to record each started service. These may be
    binary (based on whether the app starts that service or not) or numeric (for example,
    the average number of calls to the service across the set of inputs). The total
    number of services started can also be a feature. Additionally, we could associate
    a sequence of services with a feature by recording whether the app ever invokes
    that sequence (a binary feature) or how many times an app invokes it on average
    across the set of inputs (a numeric feature).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以生成动态特性来记录每个启动的服务。这些特性可能是二进制的（基于应用程序是否启动了该服务）或数字的（例如，跨输入集调用该服务的平均次数）。启动的服务总数也可以是一个特性。此外，我们还可以通过记录应用程序是否曾调用过该服务序列（一个二进制特性）或应用程序平均调用该序列的次数（一个数字特性）来将服务序列与特性关联。
- en: '**The `DexClassLoader`**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**`DexClassLoader`**'
- en: This is a standard Android API used to load classes from *.jar* and *.apk* files
    that contain a *classes.dex* file. Malicious apps frequently use this API to evade
    static analysis because it lets them execute code that didn’t come from the application’s
    source code (one example is the Xenomorph malware family discussed in [Chapter
    4](ch04.xhtml)). We could create a feature that is set to 1 if the app calls `DexClassLoader`
    and to 0 otherwise. Additional features could be defined based on the count of
    calls, *n*-gram sequences, and other statistics.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的安卓API，用于加载包含*classes.dex*文件的*.jar*和*.apk*文件。恶意应用程序经常使用此API来规避静态分析，因为它允许执行未来自应用程序源代码的代码（一个例子是[第4章](ch04.xhtml)中讨论的Xenomorph恶意软件家族）。我们可以创建一个特性，如果应用程序调用`DexClassLoader`，则该特性设为1，否则设为0。还可以根据调用次数、*n*元组序列和其他统计信息定义附加特性。
- en: '**Permissions**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**权限**'
- en: We can create binary features that record whether the app invokes an API that
    requires some permission, even if the permission doesn’t appear in the application
    code itself. Although Android apps must explicitly declare any permissions that
    they request within the manifest file, they might try to circumvent this requirement
    by acquiring permissions in different ways. One strategy is to use a covert channel,
    such as the communication between multiple APKs, to share information. This behavior
    poses a challenge to dynamic analysts, as their lab setups must be able to run
    multiple interacting apps at the same time. As in the previous cases, we can also
    generate statistical features and *n*-gram features based on permissions. For
    instance, in the Xenomorph malware, we would record the fact that it invoked the
    accessibility API by setting that value to 1.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建二进制特性，记录应用程序是否调用了需要某些权限的API，即使该权限没有出现在应用程序的代码中。尽管Android应用必须在清单文件中明确声明它们请求的任何权限，但它们可能会尝试通过不同的方式绕过这一要求，获取权限。一种策略是使用隐蔽通道，比如多个APK之间的通信，来共享信息。这种行为给动态分析人员带来了挑战，因为他们的实验室设置必须能够同时运行多个交互的应用程序。与之前的情况一样，我们也可以基于权限生成统计特性和*n*-gram特性。例如，在Xenomorph恶意软件中，我们会记录它调用了辅助功能API的事实，并将该值设置为1。
- en: '**Data leaks**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据泄露**'
- en: An app might sometimes leak a user’s personal data, be it accidentally, because
    the app is poorly coded, or intentionally, in an attempt to steal the data. We
    can generate features that reflect the leaked content.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，应用程序可能会泄露用户的个人数据，无论是因为应用程序编码不良导致的意外泄漏，还是故意泄露数据以窃取信息。我们可以生成反映泄露内容的特性。
- en: '**Use of cryptography**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密操作的使用**'
- en: We can define a feature that tracks whether an app performs any cryptographic
    operations. When an APK executes encryption operations (for example, to store
    encrypted files), the sandbox used to run it can track and record this. We might
    set a binary feature to 1 if the app generates any encrypted files during execution
    and set it to 0 otherwise. We see this behavior in the Xenomorph app; see the
    `encryptMessage` function in [Listing 4-5](ch04.xhtml#ch4lis5), which the app
    could invoke zero or more times during its execution in a sandbox environment.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个特性，用于跟踪应用程序是否执行任何加密操作。当一个APK执行加密操作（例如，存储加密文件）时，用于运行它的沙箱可以跟踪并记录这一操作。如果应用程序在执行过程中生成了加密文件，我们可以将二进制特性设置为1，否则设置为0。我们在Xenomorph应用中看到这种行为；请参阅[列表4-5](ch04.xhtml#ch4lis5)中的`encryptMessage`函数，应用程序在沙箱环境中执行时可能会调用该函数零次或多次。
- en: '**Network activities**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络活动**'
- en: We can use a set of features to keep track of operations that open or close
    network sockets by recording the destination host. We might also create features
    based on the data received from the network, as well as the source of the data
    and any data that the application sends to others on the network.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一组特性来跟踪打开或关闭网络套接字的操作，记录目标主机。我们还可以根据从网络接收到的数据、数据的来源以及应用程序发送到网络中其他设备的数据创建特性。
- en: '**Sending SMS messages**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送短信**'
- en: When an app sends text messages during its execution phase, we can record the
    identity of the recipient and the message’s content to use as features. We can
    also count the total number of messages sent during the execution or define a
    binary feature that we set to 1 if the app sends any messages at all.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在执行阶段发送短信时，我们可以记录收件人的身份和消息内容，以此作为特性。我们还可以计算发送的短信总数，或者定义一个二进制特性，如果应用程序发送了任何消息，则将其设置为1。
- en: '**Phone calls**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**电话拨打**'
- en: Malicious Android apps sometimes make phone calls (for example, to premium rate
    numbers). In such cases, we can define features to store the numbers called or
    use a binary feature to record the fact that some external numbers were called.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意Android应用有时会拨打电话（例如，拨打高收费号码）。在这种情况下，我们可以定义特性来存储拨打的号码，或者使用二进制特性记录某些外部号码被拨打的事实。
- en: '**Answered intents**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**已接听的意图**'
- en: We can capture the intents to which the application responds during its execution
    and record these as dynamic features.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以捕获应用程序在执行过程中响应的意图，并将这些意图记录为动态特性。
- en: '**Files**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件**'
- en: We might create features to record the names of any library files that the app
    uses. Also, when the application reads or writes to specific files, we can capture
    the filename and the content, then generate features based on these.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会创建一些特性，用于记录应用程序使用的任何库文件的名称。此外，当应用程序读取或写入特定文件时，我们可以捕获文件名和内容，然后基于这些信息生成特性。
- en: '**Method Call Features (A Weak Tactic)**'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**方法调用特征（一个弱策略）**'
- en: To go beyond basic static and dynamic data, some researchers have turned to
    API method calls as potential features. The Android platform provides a set of
    API packages that developers can use to access a host of valuable functionality.
    For example, the *android.accessibilityservice* package can help users with disabilities
    interact with Android devices. However, malware developers can also use it, and
    they widely abuse it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了超越基本的静态和动态数据，一些研究人员将 API 方法调用作为潜在特征。Android 平台提供了一套 API 包，开发者可以利用这些包来访问各种有价值的功能。例如，*android.accessibilityservice*
    包可以帮助残障用户与 Android 设备进行交互。然而，恶意软件开发者也可以利用它，而且他们广泛滥用它。
- en: Each API package contains a number of classes, and each class has its own methods
    that we can use to define new features for our models. To create features using
    the 171 API packages in Android API 23, for example, we might build a 171-dimensional
    feature vector for each Android app to capture the frequency with which that app
    calls the methods from each package. For instance, if some API package includes
    40 methods belonging to different classes and an app calls each of them twice,
    the corresponding feature value would be 40 × 2, or 80.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 API 包含若干个类，每个类都有其方法，我们可以利用这些方法为我们的模型定义新特征。例如，在 Android API 23 中使用 171 个 API
    包来创建特征时，我们可以为每个 Android 应用构建一个 171 维的特征向量，以捕捉该应用调用每个包中方法的频率。例如，如果某个 API 包包含 40
    个不同类的方法，且应用调用每个方法两次，则对应的特征值为 40 × 2，或 80。
- en: These API feature values can vary greatly. For instance, consider the 171 API
    feature values associated with a goodware sample called *ESPN 6.0.4*. The largest
    of these feature values is 161,698, while the smallest is 0, producing a standard
    deviation of 10,488.26\. By contrast, another goodware sample, *com.hancom.office.editor*
    (v1, 75d1), has 6 as its largest API feature value and 0 as its smallest, with
    a standard deviation of only 0.61\. You might have the instinct to normalize feature
    values to account for this difference, but normalizing isn’t necessary because
    good machine learning algorithms will automatically determine which values of
    a given feature help create good separators between malware and goodware.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 API 特征值可能会有很大差异。例如，考虑一个叫 *ESPN 6.0.4* 的良性软件样本，其对应的 171 个 API 特征值中，最大的为 161,698，最小的是
    0，标准差为 10,488.26。相比之下，另一个良性软件样本 *com.hancom.office.editor*（v1，75d1）的最大 API 特征值为
    6，最小为 0，标准差仅为 0.61。你可能会本能地想对特征值进行归一化，以应对这种差异，但其实归一化并非必要，因为好的机器学习算法会自动确定哪些特征值有助于创建良好的恶意软件和良性软件之间的分隔。
- en: While you’ll find these API-based features used in the literature, malware developers
    can evade them easily. Zhengcuan Cai and Roland Yap studied 57 Android antivirus
    tools in their 2016 paper “Inferring the Detection Logic and Evaluating the Effectiveness
    of Android Anti-Virus Apps.” They found that malicious hackers can easily uncover
    the detection logic in antivirus apps that use static analysis alone, enabling
    them to evade detection. For instance, in this case the developers could include
    a bunch of dummy calls to API features in order to change their app’s 171-dimensional
    feature vector. Likewise, obfuscation methods such as reflection and dynamic code
    loading can lower an app’s feature counts. The feature counts of particularly
    well-hidden method calls might even drop to zero if static analysis doesn’t find
    those calls (which would be the case if, for instance, the calls were in an encrypted
    section of code). For completeness, machine learning models should include both
    static and dynamic features of API calls.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你会在文献中看到这些基于 API 的特征，但恶意软件开发者可以轻松规避它们。Zhengcuan Cai 和 Roland Yap 在他们2016年的论文《推测检测逻辑与评估
    Android 杀毒应用效果》中研究了57款 Android 杀毒工具。他们发现，恶意黑客可以轻松揭示仅使用静态分析的杀毒应用的检测逻辑，从而规避检测。例如，在这种情况下，开发者可以在应用中加入大量虚假的
    API 调用，以改变其 171 维特征向量。同样，反射和动态代码加载等混淆方法可以降低应用的特征数量。特别隐藏的方法调用的特征数量甚至可能降至零，如果静态分析未能找到这些调用（例如，调用位于加密代码段中时）。为了完整性，机器学习模型应该包括
    API 调用的静态和动态特征。
- en: By contrast, advanced features, based on techniques like triadic suspicion graphs,
    landmarks, feature clustering, and correlation graphs, are highly effective in
    identifying malicious Android apps. Experiments have shown that such features
    are harder for malicious hackers to evade, in part because it is hard for them
    to determine exactly how these features are used in a detection system. The remainder
    of this chapter introduces these advanced features.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，基于三元怀疑图、地标、特征聚类和关联图等技术的高级特征在识别恶意 Android 应用方面非常有效。实验表明，这些特征更难被恶意黑客规避，部分原因是黑客很难准确判断这些特征在检测系统中的使用方式。本章其余部分将介绍这些高级特征。
- en: '**Triadic Suspicion Graph Features**'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**三元怀疑图特征**'
- en: Rather than using API method calls on their own, we can generate a more robust
    group of features derived from a special class of graphs called *triadic suspicion
    graphs (TSGs)*. Essentially, a TSG aims to understand the differences between
    the use of an API package by goodware on the one hand and different types of malicious
    apps on the other hand. [Figure 6-1](ch06.xhtml#ch6fig1) is an illustration of
    a TSG that compares goodware to banking trojans. We’ll walk through its elements
    in the paragraphs that follow.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从一种特殊类型的图形——*三元怀疑图 (TSG)*——派生出一组更强大的特征，而不仅仅是使用 API 方法调用。基本上，TSG 旨在理解良性软件和不同类型恶意应用在使用
    API 包时的差异。[图 6-1](ch06.xhtml#ch6fig1)是一个 TSG 示例，比较了良性软件与银行木马的不同。接下来的段落将详细讲解其元素。
- en: 'A TSG is made up of vertices connected by edges. In this context, the TSG contains
    three kinds of vertices: the complete set of API package calls defined in the
    Android API, the sampled goodware, and the sampled malware, randomly drawn from
    some larger collections of goodware and malware, respectively. The TSG’s edges
    are defined as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: TSG 由通过边连接的顶点组成。在这个上下文中，TSG 包含三种类型的顶点：Android API 中定义的 API 包调用的完整集合，采样得到的良性软件，和从更大的良性软件和恶意软件集合中随机抽取的样本。TSG
    的边定义如下：
- en: For each goodware *g* and each API package call *a*, if *g* calls a method from
    *a* at least once, there is an edge from *g* to *a*.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个良性软件 *g* 和每个 API 包调用 *a*，如果 *g* 至少调用过 *a* 中的某个方法一次，则从 *g* 到 *a* 会有一条边。
- en: For each pair of API package calls *a*[1] and *a*[2], if *a*[1] calls any method
    from *a*[2], there is an edge from *a*[1] to *a*[2].
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每对 API 包调用 *a*[1] 和 *a*[2]，如果 *a*[1] 调用了 *a*[2] 中的任何方法，则从 *a*[1] 到 *a*[2]
    会有一条边。
- en: For each malware *b* and each API package call *a*, if *b* calls any method
    from *a* at least once, there is an edge from *b* to *a*.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个恶意软件 *b* 和每个 API 包调用 *a*，如果 *b* 至少调用过 *a* 中的某个方法一次，则从 *b* 到 *a* 会有一条边。
- en: '![Image](../images/ch06fig01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/ch06fig01.jpg)'
- en: '*Figure 6-1: A partial TSG containing three goodware samples*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：一个包含三个良性软件样本的部分 TSG*'
- en: The goodware and malware collections don’t need to be fixed. An analyst might
    use one sampling in one week, switch to another in the next week, and keep doing
    so regularly in order to present a moving target. Varying the sets changes the
    attack surface and makes it harder for an adversary to guess the precise nature
    of the defense.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 良性软件和恶意软件集合不需要固定。分析员可能在某一周使用一个样本集，下一周切换到另一个，并且定期更换样本集，以呈现出一个不断变化的目标。变化集合会改变攻击面，使得对手更难猜测防御的具体方式。
- en: We also suggest keeping the size of the sets relatively small, and varying it
    as well. For example, if we had access to 1 million goodware samples and 10,000
    malware samples, we might select only, say, 1,000 samples for each of the groups
    in the first week, 1,322 in the next week, 1,127 in the third week, and so forth.
    Frequently modifying the sample sizes is another way to keep the attacker in the
    dark about the nature of the defenses being used; however, the number of samples
    in the two sets should be approximately the same.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还建议保持这些集合的大小相对较小，并进行变化。例如，如果我们有 100 万个良性软件样本和 10,000 个恶意软件样本，我们可能会选择每组中的 1,000
    个样本作为第一周的样本，第二周选择 1,322 个样本，第三周选择 1,127 个样本，依此类推。经常修改样本大小是让攻击者无法掌握防御体系特性的另一种方法；不过，两个集合中的样本数量应大致相同。
- en: 'Once we’ve determined the vertices and edges in a TSG, we weight the edges
    using a weight function. In this context, the weights reflect the number of times
    an app calls a corresponding API package’s methods. For any edge from a goodware
    or malware app *v* to an API package *a*, we use *f*(*v*, *a*) to denote the number
    of times *v* calls methods from *a*. The following equations demonstrate five
    plausible definitions of a weight function *w*. Functions *w*[1], *w*[2], and
    *w*[3], respectively, represent linear, quadratic, and cubic relationships between
    the API package call frequency and the edge weight, while *w*[4] and *w*[5] capture
    other possible nonlinear relationships:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了 TSG 中的顶点和边，我们就使用权重函数对边进行加权。在这个上下文中，权重反映了一个应用调用对应 API 包方法的次数。对于从良性软件或恶意软件应用
    *v* 到 API 包 *a* 的任何边，我们使用 *f*(*v*, *a*) 来表示 *v* 调用 *a* 方法的次数。以下方程展示了五种可能的权重函数
    *w* 定义。函数 *w*[1]、*w*[2] 和 *w*[3] 分别表示 API 包调用频率与边权重之间的线性、二次和三次关系，而 *w*[4] 和 *w*[5]
    捕捉了其他可能的非线性关系：
- en: '![image](../images/math188.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/math188.jpg)'
- en: Having different definitions is useful because most machine learning algorithms
    are very sensitive to the input features and can’t always correctly infer the
    most accurate nonlinear relationships between data points using the modeling framework
    alone.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有不同的定义是有用的，因为大多数机器学习算法对输入特征非常敏感，单靠建模框架不能总是正确推断数据点之间最准确的非线性关系。
- en: We set the weights of edges between pairs of API package calls to the same default
    value, 1\. This is because we are more interested in whether a specific edge exists
    than in the frequency with which one API package calls another within the Android
    API, as attackers can’t control these relationships.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 API 包调用之间的边的权重设置为相同的默认值 1。这是因为我们更关心特定边是否存在，而不是 Android API 中一个 API 包调用另一个的频率，因为攻击者无法控制这些关系。
- en: You can see the weighted edges in [Figure 6-1](ch06.xhtml#ch6fig1), which uses
    the function *w*[1], as well as directional arrows to show the calling relationships
    among pairs of API packages. Now you can observe that none of the three goodware
    samples call the API package `android.app.admin`, while two of the three banking
    trojans call it a few times. These sorts of patterns might help us identify malicious
    apps.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图 6-1](ch06.xhtml#ch6fig1)中看到加权边，它使用了函数 *w*[1]，以及方向箭头来显示 API 包之间的调用关系。现在你可以观察到，三种良性软件样本中没有调用
    API 包`android.app.admin`，而三种银行木马中的两个会多次调用该包。这类模式可能帮助我们识别恶意应用程序。
- en: '***Suspicion Scores***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可疑得分***'
- en: With the TSG defined, we can now calculate the *suspicion score* of an API package.
    In short, we rank an API package that is frequently invoked by malware but not
    by goodware as more suspicious than one that is frequently invoked by goodware
    but not by malware. Suspicion scores alone aren’t enough to predict whether an
    Android app is malicious or not, but they do generate a set of features that might
    be able to provide good predictive performance. Moreover, as the malware developer
    won’t know the reference sets and weight functions used to create the TSGs, they
    can’t easily evade detection frameworks that use them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了 TSG 后，我们现在可以计算 API 包的 *可疑得分*。简而言之，我们将一个经常被恶意软件调用而不被良性软件调用的 API 包，认为它比一个经常被良性软件调用而不被恶意软件调用的
    API 包更可疑。仅凭可疑得分不足以预测一个 Android 应用是否恶意，但它确实生成了一组特征，这些特征可能提供良好的预测性能。此外，由于恶意软件开发者无法知道用于创建
    TSG 的参考集和权重函数，他们无法轻易规避使用这些函数的检测框架。
- en: 'We define 12 possible suspicion scoring functions, *sus*[1] through *sus*[12].
    Having multiple candidate functions ensures that we are less prone to over-fitting
    a predefined model. When we supply these scores and other features as input, machine
    learning techniques can tell us which suspicion scoring function is best able
    to differentiate benign apps from malicious ones. You might notice that the function
    definitions, shown next, are closely related to the weight functions *w*[1] through
    *w*[5]:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了 12 个可能的可疑得分函数，*sus*[1] 到 *sus*[12]。拥有多个候选函数确保我们不容易过拟合一个预定义模型。当我们将这些得分和其他特征作为输入时，机器学习技术可以告诉我们哪个可疑得分函数最能区分良性应用和恶意应用。你可能注意到，下面显示的函数定义与权重函数
    *w*[1] 到 *w*[5] 密切相关：
- en: '![image](../images/math189.jpg)![image](../images/math190.jpg)![image](../images/math191-01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/math189.jpg)![image](../images/math190.jpg)![image](../images/math191-01.jpg)'
- en: These suspicion score functions all make use of an indicator function *I*(*v*[1],
    *v*[2]) to denote the existence of an edge from vertex *v*[1] to *v*[2], where
    *v*[1], *v*[2] ∈ ![image](../images/math191-03.jpg) ∪ ![image](../images/math191-04.jpg)
    ∪ ![image](../images/math191-05.jpg). In other words, if it is the case that *f*(*v*[1],
    *v*[2]) is greater than 0, then *I*(*v*[1], *v*[2]) equals 1; otherwise, it is
    0\. (In fact, we could treat the *I*(*v*, *a*) function for edges from apps to
    API packages as another kind of weight function.) We use *n* to denote the number
    of malware samples and *m* to denote the number of goodware samples.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些怀疑评分函数都使用了指示函数 *I*(*v*[1], *v*[2]) 来表示从顶点 *v*[1] 到 *v*[2]* 的边的存在，其中 *v*[1],
    *v*[2] ∈ ![image](../images/math191-03.jpg) ∪ ![image](../images/math191-04.jpg)
    ∪ ![image](../images/math191-05.jpg)。换句话说，如果 *f*(*v*[1], *v*[2]) 大于 0，那么 *I*(*v*[1],
    *v*[2]) 等于 1；否则，它为 0。（事实上，我们可以将从应用到 API 包的边的 *I*(*v*, *a*) 函数视为另一种权重函数。）我们用 *n*
    来表示恶意样本的数量，用 *m* 来表示良性样本的数量。
- en: 'For example, according to the first function, *sus*[1], if the API package
    *a*[*j*] is called by 100 malicious apps *b* and 10 goodware apps *g* from our
    samples, we reasonably consider apps that invoke this API package to be more suspicious
    than ones that do not. The definition in *sus*[7] is another way of capturing
    the same intuition: that an API function that is more extensively called by malicious
    apps than by benign ones will have a higher suspicion score. Equations *sus*[7]
    through *sus*[12] make similar assumptions to *sus*[1] through *sus*[6] except
    that they evaluate the suspicion score of one API package with respect to all
    API packages rather than by itself.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，根据第一个函数 *sus*[1]，如果 API 包 *a*[*j*] 被 100 个恶意应用 *b* 和 10 个良性应用 *g* 调用，我们合理地认为调用该
    API 包的应用比没有调用的应用更具怀疑性。*sus*[7] 中的定义是另一种方式来捕捉相同的直觉：即一个 API 函数被恶意应用调用的次数远多于良性应用时，它的怀疑评分会更高。*sus*[7]
    到 *sus*[12] 的方程与 *sus*[1] 到 *sus*[6] 做出了类似的假设，不同之处在于它们评估的是某一个 API 包相对于所有 API 包的怀疑评分，而不仅仅是自身。
- en: '***The Suspicion Rank***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***怀疑排名***'
- en: Suspicion scores label a single Android API package call by looking at how malware
    and goodware each call that package. However, a package might itself make calls
    to other packages within the Android API. If a package *P*1 makes lots of calls
    to another package *Q* that has a high suspicion score, we should rank the first
    package as more suspicious than a package *P*2 that makes no calls to packages
    that have a high suspicion score.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 怀疑评分通过观察恶意软件和良性软件各自如何调用某个 Android API 包来标记单个 API 包调用。然而，一个包可能会自身调用 Android API
    内的其他包。如果一个包 *P*1 调用了另一个包 *Q* 并且 *Q* 的怀疑评分很高，我们应当将第一个包排名为比没有调用高怀疑评分包的包 *P*2 更具怀疑性。
- en: The situation is a bit like an individual making lots of calls to a drug dealer.
    Even if the individual isn’t deemed suspicious in their own right, the fact that
    they’re in regular contact with a drug dealer makes them so. This is precisely
    the intuition behind Google Search’s famous PageRank algorithm, which captures
    the importance of a web page by considering the importance of the web pages that
    link to it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况有点像某个人频繁联系毒贩。即便这个人本身并不被认为可疑，但由于他们与毒贩的频繁接触，便会被视为可疑。这正是 Google 搜索著名的 PageRank
    算法背后的直觉，它通过考虑链接到网页的其他网页的重要性来捕捉一个网页的重要性。
- en: 'In fact, we can combine our suspicion scores with PageRank to define a family
    of suspicion ranking functions that capture these intuitions. PageRank calculates
    the importance of web pages using the following formula:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以将怀疑评分与 PageRank 结合，定义一系列怀疑排名函数来捕捉这些直觉。PageRank 使用以下公式来计算网页的重要性：
- en: '![image](../images/math192-01.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/math192-01.jpg)'
- en: Here, *E* is the set of edges in the web; *N* is the total number of nodes,
    or vertices, in the web; *d* ∈ [0, 1], called the damping factor, is usually set
    to 0.85; and *out*(*u*) is the *out-degree* of node *u*, or the number of edges
    that leave it. The ![image](../images/math192-02.jpg) expression captures the
    probability that a user will reach web page *v* by explicitly entering its address
    into a browser, while the remaining part of the expression is intended to capture
    the probability of a user reaching page *v* by following links.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*E* 是网页中的边集；*N* 是网页中节点或顶点的总数；*d* ∈ [0, 1]，称为阻尼因子，通常设置为 0.85；*out*(*u*) 是节点
    *u* 的 *出度*，即离开该节点的边的数量。![image](../images/math192-02.jpg) 表达式捕捉了用户通过显式输入网页地址到浏览器来访问网页
    *v* 的概率，而表达式的其余部分旨在捕捉用户通过点击链接访问网页 *v* 的概率。
- en: 'In the following, we define the suspicion rank for an Android API package *a*
    with respect to a fixed suspicion scoring function, *sus*. We could use any of
    the functions described earlier in this chapter, or an entirely new one, as long
    as it associates a suspicion score with each function in the Android API:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下文中，我们定义了相对于固定的可疑评分函数 *sus*，Android API 包 *a* 的可疑排名。我们可以使用本章前面描述的任何函数，或者一个全新的函数，只要它将可疑分数与
    Android API 中的每个函数相关联：
- en: '![image](../images/math192-03.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/math192-03.jpg)'
- en: The parameter *δ* ∈ [0, 1] is a damping factor similar to PageRank’s *d*. In
    practice, we set it to 0.85, as is usually done with PageRank. The value *a*′
    is any package invoked by the package *a*, and the *out*(*a*′) value is the out-degree
    of the node in the TSG corresponding to *a*′. In other words, it represents the
    number of API packages invoked by *a*′.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 *δ* ∈ [0, 1] 是一个阻尼因子，类似于 PageRank 中的 *d*。在实际操作中，我们将其设置为 0.85，通常与 PageRank
    的做法一致。值 *a*′ 是任何由包 *a* 调用的包，*out*(*a*′) 值是与 *a*′ 对应的 TSG 中节点的出度。换句话说，它表示 *a*′
    调用的 API 包的数量。
- en: Readers might have noticed that the definition of the suspicion rank mainly
    relies on a small portion of the TSG—namely, the vertices representing API packages
    and the edges between them. As a result, this structure is independent of the
    choice of apps in the goodware and malware sets, and adversaries can’t manipulate
    it, because it (that is, the Android API) is publicly disclosed in the Android
    code and documentation. This approach differs from the function call graphs described
    in previous works, which usually depend on the sequence of operations within specific
    individual apps and so lack randomness, a key element in keeping malware developers
    guessing. We list some of these alternative approaches in “[Further Reading](ch06.xhtml#ch06lev8)”
    on [page 202](ch06.xhtml#ch06lev8).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能已经注意到，可疑排名的定义主要依赖于 TSG 的一小部分——即表示 API 包的顶点和它们之间的边缘。因此，这个结构独立于良性软件和恶意软件集合中应用程序的选择，攻击者无法操纵它，因为它（即
    Android API）在 Android 代码和文档中是公开的。这种方法与之前研究中描述的函数调用图不同，后者通常依赖于特定单个应用程序内的操作顺序，因此缺乏随机性，这是让恶意软件开发者无法猜测的关键元素。我们在“[进一步阅读](ch06.xhtml#ch06lev8)”中列出了这些替代方法，详见
    [第 202 页](ch06.xhtml#ch06lev8)。
- en: '***TSG Features***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***TSG 特征***'
- en: The preceding two sections define ways to calculate suspicion scores and suspicion
    ranks for API packages in a given TSG. In total, we have 24 kinds of suspicion-based
    scores associated with each API package. Researchers can add new ones if they
    wish. Next, we must use these suspicion-based scores to generate what we call
    *TSG features* for Android apps. These features capture the package call behavior
    of all apps, meaning an app doesn’t have to be in either the malware or the goodware
    sample set to have TSG features.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两节定义了如何计算给定 TSG 中 API 包的可疑分数和可疑排名。总的来说，我们为每个 API 包提供了 24 种基于可疑性的分数。研究人员可以根据需要添加新的分数。接下来，我们必须使用这些基于可疑性的分数为
    Android 应用程序生成我们所称的 *TSG 特征*。这些特征捕捉了所有应用程序的包调用行为，意味着一个应用程序不必出现在恶意软件或良性软件的样本集里才能拥有
    TSG 特征。
- en: To generate these features, we first rank the API packages in descending order
    according to their suspicion score and suspicion rank results. Theoretically,
    the higher the rank of an API package, the more suspicious it is. However, we
    will have noise, perhaps stemming from the choice of sample applications. Therefore,
    instead of directly using the ranked package list, we apply a window-based segmentation
    to it before deriving TSG features.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成这些特征，我们首先根据 API 包的可疑分数和可疑排名结果将它们按降序排列。理论上，API 包的排名越高，它就越可疑。然而，我们可能会遇到噪声，可能来源于样本应用程序的选择。因此，我们不是直接使用排名包列表，而是在得出
    TSG 特征之前对其应用基于窗口的分割。
- en: The basic idea of *window-based* segmentation is to use an integer *W* that
    is greater than 1 to segment the list into a number of buckets, starting from
    the beginning of the list. As shown in [Figure 6-2](ch06.xhtml#ch6fig2), each
    bucket (except possibly the last one) contains *W* API packages with similar suspicion-based
    scores or ranks.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 *窗口* 的分割的基本思路是使用一个大于 1 的整数 *W* 将列表分割成若干个桶，从列表的开头开始。如 [图 6-2](ch06.xhtml#ch6fig2)
    所示，每个桶（除了可能是最后一个桶）包含 *W* 个具有相似可疑分数或排名的 API 包。
- en: '![Image](../images/ch06fig02.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch06fig02.jpg)'
- en: '*Figure 6-2: A window-based API package ranking by descending suspicion scores
    and ranks*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：基于窗口的 API 包按降序的可疑分数和排名进行排序*'
- en: 'Suppose API packages *a*[1] through *a*[*W*] are in the same bucket, and suppose
    that the corresponding API feature values of an app are *f*[1] through *f*[*W*].
    For each bucket, we can calculate a TSG feature via one of the following six methods:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 假设API包*a*[1]到*a*[*W*]在同一桶中，且假设一个应用程序的对应API特征值是*f*[1]到*f*[*W*]。对于每个桶，我们可以通过以下六种方法之一计算一个TSG特征：
- en: '**Binary value** Does this app call any API packages in this bucket? If so,
    this binary feature is 1; otherwise, it is 0.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制值** 该应用程序是否调用该桶中的任何API包？如果是，这个二进制特征值为1；否则为0。'
- en: '**Number of API packages** How many API packages in this bucket does the app
    call? The feature value is an integer ![image](../images/math193-01.jpg), where
    the function *I*(*f*[*j*]) = 1 is *f*[*j*] > 0; otherwise, it equals 0.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**API包数量** 该应用程序调用了该桶中多少个API包？特征值是一个整数 ![image](../images/math193-01.jpg)，其中函数*I*(*f*[*j*])
    = 1当*f*[*j*] > 0时；否则为0。'
- en: '**Maximum frequency value** Of the call frequencies from the app to all API
    packages in the bucket, what is the maximum value? The feature value is an integer
    ![image](../images/math193-02.jpg).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**最大频率值** 该应用程序调用该桶中所有API包的频率中，最大值是多少？特征值是一个整数 ![image](../images/math193-02.jpg)。'
- en: '**Median frequency value** Among the call frequencies, what is the median value?
    The feature value is an integer median ![image](../images/math193-03.jpg).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**中位频率值** 在所有调用频率中，中位数值是多少？特征值是一个整数中位数 ![image](../images/math193-03.jpg)。'
- en: '**Sum of frequencies** How many times in total does this app call API packages
    in this bucket? The feature value is an integer ![image](../images/math193-04.jpg).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**频率和** 该应用程序总共调用了该桶中的多少个API包？特征值是一个整数 ![image](../images/math193-04.jpg)。'
- en: '**Weighted sum** Based on the frequency sum, what would the value be if we
    took the suspicion score given by function *ρ* as the corresponding weight? This
    feature is a real value ![image](../images/math193-05.jpg), where *ρ*[*j*] stands
    for the suspicion score of API package *a*[*j*].'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**加权和** 基于频率和，如果我们将函数*ρ*给出的疑似评分作为相应的权重，那么值将是多少？该特征是一个实数值 ![image](../images/math193-05.jpg)，其中*ρ*[*j*]表示API包*a*[*j*]的疑似评分。'
- en: To illustrate how these features work, consider the small dataset with three
    banking trojans and three goodware samples we showed earlier in this chapter.
    Suppose [Table 6-1](ch06.xhtml#ch6tab1) shows the frequency with which the malware
    sample Regon calls the four API packages.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些特征如何工作，考虑我们在本章前面展示的包含三个银行木马样本和三个良性软件样本的小数据集。假设[表6-1](ch06.xhtml#ch6tab1)显示了恶意软件样本Regon调用四个API包的频率。
- en: '**Table 6-1:** Frequency of API Package Calls by Regon'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-1：** 按地区统计的API包调用频率'
- en: '|  | ***android.view*** | ***java.net*** | ***android.app.admin*** | ***java.util***
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|  | ***android.view*** | ***java.net*** | ***android.app.admin*** | ***java.util***
    |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Frequency** | 35 | 0 | 1 | 112 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **频率** | 35 | 0 | 1 | 112 |'
- en: If we use *sus*[1] as our suspicion scoring function, we could sort the packages
    based on their suspicion scores, in descending order, as shown in [Table 6-2](ch06.xhtml#ch6tab2).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用*sus*[1]作为我们的疑似评分函数，我们可以根据它们的疑似评分按降序对软件包进行排序，如[表6-2](ch06.xhtml#ch6tab2)所示。
- en: '**Table 6-2:** Suspicion Scores of the Packages Called by Regon'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-2：** 按地区统计的API包疑似评分'
- en: '|  | ***android.app.admin*** | ***android.view*** | ***java.util*** | ***java.net***
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|  | ***android.app.admin*** | ***android.view*** | ***java.util*** | ***java.net***
    |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Suspicion score** | 1 | 0.5 | 0.5 | 0.25 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **疑似评分** | 1 | 0.5 | 0.5 | 0.25 |'
- en: 'Suppose we now use *W* = 2 as the window size. In this case, there are two
    buckets, the first containing *android.app.admin* and *android.view* and the second
    containing *java.util* and *java.net*. We derive the following feature values
    for Regon from the first bucket: a binary value of 1, an API package number of
    2, a sum of frequencies of 36, a maximum frequency value of 35, a median frequency
    value of 18, and a weighted sum of 1 × 1 + 0.5 × 35, or 18.5\. The values of the
    features generated by the second bucket are 1, 1, 112, 112, 56, and 56, respectively.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在使用*W* = 2作为窗口大小。在这种情况下，存在两个桶，第一个包含*android.app.admin*和*android.view*，第二个包含*java.util*和*java.net*。我们从第一个桶得出Regon的以下特征值：二进制值为1，API包数量为2，频率和为36，最大频率值为35，中位频率值为18，加权和为1
    × 1 + 0.5 × 35，即18.5。第二个桶生成的特征值分别为1，1，112，112，56和56。
- en: Now suppose we repeat this process using both the suspicion scoring function
    *sus*[1] and the suspicion ranking formula. [Table 6-3](ch06.xhtml#ch6tab3) shows
    the resulting suspicion ranks after sorting.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们使用疑似评分函数 *sus*[1] 和疑似排序公式重复此过程。[表 6-3](ch06.xhtml#ch6tab3) 显示了排序后的结果疑似排名。
- en: '**Table 6-3:** Suspicion Ranks for the Packages Called by Regon'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-3：** Regon 调用包的疑似排名'
- en: '|  | ***java.util*** | ***java.net*** | ***android.view*** | ***android.app.admin***
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  | ***java.util*** | ***java.net*** | ***android.view*** | ***android.app.admin***
    |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Suspicion rank** | 0.1025 | 0.0811 | 0.0375 | 0.0375 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **疑似排名** | 0.1025 | 0.0811 | 0.0375 | 0.0375 |'
- en: 'These suspicion ranks generate the following feature values for Regon from
    the first bucket: a binary value of 1, an API package number of 1, a sum of frequencies
    of 112, a maximum frequency of 112, a median frequency of 56, and a weighted sum
    of 0.1025 × 112 + 0.0811 × 0, or 11.48\. For the API calls in the second bucket,
    Regon has corresponding feature values 1, 2, 36, 35, 18, and 1.35.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些疑似排名为 Regon 从第一个桶生成以下特征值：二进制值 1，API 包数量 1，频率总和 112，最大频率 112，中位数频率 56，和加权总和
    0.1025 × 112 + 0.0811 × 0，结果为 11.48。对于第二个桶中的 API 调用，Regon 具有对应的特征值 1, 2, 36, 35,
    18 和 1.35。
- en: In this example, we generated TSG features for Regon based on a subset of Android
    API packages and a part of the complete TSG. In a real implementation, however,
    we might use all 171 API packages, 24 different suspicion scoring functions, and
    6 methods for computing TSG features for each function. As a result, if we use
    a *W* of 10, we could generate 2,592 TSG features for each app.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为 Regon 生成了基于一部分 Android API 包和完整 TSG 的一部分的 TSG 特征。然而，在实际实现中，我们可能会使用所有
    171 个 API 包、24 个不同的疑似评分函数，以及每个函数计算 TSG 特征的 6 种方法。因此，如果我们使用 *W* 为 10，我们可以为每个应用生成
    2,592 个 TSG 特征。
- en: 'In addition, because we control the *W* parameter, we can vary it in several
    ways. For instance, if we have four API packages with the suspicion scores 0.9,
    0.3, 0.29, and 0.2, we could divide them into two evenly sized buckets, (0.9,
    0.3) and (0.29, 0.2). Alternatively, we could group similar scores together by
    using a variable window size to segment them into two buckets, (0.9) and (0.3,
    0.29, 0.2). Using window size in this way has an advantage: it introduces yet
    another complication for the adversary. If an attacker changed the number of calls
    made in a piece of malware to classes in one or two Android API packages, it wouldn’t
    have a huge impact on how features were derived, because packages that have similar
    features would be merged, reducing the effects of any single feature. This varying
    window size could have the potential negative effect of lowering the predictive
    performance of the resulting classifiers, but it turns out, as subsequent chapters
    will show, that this is not a major problem.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们控制 *W* 参数，我们可以通过多种方式进行变化。例如，如果我们有四个 API 包，疑似评分分别为 0.9、0.3、0.29 和 0.2，我们可以将它们分成两个大小相等的桶，（0.9，0.3）和（0.29，0.2）。或者，我们可以使用可变窗口大小将相似的评分分组，并将它们分为两个桶，（0.9）和（0.3、0.29、0.2）。以这种方式使用窗口大小有一个优点：它为对手引入了另一个复杂因素。如果攻击者改变了恶意软件中调用的一个或两个
    Android API 包中的类的调用数量，那么对特征的推导影响不会很大，因为具有相似特征的包会被合并，减少了任何单一特征的影响。虽然这种变化的窗口大小可能会对生成分类器的预测性能产生负面影响，但事实证明，正如后续章节所示，这并不是一个大问题。
- en: 'To read more about the experiments that demonstrate the difficulty of bypassing
    these features, see “DBank: Predictive Behavioral Analysis of Recent Android Banking
    Trojans” by Chongyang Bai et al. and “Android Malware Detection via (Somewhat)
    Robust Irreversible Feature Transformations” by Qian Han et al.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于展示绕过这些特征困难的实验，请参阅 Chongyang Bai 等人的《DBank：最近 Android 银行木马的预测行为分析》和 Qian
    Han 等人的《通过（某种程度上）稳健的不可逆特征变换进行 Android 恶意软件检测》。
- en: '**Landmark-Based Features**'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基于地标的特征**'
- en: Another way to generate features for Android apps that attackers can’t easily
    evade relies on the concept of landmarks. Suppose you are considering buying a
    house. Your estimate of a fair price for the house will likely depend upon several
    factors, one of which might be the sales prices of certain other houses (for example,
    those of a similar size and age in the same area). We call these reference houses
    *landmarks*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种为 Android 应用生成攻击者难以规避的特征的方法是基于地标的概念。假设你正在考虑购买一套房子。你对房子的公平价格估计可能依赖于几个因素，其中之一可能是某些其他房子的销售价格（例如，同一区域内类似大小和年龄的房子）。我们将这些参考房子称为
    *地标*。
- en: We can adopt the idea of using landmarks to define a new feature space for Android
    apps. Say there is a set of Android apps that includes both benign and malicious
    apps, and that each app has some feature vector. We can think of that feature
    vector as a point in the app feature space, just as we could characterize a house
    as a point in a housing feature space. When considering buying a house, we compare
    the house with similar houses; we can do the same with apps when trying to determine
    whether they are malicious or benign.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用使用地标的思路为Android应用定义一个新的特征空间。假设有一组Android应用，其中包含良性应用和恶意应用，每个应用都有一些特征向量。我们可以将这些特征向量看作是应用特征空间中的一个点，就像我们可以将房子看作是房产特征空间中的一个点一样。在考虑购买房子时，我们会将目标房屋与类似的房屋进行比较；在判断应用是否恶意或良性时，我们也可以采取同样的方法。
- en: '***Selecting Landmarks***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***选择地标***'
- en: To use the landmark approach, we first select a subset of the app samples and
    set them as landmarks. Then we define new features for each app in the dataset
    by comparing them with each landmark. We suggest keeping the size of the landmark
    set reasonably small. For example, if there are 1 million samples in the total
    set of apps, we might select 1,000 landmarks. That way, adversaries will have
    trouble guessing the selected landmarks, making it even harder to guess the landmark-based
    features.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用地标法，我们首先选择一部分应用样本并将它们设置为地标。然后，通过将每个应用与地标进行比较，我们为数据集中的每个应用定义新的特征。我们建议将地标集合的大小保持在合理的小范围内。例如，如果应用的总样本数为100万个，我们可以选择1000个地标。这样，攻击者将很难猜测出所选的地标，从而更难以猜测基于地标的特征。
- en: We propose three methods for selecting the set of landmarks from the sample
    set. The first, a naive approach, is to randomly select them. Another method is
    *clustering-based selection*, in which the apps are first clustered into groups.
    There are many well-studied algorithms for clustering, such as *k*-means clustering,
    *k*-median clustering, mean shift clustering, density-based spatial clustering
    of applications with noise (DBSCAN), expectation maximization clustering using
    Gaussian mixture models, and agglomerative hierarchical clustering. Each clustering
    algorithm has its own advantages and disadvantages. They may also perform differently
    due to the characteristics of the dataset.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提出了三种从样本集中选择地标集合的方法。第一种是简单的方法，即随机选择地标。另一种方法是*基于聚类的选择*，即首先将应用进行聚类。聚类有许多成熟的算法，例如*k*均值聚类、*k*中位数聚类、均值漂移聚类、基于密度的空间聚类（DBSCAN）、使用高斯混合模型的期望最大化聚类以及凝聚层次聚类。每种聚类算法都有其优缺点。由于数据集的特点，它们的表现也可能有所不同。
- en: With this approach, after clustering the apps into groups, we select one app
    from each group as a landmark. The basic idea is that when we group all the apps
    into clusters, similar apps end up in the same cluster; we can then pick one representative
    app from each of the clusters. Returning to our housing analogy, the houses in
    a cluster might have similar neighborhoods, local schools, square footages, prices,
    and numbers of bedrooms. When deciding whether a house is good or not, we might
    use one representative from each cluster as a landmark. Once we have our clusters,
    we can select a representative from each group in many ways. For instance, we
    could randomly select an app from the cluster. Alternatively, we could compute
    the sum of the distances of each app in the cluster to each of the other apps
    in the cluster, then use the app that has the smallest sum—the most “central”
    app in the cluster—as the landmark. (The distance between two apps can be calculated
    by finding the distance between their feature vectors, using a metric such as
    Euclidean distance or cosine distance.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法后，经过对应用进行聚类，我们从每个聚类中选择一个应用作为地标。基本思路是，当我们将所有应用分成不同的聚类时，相似的应用会被分到同一个聚类中；然后，我们可以从每个聚类中选择一个代表性的应用。回到我们之前的房产类比，聚类中的房屋可能在邻里、当地学校、房屋面积、价格和卧室数量等方面具有相似性。在判断一栋房子是否合适时，我们可能会选择每个聚类中的一个代表性房屋作为地标。得到聚类后，我们可以通过多种方式从每个聚类中选择一个代表性应用。例如，我们可以从聚类中随机选择一个应用。或者，我们可以计算聚类中每个应用与其他应用之间的距离总和，然后选择距离总和最小的应用——即聚类中最“中心”的应用——作为地标。（两个应用之间的距离可以通过计算它们特征向量之间的距离来确定，使用如欧氏距离或余弦距离等度量方法。）
- en: Because there are at least 6 clustering algorithms we can use and at least 2
    ways of selecting a landmark app from each cluster, there are at least 12 ways
    of performing clustering-based landmark selection, even when disregarding the
    variability in hyperparameters that some of the clustering techniques use internally.
    In fact, there are many more ways of performing clustering-based landmark, e.g.
    by varying *k* in the *k*-means clustering and *k*-median clustering algorithms.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们可以使用至少6种聚类算法，并且每种聚类算法中至少有2种选择地标应用的方式，所以即使忽略某些聚类技术内部使用的超参数变化，基于聚类的地标选择也至少有12种方法。实际上，还有更多的基于聚类的地标选择方法，例如通过改变*k*来使用*k*-均值聚类和*k*-中位数聚类算法。
- en: 'The third method, *maximum distance heuristic selection*, provides an algorithm
    for selecting landmarks that are scattered across the basic feature space. As
    input, it accepts the set of apps *D* and the number of landmarks *N*[*L*] to
    select, as well as a distance function *d* used to evaluate the distance between
    two app samples based on their feature vectors. We might, for example, use well-known
    distance functions such as Euclidean distance, Manhattan distance, cosine distance,
    or Hamming distance. The algorithm is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法，*最大距离启发式选择*，提供了一种选择分散在基本特征空间中的地标的算法。作为输入，它接受应用集*D*和要选择的地标数量*N*[*L*]，以及用于评估基于特征向量的两个应用样本之间距离的距离函数*d*。例如，我们可以使用常见的距离函数，如欧几里得距离、曼哈顿距离、余弦距离或汉明距离。算法如下：
- en: '**The Max-Distance Heuristic Selection Algorithm**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**最大距离启发式选择算法**'
- en: Randomly select an app from *D* and add it to the landmark set *L*′.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机从*D*中选择一个应用并将其添加到地标集*L*′中。
- en: If *|L*′*|* < *N*[*L*], draw a random set of apps, *R*, from *D – L*′.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*|L*′*|* < *N*[*L*]，则从*D – L*′中抽取一组随机应用*R*。
- en: Choose the best landmark from *R* using one of the following methods:![Image](../images/math197-01.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方法从*R*中选择最佳地标：![Image](../images/math197-01.jpg)
- en: Add the selected landmark to *L*′.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选择的地标添加到*L*′中。
- en: When *|L*′*|* = *N*[*L*], use *L*′ as the set of landmarks *L*.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当*|L*′*|* = *N*[*L*]时，将*L*′作为地标集*L*。
- en: It starts by randomly choosing an app from *D* as a landmark and adding it to
    the current set of selected landmarks, *L*′ (step 1). It then iteratively adds
    more landmarks (steps 2 through 4). In each iteration, it randomly draws a set
    of apps from *D – L*′ (step 2), and then selects the app that is farthest away
    from the current set of landmarks in *L*′ (step 3).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 算法首先随机选择*D*中的一个应用作为地标，并将其添加到当前选择的地标集*L*′中（步骤1）。然后它通过迭代的方式添加更多的地标（步骤2到步骤4）。在每次迭代中，它从*D
    – L*′中随机抽取一组应用（步骤2），然后选择距离当前地标集*L*′中最远的应用（步骤3）。
- en: The distance can be calculated in various ways. For instance, suppose in a given
    iteration of the algorithm we have 3 landmarks, *ℓ*[1], *ℓ*[2], *ℓ*[3], and suppose
    *D – L*′ contains 100 landmarks, ![image](../images/math197-02.jpg). In this case,
    any one of the 100 landmarks may be added into *L*′ as a fourth landmark. We could
    choose to add the landmark ![image](../images/math197-03.jpg) that maximizes the
    distance from the candidate fourth landmark in *D – L*′ to the previously selected
    landmarks in *L*′, or in other words maximizes the sum ![image](../images/math197-04.jpg).
    Alternatively, we could choose the fourth landmark to be the one in *D – L*′ that
    maximizes either the mean distance or the median distance to the previously chosen
    landmarks *ℓ*[1], *ℓ*[2], *ℓ*[3], for example by choosing ![image](../images/math197-05.jpg).
    *d* in this algorithm is a distance function. We let *d*(*ℓ*, *r*) denote the
    distance between the feature vectors of two apps, *ℓ* and *r*. This step ensures
    that the landmark selected is sufficiently far away from the previously selected
    landmarks to ensure some diversity among the landmark set.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 距离可以通过多种方式计算。例如，假设在算法的某次迭代中我们有3个地标，*ℓ*[1]、*ℓ*[2]、*ℓ*[3]，并且假设*D – L*′包含100个地标，![image](../images/math197-02.jpg)。在这种情况下，100个地标中的任何一个都可以作为第四个地标添加到*L*′中。我们可以选择将地标![image](../images/math197-03.jpg)添加到*L*′中，它最大化了候选第四个地标在*D
    – L*′中的距离与*L*′中先前选择的地标之间的距离，或者换句话说，最大化了和![image](../images/math197-04.jpg)的和。或者，我们也可以选择*D
    – L*′中那个最大化与先前选择的地标*ℓ*[1]、*ℓ*[2]、*ℓ*[3]的平均距离或中位数距离的地标，例如选择![image](../images/math197-05.jpg)。在此算法中，*d*是一个距离函数。我们让*d*(*ℓ*,
    *r*)表示两个应用*ℓ*和*r*之间的特征向量的距离。这个步骤确保选择的地标距离先前选择的地标足够远，从而确保地标集的多样性。
- en: The process ends when *N*[*L*] landmarks have been picked (step 5). As there
    are 4 distance functions and 3 possible definitions of farthest distance, we can
    apply this landmark selection method in at least 12 ways.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程在选择了*N*[*L*]个地标后结束（步骤5）。由于有4个距离函数和3种可能的最远距离定义，我们至少可以通过12种方式应用此地标选择方法。
- en: Between the three landmark selection methods we’ve described, there are numerous
    ways to select the set *L* of landmarks from the set *D* for each *N*[*L*] value.
    However, to further confound potential adversaries, we suggest that security officers
    periodically use a new set of landmarks, modify the landmark selection method,
    or both, and then recompute landmark-based features. By doing this once every
    week or two, you’ll keep any adversaries guessing and mount a moving target defense.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们描述的三种地标选择方法之间，对于每个*N*[*L*]值，选择地标集合*L*的方式有很多种。然而，为了进一步迷惑潜在的对手，我们建议安全官员定期使用新的地标集，修改地标选择方法，或两者兼而有之，然后重新计算基于地标的特征。通过每周或每两周进行一次此类操作，您可以让对手始终感到困惑，从而形成移动目标防御。
- en: '***Computing Landmark-Based Features***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算基于地标的特征***'
- en: 'Once we’ve selected landmarks, we use them to compute landmark-based features
    for each app sample *i* in set *D*. Here is the algorithm for generating landmark-based
    features:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了地标，我们就使用它们为集合*D*中的每个应用程序样本*i*计算基于地标的特征。以下是生成基于地标的特征的算法：
- en: '**The Landmark-Based Feature Generation Algorithm**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于地标的特征生成算法**'
- en: Generate the set of landmarks *L* using S.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用S生成地标集合*L*。
- en: For each landmark *ℓ* ∈ in each sample app *i* ∈ *D*, compute *d*(*i*, *ℓ*).
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个地标*ℓ* ∈ 和每个样本应用程序*i* ∈ *D*，计算*d*(*i*，*ℓ*)。
- en: 'Compute the features as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特征计算如下：
- en: '![Image](../images/math198-01.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/math198-01.jpg)'
- en: As input, we use the set *D* of Android apps with their associated feature vectors
    ![image](../images/math198-02.jpg), the number *N*[*L*] of landmarks to select,
    the landmark-selection method S (and its parameters, if applicable), and the distance
    function *d*(·).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 输入为带有相关特征向量的Android应用程序集合*D* ![image](../images/math198-02.jpg)，要选择的地标数量*N*[*L*]，地标选择方法S（如适用，包含其参数）以及距离函数*d*(·)。
- en: We generate the set *L* of landmarks using S (step 1). Next, we iteratively
    compute the landmark feature vectors for each sample app *i* (steps 2 and 3).
    This process begins by computing the distance *d*(*i*, *ℓ*) of the sample *i*
    to each *ℓ* ∈, then constructing an *N*[*L*]*–*dimensional landmark-based feature
    vector by using those distances. In other words, the first element in this vector
    is the distance between app *i* and the first landmark, the second element in
    this vector is the distance between app *i* and the second landmark, and so forth.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用S生成地标集合*L*（步骤1）。接下来，我们迭代地为每个样本应用程序*i*计算地标特征向量（步骤2和步骤3）。这个过程从计算样本*i*到每个地标*ℓ*
    ∈ 的距离*d*(*i*，*ℓ*)开始，然后使用这些距离构建*N*[*L*]*维的基于地标的特征向量。换句话说，向量中的第一个元素是应用程序*i*与第一个地标之间的距离，第二个元素是应用程序*i*与第二个地标之间的距离，以此类推。
- en: '[Figure 6-3](ch06.xhtml#ch6fig3) is a simple illustration of landmark features.
    It assumes that there are six samples in our set *D* (in practice, this number
    would be much larger), each with a four-dimensional API feature vector.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](ch06.xhtml#ch6fig3)是一个基于地标特征的简单示意图。它假设我们的集合*D*中有六个样本（实际上，这个数量要大得多），每个样本都有一个四维的API特征向量。'
- en: '![Image](../images/ch06fig03.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch06fig03.jpg)'
- en: '*Figure 6-3: Landmark-based features with six apps, two landmarks, and the
    Euclidean distance function*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：具有六个应用程序、两个地标和欧几里得距离函数的基于地标的特征*'
- en: Suppose we use the random landmark generation method to select two of the six
    samples, Perfect Girls and Marcher, as landmarks. We then generate landmark features
    using the Euclidean distance function. Here, you can see the Euclidean distance
    from each sample app *i* to each landmark. The landmark-based feature vector for,
    say, Regon is then (3551.33, 677.93), while that for Perfect Girls is (0,2903.66).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用随机地标生成方法从六个样本中选择两个作为地标，分别是Perfect Girls和Marcher。然后，我们使用欧几里得距离函数生成地标特征。在这里，您可以看到每个样本应用程序*i*到每个地标的欧几里得距离。比如，Regon的基于地标的特征向量是（3551.33，677.93），而Perfect
    Girls的特征向量是（0，2903.66）。
- en: '**Feature Clustering**'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**特征聚类**'
- en: Some of the features we generate might have similar relationships to the label
    we’re attempting to predict. When this happens, we can combine those features
    to create a smaller, but perhaps more representative, set of new features. The
    approach, called *feature clustering*, first groups a set of basic features into
    a number of categories and then derives aggregated features from each category.
    We call these new features *FC features*. You can read more about this approach
    in “Android Malware Detection via (Somewhat) Robust Irreversible Feature Transformations”
    by Qian Han et al.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成的一些特征可能与我们试图预测的标签有相似的关系。当这种情况发生时，我们可以将这些特征结合起来，创建一个更小的，但可能更具代表性的特征集合。该方法称为*特征聚类*，首先将一组基本特征分成若干类别，然后从每个类别中推导出聚合特征。我们将这些新特征称为*FC特征*。你可以在Qian
    Han等人的《通过（某种程度上）强健的不可逆特征变换进行Android恶意软件检测》中了解更多关于此方法的内容。
- en: '***Generating Feature Clusters***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生成特征簇***'
- en: 'We use the following algorithm to get FC features:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下算法来获得FC特征：
- en: '**The FC Feature Generation Algorithm**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**FC特征生成算法**'
- en: Take a subset of samples *D*′ from *D*.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*D*中取出一个样本子集*D*′。
- en: Get the feature matrix *F*′ for samples in *D*′.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取*D*′中样本的特征矩阵*F*′。
- en: Using *Clu*, cluster the *n* basic features into *G* groups according to column
    vectors {*f*[*ij*]}*i*′ in *F*′.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Clu*将*n*个基本特征根据列向量{*f*[*ij*]}*i*′聚类成*G*组，结果存储在*F*′中。
- en: For each feature group *F*[*g*] in each sample app *i*, associate a value with
    the group:![Image](../images/math199-01.jpg)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个示例应用*i*中的每个特征组*F*[*g*]，将一个值与该组关联：![Image](../images/math199-01.jpg)
- en: 'Perform this calculation for each sample app:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个示例应用执行此计算：
- en: '![Image](../images/math199-02.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/math199-02.jpg)'
- en: As input, it takes the set *D* of all sample Android apps and each of their
    *n*–dimensional basic feature vectors; the number *G* of clusters in which to
    divide the *n* features; the clustering algorithm used, *Clu*; and ⊕, the algorithm
    to aggregate features within one group. We can use any subset or all of the basic
    static and dynamic analysis features we’ve presented, as well as features defined
    by other researchers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包括所有示例 Android 应用的集合*D*及其每个*n*维基本特征向量；要将*n*个特征分成的簇的数量*G*；所使用的聚类算法*Clu*；以及⊕，用于在一个组内聚合特征的算法。我们可以使用我们已展示的基本静态和动态分析特征的任意子集或全部特征，也可以使用其他研究人员定义的特征。
- en: 'We extract a subset *D*′ of sample apps from *D* (step 1) and use their feature
    values (step 2) to cluster the *n* features into *G* groups (step 3). We use a
    subset of *D*, not *D* itself, for three reasons: first, the dataset might be
    huge, and clustering the whole thing could be very expensive; second, by using
    a subset of samples for clustering, we make it harder for an adversary to determine
    how the feature clustering works; and third, when the set *D* is extended with
    the addition of more apps, we can compute the FC features of the new apps without
    having to rerun the algorithm and recluster basic features. Moreover, as in the
    case of TSGs, we can periodically update the sample used and recompute the feature
    clusters to keep adversaries guessing about the nature of the defenses used.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从*D*中提取一个示例应用子集*D*′（步骤1），并使用它们的特征值（步骤2）将*n*个特征聚类成*G*组（步骤3）。我们使用*D*的一个子集，而不是*D*本身，原因有三：首先，数据集可能非常庞大，聚类整个数据集可能代价高昂；其次，通过使用样本的子集进行聚类，我们使得攻击者更难判断特征聚类的方式；第三，当*D*集合通过添加更多应用程序进行扩展时，我们可以计算新应用程序的FC特征，而无需重新运行算法和重新聚类基本特征。此外，与TSGs的情况类似，我们可以定期更新所使用的样本，并重新计算特征聚类，以保持攻击者对所使用防御机制的猜测。
- en: Once we’ve clustered the features, we take any app and use ⊕ to associate a
    single value with each cluster of features (step 4). That value could be a sum,
    a minimum, or a maximum of the values of the features within that cluster, or
    it could be a statistical quantity derived from the set, such as the median, standard
    deviation, variance, or entropy. We perform this action for all clusters in every
    app in *D* (step 5).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们聚类了特征，我们将选取任何一个应用，并使用⊕将每个特征簇关联一个单一值（步骤4）。该值可以是该簇内特征值的和、最小值或最大值，或者可以是从该集群派生的统计量，如中位数、标准差、方差或熵。我们对*D*中每个应用的所有簇执行此操作（步骤5）。
- en: '***Choosing Clustering and Feature Aggregation Algorithms***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***选择聚类和特征聚合算法***'
- en: 'We can invoke the feature clustering algorithm with many possible clustering
    and feature aggregation methods. For the clustering algorithm, we might use any
    of the six methods we mentioned in our discussion of landmark-based features or
    an entirely different algorithm. We can also choose from numerous possibilities
    for the feature aggregation algorithm, ⊕. Here are some options:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用特征聚类算法，并选择多种可能的聚类和特征聚合方法。对于聚类算法，我们可能会使用我们在讨论基于地标的特征时提到的六种方法中的任何一种，或者选择完全不同的算法。对于特征聚合算法
    ⊕，我们也可以选择多种可能性。以下是一些选项：
- en: '**Product** We compute the new feature as the product of elements in the set.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**乘积** 我们将新特征计算为集合中元素的乘积。'
- en: '**Mean** We use the mean value of the set of values as the new feature value.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**均值** 我们使用该组值的均值作为新的特征值。'
- en: '**Median** We use the median value of the set of values as the new feature
    value.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**中位数** 我们使用该组值的中位数作为新的特征值。'
- en: '**Sum** We compute the new feature as the sum of elements in the set.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**和** 我们将新特征计算为集合中元素的总和。'
- en: '**Weighted sum** We compute the new feature value as the weighted sum of elements
    in the set. The weight of feature *j* is inversely proportional to the distance
    between the feature’s vector and the centroid feature value of the group *j*[*c*]’s
    vector {*fij*[*c*]}*i*′, which we denote as *d*(*j*, *j*[*c*]). Thus, we compute
    the feature value as follows, where *α* is a parameter for normalization:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**加权和** 我们将新特征值计算为集合中元素的加权和。特征 *j* 的权重与该特征向量与组 *j*[*c*] 的质心特征值 {*fij*[*c*]}*i*′
    的距离成反比，记为 *d*(*j*, *j*[*c*])。因此，我们通过以下方式计算特征值，其中 *α* 是归一化的参数：'
- en: '![image](../images/math200.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/math200.jpg)'
- en: We usually select a cluster size *G* that is significantly smaller than the
    total number of features so that this number decreases dramatically. For instance,
    if the basic feature vector had 100 elements, we might set *G* to 8\. [Figure
    6-4](ch06.xhtml#ch6fig4) illustrates an example of feature clustering that uses
    sample apps and four-dimensional API features.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常选择一个显著小于特征总数的聚类大小 *G*，这样这个数字会大幅减少。例如，如果基本特征向量有 100 个元素，我们可能将 *G* 设置为 8。[图
    6-4](ch06.xhtml#ch6fig4)展示了一个使用样本应用程序和四维 API 特征的特征聚类示例。
- en: '![Image](../images/ch06fig04.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/ch06fig04.jpg)'
- en: '*Figure 6-4: A feature clustering example with two groups, four-dimensional
    basic API features, and averaging feature aggregation*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：一个特征聚类示例，包含两个组、四维基本 API 特征和特征平均聚合*'
- en: In this example, we cluster the four apps into two groups and use the mean approach
    for ⊕. We obtain the FC features for each app shown in the table on the right.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将四个应用程序聚类为两组，并使用均值方法进行 ⊕。我们获得了每个应用程序的 FC 特征，见右侧表格。
- en: While highly representative, FC features are hard for adversaries to guess,
    since generating them requires security analysts to make several choices that
    inject considerable uncertainty into the process and are difficult to reverse
    engineer. These choices include the subset of sample apps to use, the number of
    clusters to generate, the clustering method and its hyper-parameters, and the
    aggregation operator ⊕ (along with its hyperparameters, when ⊕ calculates a weighted
    sum).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 FC 特征具有高度代表性，但它们很难被对手猜测，因为生成它们需要安全分析师做出多个选择，这些选择为过程引入了相当大的不确定性，并且很难逆向工程。这些选择包括要使用的样本应用程序子集、生成的聚类数目、聚类方法及其超参数，以及聚合操作符
    ⊕（当 ⊕ 计算加权和时，还包括其超参数）。
- en: '**Correlation Graph–Based Feature Transformation**'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基于相关图的特征转换**'
- en: Another way to reduce the number of features is to use correlation graphs, which
    generate what we call *CG features*. This approach involves creating a fully connected
    graph with features as its vertices, then using concepts from social network analysis
    to divide these features into communities. As each community consists of similar
    features, we can associate one CG feature with each.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种减少特征数的方法是使用相关图，我们称之为 *CG 特征*。这种方法涉及创建一个完全连接的图，将特征作为顶点，然后利用社交网络分析中的概念将这些特征划分为多个社区。由于每个社区包含相似的特征，我们可以将一个
    CG 特征与每个社区关联。
- en: 'We use the following algorithm to perform correlation graph–based feature transformation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下算法执行基于相关图的特征转换：
- en: '**The CG Feature Generation Algorithm**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**CG 特征生成算法**'
- en: Take a subset *D*′ of samples from *D*.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *D* 中取出样本的子集 *D*′。
- en: Get the feature matrix *F*′ for samples in *D*′.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取样本 *D*′ 的特征矩阵 *F*′。
- en: Compute the *n* × *n* edge weights of the correlation graph according to the
    column vectors of *F*′.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据*F*′的列向量，计算关联图的*n* × *n*边权重。
- en: Get *G* communities with the *n* basic features according to the correlation
    graph and the community detection algorithm.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据关联图和社区检测算法，获取具有*n*基本特征的*G*社区。
- en: For each feature community *C*[*g*] in each sample app *i*, apply the aggregation
    operator:![image](../images/math201-01.jpg)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个示例应用*I*中的每个特征社区*C*[*g*]，应用聚合运算符：![image](../images/math201-01.jpg)
- en: For each sample app *i*, calculate its CG feature vector:![image](../images/math201-02.jpg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个示例应用*I*，计算其CG特征向量：![image](../images/math201-02.jpg)
- en: As input, it takes the set of apps *D*, the feature matrix *F* of those apps,
    a community detection algorithm *C*, the desired number of communities *G*, and
    an associative and commutative operator ⊕. It outputs a correlation graph with
    *G*-dimensional feature vectors for sample apps in *D*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输入，它接受应用集*D*、这些应用的特征矩阵*F*、社区检测算法*C*、期望的社区数*G*、以及结合性和交换性的运算符⊕。它输出一个具有*G*维特征向量的关联图，表示应用集*D*中的每个示例应用。
- en: We begin by selecting a subset *D*’ of sample apps from *D* (step 1) and retrieving
    their feature matrix *F*’ (step 2), just as we did when calculating FC features.
    We then compute the *correlation* between each pair of features using the Pearson
    correlation coefficient (step 3). This value becomes the weight of the edge between
    each pair of features in the correlation graph. Next, we apply the community detection
    algorithm C (step 4) to produce *G* communities. Finally, we generate the CG features
    for each app *D* using the features in each community and the associative and
    commutative feature aggregation operator ⊕ (steps 5 and 6).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从*D*中选择一个子集*D*’（步骤1），并检索它们的特征矩阵*F*’（步骤2），就像我们计算FC特征时做的那样。然后，我们使用皮尔逊相关系数计算每对特征之间的*相关性*（步骤3）。这个值成为关联图中每对特征之间边的权重。接下来，我们应用社区检测算法C（步骤4）生成*G*个社区。最后，我们使用每个社区中的特征和结合性、交换性特征聚合运算符⊕（步骤5和6）生成每个应用的CG特征。
- en: We can define ⊕ in the same five ways as for feature clustering. In addition,
    we can select many possible community detection algorithms C, including the minimum
    cut method, the Girvan–Newman algorithm, modularity maximization, statistical
    interference, and clique-based methods. You can read more about these algorithms
    in the resources listed in the “Further Reading” section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像特征聚类一样，以相同的五种方式定义⊕。此外，我们可以选择许多可能的社区检测算法C，包括最小割法、Girvan-Newman算法、模块化最大化、统计推断和基于团体的方法。您可以在“进一步阅读”部分列出的资源中了解更多关于这些算法的信息。
- en: '[Figure 6-5](ch06.xhtml#ch6fig5) shows an example of generating correlation
    graph–based features. Suppose we want to group four API features into two communities,
    as shown on the left side of the figure. On the right side, you can see the CG
    features for each sample app created using the averaging feature aggregation method.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-5](ch06.xhtml#ch6fig5)展示了基于生成关联图特征的一个示例。假设我们希望将四个API特征分为两个社区，如图的左侧所示。在右侧，您可以看到使用平均特征聚合方法生成的每个示例应用的CG特征。'
- en: '![Image](../images/ch06fig05.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch06fig05.jpg)'
- en: '*Figure 6-5: Generating CG features with two communities and the averaging
    feature aggregation method*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：使用两个社区和平均特征聚合方法生成CG特征*'
- en: As with feature clustering, the use of CG features injects a great deal of uncertainty
    for any adversary attempting to reproduce the CG features. The CG feature generation
    process consists of many different choices that may end up yielding big differences
    in the final feature values. Adversaries will therefore have considerable difficulty
    in determining its real-world implementation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与特征聚类一样，使用CG特征为任何试图重现CG特征的对手注入了大量的不确定性。CG特征生成过程包含许多不同的选择，这些选择最终可能导致最终特征值的巨大差异。因此，对手将在确定其实际实现方面遇到相当大的困难。
- en: '**Further Reading**'
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: This section lists resources you can use to further explore the topics introduced
    in this chapter.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本节列出了您可以用来进一步探索本章介绍的主题的资源。
- en: 'To learn more about API-based features like the ones introduced in this chapter,
    see “DroidAPIMiner: Mining API-Level Features for Robust Malware Detection in
    Android” by Yousra Aafer et al. and “Machine Learning for Android Malware Detection
    Using Permission and API Calls” by Naser Peiravian and Xingquan Zhu.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章介绍的基于 API 的特征，参见 Yousra Aafer 等人的论文《DroidAPIMiner：挖掘 API 级特征用于 Android
    中稳健的恶意软件检测》和 Naser Peiravian 和 Xingquan Zhu 的论文《使用权限和 API 调用进行 Android 恶意软件检测的机器学习》。
- en: 'To read about TSG features, consult the paper that introduced them, “DBank:
    Predictive Behavioral Analysis of Recent Android Banking Trojans” by Chongyang
    Bai et al. In addition, we mentioned that TSGs are an alternative to the many
    kinds of function call graphs used in other malware detection techniques:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 TSG 特征，请查阅介绍它们的论文《DBank：近期 Android 银行木马的预测行为分析》，作者为 Chongyang Bai 等人。此外，我们提到过，TSG
    是多种恶意软件检测技术中使用的函数调用图的替代方案：
- en: Dependency graphs, introduced in “Semantics-Aware Android Malware Classification
    Using Weighted Contextual API Dependency Graphs” by Mu Zhang et al.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖图，首次提出于 Mu Zhang 等人的论文《基于语义的 Android 恶意软件分类：使用加权上下文 API 依赖图》中。
- en: 'Control-flow graphs, introduced in “FlowDroid: Precise Context, Flow, Field,
    Object-Sensitive and Lifecycle-Aware Taint Analysis for Android Apps” by Steven
    Arzt et al. and “MaMaDroid: Detecting Android Malware by Building Markov Chains
    of Behavioral Models” by Enrico Mariconti et al.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流图，首次提出于 Steven Arzt 等人的论文《FlowDroid：精确的上下文、流、字段、对象敏感和生命周期意识的污染分析用于 Android
    应用》以及 Enrico Mariconti 等人的论文《MaMaDroid：通过构建行为模型的马尔可夫链检测 Android 恶意软件》中。
- en: Code-property graphs, introduced in “Modeling and Discovering Vulnerabilities
    with Code Property Graphs” by Fabian Yamaguchi et al.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码属性图，首次提出于 Fabian Yamaguchi 等人的论文《通过代码属性图建模和发现漏洞》中。
- en: 'Generating the CG features introduced in this chapter requires the use of a
    community detection algorithm. There are many ways of defining such an algorithm:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 生成本章介绍的 CG 特征需要使用社区检测算法。有许多方法可以定义这样的算法：
- en: The minimum cut method, described in “Odd Minimum Cut-Sets and b-Matchings”
    by Manfred W. Padberg and M. Ram Rao
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小割方法，描述于 Manfred W. Padberg 和 M. Ram Rao 的论文《奇数最小割集和 b-匹配》中。
- en: Hierarchical clustering, described in “Hierarchical Clustering Schemes” by Stephen
    C. Johnson
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次聚类，描述于 Stephen C. Johnson 的论文《层次聚类方案》中。
- en: 'The Girvan–Newman algorithm, described in “Community Structure in Networks:
    Girvan–Newman Algorithm Improvement” by Ljiljana Despalatović et al.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Girvan–Newman 算法，描述于 Ljiljana Despalatović 等人的论文《网络中的社区结构：Girvan–Newman 算法改进》中。
- en: Modularity maximization, described in “Community Detection via Maximization
    of Modularity and Its Variants” by Mingming Chen et al.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化最大化，描述于 Mingming Chen 等人的论文《通过模块化最大化及其变体进行社区检测》中。
- en: Statistical inference, described in Kate Calder’s *Statistical Inference* (Holt,
    1953)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计推断，描述于 Kate Calder 的《统计推断》（Holt, 1953）。
- en: Clique-based methods, described in “A Maximal Clique Based Multiobjective Evolutionary
    Algorithm for Overlapping Community Detection” by Xuyun Wen et al.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于团体的方法，描述于 Xuyun Wen 等人的论文《一种基于最大团体的多目标进化算法用于重叠社区检测》中。
- en: '**Up Next**'
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**接下来**'
- en: Whenever antivirus products detect a piece of malware, the malware’s developers
    modify it in order to evade detection. By now, malware developers understand that
    antivirus companies are increasingly using machine learning. They’re also well
    aware of the types of basic features used to detect their malware and have become
    adept at modifying their code to change these features to escape detection.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 每当杀毒产品检测到恶意软件时，恶意软件的开发者就会修改它，以逃避检测。到目前为止，恶意软件开发者已经明白杀毒公司越来越多地使用机器学习技术。他们还很清楚检测恶意软件时使用的基本特征类型，并且已经熟练地修改代码来改变这些特征，从而逃避检测。
- en: 'In this chapter, we described how to use the manual processes of static and
    dynamic analysis introduced in [Chapters 3](ch03.xhtml) and [4](ch04.xhtml) to
    define features that machine learning algorithms can use. We then discussed two
    broad classes of techniques that can make life harder for malware developers.
    The first, based on the notion of a triadic suspicion graph, was initially used
    to detect Android banking trojans but can in fact be used to detect any form of
    malware. The second transforms the original features of Android apps into a new
    set of features of a different size. We described three such methods in this chapter:
    landmark-based transformations, feature clustering, and correlation graph–based
    feature transformation, all of which are resilient to reverse engineering.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们描述了如何使用在[第3章](ch03.xhtml)和[第4章](ch04.xhtml)中介绍的静态和动态分析手动过程，来定义机器学习算法可以使用的特征。然后，我们讨论了两类广泛的技术，这些技术可以使恶意软件开发者的工作更加困难。第一类基于三元怀疑图的概念，最初用于检测Android银行木马，但实际上可以用于检测任何形式的恶意软件。第二类则将Android应用的原始特征转化为一组不同大小的新特征。本章中我们介绍了三种此类方法：基于地标的转换、特征聚类和基于关联图的特征转换，这些方法都具有抵抗逆向工程的能力。
- en: However, no method is perfect at confounding hackers. To further frustrate malware
    developers, the techniques introduced in this chapter include layers of randomization.
    In addition, we recommend that organizations change their machine learning–based
    malware detection settings frequently, just as all users should change their passwords
    frequently. For instance, in the case of TSGs, defenders could update the malware
    and goodware samples used to generate their features and modify other parameters,
    such as the window size, every week. In the case of landmark-based features, defenders
    could periodically modify the number and identities of their landmarks. These
    modifications impose a relatively small cost on enterprise security officers but
    can reap substantial benefits.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有任何方法可以完美地困扰黑客。为了进一步让恶意软件开发者感到沮丧，本章介绍的技术包括了多层次的随机化。此外，我们建议组织频繁地更改其基于机器学习的恶意软件检测设置，就像所有用户应该频繁更改密码一样。例如，在TSG的情况下，防御者可以每周更新用于生成特征的恶意软件和良性软件样本，并修改其他参数，如窗口大小。在基于地标的特征的情况下，防御者可以定期修改其地标的数量和身份。这些修改对企业安全人员的成本相对较小，但可以带来可观的收益。
- en: 'In the next chapter, we’ll apply what you’ve learned so far about machine learning
    algorithms and features to look at one important class of malware: rooting malware.
    This type of malware attempts to acquire root privileges on the user’s device,
    and once it has done so, it can be hard to dislodge. As a consequence, it’s essential
    to find characteristics of rooting malware that distinguish it from goodware.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将应用到目前为止你所学到的机器学习算法和特征，来研究一种重要类别的恶意软件：Rooting恶意软件。这种恶意软件试图获取用户设备的Root权限，一旦获得，就很难被清除。因此，找到区分Rooting恶意软件和良性软件的特征至关重要。
- en: '[*OceanofPDF.com*](https://oceanofpdf.com)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[*OceanofPDF.com*](https://oceanofpdf.com)'
