- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4'
- en: CRYPTOGRAPHIC IMPLEMENTATIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密实现**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: In [Chapter 2](ch02.xhtml#ch02), I gave an overview of cryptographic algorithms,
    their parameters, and typical use cases. However, a mathematical algorithm is
    still a long way from the secure and efficient *implementations* of cryptography.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.xhtml#ch02)中，我概述了加密算法、它们的参数以及典型的应用场景。然而，数学算法离安全高效的*加密实现*还有很长的路要走。
- en: In the majority of applications, cryptography doesn’t play a leading role. It’s
    more like a necessary evil to protect device and business assets. Therefore, developers
    and product managers would love to have cryptographic implementations that run
    in no time, occupy no memory, and consume no energy. Of course, that’s not possible,
    but it’s a significant discussion point in many cases. Inefficient implementations
    might even lead to the elimination of security features, lower product quality,
    or at the very least, annoyed comments from colleagues who aren’t focused on security.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用中，加密并不起主导作用。它更像是保护设备和业务资产的必要“恶事”。因此，开发人员和产品经理都希望有能够快速运行、不占内存、不消耗能量的加密实现。当然，这是不可能的，但在很多情况下这是一个重要的讨论点。低效的实现可能会导致安全功能被排除、产品质量下降，或者至少让那些不专注于安全的同事产生抱怨。
- en: In this chapter, I’ll discuss the requirements for cryptographic implementations
    and selection options for developers. The following sections introduce examples
    of algorithmic optimizations for symmetric and asymmetric crypto. The final case
    study analyzes and discusses performance characteristics of crypto implementations
    in hardware and software on an STM32MP157F device.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将讨论加密实现的需求以及开发人员的选择选项。接下来的部分介绍了对称加密和非对称加密算法优化的示例。最后的案例研究分析并讨论了在 STM32MP157F
    设备上硬件和软件中加密实现的性能特征。
- en: '**Implementation Context and Requirements**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实现上下文和需求**'
- en: Developers choose the central microchip early in the product design and architecture
    development phases because many further decisions depend on it. The microchip
    might be a single-core microcontroller, a homogeneous or heterogeneous multicore
    system, a field-programmable gate array (FPGA), or even a system-on-chip (SoC)
    that combines processors, peripherals, and possibly FPGAs within a single package.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员在产品设计和架构开发的早期阶段选择中央微芯片，因为许多后续决策都依赖于此。该微芯片可能是单核微控制器、同质或异质多核系统、现场可编程门阵列（FPGA），甚至是将处理器、外设以及可能的FPGA整合到一个单一封装中的系统单芯片（SoC）。
- en: If a typical processor is selected, several parameters influence general performance,
    including crypto performance. These parameters start with the *instruction set
    architecture*, or *ISA* (for example, ARM, RISC-V, or MIPS), and the data width
    (8-bit, 16-bit, 32-bit, 64-bit, or even more). The number of cores and their maximum
    frequencies are also of significant relevance. Specifically for cryptographic
    operations, it’s interesting to see whether dedicated crypto instructions are
    available, like Intel’s AES New Instructions (AES-NI) extension, or whether the
    given chip comes with a crypto coprocessor.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择了典型的处理器，几个参数会影响其整体性能，包括加密性能。这些参数从*指令集架构*（ISA， 例如 ARM、RISC-V 或 MIPS）和数据宽度（8位、16位、32位、64位甚至更高）开始。核心数及其最大频率也非常重要。特别是在加密操作中，值得关注的是是否有专门的加密指令，比如英特尔的
    AES 新指令（AES-NI）扩展，或者给定的芯片是否配备加密协处理器。
- en: In systems intended for industrial, automotive, or datacenter applications,
    considering microchips that include an FPGA part might be interesting as a way
    of benefitting from the high-performance properties or the real-time guarantees
    digital hardware designs can provide. Besides the maximum supported frequency,
    FPGAs have specific characteristics like the number of lookup tables, flip-flops,
    blocks of random access memory (RAM), multipliers, and similar options that might
    set the limits for cryptographic implementations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工业、汽车或数据中心应用，考虑包括 FPGA 部件的微芯片可能是有趣的选择，因为它可以利用数字硬件设计所能提供的高性能属性或实时保证。除了最大支持频率，FPGA
    还有一些特性，比如查找表的数量、触发器、随机存取内存（RAM）块、乘法器等，这些特性可能会设置加密实现的限制。
- en: No matter which type of processing unit you choose, it requires internal and/or
    external memory. Usually, both volatile memory like RAM and nonvolatile memory
    like flash memory, memory cards, or solid-state drives (SSDs) are necessary. Besides
    their size, which affects cryptographic implementations on only very resource-constrained
    devices, their read and write speeds might influence the overall performance of
    a crypto application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 无论选择哪种类型的处理单元，都需要内部和/或外部内存。通常，需要易失性内存（如RAM）和非易失性内存（如闪存、存储卡或固态硬盘（SSD））。除了它们的大小（这只会在非常资源受限的设备上影响加密实现）之外，它们的读写速度可能会影响加密应用程序的整体性能。
- en: Last but not least, the transmission speed of wired and wireless interfaces
    of the device (for example, Wi-Fi, Bluetooth, Ethernet, and proprietary buses)
    limits the bandwidth for communication, including cryptographically protected
    channels.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，设备的有线和无线接口的传输速度（例如Wi-Fi、蓝牙、以太网和专有总线）限制了通信的带宽，包括加密保护通道。
- en: '**NOTE**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Sometimes in practice, the device and hardware architecture is already more
    or less fixed when cryptographic performance is discussed, and you have to make
    the best of it. However, don’t shy away from contributing crypto performance requirements
    at an early stage. For example, if your intended application requires thousands
    of signatures per second, that requirement definitely must be considered for hardware
    selection.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*在实际操作中，当讨论加密性能时，设备和硬件架构往往已经或多或少固定，你必须尽力做到最好。然而，不要害怕在早期阶段提出加密性能要求。例如，如果你的预期应用程序要求每秒处理数千个签名，那么这一要求必须在硬件选择时予以考虑。*'
- en: Looking at this problem from the application side, you might impose several
    types of requirements on crypto implementations. While *latency* describes the
    time of processing a single data block from input to output, *throughput* defines
    the amount of data that can be processed in a given time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用侧来看，你可能会对加密实现提出几种类型的需求。*延迟*描述从输入到输出处理单个数据块的时间，而*吞吐量*定义了在给定时间内可以处理的数据量。
- en: For software implementations on resource-constrained devices, it might be necessary
    to limit the static code size of the compiled binary that has to be stored in
    volatile and/or nonvolatile memory. Further, the dynamic memory usage during runtime
    can be a relevant factor. On the other hand, FPGA implementations have to statically
    instantiate digital components, which is why, in addition to performance, the
    efficiency of digital hardware designs for crypto are usually compared by the
    number of occupied FPGA resources.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于资源受限设备上的软件实现，可能需要限制编译后的二进制文件的静态代码大小，这些文件必须存储在易失性和/或非易失性内存中。此外，运行时的动态内存使用也是一个相关因素。另一方面，FPGA实现需要静态实例化数字组件，这也是为什么除了性能之外，数字硬件设计在加密领域的效率通常通过占用的FPGA资源数量进行比较的原因。
- en: As several IoT devices are battery-powered and some even rely on energy harvesting,
    the energy consumption of cryptographic implementations also can be a valid requirement.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一些物联网设备由电池供电，甚至有些依赖于能量收集，因此加密实现的能耗也可能成为一个有效的需求。
- en: All information about the implementation context of a device is relevant for
    solid and efficient crypto decisions. And in some cases, finding reasonable compromises
    between resource consumption and security might be necessary.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 设备实现上下文的所有信息对于做出稳健而高效的加密决策都是至关重要的。在某些情况下，在资源消耗和安全性之间找到合理的折衷可能是必要的。
- en: '**Selecting Crypto Implementations**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**选择加密实现**'
- en: We’ve seen many implementation issues over the past decades that have led to
    vulnerabilities. If you don’t want to have such valuable but exhausting experiences
    yourself, take a look at existing optimized and mature cryptographic libraries
    like OpenSSL, LibreTLS, Mbed TLS, and wolfSSL, just to name a few from the embedded
    system area.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几十年里，我们看到许多实现问题导致了漏洞。如果你不想自己经历这些宝贵但令人疲惫的经验，可以看看现有的优化和成熟的加密库，比如OpenSSL、LibreTLS、Mbed
    TLS和wolfSSL，仅举几例来自嵌入式系统领域的库。
- en: 'However, this issue leads us to a question many developers face during development:
    How do you choose a specific crypto library for a device or an application? The
    decision depends to a large extent on your specific requirements, if already explicitly
    stated, and the frameworks and programming languages you work with. The following
    list describes four typical situations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个问题引出了许多开发人员在开发过程中会面临的一个问题：如何为设备或应用选择特定的加密库？这个决定在很大程度上取决于您的具体需求（如果已经明确提出）以及您所使用的框架和编程语言。以下列表描述了四种典型情况：
- en: '**Freedom to choose**    Sometimes only the intended protection aim is stipulated—for
    example, that communication should be protected by authenticated encryption, without
    further details. This might be the case for a company-internal feature that has
    no external dependencies. In such situations, several cryptographic algorithms
    could be considered. For example, both AES-GCM and ChaCha20-Poly1305 might be
    suitable options. Performance evaluation on the target device makes sense in this
    scenario. Test both algorithms with a set of parameters and various crypto libraries
    to obtain a preferably efficient solution.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**自由选择**    有时仅规定了预期的保护目标——例如，通信应通过认证加密进行保护，而没有进一步的细节。这可能是公司内部功能的情况，且没有外部依赖。在这种情况下，可以考虑几种加密算法。例如，AES-GCM和ChaCha20-Poly1305可能都是合适的选择。在这种情况下，对目标设备进行性能评估是有意义的。使用一组参数和多个加密库测试两种算法，以获得一个尽可能高效的解决方案。'
- en: '**Strong performance requirements**    In some cases, cryptography is essential
    and has to fulfill high demands regarding performance—for example, if an application
    requires thousands of digital signatures per second. Since ECDSA is faster in
    signature generation than RSA, the algorithm should probably be ECC based. However,
    you still have to choose the type of curve. Testing a set of curves from available
    crypto libraries on the given hardware is the way to go when choosing the best-performing
    configuration. If your requirements can’t be reached, replacing the hardware or
    implementing a custom, optimized solution might be options.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**强大的性能要求**    在某些情况下，加密是必不可少的，并且必须满足高性能要求——例如，如果某个应用需要每秒生成数千个数字签名。由于ECDSA在签名生成上比RSA更快，因此该算法可能应该基于ECC。然而，您仍然需要选择曲线类型。在给定硬件上测试来自可用加密库的一组曲线是选择最佳性能配置的有效方式。如果您的要求无法实现，可能需要更换硬件或实现定制优化的解决方案。'
- en: '**Strong resource constraints**    Devices based on small microcontrollers
    are present in a large part of the IoT. However, those components usually exhibit
    significantly weaker performance characteristics compared to Linux-based devices.
    Although much state-of-the-art cryptography can be run on these processors, requirements
    regarding latency, throughput, number of connections to serve, and many more have
    to be selected carefully. Practical evaluations on the target hardware are essential.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**强大的资源限制**    基于小型微控制器的设备在物联网中占据了很大一部分。然而，这些组件通常表现出明显低于基于Linux的设备的性能特征。尽管许多先进的加密算法可以在这些处理器上运行，但关于延迟、吞吐量、服务连接数等要求必须仔细选择。对目标硬件的实际评估至关重要。'
- en: '**Fixed algorithm and security level**    If algorithm and key size are fixed
    in advance (for example, because of compatibility concerns), the scope is significantly
    reduced. However, if the specific implementation is not fixed, a quick performance
    comparison between libraries might still be valuable and unlock performance potential.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**固定算法和安全等级**    如果算法和密钥大小预先固定（例如，由于兼容性问题），则范围会大大缩小。然而，如果特定实现没有固定，那么对不同加密库进行快速性能比较仍然具有价值，并可能解锁性能潜力。'
- en: 'Even though this chapter has a strong focus on performance, latency and throughput
    are by far not the only quality characteristics to consider for cryptographic
    implementations. Especially for security applications, the following two properties
    can make a significant difference, even if they result in lower performance:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章重点讨论性能，但延迟和吞吐量远不是加密实现中唯一需要考虑的质量特性。特别是对于安全应用，以下两种特性可能会产生显著的区别，即使它们导致较低的性能：
- en: '**Transparency and clarity**    Readable, comprehensible, and documented code
    is wonderful. It reduces mistakes, assumptions, and misconceptions. Further, those
    properties lead to trustworthiness for the developers and their products. That
    is even truer for cryptographic implementations. Spaghetti code, optimization
    to the utmost degree that makes the code completely incomprehensible, and torn
    structures can be reasons to neglect implementations despite their outstanding
    performance.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**透明性和清晰性**  可读、易懂且有文档记录的代码是非常棒的。它减少了错误、假设和误解。此外，这些特性使得开发人员及其产品更加值得信任。对于加密实现来说，这一点尤为重要。即使性能出色，意大利面条式的代码、极端优化导致代码完全无法理解的情况，以及结构破碎，可能仍然会使人忽视实现的优点。'
- en: '**Support and maintenance**    Open source software has enabled the development
    of incredible projects. However, some projects are not well-documented nor supported.
    If vulnerabilities are found and reported, there might not be anyone to fix them
    right away. Of course, the same can be true for commercial and closed source software.
    The point is, you need to pay attention to how a specific library was maintained
    in the past and to any warning signs that might indicate loss of maintenance in
    the near future, especially for cryptographic libraries.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持与维护**  开源软件促进了不可思议的项目开发。然而，一些项目没有良好的文档记录和支持。如果发现并报告了漏洞，可能没有人能立即修复它们。当然，商业软件和闭源软件也可能存在同样的情况。关键是，你需要关注特定库过去是如何维护的，以及是否有任何警告信号表明该库在不久的将来可能会失去维护，特别是对于加密库。'
- en: '**WARNING**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Do not develop your own crypto implementations unless you have very good reasons
    to do so!*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*除非你有非常充分的理由，否则不要自行开发加密实现！*'
- en: Whatever crypto algorithm you select, issues might arise someday in the future
    because of quantum computing or new cryptanalytic successes. Therefore, it makes
    sense to follow the approach of *crypto agility*, which means that algorithms
    (for example, a block cipher) can easily be replaced by another one of the same
    type.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种加密算法，将来某一天由于量子计算或新的密码分析突破，可能会出现问题。因此，遵循*加密灵活性*的做法是有意义的，*加密灵活性*意味着算法（例如，分组密码）可以轻松地被另一种同类型算法替代。
- en: '**AES Implementation Options**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**AES实现选项**'
- en: In this section, I want to shed light on options to consider if you have to
    configure or analyze an AES implementation. AES is used as an example here, but
    since many other symmetric ciphers and hash functions also exhibit a round-based
    structure and similar operations, you might be able to translate these insights
    to other algorithms.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我想阐明在配置或分析AES实现时需要考虑的选项。这里以AES为例，但由于许多其他对称加密算法和哈希函数也具有基于轮次的结构和类似的操作，你也许能够将这些见解转化为其他算法。
- en: '***Basic Architecture***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基本架构***'
- en: A fundamental consideration is the operation width of processed data. In optimal
    software implementations, the width is chosen to utilize the data width of the
    underlying hardware. However, a mismatch can lead to issues. For instance, 8-bit
    implementations on 32-bit central processing units (CPUs) lack performance, and
    32-bit implementations on 8-bit CPUs might not compile or lead to inefficient
    transformations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的考虑因素是处理数据的操作宽度。在最优的软件实现中，宽度通常会选择与底层硬件的数据宽度相匹配。然而，宽度不匹配可能会导致问题。例如，在32位中央处理单元（CPU）上进行8位实现可能会缺乏性能，而在8位CPU上进行32位实现可能无法编译，或导致低效的转换。
- en: In FPGA implementations, the operation width of an implementation can be arbitrarily
    selected. If slower performance is acceptable and the focus is on using few resources,
    an 8-bit implementation is suitable. On the other hand, if high performance is
    required, we would probably like to operate at a 128-bit data width. If a *balanced*
    implementation (one with a reasonable trade-off between required resources and
    performance) is desired, a 32-bit architecture can be a solid choice.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在FPGA实现中，实施的操作宽度可以随意选择。如果可以接受较慢的性能，并且重点是使用较少的资源，那么8位实现是合适的。另一方面，如果需要高性能，我们可能会希望使用128位的数据宽度进行操作。如果希望获得*平衡的*实现（即在所需资源和性能之间取得合理的权衡），32位架构可能是一个可靠的选择。
- en: AES needs to expand a given key to a set of round keys. This key expansion can
    be performed once in the beginning to improve performance during bulk data encryption
    and decryption. However, the second option is to perform it on the fly, just before
    the corresponding round key is needed for operations. Advantages in dynamic memory
    consumption are gained because only a single round key has to be stored in memory
    instead of all round keys.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: AES 需要将给定的密钥扩展为一组轮密钥。可以在开始时进行一次密钥扩展，以提高批量数据加密和解密过程中的性能。另一种选择是在需要相应轮密钥进行操作时动态扩展。这样可以提高动态内存使用效率，因为只需要在内存中存储单个轮密钥，而不是所有轮密钥。
- en: 'For round-based algorithms like AES, implementing a loop structure to run through
    the necessary rounds seems natural. However, continuously handling and checking
    a loop variable reduces the maximum performance. Even if a comparison and a conditional
    branch don’t take seconds, they will impair overall throughput. The term *loop
    unrolling* describes an approach you might find in high-speed implementations:
    a loop is replaced by a sequence of code representing all AES rounds in order
    to achieve a performance boost at the expense of a larger binary size.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于轮次的算法，如 AES，使用循环结构运行必要的轮次似乎很自然。然而，不断处理和检查循环变量会降低最大性能。即使比较和条件分支不会花费几秒钟，它们也会损害整体吞吐量。术语*循环展开*描述了一种你可能在高速实现中看到的方法：用一系列代码替代循环，表示所有
    AES 轮次，以提高性能，但代价是增加了二进制文件的大小。
- en: '***Optimized Operations***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***优化操作***'
- en: The AES S-box is usually represented as a table that is meant to perform a nonlinear
    substitution. Therefore, it’s often implemented as a constant lookup table in
    software implementations. However, it isn’t the only option. If static tables
    don’t fit your requirements, you could generate the substitution tables dynamically
    in RAM. Also, for digital hardware designs, a Boolean circuit implementation known
    as a *Canright S-box* can be used.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: AES S-盒通常表示为一个表，用于执行非线性替代操作。因此，它通常作为常量查找表在软件实现中进行实现。然而，这并不是唯一的选择。如果静态表不适合你的需求，你可以在
    RAM 中动态生成替代表。另外，对于数字硬件设计，可以使用一种称为*Canright S-盒*的布尔电路实现。
- en: One of the most popular approaches to implementing AES in an optimized way combines
    the round operations `SubBytes()`, `ShiftRows()`, and `MixColumns()` to obtain
    a highly efficient sequence of four table lookups and four XOR operations per
    column per round, sometimes also known as the *T-tables* implementation. It requires
    four tables containing 256 4-byte words that add up to a memory requirement of
    4KB for encryption and decryption, respectively. Further optimizations can lower
    the required table memory to 1KB at the cost of three additional rotation operations
    per column per round.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 AES 的一种流行优化方法是将轮次操作 `SubBytes()`、`ShiftRows()` 和 `MixColumns()` 结合起来，以获得每轮每列四次表查找和四次
    XOR 操作的高效序列，这也被称为*T-表*实现。它需要四个表，每个表包含 256 个 4 字节的单词，加起来加密和解密分别需要 4KB 的内存。进一步的优化可以将所需的表内存减少到
    1KB，但代价是每列每轮增加三次旋转操作。
- en: '**NOTE**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Keeping these basic options in mind can help you estimate performance characteristics
    of given implementations, but it might also allow you to derive the implementation
    details of a given device when looking at its performance data.*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*牢记这些基本选项有助于你估算给定实现的性能特点，同时也可能在查看设备的性能数据时帮助你推导出其实现细节。*'
- en: Clearly, platforms offering dedicated instructions for AES acceleration or specific
    crypto coprocessors enable further performance optimizations. Some crypto libraries
    are already prepared to support these optimizations—for example, the popular AES-NI
    instructions. However, on embedded systems, it’s not unusual that you have to
    expend effort to utilize hardware acceleration in your application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，提供专用 AES 加速指令或特定加密协处理器的平台可以进一步优化性能。一些加密库已经准备好支持这些优化——例如，流行的 AES-NI 指令。然而，在嵌入式系统中，通常需要付出一些努力才能在应用程序中利用硬件加速。
- en: While performance gains are certainly the most common motivation for hardware
    crypto usage, in some cases it might also improve power consumption of your device
    or at least take some load off the main CPU.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然性能提升无疑是使用硬件加密的最常见动机，但在某些情况下，它也可能改善设备的功耗，或者至少减轻主 CPU 的负担。
- en: '**Implementation Characteristics of RSA and ECDSA**'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**RSA 和 ECDSA 的实现特点**'
- en: Implementations of asymmetric cryptography like RSA and ECDSA are different
    from those of symmetric cryptography. The asymmetric options don’t exhibit a round
    structure filled with a set of transformations, but instead build on mathematical
    problems that require arithmetic operations on large numbers. Therefore, real-world
    performance of these algorithms depends to a certain extent on the efficiency
    of *multiple-precision arithmetic*, also known as *bignum arithmetic*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 和 ECDSA 等非对称加密实现与对称加密实现不同。非对称加密算法不像对称加密那样具有一个填充变换集的循环结构，而是基于需要在大数上进行算术运算的数学问题。因此，这些算法在现实世界中的性能在一定程度上取决于
    *多精度算术*（也称为 *大数算术*）的效率。
- en: The first obstacle these libraries have to overcome is the simple fact that
    typical processors support 32-bit and 64-bit data operations, but RSA, for example,
    is based on integers with lengths of 2,048, 4,096, or even more bits. This problem
    can be solved by splitting those long numbers into an array of *limbs*, usually
    equal to the maximum data width of the CPU.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库需要克服的第一个障碍是一个简单的事实，即典型的处理器支持 32 位和 64 位数据操作，而 RSA 例如是基于 2,048 位、4,096 位甚至更多位长度的整数。这个问题可以通过将这些长整数拆分成一个
    *limb* 数组来解决，通常每个 *limb* 的大小与 CPU 的最大数据宽度相同。
- en: '***RSA Optimizations***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***RSA 优化***'
- en: 'While general bignum libraries support a comprehensive set of arithmetic operations
    on large numbers, cryptographic algorithms usually require only a small subset.
    As shown in [Chapter 2](ch02.xhtml#ch02), the main operation of RSA is the modular
    exponentiation—for example, for encryption and signature verification: *y* = *x^e*mod
    *n*. With a naive approach, performing this calculation on integers with thousands
    of bits wouldn’t be possible. Using the square-and-multiply algorithm enables
    this computation in the first place.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通用的大数库支持对大数字的全面算术操作，但加密算法通常只需要其中的一小部分。如 [第 2 章](ch02.xhtml#ch02) 所示，RSA 的主要操作是模幂运算——例如，用于加密和签名验证：*y*
    = *x^e*mod *n*。采用简单的方法，处理几千位的整数进行此计算几乎是不可能的。使用平方乘法算法使得这种计算成为可能。
- en: RSA has two cases to consider that have very different properties. First, the
    verification and encryption operations use the public exponent *e* = 65537 = (10000000000000001)[2],
    which leads to pretty high performance. The reason for this is that its length
    of 17 bits with a leading and a trailing 1 in binary representation leads to only
    16 squarings and a single multiplication operation based on the square-and-multiply
    algorithm. As you’ll see later in this chapter, this not only is drastically faster
    than the decryption and signing functions, which have to handle integers with
    the full key length of RSA, but also beats ECDSA verification speed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 有两个需要考虑的情况，它们具有非常不同的特性。首先，验证和加密操作使用公钥指数 *e* = 65537 = (10000000000000001)[2]，这使得性能相当高。原因在于它的
    17 位长度，二进制表示中有一个前导 1 和一个尾随 1，这导致根据平方乘法算法，只需要进行 16 次平方运算和一次乘法运算。正如你在本章稍后会看到的那样，这不仅比解密和签名功能（必须处理与
    RSA 完整密钥长度相同的整数）要快得多，而且还超过了 ECDSA 验证速度。
- en: RSA’s private-key operation can’t be optimized in the same way, but an approach
    called the *Chinese remainder theorem (CRT)* reduces runtime roughly by a factor
    of 4\. This is possible because CRT exploits that *n* = *pq*, which allows it
    to obtain the result of the exponentiation modulo *n* from two exponentiations,
    modulo *p* and modulo *q*, respectively. This leads to computational savings because
    *p* and *q* are only roughly half the size of *n*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 的私钥操作无法以相同的方式进行优化，但一种叫做 *中国剩余定理 (CRT)* 的方法将运行时间大约缩短了 4 倍。之所以能够实现，是因为 CRT
    利用了 *n* = *pq*，这使得它可以通过两个指数运算（分别对 *p* 和 *q* 取模）来获得 *n* 的指数运算结果。这种方法能够节省计算量，因为
    *p* 和 *q* 的大小大约是 *n* 的一半。
- en: An important aspect of the square-and-multiply algorithm for RSA performance
    is that its complexity has a cubic dependency on the bit lengths of the processed
    exponents. You can feel the painful effect of this relation when you migrate from
    2,048-bit RSA to a more future-proof 4,096-bit RSA, because the doubling in key
    length leads to a runtime increase by a factor of around 2³ = 8, which might just
    vaporize all your runtime requirements.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 性能的平方乘法算法中一个重要的方面是，其复杂度与处理的指数位长的立方成正比。当你从 2,048 位的 RSA 升级到更具未来性的 4,096 位
    RSA 时，你会明显感受到这一关系的痛苦效果，因为密钥长度翻倍会导致运行时间大约增加 2³ = 8 倍，这可能会吞噬你所有的运行时间需求。
- en: '***ECDSA Specifics***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ECDSA 细节***'
- en: Since ECDSA operates on elliptic curves that process significantly smaller numbers,
    the private-key operations are substantially faster than their RSA counterparts.
    However, different types of curves facilitate different implementations and optimizations.
    Although the choice of a suitable curve involves mathematical and trust considerations,
    performance should not be completely ignored in this process because considerable
    differences exist across all options.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ECDSA 基于椭圆曲线运算，这些曲线处理的数字显著较小，因此私钥操作比 RSA 对应的操作要快得多。然而，不同类型的曲线支持不同的实现和优化。虽然选择合适的曲线涉及到数学和信任的考量，但在这个过程中性能不应被完全忽视，因为不同选项之间存在相当大的差异。
- en: FPGA implementations and internal hardware to support asymmetric cryptography
    are much less common than for symmetric cryptography. You can find them in dedicated
    security ICs that, for example, provide authentication by digital signatures,
    as well as in SoC devices that support digital signature verification to protect
    their boot process. However, you usually won’t know a lot of details about these
    implementations, and you won’t have arbitrary access to their interfaces.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 相较于对称加密，支持非对称加密的 FPGA 实现和内部硬件要少得多。你可以在一些专用的安全集成电路（IC）中找到它们，这些 IC 例如可以提供通过数字签名进行身份验证，也可以在支持数字签名验证的
    SoC 设备中找到，以保护其启动过程。然而，通常你无法了解这些实现的太多细节，也无法任意访问它们的接口。
- en: '**Case Study: Crypto Performance on an STM32MP157F Device**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：STM32MP157F 设备上的加密性能**'
- en: In this case study, I explore the performance of a diverse set of symmetric
    and asymmetric cryptographic algorithms on an STM32MP157F device and discuss what
    you can learn from the results. Measuring performance with high accuracy is difficult
    for complex embedded systems that have feature-rich OSs. Therefore, all results
    should be regarded as ballpark figures.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例研究中，我探讨了在 STM32MP157F 设备上运行的多种对称和非对称加密算法的性能，并讨论了你能从这些结果中学到的东西。由于嵌入式系统通常配备功能丰富的操作系统，因此在这些系统上进行高精度的性能测量非常困难。因此，所有结果应视为大致数据。
- en: The SoC at hand is based on an ARM Cortex-A7 dual core running at up to 800
    MHz. It comes with two types of cryptographic coprocessors. The *CRYP1* core offers
    DES, Triple DES, and AES in different operation modes. The hashing module *HASH1*
    provides acceleration of SHA-1, MD5, SHA-224, SHA-256, and corresponding HMAC
    operations. Both run at approximately 266 MHz.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 手头的 SoC 基于一颗 ARM Cortex-A7 双核处理器，运行频率最高可达 800 MHz，配备了两种类型的加密协处理器。*CRYP1* 核心支持
    DES、Triple DES 和 AES 的不同操作模式。哈希模块 *HASH1* 提供 SHA-1、MD5、SHA-224、SHA-256 以及相应的 HMAC
    操作加速。这两者的运行频率大约是 266 MHz。
- en: In the following test cases, the OpenSSL command line tool is used to assess
    performance because it’s often available on Linux systems and its software implementations
    are already highly optimized and suitable for our task.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的测试案例中，使用 OpenSSL 命令行工具评估性能，因为它通常可以在 Linux 系统上使用，并且其软件实现已经高度优化，非常适合我们的任务。
- en: The call `openssl speed -elapsed -evp` algorithm-to-test is always used to run
    the tests. The `-elapsed` option defines that throughput is calculated on the
    basis of elapsed wall-clock time instead of CPU time spent in user space. The
    latter would distort the results, especially when using hardware support. The
    `-evp` flag stands for *envelope* and enables a generic high-level crypto interface
    that can use software as well as hardware implementations, depending on availability.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `openssl speed -elapsed -evp` 算法进行测试。`-elapsed` 选项定义了吞吐量是根据实际经过的墙钟时间计算的，而不是根据用户空间中的
    CPU 时间。后者会扭曲结果，特别是在使用硬件支持时。`-evp` 标志表示 *封装*，启用一个通用的高级加密接口，视硬件可用性，既可以使用软件实现，也可以使用硬件实现。
- en: 'The resulting console output always includes the compilation parameters as
    shown in [Listing 4-1](ch04.xhtml#ch04list01) and a list of test results in bytes
    per second for the following set of input data sizes: 16 bytes, 64 bytes, 256
    bytes, 1,024 bytes, 8,192 bytes, and 16,384 bytes.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 结果控制台输出始终包括如 [清单 4-1](ch04.xhtml#ch04list01) 所示的编译参数，以及以下一组输入数据大小的每秒字节数的测试结果：16
    字节、64 字节、256 字节、1,024 字节、8,192 字节和 16,384 字节。
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 4-1: The compiler parameters and metadata of the given OpenSSL tool*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-1：给定 OpenSSL 工具的编译参数和元数据*'
- en: For clarity and comprehensibility, the terminal outputs of all the tests are
    reduced to the main relevant numbers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰和易懂，所有测试的终端输出都简化为主要的相关数字。
- en: '***Parameter Choice for Symmetric Encryption***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***对称加密的参数选择***'
- en: Let’s consider a use case that requires confidentiality protection for sensor
    values that should be encrypted in chunks of 50KB. Say that your team members
    already selected AES as the block cipher, but the key size and the operation mode
    have not been fixed yet.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个用例，该用例要求对传感器值进行机密性保护，并且这些值应以 50KB 的块进行加密。假设你的团队成员已经选择了 AES 作为分组密码，但密钥大小和操作模式尚未确定。
- en: 'The first analysis compares the performance of AES in CTR mode with keys of
    128, 192, and 256 bits in order to get a feel for the numbers. [Listing 4-2](ch04.xhtml#ch04list02)
    shows the results obtained on an STM32MP157F device: the top line shows the size
    of the input data chunks, and the second line shows the throughput in kilobytes
    per second associated with that specific input data size.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次分析比较了 128、192 和 256 位密钥的 AES-CTR 模式的性能，以便对这些数字有一个直观的了解。[列表 4-2](ch04.xhtml#ch04list02)
    显示了在 STM32MP157F 设备上获得的结果：第一行显示了输入数据块的大小，第二行显示了与该特定输入数据大小相关的每秒千字节吞吐量。
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 4-2: The performance differences depending on the AES key size*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-2：根据 AES 密钥大小的性能差异*'
- en: The first general point you might notice is that throughput increases if the
    input data size rises. This is due to necessary overhead that loses relevance
    for larger input data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到的第一个一般性点是，当输入数据大小增加时，吞吐量也会增加。这是因为必要的开销对于较大的输入数据的相关性减小。
- en: For our example, the last column is the one of interest because we want to handle
    input data of around 50KB. There, we can see that AES-128-CTR achieves roughly
    22.9MBps, while AES-256-CTR reaches only 16.7MBps. This is a performance reduction
    of approximately 27 percent, or a processing-time increase of approximately 37
    percent. This makes absolute sense because AES-128 has to compute only 10 rounds,
    while AES-256 needs 14 rounds, and therefore 40 percent more. However, considering
    this relation in terms of security level, we gain 128 bits of security while investing
    approximately only 37 percent more performance. The upgrade could be worth it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，最后一列是我们关注的，因为我们需要处理大约 50KB 的输入数据。在那里，我们可以看到 AES-128-CTR 达到了大约 22.9MBps，而
    AES-256-CTR 仅达到了 16.7MBps。这是大约 27％ 的性能下降，或者大约 37％ 的处理时间增加。这是完全合理的，因为 AES-128 只需要计算
    10 轮，而 AES-256 需要 14 轮，因此需要多 40％。然而，从安全性角度来看，我们可以获得 128 位的安全性，同时仅投资大约 37％ 的性能。这次升级可能是值得的。
- en: The second interesting point is the operation mode’s influence on the performance.
    While CTR, CBC, and GCM mode differ in security, they also exhibit different performance
    characteristics. In [Listing 4-3](ch04.xhtml#ch04list03), you can see that CTR
    mode shows a performance of approximately 8 percent above CBC mode for larger
    input sizes, which might be a reason to choose CTR over CBC in many cases.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个有趣的点是操作模式对性能的影响。虽然 CTR、CBC 和 GCM 模式在安全性上有所不同，但它们的性能特点也不同。在[列表 4-3](ch04.xhtml#ch04list03)中，你可以看到
    CTR 模式在较大输入数据时比 CBC 模式的性能高大约 8％，这可能是许多情况下选择 CTR 而非 CBC 的原因。
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 4-3: The impact of the AES operation mode on encryption throughput*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-3：AES 操作模式对加密吞吐量的影响*'
- en: GCM provides authenticated encryption, which means that it yields not only ciphertext
    but also an authentication tag for integrity protection. The processing efforts
    for the latter lead to a performance decrease of approximately 28 percent. However,
    if you have to add a MAC generation algorithm to AES-CTR (for example, an HMAC-SHA-256),
    this would likely cost you more than 28 percent.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: GCM 提供认证加密，这意味着它不仅会生成密文，还会生成用于完整性保护的认证标签。后者的处理工作会导致大约 28％ 的性能下降。然而，如果你必须为 AES-CTR
    添加一个 MAC 生成算法（例如 HMAC-SHA-256），这可能会比 28％ 更加耗费性能。
- en: If security has a higher priority than throughput, going with AES-256-GCM would
    still result in a reasonable performance of 12.1MBps. However, if performance
    is your key feature, you can achieve the minimal security requirement of confidentiality
    protection with AES-128-CTR at almost twice the speed—namely, 22.9MBps.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安全性比吞吐量更重要，使用 AES-256-GCM 仍然能获得 12.1MBps 的合理性能。然而，如果性能是你的关键需求，你可以通过 AES-128-CTR
    达到最低的机密性保护要求，速度几乎是它的两倍——即 22.9MBps。
- en: At this point, you might remember that software implementations of the ChaCha
    stream cipher often outperform those of AES. And since you are probably the type
    of person who wants to bring your product to perfection, you should check whether
    the software at hand supports this algorithm, as shown in [Listing 4-4](ch04.xhtml#ch04list04).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会记得ChaCha流密码的软实现通常优于AES的实现。而且由于您可能是那种追求产品完美的人，您应该检查手头的软件是否支持该算法，如[清单4-4](ch04.xhtml#ch04list04)所示。
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 4-4: The availability of the ChaCha cipher in the given OpenSSL tool*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-4：给定OpenSSL工具中ChaCha密码算法的可用性*'
- en: Running speed tests on ChaCha20 and ChaCha20-Poly1305 yields the results shown
    in [Listing 4-5](ch04.xhtml#ch04list05).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对ChaCha20和ChaCha20-Poly1305进行速度测试，得到了如[清单4-5](ch04.xhtml#ch04list05)所示的结果。
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 4-5: The performance tests for the ChaCha20 and ChaCha20-Poly1305
    ciphers*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-5：ChaCha20和ChaCha20-Poly1305密码算法的性能测试*'
- en: If your team is willing to switch from AES to ChaCha20, it can get 256-bit security
    and authenticated encryption at data rates of 47.3MBps or more. Therefore, ChaCha20
    might be worth a second thought.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的团队愿意从AES切换到ChaCha20，它可以在数据速率达到47.3MBps或更高的情况下，获得256位安全性和认证加密。因此，ChaCha20可能值得重新考虑。
- en: '***Software vs. Hardware Implementation for SHA-256 Hashing***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SHA-256哈希的软硬件实现对比***'
- en: Imagine that your device generates logfiles split at 100MB and that you want
    to sign those files for integrity and authenticity protection before they leave
    the device. Since the input data size is relatively high, the performance of the
    signing operation is mainly determined by the hashing step and not the asymmetric
    signing at the end. Therefore, comparing the software implementation of SHA-256
    and the accelerator that comes with the *HASH1* hardware module of the STM32MP157F
    device might be worthwhile.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的设备生成的日志文件按100MB分割，且您希望在文件离开设备之前对其进行签名，以确保完整性和真实性保护。由于输入数据量相对较大，签名操作的性能主要取决于哈希步骤，而不是最后的非对称签名。因此，比较STM32MP157F设备上*HASH1*硬件模块的SHA-256软件实现与加速器的性能，可能是值得的。
- en: '[Listing 4-6](ch04.xhtml#ch04list06) shows all hash functions supported by
    hardware and available through their corresponding drivers.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单4-6](ch04.xhtml#ch04list06)展示了硬件支持的所有哈希函数，并通过其相应的驱动程序提供。'
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 4-6: The SHA algorithms supported by the STM32MP157F hardware*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-6：STM32MP157F硬件支持的SHA算法*'
- en: The hardware acceleration can be made available to the OpenSSL command line
    tool, by loading the `cryptodev` kernel module and then adding `-engine devcrypto`
    to the speed test parameters. [Listing 4-7](ch04.xhtml#ch04list07) shows the basic
    comparison between OpenSSL’s software implementation of SHA-256 and the hardware-supported
    operation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过加载`cryptodev`内核模块并将`-engine devcrypto`添加到速度测试参数中，使硬件加速可供OpenSSL命令行工具使用。[清单4-7](ch04.xhtml#ch04list07)展示了OpenSSL对SHA-256的软硬件实现基本对比。
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 4-7: A comparison of SHA-256 performance in software and hardware*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-7：SHA-256性能在软件和硬件中的对比*'
- en: For small input data like 16 bytes, the software solution outperforms the hardware
    by a factor of 22\. This occurs because the test data has to be moved from user
    space to kernel space to hardware and back, which comes with significant overhead.
    However, with increasing data size, this effect becomes increasingly irrelevant.
    It seems that the STM32MP157F hardware has performance advantages for input data
    of 8KB and larger.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像16字节这样的较小输入数据，软件解决方案的性能是硬件的22倍。这是因为测试数据必须从用户空间移动到内核空间，再到硬件并返回，这会带来显著的开销。然而，随着数据量的增加，这种效应变得越来越不相关。似乎对于8KB及更大的输入数据，STM32MP157F硬件在性能上有优势。
- en: '**NOTE**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Even if most hardware suppliers call their crypto modules “accelerators,”
    they aren’t guaranteed to accelerate anything. It might well be that the use of
    hardware even slows the crypto operations in your specific case. Make sure you
    test performance before you make a choice.*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*即使大多数硬件供应商将其加密模块称为“加速器”，也不能保证它们能加速任何操作。在您的特定情况下，使用硬件可能甚至会拖慢加密操作。在做出选择之前，请确保进行性能测试。*'
- en: The standard data sizes of the OpenSSL command line tool stop at 16KB, but for
    our specific use case, it would be interesting if even higher throughput rates
    could be achieved when hashing a 100MB file. The commands in [Listing 4-8](ch04.xhtml#ch04list08)
    add the options `-bytes 104857600` and `-seconds 60` to the calls to tell OpenSSL
    to use input chunks of 100MB and do the hashing for roughly one minute.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL命令行工具的标准数据大小上限为16KB，但对于我们的特定用例，如果在哈希100MB文件时能够实现更高的吞吐量，将会是非常有趣的。[清单4-8](ch04.xhtml#ch04list08)中的命令为调用添加了`-bytes
    104857600`和`-seconds 60`选项，告诉OpenSSL使用100MB的输入块并大约进行一分钟的哈希操作。
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 4-8: The performance analysis for hashing 100MB of data with SHA-256*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-8：使用SHA-256哈希100MB数据的性能分析*'
- en: The resulting numbers show that the software implementation doesn’t benefit
    from large input data, but the hardware implementation can enhance its throughput
    to about 68.0MBps.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数据显示，软件实现并未从大输入数据中获益，但硬件实现能够将吞吐量提高到约68.0MB每秒。
- en: Sanity checks are small steps that can reduce mistakes, misconceptions, and
    even vulnerabilities. I definitely recommend doing them when it comes to using
    hardware crypto.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查是减少错误、误解甚至漏洞的小步骤。在使用硬件加密时，我强烈推荐进行这些检查。
- en: First, I want to know whether the hardware is actually used or a software fallback
    steps in and sets me on the wrong track. Second, my confidence in the chosen solution
    would increase if the performance numbers given by the chip manufacturer somehow
    match my experimental data. [Listing 4-9](ch04.xhtml#ch04list09) shows a pragmatic
    way to answer those questions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我想知道硬件是否真正被使用，还是软件回退操作让我误入歧途。其次，如果芯片制造商提供的性能数据与我的实验数据相匹配，我对所选解决方案的信心将会增加。[清单4-9](ch04.xhtml#ch04list09)展示了回答这些问题的实用方法。
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 4-9: A sanity check for SHA-256 hardware hashing*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-9：SHA-256硬件哈希的健康检查*'
- en: 'The prefixed `time` command analyzes execution time of the subsequently called
    process in terms of three classes: elapsed wall-clock time (`real`), processing
    time spent in user space (`user`), and time used for process-specific kernel space
    operations (`sys`).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀`time`命令分析随后调用的进程的执行时间，并按三类划分：经过的挂钟时间（`real`），在用户空间花费的处理时间（`user`），以及用于特定进程的内核空间操作的时间（`sys`）。
- en: The software-only analysis took 1 minute and 1.79 seconds, of which 1 minute
    and 0.94 seconds were spent in user space and only 0.75 seconds were used for
    kernel operations. The “missing” 61.79 – 60.94 – 0.75 = 0.10 seconds can probably
    be attributed to the OS scheduling other processes or performing independent OS
    tasks.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 软件-only分析耗时1分钟1.79秒，其中1分钟0.94秒花费在用户空间，仅0.75秒用于内核操作。剩余的61.79 – 60.94 – 0.75 =
    0.10秒可能是由于操作系统调度其他进程或执行独立的操作系统任务所导致的。
- en: Looking at the hardware-assisted run, the situation looks completely different.
    The speed test lasted 1 minute and 2.26 seconds, but only 0.18 seconds are allotted
    to user-space computations and 2.08 seconds were spent in kernel space. Despite
    these low numbers, 39 blocks of 100MB input data were processed by SHA-256.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 查看硬件加速的运行情况，情况完全不同。速度测试持续了1分钟2.26秒，但仅有0.18秒分配给用户空间计算，2.08秒花费在内核空间。尽管这些数字较低，但SHA-256处理了39个100MB的输入数据块。
- en: 'The first conclusion is that 62.26 – 0.18 – 2.08 = 60.00 seconds aren’t represented
    in the results. Besides the previously mentioned scheduling and OS-related tasks,
    this amount of time also includes delays when waiting for hardware components
    to process and return data. In *Reference Manual RM0436* for STM32MP157F devices,
    ST explains that the processing time of one 512-bit intermediate block for SHA-256
    takes 66 cycles. Therefore, an estimation of the time required for pure hardware
    operations in this specific case can be calculated as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个结论是62.26 – 0.18 – 2.08 = 60.00秒没有出现在结果中。除了前面提到的调度和操作系统相关任务外，这部分时间还包括等待硬件组件处理并返回数据时的延迟。在STM32MP157F设备的*参考手册RM0436*中，ST解释了SHA-256的一个512位中间块的处理时间需要66个周期。因此，针对这一特定案例的纯硬件操作所需的时间估算如下：
- en: '![Image](../images/f081-01.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f081-01.jpg)'
- en: This number is at least in the right order of magnitude, but it still indicates
    that 60.00 – 15.82 = 44.18 seconds are “lost” in OS tasks, drivers, and further
    hardware processes like bus transfers. If performance is your utmost goal, profiling
    and optimizing driver implementations could be a next step.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字至少在数量级上是正确的，但它仍然表明 60.00 – 15.82 = 44.18 秒在操作系统任务、驱动程序和其他硬件过程（如总线传输）中“丢失”。如果性能是你的首要目标，分析和优化驱动程序实现可能是下一步。
- en: '***Comparison of Software Performance of Asymmetric Crypto***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***非对称加密软件性能比较***'
- en: Operations for asymmetric cryptography are computationally expensive. However,
    it’s important to get an idea of *how* costly they are and how the available options
    differ in performance.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密操作在计算上是非常昂贵的。然而，了解它们的成本有多高以及可用选项在性能上的差异非常重要。
- en: The first analysis outputs in [Listing 4-10](ch04.xhtml#ch04list010) show the
    significant impact of key lengths in RSA implementations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-10](ch04.xhtml#ch04list010) 中的第一次分析结果显示了 RSA 实现中密钥长度的显著影响。'
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 4-10: An RSA performance analysis with keys of 1,024, 2,048, and 4,096
    bits*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-10：带有 1,024、2,048 和 4,096 位密钥的 RSA 性能分析*'
- en: While the deprecated RSA-1024 completes almost 205 signatures per second on
    my STM32MP157F device, the state-of-the-art version with 2,048-bit keys yields
    only 35 signatures per second. By doubling the key length, we have to accept a
    performance drop by a factor of approximately 6\. Moving to the 4,096-bit variant
    leaves us with only five to six signatures per second, which means that the signing
    operation takes more than 178 milliseconds, although this device is already running
    at 800 MHz.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然过时的 RSA-1024 在我的 STM32MP157F 设备上每秒完成大约 205 个签名，但采用 2,048 位密钥的最新版本仅能完成每秒 35
    个签名。通过加倍密钥长度，我们必须接受性能下降大约 6 倍的结果。转向 4,096 位变种后，每秒只剩下五到六个签名，这意味着签名操作需要超过 178 毫秒，尽管该设备的运行频率已经达到
    800 MHz。
- en: On the other hand, clearly the signature verification, equivalent to the encryption
    operation, shows a drastically higher performance for all key sizes because it
    utilizes the short RSA public exponents.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，显然签名验证（等同于加密操作）在所有密钥长度下表现出明显更高的性能，因为它利用了短 RSA 公钥指数。
- en: When it comes to ECDSA, the OpenSSL tool provides a large set of curves. [Listing
    4-11](ch04.xhtml#ch04list011) gives a performance overview for some of the most
    popular NIST curves in use.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECDSA 方面，OpenSSL 工具提供了一套大规模的曲线。[列表 4-11](ch04.xhtml#ch04list011) 给出了使用中一些最流行的
    NIST 曲线的性能概述。
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 4-11: The signing and verification performance of selected NIST curves*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-11：选定 NIST 曲线的签名和验证性能*'
- en: We can instantly see that NIST curve P-256 is tremendously faster than the other
    curves because of its highly optimized structure and implementation. Further,
    ballpark estimations of performance cost factors (for example, for RSA) are hard
    to provide. Measuring a specific implementation on a specific platform is usually
    the way to go.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即看到，NIST 曲线 P-256 比其他曲线快得多，因为它的结构和实现经过高度优化。此外，性能成本因素（例如，对于 RSA）的粗略估计是很难提供的。通常，测量特定平台上的特定实现是最可行的方式。
- en: Regarding the comparison of ECDSA and RSA, NIST’s P-224 and RSA-2048, which
    have a similar security level, differ in signing performance by roughly a factor
    of 3 to the benefit of ECDSA. But in terms of verification speed, RSA-2048 is
    more than 11 times faster than the P-224 curve.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 ECDSA 和 RSA 的比较，NIST 的 P-224 和 RSA-2048 具有相似的安全级别，但在签名性能上有大约 3 倍的差异，ECDSA
    更有优势。然而，在验证速度方面，RSA-2048 比 P-224 曲线快了超过 11 倍。
- en: Finally, alternative elliptic curves are often considered because of trust issues
    with the NIST selection, but performance can also be a positive aspect, as presented
    in [Listing 4-12](ch04.xhtml#ch04list012).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，替代椭圆曲线通常由于对 NIST 选择的信任问题而被考虑，但性能也可以是一个积极的方面，如 [列表 4-12](ch04.xhtml#ch04list012)
    中所示。
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 4-12: Alternative elliptic curves with interesting performance*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-12：具有有趣性能的替代椭圆曲线*'
- en: The Brainpool curve P512t1 exhibits better performance than NIST P-521 for a
    similar level of security. Further, Bernstein’s Ed25519 (Curve25519) shows outstanding
    performance, even higher than that of NIST P-256.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Brainpool 曲线 P512t1 在与 NIST P-521 提供相似安全级别的情况下表现更好。此外，Bernstein 的 Ed25519（Curve25519）展现出卓越的性能，甚至超过了
    NIST P-256。
- en: Assuming you are free to choose an asymmetric signature algorithm for your application,
    Ed25519 would be a pretty interesting candidate from a performance point of view.
    If backward compatibility with RSA is a requirement, RSA-2048 might currently
    be a solid choice, but make sure that RSA-4096 is also feasible on your device
    to be prepared for future updates.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你可以自由选择适合你应用的非对称签名算法，从性能角度来看，Ed25519是一个非常有趣的候选算法。如果需要与RSA兼容，RSA-2048目前可能是一个稳妥的选择，但请确保你的设备也能支持RSA-4096，以便为未来的更新做好准备。
- en: '**Summary**'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Performance is not everything. However, when it comes to the implementation
    of cryptographic algorithms, it’s a property you should never neglect. In addition
    to security itself, performance is one of the fundamental quality characteristics
    of crypto.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 性能不是一切。然而，在加密算法的实现过程中，它是一个你绝对不应该忽视的属性。除了安全性本身，性能是加密技术的基本质量特性之一。
- en: Some embedded systems have strong restrictions regarding processing power, memory
    size, or power consumption, which makes optimized implementations a necessity.
    Otherwise, crypto might lose in a trade-off discussion. Other devices serve dedicated
    purposes in networking or data processing and require high-speed crypto implementations.
    Sometimes performance requirements can be met by the use of efficient software
    libraries, but other scenarios demand specific, digital hardware designs in FPGAs
    (which is an engineering field of its own) or hardware coprocessors built exactly
    for this task.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一些嵌入式系统在处理能力、内存大小或功耗方面有很大的限制，这使得优化的实现变得不可或缺。否则，加密可能在权衡讨论中处于劣势。其他设备则专门用于网络或数据处理，要求高速的加密实现。有时候，性能要求可以通过使用高效的软件库来满足，但在其他场景下，则需要专门的数字硬件设计，如FPGA（这本身是一个工程领域）或专为此任务设计的硬件协处理器。
- en: 'Be aware that even if your chosen crypto algorithms are secure from a mathematical
    point of view and exhibit nice performance characteristics, they’re not necessarily
    robust against implementation attacks like side-channel analysis and fault injection.
    *The Hardware Hacking Handbook* by Jasper van Woudenberg and Colin O’Flynn (No
    Starch Press, 2021) is full of practical examples and insights on how to break
    and secure crypto implementations. *Power Analysis Attacks: Revealing the Secrets
    of Smart Cards* by Stefan Mangard, Elisabeth Oswald, and Thomas Popp (Springer,
    2007) is also a classic for diving deeper into this field.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使你选择的加密算法从数学角度来看是安全的，并且展现出良好的性能特征，它们也不一定能抵御像侧信道分析和故障注入等实现攻击。Jasper van
    Woudenberg 和 Colin O'Flynn 的《*硬件破解手册*》（No Starch Press，2021年）充满了关于如何破解和保护加密实现的实用示例和见解。Stefan
    Mangard、Elisabeth Oswald 和 Thomas Popp 的《*电力分析攻击：揭示智能卡的秘密*》（Springer，2007年）也是深入研究这一领域的经典之作。
- en: Also, keep in mind that such advanced protection measures often come with a
    reduction in crypto performance. Make sure to determine as soon as possible in
    your development life cycle whether your product requires specifically hardened
    crypto implementations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，请记住，这些先进的保护措施往往伴随着加密性能的下降。在开发生命周期的早期，务必尽早确定你的产品是否需要特别加固的加密实现。
