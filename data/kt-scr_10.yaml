- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 7 SORTING AND SEARCHING
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7 排序与搜索
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/icon.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/icon.jpg)'
- en: One of the fundamental skills that any serious developer needs to learn is how
    to efficiently sort and search through a given dataset. This skill is invaluable
    for transforming raw data into actionable insights, whether you’re working with
    a simple array or with complex data structures spanning terabytes of multifield
    information extracted from the vast expanse of the internet.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每个严肃的开发者都需要掌握的基本技能之一就是如何高效地对给定的数据集进行排序和搜索。这项技能对于将原始数据转化为可操作的洞察非常宝贵，无论你是在处理简单的数组，还是在处理跨越数TB、多字段信息的复杂数据结构，这些数据可能来自互联网的广阔天地。
- en: Sorting and searching are a dynamic duo that work hand in hand. *Sorting* organizes
    data into a specific order, which enables meaningful analysis of the dataset as
    a whole. Once the data is sorted, it becomes easier to identify patterns, trends,
    and outliers. Sorting also improves the speed and ease of *searching* for desired
    items within the dataset, especially when working with large volumes of data.
    Indeed, many search algorithms, such as binary search, interpolation search, and
    tree-based searches, rely on the organization achieved through sorting. Searching
    further complements sorting by enabling targeted analysis, allowing for the quick
    location of specific data points or subsets within the dataset. Together, sorting
    and searching streamline data exploration, optimize retrieval efficiency, and
    empower decision-making processes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和搜索是相辅相成的强大组合。*排序*将数据按特定顺序组织，从而使整个数据集能够进行有意义的分析。一旦数据被排序，就更容易识别模式、趋势和异常值。排序还提高了在数据集中*搜索*所需项的速度和便利性，尤其是在处理大量数据时。实际上，许多搜索算法，如二分搜索、插值搜索和基于树的搜索，都依赖于排序所实现的组织结构。搜索进一步补充了排序，通过启用有针对性的分析，使得快速定位数据集中的特定数据点或子集成为可能。排序和搜索共同简化了数据探索，优化了检索效率，并增强了决策过程的能力。
- en: A wide array of sorting and search algorithms are available. In this chapter’s
    projects, we’ll focus on a selected group of algorithms that have broad applications
    in fields that require working with large datasets. By mastering these algorithms,
    you’ll be better equipped to tackle complex data challenges and make the most
    of sorting and searching capabilities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种排序和搜索算法可供选择。在本章的项目中，我们将专注于一组具有广泛应用的算法，特别是在需要处理大规模数据集的领域。通过掌握这些算法，你将更好地应对复杂的数据挑战，充分发挥排序和搜索的能力。
- en: Sorting Algorithms
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序算法
- en: Sorting algorithms allow us to rearrange a collection of data elements into
    a specific order, such as numerical or alphabetical or based on any other desired
    criteria. We can sort various types of data, including numbers, strings, records
    (lines of data in a database), and complex objects. Sorting is a fundamental building
    block for a variety of operations, such as merging, joining, and aggregating datasets.
    It paves the way for efficient data manipulation, which is crucial in domains
    like database management, algorithms, and programming. By organizing data structures,
    sorting provides a structured framework that promotes clarity, consistency, and
    ease of use. This streamlined approach enhances data management and maintenance,
    particularly in scenarios where data must be updated or modified frequently.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法允许我们将一组数据元素重新排列成特定的顺序，例如按数字、字母顺序或任何其他所需的标准进行排序。我们可以排序各种类型的数据，包括数字、字符串、记录（数据库中的数据行）以及复杂对象。排序是多种操作的基本构建块，如合并、连接和聚合数据集。它为高效的数据操作铺平道路，这在数据库管理、算法和编程等领域至关重要。通过组织数据结构，排序提供了一个有条理的框架，促进了清晰性、一致性和易用性。这种精简的方法提升了数据管理和维护，特别是在数据需要频繁更新或修改的场景中。
- en: Each sorting algorithm has its own advantages and disadvantages in terms of
    time complexity, space complexity, and stability. Before we get into specific
    algorithms, it’s important to review these concepts, as they’ll assist us in selecting
    the appropriate algorithm for a given problem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每种排序算法在时间复杂度、空间复杂度和稳定性方面都有各自的优缺点。在我们深入讨论具体算法之前，了解这些概念非常重要，因为它们将帮助我们为特定问题选择合适的算法。
- en: '*Time complexity* refers to the estimation of the algorithm’s running time
    based on the input size, which is denoted by *n*. It provides insight into how
    the algorithm’s performance scales with larger datasets. Common notations like
    *O*(1), *O*(log *n*), *O*(*n*), *O*(*n* log *n*), *O*(*n*²), and *O*(2*^n*) indicate
    different growth rates of time complexity in increasing order. The smaller the
    growth rate, the quicker the algorithm is in sorting a collection of data.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间复杂度*是指根据输入大小*n*来估计算法的运行时间。它提供了算法性能如何随数据集增大而变化的洞察。常见的表示法如 *O*(1)、*O*(log
    *n*)、*O*(*n*)、*O*(*n* log *n*)、*O*(*n*²) 和 *O*(2*^n*) 表示时间复杂度不同的增长速度，按递增顺序排列。增长率越小，算法在排序数据集合时的速度越快。'
- en: '*Space complexity*, on the other hand, describes the amount of additional memory
    an algorithm requires to perform the sorting operation, beyond the memory it needs
    to store the data being sorted. Some algorithms may operate with minimal extra
    space, where the swapping of data elements happens *in place*. Others may require
    significant auxiliary memory to perform sorting operations efficiently. This is
    also called *out-of-place* sorting, where full or partial copies of the original
    dataset are needed to carry out the sorting operation. The smaller the space complexity,
    the more efficient (and scalable) that algorithm is in terms of memory requirements.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*空间复杂度*则描述了算法在执行排序操作时所需的额外内存量，除了存储待排序数据的内存之外。有些算法可能只需最少的额外空间，数据元素的交换发生在*原地*。而另一些算法可能需要大量的辅助内存来有效地执行排序操作，这种方式也称为*非原地排序*，需要对原始数据集进行完整或部分复制来执行排序操作。空间复杂度越小，算法在内存需求方面就越高效（且更具可扩展性）。'
- en: '*Stability* is another important consideration. A sorting algorithm is stable
    if it maintains the relative order of elements with equal values. In certain situations,
    preserving the initial order of equal elements is required, and a stable algorithm
    becomes essential.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*稳定性*是另一个重要的考虑因素。一个排序算法是稳定的，如果它能保持具有相同值的元素的相对顺序。在某些情况下，保持相同元素的初始顺序是必要的，这时稳定的算法就变得至关重要。'
- en: '[Table 7-1](chapter7.xhtml#tab7-1) shows these properties for a selected group
    of sorting algorithms that we’ll discuss in this chapter.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-1](chapter7.xhtml#tab7-1) 展示了我们将在本章讨论的选定排序算法的这些特性。'
- en: 'Table 7-1: Key Features of Selected Sorting Algorithms'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1：选定排序算法的主要特性
- en: '| Algorithm | Time complexity |  | Space complexity | Stability |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 算法 | 时间复杂度 |  | 空间复杂度 | 稳定性 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Best | Average | Worst |  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 最佳 | 平均 | 最坏 |  |'
- en: '| --- | --- | --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Insertion sort | O(n) | O(n2) | O(n2) |  | O(1) | Stable |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 插入排序 | O(n) | O(n²) | O(n²) |  | O(1) | 稳定 |'
- en: '| Merge sort | O(n log n) | O(n log n) | O(n log n) |  | O(n) | Stable |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 归并排序 | O(n log n) | O(n log n) | O(n log n) |  | O(n) | 稳定 |'
- en: '| Quick sort | O(n log n) | O(n log n) | O(n2) |  | O(log n)* | Unstable |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 快速排序 | O(n log n) | O(n log n) | O(n²) |  | O(log n)* | 不稳定 |'
- en: '| Heap sort | O(n log n) | O(n log n) | O(n log n) |  | O(1) | Unstable |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 堆排序 | O(n log n) | O(n log n) | O(n log n) |  | O(1) | 不稳定 |'
- en: '| *The worst case can be O(n). |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| *最坏情况可以是 O(n)。 |'
- en: Of the sorting algorithms listed in [Table 7-1](chapter7.xhtml#tab7-1), insertion
    sort is the simplest and most intuitive, but it isn’t the most efficient in terms
    of average time complexity. It tends to be slower than the other algorithms for
    larger datasets. Due to this limitation, insertion sort generally isn’t used as
    a standalone algorithm, but rather as part of a hybrid sorting scheme that combines
    multiple methods, depending on the characteristics of the data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 7-1](chapter7.xhtml#tab7-1)列出的排序算法中，插入排序是最简单且最直观的，但在平均时间复杂度方面并不是最有效的。对于较大的数据集，它通常比其他算法慢。由于这一限制，插入排序通常不是作为独立的算法使用，而是作为混合排序方案的一部分，根据数据的特征结合多种方法。
- en: Both merge sort and heap sort have similar time complexities, typically *O*(*n*
    log *n*). However, heap sort has an advantage in terms of space complexity because
    it’s an in-place algorithm, meaning it requires minimal additional memory beyond
    the input array. On the other hand, merge sort requires additional space proportional
    to the input size. If stability is a desired property, then merge sort becomes
    the preferred choice over heap sort. It’s a stable sorting algorithm, ensuring
    that elements with equal values maintain their original order.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 合并排序和堆排序具有相似的时间复杂度，通常为*O*(*n* log *n*)。然而，堆排序在空间复杂度方面具有优势，因为它是一种就地排序算法，这意味着它除了输入数组外几乎不需要额外的内存。另一方面，合并排序需要与输入大小成比例的额外空间。如果稳定性是一个期望的属性，那么合并排序就比堆排序更受欢迎。它是一种稳定的排序算法，确保具有相同值的元素保持其原始顺序。
- en: In practice, quick sort often performs better than other sorting algorithms,
    except when the data is already sorted or nearly sorted. Quick sort benefits from
    lower space complexity, and it has smaller overhead, or fewer hidden operations
    that don’t depend on the size of the input data. Many programming language libraries
    provide built-in functions for quick sort, making it easily accessible and widely
    used.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，快速排序通常比其他排序算法表现更好，除非数据已经排序或接近排序。快速排序具有较低的空间复杂度，并且它的开销较小，或者说没有依赖于输入数据大小的隐藏操作。许多编程语言的库都提供了内置的快速排序函数，使其易于访问和广泛使用。
- en: 'Project 27: Space-Efficient Sorting with Insertion Sort'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 项目27：使用插入排序实现空间高效排序
- en: Insertion sort is a simple and intuitive sorting algorithm that works by building
    a sorted array one element at a time. The algorithm maintains a sorted subarray
    within the given array and extends it by inserting elements from the unsorted
    part of the array into the correct position in the sorted part. At the beginning,
    the first element of the array is considered to be a sorted subarray of size 1\.
    The algorithm then iterates through the remaining elements, one at a time, and
    inserts each element into its appropriate position within the sorted subarray.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序是一种简单直观的排序算法，它通过一次插入一个元素来构建一个已排序的数组。该算法在给定数组中保持一个已排序的子数组，并通过将未排序部分的元素插入已排序部分的正确位置来扩展它。开始时，数组的第一个元素被视为大小为1的已排序子数组。然后，算法逐个遍历剩余的元素，并将每个元素插入到已排序子数组中的适当位置。
- en: To insert an element, the algorithm compares it with the elements in the sorted
    subarray from right to left. It shifts any larger elements one position to the
    right until it finds the correct position for the current element. Once the correct
    position is found, the element is inserted into that position. This process continues
    until all the elements in the array are processed, resulting in a fully sorted
    array.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入一个元素，算法将其与已排序子数组中的元素从右到左进行比较。它将任何较大的元素右移一个位置，直到找到当前元素的正确位置。一旦找到正确位置，元素就被插入到该位置。这个过程持续进行，直到数组中的所有元素都被处理，从而得到一个完全排序的数组。
- en: 'Say we have the unsorted array [8, 3, 4, 5, 1, 2]. Here’s how the insertion
    sort algorithm would process it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个未排序的数组[8, 3, 4, 5, 1, 2]。下面是插入排序算法如何处理它的步骤：
- en: 1.  Imagine that the given array is made up of two subarrays—a sorted array,
    which initially holds only the first element (8), and an unsorted array made up
    of the remaining elements.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  假设给定的数组由两个子数组组成——一个已排序的数组，最初只包含第一个元素（8），另一个未排序的数组由剩余元素构成。
- en: '2.  Compare the second element of the array (index 1) with its preceding element
    (index 0) as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将数组的第二个元素（索引1）与其前一个元素（索引0）进行比较，如下所示：
- en: a.  Compare 3 with 8\. Since 3 is smaller, swap the elements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: a.  将3与8进行比较。由于3较小，交换元素。
- en: b.  The array after the first pass is [3, 8, 4, 5, 1, 2].
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: b.  第一次遍历后的数组是[3, 8, 4, 5, 1, 2]。
- en: 3.  Move to the next element (index 2) and compare it with the previous elements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  移动到下一个元素（索引2），并将其与前一个元素进行比较。
- en: a.  Compare 4 with 8\. Since 4 is smaller, swap the elements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: a.  将4与8进行比较。由于4较小，交换元素。
- en: b.  Compare 4 with 3\. Since 4 is greater, stop comparing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: b.  将4与3进行比较。由于4较大，停止比较。
- en: c.  The array after the second pass is [3, 4, 8, 5, 1, 2].
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: c.  第二次遍历后的数组是[3, 4, 8, 5, 1, 2]。
- en: '4.  Repeat this process for the remaining elements of the array. In the end,
    the array will be sorted in ascending order: [1, 2, 3, 4, 5, 8].'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  对数组中的剩余元素重复此过程。最后，数组将按升序排序：[1, 2, 3, 4, 5, 8]。
- en: As indicated in [Table 7-1](chapter7.xhtml#tab7-1), insertion sort has an average
    and worst-case time complexity of *O*(*n*²), where *n* is the number of elements
    in the array. However, it performs well for small lists or nearly sorted lists.
    It’s an in-place sorting algorithm with space complexity of *O*(1) for all cases,
    meaning it doesn’t require additional memory to perform the sorting.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如[表 7-1](chapter7.xhtml#tab7-1)所示，插入排序的平均和最坏情况时间复杂度为 *O*(*n*²)，其中 *n* 是数组中元素的个数。然而，它在处理小型列表或几乎已排序的列表时表现良好。它是一种就地排序算法，对于所有情况，空间复杂度为
    *O*(1)，这意味着它在执行排序时不需要额外的内存。
- en: The Code
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: Implementing the insertion sort algorithm in Kotlin takes only a few lines of
    code. We’ll create a dedicated function called insertionSort() to handle all the
    necessary steps for sorting an array and call this function from main() to get
    the job done.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中实现插入排序算法只需要几行代码。我们将创建一个名为 `insertionSort()` 的专用函数来处理排序数组所需的所有步骤，并从
    `main()` 函数中调用此函数来完成任务。
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code snippet implements the insertion sort algorithm to sort an array of
    numbers (in this case, integers) in ascending order. We create an array called
    arr that holds the initial unsorted array elements. The content of this array
    is printed to the console, allowing us to see the original order of the numbers.
    We then call the insertionSort() function to perform the sorting operation. It
    takes the array as input and modifies it in place, so you don’t have to return
    the sorted array to the calling function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实现了插入排序算法，用于按升序对一个数字数组（在此例中为整数）进行排序。我们创建了一个名为 `arr` 的数组，存储初始的未排序数组元素。该数组的内容将打印到控制台，使我们可以看到数字的原始顺序。然后，我们调用
    `insertionSort()` 函数来执行排序操作。它接受数组作为输入并就地修改它，因此您无需将排序后的数组返回给调用函数。
- en: 'Within the insertionSort() function, we iterate through the unsorted portion
    of the array by using a for loop ❶, starting from the second element (index 1)
    and continuing to the last element. For each element, we temporarily store the
    value in a variable called key. Next, we use a while loop ❷ to move from right
    to left through the sorted portion of the array, comparing key with each element.
    The while loop continues as long as two conditions are met: more elements remain
    to the left (checked using j > 0), and the current element is greater than key
    (checked using A[j-1] > key). Inside the while loop, if an element is greater
    than key, it’s shifted one position to the right. This makes space for key to
    be inserted at the correct sorted position.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `insertionSort()` 函数中，我们通过使用 `for` 循环 ❶ 遍历数组的未排序部分，从第二个元素（索引为 1）开始，一直到最后一个元素。对于每个元素，我们将其值临时存储在一个名为
    `key` 的变量中。接下来，我们使用 `while` 循环 ❷ 从右到左遍历数组的已排序部分，将 `key` 与每个元素进行比较。只要满足两个条件，`while`
    循环将继续：左边还有更多元素（使用 `j > 0` 检查），并且当前元素大于 `key`（使用 `A[j-1] > key` 检查）。在 `while` 循环内，如果某个元素大于
    `key`，它将向右移动一个位置。这样就为 `key` 的插入腾出了空间，使其能够插入到正确的排序位置。
- en: When the while loop ends, we assign the value of key to the current position
    in the array ❸, effectively inserting the element into the sorted portion of the
    array at the correct position. The for loop then moves to the next element, and
    the process repeats for all the elements in the array. Once the sorting is complete,
    the code prints the sorted array to the console, displaying the numbers in ascending
    order.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `while` 循环结束时，我们将 `key` 的值赋给数组中的当前位置 ❸，有效地将元素插入到数组已排序部分的正确位置。然后 `for` 循环移到下一个元素，并且这个过程会对数组中的所有元素重复进行。一旦排序完成，代码将排序后的数组打印到控制台，按升序显示数字。
- en: The Result
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'If you run the code without changing the given unsorted array, the output should
    look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在不更改给定的未排序数组的情况下运行代码，输出应如下所示：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code can easily be tweaked to sort floating-point numbers by assembling
    an array of either Float or Double data types. I encourage you to modify the code
    to accept user input regarding the preferred sorting order—either ascending or
    descending. After that, you can implement a suitable function based on the user’s
    choice. Alternatively, you can use the same function with two subfunctions, which
    can be implemented using when(choice), one for sorting an array in ascending order
    and one for doing the opposite.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以很容易地调整以对浮点数进行排序，只需将数组改为 `Float` 或 `Double` 数据类型。我鼓励你修改代码以接受用户输入，选择首选的排序顺序——升序或降序。之后，您可以根据用户的选择实现适当的函数。或者，您可以使用相同的函数，并结合两个子函数来实现，通过
    `when(choice)` 来判断一个用于升序排序数组，另一个用于降序排序。
- en: 'Project 28: Faster Sorting with Merge Sort'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 项目28：使用归并排序提高排序速度
- en: '*Merge sort* is a popular sorting algorithm that follows a divide-and-conquer
    approach. It works by recursively dividing an array into smaller subarrays until
    each subarray contains only one element. The subarrays are then merged back into
    longer arrays, placing the elements in the correct order in the process, eventually
    resulting in a fully sorted array. [Figure 7-1](chapter7.xhtml#fig7-1) illustrates
    this process for the same [8, 3, 4, 5, 1, 2] array we used in [Project 27](chapter7.xhtml#pre-27).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*归并排序*是一种流行的排序算法，它采用分治法。它通过递归地将一个数组划分为更小的子数组，直到每个子数组只包含一个元素。然后，这些子数组会被合并成更长的数组，在合并过程中将元素按正确的顺序放置，最终生成一个完全排序的数组。[图
    7-1](chapter7.xhtml#fig7-1)展示了我们在[项目27](chapter7.xhtml#pre-27)中使用的同一个[8, 3, 4,
    5, 1, 2]数组的过程。'
- en: '![](../images/Figure7-1.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-1.jpg)'
- en: 'Figure 7-1: Visualizing the merge sort algorithm'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：可视化归并排序算法
- en: Notice how the given array is initially divided into two subarrays, and then
    notice how each of those subarrays is further divided into two subarrays, and
    so on. The subarrays are then sorted and merged. When we implement the algorithm
    by using a recursive function, we’ll first process entirely the left subarray
    of the first pair of subarrays—in this example, [8, 3, 4]—before moving on to
    the right subarray, [5, 1, 2]. Within each branch, we’ll divide the subarrays
    into individual elements and then reassemble the sorted subarrays. Eventually,
    the final pair of sorted left and right subarrays will be merged to generate the
    final sorted array.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，给定的数组最初被划分为两个子数组，然后每个子数组会进一步被划分成两个子数组，以此类推。接着，子数组会被排序并合并。当我们通过递归函数实现该算法时，我们会首先完全处理第一对子数组中的左子数组——例如[8,
    3, 4]——然后再处理右子数组[5, 1, 2]。在每个分支内，我们会将子数组划分成单个元素，然后重新组合排序后的子数组。最终，最后一对已排序的左、右子数组将被合并，生成最终的排序数组。
- en: Merge sort guarantees a consistent time complexity of *O*(*n* log *n*) in all
    cases, making it efficient for large datasets. It’s also a stable sorting algorithm,
    preserving the relative order of equal elements. However, it needs additional
    space for the merging step, making its space complexity *O*(*n*). Nonetheless,
    merge sort’s efficiency and stability make it a popular choice for sorting in
    various applications.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序在所有情况下都能保证一致的时间复杂度 *O*(*n* log *n*)，使其在处理大数据集时非常高效。它还是一个稳定的排序算法，能够保持相等元素的相对顺序。然而，它在合并步骤中需要额外的空间，因此其空间复杂度为
    *O*(*n*)。尽管如此，归并排序的高效性和稳定性使它在各种应用中成为排序的热门选择。
- en: The Code
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'We’ll follow a similar structure for the merge sort code as we did for the
    insertion sort: a main() function that kicks off the sorting process by passing
    an array to a mergeSort() function. This time, however, mergeSort() will recursively
    call itself until it reaches a stopping condition (when each subarray has only
    one element). To put everything back together, we’ll use a helper function called
    merge(), which handles the task of sorting and merging the subarrays.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用类似于插入排序代码结构的方式来编写归并排序代码：通过传递一个数组到mergeSort()函数来启动排序过程的main()函数。然而，这一次，mergeSort()将递归调用自身，直到达到停止条件（每个子数组只包含一个元素）。为了将所有内容重新组合起来，我们将使用一个名为merge()的辅助函数，该函数负责排序和合并子数组。
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the main() function, we begin by initializing an array called arr with a
    set of integer values. We also print the given array before proceeding so that
    we’ll be able to compare this with the sorted array once it’s generated. We then
    call the mergeSort() function ❶, which is responsible for carrying out the sorting
    process. This function takes an array arr as an argument.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在main()函数中，我们首先初始化一个名为arr的数组，包含一组整数值。在继续操作之前，我们还会打印出给定的数组，这样在生成排序后的数组时，便于我们进行对比。然后，我们调用mergeSort()函数
    ❶，该函数负责执行排序过程。这个函数将数组arr作为参数。
- en: 'Within mergeSort(), we first check the length of the incoming array. If it’s
    less than 2, the subarray has a length of 1, so the function simply returns, and
    the splitting process stops. This is the all-important stopping condition that
    any recursive function needs. Next, we calculate the middle index of the array
    ❷ and create two subarrays: leftArray and rightArray. The former contains elements
    from index 0 up to but not including middle, while the latter contains elements
    from middle to the end of the array. To continue the process, the mergeSort()
    function recursively calls itself on both leftArray and rightArray ❸. As mentioned,
    this recursive step continues until the base case is reached—that is, when the
    length of the subarrays becomes 1. Finally, we call merge() to reassemble leftArray
    and rightArray into a single, sorted array.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 mergeSort() 中，我们首先检查传入数组的长度。如果长度小于 2，则子数组的长度为 1，函数直接返回，分割过程停止。这是任何递归函数所需的至关重要的停止条件。接下来，我们计算数组的中间索引
    ❷，并创建两个子数组：leftArray 和 rightArray。前者包含从索引 0 到但不包括中间的元素，后者包含从中间到数组末尾的元素。为了继续这个过程，mergeSort()
    函数会递归地调用自身处理 leftArray 和 rightArray ❸。如前所述，这个递归步骤会继续进行，直到达到基本情况——即子数组的长度变为 1。最后，我们调用
    merge() 将 leftArray 和 rightArray 重新组合成一个排序后的数组。
- en: The merge() function accepts three parameters, leftArray, rightArray, and arr,
    representing the two subarrays to be merged and the original array that will be
    modified during the merging process. We start the function by initializing variables
    to keep track of the indices within the arrays; i is for traversing the original
    arr, l for the leftArray, and r for the rightArray. The actual merging and sorting
    occur within a while loop ❹ that continues as long as elements remain in both
    leftArray and rightArray to compare. During each iteration, the function compares
    the values at indices l and r in leftArray and rightArray, respectively. If the
    value in leftArray is smaller, it’s assigned to arr at index i, and the l index
    is incremented. Conversely, if the value in rightArray is smaller, it’s assigned
    to arr at index i, and the r index is incremented. Following each assignment,
    the i index is also incremented ❺.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: merge() 函数接受三个参数：leftArray、rightArray 和 arr，分别表示要合并的两个子数组和在合并过程中会被修改的原始数组。我们通过初始化变量来跟踪数组中的索引；i
    用于遍历原始 arr，l 用于 leftArray，r 用于 rightArray。实际的合并和排序发生在一个 while 循环 ❹ 中，只要 leftArray
    和 rightArray 中仍然有元素可以比较，循环就会继续。在每次迭代中，函数会比较 leftArray 和 rightArray 中索引 l 和 r 处的值。如果
    leftArray 中的值更小，则将其赋值给 arr 中的索引 i，并且 l 索引递增。相反，如果 rightArray 中的值更小，则将其赋值给 arr
    中的索引 i，并且 r 索引递增。每次赋值后，i 索引也会递增 ❺。
- en: The while loop concludes when either leftArray or rightArray has been fully
    processed. The remaining elements from the nonempty array are then assigned to
    arr to complete the merging process. We use two separate while loops for this
    task—one for leftArray and one for rightArray. Only one of these loops will actually
    execute.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当左数组（leftArray）或右数组（rightArray）被完全处理时，while 循环结束。然后，将非空数组中的剩余元素分配到 arr 中，完成合并过程。我们为此任务使用了两个独立的
    while 循环——一个用于 leftArray，另一个用于 rightArray。只有其中一个循环会真正执行。
- en: The Result
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'When you run the merge sort code for the given input array, it should produce
    the following output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行给定输入数组的归并排序代码时，它应该输出以下结果：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I encourage you to repeat the same exercise you did with insertion sort, allowing
    the user to choose the order of sorting (ascending or descending) and then modifying
    the code to sort accordingly. I also recommend that you think about arrays containing
    both positive and negative numbers. You might soon realize that by selectively
    multiplying the entire array by –1 before and after sorting, you can use the same
    code to sort an array in ascending or descending order instead of writing two
    separate functions!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你重复你在插入排序时做的练习，让用户选择排序的顺序（升序或降序），然后修改代码以相应地排序。我还建议你考虑包含正数和负数的数组。你可能很快会意识到，通过在排序前后有选择性地将整个数组乘以
    -1，你可以使用相同的代码对数组进行升序或降序排序，而无需编写两个独立的函数！
- en: 'Project 29: High-Efficiency Sorting with Quick Sort'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 29：使用快速排序进行高效排序
- en: '*Quick sort* is a well-known and highly efficient in-place sorting algorithm
    that’s widely used in various real-world applications. It involves selecting a
    pivot element from the array and dividing the remaining elements into two subarrays,
    one for values less than the pivot and the other for values greater than the pivot.
    This mechanism places the pivot element itself in the correct position in the
    final sorted array, while the remaining elements end up on the appropriate side
    of the pivot. The process repeats recursively for the subarrays, selecting new
    pivot elements and further portioning the array, until everything is sorted.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*快速排序*是一种著名且高效的原地排序算法，广泛应用于各种现实世界的应用中。它涉及从数组中选择一个基准元素，并将剩余的元素划分为两个子数组，一个包含小于基准元素的值，另一个包含大于基准元素的值。这个机制将基准元素本身放置在最终排序数组的正确位置，而剩余的元素则落在基准元素的相应一侧。该过程会递归地应用于子数组，选择新的基准元素并进一步划分数组，直到所有元素排序完毕。'
- en: 'Here’s a step-by-step example of how quick sort works, using the array [8,
    3, 4, 5, 1, 2]:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是快速排序如何工作的逐步示例，使用数组[8, 3, 4, 5, 1, 2]：
- en: 1.  Choose a pivot element, which can be any element from the array. In this
    example, we’ll choose the last element, 2.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  选择一个基准元素，可以是数组中的任何元素。在这个例子中，我们选择最后一个元素，2。
- en: 2.  Partition the array into two subarrays, the left subarray with elements
    less than the pivot and the right subarray with elements greater than the pivot.
    In this case, the left subarray becomes [1], and the right becomes [4, 5, 8, 3].
    I’ll explain where this order comes from later in the project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将数组划分为两个子数组，左子数组包含小于基准元素的元素，右子数组包含大于基准元素的元素。在这个例子中，左子数组变为[1]，右子数组变为[4, 5,
    8, 3]。我将在项目后续部分解释这个顺序的来源。
- en: '3.  Recursively apply quick sort to the subarrays. For the left subarray, no
    further action is needed: it has only one element, so it’s already in its final
    position. For the right subarray, we now pick 3 as the pivot. This creates an
    empty left subarray as 3 is the smallest number. The right subarray now has [5,
    8, 4].'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  递归地对子数组应用快速排序。对于左子数组，不需要进一步操作：它只有一个元素，因此已经处于最终位置。对于右子数组，我们现在选择3作为基准元素。这将产生一个空的左子数组，因为3是最小的数字。右子数组现在为[5,
    8, 4]。
- en: 4.  Repeat step 3 until all subarrays are sorted, meaning each subarray has
    only one element or is empty.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  重复第3步，直到所有子数组都已排序，即每个子数组只有一个元素或为空。
- en: '5.  Combine the sorted subarrays to get the final sorted array: [1, 2, 3, 4,
    5, 8].'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  将已排序的子数组合并，得到最终的排序数组：[1, 2, 3, 4, 5, 8]。
- en: 'In this example, we always chose the last element of the array or subarray
    as the pivot element. Another option could have been to choose the first element
    as the pivot. For a wide range of inputs, choosing the first or last element as
    the pivot will work well, especially if the input data is randomly or uniformly
    distributed. However, if the array is already sorted or nearly sorted, pivoting
    around the first or last element will yield the worst-case time complexity of
    *O*(*n*²). To avoid this, you can use one of the following alternative techniques
    for choosing a pivot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们总是选择数组或子数组的最后一个元素作为基准元素。另一种选择是选择第一个元素作为基准元素。对于广泛的输入，选择第一个或最后一个元素作为基准通常表现良好，尤其是在输入数据是随机分布或均匀分布的情况下。然而，如果数组已经排序好或几乎排序好，基于第一个或最后一个元素的选择将导致最坏情况的时间复杂度为*O*(*n*²)。为了避免这种情况，你可以使用以下替代技术来选择基准元素：
- en: '**Choose a random element**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择一个随机元素**'
- en: Randomly selecting a pivot element helps mitigate the inefficiency of choosing
    the first or the last element when the array is already mostly sorted. This approach
    can provide a good average-case performance since the pivot’s position is less
    predictable. It reduces the likelihood of encountering worst-case scenarios, resulting
    in better overall efficiency.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随机选择基准元素有助于减少选择第一个或最后一个元素时的低效，尤其是当数组已经大部分排序时。这种方法可以提供良好的平均情况性能，因为基准元素的位置较难预测。它减少了遇到最坏情况的可能性，从而提高了整体效率。
- en: '**Choose the median of three**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择三数中的中值**'
- en: This strategy involves using the median value among the first, middle, and last
    elements of the array as the pivot. This approach aims to balance the pivot selection
    by choosing a value closer to the true median of the dataset. It helps improve
    the algorithm’s performance on a wide range of inputs, reducing the chance of
    worst-case behavior.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略通过使用数组中第一个、中央和最后一个元素的中位数作为枢轴。这种方法通过选择一个更接近数据集真正中位数的值来平衡枢轴选择。它有助于提高算法在各种输入上的性能，减少最坏情况的发生概率。
- en: Compared to other sorting algorithms, quick sort is highly efficient for large
    datasets, and its average and worst-case time complexity are *O*(*n* log *n*)
    and *O*(*n*²), respectively. Quick sort has an average space complexity of *O*(log
    *n*), which can degenerate to *O*(*n*) when the input array is already sorted
    or nearly sorted and the first or the last element is chosen as the pivot (worst
    case).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他排序算法相比，快速排序对于大数据集具有很高的效率，其平均时间复杂度和最坏情况下的时间复杂度分别为 *O*(*n* log *n*) 和 *O*(*n*²)。快速排序的平均空间复杂度为
    *O*(log *n*)，但当输入数组已经排序或接近排序，并且选择第一个或最后一个元素作为枢轴时（最坏情况），空间复杂度可能退化为 *O*(*n*)。
- en: The Code
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: The code for quick sort is quite similar to that of merge sort in structure,
    as both algorithms rely on a divide-and-conquer approach. In the code, the main()
    function accepts an input array and passes it to the quickSort() function. Within
    quickSort(), we invoke a partition() helper function to determine the correct
    position for the pivot element. This allows us to divide the original array into
    a left array containing elements less than the pivot and a right array containing
    elements greater than or equal to the pivot. Finally, quickSort() is recursively
    called on these subarrays as long as start is less than end, which means at least
    two elements remain in the subarray.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序的代码在结构上与归并排序非常相似，因为这两种算法都依赖于分治法。在代码中，main() 函数接受一个输入数组，并将其传递给 quickSort()
    函数。在 quickSort() 中，我们调用 partition() 辅助函数来确定枢轴元素的正确位置。这使我们能够将原始数组分成一个包含小于枢轴的元素的左数组和一个包含大于或等于枢轴的元素的右数组。最后，只要
    start 小于 end，即子数组中至少还有两个元素，quickSort() 就会递归调用这些子数组。
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the main() function, we call the quickSort() function by passing three parameter
    values: the array to be sorted (arr) and the indices for its first and last elements
    (start and end) ❶. As before, we print the array before and after sorting.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 main() 函数中，我们通过传递三个参数值调用 quickSort() 函数：要排序的数组 (arr) 以及其第一个和最后一个元素的索引 (start
    和 end) ❶。如前所述，我们在排序前后打印数组。
- en: In the quickSort() function, we start by checking whether the starting index
    of the incoming subarray is less than the ending index ❷. When this is no longer
    true, the subarray will have only one element, so the recursion of that branch
    will stop. Otherwise, we call the partition() helper function, which returns the
    final (sorted) position of the pivot element. We store this position as pivotIndex
    and use it to divide the original array into left and right subarrays. We then
    recursively call quicksort() on the left and right subarrays until the stopping
    condition is met.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 quickSort() 函数中，我们首先检查传入子数组的起始索引是否小于结束索引 ❷。当这不再成立时，子数组将只包含一个元素，因此该分支的递归将停止。否则，我们调用
    partition() 辅助函数，它返回枢轴元素的最终（已排序）位置。我们将这个位置存储为 pivotIndex，并利用它将原始数组分成左子数组和右子数组。然后，我们递归地调用
    quicksort() 对左子数组和右子数组进行排序，直到满足停止条件。
- en: The real sorting work happens inside the partition() function. After setting
    pivot to the value of the last element in the subarray, we use two index variables,
    i and j, to swap the positions of the elements inside a for loop. Both start at
    the beginning of the subarray, and then j steps through the subarray looking for
    elements with values less than pivot ❸. Each time one is found, the values at
    i and j are swapped, and then i is incremented. In effect, this moves elements
    less than the pivot to earlier in the array, and elements greater than the pivot
    to later in the array. Once the for loop is done, the pivot itself is swapped
    with the element at i ❹, which puts the pivot element into its final sorted position.
    Then the final value of i is returned so that two new subarrays can be formed
    on both sides of the final position of the last pivot element. The swaps themselves
    are relegated to a swap() helper function, which uses the temp variable to avoid
    overwriting the value at i. Apart from this one extra variable, the sorting happens
    in place.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的排序工作发生在`partition()`函数内部。在将枢轴设置为子数组中最后一个元素的值后，我们使用两个索引变量i和j，在for循环内交换元素的位置。i和j都从子数组的开头开始，然后j遍历子数组，寻找小于枢轴值的元素❸。每次找到一个这样的元素，就交换i和j的位置，然后i自增。这样，所有小于枢轴的元素都会移动到数组的前面，而大于枢轴的元素则移到数组的后面。一旦for循环完成，枢轴本身与位置为i的元素交换❹，将枢轴元素放到最终的排序位置。然后返回i的最终值，以便在最后一个枢轴元素的位置两侧形成两个新的子数组。交换操作本身被交给一个`swap()`辅助函数，该函数使用temp变量避免覆盖i位置的值。除了这个额外的变量，排序是在原地进行的。
- en: The Result
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'If you run the code with the example array, the output should look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行代码并使用示例数组，输出应该如下所示：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I mentioned earlier that I would explain how the order of the subarray elements
    is determined. This has to do with the swapping algorithm in the partition() function.
    During the first round of processing the [8, 3, 4, 5, 1, 2] array, for example,
    2 is the pivot, and the first element in the array less than the pivot is 1\.
    This element gets swapped with the 8 at the start of the array (accessed using
    index variable i), yielding an array of [1, 3, 4, 5, 8, 2]. Then the pivot itself
    (2) is swapped with the next element of the array (3—again accessed via i), yielding
    [1, 2, 4, 5, 8, 3].
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，我会解释子数组元素顺序是如何确定的。这与`partition()`函数中的交换算法有关。以处理[8, 3, 4, 5, 1, 2]数组的第一次为例，2是枢轴元素，而数组中小于枢轴的第一个元素是1。这个元素与数组开头的8交换（使用索引变量i访问），得到数组[1,
    3, 4, 5, 8, 2]。然后，枢轴元素本身（2）与数组中的下一个元素（3——同样通过i访问）交换，得到[1, 2, 4, 5, 8, 3]。
- en: I encourage you to manually step through the entire process of sorting the array
    with quick sort. You can refer to [Figure 7-2](chapter7.xhtml#fig7-2), which shows
    the original input array, the intermediate subarrays after each round of processing,
    and the final sorted array. By going through the comparisons and swaps yourself,
    you can visualize the partitioning and sorting process in a more tangible way.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你手动执行整个快速排序的过程。你可以参考[图7-2](chapter7.xhtml#fig7-2)，其中展示了原始输入数组、每一轮处理后的中间子数组和最终排序后的数组。通过亲自进行比较和交换，你可以以更直观的方式可视化分区和排序过程。
- en: '![](../images/Figure7-2.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-2.jpg)'
- en: 'Figure 7-2: The quick sort steps for [8, 3, 4, 5, 1, 2]'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-2：快速排序步骤，针对[8, 3, 4, 5, 1, 2]
- en: You can also autogenerate the subarrays at each stage by printing the left and
    right arrays from inside the quicksort() function, just after the position of
    the pivot is determined.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在quicksort()函数内部打印左右数组，在确定枢轴位置之后，自动生成每个阶段的子数组。
- en: Search Algorithms
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索算法
- en: Searching through a data structure is a fundamental operation in computer science.
    It helps us track down specific elements or retrieve information stored within
    a collection of data. While this task may seem trivial for a small amount of data,
    as the volume of data increases—up to large databases, filesystems, or even the
    whole internet—knowing how to choose the right search algorithm becomes paramount
    to keeping our digital life humming.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，搜索数据结构是一项基本操作。它帮助我们追踪特定元素或从数据集合中检索信息。虽然对于少量数据来说这项任务看似微不足道，但随着数据量的增加——直到庞大的数据库、文件系统，甚至整个互联网——知道如何选择合适的搜索算法变得至关重要，这样才能保持我们的数字生活顺畅运行。
- en: Search algorithms are intimately connected to the data structures they’re designed
    to search, since how the data is organized affects how efficiently a particular
    item can be found and accessed. For the purposes of the coming projects, we’ll
    focus on several algorithms that are used to search a graph, which is a type of
    data structure. Before we get to the algorithms themselves, however, it’s important
    to establish how graphs are structured.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索算法与它们所设计的搜索数据结构密切相关，因为数据的组织方式会影响找到并访问特定项的效率。为了即将开展的项目，我们将重点讨论几种用于搜索图的算法，图是一种数据结构。然而，在讨论这些算法之前，了解图的结构是非常重要的。
- en: What Is a Graph?
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 什么是图？
- en: In the field of graph theory, a graph is a mathematical structure consisting
    of a set of vertices (also known as *nodes*) and a set of edges (also known as
    *arcs* or *links*) that connect pairs of vertices. Vertices can represent any
    kind of objects, such as cities, people, or even more abstract concepts. Edges
    represent relationships or connections between the vertices. Mathematically, a
    graph is denoted by *G* and defined as *G* = (***V***, ***E***), where ***V***
    is a set of vertices or nodes, and ***E*** is a set of edges or links.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论领域，图是一种数学结构，由一组顶点（也称为*节点*）和一组连接顶点对的边（也称为*弧*或*链接*）组成。顶点可以代表任何类型的对象，例如城市、人物，甚至更抽象的概念。边表示顶点之间的关系或连接。从数学角度看，图用*G*表示，定义为*G*
    = (***V***, ***E***)，其中***V***是顶点或节点的集合，***E***是边或链接的集合。
- en: '[Figure 7-3](chapter7.xhtml#fig7-3) depicts a simple graph consisting of five
    nodes and five edges. Each circle in the figure represents a vertex, and each
    line represents an edge. The nodes are named with sequential numbers for convenience.
    In real-world cases, most nodes would be names with strings, however. When node
    names are designated by whole numbers, we can treat them as either of type Int
    or of type String in the code.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-3](chapter7.xhtml#fig7-3)展示了一个由五个节点和五条边组成的简单图。图中的每个圆圈代表一个顶点，每条线代表一条边。为了方便起见，节点用顺序编号命名。然而，在实际应用中，大多数节点会用字符串命名。当节点名称由整数表示时，我们可以在代码中将它们视为
    Int 类型或 String 类型。'
- en: '![](../images/Figure7-3.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-3.jpg)'
- en: 'Figure 7-3: A simple graph with five nodes and five edges'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3：一个包含五个节点和五条边的简单图
- en: 'Graphs can be categorized into two main groups: undirected and directed. In
    an *undirected graph*, the edges allow movement between vertices in both directions.
    This type of graph is often used to represent scenarios like a road network, where
    traffic can flow both ways. By contrast, each edge in a *directed graph* has a
    specific direction associated with it, restricting the way you can move between
    vertices. For example, a directed graph can represent a water or power distribution
    network, where the flow always moves from areas of high pressure to areas of low
    pressure or from high voltage to low voltage, respectively.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以分为两大类：无向图和有向图。在*无向图*中，边允许在顶点之间双向移动。这种类型的图常用于表示像道路网络这样的场景，在这种网络中，交通可以双向流动。相反，*有向图*中的每条边都有一个特定的方向，限制了在顶点之间移动的方式。例如，有向图可以表示水力或电力分配网络，其中流动总是从高压区流向低压区，或从高电压流向低电压。
- en: When the edges of a graph have weights associated with them, the graph is called
    a *weighted graph*. The weight in this case could be a proxy for cost, distance,
    or any other edge-related property. Weighted graphs can be either directed or
    undirected.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当图的边带有权重时，这种图被称为*加权图*。在这种情况下，权重可以作为成本、距离或其他与边相关的属性的代理。加权图可以是有向的，也可以是无向的。
- en: How to Search a Graph
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何搜索图
- en: In the coming projects, we’ll consider three different algorithms for searching
    a graph. The first, *depth-first search (DFS)*, is a technique that starts at
    a particular node and explores as far (or “as deep”) as possible along one branch
    before backtracking and exploring the next. In this way, it traverses the depth
    of a data structure before exploring its breadth. DFS is often implemented by
    using a *stack* data structure (we explored stacks in [Chapter 6](chapter6.xhtml)
    while developing the L-system simulator). This way, DFS can use the youngest node
    in the stack to extend the branch and explore each adjacent node at the end of
    a branch before backtracking and moving to the next branch. DFS is useful in many
    applications, including scheduling problems, detecting cycles in graphs, and solving
    puzzles with only one solution, such as a maze or a sudoku puzzle.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的项目中，我们将考虑三种不同的图搜索算法。首先是 *深度优先搜索（DFS）*，这是一种从特定节点开始，在一条分支上尽可能深入探索（或“深度”）后，再回溯并探索下一条分支的技术。这样，它在探索数据结构的广度之前，先遍历数据结构的深度。DFS
    通常通过使用 *栈* 数据结构来实现（在我们开发 L-system 模拟器时，我们在[第六章](chapter6.xhtml)中探索了栈）。通过这种方式，DFS
    可以使用栈中最新的节点来延伸分支，并在回溯并转向下一个分支之前，探索分支末端的每个相邻节点。DFS 在许多应用中都很有用，包括调度问题、图中检测循环，以及解决只有一个解的谜题，如迷宫或数独。
- en: The next algorithm, *breadth-first search (BFS)*, takes the opposite approach
    of DFS, exploring the data structure level by level. It starts at a given node
    and visits all its immediate neighbors. Then it moves on to the next level, visiting
    all the neighbors’ neighbors, and so on. In this way, BFS prioritizes exploring
    the breadth of the entire data structure over the depth of any individual branch.
    As we’ll discuss in [Project 31](chapter7.xhtml#pre-31), BFS typically uses a
    queue data structure, allowing it to visit each level in order. It’s useful for
    finding the shortest path, web crawling, analyzing social networks, and exploring
    all reachable nodes in a graph while using the smallest number of iterations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个算法是 *广度优先搜索（BFS）*，它采取与 DFS 相反的方法，逐层探索数据结构。它从给定的节点开始，访问所有直接邻居。然后，它继续到下一级，访问所有邻居的邻居，依此类推。通过这种方式，BFS
    优先探索整个数据结构的广度，而非任何单一分支的深度。正如我们在[第31项目](chapter7.xhtml#pre-31)中将讨论的那样，BFS 通常使用队列数据结构，使其能够按顺序访问每一层。它对于寻找最短路径、网页爬取、分析社交网络以及在图中以最少的迭代次数探索所有可达节点非常有用。
- en: The choice between DFS and BFS depends on the specific problem and the characteristics
    of the data structure being searched. DFS is typically used when we want to conduct
    a deep exploration and potentially find a target item more quickly, while BFS
    is suitable for situations where we want to visit all nodes at a certain distance
    from the starting point or find the shortest path between nodes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: DFS 和 BFS 的选择取决于特定问题和正在搜索的数据结构的特点。DFS 通常在我们希望进行深入探索并可能更快地找到目标项时使用，而 BFS 则适用于我们希望访问距离起始点一定范围内的所有节点或寻找节点之间的最短路径的情况。
- en: The final algorithm we’ll explore is called *A* search* (pronounced “A-star
    search”). It excels in finding the shortest path in a graph or a maze by combining
    heuristic decision-making with real-time exploration to guide the search. The
    term *heuristic* refers to general decision-making strategies that rely on intuition,
    educated guesses, or common sense to arrive at a plausible solution or direction
    to explore. While heuristics can’t guarantee an optimal or perfect outcome, they
    often provide an advantage in situations where constraints such as limited information,
    time, or resources exist.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索的最后一个算法是 *A* 搜索*（发音为“A-star search”）。它通过将启发式决策与实时探索相结合，擅长在图或迷宫中找到最短路径。*启发式*
    一词指的是依赖于直觉、教育性猜测或常识来得出合理解答或探索方向的一般决策策略。虽然启发式方法无法保证最优或完美的结果，但它们通常能在信息、时间或资源受限的情况下提供优势。
- en: The A* algorithm’s heuristic is to consider both the cost of reaching a specific
    node and an estimate of the remaining effort required to reach the destination.
    In this way, A* is able to intelligently prioritize the most promising paths.
    This strategic approach, similar to having a GPS in a labyrinth, helps save time
    and effort in the search process. Due to its versatility, A* is frequently applied
    in fields such as pathfinding in video games, robotics, navigation systems, and
    various optimization problems.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: A* 算法的启发式是考虑到到达特定节点的成本以及估算到达目标所需的剩余努力。通过这种方式，A* 能够智能地优先考虑最有前景的路径。这种策略性方法，类似于在迷宫中使用
    GPS，能够帮助节省搜索过程中的时间和精力。由于其多功能性，A* 被广泛应用于视频游戏、机器人学、导航系统和各种优化问题等领域。
- en: 'Project 30: Stack-Based Searching with Depth-First Search'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 30：基于栈的深度优先搜索
- en: In this project, we’ll explore the core steps of depth-first search and implement
    them in Kotlin. We’ll employ the stack data structure in the code, although it’s
    worth noting the existence of other viable methods for implementing the core DFS
    algorithm. Later on, I’ll share some hints on an alternative approach.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，我们将探索深度优先搜索的核心步骤并在 Kotlin 中实现它们。我们将在代码中使用栈数据结构，尽管值得注意的是，存在其他可行的方法来实现核心的
    DFS 算法。稍后，我会分享一些关于替代方法的提示。
- en: 'For a given graph (a network of nodes and edges), here are the steps to perform
    a DFS by using a stack:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的图（一个由节点和边组成的网络），以下是通过栈执行深度优先搜索（DFS）的步骤：
- en: 1.  Start by selecting a node as the starting node (it can be any node).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  首先选择一个节点作为起始节点（它可以是任何节点）。
- en: 2.  Push the starting node onto the stack.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将起始节点压入栈中。
- en: 3.  While the stack is not empty, pop a node from the stack.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  当栈不为空时，从栈中弹出一个节点。
- en: 4.  If the popped node is not yet visited, mark it as visited and push its neighbors
    to the stack; or else pop the next node from the stack.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  如果弹出的节点尚未访问，标记为已访问并将其邻居节点压入栈中；否则，从栈中弹出下一个节点。
- en: 5.  Repeat steps 3 and 4 until the stack is empty.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  重复执行步骤 3 和步骤 4，直到栈为空。
- en: Recall from [Chapter 6](chapter6.xhtml) that a stack follows the LIFO principle,
    whereby items are removed from the stack in the reverse order in which they were
    added. The LIFO principle allows the DFS algorithm to backtrack from the end of
    one branch before starting on a new, unvisited branch. This ensures an exhaustive
    search of the entire graph, although it would also be beneficial to include a
    stopping condition. When each node is visited, this condition would check if the
    desired goal of the search has been achieved, such as finding a specific object
    or completing a particular task. Once the goal is met, the search can be terminated
    early. For this project, we’ll use the graph shown in [Figure 7-3](chapter7.xhtml#fig7-3).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下在[第 6 章](chapter6.xhtml)中提到的，栈遵循后进先出（LIFO）原则，即按照元素被加入栈的相反顺序将其移除。LIFO 原则使得
    DFS 算法能够在开始新的未访问的分支之前，从一条分支的末端回溯。这确保了对整个图的穷举搜索，尽管加入停止条件也会有所帮助。当访问到每个节点时，该条件会检查搜索是否已经达到了预期目标，比如找到特定对象或完成特定任务。一旦达成目标，搜索可以提前终止。对于这个项目，我们将使用[图
    7-3](chapter7.xhtml#fig7-3)中展示的图。
- en: The time complexity of the DFS algorithm is *O*(*V* + *E*), where *V* is the
    number of vertices and *E* is the number of edges in the graph. The space complexity
    of DFS depends on the implementation (a stack versus a recursive function); the
    worst-case space complexity is *O*(*V*).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索（DFS）算法的时间复杂度是 *O*(*V* + *E*)，其中 *V* 是图中顶点的数量，*E* 是图中边的数量。DFS 的空间复杂度取决于实现方式（使用栈与递归函数的区别）；最坏情况下的空间复杂度是
    *O*(*V*)。
- en: The Code
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: Let’s now examine the code that implements the core steps of DFS. We’ll use
    the code to traverse the entire example graph shown earlier in [Figure 7-3](chapter7.xhtml#fig7-3).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来查看实现 DFS 核心步骤的代码。我们将使用该代码来遍历之前在[图 7-3](chapter7.xhtml#fig7-3)中展示的整个示例图。
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we import the ArrayDeque class from java.util, which we’ll use to implement
    the stack. Next, we declare the main() function, which serves as the entry point
    of the program. It defines the graph as a map pairing each node ("0" through "4")
    with a set of all its neighboring nodes ❶. For example, node "2" is paired with
    the set ["0", "1", "4"], since it’s connected to those nodes. We print the graph
    to the console, then call the dfsStack() function to perform the search, passing
    the graph and a starting node as arguments ❷. Upon completion of the search, the
    list of visited nodes is returned, which is printed as the program’s final output.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`java.util`导入`ArrayDeque`类，我们将用它来实现栈。接下来，我们声明`main()`函数，它作为程序的入口点。它将图定义为一个映射，将每个节点（从"0"到"4"）与它的所有邻居节点的集合配对❶。例如，节点"2"与集合["0",
    "1", "4"]配对，因为它与这些节点相连。我们将图打印到控制台，然后调用`dfsStack()`函数执行搜索，传递图和起始节点作为参数❷。搜索完成后，返回访问过的节点列表，并将其打印为程序的最终输出。
- en: Inside the dfsStack() function, we create a mutable set called visited to keep
    track of the visited nodes and an ArrayDeque named stack to store the nodes during
    traversal. We push the starting node to the stack, then enter a while loop that
    iterates for as long as the stack is not empty ❸. In each iteration, the last
    node from the stack is removed by using pop() and assigned to the variable node.
    If the node hasn’t been visited before, we could perform additional operations
    or processing specific to the application at this point—for example, checking
    if the node matches our search criteria and breaking from the loop if it does.
    The node is then added to the visited set by using the add() function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dfsStack()`函数内部，我们创建一个可变集合`visited`来跟踪访问过的节点，并创建一个名为`stack`的`ArrayDeque`来存储遍历过程中的节点。我们将起始节点推入栈中，然后进入一个`while`循环，只要栈不为空，就会一直执行❸。在每次迭代中，我们通过使用`pop()`方法从栈中移除最后一个节点，并将其赋值给变量`node`。如果该节点之前未被访问过，我们可以在此时执行额外的操作或特定的处理——例如，检查节点是否符合我们的搜索标准，如果符合则跳出循环。然后，通过`add()`方法将该节点添加到`visited`集合中。
- en: Next, we add all neighboring nodes, retrieved from graph by using node as the
    key, to the stack via the push() function ❹. We use the nonnull assertion operator
    (!!) while adding graph[node] to the stack to avoid additional null safety checks
    that aren’t required for undirected graphs (every node will have at least one
    link or edge). The while loop terminates once the stack is empty, at which point
    the set of visited nodes is returned to main().
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用节点作为键从图中检索所有邻居节点，并通过`push()`方法将它们添加到栈中❹。在将`graph[node]`添加到栈时，我们使用非空断言操作符`!!`，以避免对无向图不必要的空安全检查（每个节点至少会有一个链接或边）。当栈为空时，`while`循环终止，此时访问过的节点集合会返回到`main()`函数。
- en: Note that we could have used the ArrayDeque class from kotlin.collections (as
    we did in [Chapter 6](chapter6.xhtml)) instead of ArrayDeque from java.util to
    implement the stack. In that case, we would replace push() with addLast() and
    pop() with the removeLast() function. I’ve chosen to use the Java version in part
    to illustrate an alternative stack implementation and in part because the ArrayDeque
    method names like push() and pop() fit naturally with the stack architecture.
    Both techniques follow the LIFO principle, meaning that the last element added
    to the stack is the first one removed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们本可以使用`kotlin.collections`中的`ArrayDeque`类（如我们在[第6章](chapter6.xhtml)中所做的）来实现栈。在这种情况下，我们会将`push()`替换为`addLast()`，将`pop()`替换为`removeLast()`方法。我选择使用Java版本，部分是为了展示另一种栈实现方法，部分是因为`ArrayDeque`中的方法名（如`push()`和`pop()`）更自然地契合栈结构。两种方法都遵循LIFO原则，即最后添加到栈中的元素是第一个被移除的。
- en: The Result
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'If you run the code with the given graph, you should get the following output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行给定图的代码，你应该会得到以下输出：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The list of visited nodes [0, 3, 2, 4, 1] indicates the algorithm has traversed
    the entire graph. To see where this order comes from, and to better understand
    how the stack facilitates the DFS process, consider [Table 7-2](chapter7.xhtml#tab7-2),
    which shows the intermediate values at each step of the algorithm.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 访问过的节点列表[0, 3, 2, 4, 1]表示算法已经遍历了整个图。为了理解这个顺序的来源，并更好地理解栈如何促进DFS过程，参考[表7-2](chapter7.xhtml#tab7-2)，它展示了算法每一步的中间值。
- en: 'Table 7-2: Anatomy of the Depth-First Search Using Stack'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 表7-2：使用栈的深度优先搜索解析
- en: '| Stage | Node | Node not visited? | Visited nodes | Neighbor nodes | Nodes
    on stack |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 阶段 | 节点 | 节点未访问？ | 已访问节点 | 邻居节点 | 栈中的节点 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Initialization, with start of 0 | N/A | N/A | [] (empty) | N/A | [0] (start
    pushed to stack) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 初始化，起始为0 | N/A | N/A | []（空） | N/A | [0]（起始节点已压入栈） |'
- en: '| Inside the while loop | 03024212001 | truetruefalsetruetruefalsetruefalsefalsefalsefalse
    | [0][0, 3]no change[0, 3, 2][0, 3, 2, 4]no change[0, 3, 2, 4, 1]no changeno changeno
    changeno change | [1, 2, 3][0]N/A[0, 1, 4][2]N/A[0, 2]N/AN/AN/AN/A | [1, 2, 3][1,
    2, 0][1, 2][1, 0, 1, 4][1, 0, 1, 2][1, 0, 1][1, 0, 0, 2][1, 0, 0][1, 0][1][] (empty;
    while loop terminates) |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 在while循环内部 | 03024212001 | truetruefalsetruetruefalsetruefalsefalsefalsefalse
    | [0][0, 3]无变化[0, 3, 2][0, 3, 2, 4]无变化[0, 3, 2, 4, 1]无变化无变化无变化无变化 | [1, 2, 3][0]无[N/A][0,
    1, 4][2]无[0, 2]无无无无 | [1, 2, 3][1, 2, 0][1, 2][1, 0, 1, 4][1, 0, 1, 2][1, 0, 1][1,
    0, 0, 2][1, 0, 0][1, 0][1][]（空；while循环终止） |'
- en: Let’s take a look at a few rows from [Table 7-2](chapter7.xhtml#tab7-2) to understand
    how DFS works. In the first row, we see what happens during the initialization
    phase, before entering the while loop. We set the starting node to "0" and push
    it onto the stack. At this stage, node "0" hasn’t been marked as visited yet.
    Next, we move inside the while loop, where the rest of the processing happens.
    First, we pop the last node from the stack, which is "0" (this makes the stack
    momentarily empty). Since this node isn’t yet marked as visited, we add it to
    the list of visited nodes, which goes from [] to [0]. We then add all this node’s
    neighbors (accessed with graph["0"]) to the stack, which goes from [] to [1, 2,
    3].
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下[表格7-2](chapter7.xhtml#tab7-2)中的几行，以了解深度优先搜索（DFS）是如何工作的。在第一行，我们看到初始化阶段发生了什么，在进入while循环之前。我们将起始节点设置为"0"，并将其压入栈中。在此阶段，节点"0"还没有被标记为已访问。接下来，我们进入while循环，剩余的处理就在这里进行。首先，我们从栈中弹出最后一个节点，即"0"（这使得栈暂时为空）。由于此节点尚未标记为已访问，我们将其添加到已访问节点列表中，从[]变为[0]。然后，我们将该节点的所有邻居（通过graph["0"]访问）添加到栈中，栈从[]变为[1,
    2, 3]。
- en: The next time through the loop, "3" is popped from the stack, since it’s the
    last element. It hasn’t been visited yet, so it’s added to visited, and its only
    neighbor "0" is pushed to the stack. The process continues until the stack is
    found to be empty at the start of a while loop iteration. I strongly encourage
    you to go over the remaining rows of the table to get a hands-on feel for how
    the DFS algorithm works in practice.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次循环时，"3"从栈中弹出，因为它是最后一个元素。它还没有被访问，所以它被添加到visited中，并且它唯一的邻居"0"被推入栈中。这个过程会持续，直到栈在while循环迭代开始时为空。我强烈建议你查看表格中的其余行，亲自体验DFS算法在实践中的运作。
- en: 'Project 31: Queue-Based Searching with Breadth-First Search'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 项目31：基于队列的广度优先搜索
- en: In this project we’ll continue our exploration of search algorithms by implementing
    breadth-first search. BFS guarantees that all nodes at the same level are visited
    before moving on to the next level. This process continues until all nodes in
    the graph have been visited. As in [Project 30](chapter7.xhtml#pre-30), we’ll
    use the ArrayDeque class from java.util to implement the BFS algorithm. This time,
    however, we’ll use the class as a *queue*, a data structure that adheres to the
    *first in, first out (FIFO)* principle. Whereas items are always added (“pushed”)
    or removed (“popped”) from the end of a stack, items are added (“enqueued”) at
    the end of a queue and removed (“dequeued”) from the beginning of the queue. This
    ensures that items are processed in the order in which they were added to the
    queue.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将继续探索搜索算法，通过实现广度优先搜索（BFS）。BFS确保所有处于同一层次的节点在进入下一层之前都被访问。这个过程会持续，直到图中的所有节点都被访问过。与[项目30](chapter7.xhtml#pre-30)一样，我们将使用java.util中的ArrayDeque类来实现BFS算法。然而，这次我们将使用该类作为*队列*，一种遵循*先进先出（FIFO）*原则的数据结构。与始终从栈的末端添加（“推入”）或移除（“弹出”）项不同，项被添加（“入队”）到队列的末端，并从队列的开始处移除（“出队”）。这确保了项按照其添加到队列中的顺序进行处理。
- en: 'To perform a BFS, we’ll follow these steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 执行广度优先搜索（BFS），我们将遵循以下步骤：
- en: 1.  Select a node as the starting node (it can be any node).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  选择一个节点作为起始节点（可以是任何节点）。
- en: 2.  Create a mutable list called visited and add the starting node to it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  创建一个可变列表，名为visited，并将起始节点添加到其中。
- en: 3.  Create an empty queue and enqueue (add) the starting node.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  创建一个空队列并将起始节点入队（添加）。
- en: '4.  While the queue is not empty, perform the following steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  当队列不为空时，执行以下步骤：
- en: a.  Dequeue the front node from the queue.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: a.  从队列中出队最前面的节点。
- en: b.  Process the dequeued node as needed (perhaps printing its value or performing
    some operation).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: b.  根据需要处理出队的节点（可能打印其值或执行某些操作）。
- en: c.  Enqueue all the unvisited neighbors of the dequeued node and mark them as
    visited.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: c.  将所有未访问的邻接节点加入队列，并将其标记为已访问。
- en: We’ll use the graph shown in [Figure 7-3](chapter7.xhtml#fig7-3) for this project
    as well.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 [图 7-3](chapter7.xhtml#fig7-3) 中显示的图形作为本项目的图。
- en: The time complexity of the BFS algorithm is *O*(*V* + *E*), where *V* is the
    number of vertices and *E* is the number of edges in the graph. The space complexity
    of the BFS algorithm is typically *O*(*V*). Both DFS and BFS therefore have the
    same time complexity, but their space complexity can vary depending on the implementation
    and the structure of the graph.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: BFS 算法的时间复杂度是 *O*(*V* + *E*)，其中 *V* 是图中顶点的数量，*E* 是边的数量。BFS 算法的空间复杂度通常是 *O*(*V*)。因此，DFS
    和 BFS 的时间复杂度相同，但它们的空间复杂度可能因实现方式和图的结构而有所不同。
- en: The Code
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: The code for BFS closely resembles that of DFS, but I’ll highlight a few important
    distinctions as we discuss the program.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: BFS 的代码与 DFS 的代码非常相似，但在讨论程序时，我会突出几个重要的区别。
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The main() function is essentially the same as that of the previous project.
    We define the input graph by using a map data structure and print the graph, displaying
    each node and its neighbors. We then call the bfsQueue() search function, passing
    the graph and the starting node as arguments ❶. The function returns the visited
    nodes, which are printed as the final output of the program.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: main() 函数与之前项目中的基本相同。我们使用映射数据结构定义输入图，并打印图，显示每个节点及其邻接节点。然后，我们调用 bfsQueue() 搜索函数，传递图和起始节点作为参数
    ❶。该函数返回已访问的节点，并将其打印为程序的最终输出。
- en: Inside the bfsQueue() function, we initialize a mutable list called visited
    to keep track of visited nodes as before, along with an ArrayDeque called queue
    to store the nodes to be visited. We then add the starting node to both the visited
    set and the queue, using the offer() method for the latter. Next, we initiate
    a while loop that continues until the queue becomes empty ❷. Within the loop,
    we dequeue a node from the front of the queue by using the poll() method, placing
    it in the node variable. We then iterate over each neighbor of the current node,
    obtained from the graph. If a neighbor hasn’t been visited (meaning it isn’t present
    in the visited set), it’s enqueued by using the offer() method and added to the
    visited set ❸. After processing all the neighbors, the loop continues until the
    queue becomes empty. The visited set is then returned, containing all the nodes
    visited during the search.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 bfsQueue() 函数内部，我们初始化了一个可变列表，称为 visited，用来跟踪已访问的节点，和一个叫做 queue 的 ArrayDeque
    来存储待访问的节点。然后，我们将起始节点同时添加到 visited 集合和队列中，后者使用 offer() 方法。接下来，我们启动一个 while 循环，直到队列为空为止
    ❷。在循环内，我们通过 poll() 方法从队列的前端出队一个节点，并将其存放在 node 变量中。然后，我们遍历当前节点的每个邻接节点，这些邻接节点是从图中获得的。如果一个邻接节点未被访问（意味着它不在
    visited 集合中），则使用 offer() 方法将其入队并添加到 visited 集合中 ❸。处理完所有邻接节点后，循环继续，直到队列为空。然后返回
    visited 集合，包含了搜索过程中访问的所有节点。
- en: The Result
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'For the given graph, if you run the code without any changes, the code will
    produce the following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的图，如果你运行没有任何更改的代码，代码将产生以下输出：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, the list of visited nodes [0, 1, 2, 3, 4] indicates the algorithm has
    successfully traversed the entire graph. This time, the nodes are marked as visited
    in numerical order, a function of the FIFO principle of the queue. [Table 7-3](chapter7.xhtml#tab7-3)
    shows the intermediate values of the key variables as the process unfolds and
    how the BFS algorithm works.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，访问过的节点列表 [0, 1, 2, 3, 4] 表明算法已成功遍历整个图。这次，节点按数字顺序标记为已访问，这是队列的 FIFO 原则的体现。[表
    7-3](chapter7.xhtml#tab7-3) 显示了关键变量的中间值，展示了过程的展开以及 BFS 算法的工作原理。
- en: 'Table 7-3: Anatomy of the Breadth-First Search Using a Queue'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-3：使用队列的广度优先搜索解剖
- en: '| Stage | Node | Neighbor nodes | next node | Node not visited? | Nodes on
    queue | Visited nodes |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 阶段 | 节点 | 邻接节点 | 下一个节点 | 节点未访问? | 队列中的节点 | 已访问节点 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| Initialization, with start of 0 | N/A | N/A | N/A | N/A | [0] | [0] |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 初始化，起始为 0 | 不适用 | 不适用 | 不适用 | 不适用 | [0] | [0] |'
- en: '| Inside the while loop | 0 | [1, 2, 3] | 123 | truetruetrue | [1][1, 2][1,
    2, 3] | [0, 1][0, 1, 2][0, 1, 2, 3] |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 在 while 循环中 | 0 | [1, 2, 3] | 123 | truetruetrue | [1][1, 2][1, 2, 3] | [0,
    1][0, 1, 2][0, 1, 2, 3] |'
- en: '| 1 | [0, 2] | 02 | falsefalse | [2, 3][2, 3] | no changeno change |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 1 | [0, 2] | 02 | falsefalse | [2, 3][2, 3] | 无变化无变化 |'
- en: '| 2 | [0, 1, 4] | 014 | falsefalsetrue | [3][3][3, 4] | no changeno change[0,
    1, 2, 3, 4] |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 2 | [0, 1, 4] | 014 | falsefalsetrue | [3][3][3, 4] | no changeno change[0,
    1, 2, 3, 4] |'
- en: '| 3 | [0] | 0 | false | [4] | no change |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 3 | [0] | 0 | false | [4] | no change |'
- en: '| 4 | [2] | 2 | false | [] (empty; while loop terminates) | no change |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 4 | [2] | 2 | false | []（空；while循环终止） | no change |'
- en: Let’s go over a few of the rows in [Table 7-3](chapter7.xhtml#tab7-3) to gain
    a better understanding of how the BFS algorithm is implemented. At the initialization
    stage, we identify node "0" as the start node and add it to both the visited list
    and the queue. Both of these lists now contain "0" (see the first row).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看一下[表7-3](chapter7.xhtml#tab7-3)中的几行，以便更好地理解BFS算法的实现。在初始化阶段，我们将节点"0"标识为起始节点，并将其添加到访问列表和队列中。此时，这两个列表中都包含"0"（请参见第一行）。
- en: Next, we move inside the while loop, which runs as long as queue is not empty.
    We start with the front node "0" and fetch its neighboring nodes, "1", "2", and
    "3". For each, we check that it hasn’t been visited before; when this is true,
    we add that node to both queue and visited. Since none of these nodes were visited,
    they’re all added to queue and visited when we’re done with node "0".
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入while循环，只要队列不为空，循环就会继续进行。我们从前端节点"0"开始，并获取其邻居节点"1"、"2"和"3"。对于每个节点，我们检查它是否以前未被访问过；当这个条件成立时，我们将该节点添加到队列和访问列表中。由于这些节点都未被访问过，它们在完成节点"0"的处理后都会被添加到队列和访问列表中。
- en: The process continues by pulling the next front node, "1". This time both its
    neighbors, "0" and "2", show up in the visited list, so nothing is added to queue
    or visited. Each time we remove a node from queue, the queue shrinks in size.
    In the final step, node "4" is pulled out, making queue empty, which breaks the
    while loop. The code returns the visited list as the final output.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程继续，通过提取下一个前端节点"1"来进行。这一次，它的两个邻居"0"和"2"出现在访问列表中，因此队列和访问列表都没有添加任何内容。每次从队列中移除一个节点时，队列的大小都会减少。在最后一步，节点"4"被提取出来，使队列为空，这打破了while循环。代码返回访问列表作为最终输出。
- en: Comparing [Tables 7-2](chapter7.xhtml#tab7-2) and [7-3](chapter7.xhtml#tab7-3)
    will help you gain a deeper understanding of the unique features of the DFS and
    BFS algorithms.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 比较[表7-2](chapter7.xhtml#tab7-2)和[7-3](chapter7.xhtml#tab7-3)将帮助你更深入地理解DFS和BFS算法的独特特点。
- en: 'Project 32: Heuristic Searching with A*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 项目32：使用A*的启发式搜索
- en: In this project, we’ll explore the A* search algorithm, an informed search algorithm
    that uses a heuristic function to guide the search. Its primary objective is to
    find the optimal path between two nodes in a graph by considering the cost of
    each path. To that end, it’s best suited for working with weighted graphs, where
    each edge has an associated score. [Figure 7-4](chapter7.xhtml#fig7-4) shows the
    graph we’ll use for the project.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将探索A*搜索算法，这是一种使用启发式函数来引导搜索的有信息搜索算法。它的主要目标是通过考虑每条路径的代价，找到图中两个节点之间的最优路径。为了实现这一目标，它最适合用于加权图，其中每条边都有一个关联的得分。[图7-4](chapter7.xhtml#fig7-4)展示了我们将用于本项目的图。
- en: '![](../images/Figure7-4.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-4.jpg)'
- en: 'Figure 7-4: An example graph for [Project 32](chapter7.xhtml#pre-32) (start
    node = A, target node = J)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-4：用于[项目32](chapter7.xhtml#pre-32)的示例图（起始节点 = A，目标节点 = J）
- en: The graph in the figure has 13 nodes (A through M) and 20 edges, making it significantly
    more substantial than the example graph we used in the previous projects. The
    values along the edges represent the cost of traveling between the two nodes connected
    by that edge. We’re assuming that the graph is undirected, so travel along an
    edge can go in either direction, and that the cost for each edge is *symmetric*,
    meaning it’s the same no matter the direction of travel. For this project, we’re
    interested in determining the lowest-cost route from node A (the start) to node
    J (the target).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的图形有13个节点（从A到M）和20条边，使得它比我们在前几个项目中使用的示例图要大得多。沿着边的值表示在连接这两个节点的边上旅行的代价。我们假设图是无向图，因此沿着边的旅行可以朝任何一个方向进行，而且每条边的代价是*symmetric*（对称的），意味着无论旅行的方向如何，代价都是相同的。在这个项目中，我们的目标是确定从节点A（起点）到节点J（目标）的最低代价路径。
- en: 'As the A* algorithm traverses a graph, it uses two distinct functions to help
    make decisions. One calculates the *g-score*, the actual cost of traveling from
    the start node to the current node. The other calculates the *h-score*, the estimated
    or heuristic cost of traveling from the current node to the target node. Added
    together, these two scores give the *f-score*, the estimated total cost of the
    path:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当 A* 算法遍历图时，它使用两个不同的函数来帮助做决策。一个计算*g-score*，即从起始节点到当前节点的实际成本。另一个计算*h-score*，即从当前节点到目标节点的估算或启发式成本。将这两个分数相加，得到*f-score*，即路径的估计总成本：
- en: '*  f-score* = *g-score* + *h-score*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*  f-score* = *g-score* + *h-score*'
- en: One of the key strengths of the A* algorithm is its efficiency in finding the
    shortest path based on this informed approach. But for this to work, we need a
    good heuristic function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: A* 算法的一个关键优势是基于这种信息化方法在寻找最短路径时的效率。但要实现这一点，我们需要一个好的启发式函数。
- en: '#### The Heuristic Function'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 启发式函数'
- en: In the context of the A* search algorithm, a heuristic function, denoted as
    *h*(*n*), is a function that estimates the cost from the current node to the target
    node in a graph. The purpose of the heuristic function is to guide the search
    algorithm by providing an informed estimate of how far a node is from the target,
    which helps A* make more efficient decisions about which nodes to explore next.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 A* 搜索算法的背景下，启发式函数，用 *h*(*n*) 表示，是一个估算图中当前节点到目标节点的成本的函数。启发式函数的目的是通过提供关于节点距离目标的有根据的估算，来引导搜索算法，从而帮助
    A* 做出更高效的决策，决定接下来探索哪些节点。
- en: An *admissible* heuristic function for the A* algorithm is a function that never
    overestimates the cost of reaching the goal from any node. With an admissible
    set of h-scores, A* is guaranteed to find the shortest or least costly path. However,
    not all sets of admissible h-scores are equally good. The algorithm’s performance
    depends on how close the h-scores are to the true costs. The more accurate the
    h-scores are, the faster the algorithm will find the optimal path.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*A*算法的*可接受*启发式函数是一个从任何节点到达目标的成本永远不会被高估的函数。通过一个可接受的 h-score 集合，A* 可以保证找到最短或最不昂贵的路径。然而，并非所有的可接受
    h-score 集合都同样优秀。算法的性能取决于 h-score 与真实成本的接近程度。h-score 越准确，算法找到最优路径的速度就越快。
- en: 'Another desirable property of the heuristic function is consistency. A *consistent*
    function satisfies this condition: the cost of reaching the goal from a node is
    always less than or equal to the cost of reaching the goal from any neighbor of
    that node, plus the cost of moving to that neighbor. Consistency implies admissibility
    but not vice versa. A consistent set of h-scores can make the A* algorithm more
    efficient, as it will expand fewer nodes and converge to the optimal solution
    very quickly.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 启发式函数的另一个理想特性是一致性。一个*一致的*函数满足以下条件：从某个节点到达目标的成本总是小于或等于从该节点的任何邻居到达目标的成本，再加上到该邻居的移动成本。一致性意味着可接受性，但反之则不然。一致的
    h-score 集合可以使 A* 算法更加高效，因为它将扩展更少的节点，并能非常迅速地收敛到最优解。
- en: 'Consistent h-scores may be hard or impossible to obtain for large and complex
    real-world problems. However, we can still estimate admissible h-scores that are
    of high quality by using various techniques, depending on the problem type. Here
    are some common approaches for generating heuristic functions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型和复杂的现实问题，一致的 h-score 可能很难或不可能获得。然而，我们仍然可以通过使用各种技术来估算高质量的可接受 h-score，具体取决于问题类型。以下是一些常见的启发式函数生成方法：
- en: '**Ad hoc selection of h-scores**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**临时选择 h-score**'
- en: This method will work when the graph is small and it’s possible to make conservative
    guesses about the h-scores depending on the depth of a node. For example, one
    can set all h-scores to some arbitrary small value that’s guaranteed to be both
    admissible and consistent.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当图较小并且可以根据节点的深度对 h-score 进行保守猜测时，这种方法会有效。例如，可以将所有 h-score 设置为一些任意的小值，这些值既可接受又一致。
- en: '**Domain knowledge**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域知识**'
- en: In some cases, domain-specific knowledge can be used to craft heuristic functions.
    This requires an understanding of the problem and what makes a good heuristic
    based on expert insights. For example, in the case of solving an eight-piece sliding
    puzzle with a 3×3 grid, a practical heuristic is the Manhattan distance, determined
    by adding the horizontal and vertical distances between each tile’s current position
    and its target location.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可以使用特定领域的知识来制定启发式函数。这需要对问题及其背后的知识有一定的理解，并根据专家见解判断什么样的启发式是好的。例如，在解决一个3×3格的八块滑动拼图问题时，一种实用的启发式是曼哈顿距离，通过将每个瓷砖当前位置和目标位置之间的水平和垂直距离相加来确定。
- en: '**Relaxation heuristics**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**松弛启发式**'
- en: This method involves simplifying a problem by temporarily ignoring certain constraints.
    Relaxation frequently results in an admissible heuristic because it tends to underestimate
    the actual cost. Take, for example, pathfinding problems, where one can use the
    Euclidean distance between two points as a heuristic, ignoring any obstacles that
    may lengthen the path.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通过暂时忽略某些约束来简化问题。松弛通常会导致可接受的启发式，因为它往往低估了实际代价。以路径查找问题为例，可以使用两点之间的欧几里得距离作为启发式，忽略可能延长路径的障碍物。
- en: '**Abstraction**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象化**'
- en: This method involves simplifying the problem representation by grouping or abstracting
    specific elements within it. Abstraction can lead to admissible and consistent
    heuristics. Consider, for example, a navigation problem, where you could choose
    to abstract the map by representing cities as nodes and major highways as edges,
    while ignoring smaller streets.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通过将问题中的特定元素进行分组或抽象化，简化问题表示。抽象化可以得到可接受且一致的启发式。以导航问题为例，你可以选择通过将城市表示为节点，主要高速公路表示为边，而忽略较小的街道来抽象化地图。
- en: '**Pattern databases**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式数据库**'
- en: In problems with large state spaces, where the graph includes numerous nodes
    and links (such as puzzle games), pattern databases can be employed to precompute
    heuristic values for subsets of the state space. These databases store the cost-to-goal
    for small subsets of the problem, and the heuristic for a given state is estimated
    as the sum of the costs associated with the relevant subsets.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有大状态空间的问题中，当图形包含大量节点和连接（例如谜题游戏）时，可以使用模式数据库来预计算状态空间子集的启发式值。这些数据库存储问题的小子集的目标代价，并且给定状态的启发式值是相关子集的代价之和。
- en: 'In the context of the graph shown in [Figure 7-4](chapter7.xhtml#fig7-4), we’ll
    employ a combination of abstraction and ad hoc heuristic approaches to estimate
    a set of h-scores that are both admissible and consistent. Since we lack additional
    information about the nodes, such as their coordinates, we’ll begin with a simplifying
    assumption (abstraction): all edges or links within the graph have the same weight
    or cost. Furthermore, we’ll assume this weight equals the smallest weight found
    within the graph (ad hoc). Our approach can be summarized as a three-step process:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-4](chapter7.xhtml#fig7-4)所示的图形上下文中，我们将采用抽象化和特定启发式方法的结合来估算一组既可接受又一致的h分数。由于我们缺乏关于节点的额外信息，例如它们的坐标，我们将从一个简化假设（抽象化）开始：图中的所有边或链接具有相同的权重或代价。此外，我们将假设这个权重等于图中找到的最小权重（特定）。我们的方法可以总结为一个三步过程：
- en: '1.  Edge weight assumption: Assume that all edges within the graph have an
    identical weight, and set this value to the smallest weight found within the graph.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  边权假设：假设图中的所有边具有相同的权重，并将该值设置为图中找到的最小权重。
- en: '2.  Minimum links count: For each node, determine the minimum number of edges
    or links needed to traverse from that node to the target node.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  最小链接数：对于每个节点，确定从该节点到目标节点所需的最小边数或链接数。
- en: '3.  H-score estimation: The h-score for each node is estimated by multiplying
    the smallest weight determined in step 1 with the minimum number of links needed
    to reach the target node, as found in step 2.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  H分数估算：每个节点的h分数通过将步骤1中确定的最小权重与步骤2中找到的到达目标节点所需的最小链接数相乘来估算。
- en: Given the relatively modest size of the graph, using this process to calculate
    h-scores is straightforward and quick. A brief examination of the weights reveals
    that the smallest one within the graph is 2 (for the link connecting nodes B and
    C). Now let’s consider nodes I and K, immediate neighbors of the target node J.
    Their h-scores will be 2 × 1 = 2, since both I and K are only one link away from
    the target. Similarly, h-scores for nodes E, F, G, H, and L, which are two links
    away from the target, can be estimated as 2 × 2 = 4\. Following this logical progression,
    the h-score for the starting node A, located farthest from the target, is estimated
    to be 2 × 4 = 8 because at least four links must be traversed to reach the target.
    Once these heuristic values are computed, you can easily incorporate them into
    the application’s getHScore() function, a lookup function that retrieves the h-score
    for a given node. (We’ll discuss this function later, along with the rest of the
    code.)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于图的相对较小的规模，使用此过程计算 h 分数既直接又快速。简要检查权重后发现，图中最小的权重是 2（连接节点 B 和 C 的链路）。现在让我们考虑目标节点
    J 的直接邻居节点 I 和 K。它们的 h 分数为 2 × 1 = 2，因为 I 和 K 距离目标节点仅一个链路。同样，离目标节点有两个链路的节点 E、F、G、H
    和 L 的 h 分数可以估算为 2 × 2 = 4。按照这个逻辑推理，起始节点 A 的 h 分数估算为 2 × 4 = 8，因为至少需要穿越四个链路才能到达目标。一旦这些启发式值计算出来，您可以轻松将它们纳入应用程序的
    getHScore() 函数，这是一个用于获取给定节点 h 分数的查找函数。（我们将在后面讨论这个函数，以及其余的代码。）
- en: Given our approach of utilizing the minimum number of links necessary to traverse
    from a given node to the target, along with our use of the smallest weight present
    in the graph for h-score calculation, the resulting h-scores meet the criterion
    of admissibility. They never overestimate the cost of reaching the target. I invite
    you to verify that these h-scores also meet the criterion of consistency as defined
    earlier in the section. You can do this either manually or by writing a few lines
    of code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们采用的最小链接数方法来从给定节点遍历到目标节点，并且我们使用图中最小的权重来计算 h 分数，最终得到的 h 分数符合可接受性标准。它们从不高估到达目标的成本。我邀请您验证这些
    h 分数是否也符合本节前面定义的一致性标准。您可以手动验证，也可以写几行代码进行验证。
- en: The Algorithm
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 算法
- en: 'Given our heuristic function, here are the steps we’ll take to find the optimal
    path between two nodes by using the A* algorithm. This method assumes that at
    least one valid route exists between the starting node and the target:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们的启发式函数，以下是使用 A* 算法找到两个节点之间的最佳路径的步骤。此方法假设从起始节点到目标节点之间至少存在一条有效路径：
- en: 1.  Initialize two mutable maps to keep track of the visited and the unvisited
    nodes, respectively. The visited map starts empty; the unvisited map starts with
    all nodes in the graph.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  初始化两个可变的地图，分别用于跟踪已访问节点和未访问节点。已访问地图开始为空；未访问地图开始时包含图中的所有节点。
- en: 2.  Initialize each unvisited node’s g-score and f-score to infinity (or the
    maximum possible value of the corresponding type) and its previous node property
    to “none.”
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将每个未访问节点的 g 分数和 f 分数初始化为无穷大（或对应类型的最大可能值），并将其前驱节点属性设置为“无”。
- en: 3.  Set the starting node’s g-score to 0 (as the journey starts here, no previous
    node exists to come from), calculate or look up its h-score, and set its f-score
    equal to its h-score (since g-score = 0). Leave its previous node property set
    to “none.”
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  将起始节点的 g 分数设置为 0（因为旅程从这里开始，之前没有节点可以来），计算或查找其 h 分数，并将其 f 分数设置为与其 h 分数相等（因为
    g 分数 = 0）。将其前驱节点属性设置为“无”。
- en: '4.  While the unvisited map is not empty:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  当未访问地图不为空时：
- en: a.  Select the node with the lowest f-score from the unvisited nodes and designate
    that as the current node. (The starting node will be the first current node.)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: a.  从未访问节点中选择 f 分数最低的节点，将其指定为当前节点。（起始节点将是第一个当前节点。）
- en: b.  If the current node is the target node, add the current node to the visited
    map and terminate the loop (the target has been reached).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: b.  如果当前节点是目标节点，将当前节点添加到已访问地图并终止循环（目标已达到）。
- en: c.  Otherwise (when the current node is not the target node), retrieve the current
    node’s neighbors from the graph.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: c.  否则（当当前节点不是目标节点时），从图中获取当前节点的邻居节点。
- en: d.  For each neighbor that has not already been visited, calculate a new g-score
    by adding the weight of the edge between the current node and the neighbor to
    the g-score of the current node. If this new g-score is lower than the neighbor’s
    existing g-score, update the neighbor’s attributes (g-score, f-score, previous
    node).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: d.  对于每个尚未访问的邻居，通过将当前节点与邻居之间边的权重加到当前节点的 g-score 上，计算新的 g-score。如果这个新的 g-score
    小于邻居的现有 g-score，则更新邻居的属性（g-score、f-score、前一个节点）。
- en: e.  Add the current node to the visited map and remove it from the unvisited
    map.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: e.  将当前节点添加到已访问地图，并将其从未访问地图中移除。
- en: 5.  Once the loop ends, the visited map is returned, which contains information
    about the nodes explored during the search, their directional relationship (as
    captured in the “previous node” property), and the associated costs (g-scores
    and f-scores).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  一旦循环结束，返回已访问地图，其中包含搜索过程中探索的节点信息、它们的方向关系（如“前一个节点”属性所示）以及相关的成本（g-score 和 f-score）。
- en: 6.  Use the information contained in the visited map to reconstruct the entire
    optimal path.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  使用已访问地图中的信息重建整个最优路径。
- en: These steps outline the essence of the A* algorithm. They involve maintaining
    an open set of nodes to be explored and a closed set of nodes that have been visited,
    and calculating the cost of each node based on the actual cost from the starting
    node (g-score) and the estimated cost to the target node (h-score). By iteratively
    selecting the node with the lowest total cost (f-score), the algorithm efficiently
    finds the shortest path from the starting node to the target node.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤概述了 A* 算法的本质。它们涉及保持一个待探索的开放节点集合和一个已访问的封闭节点集合，并根据从起始节点到当前节点的实际成本（g-score）和到目标节点的估算成本（h-score）计算每个节点的成本。通过反复选择具有最低总成本（f-score）的节点，算法高效地找到从起始节点到目标节点的最短路径。
- en: The time complexity of the A* search algorithm depends on the nature of the
    problem and the quality of the heuristic function used. In the worst case, the
    time complexity of A* is *O*(*b**^d*), where *b* is the branching factor (the
    average number of edges per node) and *d* is the depth of the shallowest target
    node (the minimum number of edges or steps needed to reach the target from the
    starting node). The space complexity of the standard A* algorithm depends on the
    data structure used for the open and closed lists (for example, this could be
    implemented by using priority queues). In the worst case, the space complexity
    can be very high, also up to *O*(*b**^d*), due to the storage of nodes in the
    open and closed lists.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: A* 搜索算法的时间复杂度取决于问题的性质和所使用启发式函数的质量。在最坏情况下，A* 的时间复杂度是 *O*(*b**^d*)，其中 *b* 是分支因子（每个节点的平均边数），*d*
    是最浅目标节点的深度（从起始节点到目标节点所需的最少边数或步骤数）。标准 A* 算法的空间复杂度取决于用于开放列表和封闭列表的数据结构（例如，可以使用优先队列来实现）。在最坏情况下，空间复杂度可能非常高，最多达到
    *O*(*b**^d*)，因为需要存储开放列表和封闭列表中的节点。
- en: A well-chosen (admissible and consistent) heuristic can significantly improve
    the performance of A*, however, by efficiently guiding the algorithm to the target
    node, reducing the search space, and potentially making the actual time and space
    complexities much lower in practice. In the best-case scenario, when the heuristic
    function is perfect and the algorithm efficiently explores the most promising
    paths first, for example, A* can have a time complexity of *O*(*d*).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 精心选择的（可接受的且一致的）启发式函数可以显著提高 A* 的性能，因为它能有效地引导算法向目标节点逼近，减少搜索空间，并可能在实际应用中大大降低时间和空间复杂度。在最好的情况下，当启发式函数完美且算法高效地优先探索最有前景的路径时，例如，A*
    的时间复杂度可以是 *O*(*d*)。
- en: The Code
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: The code for A* search is more involved than the code for DFS and BFS. For this
    reason, I’ll break it down into a number of segments, starting with the global
    declarations and the main() function.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: A* 搜索的代码比深度优先搜索（DFS）和广度优先搜索（BFS）的代码更复杂。因此，我会将其分解为多个部分，首先从全局声明和 main() 函数开始。
- en: '[PRE10]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This application doesn’t require an import block, as the search algorithm can
    be implemented without relying on any specialized library functions. The sole
    global component is a data class that holds three key attributes of a node: its
    g-score, its f-score, and the previous node along the optimal path.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序不需要导入块，因为搜索算法可以在不依赖任何专用库函数的情况下实现。唯一的全局组件是一个数据类，它包含节点的三个关键属性：g-score、f-score
    和沿着最优路径的前一个节点。
- en: In the main() function, we first define the graph shown in [Figure 7-4](chapter7.xhtml#fig7-4)
    as a Map ❶. Each node is specified in terms of its name ("A", "B", "C", and so
    on) along with an inner Map pairing each of the node’s neighbors with the weight
    of the edge leading to that neighbor. You can think of graph as a map of maps
    (similar to a list of lists) encapsulating all nodes in the network and their
    interconnections. Once the graph is defined, it’s printed by calling the displayGraph()
    function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在main()函数中，我们首先将[图7-4](chapter7.xhtml#fig7-4)中显示的图定义为一个Map❶。每个节点都通过其名称（“A”、“B”、“C”等）以及一个内部Map将每个节点的邻居与通向该邻居的边的权重进行配对来指定。你可以将图看作是一个包含所有节点及其相互连接的映射的映射（类似于列表的列表）。一旦图被定义，它将通过调用displayGraph()函数打印出来。
- en: We next define the start and target nodes ("A" and "J" in this example) and
    call the aStar() function by passing the start and target nodes and the graph
    to be searched as arguments ❷. A call to this function returns a list of visited
    nodes (visitedList) as a Map of type <String, List<Any>>. This list represents
    a subset of nodes that the algorithm explored while trying to locate the optimal
    path. Crucially, A* search doesn’t need to visit all nodes in the graph, as it
    relies on heuristic information to zoom in on the region that includes the optimal
    solution. We use the displayList() function to print this visited list and then
    call the displayShortestPath() function, which reconstructs and displays the optimal
    path.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义起始节点和目标节点（在此示例中为“A”和“J”），并通过传递起始节点、目标节点和要搜索的图作为参数调用aStar()函数❷。对该函数的调用返回一个已访问节点的列表（visitedList），它是一个类型为<String,
    List<Any>>的Map。该列表表示算法在尝试寻找最优路径时探索的节点子集。至关重要的是，A*搜索不需要访问图中的所有节点，因为它依赖启发式信息来聚焦于包含最优解的区域。我们使用displayList()函数打印该已访问列表，然后调用displayShortestPath()函数，重建并显示最优路径。
- en: '##### The Display Functions'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 显示函数'
- en: Let’s take a closer look at the various display helper functions called from
    the main() function, starting with the displayGraph() function, which prints the
    whole graph.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看一下从main()函数调用的各种显示辅助函数，首先是displayGraph()函数，它打印整个图。
- en: '[PRE11]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function takes in graph as its sole argument, which as we’ve seen is a
    Map of type <String, Map<String, Int>>. It uses two for loops to print the elements
    of graph. The outer loop cycles through the nodes, one at a time, printing each
    one. The inner loop extracts and prints each of the current node’s neighbors,
    along with the associated edge weights (labeled as Cost in the output). You’ll
    see how the output looks later when we examine the results.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将图作为唯一参数传入，正如我们所见，它是一个类型为<String, Map<String, Int>>的Map。它使用两个for循环打印图的元素。外循环逐个节点遍历，每次打印一个节点。内循环提取并打印当前节点的每个邻居，并附上相关的边的权重（在输出中标记为Cost）。稍后我们会查看结果时，你将看到输出的样子。
- en: Now we’ll consider the displayList() function, which prints the characteristics
    of each visited node after the A* search is complete.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看displayList()函数，它在A*搜索完成后打印每个已访问节点的特征。
- en: '[PRE12]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This simple function uses a for loop to extract and print the collection of
    visited nodes and their attributes. Each element in this list, which is presented
    as a Map object, has two components: the name of the visited node and a Node object
    with three data points linked to the node—its g-score (Int), f-score (Int), and
    the previous node (String). The latter is the node from which we would have departed
    to reach the current node, ensuring the minimum f-score for the current node.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数使用for循环提取并打印已访问节点及其属性的集合。该列表中的每个元素，呈现为一个Map对象，都有两个组成部分：已访问节点的名称和一个Node对象，后者包含与节点相关的三个数据点——其g-score（Int）、f-score（Int）以及前一个节点（String）。后者是我们为了到达当前节点而从中出发的节点，确保当前节点的最小f-score。
- en: 'Finally, here’s the displayShortestPath() function, which takes in the list
    of visited nodes, the start node, and the target node, and identifies the optimal
    path:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是displayShortestPath()函数，它接受已访问节点的列表、起始节点和目标节点，并确定最优路径：
- en: '[PRE13]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The function reconstructs the path in reverse, working backward from the target
    to the starting node. We start by initializing two variables to targetNode: currentNode,
    representing the current position in the path, and path, where the entire path
    is built up node by node. We then enter a while loop that iterates until currentNode
    becomes startNode. In the loop, we access currentNode from the list of visited
    nodes (supplied as a Map of type <String, Node>) and use its previousNode property
    to look up its previous node ❶. Next, we concatenate previousNode with the current
    value of path ❷ and update currentNode to previousNode for the next iteration.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过逆向重建路径，从目标节点回溯到起始节点。我们首先初始化两个变量为 targetNode：currentNode，表示路径中的当前节点，以及 path，表示通过节点逐步构建的完整路径。然后，我们进入一个
    while 循环，直到 currentNode 变为 startNode。在循环中，我们从已访问节点的列表（以 <String, Node> 类型的 Map
    提供）中访问 currentNode，并使用它的 previousNode 属性查找其前一个节点 ❶。接下来，我们将 previousNode 与当前的 path
    值连接起来 ❷，并更新 currentNode 为 previousNode，以便进入下一次迭代。
- en: After the loop ends, we retrieve cost, the g-score of the target node, from
    the list of visited nodes, using targetNode as the key. We then print the reconstructed
    optimal path and its cost.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 循环结束后，我们从已访问的节点列表中获取目标节点的 g-score（即成本），使用 targetNode 作为键。然后，我们打印重建的最优路径及其成本。
- en: The aStar() Function and Its Helpers
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: aStar() 函数及其辅助函数
- en: Let’s now dive into the core of the A* algorithm implemented in aStar() and
    its helper functions. This code very closely follows the steps outlined earlier
    for implementing the A* algorithm.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解 A* 算法的核心实现，位于 aStar() 函数及其辅助函数中。这段代码紧密遵循了前面解释的实现 A* 算法的步骤。
- en: '[PRE14]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The algorithm begins by creating two mutable maps: visited and unvisited. At
    first, unvisited contains all the nodes in the graph, each initialized with the
    maximum possible g-score and f-score, and with a previous node of "none" ❶. The
    visited map, which is initially empty, keeps track of the nodes that have been
    visited. Next, the startNode in the unvisited map is updated to have a g-score
    of 0 and an f-score equivalent to its h-score ❷, which is retrieved with the getHScore()
    helper function. As shown here, this helper is implemented as a simple lookup
    function:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 算法开始时创建两个可变映射：visited 和 unvisited。一开始，unvisited 包含图中的所有节点，每个节点的 g-score 和 f-score
    初始化为最大值，且前一个节点为 "none" ❶。visited 映射初始为空，用来跟踪已访问的节点。接下来，将 unvisited 中的 startNode
    更新为 g-score 为 0，f-score 等于其 h-score ❷，该值通过 getHScore() 辅助函数获取。如下面所示，这个辅助函数实现为一个简单的查找函数：
- en: '[PRE15]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These scores were estimated by using the hybrid three-step process explained
    earlier. Note that the h-score for the target node "J" is 0.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分数是通过前面解释的混合三步法估算得出的。请注意，目标节点 "J" 的 h-score 为 0。
- en: 'Returning to the aStar() function, we next display the list of unvisited nodes
    and enter a while loop that continues until the unvisited map is empty or the
    target node is reached ❸. Within the loop, currentNode is set to the unvisited
    node with the minimum f-score by using the getCurrentNode() helper function ❹.
    Here’s how that helper function is implemented by using Kotlin’s built-in .minByOrNull
    method:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 aStar() 函数后，我们接下来展示未访问节点的列表，并进入一个 while 循环，直到未访问映射为空或目标节点被找到 ❸。在循环中，currentNode
    通过使用 getCurrentNode() 辅助函数设置为具有最小 f-score 的未访问节点 ❹。下面是该辅助函数的实现，它使用 Kotlin 内建的
    .minByOrNull 方法：
- en: '[PRE16]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Back in aStar(), we check if currentNode is the same as targetNode ❺. If it
    is, we add the current node to the visited map and break the loop. Otherwise,
    for each neighbor of the current node not already in the visited map ❻, we calculate
    a new g-score by adding the edge weight to the current node’s g-score. If the
    new g-score is lower than the neighbor’s current g-score ❼, the neighbor’s attributes
    in the unvisited map are updated: its g-score is set to newGScore, its f-score
    is set to its new g-score, plus its h-score (again retrieved with the getHScore()
    function), and its previous node is set to currentNode.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 aStar() 函数中，我们检查当前节点（currentNode）是否与目标节点（targetNode）相同 ❺。如果相同，我们将当前节点添加到已访问的映射中，并跳出循环。否则，对于当前节点的每个相邻节点（该节点尚未在已访问映射中）❻，我们通过将边的权重加到当前节点的
    g-score 来计算一个新的 g-score。如果新的 g-score 小于相邻节点当前的 g-score ❼，则更新该相邻节点在未访问映射中的属性：将它的
    g-score 设置为 newGScore，将它的 f-score 设置为新的 g-score 加上它的 h-score（再次通过 getHScore()
    函数获取），并将它的前一个节点设置为 currentNode。
- en: After processing all neighbors, the currentNode is added to the visited map
    and removed from the unvisited map. When the while loop terminates, the visited
    map is returned with all the information needed to reconstitute the optimal path.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完所有邻居后，currentNode被添加到已访问映射中，并从未访问映射中移除。当while循环终止时，返回已访问映射，并包含重建最优路径所需的所有信息。
- en: The Result
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: We’re now ready to run the code and have a look at its console output.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备运行代码并查看其控制台输出。
- en: '[PRE17]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output starts by printing the entire graph, node by node, along with each
    node’s neighbors and edge weights. Next, the initial state of the unvisited map
    is shown after updating the starting node’s attributes. Apart from node "A", each
    node should have the maximum possible g- and f-scores (2147483647) and a previous
    node of "none". Once the target node is reached, a message is printed before exiting
    the while loop. Then the final list of all visited nodes is printed. Looking over
    the list, we can see that not every node as been visited—nodes "L" and "M", representing
    a dead end, were skipped. Notice also that the target node’s g-score is the same
    as its f-score because its h-score is 0\. Also, as expected, all g-scores are
    less than or equal to their corresponding f-scores. This is because the f-score
    is the sum of the g-score and the h-score, and the latter is assumed to be greater
    than or equal to 0.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 输出首先打印整个图，逐个节点，以及每个节点的邻居和边的权重。接下来，更新起始节点属性后的未访问映射的初始状态被显示出来。除了节点 "A" 外，每个节点应该具有最大的g分数和f分数（2147483647），并且前一个节点是"none"。一旦目标节点被到达，程序会打印一条消息，然后退出while循环。接着，打印出所有已访问节点的最终列表。查看列表时，我们可以看到并非每个节点都被访问——节点"L"和"M"代表死胡同，被跳过了。还要注意，目标节点的g分数与其f分数相同，因为它的h分数为0。并且，正如预期的那样，所有g分数都小于或等于相应的f分数。这是因为f分数是g分数和h分数之和，而后者假定大于或等于0。
- en: Finally, the terminal output shows the step-by-step process of reconstructing
    the optimal path, followed by the full path and its total associated cost.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，终端输出展示了重建最优路径的逐步过程，接着是完整路径及其相关的总成本。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we explored some representative concepts and algorithms from
    two related domains: sorting and searching. These essential concepts and tools
    have extensive use in the realms of computer and data science, particularly in
    the context of information retrieval from databases, search engine performance
    optimization, data visualization, data mining, machine learning, and network routing.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了来自排序和搜索两个相关领域的一些代表性概念和算法。这些基本概念和工具在计算机和数据科学领域有广泛的应用，特别是在从数据库中检索信息、搜索引擎性能优化、数据可视化、数据挖掘、机器学习和网络路由的背景下。
- en: Within the domain of sorting, we implemented the insertion sort, merge sort,
    and quick sort algorithms and gained insight into their respective strengths,
    weaknesses, time and space complexities, and stability characteristics. In the
    searching domain, our projects revolved around navigating graph data structures.
    We implemented the depth-first search (DFS), breadth-first search (BFS), and A*
    algorithms.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在排序领域，我们实现了插入排序、归并排序和快速排序算法，并深入了解了它们各自的优缺点、时间和空间复杂度以及稳定性特征。在搜索领域，我们的项目围绕图数据结构展开。我们实现了深度优先搜索（DFS）、广度优先搜索（BFS）和A*算法。
- en: Throughout these projects, we harnessed the power of various Kotlin features,
    including both stack and queue data structures, as well as lists, maps, and more
    intricate constructs like maps of maps. Last but not least, by tackling the exercises,
    you’ll not only solidify your grasp of these core concepts but also raise your
    sorting and searching skills to a professional level.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些项目中，我们利用了各种Kotlin特性的强大功能，包括堆栈和队列数据结构，以及列表、映射和更复杂的构造，如映射的映射。最重要的是，通过完成这些练习，你不仅能巩固对这些核心概念的理解，还能将你的排序和搜索技能提升到专业水平。
- en: Resources
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: 'Bhargava, Aditya Y. *Grokking Algorithms*. 2nd ed. Shelter Island, NY: Manning,
    2024.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'Bhargava, Aditya Y. *算法启蒙*. 第2版. Shelter Island, NY: Manning, 2024年。'
- en: 'Cormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.
    *Introduction to Algorithms*. 4th ed. Cambridge, MA: MIT Press, 2022.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cormen, Thomas H., Charles E. Leiserson, Ronald L. Rivest, 和 Clifford Stein.
    *算法导论*. 第4版. 剑桥，MA: MIT出版社，2022年。'
- en: 'Even, Shimon. *Graph Algorithms*. 2nd ed., edited by Guy Even. New York: Cambridge
    University Press, 2012.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'Even, Shimon. *图算法*. 第2版，编辑：Guy Even. 纽约: 剑桥大学出版社，2012年。'
- en: 'Heineman, George, Gary Pollice, and Stanley Selkow. *Algorithms in a Nutshell*.
    2nd ed. Sebastopol, CA: O’Reilly, 2016.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 'Heineman, George, Gary Pollice, 和 Stanley Selkow. *算法概览*. 第二版. 美国加利福尼亚州塞巴斯托波尔市:
    O''Reilly出版社, 2016年。'
- en: 'Kopec, David. *Classic Computer Science Problems in Python*. Shelter Island,
    NY: Manning, 2019.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 'Kopec, David. *Python中的经典计算机科学问题*. 美国纽约州Shelter Island市: Manning出版社, 2019年。'
- en: 'Skiena, Steven. *The Algorithm Design Manual*. 3rd ed. Cham, Switzerland: Springer
    Nature, 2020.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'Skiena, Steven. *算法设计手册*. 第三版. 瑞士Cham: Springer Nature出版社, 2020年。'
- en: 'Wengrow, Jay. *A Common-Sense Guide to Data Structures and Algorithms*. 2nd
    ed. Raleigh, NC: The Pragmatic Bookshelf, 2020.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 'Wengrow, Jay. *数据结构与算法的常识指南*. 第二版. 美国北卡罗来纳州罗利市: Pragmatic Bookshelf出版社, 2020年。'
