- en: '## **13'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **13'
- en: EXTENDING GHIDRA’s WORLDVIEW**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 Ghidra 的世界观**
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: One of the things we hope for from a high-quality reverse engineering tool is
    fully automated identification and annotation of as much of a binary as possible.
    In ideal cases, 100 percent of instructions are identified and grouped into 100
    percent of the original functions that compose the binary. Each of these functions
    would have a name and a full prototype, and all data manipulated by the functions
    would also be identified to include full understanding of the original data types
    used by the programmers. This is precisely Ghidra’s goal, beginning with the initial
    import of a binary and continuing through auto analysis, at which point anything
    that Ghidra was unable to accomplish becomes an exercise for its user.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从高质量的逆向工程工具中获得的一项功能是能够完全自动地识别并注释尽可能多的二进制内容。在理想情况下，100% 的指令会被识别，并归入构成二进制文件的
    100% 原始函数中。这些函数每一个都会有名称和完整的原型，所有由函数操作的数据也会被识别，包括对程序员使用的原始数据类型的完全理解。这正是 Ghidra
    的目标，从初始导入二进制文件开始，经过自动分析，Ghidra 无法完成的任何部分将变成用户的任务。
- en: In this chapter, we look at the techniques Ghidra uses to identify various constructs
    within binaries and discuss how you can enhance its ability to do so. We begin
    with a discussion of the initial loading and analysis processes. The choices you
    make during these steps help determine what resources Ghidra will bring to the
    table for the file you are analyzing. This is your opportunity to provide Ghidra
    with information that it may have failed to detect automatically so that Ghidra’s
    analysis stages can make more informed decisions. Following that, we will look
    at how Ghidra utilizes word models, data types, and function identification algorithms,
    and how each of these may be enhanced to tailor its performance to your particular
    RE application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Ghidra 用于识别二进制文件中各种结构的技术，并讨论如何增强其识别能力。我们首先讨论初始加载和分析过程。你在这些步骤中的选择有助于确定
    Ghidra 为你分析的文件提供哪些资源。这是一个向 Ghidra 提供它可能未能自动检测到的信息的机会，这样 Ghidra 的分析阶段就能做出更明智的决策。随后，我们将讨论
    Ghidra 如何利用字模型、数据类型和函数识别算法，以及如何增强这些算法以根据你的特定逆向工程应用来定制其性能。
- en: '**Importing Files**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**导入文件**'
- en: During the import, the dialog shown in [Figure 13-1](ch13.xhtml#fig13_1) presents
    Ghidra’s initial analysis of the file’s identity, which will guide the file-loading
    process. You can override any of the fields or proceed with the recommendations
    Ghidra has made. The additional options, accessed with the Options . . . button,
    are specific to the type of file being loaded. [Figure 13-1](ch13.xhtml#fig13_1)
    shows options for a PE file, and [Figure 13-2](ch13.xhtml#fig13_2) shows options
    for loading an ELF binary.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入过程中，显示在[图 13-1](ch13.xhtml#fig13_1)中的对话框呈现了 Ghidra 对文件身份的初步分析，这将指导文件加载过程。你可以覆盖任何字段，或者按照
    Ghidra 的建议继续操作。通过“选项...”按钮访问的附加选项是特定于所加载文件类型的。[图 13-1](ch13.xhtml#fig13_1) 显示了
    PE 文件的选项，[图 13-2](ch13.xhtml#fig13_2) 显示了加载 ELF 二进制文件的选项。
- en: '![image](Images/fig13-1.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-1.jpg)'
- en: '*Figure 13-1: Import dialog and options for a PE file*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-1：PE 文件的导入对话框和选项*'
- en: '![image](Images/fig13-2.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-2.jpg)'
- en: '*Figure 13-2: Import dialog and options for an ELF binary*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-2：ELF 二进制文件的导入对话框和选项*'
- en: '**LANGUAGE/COMPILER SPECIFICATIONS**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言/编译器规格**'
- en: 'The Language field in [Figures 13-1](ch13.xhtml#fig13_1) and [13-2](ch13.xhtml#fig13_2)
    dictates exactly how Ghidra will interpret any bytes recognized as machine code
    within the file you are loading. The language/compiler specification is composed
    of three to five colon-separated subfields, as described here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-1](ch13.xhtml#fig13_1) 和 [13-2](ch13.xhtml#fig13_2) 中的语言字段决定了 Ghidra
    如何解释在你加载的文件中识别为机器代码的字节。语言/编译器规格由三个到五个冒号分隔的子字段组成，如下所述：'
- en: The processor name field names the processor type for which the binary was built.
    It directs Ghidra to a specific subdirectory under *Ghidra/Processors*.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器名称字段指定了二进制文件构建所使用的处理器类型。它将 Ghidra 定向到 *Ghidra/Processors* 目录下的特定子目录。
- en: The endian field indicates the endianness of the binary’s processor, which is
    either little-endian (LE) or big-endian (BE).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节序字段表示二进制文件处理器的字节序，它可以是小端字节序（LE）或大端字节序（BE）。
- en: The architecture size (bitness) field usually coincides with the size of a pointer
    for the chosen processor (16/32/64 bits).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构大小（位数）字段通常与所选处理器的指针大小一致（16/32/64 位）。
- en: The processor variant/mode field is used to choose a specific model of the selected
    processor or identify a specific mode of operation. For example, when the x86
    processor is selected, we can choose modes System Management Mode, Real Mode,
    Protected Mode, or default. For the ARM processor, we can choose models v4, v4T,
    v5, v5T, v6, Cortex, v7, v8 or v8T, among others.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器变种/模式字段用于选择所选处理器的特定型号或标识特定的操作模式。例如，当选择 x86 处理器时，我们可以选择系统管理模式、实模式、保护模式或默认模式。对于
    ARM 处理器，我们可以选择 v4、v4T、v5、v5T、v6、Cortex、v7、v8 或 v8T 等型号。
- en: When known, the compiler field names the compiler, or in some cases a calling
    convention, that was used to compile the binary. Valid names include *windows*,
    *gcc*, *borlandcpp*, *borlanddelphi*, and *default*.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已知，编译器字段会列出用于编译二进制文件的编译器，或者在某些情况下，列出用于编译的调用约定。有效的名称包括*windows*、*gcc*、*borlandcpp*、*borlanddelphi*和*default*。
- en: '[Figure 13-3](ch13.xhtml#fig13_3) breaks down the language identifier ARM:LE:32:v7:default
    into its component subfields. One of a loader’s most important jobs is to infer
    a correct language/compiler specification.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-3](ch13.xhtml#fig13_3)将语言标识符 ARM:LE:32:v7:default 分解为其组成的子字段。加载器最重要的任务之一就是推断正确的语言/编译器规范。'
- en: '![image](Images/fig13-3.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-3.jpg)'
- en: '*Figure 13-3: Language/compiler specification example*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-3：语言/编译器规范示例*'
- en: 'The Format option specifies which loader Ghidra will use to import the file.
    Ghidra relies on a loader’s detailed knowledge of a particular file format to
    identify characteristics of the file and choose the proper plugins to use for
    analysis. A well-written loader recognizes specific content or structural features
    to identify the file’s type, architecture, and, hopefully, the compiler that was
    used to create the binary. Information about the compiler can enhance function
    identification. To fingerprint a compiler, a loader examines the structure of
    a binary to look for compiler-specific characteristics (like number, name, position,
    and ordering of program sections) or searches the binary for compiler-specific
    byte sequences (like blocks of code or strings). For example, it is not uncommon
    to find version strings in binaries compiled using `gcc`—for example, *GCC: (Ubuntu
    7.3.0-27ubuntu1~18.04) 7.3.0*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '格式选项指定 Ghidra 用于导入文件的加载器。Ghidra 依赖于加载器对特定文件格式的详细了解，以识别文件的特征并选择用于分析的正确插件。一个写得很好的加载器能够识别文件的类型、架构，并且希望能够识别用于创建该二进制文件的编译器。有关编译器的信息有助于增强函数识别。为了指纹识别编译器，加载器会检查二进制文件的结构，寻找特定于编译器的特征（例如，程序段的数量、名称、位置和顺序），或搜索二进制文件中的特定编译器字节序列（如代码块或字符串）。例如，在使用`gcc`编译的二进制文件中，找到版本字符串并不罕见——例如，*GCC:
    (Ubuntu 7.3.0-27ubuntu1~18.04) 7.3.0*。'
- en: When Ghidra has completed the loading process, an Import Results Summary window
    is displayed, as shown in [Figure 13-4](ch13.xhtml#fig13_4).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ghidra 完成加载过程后，会显示一个导入结果摘要窗口，如[图 13-4](ch13.xhtml#fig13_4)所示。
- en: '![image](Images/fig13-4.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-4.jpg)'
- en: '*Figure 13-4: Import Results Summary window for an ELF binary*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-4：ELF 二进制文件的导入结果摘要窗口*'
- en: This summary identifies an ELF Required Library, *lib.so.6* ➊. (Note that this
    library would not be listed as a requirement if the file were statically linked.)
    More than one library file may be listed when an executable depends on multiple
    shared libraries. Understanding which libraries a program depends on can help
    direct you to resources you may need while analyzing the program. For example,
    if *libssl.so* or *libcrypto.so* appears in the list of required libraries, you
    might want to locate OpenSSL documentation and possibly source code. We discuss
    how Ghidra can make use of source code later in this chapter. Once a file has
    been successfully imported, you can auto analyze the file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此摘要标识了一个 ELF 必需的库，*lib.so.6* ➊。（请注意，如果该文件是静态链接的，这个库不会作为依赖项列出。）当可执行文件依赖多个共享库时，可能会列出多个库文件。了解程序依赖哪些库可以帮助你在分析程序时找到可能需要的资源。例如，如果*libssl.so*
    或 *libcrypto.so* 出现在所需库列表中，你可能需要查找 OpenSSL 文档并可能需要源代码。本章后面会讨论 Ghidra 如何使用源代码。一旦文件成功导入，你可以自动分析该文件。
- en: '### **Analyzers**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '### **分析器**'
- en: '*Auto analysis* is accomplished by a collection of cooperating analysis tools
    (analyzers) that are activated either manually (for example, when opening a new
    file) or automatically when a change that can affect the resulting disassembly
    is detected. Analyzers run sequentially in a prioritized order based on the type
    of analyzer because the changes an analyzer makes can affect subsequent analyzers.
    For example, the stack analyzers cannot look at functions until a function analyzer
    has looked at all calls and created the functions. We investigate this hierarchy
    in more detail in [Chapter 15](ch15.xhtml#ch15) when we build an analyzer.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动分析*是通过一组协同工作的分析工具（分析器）完成的，这些工具可以手动激活（例如，当打开一个新文件时），或者在检测到可能影响最终反汇编的更改时自动激活。分析器按优先级顺序依次运行，因为分析器所做的更改可能会影响后续的分析器。例如，堆栈分析器在函数分析器查看所有调用并创建函数之前无法查看函数。我们将在[第15章](ch15.xhtml#ch15)中更详细地探讨这个层次结构，当我们构建一个分析器时。'
- en: When you open a new file in the CodeBrowser and choose to auto analyze it, Ghidra
    presents a list of analyzers that can be run on that file. The list of default
    and optional analyzers is dependent on file information provided by the loader
    (which is also displayed to the user as part of the import summary, as shown in
    [Figure 13-4](ch13.xhtml#fig13_4)). For example, the Windows x86 PE RTTI Analyzer
    would not be of much use in analyzing an ELF or ARM binary. Default analyzer selections
    can be modified using the Edit ▸ Tool Options menu.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在CodeBrowser中打开一个新文件并选择自动分析时，Ghidra会显示一个可以在该文件上运行的分析器列表。默认和可选分析器的列表取决于加载器提供的文件信息（这些信息也作为导入摘要的一部分显示给用户，如[图13-4](ch13.xhtml#fig13_4)所示）。例如，Windows
    x86 PE RTTI分析器在分析ELF或ARM二进制文件时就不太有用了。默认的分析器选择可以通过“编辑 ▸ 工具选项”菜单进行修改。
- en: Some analyzers are also available as one-shot options by using the Analysis
    ▸ One Shot menu in the CodeBrowser. An analyzer appears in the list if it supports
    one-shot use and applies to the type of file being analyzed. One-shot analysis
    is useful for running analyzers that were not selected during the initial auto
    analysis, or for rerunning an analyzer after new information has been located
    that might benefit from additional analysis. For example, if you receive a missing
    PDB error message during initial analysis, you can locate the PDB file and then
    run the PDB analyzer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些分析器也可以通过使用CodeBrowser中的“分析 ▸ 一次性”菜单作为一次性选项使用。如果分析器支持一次性使用并且适用于正在分析的文件类型，它就会出现在列表中。一次性分析对于运行在初始自动分析过程中未选择的分析器非常有用，或者在找到新信息可能从额外分析中受益时重新运行分析器。例如，如果在初始分析过程中收到缺少PDB的错误消息，你可以找到PDB文件，然后运行PDB分析器。
- en: The Analyze All Open option on the CodeBrowser ▸ Analysis menu analyzes all
    open files in the project at once, using the list of analyzers selected in Edit
    ▸ Tool Options. If all of the open files in the project have the same architecture
    (language/compiler specification), all of the files will be analyzed. Any files
    that do not match the architecture of the current file will not be included in
    the analysis. This ensures that the analyzers are consistent with the type of
    file being analyzed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: CodeBrowser ▸ 分析菜单中的“分析所有打开的文件”选项一次性分析项目中所有打开的文件，使用在“编辑 ▸ 工具选项”中选择的分析器列表。如果项目中所有打开的文件具有相同的架构（语言/编译器规范），则所有文件都将被分析。任何与当前文件架构不匹配的文件将不会包含在分析中。这确保了分析器与正在分析的文件类型一致。
- en: Many CodeBrowser tools, including analyzers, rely on various artifacts in order
    to identify important constructs in a file. Fortunately for us, we can extend
    many of these artifacts to improve Ghidra’s capabilities. We will start with a
    discussion of word model files and how they are used to identify special strings
    and types of strings within search results.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 许多CodeBrowser工具，包括分析器，依赖于各种工件来识别文件中的重要结构。幸运的是，我们可以扩展这些工件来增强Ghidra的功能。我们将从讨论单词模型文件以及它们如何用于在搜索结果中识别特殊字符串和字符串类型开始。
- en: '**Word Models**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**单词模型**'
- en: A *word model* provides a way to identify special strings and types of strings
    you’re interested in searching for, such as known identifiers, email addresses,
    directory pathnames, file extensions, and so on. When your string search is associated
    with a word model, the String Search results window will include a column called
    IsWord that specifies whether the found string is a word according to the word
    model. Defining strings of interest as valid words and then filtering for valid
    words is a good way to prioritize strings for further inspection.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*词模型*提供了一种识别你感兴趣的特殊字符串和字符串类型的方式，例如已知的标识符、电子邮件地址、目录路径名、文件扩展名等等。当你的字符串搜索与词模型相关联时，字符串搜索结果窗口将包含一个名为IsWord的列，用于指示找到的字符串是否根据词模型被视为一个词。将感兴趣的字符串定义为有效的词，然后筛选有效的词是一个很好的方法，可以优先考虑对这些字符串进行进一步检查。'
- en: At a high level, a word model uses training sets of valid strings to determine
    that “if trigram X (a sequence of three characters) appears in a sequence Y of
    length Z, then there is a probability, P, that Y is a word.” The resulting probability
    is used indirectly as a threshold to determine if the string should be considered
    a valid word during analysis.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，词模型使用有效字符串的训练集来确定“如果三元组X（一个由三个字符组成的序列）出现在长度为Z的序列Y中，那么Y是一个词的概率为P”。该概率被间接地用作阈值，以确定在分析过程中是否应将字符串视为有效词。
- en: '*StringModel.sng*, seen in [Figure 13-5](ch13.xhtml#fig13_5), is the default
    word model file for string searches in Ghidra.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*StringModel.sng*，如[图13-5](ch13.xhtml#fig13_5)所示，是Ghidra中字符串搜索的默认词模型文件。'
- en: '![image](Images/fig13-5.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-5.jpg)'
- en: '*Figure 13-5: Search for Strings dialog*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-5：字符串搜索对话框*'
- en: 'The following excerpt from the *StringModel.sng* file shows the format of a
    valid word model file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*StringModel.sng*文件的一个摘录，展示了有效词模型文件的格式：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first 12 lines in the file are metadata comments about the model. In this
    example, the model type ➊ is `lowercase`, which likely means the model does not
    distinguish between upper- and lowercase letters. The names of the training files
    used for this model are listed ➋. The names generally indicate the content: *contractions.txt*
    is likely a file of valid contractions, like *can’t*. Four lines ➌ describe the
    notation for some nonprinting ASCII characters used in the trigrams. The actual
    trigram list starts ➍, where each entry row contains the three characters in the
    trigram followed by a value that is used in determining the probability that the
    trigram is part of a word.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的前12行是关于模型的元数据注释。在这个例子中，模型类型➊是`lowercase`，这可能意味着模型不区分大小写字母。用于此模型的训练文件的名称列在➋处。文件名称通常表明内容：*contractions.txt*很可能是一个有效缩写的文件，例如*can’t*。四行注释➌描述了在三元组中使用的一些不可打印ASCII字符的符号。实际的三元组列表从➍开始，每一行条目包含三元组中的三个字符，后面跟着一个值，用于确定该三元组是否为一个词的一部分的概率。
- en: You can supplement or replace the default word model by editing *StringModel.sng*
    or creating new model files and storing them in *Ghidra/Features/Base/data/stringngrams*
    and then selecting the new file in the Word Model field in the Search for Strings
    dialog. There are many reasons to modify word models, like including strings specific
    to known malware families or detecting words in languages other than English.
    Ultimately, word models provide a powerful means to control the types of strings
    that Ghidra recognizes as higher priority by tagging them in the Strings window.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编辑*StringModel.sng*或创建新的模型文件并将它们存储在*Ghidra/Features/Base/data/stringngrams*中，来补充或替换默认的词模型，然后在字符串搜索对话框的词模型字段中选择新文件。有很多理由修改词模型，比如包括特定于已知恶意软件家族的字符串，或检测英语以外语言中的词汇。最终，词模型提供了一种强大的手段，通过在字符串窗口中标记它们来控制Ghidra识别为更高优先级的字符串类型。
- en: In a similar manner, we can edit and extend the data types that Ghidra recognizes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以编辑并扩展Ghidra识别的数据类型。
- en: '**Data Types**'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: The Data Type Manager allows us to manage all of the data types associated with
    a file. Ghidra lets you reuse data type definitions by storing them in *data type
    archive files*. Each root node in the Data Type Manager window is a data type
    archive. [Figure 13-6](ch13.xhtml#fig13_6) shows a Data Type Manager window with
    three data type archives selected by the Ghidra loader.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型管理器允许我们管理与文件相关的所有数据类型。Ghidra通过将数据类型定义存储在*数据类型归档文件*中，允许你重用数据类型定义。数据类型管理器窗口中的每个根节点都是一个数据类型归档。[图13-6](ch13.xhtml#fig13_6)显示了一个数据类型管理器窗口，其中选择了三个数据类型归档。
- en: '![image](Images/fig13-6.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-6.jpg)'
- en: '*Figure 13-6: Data Type Manager window*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-6：数据类型管理器窗口*'
- en: The BuiltInTypes archive is always listed. This archive includes all (and only)
    types that are modeled within Ghidra by Java classes that implement the `ghidra.program.model.data.BuiltInDataType`
    interface. Ghidra searches for every such class within its classpath in order
    to populate this archive.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: BuiltInTypes档案始终会列出。该档案包括所有（且仅包括）由实现`ghidra.program.model.data.BuiltInDataType`接口的Java类在Ghidra中建模的类型。Ghidra会在其类路径中查找每个这样的类，以便填充此档案。
- en: The second archive is specific to the file that is being analyzed, and the archive
    shares the file’s name. In this case, the archive is associated with the file
    *global_array_demo_x64*. The checkmark next to the archive indicates that it is
    associated with the active file. Initially, Ghidra populates this archive with
    data types specific to the file’s format (for example, PE- or ELF-related data
    types). During auto analysis, Ghidra copies additional types, from the other archives,
    into this one when they are recognized to be in use in the program. In other words,
    this archive contains the subset of all data types, known to the Data Type Manager,
    that happen to be in use in the current program. This archive is also the home
    to any custom data types that you choose to create in Ghidra, as discussed in
    “[Creating Structures with Ghidra](ch08.xhtml#ch08lev156)” on [page 166](ch08.xhtml#page_166).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个档案是特定于正在分析的文件的，且该档案与文件名相同。在这种情况下，档案与文件*global_array_demo_x64*相关联。档案旁边的勾选框表示它与当前活动文件相关联。最初，Ghidra会使用特定于文件格式的数据类型（例如，PE或ELF相关的数据类型）填充该档案。在自动分析过程中，Ghidra会将其他档案中的数据类型复制到此档案中，前提是它们被识别为当前程序中正在使用的数据类型。换句话说，这个档案包含了所有已知数据类型管理器的子集，这些数据类型恰好在当前程序中使用。这个档案也是你在Ghidra中选择创建的任何自定义数据类型的存放地，具体内容可以参考[《使用Ghidra创建结构体》](ch08.xhtml#ch08lev156)，详见[第166页](ch08.xhtml#page_166)。
- en: 'The third archive provides the 64-bit ANSI C function prototypes and C library
    data types. This particular archive contains information extracted from the standard
    C library headers of a 64-bit Linux system and is one of several platform-specific
    archives in a default Ghidra installation. It is present because this particular
    binary has a library dependency on *libc.so.6*, as indicated in [Figure 13-4](ch13.xhtml#fig13_4).
    A default Ghidra installation has four additional platform-specific data archives,
    located in the *Ghidra/Features/Base/data/typeinfo* directory under a subdirectory
    specific to the platform. The filenames indicate the platforms they support: *generic_clib.gdt*,
    *generic_clib_64.gdt*, *mac_osx.gdt*, *windows_vs12_32.gdt*, and *windows_vs12_64.gdt*.
    (The *.gdt* extension is used for all Ghidra data type archives.)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个档案提供了64位ANSI C函数原型和C库数据类型。这个特定的档案包含从64位Linux系统的标准C库头文件中提取的信息，是默认Ghidra安装中的几个平台特定档案之一。之所以存在，是因为这个特定的二进制文件有一个库依赖，依赖于*libc.so.6*，如[图13-4](ch13.xhtml#fig13_4)所示。默认的Ghidra安装有四个额外的特定平台数据档案，这些档案位于*Ghidra/Features/Base/data/typeinfo*目录下的一个平台特定的子目录中。文件名指示它们支持的平台：*generic_clib.gdt*、*generic_clib_64.gdt*、*mac_osx.gdt*、*windows_vs12_32.gdt*和*windows_vs12_64.gdt*。（*.gdt*扩展名用于所有Ghidra数据类型档案。）
- en: In addition to the archives that the Ghidra loader selects automatically, you
    can add your own data type archives as nodes in the Data Type Manager window.
    For demonstration purposes, [Figure 13-7](ch13.xhtml#fig13_7) shows the Data Type
    Manager window after all of the default *.gdt* files have been added to the Data
    Types list. The right side of the figure shows the menu for manipulating archives
    and data types. Additional archives are loaded using the Open File Archive menu
    option, which opens a file browser for you to select an archive of interest.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Ghidra加载器自动选择的档案外，你还可以将自己的数据类型档案添加为数据类型管理器窗口中的节点。为了演示，[图13-7](ch13.xhtml#fig13_7)展示了在所有默认的*.gdt*文件被添加到数据类型列表后，数据类型管理器窗口的样子。图的右侧显示了用于操作档案和数据类型的菜单。额外的档案通过“打开文件档案”菜单选项加载，该选项会打开文件浏览器供你选择感兴趣的档案。
- en: To add new built-in types to the BuiltInTypes archive, add corresponding *.class*
    files to Ghidra’s classpath. If you add types while Ghidra is running, you must
    Refresh BuiltInTypes (see [Figure 13-7](ch13.xhtml#fig13_7)) in order for them
    to appear. The refresh operation causes Ghidra to rescan its classpath to find
    any newly added `BuiltInDataType` classes. The inquisitive reader may find numerous
    examples of built-in types in their Ghidra source distribution at *Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新的内置类型添加到BuiltInTypes归档中，请将相应的*.class*文件添加到Ghidra的类路径中。如果在Ghidra运行时添加类型，您必须刷新BuiltInTypes（见[图13-7](ch13.xhtml#fig13_7)），才能使它们显示出来。刷新操作会导致Ghidra重新扫描其类路径，以查找任何新添加的`BuiltInDataType`类。好奇的读者可能会在其Ghidra源代码分发包中找到大量内置类型的示例，路径为*Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data*。
- en: '![image](Images/fig13-7.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-7.jpg)'
- en: '*Figure 13-7: Data Type Manager with all standard archives loaded and options
    menu expanded*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-7：数据类型管理器，所有标准归档已加载，选项菜单已展开*'
- en: '***Creating New Data Type Archives***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建新的数据类型归档***'
- en: It’s impossible to anticipate every data type that you may encounter while analyzing
    binaries. The archives included in your Ghidra distribution include data types
    culled from the most commonly used libraries on Windows (Windows SDK) and Unix
    (C library) systems. When Ghidra doesn’t contain information on the data types
    used in a program you’re analyzing, it offers you the ability to create new data
    type archives, populate them in a variety of ways, and share them with others.
    In the following sections, we discuss the three ways you are likely to create
    new data type archives.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析二进制文件时，无法预见您可能遇到的所有数据类型。您在Ghidra分发包中包含的归档包含了来自Windows（Windows SDK）和Unix（C库）系统中最常用库的数据类型。当Ghidra未包含您正在分析的程序中使用的数据类型信息时，它提供了创建新数据类型归档的功能，可以通过多种方式填充它们，并与其他人共享。在接下来的章节中，我们将讨论您可能创建新数据类型归档的三种方式。
- en: '**Parsing C Header Files**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**解析C头文件**'
- en: One of the most common sources for data type information is C header files.
    Assuming you have the header files you need, or take the time to create them yourself,
    you can create your own data type archive by using the C-Parser plugin to extract
    the information from an existing C header file. For example, if you frequently
    find yourself analyzing binaries that link against the OpenSSL cryptographic library,
    you might download the OpenSSL source code and ask Ghidra to parse the included
    header files to create an archive of OpenSSL data types and function signatures.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型信息最常见的来源之一是C头文件。假设您拥有所需的头文件，或者花时间自己创建它们，您可以使用C-Parser插件从现有的C头文件中提取信息，创建自己的数据类型归档。例如，如果您经常分析与OpenSSL加密库链接的二进制文件，您可以下载OpenSSL源代码，并要求Ghidra解析其中的头文件，以创建一个包含OpenSSL数据类型和函数签名的归档。
- en: This process is not nearly as straightforward as it might seem. Header files
    are often littered with macros designed to influence the behavior of a compiler
    based on the compiler being used and the operating system and architecture being
    targeted. For example, the C structure
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程远没有看起来那么简单。头文件通常充满了宏，用于根据所使用的编译器、操作系统和架构来影响编译器的行为。例如，C结构体
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: occupies 8 bytes when compiled on a 32-bit system and 16 bytes when compiled
    on a 64-bit system. This variability poses a problem for Ghidra, which is attempting
    to act as the universal preprocessor, and it is up to you to guide Ghidra through
    the parsing process to create a useful archive. When the time comes to use your
    archive with Ghidra, you must have ensured that the archive was created in a manner
    compatible with the binary you are analyzing (that is, don’t load 64-bit archives
    to help you analyze a 32-bit file).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位系统上编译时占用8个字节，在64位系统上编译时占用16个字节。这种可变性给Ghidra带来了问题，因为Ghidra试图充当通用预处理器，您需要引导Ghidra完成解析过程，以创建一个有用的归档。当您需要将归档与Ghidra一起使用时，必须确保归档的创建方式与您正在分析的二进制文件兼容（也就是说，不要将64位归档加载到帮助分析32位文件时）。
- en: To parse one or more C header files, select File ▸ Parse C Source in the CodeBrowser
    to open the dialog shown in [Figure 13-8](ch13.xhtml#fig13_8). The source files
    to parse section provides an ordered list of header files for the plugin to parse.
    The order is important, as the data types and preprocessor directives from one
    file become available for the next file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析一个或多个 C 头文件，请在 CodeBrowser 中选择 文件 ▸ 解析 C 源代码，打开[图 13-8](ch13.xhtml#fig13_8)所示的对话框。待解析的源文件部分提供了一个按顺序排列的头文件列表，供插件解析。顺序很重要，因为一个文件中的数据类型和预处理指令会在下一个文件中生效。
- en: The Parse Options box provides a list of options, similar to compiler command
    line options, that influence the behavior of the C-Parser plugin. The parser recognizes
    only the `-I` (include directory) and `-D` (define a macro) options understood
    by most compilers. Ghidra offers a number of preprocessor configurations, in the
    form of *.prf* files, that you can choose from to provide reasonable defaults
    for common operating system and compiler combinations. You can also customize
    any of the available configurations or create your own from scratch and save them
    to your own *.prf* for future use. A common change to the parser options is to
    correctly set the architecture that you want the C-Parser to target, as all of
    the supplied configurations target x86\. For example, you might change `-D_X86_`
    in a Linux-oriented configuration to `-D__ARMEL__` if you are analyzing little-endian
    ARM binaries.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 解析选项框提供了一系列选项，类似于编译器命令行选项，影响 C 解析器插件的行为。解析器仅识别大多数编译器理解的 `-I`（包含目录）和 `-D`（定义宏）选项。Ghidra
    提供了多种预处理器配置，形式为 *.prf* 文件，您可以从中选择，以为常见的操作系统和编译器组合提供合理的默认设置。您还可以自定义任何可用的配置，或从头开始创建自己的配置，并将其保存到自己的
    *.prf* 文件中，以便将来使用。常见的解析器选项更改是正确设置您希望 C 解析器针对的架构，因为所有提供的配置都针对 x86。例如，如果您正在分析小端
    ARM 二进制文件，您可能会将面向 Linux 的配置中的 `-D_X86_` 更改为 `-D__ARMEL__`。
- en: The plugin’s output can be merged into the current active file with the Parse
    to Program button or stored in a separate Ghidra data type archive file (*.gdt*)
    with Parse to File. Additional information about the C-Parser can be found in
    Ghidra Help.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的输出可以通过“解析到程序”按钮合并到当前活动文件中，或通过“解析到文件”存储在一个单独的 Ghidra 数据类型归档文件（*.gdt*）中。有关
    C 解析器的更多信息，请参阅 Ghidra 帮助。
- en: '![image](Images/fig13-8.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-8.jpg)'
- en: '*Figure 13-8: Parse C Source dialog*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-8：解析 C 源代码对话框*'
- en: '**Creating a New File Archive**'
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建新的文件归档**'
- en: As an alternative to parsing C headers files, you might want to capture custom
    data types that you create while analyzing a file into an archive that can be
    shared with other Ghidra users or used in other Ghidra projects. The Data Type
    Manager’s New File Archive option (refer to [Figure 13-7](ch13.xhtml#fig13_7))
    asks you to select a filename and save location, and then creates a new, empty
    archive that is listed in the Data Type Manager window. You can add new types
    to the archive by using the techniques described in “[Creating Structures with
    Ghidra](ch08.xhtml#ch08lev156)” on [page 166](ch08.xhtml#page_166). Once your
    archive is created, you may share it with other Ghidra users or use it in your
    other Ghidra projects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解析 C 头文件的替代方法，您可能希望将分析文件时创建的自定义数据类型捕获到一个归档文件中，以便与其他 Ghidra 用户共享或在其他 Ghidra
    项目中使用。数据类型管理器的“新建文件归档”选项（参见[图 13-7](ch13.xhtml#fig13_7)）要求您选择文件名和保存位置，然后创建一个新的空归档，该归档会列在数据类型管理器窗口中。您可以使用在“[使用
    Ghidra 创建结构体](ch08.xhtml#ch08lev156)”（第 166 页）中描述的技术将新的类型添加到归档中。归档创建后，您可以与其他 Ghidra
    用户共享它，或在您的其他 Ghidra 项目中使用它。
- en: '##### **Creating a New Project Archive**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '##### **创建新的项目归档**'
- en: A project data archive exists only within the project in which it was created.
    This may be useful if you expect to reuse custom data types in more than one file
    within a project but never expect to use the data types outside your project.
    Within the Data Type Manager, the New Project Archive option (refer to [Figure
    13-7](ch13.xhtml#fig13_7)) asks you to select a folder within your project to
    hold your new archive, and then creates a new, empty archive that is listed in
    the Data Type Manager window. As with the other data type archives, you can add
    new types to the archive as needed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 项目数据归档仅存在于创建它的项目中。如果您期望在项目中多个文件之间重用自定义数据类型，但不打算在项目外部使用这些数据类型，这可能会很有用。在数据类型管理器中，“新建项目归档”选项（参见[图
    13-7](ch13.xhtml#fig13_7)）要求您选择项目中的一个文件夹来存放新的归档，然后创建一个新的空归档，并将其列出在数据类型管理器窗口中。与其他数据类型归档一样，您可以根据需要向归档中添加新类型。
- en: '**Function IDs**'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**功能 ID**'
- en: 'When you set out to reverse engineer any binary, the last thing you want to
    do is waste time reverse engineering library functions whose behavior you could
    learn much more easily by simply reading a man page, reading some source code,
    or doing a little internet research. Unfortunately, statically linked binaries
    blur the distinction between application code and library code: entire libraries
    are combined with application code to form a single, monolithic executable file.
    Fortunately for us, Ghidra has tools to recognize and mark library code, regardless
    of whether the code was taken from a library archive or is simply the result of
    code reuse across multiple binaries, allowing us to focus our attention on the
    unique code within the application. The *Function ID analyzer* recognizes many
    common library functions using function signatures included with Ghidra, and you
    can extend the function signature databases by using the Function ID plugin.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始逆向工程任何二进制文件时，最不希望做的事情就是浪费时间逆向工程那些你可以通过简单地阅读手册页、查看一些源代码或做一点互联网研究就能更容易了解其行为的库函数。不幸的是，静态链接的二进制文件模糊了应用程序代码和库代码之间的区别：整个库与应用程序代码结合，形成一个单一的、庞大的可执行文件。幸运的是，Ghidra
    提供了工具来识别和标记库代码，无论这些代码是来自库归档文件还是仅仅是通过跨多个二进制文件的代码重用生成的，这使我们能够将注意力集中在应用程序中的独特代码上。*函数
    ID 分析器*使用 Ghidra 提供的函数签名识别许多常见的库函数，并且你可以通过使用函数 ID 插件来扩展函数签名数据库。
- en: 'The Function ID analyzer works with Function ID databases (FidDbs) that use
    a hierarchy of hash values to characterize functions. A full hash (which is intended
    to be resilient against changes that might be introduced by the linker) and a
    specific hash (which helps differentiate between variants of functions) are computed
    for each function. The major difference between the two is that the specific hash
    may include the specific values of any constant operands (based on a heuristic),
    whereas the full hash does not. The combination of the two hashes coupled with
    information about any associated parent and child functions forms a fingerprint
    for each library function, which is recorded in an FidDb. The Function ID analyzer
    derives the same type of fingerprint for each function in the binary you are analyzing
    and compares it against all known fingerprints in relevant FidDbs. When a match
    is found, Ghidra recovers the function’s original name from the FidDb, applies
    the appropriate label to the function under analysis, adds the function to the
    Symbol Tree window, and updates the function’s plate comment. The following is
    a sample plate comment for the `_malloc` function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 ID 分析器与使用哈希值层次结构来描述函数的函数 ID 数据库（FidDb）配合使用。每个函数都会计算一个完整哈希（旨在抵御链接器可能引入的变化）和一个特定哈希（帮助区分函数的不同变种）。这两者之间的主要区别在于，特定哈希可能包括任何常量操作数的具体值（基于启发式方法），而完整哈希则不包括。两个哈希值的结合，再加上关于任何关联父函数和子函数的信息，形成了每个库函数的指纹，这些指纹被记录在
    FidDb 中。函数 ID 分析器为你正在分析的二进制文件中的每个函数生成相同类型的指纹，并将其与相关 FidDb 中所有已知的指纹进行比较。当找到匹配项时，Ghidra
    会从 FidDb 中恢复该函数的原始名称，将适当的标签应用到正在分析的函数上，添加该函数到符号树窗口，并更新该函数的注释。以下是 `_malloc` 函数的示例注释：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Information about functions in a FidDb are stored hierarchically and include
    a name, version, and variant. The variant field is used to encode information
    such as compiler settings, which affect the hashes but aren’t part of the version
    number.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: FidDb 中的函数信息是以层次结构存储的，包括名称、版本和变体。变体字段用于编码诸如编译器设置之类的信息，这些信息会影响哈希值，但不属于版本号的一部分。
- en: The Function ID analyzer offers several options, accessible when you select
    the analyzer in the Auto Analysis dialog, to control its behavior, as shown in
    [Figure 13-9](ch13.xhtml#fig13_9). Instruction count threshold is a tunable threshold
    designed to reduce false positives from random matches against small functions.
    False positives occur when a function is incorrectly matched to a library function.
    False negatives occur when a function is not matched to a library function but
    should be. The threshold roughly represents the minimum number of instructions
    that a function, its parents, and its children must contain (combined) in order
    to be considered for a match. Refer to *Scoring and Disambiguation* in Ghidra
    Help for more information on match scores.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 功能ID分析器提供了多个选项，可以在自动分析对话框中选择分析器来控制其行为，如[图13-9](ch13.xhtml#fig13_9)所示。指令计数阈值是一个可调节的阈值，旨在减少与小函数进行随机匹配时的假阳性。假阳性是指一个函数错误地匹配到一个库函数。假阴性是指一个函数没有与库函数匹配，但本应匹配。该阈值大致表示一个函数、其父函数和子函数（合计）必须包含的最小指令数，以便被考虑匹配。有关匹配分数的更多信息，请参阅Ghidra帮助中的*评分与消歧*。
- en: '![image](Images/fig13-9.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-9.jpg)'
- en: '*Figure 13-9: Auto analysis options*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-9：自动分析选项*'
- en: Since the actual functionality within a binary is generally contained in functions,
    the ability to extend function signatures is paramount to minimizing duplication
    of effort, and this work is facilitated by the Function ID plugin.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二进制文件中的实际功能通常包含在函数中，因此扩展函数签名的能力对于减少重复工作至关重要，而这一工作由功能ID插件来促进。
- en: '**Function ID Plugin**'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**功能ID插件**'
- en: The *Function ID plugin* (not to be confused with the Function ID analyzer)
    allows you to create, modify, and control associations for FidDbs. This plugin
    is not enabled in a default Ghidra installation. To enable it, select **File**
    ▸ **Configure** from the CodeBrowser window and then click the checkbox for Function
    ID. Choose **Configure** within the Function ID description and select the **FidPlugin**
    to see additional information about actions associated with the plugin, as shown
    in [Figure 13-10](ch13.xhtml#fig13_10).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*功能ID插件*（与功能ID分析器不同）允许您创建、修改和控制FidDb的关联。默认的Ghidra安装中未启用此插件。要启用它，请从CodeBrowser窗口选择**文件**
    ▸ **配置**，然后勾选功能ID的复选框。在功能ID描述中选择**配置**，并选择**FidPlugin**以查看与插件相关的其他操作信息，如[图13-10](ch13.xhtml#fig13_10)所示。'
- en: '![image](Images/fig13-10.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-10.jpg)'
- en: '*Figure 13-10: FidPlugin details*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-10：FidPlugin详细信息*'
- en: Once enabled, the Function ID plugin is controlled via the CodeBrowser’s Tools
    ▸ Function ID menu, as shown in [Figure 13-11](ch13.xhtml#fig13_11).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 启用后，功能ID插件通过CodeBrowser的工具 ▸ 功能ID菜单进行控制，如[图13-11](ch13.xhtml#fig13_11)所示。
- en: '![image](Images/fig13-11.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-11.jpg)'
- en: '*Figure 13-11: CodeBrowser Function ID submenu*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-11：CodeBrowser功能ID子菜单*'
- en: 'Before we walk through an example of using the Function ID plugin to extend
    Ghidra signatures, let’s briefly discuss the five new menu options:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过示例演示如何使用功能ID插件扩展Ghidra签名之前，先简要讨论五个新的菜单选项：
- en: '**Choose active FidDbs** Displays a list of active Function ID databases. Each
    may be selected or deselected using an associated checkbox.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择活动FidDb** 显示一个活动功能ID数据库的列表。每个数据库都可以通过关联的复选框进行选择或取消选择。'
- en: '**Create new empty FidDb** Allows you to create and name a new Function ID
    database. The new FidDb will be listed when Choose active FidDbs is selected.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建新的空FidDb** 允许您创建并命名一个新的功能ID数据库。创建的新FidDb将在选择“选择活动FidDb”时列出。'
- en: '**Attach existing FidDb** Displays a file chooser dialog that lets you add
    an existing FidDb to the list of active FidDbs. After you add the FidDb, you can
    select Choose active FidDbs to see the added FidDb listed.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加现有FidDb** 显示一个文件选择对话框，让您将现有的FidDb添加到活动FidDb列表中。添加FidDb后，您可以选择“选择活动FidDb”以查看已添加的FidDb。'
- en: '**Detach existing FidDb** Can be applied to only FidDbs that have been manually
    attached. The operation removes the association between the selected FidDb and
    the current Ghidra instance.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**分离现有FidDb** 仅适用于已手动附加的FidDb。此操作将移除所选FidDb与当前Ghidra实例之间的关联。'
- en: '**Populate FidDb from programs** Generates new function fingerprints to add
    to an existing FidDb. The dialog in [Figure 13-12](ch13.xhtml#fig13_12) is used
    to control this process, and its use will be discussed shortly.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**从程序填充FidDb** 生成新的函数指纹并将其添加到现有的FidDb中。[图13-12](ch13.xhtml#fig13_12)中的对话框用于控制此过程，稍后将讨论其使用方法。'
- en: '![image](Images/fig13-12.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-12.jpg)'
- en: '*Figure 13-12: Populate Fid Database dialog*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-12：填充 Fid 数据库对话框*'
- en: '***Function ID Plugin Example: UPX***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***函数 ID 插件示例：UPX***'
- en: When we auto analyze binaries that contain very few functions outside of library
    functions that Ghidra recognizes, our reverse engineering task is somewhat simplified.
    We can focus on the subset of functions that Ghidra fails to recognize under the
    assumption that this is where the new, interesting functionality lies. Our task
    is much more challenging when Ghidra can’t identify any functions. When we (human
    analysts) recognize functions and extend Ghidra’s ability to recognize those same
    functions in the future, we reduce our future workload. Let’s walk through a demonstration
    of how powerful this sort of extension can be.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们自动分析的二进制文件中，除了 Ghidra 识别的库函数外，几乎没有其他函数时，我们的逆向工程任务相对简化。我们可以集中精力处理 Ghidra 未能识别的函数，假设新且有趣的功能就在这里。当
    Ghidra 完全无法识别任何函数时，我们的任务变得更加具有挑战性。当我们（人工分析员）识别出这些函数并扩展 Ghidra 未来识别这些函数的能力时，我们减少了未来的工作量。接下来，我们将演示这种扩展是多么强大。
- en: Let’s assume we load a 64-bit Linux ELF binary into Ghidra and auto analyze
    the file. The resulting Symbol Tree entries are shown in [Figure 13-13](ch13.xhtml#fig13_13).
    We use the Symbol Tree to navigate to the entry point and examine the code. Our
    initial analysis leads us to believe that the binary is packed using *the Ultimate
    Packer for eXecutatbles (UPX)* and that the functions we are seeing were added
    by the UPX packer to unpack the binary at runtime. We confirm this hypothesis
    by comparing the bytes we see in `entry` with published bytes for the UPX entry
    point function. (Alternatively, we could create our own UPX-packed binary for
    comparison.) Now, we add this information to our FidDb so that we don’t have to
    perform this same analysis should we ever encounter another UPX-packed 64-bit
    Linux binary.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将一个 64 位的 Linux ELF 二进制文件加载到 Ghidra 中并自动分析该文件。生成的符号树条目如[图 13-13](ch13.xhtml#fig13_13)所示。我们使用符号树导航到入口点并检查代码。我们初步分析认为，该二进制文件使用*Ultimate
    Packer for eXecutables (UPX)* 进行打包，且我们看到的函数是 UPX 打包器添加的，用于在运行时解包二进制文件。我们通过将 `entry`
    中看到的字节与已发布的 UPX 入口函数的字节进行对比，确认了这一假设。（另外，我们也可以创建自己的 UPX 打包二进制文件进行对比。）现在，我们将这些信息添加到我们的
    FidDb 中，这样以后遇到其他 UPX 打包的 64 位 Linux 二进制文件时，我们就不必再进行相同的分析。
- en: '![image](Images/fig13-13.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-13.jpg)'
- en: '*Figure 13-13: Suspected UPX packer functions for* upx_demo1_x64_static.upx'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-13：疑似 UPX 压缩程序函数，用于* upx_demo1_x64_static.upx'
- en: Functions you add to an FidDb should have meaningful names. Accordingly, we
    change the names of the functions in our example to indicate that they are part
    of a UPX packer, as shown in [Figure 13-14](ch13.xhtml#fig13_14), and then add
    these functions to a new Function ID database so that Ghidra can label the functions
    appropriately in the future.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加到 FidDb 的函数应该有意义的名称。因此，我们将示例中的函数名称更改为表示它们是 UPX 压缩程序的一部分，如[图 13-14](ch13.xhtml#fig13_14)所示，然后将这些函数添加到一个新的函数
    ID 数据库中，以便 Ghidra 在未来能正确标记这些函数。
- en: '![image](Images/fig13-14.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-14.jpg)'
- en: '*Figure 13-14: Labeled UPX packer functions for* upx_demo1_x64_static.upx'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-14：已标记的 UPX 压缩程序函数，用于* upx_demo1_x64_static.upx'
- en: We create a new FidDb by selecting **Tools** ▸ **Function ID** ▸ **Create new
    empty FidDb** and then name the new FidDb *UPX.fidb*. Next, we populate our new
    database with information extracted from the updated binary by selecting **Tools**
    ▸ **Function ID** ▸ **Populate FidDb** from programs. Enter information about
    the FidDb in the resulting dialog, as shown in [Figure 13-15](ch13.xhtml#fig13_15).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过选择**工具** ▸ **函数 ID** ▸ **创建新的空 FidDb** 来创建一个新的 FidDb，并命名为*UPX.fidb*。接下来，我们通过选择**工具**
    ▸ **函数 ID** ▸ **从程序填充 FidDb**，将从更新后的二进制文件中提取的信息填充到新的数据库中。在弹出的对话框中输入 FidDb 信息，如[图
    13-15](ch13.xhtml#fig13_15)所示。
- en: '![image](Images/fig13-15.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-15.jpg)'
- en: '*Figure 13-15: Populate Fid Database dialog*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-15：填充 Fid 数据库对话框*'
- en: 'The purpose of each field and the values we have entered are described here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述了每个字段的目的以及我们输入的值：
- en: '**Fid Database** *UPX.fidb* is the name of our new FidDb. The pull-down list
    allows you to choose from among all of the FidDbs you have created.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fid 数据库** *UPX.fidb* 是我们新创建的 FidDb 的名称。下拉列表允许你从已创建的所有 FidDb 中进行选择。'
- en: '**Library Family Name** Choose a name that describes the library from which
    you are extracting function data. In our case, we have input *UPX*.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**库的名称** 选择一个能够描述你提取函数数据的库名称。在我们的例子中，我们输入了*UPX*。'
- en: '**Library Version** This can be a version number or a platform name or a combination
    of both. Since UPX is available for many platforms, we chose the library version
    based on the architecture of the binary.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**库版本** 此字段可以是版本号、平台名称或两者的组合。由于 UPX 适用于许多平台，我们根据二进制文件的架构选择了库版本。'
- en: '**Library Variant** This field may be used for any additional information that
    distinguishes this library from others of the same version. In this example, we
    used the commit ID for this version of UPX from the UPX repository on GitHub (*[https://github.com/upx/](https://github.com/upx/)*).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**库变种** 此字段可用于任何其他信息，用以区分同一版本的其他库。在本例中，我们使用了来自 GitHub 上 UPX 仓库的该版本 UPX 的提交
    ID（*[https://github.com/upx/](https://github.com/upx/)*）。'
- en: '**Base Library** Here you may reference another FidDb that Ghidra will use
    to establish parent/child relationships. We did not use a base library, as UPX
    is completely self-contained.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础库** 在此，您可以引用另一个 FidDb，Ghidra 将用它来建立父/子关系。我们没有使用基础库，因为 UPX 是完全自包含的。'
- en: '**Root Folder** This field names a Ghidra project folder. All files in the
    chosen folder will be processed during the function ingest process. In this case,
    we chose */UPX* from the pull-down menu.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**根文件夹** 此字段命名一个 Ghidra 项目文件夹。选定文件夹中的所有文件将在功能摄取过程中进行处理。在本例中，我们从下拉菜单中选择了 */UPX*。'
- en: '**Language** This contains the Ghidra language identifier associated with the
    new FidDb. To be processed from the root folder, a file’s language identifier
    must match this value. This entry is populated from the Imports Results Summary
    window for the binary, but may be modified using the button to the right of the
    text box.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言** 此项包含与新 FidDb 相关联的 Ghidra 语言标识符。要从根文件夹进行处理，文件的语言标识符必须与此值匹配。此项内容来自二进制文件的导入结果摘要窗口，但可以使用文本框右侧的按钮进行修改。'
- en: '**Common Symbols File** This field names a file containing a list of functions
    that should be excluded from the ingest process. This field is unused in this
    case.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用符号文件** 此字段指定包含应从摄取过程中排除的功能列表的文件。此字段在本例中未使用。'
- en: When we click OK, the ingest process begins. When it’s complete, we see the
    results of the FidDb population ([Figure 13-16](ch13.xhtml#fig13_16)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击“确定”时，摄取过程开始。当完成后，我们将看到 FidDb 填充的结果（[图 13-16](ch13.xhtml#fig13_16)）。
- en: '![image](Images/fig13-16.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-16.jpg)'
- en: '*Figure 13-16: Results window from UPX FidDb population*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-16：来自 UPX FidDb 填充的结果窗口*'
- en: Once the new FidDb is created, Ghidra can use it to identify functions in any
    binary you are analyzing. We demonstrate this by loading a new UPX packed 64-bit
    Linux ELF binary, *upx_demo2_x64_static.upx*, and auto analyze the file *without*
    the Function ID analyzer. The resulting Symbol Tree, shown in [Figure 13-17](ch13.xhtml#fig13_17),
    shows five unidentified functions, as we expect.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新 FidDb 被创建，Ghidra 就可以使用它来识别您正在分析的任何二进制文件中的功能。我们通过加载一个新的 UPX 打包的 64 位 Linux
    ELF 二进制文件 *upx_demo2_x64_static.upx*，并在没有功能 ID 分析器的情况下对文件进行自动分析来演示这一过程。结果符号树，如[图
    13-17](ch13.xhtml#fig13_17)所示，显示了五个未识别的功能，正如我们预期的那样。
- en: '![image](Images/fig13-17.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-17.jpg)'
- en: '*Figure 13-17: Symbol Tree entry for* upx_demo2_x64_static.upx *before Function
    ID analyzer*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-17：* upx_demo2_x64_static.upx *在功能 ID 分析器前的符号树条目*'
- en: Running Function ID as a one-shot analyzer (Analysis ▸ One Shot ▸ Function ID)
    results in the Symbol Tree shown in [Figure 13-18](ch13.xhtml#fig13_18), which
    includes the UPX function names.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 运行功能 ID 作为一次性分析器（分析 ▸ 一次性 ▸ 功能 ID）会生成[图 13-18](ch13.xhtml#fig13_18)中所示的符号树，其中包括
    UPX 功能名称。
- en: '![image](Images/fig13-18.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-18.jpg)'
- en: '*Figure 13-18: Symbol Tree entry for* upx_demo2_x64_static.upx *after Function
    ID analyzer*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 13-18：* upx_demo2_x64_static.upx *在功能 ID 分析器后的符号树条目*'
- en: 'The analyzer also updates the Listing window with new function names and plate
    comments, like the plate comment for `UPX_1` shown next. This plate comment contains
    the information that we provided when creating the FidDb:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器还会更新列出窗口，显示新的功能名称和板块注释，类似于接下来展示的 `UPX_1` 的板块注释。这个板块注释包含了我们在创建 FidDb 时提供的信息：
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating new FidDbs is only the beginning of extending Ghidra’s function identification
    capabilities. You can analyze parameters associated with a function and save them
    in a Data Type archive. Then, when Function ID correctly identifies the function,
    you can drag the appropriate Data Type Manager entry onto the function in the
    Listing window, and the function prototype will be updated with the appropriate
    parameters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的FidDb只是扩展Ghidra函数识别功能的开始。你可以分析与函数相关的参数，并将其保存在数据类型档案中。然后，当Function ID正确识别函数时，你可以将相应的数据类型管理器条目拖动到列表窗口中的函数上，函数原型就会更新为适当的参数。
- en: '***Function ID Plugin Example: Profiling a Static Library***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Function ID插件示例：静态库分析***'
- en: 'When you are reverse engineering a statically linked binary, one of the first
    things you may wish for is an FidDb that matches the functions linked into that
    binary, so that Ghidra can identify the library code and save you the effort of
    analyzing it. The following example addresses two important questions: (1) how
    can you know whether you have such an FidDb, and (2) what can you do if you don’t
    have one? The answer to the first question is simple: Ghidra ships with at least
    a dozen FidDbs (in the form of *.fidbf* files), all related to Visual Studio library
    code. If the binary is not a Windows binary and you have not yet created or imported
    any FidDbs, you’ll need to make your own FidDb by using the Ghidra Function ID
    plugin (which addresses the second question).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你逆向工程一个静态链接的二进制文件时，你可能首先希望得到一个与该二进制文件中链接的函数相匹配的FidDb，这样Ghidra就能识别出库代码，节省你分析的精力。以下示例解答了两个重要问题：（1）如何知道你是否拥有这样的FidDb？（2）如果没有FidDb，该怎么办？第一个问题的答案很简单：Ghidra自带至少十几个FidDb（以*.fidbf*文件的形式），这些都与Visual
    Studio的库代码相关。如果二进制文件不是Windows二进制文件，而且你还没有创建或导入任何FidDb，那么你需要通过使用Ghidra的Function
    ID插件来自己制作一个FidDb（这也解决了第二个问题）。
- en: The most important thing to understand when populating a new FidDb is that you
    need an input source that has a high probability of matching against any binaries
    you plan to apply the FidDb against. In the UPX example, we had a binary that
    contained code that our intuition told us we might see again in the future. In
    a common static linking case, we have a binary and we simply want to match as
    much code in that binary as possible.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在填充新的FidDb时，最重要的一点是你需要一个输入源，它应该有较高的概率与任何你打算应用FidDb的二进制文件匹配。在UPX示例中，我们有一个包含我们直觉上可能在未来再次遇到的代码的二进制文件。在常见的静态链接情况下，我们有一个二进制文件，目标是尽可能匹配这个二进制文件中的所有代码。
- en: There are a variety of ways to recognize that you’re dealing with a statically
    linked binary. Within Ghidra, look at the *Imports* folder within the Symbol Tree.
    This folder will be empty for a fully statically linked binary with no need for
    imported functions. A partially statically linked binary may have some imports,
    so you can look for copyright or version strings from well-known libraries in
    the Defined Strings window.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以识别你正在处理的是一个静态链接的二进制文件。在Ghidra中，查看符号树中的*Imports*文件夹。对于一个完全静态链接的二进制文件，文件夹会为空，因为它不需要导入函数。部分静态链接的二进制文件可能有一些导入，因此你可以在“已定义字符串”窗口中查找来自著名库的版权或版本字符串。
- en: 'On the command line, you can use simple utilities like `file` and `strings`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，你可以使用简单的工具，如`file`和`strings`：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output of `file` informs us that the binary is statically linked, stripped
    of any symbols, and from a Linux system. (A stripped binary contains no familiar
    names to clue us in to the behavior of any of the functions.) Filtering the output
    of `strings` using `grep GCC` identifies the compiler, GCC 7.4.0, as well as the
    Linux distribution, Ubuntu 18.04.1, used to build the binary. (You can locate
    the same information with CodeBrowser’s Search ▸ Program Text functionality using
    *GCC* as a qualifier.) It’s likely this binary was linked with *libc.a*,^([1](footnotes.xhtml#ch13fn1))
    so we take a copy of *libc.a* from Ubuntu 18.04.1 and use it as the starting point
    for recovering symbols in our stripped binary. (Additional strings in the binary
    might lead us to select additional static libraries for the Function ID analysis;
    however, we limit this example to *libc.a*.)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`命令的输出告诉我们，该二进制文件是静态链接的，已剥离符号，并且来自Linux系统。（一个剥离符号的二进制文件不包含任何熟悉的名称，因此无法通过函数名推测其行为。）使用`grep
    GCC`过滤`strings`命令的输出可以识别编译器GCC 7.4.0以及用于构建该二进制文件的Linux发行版Ubuntu 18.04.1。（你也可以使用CodeBrowser的搜索功能，选择程序文本并使用*GCC*作为过滤条件，来获取相同的信息。）很可能这个二进制文件是与*libc.a*链接的，^([1](footnotes.xhtml#ch13fn1))因此我们从Ubuntu
    18.04.1中复制*libc.a*，并将其作为恢复剥离符号的起点。（二进制文件中的其他字符串可能会促使我们选择更多静态库进行函数ID分析；但在此示例中，我们仅限于使用*libc.a*。）'
- en: To use *libc.a* to populate an FidDb, Ghidra must identify the instructions
    and functions that it contains. The archive (hence *.a*) file format defines a
    container for other files, most commonly for object files (*.o*) that a compiler
    might extract and link into an executable. Ghidra’s process for importing container
    files differs from its process for importing single binaries, so when we import
    *libc.a* with File ▸ Import, as we usually do when importing a single file, Ghidra
    offers alternate import modes, as shown in [Figure 13-19](ch13.xhtml#fig13_19).
    (These other options are also available from the File menu.)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用*libc.a*来填充FidDb，Ghidra必须识别其中包含的指令和函数。归档（即*.a*）文件格式定义了一个容器，通常用于存储对象文件（*.o*），这些文件可能被编译器提取并链接到可执行文件中。Ghidra导入容器文件的过程与导入单个二进制文件的过程不同，因此当我们使用“文件
    ▸ 导入”来导入*libc.a*时，Ghidra会提供其他导入模式，如[图13-19](ch13.xhtml#fig13_19)所示。（这些选项也可以通过文件菜单选择。）
- en: '![image](Images/fig13-19.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-19.jpg)'
- en: '*Figure 13-19: Importing a container file*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-19：导入容器文件*'
- en: Single File mode asks Ghidra to import the container as if it was a single file.
    Since the container is not an executable file, Ghidra is likely to suggest the
    Raw Binary format for your import and perform minimal automated analysis. In File
    System mode, Ghidra opens a file browser window (see [Figure 13-20](ch13.xhtml#fig13_20))
    to display the contents of the container file. In this mode, you may choose any
    combination of files from the container to import into Ghidra using options from
    context menus.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 单文件模式要求Ghidra将容器文件作为单个文件导入。由于容器文件并不是一个可执行文件，Ghidra可能会建议使用原始二进制格式进行导入，并执行最小化的自动化分析。在文件系统模式下，Ghidra会打开一个文件浏览窗口（见[图13-20](ch13.xhtml#fig13_20)），显示容器文件的内容。在这种模式下，你可以通过上下文菜单的选项选择容器中的任意文件进行导入。
- en: '![image](Images/fig13-20.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-20.jpg)'
- en: '*Figure 13-20: File System import mode*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-20：文件系统导入模式*'
- en: In Batch mode, Ghidra automatically imports files in the container without pausing
    to display individual file information. After initially processing the container’s
    contents, Ghidra displays the Batch Import dialog shown in [Figure 13-21](ch13.xhtml#fig13_21).
    Before clicking OK, you can view information on each file being imported, add
    more files to the batch import, set import options, and choose the destination
    folder within your Ghidra project. [Figure 13-21](ch13.xhtml#fig13_21) shows that
    we are about to import 1690 files from the *libc.a* archive into our CH13 project’s
    root directory.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在批处理模式下，Ghidra会自动导入容器中的文件，而不会暂停显示单个文件的信息。在初步处理容器内容后，Ghidra会显示如[图13-21](ch13.xhtml#fig13_21)所示的批量导入对话框。在点击确定之前，你可以查看每个正在导入文件的信息，添加更多文件到批量导入中，设置导入选项，并选择Ghidra项目中的目标文件夹。[图13-21](ch13.xhtml#fig13_21)显示我们即将从*libc.a*库中导入1690个文件到CH13项目的根目录。
- en: '![image](Images/fig13-21.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig13-21.jpg)'
- en: '*Figure 13-21: Ghidra’s Batch Import dialog*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-21：Ghidra的批量导入对话框*'
- en: Click **OK** to kick off the import process (which may take some time). Once
    the import is complete, you will be able to browse the newly imported files in
    the Ghidra Project window. Because *libc.a* is a container file, it will appear
    as a folder in the Project window, and you can navigate its contents to open and
    analyze any one of the files contained in the folder.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**OK**开始导入过程（可能需要一些时间）。导入完成后，您将能够在Ghidra项目窗口中浏览新导入的文件。由于*libc.a*是一个容器文件，它将在项目窗口中显示为一个文件夹，您可以浏览其内容，打开并分析文件夹中的任何文件。
- en: At this point, we can finally capture fingerprints of each `libc` function into
    an FidDb and use that FidDb to perform Function ID analysis against our sample
    statically linked binary. This process parallels the UPX example, beginning with
    creating a new empty FidDb that will then be populated from programs. The programs
    in this case will be the entire contents of our newly import *libc.a* folder.
    Here we run into a significant challenge.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一步，我们终于可以将每个`libc`函数的指纹捕获到FidDb中，并使用这个FidDb对我们样本的静态链接二进制文件进行功能ID分析。这个过程类似于UPX示例，首先创建一个新的空FidDb，然后从程序中填充数据。在这种情况下，程序将是我们新导入的*libc.a*文件夹的全部内容。这里我们遇到了一个重大挑战。
- en: When we select the files to populate our new FidDb, we must ensure that every
    file has been properly analyzed by Ghidra to identify functions and their associated
    instructions (the input to the Function ID hashing process). Up to this point,
    we have seen Ghidra analyze programs only when we open them in the CodeBrowser,
    but with *libc.a*, we are faced with the daunting task of analyzing 1690 individual
    files within the *libc.a* archive. Opening and analyzing them one at a time is
    not a good use of our time. Even selecting to open all files on import and using
    Ghidra’s Analyze All Open option will still take us a while to work through all
    1690 files (and will likely require manual intervention to adjust our tool options
    and resource allocations to accommodate a task of this size within our Ghidra
    instance).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择文件来填充新的FidDb时，必须确保每个文件都已被Ghidra正确分析，以识别函数及其相关指令（即功能ID哈希过程的输入）。到目前为止，我们看到Ghidra只会在我们打开程序时在CodeBrowser中进行分析，但在处理*libc.a*时，我们面临着分析*libc.a*归档中1690个单独文件的艰巨任务。逐一打开并分析它们并不是一种高效的做法。即使选择在导入时打开所有文件，并使用Ghidra的“分析所有打开的文件”选项，也需要花费我们相当多的时间来处理所有1690个文件（并且可能需要手动调整工具选项和资源分配，以适应在Ghidra实例中处理如此庞大任务）。
- en: If this problem seems unwieldy, you are correct. This is not the sort of task
    that we should be solving manually through the Ghidra GUI. This is a well-defined
    repetitive task that shouldn’t require human intervention. Fortunately for us,
    the next three chapters introduce methods we can use to automate this and other
    tasks. When we get to “[Automated FidDb Creation](ch16.xhtml#ch16lev303)” on [page
    359](ch16.xhtml#page_359), we will revisit this specific task and demonstrate
    how easily batch processing can be accomplished using Ghidra’s headless mode of
    operation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个问题看起来笨重，您是对的。这不是我们应该通过Ghidra GUI手动解决的任务。这是一个明确定义的重复性任务，不应该需要人工干预。幸运的是，接下来的三章介绍了我们可以用来自动化这一任务及其他任务的方法。当我们到达
    “[自动化FidDb创建](ch16.xhtml#ch16lev303)” [第359页](ch16.xhtml#page_359)时，我们将重新审视这个具体任务，并演示如何使用Ghidra的无头模式轻松实现批处理操作。
- en: 'Regardless of the method we use to process *libc.a*, once complete, it’s a
    simple matter to return to the Function ID plugin and populate our new FidDb,
    yielding the following results:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用什么方法来处理*libc.a*，一旦完成，返回到功能ID插件并填充我们的新FidDb，生成以下结果就变得简单：
- en: '[PRE5]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our new FidDb is now available for use and allows the Function ID analyzer to
    match many of the functions contained in *upx_demo2_x64_static_stripped*, significantly
    reducing our reverse engineering workload for this particular binary.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新FidDb现在可以使用了，并允许功能ID分析器匹配*upx_demo2_x64_static_stripped*中包含的许多函数，从而大大减少了我们对该二进制文件进行逆向工程的工作量。
- en: '### **Summary**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '### **总结**'
- en: This chapter demonstrated some of the ways that Ghidra can be extended by parsing
    C source files, extending word models, and extracting function fingerprints using
    the Function ID plugin. When a binary contains statically linked code or code
    reused from previously analyzed binaries, matching those functions against Ghidra
    FidDbs can save you the hassle of manually wading through a mountain of code.
    Predictably, so many static link libraries exist that it is not possible for Ghidra
    to include FidDb files that cover every possible use case. The ability to create
    your own FidDb files when necessary allows you to build up a collection of FidDbs
    that are tuned to your particular needs. In [Chapters 14](ch14.xhtml#ch14) and
    [15](ch15.xhtml#ch15), we introduce Ghidra’s powerful scripting capabilities to
    further extend Ghidra’s functionality.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了通过解析 C 源文件、扩展词模型以及使用 Function ID 插件提取函数指纹等方式扩展 Ghidra 的一些方法。当二进制文件包含静态链接的代码或来自先前分析过的二进制文件的复用代码时，将这些函数与
    Ghidra FidDb 进行匹配，可以帮助你避免手动查找大量代码的麻烦。可以预见的是，静态链接库种类繁多，Ghidra 不可能包含涵盖所有使用场景的 FidDb
    文件。必要时创建自己的 FidDb 文件的能力，允许你构建一个针对特定需求调整的 FidDb 集合。在[第 14 章](ch14.xhtml#ch14)和[第
    15 章](ch15.xhtml#ch15)中，我们将介绍 Ghidra 强大的脚本功能，进一步扩展 Ghidra 的功能。
