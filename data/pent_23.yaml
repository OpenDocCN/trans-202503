- en: Chapter 18. Structured Exception Handler Overwrites
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 18 章. 结构化异常处理程序覆盖
- en: When something goes wrong and causes a program to crash, it has caused an exception.
    Accessing an invalid memory location is one type of exception a program can encounter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误导致程序崩溃时，就会引发异常。访问无效的内存位置是程序可能遇到的一种异常类型。
- en: 'Windows systems use a method called *structured exception handlers (SEH)* to
    deal with program exceptions as they arise. SEH are similar to try/catch blocks
    in Java: Code is executed, and if something goes wrong, the function stops executing
    and passes execution to SEH.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 系统使用一种名为*结构化异常处理程序（SEH）*的方法来处理程序发生的异常。SEH 类似于 Java 中的 try/catch 块：代码会执行，如果出现问题，函数停止执行，并将控制权传递给
    SEH。
- en: Each function can have its own SEH registration entry. An *SEH registration
    record* is eight bytes long, consisting of a pointer to the next SEH record (NSEH)
    followed by the memory address of the exception handler, as illustrated in [Figure 18-1](ch18.xhtml#seh_structure
    "Figure 18-1. SEH structure"). The list of all the SEH entries is the *SEH chain*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都可以有自己的 SEH 注册条目。一个*SEH 注册记录*长度为 8 个字节，由指向下一个 SEH 记录的指针（NSEH）和异常处理程序的内存地址组成，如[图
    18-1](ch18.xhtml#seh_structure "图 18-1. SEH 结构")所示。所有 SEH 条目的列表即为*SEH 链*。
- en: '![SEH structure](httpatomoreillycomsourcenostarchimages2030540.png)Figure 18-1. SEH
    structure'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![SEH 结构](httpatomoreillycomsourcenostarchimages2030540.png)图 18-1. SEH 结构'
- en: In many cases, an application uses only the operating system’s SEH entry to
    handle exceptions. You are probably already familiar with this usage; it puts
    up a message box with something like “Application X has encountered a problem
    and needs to close.” However, programs can also specify custom SEH entries. When
    an exception is encountered, execution will be passed to the SEH chain to look
    for an entry that can handle the exception. To view the SEH chain for an application
    in Immunity Debugger, go to **View** ▸ **SEH chain**, as illustrated in [Figure 18-2](ch18.xhtml#viewing_the_seh_chain
    "Figure 18-2. Viewing the SEH chain").
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，应用程序仅使用操作系统的 SEH 条目来处理异常。你可能已经熟悉这种用法；它会弹出一个消息框，内容类似于“应用程序 X 遇到问题，需要关闭”。然而，程序也可以指定自定义
    SEH 条目。当遇到异常时，执行会传递给 SEH 链，寻找能够处理该异常的条目。在 Immunity Debugger 中查看应用程序的 SEH 链，请前往**视图**
    ▸ **SEH 链**，如[图 18-2](ch18.xhtml#viewing_the_seh_chain "图 18-2. 查看 SEH 链")所示。
- en: '![Viewing the SEH chain](httpatomoreillycomsourcenostarchimages2030542.png)Figure 18-2. Viewing
    the SEH chain'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '![查看 SEH 链](httpatomoreillycomsourcenostarchimages2030542.png)图 18-2. 查看 SEH
    链'
- en: SEH Overwrite Exploits
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SEH 覆盖漏洞
- en: Now let’s look at using SEH entries to take control of a program. A natural
    question when working through the War-FTP buffer overflow example in [Chapter 17](ch17.xhtml
    "Chapter 17. A Stack-Based Buffer Overflow in Windows") would be, Why are we limited
    to 607 bytes for our shellcode? Why can’t we write an even longer attack string
    and create a payload that’s as long as we like?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何利用 SEH 条目来控制程序。在通过[第 17 章](ch17.xhtml "第 17 章. Windows 中基于栈的缓冲区溢出")的
    War-FTP 缓冲区溢出示例时，一个自然的问题是，为什么我们只能为我们的 shellcode 使用 607 字节？为什么不能编写一个更长的攻击字符串，创建一个任意长度的
    payload？
- en: We’ll begin our exploration of SEH overwrites with the exploit we used to crash
    War-FTP. Instead of the 1,100-byte exploit string that we used in the example
    in [Chapter 17](ch17.xhtml "Chapter 17. A Stack-Based Buffer Overflow in Windows"),
    let’s try crashing War-FTP with a 1,150-byte string of *A*s, as shown in [Example 18-1](ch18.xhtml#war-ftp_exploit_with_1comma150_as
    "Example 18-1. War-FTP exploit with 1,150 As").
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过用来崩溃 War-FTP 的漏洞开始探索 SEH 覆盖。与在[第 17 章](ch17.xhtml "第 17 章. Windows 中基于栈的缓冲区溢出")示例中使用的
    1,100 字节漏洞字符串不同，让我们尝试使用 1,150 字节的 *A* 字符串来崩溃 War-FTP，如[示例 18-1](ch18.xhtml#war-ftp_exploit_with_1comma150_as
    "示例 18-1. 使用 1,150 个 A 的 War-FTP 漏洞")所示。
- en: Example 18-1. War-FTP exploit with 1,150 As
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 18-1. 使用 1,150 个 A 的 War-FTP 漏洞
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As shown in [Figure 18-3](ch18.xhtml#program_crashes_without_eip_controldot
    "Figure 18-3. A program crashes without EIP control."), the program crashes as
    expected, but this time our access violation is a bit different from the one in
    [Chapter 17](ch17.xhtml "Chapter 17. A Stack-Based Buffer Overflow in Windows").
    EIP points to `0x77C3F973`, a valid instruction inside *MSVCRT.dll*. Instead of
    overwriting the saved return pointer and crashing the program with EIP control,
    War-FTP crashed writing to memory address `0x00B00000`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图18-3](ch18.xhtml#program_crashes_without_eip_controldot "图18-3. 程序在没有EIP控制的情况下崩溃。")所示，程序如预期般崩溃，但这次我们的访问违规异常与[第17章](ch17.xhtml
    "第17章. Windows中的基于栈的缓冲区溢出")中的略有不同。EIP指向`0x77C3F973`，这是*MSVCRT.dll*中的一个有效指令。与覆盖保存的返回指针并通过EIP控制使程序崩溃不同，War-FTP此次崩溃时尝试写入内存地址`0x00B00000`。
- en: Notice in the CPU pane that the instruction at `0x77C3F973` is `MOV BYTE PTR`
    `DS:[EAX], 0`. Basically, the program is trying to write to the memory location
    of the value of `EAX`. Looking at the top right of Immunity Debugger, the Registers
    pane, we see `EAX` contains the value `00B00000`. Something about our attack string
    seems to have corrupted `EAX`, because the program is now trying to write to a
    memory location that is not writable. Without EIP control, is this crash still
    viable? Really long attack strings frequently cause an exception by trying to
    write data off the end of the stack.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意CPU面板中的指令`0x77C3F973`是`MOV BYTE PTR` `DS:[EAX], 0`。基本上，程序正在尝试写入`EAX`值对应的内存位置。在Immunity
    Debugger的右上角的寄存器面板中，我们看到`EAX`包含值`00B00000`。我们的攻击字符串似乎破坏了`EAX`，因为程序现在正尝试写入一个无法写入的内存位置。在没有EIP控制的情况下，这次崩溃还有意义吗？非常长的攻击字符串常常会因为试图将数据写入栈的末尾而引发异常。
- en: Before we write off this exploit and move on, take a look at the SEH chain.
    As shown in [Figure 18-4](ch18.xhtml#seh_overwritten "Figure 18-4. SEH overwritten"),
    the structured exception handler has been overwritten with *A*s. Recall that in
    the event of a crash, execution is passed to SEH. Though we were not able to control
    EIP directly at the time of the crash, perhaps controlling SEH will allow us to
    still hijack execution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们放弃这个漏洞并继续之前，先看看SEH链。如[图18-4](ch18.xhtml#seh_overwritten "图18-4. SEH被覆盖")所示，结构化异常处理程序（SEH）已被*A*覆盖。回想一下，在崩溃事件中，执行会转交给SEH。尽管我们当时没有直接控制EIP，但也许控制SEH可以让我们仍然劫持执行。
- en: '![A program crashes without EIP control.](httpatomoreillycomsourcenostarchimages2030544.png.jpg)Figure 18-3. A
    program crashes without EIP control.![SEH overwritten](httpatomoreillycomsourcenostarchimages2030546.png.jpg)Figure 18-4. SEH
    overwritten'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![程序在没有EIP控制的情况下崩溃。](httpatomoreillycomsourcenostarchimages2030544.png.jpg)图18-3。程序在没有EIP控制的情况下崩溃。![SEH被覆盖](httpatomoreillycomsourcenostarchimages2030546.png.jpg)图18-4.SEH被覆盖'
- en: Just as we used Mona to create a cyclic pattern to see which four bytes overwrote
    the saved return pointer in the previous chapter, we will find which four *A*s
    are overwriting SEH using the command `!mona pattern_create 1150` in Immunity
    Debugger, as shown in [Figure 18-5](ch18.xhtml#generating_a_cyclic_pattern_with_mona
    "Figure 18-5. Generating a cyclic pattern with Mona").
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在上一章中使用Mona创建一个循环模式来查看哪个四个字节覆盖了保存的返回指针一样，我们将使用命令`!mona pattern_create 1150`在Immunity
    Debugger中找到覆盖SEH的四个*A*，如[图18-5](ch18.xhtml#generating_a_cyclic_pattern_with_mona
    "图18-5. 使用Mona生成循环模式")所示。
- en: '![Generating a cyclic pattern with Mona](httpatomoreillycomsourcenostarchimages2030548.png.jpg)Figure 18-5. Generating
    a cyclic pattern with Mona'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用Mona生成循环模式](httpatomoreillycomsourcenostarchimages2030548.png.jpg)图18-5.
    使用Mona生成循环模式'
- en: Copy the resulting pattern from *C:\logs\war-ftpd\pattern.txt* into the exploit
    in place of the 1,150 *A*s, as shown in [Example 18-2](ch18.xhtml#using_pattern_generation_to_pinpoint_the
    "Example 18-2. Using pattern generation to pinpoint the SEH overwrite in the attack
    string").
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成的模式从*C:\logs\war-ftpd\pattern.txt*复制到利用代码中，替换掉1,150个*A*，如[示例18-2](ch18.xhtml#using_pattern_generation_to_pinpoint_the
    "示例18-2. 使用模式生成精确定位攻击字符串中的SEH覆盖")所示。
- en: Example 18-2. Using pattern generation to pinpoint the SEH overwrite in the
    attack string
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 示例18-2. 使用模式生成精确定位攻击字符串中的SEH覆盖
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we’ve generated a 1,150-character pattern and replaced the string of *A*s
    at ❶. Next, restart War-FTP in Immunity Debugger, and run the exploit again. As
    shown in [Figure 18-6](ch18.xhtml#seh_overwritten_with_monaapostrophes_pat "Figure 18-6. SEH
    overwritten with Mona’s pattern"), SEH is overwritten with `41317441`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们生成了一个 1,150 字符的模式，并在 ❶ 处替换了 *A* 字符串。接下来，重新启动 War-FTP，在 Immunity Debugger
    中运行该漏洞利用程序。正如图 [18-6](ch18.xhtml#seh_overwritten_with_monaapostrophes_pat "图 18-6.
    SEH 被 Mona 的模式覆盖") 所示，SEH 被 `41317441` 覆盖。
- en: '![SEH overwritten with Mona’s pattern](httpatomoreillycomsourcenostarchimages2030550.png.jpg)Figure 18-6. SEH
    overwritten with Mona’s pattern'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![SEH 被 Mona 的模式覆盖](httpatomoreillycomsourcenostarchimages2030550.png.jpg)图
    18-6. SEH 被 Mona 的模式覆盖'
- en: Now use `!mona findmsp` to find out where in our 1,150-character attack string
    the SEH entry is overwritten, as shown in [Figure 18-7](ch18.xhtml#finding_the_seh_overwrite_in_the_cyclic
    "Figure 18-7. Finding the SEH overwrite in the cyclic pattern").
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用 `!mona findmsp` 来查找在我们 1,150 字符的攻击字符串中，SEH 条目被覆盖的位置，如图 [18-7](ch18.xhtml#finding_the_seh_overwrite_in_the_cyclic
    "图 18-7. 在循环模式中找到 SEH 覆盖") 所示。
- en: '![Finding the SEH overwrite in the cyclic pattern](httpatomoreillycomsourcenostarchimages2030552.png.jpg)Figure 18-7. Finding
    the SEH overwrite in the cyclic pattern'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![在循环模式中找到 SEH 覆盖](httpatomoreillycomsourcenostarchimages2030552.png.jpg)图
    18-7. 在循环模式中找到 SEH 覆盖'
- en: Looking through the log output at *C:\logs\war-ftpd\findmsp.txt*, shown in part
    here, we find that the NSEH entry is overwritten 569 bytes into the attack string.
    Recall from [Figure 18-1](ch18.xhtml#seh_structure "Figure 18-1. SEH structure")
    that SEH chain entries are made up of eight bytes (the NSEH entry followed by
    the SEH pointer). Thus our SEH overwrite is at 573 bytes into our attack string
    (four bytes after NSEH).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 查看位于 *C:\logs\war-ftpd\findmsp.txt* 的日志输出（部分内容如下），我们发现 NSEH 条目被覆盖在攻击字符串的第 569
    字节。回顾图 [18-1](ch18.xhtml#seh_structure "图 18-1. SEH 结构")，SEH 链条目由八个字节组成（NSEH 条目后跟
    SEH 指针）。因此，我们的 SEH 覆盖发生在攻击字符串的第 573 字节（NSEH 后的四个字节）。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Passing Control to SEH
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将控制权传递给 SEH
- en: Back on the Windows XP target, the bottom of the Immunity Debugger screen shows
    the access violation and also notes that you can type shift-F7/F8/F9 to pass an
    exception to the program. In this case, the program will attempt to execute the
    memory address `41317441`, the string that has overwritten SEH. Use shift-F9 to
    run the program until the next error occurs. As shown in [Figure 18-8](ch18.xhtml#execution_is_passed_to_the_overwritten_s
    "Figure 18-8. Execution is passed to the overwritten SEH."), the program receives
    an access violation when attempting to access the memory address `41317441`. As
    in the previous examples, we will put a useful memory address in the place of
    `41317441` to successfully hijack execution.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Windows XP 目标系统，Immunity Debugger 屏幕底部显示了访问冲突，并指出你可以按 shift-F7/F8/F9 将异常传递给程序。在这种情况下，程序将尝试执行内存地址
    `41317441`，该地址是覆盖了 SEH 的字符串。使用 shift-F9 继续运行程序，直到发生下一个错误。如图 [18-8](ch18.xhtml#execution_is_passed_to_the_overwritten_s
    "图 18-8. 执行被传递到被覆盖的 SEH.") 所示，程序在尝试访问内存地址 `41317441` 时遇到访问冲突。与之前的例子一样，我们将把一个有效的内存地址放置在
    `41317441` 位置，以成功劫持执行。
- en: Also note in [Figure 18-8](ch18.xhtml#execution_is_passed_to_the_overwritten_s
    "Figure 18-8. Execution is passed to the overwritten SEH.") that when execution
    is passed to SEH, many of our registers have been zeroed out. This might make
    jumping to an attacker-controlled register more difficult.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意在图 [18-8](ch18.xhtml#execution_is_passed_to_the_overwritten_s "图 18-8. 执行被传递到被覆盖的
    SEH.") 中，当执行传递到 SEH 时，我们的许多寄存器已经被清零。这可能使得跳转到攻击者控制的寄存器变得更加困难。
- en: '![Execution is passed to the overwritten SEH.](httpatomoreillycomsourcenostarchimages2030554.png.jpg)Figure 18-8. Execution
    is passed to the overwritten SEH.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![执行被传递到被覆盖的 SEH](httpatomoreillycomsourcenostarchimages2030554.png.jpg)图 18-8.
    执行被传递到被覆盖的 SEH'
- en: Of the registers that have not been zeroed out, none appears to point to a portion
    of our attack string. Clearly, a simple `JMP ESP` in SEH will not work to redirect
    execution to attacker-controlled memory. Things are still looking pretty bleak
    in our search for exploitability.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在未被清零的寄存器中，似乎没有任何一个指向我们攻击字符串的部分。显然，SEH 中简单的 `JMP ESP` 不会将执行重定向到攻击者控制的内存。我们在寻找可利用性时，形势依然相当严峻。
- en: Finding the Attack String in Memory
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在内存中查找攻击字符串
- en: Of course, in this case, we already have a working saved return pointer overwrite
    exploit. However, some programs will be vulnerable only to SEH overwrites, so
    developing a method to exploit these issues is of the utmost importance. Luckily,
    an attacker-controlled memory address is on the horizon for SEH overwrites. As
    shown in [Figure 18-9](ch18.xhtml#following_esp_on_the_stack "Figure 18-9. Following
    ESP on the stack"), highlight the ESP register in Immunity Debugger, right-click,
    and select **Follow in Stack**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这种情况下，我们已经有了一个有效的返回指针覆盖漏洞利用程序。然而，一些程序仅对SEH覆盖漏洞存在漏洞，因此开发利用这些问题的方法至关重要。幸运的是，SEH覆盖漏洞的攻击者控制内存地址即将到来。如[图18-9](ch18.xhtml#following_esp_on_the_stack
    "图18-9. 跟随栈上的ESP")所示，在Immunity Debugger中突出显示ESP寄存器，右键单击并选择**在栈中跟踪**。
- en: '![Following ESP on the stack](httpatomoreillycomsourcenostarchimages2030556.png.jpg)Figure 18-9. Following
    ESP on the stack'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![跟随栈上的ESP](httpatomoreillycomsourcenostarchimages2030556.png.jpg)图18-9. 跟随栈上的ESP'
- en: Though the contents of the ESP register do not point to any part of our cyclic
    pattern, two steps down from ESP, at ESP+8, we see that memory address `00AFD94`
    points to our cyclic pattern in memory, as shown in [Figure 18-10](ch18.xhtml#cyclic_pattern_eight_bytes_higher_than_e
    "Figure 18-10. Cyclic pattern eight bytes higher than ESP"). If we can find a
    way to remove two elements from the stack and then execute the contents of this
    memory address, we can execute shellcode in place of the pattern.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ESP寄存器的内容并没有指向我们的循环模式的任何部分，但从ESP开始向下两个步骤，在ESP+8处，我们看到内存地址`00AFD94`指向了我们内存中的循环模式，如[图18-10](ch18.xhtml#cyclic_pattern_eight_bytes_higher_than_e
    "图18-10. 比ESP高八字节的循环模式")所示。如果我们能够找到一种方法移除栈中的两个元素，然后执行该内存地址的内容，我们就可以用shellcode代替模式来执行代码。
- en: '![Cyclic pattern eight bytes higher than ESP](httpatomoreillycomsourcenostarchimages2030558.png.jpg)Figure 18-10. Cyclic
    pattern eight bytes higher than ESP'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![比ESP高八字节的循环模式](httpatomoreillycomsourcenostarchimages2030558.png.jpg)图18-10.
    比ESP高八字节的循环模式'
- en: The location of NSEH is `00AFFD94`, as noted by the output of Mona’s `findmsp`
    command. We can verify this by right-clicking `00AFFD94` in the stack pane and
    clicking **Follow in Stack**, as shown in [Figure 18-11](ch18.xhtml#cyclic_pattern_in_the_pointer_to_the_nex
    "Figure 18-11. Cyclic pattern in the pointer to the next SEH record").
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: NSEH的位置是`00AFFD94`，如Mona的`findmsp`命令的输出所示。我们可以通过在栈窗格中右键单击`00AFFD94`并选择**在栈中跟踪**来验证这一点，如[图18-11](ch18.xhtml#cyclic_pattern_in_the_pointer_to_the_nex
    "图18-11. 指向下一个SEH记录的指针中的循环模式")所示。
- en: '![Cyclic pattern in the pointer to the next SEH record](httpatomoreillycomsourcenostarchimages2030560.png.jpg)Figure 18-11. Cyclic
    pattern in the pointer to the next SEH record'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![指向下一个SEH记录的指针中的循环模式](httpatomoreillycomsourcenostarchimages2030560.png.jpg)图18-11.
    指向下一个SEH记录的指针中的循环模式'
- en: As discussed earlier, SEH entries are eight-byte-long linked lists consisting
    of a pointer to the next SEH record in the chain and the memory address of the
    handler on the stack. If we can load ESP+8 into EIP, we can execute some shellcode.
    Unfortunately, it looks like we have only four bytes to work with before we hit
    the SEH entry itself, but let’s deal with one problem at a time. We need to find
    a viable way of getting to our shellcode, and then we will return to making our
    shellcode fit into the space available.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，SEH条目是一个八字节长的链表，由指向链中下一个SEH记录的指针和栈上处理程序的内存地址组成。如果我们能够将ESP+8加载到EIP中，就可以执行一些shellcode。不幸的是，在遇到SEH条目之前，看起来我们只有四个字节可供使用，但让我们一个问题一个问题地处理。我们需要找到一种可行的方式来获取我们的shellcode，然后再返回去让我们的shellcode适应可用的空间。
- en: Before we move on, let’s verify that our offsets are correct, as shown in [Example 18-3](ch18.xhtml#verifying_overwrite_offsets
    "Example 18-3. Verifying overwrite offsets").
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们验证一下我们的偏移量是否正确，如[示例18-3](ch18.xhtml#verifying_overwrite_offsets "示例18-3.
    验证覆盖偏移量")所示。
- en: Example 18-3. Verifying overwrite offsets
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 18-3. 验证覆盖偏移量
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Edit your exploit program to send over 569 *A*s, followed by 4 *B*s, followed
    by 4 *C*s, and rounding out the 1,150 byte attack string with 573 *D*s at ❶. Restart
    War-FTP and run the exploit again. We see in [Figure 18-12](ch18.xhtml#seh_is_overwritten_by_four_csdot
    "Figure 18-12. SEH is overwritten by four Cs.") that SEH is overwritten by our
    4 *C*s.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑你的漏洞利用程序，发送569个*A*，接着是4个*B*，再接着是4个*C*，最后以573个*D*结束，形成1,150字节的攻击字符串，位置在❶。重新启动War-FTP并再次运行漏洞利用程序。我们在[图18-12](ch18.xhtml#seh_is_overwritten_by_four_csdot
    "图18-12. SEH被四个C覆盖")中看到，SEH被我们的4个*C*覆盖。
- en: '![SEH is overwritten by four Cs.](httpatomoreillycomsourcenostarchimages2030562.png.jpg)Figure 18-12. SEH
    is overwritten by four Cs.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![SEH 被四个 C 字符覆盖。](httpatomoreillycomsourcenostarchimages2030562.png.jpg)Figure 18-12. SEH
    被四个 C 字符覆盖。'
- en: If we again type shift-F9 to pass the exception handler to the crashed program,
    War-FTP crashes a second time when accessing the memory address `43434343`, our
    *C*s. Now follow the ESP register in the stack. As shown in [Figure 18-13](ch18.xhtml#espplus8_is_attacker_controlleddot
    "Figure 18-13. ESP+8 is attacker controlled."), ESP+8 points to a memory address
    filled with the four *B*s followed by our four *C*s and then the *D*s.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次按下 shift-F9 将异常处理程序传递给崩溃的程序，当访问内存地址 `43434343` 时，War-FTP 第二次崩溃，出现我们的 *C*
    字符。现在跟踪栈中的 ESP 寄存器。如图 [Figure 18-13](ch18.xhtml#espplus8_is_attacker_controlleddot
    "Figure 18-13. ESP+8 是攻击者控制的。") 所示，ESP+8 指向一个内存地址，该地址首先填充了四个 *B* 字符，然后是四个 *C*
    字符，接着是 *D* 字符。
- en: '![ESP+8 is attacker controlled.](httpatomoreillycomsourcenostarchimages2030564.png.jpg)Figure 18-13. ESP+8
    is attacker controlled.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![ESP+8 是攻击者控制的。](httpatomoreillycomsourcenostarchimages2030564.png.jpg)Figure 18-13. ESP+8
    是攻击者控制的。'
- en: Our offsets are correct. Now to find a way to redirect execution to ESP+8\.
    Unfortunately, a simple `JMP ESP` won’t cut it this time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的偏移量是正确的。现在，需要找到一种方法将执行重定向到 ESP+8。遗憾的是，这次简单的 `JMP ESP` 无法实现。
- en: POP POP RET
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POP POP RET
- en: We need an instruction, or series of instructions, that will allow us to move
    eight bytes down the stack and then execute the contents of the memory address
    located at ESP+8\. To figure out the assembly instructions we need, we must consider
    how the stack works.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一条指令，或者一系列指令，允许我们将栈向下移动八个字节，然后执行位于 ESP+8 的内存地址内容。为了弄清楚需要的汇编指令，我们必须考虑栈是如何工作的。
- en: The stack is a last-in, first-out (LIFO) structure. The analogy of a stack of
    trays in a cafeteria is often used for this concept. The last tray put on the
    stack by cafeteria staff is the first one grabbed by a cafeteria patron. The assembly
    command equivalents of the tray being added to the stack and then picked up by
    a patron are `PUSH` and `POP`, respectively.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一个后进先出（LIFO）的结构。常用的比喻是自助餐厅里的托盘堆叠概念。餐厅员工最后放上堆栈的托盘是餐客首先拿到的托盘。将托盘加入栈和顾客拿到托盘的汇编命令分别是
    `PUSH` 和 `POP`。
- en: Recall that ESP points to the top (lowest memory address) of the current stack
    frame. If we use the `POP` instruction to pop one entry (four bytes) off the stack,
    ESP will now point to ESP+4\. Thus, if we execute two `POP` instructions in succession,
    ESP will now point to ESP+8, which is exactly what we are going for.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，ESP 指向当前栈帧的顶部（最低内存地址）。如果我们使用 `POP` 指令从栈中弹出一个条目（四个字节），ESP 会指向 ESP+4。因此，如果我们连续执行两个
    `POP` 指令，ESP 会指向 ESP+8，这正是我们想要的。
- en: Finally, to redirect our execution to our attacker-controlled string, we need
    to load the value of ESP+8 (now in ESP after our two `POP` instructions) into
    EIP (the next memory address to be executed). Luckily, there’s an instruction
    for that, namely, the `RET` instruction. By design, `RET` takes the contents of
    the ESP register and loads them into EIP to be executed next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了将我们的执行重定向到攻击者控制的字符串，我们需要将 ESP+8 的值（现在在执行了两个 `POP` 指令后位于 ESP 中）加载到 EIP 中（即下一个将被执行的内存地址）。幸运的是，有一条指令可以做到这一点，即
    `RET` 指令。根据设计，`RET` 会将 ESP 寄存器中的内容加载到 EIP 中，然后执行这些内容。
- en: If we can find these three instructions, `POP` *`<some register>`*, `POP` *`<some
    register>`*, `RET` (often abbreviated by exploit developers as `POP POP RET`),
    we should be able to redirect the program’s execution by overwriting SEH with
    the memory address of the first `POP` instruction. The contents of ESP will then
    be popped into the register indicated by the instruction. We don’t particularly
    care which register gets the honor of holding the popped-off data, as long as
    it’s not ESP itself. We care only about burning things off the stack until we
    get to ESP+8.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够找到这三条指令，`POP` *`<某个寄存器>`*、`POP` *`<某个寄存器>`*、`RET`（通常被漏洞开发者缩写为 `POP POP
    RET`），我们应该能够通过覆盖 SEH 来重定向程序的执行，将 SEH 替换为第一个 `POP` 指令的内存地址。然后，ESP 的内容将被弹入指令所指定的寄存器中。我们并不特别关心哪个寄存器获得了被弹出的数据，只要它不是
    ESP 本身即可。我们唯一关心的是将栈中的内容逐步弹出，直到到达 ESP+8。
- en: Next, the second `POP` instruction is executed. Now ESP points to the original
    ESP+8\. Then, the `RET` instruction is executed, and ESP (ESP+8 when the SEH was
    executed) is loaded into EIP. Recall from the previous section that ESP+8 held
    a memory address that points to byte 569 of our attacker-controlled string.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，执行第二个 `POP` 指令。此时，ESP 指向原始的 ESP+8。然后，执行 `RET` 指令，ESP（在执行 SEH 时为 ESP+8）被加载到
    EIP 中。回忆前一节，ESP+8 存储了一个内存地址，该地址指向我们攻击者控制的字符串的第 569 字节。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As with `JMP ESP`, it is not a hard requirement that we find `POP POP RET` instructions.
    Logical equivalents, such as adding eight bytes to ESP followed by a `RET` and
    others, would work just as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `JMP ESP` 一样，找到 `POP POP RET` 指令并不是硬性要求。逻辑等效的指令，如将 ESP 加八个字节后紧接着一个 `RET` 指令，或者其他类似的指令，也同样有效。
- en: Though this technique is a little more complicated, it’s similar to the saved
    return pointer buffer overflow exercise we completed in [Chapter 17](ch17.xhtml
    "Chapter 17. A Stack-Based Buffer Overflow in Windows"). We are hijacking the
    program’s execution and redirecting it to our shellcode. Now we need to find an
    instance of `POP POP RET` instructions in War-FTP or its executable modules.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个技术稍微复杂一些，但它与我们在 [第 17 章](ch17.xhtml "第 17 章. 基于栈的缓冲区溢出攻击")完成的保存返回指针缓冲区溢出练习类似。我们正在劫持程序的执行流并将其重定向到我们的
    Shellcode。现在，我们需要在 War-FTP 或其可执行模块中找到一个 `POP POP RET` 指令实例。
- en: SafeSEH
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SafeSEH
- en: As SEH overwrite attacks have become prevalent, Microsoft has come up with ways
    to stop them from working. One such example is SafeSEH. Programs compiled with
    SafeSEH record the memory locations that will be used for structured exception
    handling, which means that attempts to redirect execution to a memory location
    with `POP POP RET` instructions will fail the SafeSEH check.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SEH 覆盖攻击已经变得非常普遍，微软提出了阻止这些攻击生效的方法。一个这样的例子就是 SafeSEH。使用 SafeSEH 编译的程序会记录将用于结构化异常处理的内存位置，这意味着尝试将执行重定向到包含
    `POP POP RET` 指令的内存位置将无法通过 SafeSEH 检查。
- en: It’s important to realize that even if DLLs in Windows XP SP2 and later are
    compiled with SafeSEH, third-party software doesn’t have to implement this mitigation
    technique. If War-FTP or any of its custom DLLs do not use SafeSEH, we may not
    have to deal with this check.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 需要意识到的是，即使 Windows XP SP2 及以后版本的 DLL 使用 SafeSEH 编译，第三方软件也不必实现这种缓解技术。如果 War-FTP
    或其任何自定义 DLL 没有使用 SafeSEH，我们可能就不需要处理这个检查。
- en: Mona will determine which modules are not compiled with SafeSEH in the process
    of finding the `POP POP RET` instructions when we use the command `!mona seh`,
    as shown in [Figure 18-14](ch18.xhtml#running_the_seh_command_in_mona "Figure 18-14. Running
    the SEH command in Mona").
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `!mona seh` 命令时，Mona 会在查找 `POP POP RET` 指令的过程中确定哪些模块没有使用 SafeSEH，如 [图
    18-14](ch18.xhtml#running_the_seh_command_in_mona "图 18-14. 在 Mona 中运行 SEH 命令")
    所示。
- en: '![Running the SEH command in Mona](httpatomoreillycomsourcenostarchimages2030566.png.jpg)Figure 18-14. Running
    the SEH command in Mona'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![在 Mona 中运行 SEH 命令](httpatomoreillycomsourcenostarchimages2030566.png.jpg)图
    18-14. 在 Mona 中运行 SEH 命令'
- en: The results of `!mona seh` are written to *C:\logs\war-ftpd\seh.txt*, as shown
    in part here.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`!mona seh` 的结果会写入 *C:\logs\war-ftpd\seh.txt*，部分内容如图所示。'
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see from the output, the only modules without SafeSEH are the War-FTP
    executable itself and a War-FTP-included DLL called *MFC42.dll*. We need to choose
    an instance of `POP POP RET` (or a logical equivalent) from Mona’s output that
    avoids the four bad characters discussed in [Chapter 17](ch17.xhtml "Chapter 17. A
    Stack-Based Buffer Overflow in Windows") (\x00, \x40, \x0a, \x0d). (To have Mona
    automatically exclude entries with bad characters during the search, enter **`!mona
    seh -cpb "\x00\x40\x0a\x0d"`**. One such address is `5F4580CA`. The instructions
    are `POP` `EBX`, `POP EBP`, `RET`. Again, we don’t care where the instructions
    are stored, as long as we `POP` two entries off the stack. If we overwrite SEH
    with the address `5F4580CA`, these instructions will be executed, and we will
    redirect execution to our attack string.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看到，唯一没有 SafeSEH 的模块是 War-FTP 可执行文件本身和一个名为 *MFC42.dll* 的 War-FTP 附带 DLL。我们需要从
    Mona 的输出中选择一个 `POP POP RET`（或其逻辑等效）实例，该实例避免了 [第 17 章](ch17.xhtml "第 17 章. 基于栈的缓冲区溢出攻击")中讨论的四个坏字符（\x00,
    \x40, \x0a, \x0d）。(要让 Mona 在搜索过程中自动排除包含坏字符的条目，可以输入 **`!mona seh -cpb "\x00\x40\x0a\x0d"`**。一个这样的地址是
    `5F4580CA`。指令为 `POP` `EBX`，`POP EBP`，`RET`。再次强调，我们不在乎这些指令存储在哪里，只要我们能从栈上弹出两个条目。如果我们用地址
    `5F4580CA` 覆盖 SEH，这些指令就会被执行，我们的执行流将被重定向到攻击字符串。
- en: Before we move on, set a breakpoint at `5F4580CA` with `bp 0x5F4580CA`, as shown
    in [Figure 18-15](ch18.xhtml#breakpoint_at_the_pop_pop_ret "Figure 18-15. Breakpoint
    at the POP POP RET").
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，按照[图 18-15](ch18.xhtml#breakpoint_at_the_pop_pop_ret "图 18-15. POP POP
    RET 的断点")所示，在 `5F4580CA` 处设置断点，命令为 `bp 0x5F4580CA`。
- en: '![Breakpoint at the POP POP RET](httpatomoreillycomsourcenostarchimages2030568.png.jpg)Figure 18-15. Breakpoint
    at the `POP POP RET`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![POP POP RET 处的断点](httpatomoreillycomsourcenostarchimages2030568.png.jpg)图
    18-15. POP POP RET 处的断点'
- en: Replace the four *C*s in the previous exploit with the `POP POP RET` memory
    address in little-endian format, as shown in [Example 18-4](ch18.xhtml#replacing_the_seh_overwrite_with_pop_pop
    "Example 18-4. Replacing the SEH overwrite with POP POP RET").
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前 exploit 中的四个 *C* 替换为 `POP POP RET` 内存地址的小端格式，正如在[示例 18-4](ch18.xhtml#replacing_the_seh_overwrite_with_pop_pop
    "示例 18-4. 使用 POP POP RET 替换 SEH 覆盖")中所示。
- en: Example 18-4. Replacing the SEH overwrite with `POP POP RET`
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 18-4. 使用 `POP POP RET` 替换 SEH 覆盖
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now run the exploit again. As you can see in [Figure 18-16](ch18.xhtml#seh_overwritten_with_a_pop_pop_ret_addre
    "Figure 18-16. SEH overwritten with a POP POP RET address"), the program crashes
    again, and, as expected, SEH is overwritten with `5F4580CA`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行 exploit。正如在[图 18-16](ch18.xhtml#seh_overwritten_with_a_pop_pop_ret_addre
    "图 18-16. SEH 被 `POP POP RET` 地址覆盖")中看到的，程序再次崩溃，正如预期的那样，SEH 被 `5F4580CA` 覆盖。
- en: '![SEH overwritten with a POP POP RET address](httpatomoreillycomsourcenostarchimages2030570.png.jpg)Figure 18-16. SEH
    overwritten with a `POP POP RET` address'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![SEH 被 `POP POP RET` 地址覆盖](httpatomoreillycomsourcenostarchimages2030570.png.jpg)图
    18-16. SEH 被 `POP POP RET` 地址覆盖'
- en: Type shift-F9 to let the program pass the overwritten exception handler. As
    expected, we hit our breakpoint, as shown in [Figure 18-17](ch18.xhtml#we_hit_our_breakpointdot
    "Figure 18-17. We hit our breakpoint.").
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 Shift-F9 让程序跳过已覆盖的异常处理程序。正如预期的那样，我们击中了断点，正如在[图 18-17](ch18.xhtml#we_hit_our_breakpointdot
    "图 18-17. 我们击中断点。")中所示。
- en: '![We hit our breakpoint.](httpatomoreillycomsourcenostarchimages2030572.png.jpg)Figure 18-17. We
    hit our breakpoint.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![我们击中断点](httpatomoreillycomsourcenostarchimages2030572.png.jpg)图 18-17. 我们击中断点。'
- en: The CPU pane (top left) shows that the next instructions to be executed are
    the `POP POP RET`. Press **F7** to step through the instructions one at a time,
    and watch what happens to the stack (bottom right) as you do. You will see ESP
    move down to a higher address as we execute the `POP` instructions. As you can
    see in [Figure 18-18](ch18.xhtml#execution_is_redirected_to_your_attack_s "Figure 18-18. Execution
    is redirected to your attack string."), when we execute the `RET` instruction
    we end up in our attack string, at the pointer to the NSEH record, which is currently
    filled with four *B*s.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 面板（左上角）显示接下来要执行的指令是 `POP POP RET`。按 **F7** 键逐步执行指令，并观察堆栈（右下角）发生了什么变化。你会看到
    ESP 在执行 `POP` 指令时，指针向更高的地址移动。正如在[图 18-18](ch18.xhtml#execution_is_redirected_to_your_attack_s
    "图 18-18. 执行已重定向到你的攻击字符串。")中所示，当我们执行 `RET` 指令时，最终会跳转到我们的攻击字符串，指向 NSEH 记录的指针，目前该指针填充了四个
    *B*。
- en: '![Execution is redirected to your attack string.](httpatomoreillycomsourcenostarchimages2030574.png.jpg)Figure 18-18. Execution
    is redirected to your attack string.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![执行已重定向到你的攻击字符串。](httpatomoreillycomsourcenostarchimages2030574.png.jpg)图
    18-18. 执行已重定向到你的攻击字符串。'
- en: 'We have solved our first problem: We have redirected the program’s execution
    to our attack string. Unfortunately, as we can see in [Figure 18-18](ch18.xhtml#execution_is_redirected_to_your_attack_s
    "Figure 18-18. Execution is redirected to your attack string."), we only have
    four useable bytes before we run into our SEH overwrite address, `5F4580CA`. We
    have a long string of *D*s after the SEH address, but currently we are stuck with
    only four bytes to work with. We won’t be able to do much with only four bytes
    of shellcode.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解决了第一个问题：我们已将程序的执行重定向到我们的攻击字符串。不幸的是，正如在[图 18-18](ch18.xhtml#execution_is_redirected_to_your_attack_s
    "图 18-18. 执行已重定向到你的攻击字符串。")中看到的那样，在我们遇到 SEH 覆盖地址 `5F4580CA` 之前，我们只有四个可用的字节。SEH
    地址后面有一长串 *D*，但目前我们只能使用四个字节。只有四个字节的 shellcode 我们无法做太多事情。
- en: Using a Short Jump
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用短跳转
- en: We need to somehow bypass the return address and get to our long string of *D*s,
    which has plenty of space for our final shellcode. We can use the `short jump`
    assembly instruction to move EIP a short distance. This method is ideal for our
    purposes because we need to jump over the four bytes of the SEH overwrite.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以某种方式绕过返回地址，并跳转到我们的一长串 *D* 字符中，这里有足够的空间放置我们的最终 shellcode。我们可以使用 `short jump`
    汇编指令将 EIP 移动一个短距离。这种方法非常适合我们的目的，因为我们需要跳过 SEH 覆盖的四个字节。
- en: The hexadecimal representation of a short jump is `\xEB` *`<length to jump>`*.
    Padding the short jump instruction `\xEB` *`<length to jump>`* with two bytes
    to take up all four bytes before the SEH overwrite, we can jump forward six bytes
    over the padding and the SEH overwrite.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 短跳转的十六进制表示为`\xEB` *`<跳转长度>`*。通过将短跳转指令`\xEB` *`<跳转长度>`* 填充两个字节，填满在 SEH 覆盖前的所有四个字节，我们可以跳过填充字节和
    SEH 覆盖，跳过六个字节。
- en: Edit the attack string to include a short jump, as shown in [Example 18-5](ch18.xhtml#adding_a_short_jump
    "Example 18-5. Adding a short jump").
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑攻击字符串，加入短跳转，如[示例 18-5](ch18.xhtml#adding_a_short_jump "示例 18-5. 添加短跳转")所示。
- en: Example 18-5. Adding a short jump
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 18-5. 添加短跳转
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As shown in [Example 18-5](ch18.xhtml#adding_a_short_jump "Example 18-5. Adding
    a short jump"), this time we replace the NSEH (previously four *B*s) with `"\xEB\x06"
    + "B" * 2`. Reset your breakpoint at the `POP POP RET` before running the exploit
    again, and when you hit the breakpoint, step through the program line by line
    (F7) to see what is happening. Now after the `POP POP RET` we have a six-byte
    short jump, as shown in [Figure 18-19](ch18.xhtml#execution_is_redirected_to_the_short_jum
    "Figure 18-19. Execution is redirected to the short jump.").
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 18-5](ch18.xhtml#adding_a_short_jump "示例 18-5. 添加短跳转")所示，这次我们将 NSEH（之前是四个
    *B* 字符）替换为`"\xEB\x06" + "B" * 2`。在重新运行漏洞利用之前，重置你在 `POP POP RET` 处的断点，当你触发断点时，逐行单步调试程序（F7），查看发生了什么。现在，在
    `POP POP RET` 之后，我们有了一个六字节的短跳转，如[图 18-19](ch18.xhtml#execution_is_redirected_to_the_short_jum
    "图 18-19. 执行被重定向到短跳转")所示。
- en: '![Execution is redirected to the short jump.](httpatomoreillycomsourcenostarchimages2030576.png.jpg)Figure 18-19. Execution
    is redirected to the short jump.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![执行被重定向到短跳转。](httpatomoreillycomsourcenostarchimages2030576.png.jpg)图 18-19.
    执行被重定向到短跳转。'
- en: Now press **F7** to execute the short jump. As shown in [Figure 18-20](ch18.xhtml#short_jump_gets_us_past_the_seh_overwrit
    "Figure 18-20. The short jump gets us past the SEH overwrite."), the short jump
    successfully bypasses the SEH overwrite address and redirects execution to the
    rest of our attack string (*D*s).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按下 **F7** 执行短跳转。如[图 18-20](ch18.xhtml#short_jump_gets_us_past_the_seh_overwrit
    "图 18-20. 短跳转使我们绕过了 SEH 覆盖")所示，短跳转成功绕过了 SEH 覆盖地址，并将执行重定向到我们攻击字符串的其余部分（*D* 字符）。
- en: '![The short jump gets us past the SEH overwrite.](httpatomoreillycomsourcenostarchimages2030578.png.jpg)Figure 18-20. The
    short jump gets us past the SEH overwrite.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![短跳转使我们绕过了 SEH 覆盖。](httpatomoreillycomsourcenostarchimages2030578.png.jpg)图
    18-20. 短跳转使我们绕过了 SEH 覆盖。'
- en: Choosing a Payload
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择有效载荷
- en: We have now redirected execution a second time, to a longer part of our controlled
    memory—an ideal place for our shellcode. Now to choose a payload and generate
    it with Msfvenom, as shown here.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经第二次重定向了执行，跳转到了我们控制内存的更长部分——这是放置我们的 shellcode 的理想位置。接下来选择一个有效载荷，并使用 Msfvenom
    生成，如下所示。
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Remember to tell Msfvenom to use a maximum size of 573 bytes and exclude our
    bad characters for the FTP username. (Again, you might be able to go a little
    bit longer, but our original exception occurs because we are writing off the end
    of the stack. We want to make sure all of our shellcode is executed.) Now add
    the shellcode to our exploit in place of the *D*s. To make the exploit long enough
    to trigger the SEH overwrite (instead of the saved return pointer overwrite we
    saw in [Chapter 17](ch17.xhtml "Chapter 17. A Stack-Based Buffer Overflow in Windows")),
    pad the exploit string out to 1,150 characters with *D*s. The finished exploit
    is shown in [Example 18-6](ch18.xhtml#finished_seh_overwrite_exploit "Example 18-6. The
    finished SEH overwrite exploit"). Our shellcode goes directly after our SEH overwrite.
    (In this example, we again use a Windows bind shell.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记得告诉Msfvenom使用最大大小573字节，并排除我们为FTP用户名设置的坏字符。（再次提醒，尽管你可能能稍微增加一点长度，但我们最初的异常是因为我们写出了栈的末尾。我们想确保所有的shellcode都能执行。）现在将shellcode替换到漏洞中的*D*字符位置。为了使漏洞足够长以触发SEH覆盖（而不是我们在[第17章](ch17.xhtml
    "第17章：Windows中的基于堆栈的缓冲区溢出")看到的保存的返回指针覆盖），将漏洞字符串填充至1,150个字符，使用*D*字符填充。完成的漏洞如[示例18-6](ch18.xhtml#finished_seh_overwrite_exploit
    "示例18-6：完成的SEH覆盖漏洞")所示。我们的shellcode直接位于SEH覆盖之后。（在这个示例中，我们再次使用Windows绑定shell。）
- en: Example 18-6. The finished SEH overwrite exploit
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 示例18-6：完成的SEH覆盖漏洞
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When War-FTP is attached to Immunity Debugger, we have to manually tell the
    debugger to pass SEH to the program. When we run War-FTP without a debugger and
    an error is encountered, execution is automatically passed to SEH, executing `POP
    POP RET`, the short jump, and finally our shellcode.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当War-FTP连接到Immunity Debugger时，我们必须手动告诉调试器将SEH传递给程序。当我们在没有调试器的情况下运行War-FTP并遇到错误时，执行会自动传递给SEH，执行`POP
    POP RET`指令，短跳转，最后是我们的shellcode。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We have successfully built an SEH overwrite exploit for War-FTP. Though War-FTP
    allowed us to exploit the buffer overflow vulnerability by directly overwriting
    a return address or SEH, some vulnerable programs will not crash in a way that
    will allow you to control EIP but will allow you to overwrite SEH. In such cases,
    knowing the steps to exploit this sort of crash is paramount to creating a working
    exploit. Due to the way structured exception handlers work, you can count on NSEH
    being at ESP+8 every time you encounter this type of crash. When you overwrite
    SEH, you will find the pointer to the next SEH record at ESP+8\. After executing
    a `POP POP RET` series of instructions from a module that is not compiled with
    SafeSEH, you will need to execute a short jump to get to your shellcode in the
    attack string. If you continue in exploit development, you may run into another
    challenge where `\xEB` is a bad character, so you will need to find other ways
    of performing a jump.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功构建了War-FTP的SEH覆盖漏洞。虽然War-FTP允许我们通过直接覆盖返回地址或SEH来利用缓冲区溢出漏洞，但有些脆弱的程序不会以能够控制EIP的方式崩溃，但却允许你覆盖SEH。在这种情况下，知道如何利用这种崩溃是创建有效漏洞的关键。由于结构化异常处理程序的工作方式，每次遇到这种崩溃时，你可以依赖NSEH总是在ESP+8的位置。当你覆盖SEH时，会发现在ESP+8处有指向下一个SEH记录的指针。在执行来自没有启用SafeSEH的模块的`POP
    POP RET`指令系列后，你需要执行一个短跳转来到达攻击字符串中的shellcode。如果你继续进行漏洞开发，可能会遇到另一个挑战，其中`\xEB`是一个不良字符，因此你需要找到其他方法来执行跳转。
- en: In the next chapter we will finish up our study of the basics of exploit development
    with a few odds and ends, such as first discovering a crash using a technique
    called *fuzzing*, porting public exploit code to meet our needs, and writing our
    own Metasploit modules.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过一些零碎的内容完成对漏洞开发基础的学习，比如使用一种叫做*fuzzing*的技术首次发现崩溃，将公共漏洞代码移植以满足我们的需求，以及编写我们自己的Metasploit模块。
