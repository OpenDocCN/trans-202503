- en: '**8**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8**'
- en: '**MANIPULATING CONTROL FLOW IN A GAME**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**在游戏中操控控制流**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Forcing a game to execute foreign code is definitely powerful, but what if you
    could alter the way a game executes its own code? What if you could force the
    game to bypass the code that draws the fog of war, trick it into making enemies
    visible through walls, or manipulate the arguments it passes to functions? *Control
    flow manipulation* lets you do exactly that, allowing you to change what a process
    does by intercepting code execution and monitoring, modifying, or preventing it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 强制一个游戏执行外部代码确实很强大，但如果你能改变一个游戏执行自身代码的方式呢？如果你能强迫游戏绕过绘制战争迷雾的代码，欺骗它让敌人透过墙壁变得可见，或者操控它传递给函数的参数呢？*控制流操控*让你正是可以做到这一点，通过拦截代码执行并监控、修改或阻止它，来改变一个进程的行为。
- en: There are many ways to manipulate the control flow of a process, but almost
    all require you to modify the process’s assembly code. Depending on your goals,
    you’ll need to either completely remove code from the process (called *NOPing*)
    or force the process to redirect execution to injected functions (called *hooking*).
    In the beginning of this chapter, you’ll learn about NOPing, several types of
    hooking, and other control flow manipulation techniques. Once I’ve explained the
    basics, I’ll show you how I’ve applied these principles to common game libraries
    like Adobe AIR and Direct3D.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以操控进程的控制流，但几乎所有方法都需要修改进程的汇编代码。根据你的目标，你需要完全移除进程中的代码（这叫做*NOP*）或者强迫进程将执行重定向到注入的函数（这叫做*钩子*）。在本章的开头，你将学习NOP、几种类型的钩子以及其他控制流操控技巧。一旦我解释了基础知识，我将展示如何将这些原则应用到常见的游戏库，如Adobe
    AIR和Direct3D。
- en: Open the directory *GameHackingExamples/Chapter8_ControlFlow* in this book’s
    resource files to see the complete sample code for the next section and “[Hooking
    to Redirect Game Execution](ch08.xhtml#ch00lev1sec151)” on [page 153](ch08.xhtml#page_153).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 打开本书资源文件中的 *GameHackingExamples/Chapter8_ControlFlow* 目录，查看下一节的完整示例代码和 “[钩子重定向游戏执行](ch08.xhtml#ch00lev1sec151)”
    在[153页](ch08.xhtml#page_153)的内容。
- en: '**NOPing to Remove Unwanted Code**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用NOP移除不需要的代码**'
- en: '[Chapter 7](ch07.xhtml#ch07) described how to inject new code into a game,
    but the opposite—removing code from a game—can also be useful. Some hacks require
    you to stop some of a game’s original code from being executed, and to do that,
    you’ll have to get rid of it. One way to eliminate code from a game process is
    NOPing, which involves overwriting the original x86 assembly code with NOP instructions.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[第七章](ch07.xhtml#ch07)描述了如何向游戏中注入新代码，但相反——从游戏中移除代码——也同样有用。一些黑客技术要求你停止某些游戏原始代码的执行，为了做到这一点，你必须将其移除。消除游戏进程中的代码的一种方法是NOP操作，这涉及用NOP指令覆盖原始的x86汇编代码。'
- en: '***When to NOP***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***何时使用NOP***'
- en: Consider a game that won’t show the health bars of cloaked enemies. It’s pretty
    hard to see cloaked enemies coming, and you’d have a huge advantage in combat
    if you could at least see their health bars. The code to draw health bars often
    looks like [Listing 8-1](ch08.xhtml#ch8exe1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个游戏，它无法显示隐形敌人的血条。很难看到隐形敌人接近，如果至少能看到他们的血条，你在战斗中就能获得巨大的优势。绘制血条的代码通常看起来像[列表8-1](ch08.xhtml#ch8exe1)。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 8-1: The loop from the* `drawCreatureHealthBarExample()` *function*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表8-1：* `drawCreatureHealthBarExample()` *函数中的循环*'
- en: When drawing health bars, a game with cloaked creatures might use a `for` loop
    to check whether the creatures within the screen’s bounds are cloaked. If an enemy
    isn’t cloaked, the loop calls some function (`drawHealthBar()` in this example)
    to display the enemy’s health bar.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制血条时，一个有隐形生物的游戏可能会使用一个 `for` 循环来检查屏幕范围内的生物是否隐形。如果一个敌人不是隐形的，循环会调用某个函数（本例中是
    `drawHealthBar()`）来显示敌人的血条。
- en: 'Given the source code, you could force the game to draw even cloaked enemies’
    health bars by simply removing `if (c.isEnemy && c.isCloaked) continue;` from
    the code. But as a game hacker, you have only the assembly code, not the source
    code. When simplified, the assembly that [Listing 8-1](ch08.xhtml#ch8exe1) translates
    into looks something like this pseudocode:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 给定源代码，你可以通过简单地移除 `if (c.isEnemy && c.isCloaked) continue;` 来强迫游戏绘制隐形敌人的血条。但作为一个游戏黑客，你只有汇编代码，而不是源代码。当简化时，[列表8-1](ch08.xhtml#ch8exe1)翻译后的汇编代码看起来像下面的伪代码：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To trick the game into drawing all enemy health bars, regardless of cloaking,
    you’d need to remove the `JMP increment` command ➊ that executes when `c.isEnemy
    && c.isCloaked` evaluates to `true`. In assembly, though, replacing unwanted code
    with instructions that do nothing is easier than deleting code. That’s where the
    NOP command comes in. Since NOP is a single byte (0x90), you can overwrite the
    2-byte `JMP increment` command with two NOP commands. When the processor reaches
    those NOP commands, it rolls over them and falls into `drawHealthBar()` even when
    `c.isEnemy && c.isCloaked` evaluates to `true`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让游戏无论敌人是否隐形都能绘制所有敌人的血条，你需要移除在 `c.isEnemy && c.isCloaked` 为 `true` 时执行的 `JMP
    increment` 指令 ➊。不过，在汇编中，用不执行任何操作的指令替换不需要的代码比删除代码更容易。这就是 NOP 指令的作用。由于 NOP 是一个字节（0x90），你可以用两个
    NOP 指令覆盖两字节的 `JMP increment` 指令。当处理器遇到这些 NOP 指令时，它会跳过这些指令并进入 `drawHealthBar()`，即使
    `c.isEnemy && c.isCloaked` 为 `true`。
- en: '***How to NOP***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***如何进行 NOP 操作***'
- en: The first step to NOPing a chunk of assembly code is making the memory chunk
    where the code lives writable. It’s possible for the code on the same memory page
    to be executed while you’re writing the NOP commands, though, so you also want
    to make sure the memory is still executable. You can accomplish both of these
    tasks by setting the memory’s protection to `PAGE_EXECUTE_READWRITE`. Once the
    memory is properly protected, you can write the NOP commands and be done. It technically
    doesn’t hurt to leave the memory writable, but it’s good practice to also restore
    the original protection when you’re finished.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: NOP（无操作）一段汇编代码的第一步是使代码所在的内存块可写。虽然同一内存页上的代码在你写入 NOP 指令时仍然可能被执行，但你还需要确保内存仍然是可执行的。你可以通过将内存保护设置为`PAGE_EXECUTE_READWRITE`来同时完成这两个任务。一旦内存得到了适当的保护，你就可以写入
    NOP 指令并完成操作。从技术上讲，保持内存可写并不会造成问题，但当你完成操作后，恢复原始的保护设置是一种好的实践。
- en: Provided you have facilities in place for writing and protecting memory (as
    described in [Chapter 6](ch06.xhtml#ch06)), you can write a function like the
    one shown in [Listing 8-2](ch08.xhtml#ch8exe2) to write NOP commands to game memory.
    (Follow along by opening the project’s *NOPExample.cpp* file.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你有适当的设施来写入和保护内存（如[第6章](ch06.xhtml#ch06)所描述），你就可以编写类似于[示例 8-2](ch08.xhtml#ch8exe2)中显示的函数，将
    NOP 指令写入游戏内存。（可以通过打开项目中的 *NOPExample.cpp* 文件来跟随操作。）
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 8-2: Proper NOPing, complete with memory protection*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-2：正确的 NOP 操作，完整的内存保护*'
- en: In this example, the `writeNop()` function sets the appropriate memory protection,
    writes a number of NOP commands equal to `SIZE`, and reapplies the original memory
    protection level.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`writeNop()` 函数设置了适当的内存保护，写入了与 `SIZE` 相等数量的 NOP 指令，并重新应用了原始的内存保护级别。
- en: The `writeNop()` function takes the number of NOP instructions to place as a
    template parameter, since the memory functions require a correctly sized type
    at compile time. Passing an integer `SIZE` tells the memory functions to operate
    on a type of `BYTE[SIZE]` at compile time. To specify a dynamic size at runtime,
    simply drop the loop and instead call `protectMemory<BYTE>` and pass `address`
    and `address + SIZE` as arguments. As long as the size isn’t larger than a page
    (and really, you shouldn’t be NOPing a full page), this will ensure that the memory
    gets properly protected even if it’s on a page boundary.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeNop()` 函数将 NOP 指令的数量作为模板参数传递，因为内存函数需要在编译时使用正确大小的类型。传递一个整数`SIZE`会告诉内存函数在编译时操作一个类型为
    `BYTE[SIZE]` 的数组。为了在运行时指定动态大小，只需去掉循环，改为调用 `protectMemory<BYTE>`，并传入 `address`
    和 `address + SIZE` 作为参数。只要大小不超过一个页面（实际上，你不应该将一个完整页面做 NOP），这将确保即使内存在页面边界处，它也会被正确保护。'
- en: 'Call this function with the address where you want to place your NOPs and the
    number of NOP commands to place:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你想要放置 NOP 指令的地址以及要放置的 NOP 指令数量来调用此函数：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Keep in mind that the number of NOP commands should match the size in bytes
    of the command being removed. This call to `writeNop()` writes two NOP commands
    to the address 0xDEADBEEF.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，NOP 指令的数量应与被删除指令的字节大小匹配。这个 `writeNop()` 调用将两条 NOP 指令写入地址 0xDEADBEEF。
- en: '**PRACTICE NOPING**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 NOP 操作**'
- en: If you haven’t already, open *NOPExample.cpp* in this chapter’s example code
    now and play around with it for a bit. You’ll find a working implementation of
    the `writeNop()` function and an interesting function called `getAddressforNOP()`
    that scans the example program’s memory to find where the NOP command should be
    placed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有，赶紧打开本章示例代码中的*NOPExample.cpp*，玩一玩。你会发现`writeNop()`函数的工作实现和一个有趣的函数`getAddressforNOP()`，它扫描示例程序的内存，以找出NOP命令应该放置的位置。
- en: To see the NOP command in action, run the compiled NOPapplication in Visual
    Studio’s debugger with breakpoints at the start and end of the `writeNop()` function.
    When the first breakpoint is hit, press ALT-8 to open the disassembly window,
    enter `address` in the input box, and press ENTER. This brings you to the NOP’s
    target address, where you’ll see the assembly code fully intact. Press F5 to continue
    execution, which triggers the second breakpoint after allowing the application
    to place the NOPs. Finally, jump back to `address` in the disassembly tab to see
    that the code was replaced by NOPs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看NOP命令的实际效果，在Visual Studio调试器中运行编译好的NOP应用程序，并在`writeNop()`函数的开始和结束处设置断点。当第一个断点被触发时，按下ALT-8打开反汇编窗口，在输入框中输入`address`并按回车。这将把你带到NOP的目标地址，在那里你将看到完整的汇编代码。按F5继续执行，这将触发第二个断点，并允许应用程序放置NOP指令。最后，跳回反汇编窗口中的`address`，你将看到代码已被NOP替换。
- en: You can rework this code to do other cool stuff. For example, you might try
    placing NOPs on the comparisons instead of the jump or even modifying the jump’s
    type or destination.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重新调整这段代码做其他有趣的事情。例如，你可能尝试将NOP指令放在比较操作上，而不是跳转指令，或者甚至修改跳转的类型或目标地址。
- en: These and other alternative approaches may work, but note that they introduce
    more room for error than overwriting the single JMP with NOP commands. When modifying
    foreign code, make as few changes as possible to minimize the potential for errors.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些和其他替代方法可能有效，但请注意，它们比用NOP命令覆盖单个JMP指令更容易出错。当修改外部代码时，请尽量减少更改，以最小化错误的可能性。
- en: '**Hooking to Redirect Game Execution**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挂钩以重定向游戏执行**'
- en: 'So far, I’ve shown you how to manipulate games by adding code to them, hijacking
    their threads, creating new threads, and even removing existing code from their
    execution flow. These methods are very powerful on their own, but when combined,
    they form an even more potent method of manipulation called *hooking*. Hooking
    allows you to intercept precise branches of execution and redirect them to injected
    code that you’ve written to dictate what the game should do next, and it comes
    in a variety of flavors. In this section, I’ll teach you about four of the most
    powerful hooking methods for game hacking: call hooking, virtual function table
    hooking, import address table hooking, and jump hooking.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经向你展示了如何通过向游戏中添加代码、劫持其线程、创建新线程，甚至从其执行流中移除现有代码来操控游戏。这些方法本身已经非常强大，但当它们结合在一起时，就形成了一种更为强大的操控方法——*挂钩*。挂钩允许你拦截执行的精确分支，并将它们重定向到你编写的注入代码，从而决定游戏接下来应该做什么，且挂钩有多种形式。在本节中，我将教你四种最强大的游戏黑客挂钩方法：调用挂钩、虚拟函数表挂钩、导入地址表挂钩和跳转挂钩。
- en: '***Call Hooking***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调用挂钩***'
- en: 'A *call hook* directly modifies the target of a `CALL` operation to point to
    a new piece of code. There are a few variations of the `CALL` operation in x86
    assembly, but call hooks are generally used on only one: the *near call*, which
    takes an immediate address as an operand.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用挂钩*直接修改`CALL`操作的目标，将其指向一段新的代码。在x86汇编中，`CALL`操作有几种变体，但挂钩通常只应用于其中一种：*近调用*，它将立即地址作为操作数。'
- en: '**Working with Near Calls in Memory**'
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在内存中使用近调用**'
- en: 'In an assembly program, a near call looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编程序中，近调用看起来是这样的：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This near call is represented by the byte 0xE8, so you might assume it is stored
    in memory like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种近调用由字节0xE8表示，因此你可能会假设它在内存中是这样存储的：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or, when split into single bytes and swapped for endianness, like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，当拆分成单个字节并交换字节序时，像这样：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But the anatomy of a near call in memory is not that simple. Instead of storing
    the callee’s absolute address, a near call stores an offset to the callee relative
    to the address immediately after the call. Since a near call is 5 bytes, the address
    immediately after the call is 5 bytes later in memory. Given that, the address
    stored can be computed as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但近距离调用在内存中的结构并不像看起来那么简单。近距离调用不会存储被调用函数的绝对地址，而是存储相对于调用之后立即地址的偏移量。由于近距离调用是5字节，因此调用之后立即的地址是内存中的5字节。基于此，可以按以下方式计算存储的地址：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If `CALL 0x0BADF00D` lives at 0xDEADBEEF in memory, then the value after 0xE8
    is this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`CALL 0x0BADF00D`位于内存中的0xDEADBEEF地址，那么0xE8之后的值是这样的：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In memory, then, that `CALL` instruction looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中，该`CALL`指令看起来是这样的：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To hook a near call, you first need to change the offset following 0xE8 (that
    is, the little-endian 0x19 0x31 0x00 0x2D) to point to your new callee.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要挂钩一个近距离调用，首先需要更改0xE8之后的偏移量（即小端格式的0x19 0x31 0x00 0x2D）以指向你的新被调用函数。
- en: '**Hooking a Near Call**'
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**挂钩近距离调用**'
- en: 'Following the same memory protection rules shown in [Listing 8-2](ch08.xhtml#ch8exe2),
    you hook a near call like so (follow along by opening *CallHookExample.cpp*):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[示例8-2](ch08.xhtml#ch8exe2)中展示的相同内存保护规则，你可以这样挂钩一个近距离调用（通过打开*CallHookExample.cpp*来跟随）：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function takes as arguments the address of the `CALL` to hook (`hookAt`)
    and the address to redirect execution to (`newFunc`), and it uses them to calculate
    the offset required to call the code at the address `newFunc` contains. After
    you apply the correct memory protections, the `callHook()` function writes the
    new offset to the memory at `hookAt + 1` ➊, applies the old memory protections,
    calculates the address of the original call ➋, and returns that value to the caller.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数以`CALL`的地址(`hookAt`)和重定向执行的地址(`newFunc`)作为参数，并使用它们来计算调用`newFunc`包含的地址的偏移量。在应用正确的内存保护后，`callHook()`函数将新的偏移量写入`hookAt
    + 1`的内存 ➊，然后恢复原来的内存保护，计算原始调用的地址 ➋，并将该值返回给调用者。
- en: 'Here’s how you might actually use a function like this in a game hack:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是你可能在游戏破解中实际使用这样的函数的方法：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This hooks the near call to 0x0BADF00D at 0xDEADBEEF and redirects it to the
    address of `someNewFunction`, which is the code your hack will execute. After
    this is called, the `origFunc` value will hold 0x0BADF00D.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将近距离调用挂钩到0x0BADF00D（位于0xDEADBEEF），并将其重定向到`someNewFunction`的地址，这就是你的破解程序将执行的代码。调用后，`origFunc`的值将包含0x0BADF00D。
- en: '**Cleaning Up the Stack**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**清理堆栈**'
- en: The new callee must also properly handle the stack, preserve registers, and
    pass proper return values. At the least, this means your replacement function
    must match the game’s original function in both calling convention and argument
    count.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 新的被调用函数还必须正确处理堆栈，保存寄存器，并传递正确的返回值。至少，这意味着你的替代函数必须在调用约定和参数数量上与游戏的原始函数匹配。
- en: 'Let’s say this is the original full function call, in assembly:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这是原始的完整函数调用，汇编语言如下：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can tell the function has the C++ `__cdecl` convention because the stack
    is being reset by the caller. Additionally, the 0x0C bytes being cleaned from
    the stack show that there are three arguments, which you can calculate as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看函数使用C++ `__cdecl`调用约定来判断，因为堆栈是由调用者重置的。另外，从堆栈中清除的0x0C字节显示有三个参数，你可以通过以下方式计算：
- en: '![image](../images/f0155-01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0155-01.jpg)'
- en: 'Of course, you can also obtain the number of arguments by checking how many
    things are pushed to the stack: there are three `PUSH` commands, one for each
    argument.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以通过检查推送到堆栈的项数来获取参数数量：有三个`PUSH`命令，每个参数一个。
- en: '**Writing a Call Hook**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**编写调用钩子**'
- en: 'In any case, the new callee, `someNewFunction`, must follow the `__cdecl` convention
    and have three arguments. Here’s an example skeleton for the new callee:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，新的被调用函数`someNewFunction`必须遵循`__cdecl`约定，并且有三个参数。以下是新被调用函数的示例框架：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In Visual Studio, C++ programs use the `__cdecl` convention by default, so technically
    you could omit it from your function definition; however, I’ve found it’s better
    to be verbose so you get into the habit of being specific. Also keep in mind that
    if the caller expects a value to be returned, the return type of your function
    should match as well. This example assumes the return type is always a `DWORD`
    or smaller. Since return types in this size range will all be passed back on EAX,
    further examples will also use a return type of `DWORD`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，C++ 程序默认使用 `__cdecl` 调用约定，因此从技术上讲，你可以在函数定义中省略它；然而，我发现最好保持详细，这样可以养成具体明确的习惯。还要记住，如果调用者期望返回值，那么你的函数的返回类型也应该匹配。这个示例假设返回类型总是
    `DWORD` 或更小。因为这个大小范围内的返回值都会通过 EAX 返回，接下来的示例也会使用 `DWORD` 作为返回类型。
- en: 'In most cases, a hook finishes by calling the original function and passing
    its return value back to the caller. Here’s how all of that might fit together:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，钩子通过调用原始函数并将其返回值传递回调用者来完成。下面是这些内容如何组合在一起的示例：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example uses `typedef` to declare a type representing the original function’s
    prototype and creates a pointer with this type to the original function. Then
    `someNewFunction()` uses this pointer to call the original function with the original
    arguments and pass the returned value back to the caller.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用 `typedef` 声明一个类型，表示原始函数的原型，并创建一个指向该原始函数的指针。然后 `someNewFunction()` 使用这个指针调用原始函数，传递原始参数并将返回值传递回调用者。
- en: Right now, all `someNewFunction()` does is return to the original function.
    But you can do whatever you want from inside the `someNewFunction()` call from
    here. You can modify the parameters being passed to the original function or intercept
    and store interesting parameters for later use. If you know the caller isn’t expecting
    a return value (or if you know how to spoof the return value), you can even forget
    about the original function and completely replace, replicate, or improve its
    functionality inside the new callee. Once you’ve perfected this skill, you can
    add your own native C or C++ code to any part of a game that you wish.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`someNewFunction()` 所做的只是返回到原始函数。但你可以在 `someNewFunction()` 的调用中做任何你想做的事情。你可以修改传递给原始函数的参数，或者拦截并存储有趣的参数以备后用。如果你知道调用者不期望返回值（或者知道如何伪造返回值），你甚至可以忽略原始函数，完全替换、复制或改进其功能，放入新的被调用函数中。一旦你掌握了这项技能，你就可以在游戏的任何部分添加你自己的本地
    C 或 C++ 代码。
- en: '***VF Table Hooking***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***VF 表格钩子***'
- en: Unlike call hooks, *virtual function (VF) table hooks* don’t modify assembly
    code. Instead, they modify the function addresses stored in the VF tables of classes.
    (If you need a refresher on VF tables, see “[A Class with Virtual Functions](ch04.xhtml#ch00lev1sec78)”
    on [page 75](ch04.xhtml#page_75).) All instances of the same class type share
    a static VF table, so VF table hooks will intercept all calls made to a member
    function, regardless of which class instance the game is calling the function
    from. This can be both powerful and tricky.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与调用钩子不同，*虚拟函数（VF）表钩子*并不修改汇编代码。相反，它们修改存储在类的 VF 表中的函数地址。（如果你需要复习 VF 表，请参阅[《具有虚拟函数的类》](ch04.xhtml#ch00lev1sec78)章节中的[第75页](ch04.xhtml#page_75)）。同一类类型的所有实例共享一个静态的
    VF 表，因此 VF 表钩子会拦截对成员函数的所有调用，无论游戏是从哪个类实例调用该函数。这既强大又棘手。
- en: '**THE TRUTH ABOUT VF TABLES**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**VF 表格的真相**'
- en: To simplify the explanation, I lied a little when I said that VF table hooks
    could intercept all calls made to a function. In reality, the VF table is traversed
    only when a virtual function is called in a way that leaves the compiler with
    some plausible type ambiguity. For example, a VF table will be traversed when
    a function is called through the `inst->function()` call format. A VF table won’t
    be traversed when a virtual function is invoked in such a way that the compiler
    is sure about the type, as in `inst.function()` or similar calls, since the compiler
    will know the function’s address. Conversely, calling `inst.function()` from a
    scope where `inst` is passed in as a reference would trigger a VF table traversal.
    Before you try to deploy VF table hooking, make sure the function calls you want
    to hook have type ambiguity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化说明，当我说VF表钩子可以拦截所有对函数的调用时，我稍微撒了个谎。实际上，只有当虚函数的调用方式让编译器产生某种合理的类型模糊时，VF表才会被遍历。例如，当通过`inst->function()`调用函数时，VF表会被遍历。虚函数调用时如果编译器对类型没有疑问，例如`inst.function()`或类似的调用，VF表则不会被遍历，因为编译器已经知道函数的地址。相反，从一个作用域调用`inst.function()`，如果`inst`是作为引用传入的，那么VF表就会被遍历。在你尝试部署VF表钩子之前，确保你想要挂钩的函数调用有类型模糊性。
- en: '**Writing a VF Table Hook**'
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**编写VF表钩子**'
- en: Before we go any deeper into how to place a VF table hook, we need to talk about
    those pesky calling conventions again. VF tables are used by class instances to
    call virtual member functions, and all member functions will have the `__thiscall`
    convention. The name `__thiscall` is derived from the `this` pointer that member
    functions use to reference the active class instance. Thus, member functions are
    given `this` as a pseudoparameter on ECX.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨如何放置VF表钩子之前，我们需要再次讨论那些令人头疼的调用约定。VF表由类实例用来调用虚成员函数，所有成员函数都将采用`__thiscall`约定。`__thiscall`这个名字来源于成员函数用来引用当前类实例的`this`指针。因此，成员函数会将`this`作为伪参数放置在ECX寄存器上。
- en: 'It’s possible to match the prototype of a `__thiscall` by declaring a class
    that acts as a container for all `__thiscall` hook callbacks, but I don’t prefer
    this method. Instead, I find it easier to control the data using inline assembly.
    Let’s explore how you control the data when placing a VF hook on a class that
    looks like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明一个类作为所有`__thiscall`钩子回调的容器，确实可以匹配`__thiscall`的原型，但我不太倾向于使用这种方法。相反，我发现通过内联汇编来控制数据更容易。让我们看看当你在一个像这样的类上放置VF钩子时如何控制数据：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `someBaseClass` class just has one member (a public virtual function), and
    the `someClass` class inherits from `someBaseClass` and overrides the `someBaseClass::someFunction`
    member. To hook `someClass::someFunction`, you replicate the prototype in your
    VF table hook, as shown in [Listing 8-3](ch08.xhtml#ch8exe3) (follow along in
    the *VFHookExample.cpp* file of the project).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`someBaseClass`类只有一个成员（一个公共虚函数），而`someClass`类继承自`someBaseClass`并重写了`someBaseClass::someFunction`成员。要挂钩`someClass::someFunction`，你需要在VF表钩子中复制原型，如[清单8-3](ch08.xhtml#ch8exe3)所示（在项目中的*VFHookExample.cpp*文件中查看）。'
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 8-3: The start of a VF table hook*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-3：VF表钩子的开始*'
- en: This function works as a hook because `__thiscall` only differs from `__stdcall`
    in that the former is given `this` on ECX. To reconcile this small difference,
    the callback function uses inline assembly (denoted by `__asm`) to copy `this`
    from ECX to a static variable ➊. Since the static variable is actually initialized
    as a global, the only code that executes before `MOV _this, ECX` is the code that
    sets up the stack frame—and that code never touches ECX. That ensures that the
    proper value is in ECX when the assembly is executed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数之所以能作为钩子工作，是因为`__thiscall`与`__stdcall`的唯一区别在于前者将`this`传递到ECX寄存器。为了调和这一小小的差异，回调函数使用内联汇编（用`__asm`表示）将`this`从ECX复制到静态变量➊。由于静态变量实际上初始化为全局变量，因此在执行`MOV
    _this, ECX`之前，唯一执行的代码是设置栈帧的代码——而这段代码从不接触ECX。这确保了在执行汇编时，ECX中的值是正确的。
- en: '**NOTE**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If multiple threads start calling the same VF function, the* `someNewVFFunction()`
    *hook will break because* `_this` *might be modified by one call while still being
    used by another call. I’ve never personally run into this problem, as games don’t
    typically throw around multiple instances of critical classes between threads,
    but an efficient remedy would be to store* `_this` *in thread local storage, ensuring
    each thread would have its own copy.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果多个线程开始调用相同的 VF 函数，* `someNewVFFunction()` *钩子将会失效，因为* `_this` *可能在一个调用被修改的同时仍然被另一个调用使用。我个人从未遇到过这个问题，因为游戏通常不会在线程之间传递多个关键类的实例，但一个有效的解决方法是将*
    `_this` *存储在线程本地存储中，从而确保每个线程都有自己的副本。*'
- en: 'Before returning, a VF table callback must also restore ECX, to keep with the
    `__thiscall` convention. Here’s how that process looks:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回之前，VF 表回调还必须恢复 ECX，以保持与 `__thiscall` 调用约定一致。以下是这个过程的具体操作：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After executing some game-hacking code, this version of the function `someNewVFFunction()`
    restores ECX ➊ with a reversed version of the first `MOV` instruction from [Listing
    8-3](ch08.xhtml#ch8exe3).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行一些游戏破解代码之后，这个版本的函数 `someNewVFFunction()` 使用反向版本的第一个 `MOV` 指令来恢复 ECX ➊，该指令来自
    [Listing 8-3](ch08.xhtml#ch8exe3)。
- en: 'Unlike with `__cdecl` functions, however, you shouldn’t call functions that
    use the `__thiscall` convention from pure C++ using only a function pointer and
    `typedef` (as you would for a call hook). When calling the original function from
    a VF table hook, you must use inline assembly—that’s the only way to be sure you’re
    passing data (specifically `_this`) around properly. For example, this is how
    you continue to build the `someNewVFFunction()` hook:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与 `__cdecl` 函数不同的是，你不应该仅使用函数指针和 `typedef`（如同在调用钩子中那样）从纯 C++ 调用使用 `__thiscall`
    调用约定的函数。当从 VF 表钩子中调用原始函数时，必须使用内联汇编——这是确保正确传递数据（特别是 `_this`）的唯一方法。例如，以下是如何继续构建
    `someNewVFFunction()` 钩子：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, `someNewVFFunction()` stores `this` in the `_this` variable, allows some
    code to execute, calls the original game function ➊ that’s being hooked, stores
    that function’s return value in `_ret` ➋, allows some more code to execute, restores
    `this` to ECX ➌, and returns the value stored in `_ret`. The callee cleans the
    stack for `__thiscall` calls, so unlike a call hook, the pushed argument doesn’t
    need to be removed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`someNewVFFunction()` 将 `this` 存储在 `_this` 变量中，允许一些代码执行，调用被钩住的原始游戏函数 ➊，将该函数的返回值存储在
    `_ret` ➋，然后允许更多代码执行，恢复 `this` 到 ECX ➌，并返回存储在 `_ret` 中的值。被调用者负责清理 `__thiscall`
    调用的栈，因此与调用钩子不同，推入的参数无需移除。
- en: '**NOTE**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you want to remove a single pushed argument at any point, use the assembly
    instruction* `ADD ESP, 0x4` *because a single argument is 4 bytes.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想在任何时刻移除一个被推入的参数，使用汇编指令* `ADD ESP, 0x4` *，因为一个参数占 4 字节。*'
- en: '**Using a VF Table Hook**'
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 VF 表钩子**'
- en: 'With the calling convention established and a skeleton callback in place, it’s
    time to move on to the fun part: actually using a VF table hook. A pointer to
    a class’s VF table is the first member of every class instance, so placing a VF
    table hook requires only a class instance address and the index of the function
    to be hooked. Using these two pieces of information, you need only a modest amount
    of code to place a hook. Here’s an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了调用约定并建立了基本的回调框架后，是时候进入有趣的部分了：真正使用 VF 表钩子。每个类实例的第一个成员是指向该类 VF 表的指针，因此设置 VF
    表钩子只需要类实例的地址和要钩住的函数索引。通过这两条信息，你只需编写少量代码就能设置钩子。以下是一个示例：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `hookVF()` function finds the VF table by reading the first member of the
    class instance ➊ and storing it in `VFTable`. Since the VF table is just an array
    of `DWORD`-sized addresses, this code finds the function address by multiplying
    the function’s index in the VF table (`funcIndex` in this example) by the size
    of a `DWORD`, which is 4, and adding the result to the VF table’s address. From
    there, `hookVF()` acts similar to a call hook: it makes sure the memory is properly
    accessible by setting appropriate protections, stores the original function address
    for later, writes the new function address, and finally, restores the original
    memory protection.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`hookVF()` 函数通过读取类实例的第一个成员 ➊ 来找到 VF 表，并将其存储在 `VFTable` 中。由于 VF 表只是一个 `DWORD`
    大小地址的数组，这段代码通过将函数在 VF 表中的索引（本例中的 `funcIndex`）乘以 `DWORD` 的大小，即 4，再将结果加到 VF 表的地址上，从而找到函数的地址。之后，`hookVF()`
    的作用类似于调用钩子：它通过设置适当的保护确保内存可访问，存储原始函数地址以便后续使用，写入新的函数地址，最后恢复原始的内存保护。'
- en: 'You’ll typically hook the VF table of a class instantiated by the game, and
    calling a function like `hookVF()` for a VF table hook looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会钩住游戏实例化的类的 VF 表，而像 `hookVF()` 这样的函数调用，钩住 VF 表看起来是这样的：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As usual, you need to find `classInstAddr` and the `funcIndex` argument ahead
    of time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，你需要提前找到 `classInstAddr` 和 `funcIndex` 参数。
- en: There are some very niche cases in which VF table hooks are useful, and it can
    be really hard to find the right class pointers and functions. Given that, instead
    of showing contrived use cases, I’ll come back to VF table hooks in “[Applying
    Jump Hooks and VF Hooks to Direct3D](ch08.xhtml#ch00lev1sec174)” on [page 175](ch08.xhtml#page_175),
    once I’ve discussed other types of hooking.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些非常小众的情况下，VF 表钩子是有用的，而找到正确的类指针和函数可能非常困难。考虑到这一点，我不会展示一些牵强的使用案例，而是会在“[将跳转钩子和
    VF 钩子应用于 Direct3D](ch08.xhtml#ch00lev1sec174)”的 [第 175 页](ch08.xhtml#page_175)
    中回到 VF 表钩子，一旦我讨论了其他类型的钩子。
- en: If you want to play with VF hooks before reading more, add new virtual functions
    to the example classes in this book’s resource files and practice hooking them.
    You might even create a second class that derives from `someBaseClass` and place
    a hook on its virtual table to demonstrate how you can have two completely separate
    VF hooks on two classes that inherit the same base class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在阅读更多内容之前先玩一下 VF 钩子，可以在本书资源文件中的示例类里添加新的虚拟函数，并练习钩住它们。你甚至可以创建一个从 `someBaseClass`
    派生的第二个类，并在其虚拟表上放置一个钩子，展示如何在两个继承自相同基类的类上拥有两个完全独立的 VF 钩子。
- en: '***IAT Hooking***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***IAT 钩子***'
- en: IAT hooks actually replace function addresses in a specific type of VF table,
    called the *import address table (IAT)*. Each loaded module in a process contains
    an IAT in its PE header. A module’s IAT holds a list of all the other modules
    on which the module depends, as well as a list of functions that the module uses
    from each dependency. Think of an IAT as a lookup table for APIs to call one another.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: IAT 钩子实际上是通过替换特定类型的 VF 表中的函数地址来工作的，这种表被称为 *导入地址表（IAT）*。每个进程中加载的模块都包含一个 IAT，在其
    PE 头部。一个模块的 IAT 保存了该模块依赖的所有其他模块的列表，以及该模块使用的每个依赖项中的函数列表。可以将 IAT 看作是一个 API 调用彼此的查找表。
- en: When a module is loaded, its dependencies are also loaded. Dependency loading
    is a recursive process that continues until all dependencies for all modules are
    loaded. As each dependency is loaded, the operating system finds all functions
    used by the dependent module and fills any blank spaces in its IAT with the function
    addresses. Then, when a module calls a function from a dependency, it makes that
    call by resolving the function’s address from the IAT.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块被加载时，它的依赖项也会被加载。依赖项加载是一个递归过程，直到所有模块的所有依赖项都被加载为止。当每个依赖项被加载时，操作系统会找到被依赖模块所使用的所有函数，并用函数地址填充其
    IAT 中的空白位置。然后，当模块调用依赖项中的某个函数时，它会通过从 IAT 中解析函数地址来执行该调用。
- en: '**Paying for Portability**'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**为了可移植性付出的代价**'
- en: Function addresses are always resolved from the IAT in real time, so hooking
    the IAT is similar to hooking VF tables. Since function pointers are stored in
    the IAT beside their actual names, there’s no need to do any reverse engineering
    or memory scanning; as long as you know the name of the API you want to hook,
    you can hook it! Moreover, IAT hooking lets you easily hook Windows API calls
    on a module-specific basis, allowing your hooks to intercept only API calls from
    a game’s main module.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 函数地址总是从 IAT 中实时解析出来的，所以钩住 IAT 类似于钩住 VF 表。由于函数指针存储在 IAT 中并与其实际名称一起出现，所以不需要进行逆向工程或内存扫描；只要你知道你想钩住的
    API 的名称，就可以钩住它！此外，IAT 钩子使你可以在模块特定的基础上轻松钩住 Windows API 调用，从而允许你的钩子仅拦截来自游戏主模块的 API
    调用。
- en: This portability has a cost, though; the code to place an IAT hook is much more
    complex than what you’ve seen so far. First, you need to locate the PE header
    of the game’s main module. Since the PE header is the first structure in any binary,
    you can find it at the base address of each module, as shown in [Listing 8-4](ch08.xhtml#ch8exe4)
    (follow along in the *IATHookExample.cpp* file of the project).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种可移植性是有代价的；放置 IAT 钩子的代码比你迄今所见的要复杂得多。首先，你需要定位游戏主模块的 PE 头部。由于 PE 头是任何二进制文件中的第一个结构，你可以在每个模块的基地址处找到它，如
    [Listing 8-4](ch08.xhtml#ch8exe4) 中所示（可以在项目的 *IATHookExample.cpp* 文件中跟随）。
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 8-4: Fetching the module’s base address*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-4：获取模块的基地址*'
- en: Once you’ve found the base address, you must verify that the PE header is valid.
    This validation can be very important, as some games try to prevent these types
    of hooks by scrambling nonessential parts of their PE header after they load.
    A valid PE header is prefixed by a DOS header, which indicates the file is a DOS
    MZ executable; the DOS header is identified by the magic value 0x5A4D. A member
    of the DOS header called `e_lfanew` then points to the optional header, which
    contains values like the size of the code, a version number, and so on and is
    identified by the magic value 0x10B.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你找到了基地址，就必须验证PE头部是否有效。这项验证非常重要，因为一些游戏会在加载后通过混淆PE头部中的非必要部分来防止这类钩子。有效的PE头部之前是一个DOS头部，表示该文件是一个DOS
    MZ可执行文件；DOS头部的标识值为0x5A4D。DOS头部中的一个成员`e_lfanew`指向可选头部，后者包含诸如代码大小、版本号等信息，并由魔术值0x10B标识。
- en: The Windows API has PE structures called `IMAGE_DOS_HEADER` and `IMAGE_OPTIONAL_HEADER`
    that correspond to the DOS header and optional header, respectively. You can use
    them to validate the PE header with code like [Listing 8-5](ch08.xhtml#ch8exe5).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Windows API有PE结构`IMAGE_DOS_HEADER`和`IMAGE_OPTIONAL_HEADER`，分别对应DOS头部和可选头部。你可以通过代码如[Listing
    8-5](ch08.xhtml#ch8exe5)来验证PE头部。
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 8-5: Confirming the DOS and optional headers are valid*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-5: 确认DOS头部和可选头部有效*'
- en: The calls to `pointMemory()` create pointers to the two headers that need to
    be checked. If either `if()` statement returns `0`, then the corresponding header
    has the wrong magic number, meaning the PE header isn’t valid.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对`pointMemory()`的调用创建了两个指向需要检查的头部的指针。如果任何一个`if()`语句返回`0`，则表示对应的头部的魔术数字错误，意味着PE头部无效。
- en: References to the IAT from assembly are hardcoded, meaning assembly references
    don’t traverse the PE header to locate the IAT. Instead, each function call has
    a static location indicating where to find the function address. That means overwriting
    the PE header to say that there are no imports is a viable way to protect against
    IAT hooks, and some games have this protection.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从汇编中对IAT的引用是硬编码的，这意味着汇编引用不会遍历PE头部来定位IAT。相反，每个函数调用都有一个静态位置，指示在哪里可以找到函数地址。这意味着通过覆盖PE头部来声明没有导入是防止IAT钩子的可行方法，一些游戏就采取了这种保护措施。
- en: To account for that, you also need to make sure the game’s IAT still exists.
    [Listing 8-6](ch08.xhtml#ch8exe6) shows how to add such a check to the code in
    [Listing 8-5](ch08.xhtml#ch8exe5).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这种情况，你还需要确保游戏的IAT仍然存在。[Listing 8-6](ch08.xhtml#ch8exe6)展示了如何在[Listing 8-5](ch08.xhtml#ch8exe5)中的代码中添加此检查。
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 8-6: Checking that the IAT actually exists*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-6: 检查IAT是否实际存在*'
- en: The PE header contains many sections that store information about the application’s
    code, embedded resources, relocations, and so on. The piece of code in [Listing
    8-6](ch08.xhtml#ch8exe6) is particularly interested in the data section, which—as
    you might guess—stores many different types of data. Each type of data is stored
    in its own directory, and the `DataDirectory` member of `IMAGE_OPTIONAL_HEADER`
    is an array of directory headers that describes the size and virtual address of
    each directory in the data section. The Windows API defines a constant called
    `IMAGE_DIRECTORY_ENTRY_IMPORT`, which happens to be the index of the IAT header
    within the `DataDirectory` array.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: PE头部包含许多部分，用于存储应用程序代码、嵌入资源、重定位等信息。[Listing 8-6](ch08.xhtml#ch8exe6)中的代码特别关注数据段——正如你可能猜到的，它存储了许多不同类型的数据。每种类型的数据存储在自己的目录中，`IMAGE_OPTIONAL_HEADER`中的`DataDirectory`成员是一个目录头数组，描述了数据段中每个目录的大小和虚拟地址。Windows
    API定义了一个常量`IMAGE_DIRECTORY_ENTRY_IMPORT`，它恰好是IAT头部在`DataDirectory`数组中的索引。
- en: Thus, this code uses `optHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]`
    to resolve the header of the IAT and check that the header’s `Size` and `VirtualAddress`
    are nonzero, essentially confirming its existence.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这段代码使用`optHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]`来解析IAT的头部，并检查该头部的`Size`和`VirtualAddress`是否非零，基本上确认了其存在性。
- en: '**Traversing the IAT**'
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**遍历IAT**'
- en: Once you know the IAT is still intact, you can start traversing it, and this
    is where IAT hooking starts to get ugly. The IAT is an array of structures called
    *import descriptors*. There is one import descriptor for each dependency, each
    import descriptor points to an array of structures called *thunks*, and each thunk
    represents a function imported from the dependency.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确认IAT仍然完好无损，你就可以开始遍历它了，这也是IAT钩子开始变得复杂的地方。IAT是一个由称为*导入描述符*的结构体数组组成。每个依赖项都有一个导入描述符，每个导入描述符指向一个称为*thunks*的结构体数组，每个thunk代表从依赖项中导入的函数。
- en: Luckily, the Windows API exposes both the import descriptors and thunks through
    the `IMAGE_IMPORT_DESCRIPTOR` and `IMAGE_THUNK_DATA` structures, respectively.
    Having the structures predefined saves you from creating your own, but it doesn’t
    make the code to traverse the IAT any prettier. To see what I mean, look at [Listing
    8-7](ch08.xhtml#ch8exe7), which builds on [Listings 8-4](ch08.xhtml#ch8exe4) through
    [8-6](ch08.xhtml#ch8exe6).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Windows API通过`IMAGE_IMPORT_DESCRIPTOR`和`IMAGE_THUNK_DATA`结构分别暴露了导入描述符和thunks。由于这些结构是预定义的，你不必自己创建它们，但这并没有使遍历IAT的代码更加简洁。要理解我的意思，看看[列表
    8-7](ch08.xhtml#ch8exe7)，它是基于[列表 8-4](ch08.xhtml#ch8exe4)至[8-6](ch08.xhtml#ch8exe6)构建的。
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 8-7: Iterating over the IAT to find a function*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-7：遍历IAT以查找函数*'
- en: Keeping in mind that the import descriptors are stored relative to the start
    of the PE header, this code adds the module’s base address to the virtual address
    found in the IAT’s directory header ➊, creating a pointer, `impDesc`, that points
    to the module’s first import descriptor.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，导入描述符是相对于PE头部的开始位置存储的，代码通过将模块的基地址加到IAT目录头部找到的虚拟地址 ➊，创建一个指针`impDesc`，指向模块的第一个导入描述符。
- en: Import descriptors are stored in a sequential array, and a descriptor with a
    `FirstThunk` member set to `NULL` signifies the end of the array. Knowing this,
    the code uses a `while` loop ➋ that continues until `impDesc->FirstThunk` is `NULL`,
    incrementing the descriptor by executing `impDesc++` each iteration.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 导入描述符存储在一个顺序数组中，若某个描述符的`FirstThunk`成员为`NULL`，则表示数组的结束。知道这一点后，代码使用`while`循环 ➋，直到`impDesc->FirstThunk`为`NULL`，每次迭代时通过执行`impDesc++`来递增描述符。
- en: For each import descriptor, the code creates a pointer called `thunkData` ➌
    that points to the first thunk inside the descriptor. Using a familiar loop, the
    code iterates over thunks ➍ until one is found with a `Function` member set to
    `NULL`. The loop also uses an integer, `n`, to keep track of the current thunk
    index, as the index is important when placing the hook.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个导入描述符，代码会创建一个指针，名为`thunkData` ➌，指向描述符中的第一个thunk。通过一个熟悉的循环，代码会遍历thunks ➍，直到找到一个`Function`成员为`NULL`的thunk。该循环还使用一个整数`n`来跟踪当前的thunk索引，因为在放置钩子时，索引非常重要。
- en: '**Placing the IAT Hook**'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**放置IAT钩子**'
- en: From here, placing the hook is just a matter of finding the proper function
    name and replacing the function address. You can find the name inside the nested
    `while` loop, as shown in [Listing 8-8](ch08.xhtml#ch8exe8).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，放置钩子只需要找到正确的函数名称并替换函数地址。你可以在嵌套的`while`循环中找到该名称，如[列表 8-8](ch08.xhtml#ch8exe8)所示。
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 8-8: Finding the function name*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-8：查找函数名称*'
- en: The function name for each thunk is stored at `thunkData->u1.AddressOfData +
    2` bytes into the module, so you can add that value to the module’s base address
    to locate the function name in memory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个thunk的函数名称存储在`thunkData->u1.AddressOfData + 2`字节处，因此你可以将该值加到模块的基地址上，以定位内存中的函数名称。
- en: 'After obtaining a pointer to the function name, use `strcmp()` to check whether
    it’s the target function, like so:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 获取到函数名称的指针后，使用`strcmp()`来检查它是否为目标函数，方法如下：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once you’ve located the target function using its name, you simply need to overwrite
    the function address with the address of your own function. Unlike function names,
    function addresses are stored in an array at the start of each import descriptor.
    Using `n` from the thunk loop, you can finally set the hook, as shown in [Listing
    8-9](ch08.xhtml#ch8exe9).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你通过其名称找到了目标函数，你只需将函数地址覆盖为你自己函数的地址。与函数名称不同，函数地址存储在每个导入描述符开头的数组中。使用`n`从thunk循环中，你最终可以设置钩子，如[列表
    8-9](ch08.xhtml#ch8exe9)所示。
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 8-9: Finding the function address*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-9：查找函数地址*'
- en: This code locates the VF table for the current descriptor by adding the address
    of the first thunk to the module base address. The VF table is an array of function
    addresses, so the code uses the `n` variable as an index to locate the target
    function address.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过将第一个thunk的地址加到模块基地址来定位当前描述符的VF表。VF表是一个函数地址数组，因此代码使用`n`变量作为索引来定位目标函数地址。
- en: 'Once the address is found, the code in [Listing 8-9](ch08.xhtml#ch8exe9) works
    just like a typical VF hook: it stores the original function address, sets the
    protection of index `n` in the VF table to `PAGE_READWRITE` ➊, inserts the new
    function address into the VF table ➋, and finally restores the old protection.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到地址，[列表 8-9](ch08.xhtml#ch8exe9)中的代码就像典型的VF钩取一样工作：它存储原始函数地址，将VF表中索引`n`的保护设置为`PAGE_READWRITE`
    ➊，将新的函数地址插入到VF表中 ➋，最后恢复旧的保护状态。
- en: If you stitch together the code from [Listings 8-4](ch08.xhtml#ch8exe4) through
    [8-9](ch08.xhtml#ch8exe9), the final IAT hooking function looks like [Listing
    8-10](ch08.xhtml#ch8exe10).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将[列表 8-4](ch08.xhtml#ch8exe4)到[8-9](ch08.xhtml#ch8exe9)的代码拼接起来，最终的IAT钩取函数看起来就像[列表
    8-10](ch08.xhtml#ch8exe10)。
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 8-10: The complete IAT hooking function*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-10：完整的IAT钩取函数*'
- en: This is the most complex code that we’ve put together so far, and it’s pretty
    hard to read when squished to fit on a page. If you haven’t yet wrapped your head
    around what it’s doing, you might want to study the example code from this book’s
    resource files before continuing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们到目前为止编写的最复杂的代码，在页面压缩显示时非常难以阅读。如果你还没完全理解它的作用，建议在继续之前先学习本书资源文件中的示例代码。
- en: '**Using an IAT Hook to Sync with a Game Thread**'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用IAT钩取与游戏线程同步**'
- en: With the code in [Listing 8-10](ch08.xhtml#ch8exe10), hooking any Windows API
    function is as simple as knowing the function name and the proper prototype. The
    `Sleep()` API is a common API to hook when game hacking, as bots can use a `Sleep()`
    hook to thread-sync with a game’s main loop.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[列表 8-10](ch08.xhtml#ch8exe10)中的代码，钩取任何Windows API函数都变得像知道函数名和正确的原型一样简单。`Sleep()`
    API是游戏黑客中常用的钩取API，因为机器人可以通过钩取`Sleep()`来与游戏的主循环同步线程。
- en: '**GETTING IN SYNC WITH THREAD SYNC**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**与线程同步**'
- en: Your injected code will inevitably have to sync with a game’s main loop, or
    it won’t work. When you’re reading or writing data larger than 4 bytes, for example,
    being out of sync allows the game to read or write that data at the same time
    as you. You’ll be stepping on the game’s toes, and vice versa, leading to all
    sorts of race conditions and data corruption issues. Similarly, if you try to
    call a game’s function from your own thread, you run the risk of crashing the
    game if the function is not thread safe.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你的注入代码必然需要与游戏的主循环同步，否则它将无法正常工作。例如，当你读写大于4字节的数据时，如果不同步，游戏可能会同时读写这些数据。这时你就会干扰到游戏，反之亦然，导致各种竞态条件和数据损坏问题。同样，如果你尝试从自己的线程调用游戏函数，如果该函数不是线程安全的，可能会导致游戏崩溃。
- en: Since IAT hooks are thread-safe modifications to the PE header, they can be
    placed from any thread. By placing one on a function that’s called before or after
    the game’s main loop, you can effectively sync with the game’s main thread. All
    you need to do is place the hook and execute any thread-sensitive code from your
    hook callback.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IAT钩取是对PE头的线程安全修改，它们可以从任何线程进行设置。通过将钩子放置在游戏主循环之前或之后调用的函数上，你可以有效地与游戏的主线程同步。你需要做的就是放置钩子，并在钩子回调中执行任何线程敏感的代码。
- en: 'Here’s one way to use `hookIAT()` to hook the `Sleep()` API:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`hookIAT()`钩取`Sleep()` API的一种方式：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here’s why this works. At the end of a game’s main loop, it might call `Sleep()`
    to rest until it’s ready to draw the next frame. Since it’s sleeping, it’s safe
    for you to do anything you want without worrying about synchronization issues.
    Some games might not do this, or they might call `Sleep()` from multiple threads,
    and those games will require a different method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是为什么这能奏效的原因。在游戏的主循环结束时，它可能会调用`Sleep()`来休息，直到准备好绘制下一帧。由于处于休眠状态，你可以安全地执行任何操作而不必担心同步问题。有些游戏可能不会这样做，或者它们可能从多个线程调用`Sleep()`，这些游戏就需要使用不同的方法。
- en: A more portable alternative is to hook the `PeekMessageA()` API function, because
    games often call that function from the main loop while waiting for input. Then,
    your bot can do thread-sensitive operations from within the `PeekMessageA()` hook,
    ensuring that they’re done from the game’s main thread. You may also want your
    bot to use this method to hook the `send()` and `recv()` API functions, as intercepting
    these allows you to create a packet sniffer relatively simply.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更具可移植性的替代方法是钩住`PeekMessageA()` API函数，因为游戏通常会在等待输入时从主循环调用该函数。然后，你的机器人可以在`PeekMessageA()`钩子内进行线程敏感的操作，确保它们从游戏的主线程中执行。你也可能希望你的机器人使用这种方法钩住`send()`和`recv()`
    API函数，因为拦截这些函数可以相对简单地创建一个数据包嗅探器。
- en: '***Jump Hooking***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***跳转钩子***'
- en: '*Jump hooking* allows you to hook code in places where there is no branching
    code to manipulate. A jump hook replaces the code being hooked with an unconditional
    jump to a *trampoline function*. When the jump is hit, the trampoline function
    stores all current register and flag values, calls a callback function of your
    choice, restores the registers, restores the flags, executes the code that was
    replaced by the hook, and finally jumps back to the code just below the hook.
    This process is shown in [Figure 8-1](ch08.xhtml#ch8fig1).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*跳转钩子*允许你在没有分支代码可以操作的地方钩住代码。跳转钩子用一个无条件跳转替换被钩住的代码，跳转到一个*弹跳函数*。当跳转被触发时，弹跳函数会保存所有当前的寄存器和标志值，调用你选择的回调函数，恢复寄存器，恢复标志，执行被钩住的代码，最后跳回钩子下方的代码。这一过程在[图
    8-1](ch08.xhtml#ch8fig1)中展示。'
- en: '![image](../images/f08-01.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f08-01.jpg)'
- en: '*Figure 8-1: A jump hook*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：一个跳转钩子*'
- en: The original code shows an example of some unmodified assembly you might find
    in a game, and the hooked code shows how that assembly might look after being
    hooked by a jump hook. The trampoline box shows an example trampoline function,
    in assembly, and the callback represents the code you’re trying to execute through
    hooking. In the original code, the assembly executes from top to bottom. In the
    hooked code, to get from the `SUB EAX,1` instruction to the `RETN` instruction,
    execution must follow the path shown by the dashed arrows.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 原始代码展示了你在游戏中可能遇到的一些未修改的汇编代码，而钩住的代码展示了跳转钩子钩住后该汇编代码的样子。弹跳函数框展示了一个汇编语言的示例弹跳函数，而回调函数则表示你通过钩子试图执行的代码。在原始代码中，汇编代码是从上到下执行的。在钩住的代码中，要从`SUB
    EAX,1`指令跳到`RETN`指令，执行路径必须按照虚线箭头所示的路径进行。
- en: '**NOTE**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If your callback code is simple, it can be integrated into the trampoline
    instead. It’s also not always necessary to store and restore the registers and
    flags, but doing so is good practice.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你的回调代码很简单，它可以直接集成到弹跳函数中。并且并不总是需要存储和恢复寄存器和标志，但这样做是良好的实践。*'
- en: '**Placing a Jump**'
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**放置跳转**'
- en: 'The byte code of an unconditional jump resembles that of a near call, but the
    first byte is 0xE9 instead of 0xE8\. (See “[Working with Near Calls in Memory](ch08.xhtml#ch00lev1sec153)”
    on [page 153](ch08.xhtml#page_153) for a refresher.) In [Figure 8-1](ch08.xhtml#ch8fig1),
    the unconditional jump `JMP trampoline` replaces the following four operations:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 无条件跳转的字节码与近距离调用类似，但第一个字节是0xE9而不是0xE8。（有关更多信息，请参阅[《在内存中使用近距离调用》](ch08.xhtml#ch00lev1sec153)第[153页](ch08.xhtml#page_153)。）在[图
    8-1](ch08.xhtml#ch8fig1)中，无条件跳转`JMP trampoline`替换了以下四个操作：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this case, you need to replace multiple sequential operations to accommodate
    the 5-byte size of the unconditional jump. You may come across cases where the
    size of the operation (or operations) being replaced is larger than 5 bytes. When
    this happens, replace the remaining bytes with NOP instructions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要替换多个连续操作，以适应无条件跳转的5字节大小。你可能会遇到需要替换的操作（或操作）的大小大于5字节的情况。当这种情况发生时，用NOP指令替换剩余的字节。
- en: Now, let’s look at how to replace those operations. [Listing 8-11](ch08.xhtml#ch8exe11)
    shows the code to place a jump hook.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下如何替换这些操作。[清单 8-11](ch08.xhtml#ch8exe11)展示了如何放置跳转钩子的代码。
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 8-11: How to place a jump hook*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-11：如何设置跳转钩子*'
- en: This function takes the address to hook at, the address of the callback function,
    and the size of the memory to overwrite (in bytes) as arguments. First, it calculates
    the offset between the hook site and the trampoline and stores the result in `newOffset`
    ➊. Next, `PAGE_EXECUTE_READWRITE` permissions are applied to the memory to be
    changed. The unconditional jump (0xE9) ➋ and the address of the callback function
    ➌ are then written to memory, and a `for` loop writes NOP instructions (0x90)
    to any abandoned bytes. After the old protections are reapplied, `hookWithJump()`
    returns to the original address.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受钩子的地址、回调函数的地址和要覆盖的内存大小（以字节为单位）作为参数。首先，它计算钩子位置和跳板之间的偏移量，并将结果存储在 `newOffset`
    ➊ 中。接下来，将 `PAGE_EXECUTE_READWRITE` 权限应用于需要修改的内存。然后将无条件跳转指令（0xE9） ➋ 和回调函数的地址 ➌
    写入内存，并且使用 `for` 循环将 NOP 指令（0x90）写入任何被弃用的字节。旧的保护被重新应用后，`hookWithJump()` 返回到原始地址。
- en: Notice that the `hookWithJump()` function ensures that `size` is not above 12
    before placing the jump. This check is important because a jump takes up 5 bytes,
    meaning it can replace up to five commands if the first four are each a single
    byte. If the first four commands are each a single byte, the fifth command would
    need to be more than 8 bytes to trigger the `if (size > 12)` clause. Because 9-byte
    operations are very, very rare, 12 is a safe but flexible limit. Having this limit
    can stop all sorts of bugs from happening, especially if your bot is dynamically
    detecting the `size` parameter. If the bot messes up and passes a `size` of `500,000,000`,
    for instance, the check will stop you from NOPing the whole universe.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`hookWithJump()` 函数确保在放置跳转之前，`size` 不会超过 12。这个检查很重要，因为跳转占用 5 字节，这意味着如果前四个命令都是单字节，它最多可以替换五个命令。如果前四个命令是单字节的，第五个命令需要超过
    8 字节才会触发 `if (size > 12)` 子句。由于 9 字节的操作非常罕见，因此 12 是一个安全但灵活的限制。设置这个限制可以避免各种 bug，尤其是当你的机器人动态检测
    `size` 参数时。如果机器人出错并传递了 `size` 为 `500,000,000`，例如，这个检查将阻止你把整个宇宙做 NOP 操作。
- en: '**Writing the Trampoline Function**'
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**编写跳板函数**'
- en: 'Using the function in [Listing 8-11](ch08.xhtml#ch8exe11), you can replicate
    the hook shown in [Figure 8-1](ch08.xhtml#ch8fig1), but first you’ll have to create
    the trampoline function as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[清单 8-11](ch08.xhtml#ch8exe11)中的函数，你可以复制[图8-1](ch08.xhtml#ch8fig1)中显示的钩子，但首先你需要按以下方式创建跳板函数：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Just like the trampoline described alongside [Figure 8-1](ch08.xhtml#ch8fig1),
    this trampoline stores all current flag ➊ and register values ➋, calls a callback
    function ➌, restores the registers ➍, restores the flags ➎, executes the code
    that was replaced by the hook at ➏ and ➐, and finally jumps back to the original
    code just below the jump and NOPs ➑.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[图8-1](ch08.xhtml#ch8fig1)中描述的跳板一样，这个跳板会存储当前所有标志 ➊ 和寄存器值 ➋，调用回调函数 ➌，恢复寄存器
    ➍，恢复标志 ➎，执行被钩子替换的代码 ➏ 和 ➐，最后跳回到原始代码的跳转位置下方并执行 NOP 操作 ➑。
- en: '**NOTE**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To ensure that the compiler doesn’t autogenerate any extra code within the
    trampoline, always declare the trampoline using the* `__declspec(naked)` *convention.*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了确保编译器不会在跳板中自动生成任何额外的代码，请始终使用* `__declspec(naked)` *约定声明跳板。*'
- en: '**Finishing the Jump Hook**'
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**完成跳转钩子**'
- en: 'Once you create the trampoline, define the callback and set the hook like so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了跳板，定义回调函数并按如下方式设置钩子：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, inside the `jumpHookCallback()` function, execute the code that relies
    on the hook. If your code needs to read or write the values of the registers as
    they were when the hook executed, you’re in luck. The `PUSHAD` command pushes
    them to the stack in the order EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and
    EDI. The trampoline calls `PUSHAD` directly before the `jumpHookCallback()` call,
    so you can reference the register values as arguments, like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `jumpHookCallback()` 函数内部，执行依赖于钩子的代码。如果你的代码需要读取或写入在钩子执行时的寄存器值，那么你很幸运。`PUSHAD`
    命令会按照 EAX、ECX、EDX、EBX、原始 ESP、EBP、ESI 和 EDI 的顺序将寄存器值压入栈中。跳板会在调用 `jumpHookCallback()`
    之前直接调用 `PUSHAD`，因此你可以将寄存器值作为参数引用，像这样：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Since the trampoline uses `POPAD` to directly restore the registers from these
    values on the stack, any modifications you make to the parameters will be applied
    to the actual registers when they are restored from the stack.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于跳板使用 `POPAD` 从栈中直接恢复寄存器的值，因此你对参数所做的任何修改将在寄存器从栈中恢复时应用到实际寄存器。
- en: Like VF table hooks, jump hooks are rarely needed, and they can be tricky to
    simulate with a simple example. To help you wrap your head around them, I’ll explore
    a real-world, practical use case in “[Applying Jump Hooks and VF Hooks to Direct3D](ch08.xhtml#ch00lev1sec174)”
    on [page 175](ch08.xhtml#page_175).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 像 VF 表钩子一样，跳转钩子很少需要使用，而且用一个简单的例子来模拟它们可能会比较棘手。为了帮助你理解它们，我将在[《将跳转钩子和 VF 钩子应用于
    Direct3D》](ch08.xhtml#ch00lev1sec174)一文中，展示一个现实世界中的实际应用案例，内容位于[第 175 页](ch08.xhtml#page_175)。
- en: '**PROFESSIONAL API HOOKING LIBRARIES**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**专业 API 钩子库**'
- en: There are prewritten hooking libraries, like Microsoft’s Detours and MadCHook,
    that use only jump hooks. These libraries can automatically detect and follow
    other hooks, they know how many instructions to replace, and they generate trampoline
    functions for you. The libraries are able to do this because they understand how
    to disassemble and walk through assembly instructions to determine lengths, jump
    destinations, and so on. If you need to use hooks with that much power, it is
    arguably better to use one of those libraries than to create your own.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些预写的钩子库，比如微软的 Detours 和 MadCHook，仅使用跳转钩子。这些库可以自动检测并跟踪其他钩子，知道需要替换多少条指令，并且为你生成跳板函数。这些库之所以能够做到这一点，是因为它们理解如何反汇编并分析汇编指令，以确定指令长度、跳转目标等。如果你需要使用如此强大的钩子功能，使用这些库可能比自己编写更为合适。
- en: '**Applying Call Hooks to Adobe AIR**'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将调用钩子应用于 Adobe AIR**'
- en: Adobe AIR is a development framework that can be used to make cross-platform
    games in an environment similar to Abode Flash. AIR is a common framework for
    online games, as it allows developers to write cross-platform code in a versatile,
    high-level language called ActionScript. ActionScript is an interpreted language,
    and AIR runs the code inside a virtual machine, which makes it infeasible to hook
    game-specific code with AIR. Instead, it is easier to hook AIR itself.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Adobe AIR 是一个开发框架，可以用来在类似 Adobe Flash 的环境中制作跨平台游戏。AIR 是在线游戏中常用的框架，因为它允许开发者使用一种叫做
    ActionScript 的多功能高级语言编写跨平台代码。ActionScript 是一种解释型语言，AIR 在虚拟机中运行这些代码，这使得直接钩住游戏特定的代码变得不可行。相反，钩住
    AIR 本身会更容易。
- en: The example code for this section can be found in *GameHackingExamples/Chapter8_AdobeAirHook*
    in this book’s source files. The code comes from an old project of mine, and it
    works on any game running *Adobe AIR.dll* version 3.7.0.1530\. I’ve gotten it
    working on other versions as well, but I can’t guarantee it will work with much
    newer or much older versions, so treat this as a case study.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在本书的源文件中找到，路径为 *GameHackingExamples/Chapter8_AdobeAirHook*。这些代码来自我以前的一个项目，适用于运行
    *Adobe AIR.dll* 版本 3.7.0.1530 的任何游戏。我也让它在其他版本上运行过，但不能保证它能在更新或更旧的版本上正常工作，因此请将此作为案例研究来参考。
- en: '***Accessing the RTMP Goldmine***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***访问 RTMP 金矿***'
- en: The *Real Time Messaging Protocol (RTMP)* is a text-based network protocol that
    ActionScript uses to serialize and send entire objects over the network. RTMP
    sits on top of the *HyperText Transfer Protocol (HTTP)*, and a secure version,
    RTMPS, sits on top of *HTTP Secure (HTTPS)*. RTMPS allows game developers to easily
    send and receive entire object instances over a secure connection with little
    complication, making it the network protocol of choice for any games running on
    AIR.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时消息传输协议（RTMP）* 是一种基于文本的网络协议，ActionScript 用它来序列化并通过网络发送整个对象。RTMP 运行在 *超文本传输协议（HTTP）*
    之上，而安全版本的 RTMPS 则运行在 *安全的 HTTP（HTTPS）* 之上。RTMPS 使游戏开发者能够通过安全连接轻松发送和接收整个对象实例，几乎没有复杂的操作，因此成为了在
    AIR 上运行的游戏的首选网络协议。'
- en: '**NOTE**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Data sent over RTMP/RTMPS is serialized through* Action Message Format (AMF)*,
    and parsing AMF packets is beyond the scope of this book. Search online for “AMF3
    Parser,” and you’ll find a lot of code that does it.*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过 RTMP/RTMPS 发送的数据是通过* Action Message Format (AMF)* 序列化的，解析 AMF 数据包超出了本书的范围。你可以在网上搜索
    “AMF3 Parser”，你会找到很多可以解析 AMF 数据包的代码。*'
- en: Data sent over RTMP and RTMPS is very rich. The packets contain information
    about object types, names, and values. This is a gold mine. If you can intercept
    this data in real time, you can instantaneously respond to changes in game state,
    see a wealth of critical information without ever reading it from memory, and
    find useful pieces of data that you might not even know exist.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 RTMP 和 RTMPS 发送的数据非常丰富。这些数据包包含了关于对象类型、名称和数值的信息。这是一座金矿。如果你能够实时拦截这些数据，你就能即时响应游戏状态的变化，无需从内存中读取信息就能看到大量关键数据，甚至能发现一些你可能从未意识到存在的数据。
- en: A while back, I was working on a tool that required a ton of insight into the
    state of a game. Obtaining such a large amount of data directly from memory would
    have been extremely hard, if not impossible. After some research, I realized that
    the game was using RTMPS to communicate with the server, and that prompted me
    to start digging into this gold mine.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间前，我正在开发一个需要大量洞察游戏状态的工具。从内存中直接获取如此大量的数据将是极其困难的，甚至是不可能的。经过一些研究，我意识到游戏使用RTMPS与服务器进行通信，这促使我开始挖掘这个金矿。
- en: Since RTMPS is encrypted, I knew I had to somehow hook the cryptographic functions
    used by AIR before I could get any usable data. After searching online, I found
    source code for a small tool called airlog, created by another game hacker who,
    like me, was trying to log packets sent over RTMPS. Although the tool hooked the
    exact functions I needed, the code was outdated, messy, and, worst of all, didn’t
    work on the version of AIR I was trying to hook.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RTMPS是加密的，我知道我必须在获取任何可用数据之前以某种方式钩取AIR使用的加密函数。经过在线搜索，我找到了一个名为airlog的小工具的源代码，它是由另一位游戏黑客创建的，和我一样，他也在尝试记录通过RTMPS发送的数据包。虽然这个工具钩取了我所需的确切函数，但代码已经过时、杂乱无章，最糟糕的是，它在我尝试钩取的AIR版本上不起作用。
- en: But that didn’t mean it was useless. Not only did airlog hook the two functions
    I needed, but it also located them by scanning for certain byte patterns within
    the Adobe AIR library. These byte patterns were three years old, though, so they
    weren’t working anymore. The newer versions of Adobe AIR had changed enough that
    the assembly bytes were no longer the same. The difference in bytes was a problem
    for the code in airlog, but not for me.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不意味着它没有用。airlog不仅钩取了我需要的两个函数，而且它还通过扫描Adobe AIR库中的某些字节模式来定位它们。然而，这些字节模式已经三年没更新了，所以它们不再有效。Adobe
    AIR的新版本发生了足够的变化，以至于汇编字节不再相同。字节的差异对airlog中的代码来说是个问题，但对我来说却不是。
- en: 'Inside an inline assembly block, you can specify raw bytes with the following
    function call:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在内联汇编块中，你可以使用以下函数调用来指定原始字节：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you replace `BYTE` with, say, `0x03`, the code will be compiled in a way
    that treats `0x03` as a byte in the assembly code, regardless of whether that
    makes sense. Using this trick, I compiled the byte arrays back to assembly code.
    The code didn’t do anything, and it wasn’t meant to; using this trick simply allowed
    me to attach to my dummy application with OllyDBG and inspect bytes, which were
    conveniently presented as a clean disassembly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`BYTE`替换为例如`0x03`，代码将以一种将`0x03`视为汇编代码中的字节的方式编译，无论这是否有意义。利用这个技巧，我将字节数组重新编译成了汇编代码。代码没有执行任何操作，也不是为了执行；使用这个技巧只是让我能够通过OllyDBG连接到我的虚拟应用程序，并检查字节，这些字节被方便地呈现为清晰的反汇编。
- en: Since these bytes represented the code surrounding the functions I needed, so,
    too, did their disassembly. The code was pretty standard and didn’t seem likely
    to change, so I turned my attention to the constants. The code had a few immediate
    values passed as offsets in commands. Knowing how commonly these can change, I
    rewired airlog’s pattern-matching algorithm to support wildcards, updated the
    patterns to treat any constants as wildcards, and then ran the match. After some
    tweaks to the patterns and a bit of digging through duplicate search results,
    I tracked down the functions I wanted to hook. I appropriately named them `encode()`
    and `decode()` and began working on a tool similar to airlog—but better.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些字节表示了我所需函数周围的代码，它们的反汇编也是如此。代码相当标准，看起来不太可能发生变化，所以我将注意力转向了常量。代码中有一些立即值作为命令中的偏移量传递。考虑到这些常量变化的频率，我重新编写了airlog的模式匹配算法以支持通配符，更新了模式以将任何常量视为通配符，然后运行匹配。经过一些对模式的调整和对重复搜索结果的挖掘，我找到了我想钩取的函数。我将它们适当地命名为`encode()`和`decode()`，并开始开发一个类似于airlog的工具——但更加完善。
- en: '***Hooking the RTMPS encode() Function***'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***钩取RTMPS encode()函数***'
- en: I discovered that the `encode()` function, which is used to encrypt the data
    for outgoing packets, is a nonvirtual `__thiscall`, meaning it’s called by a near
    call. Moreover, the call happens inside a loop. The entire loop looks like [Listing
    8-12](ch08.xhtml#ch8exe12), taken directly from the OllyDBG disassembly pane.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现`encode()`函数用于加密传出数据包的数据显示，它是一个非虚拟的`__thiscall`，意味着它是通过近距离调用的。此外，调用发生在一个循环中。整个循环的代码如下所示：[Listing
    8-12](ch08.xhtml#ch8exe12)，直接取自OllyDBG的反汇编窗格。
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 8-12: The `encode()` loop*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 8-12: `encode()`循环*'
- en: With a bit of analysis and some guidance from airlog, I determined that the
    `encode()` function called at ➊ takes a byte array and buffer length (let’s call
    them `buffer` and `size`, respectively) as parameters. The function returns `-1`
    when it fails and returns `size` otherwise. The function operates on chunks of
    4,096 bytes, which is why this happens in a loop.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些分析和来自airlog的指导，我确定了在➊调用的`encode()`函数接受一个字节数组和缓冲区长度（分别称为`buffer`和`size`）作为参数。当函数失败时返回`-1`，否则返回`size`。该函数以4,096字节为单位操作，这就是为什么它会在一个循环中执行的原因。
- en: 'Turned into more readable pseudocode, the loop calling `encode()` looks like
    this (the numbers refer to the relevant assembly instructions in [Listing 8-12](ch08.xhtml#ch8exe12)):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为更易读的伪代码后，调用`encode()`的循环看起来像这样（数字表示在[Listing 8-12](ch08.xhtml#ch8exe12)中相关汇编指令的位置）：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I wasn’t interested in what `encode()` did, but I needed the entire buffer it
    was looping over, and hooking `encode()` was my means of getting that buffer.
    Looking at the real loop in [Listing 8-12](ch08.xhtml#ch8exe12), I knew that the
    calling object instance’s full buffer was stored at ESI+0x1C58, that the full
    size was stored at ESI+0x3C58, and that EDI contained the loop counter. I devised
    the hook with these things in mind, ultimately creating a two-part hook.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不关心`encode()`做了什么，但我需要它循环处理的整个缓冲区，而钩住`encode()`是我获取这个缓冲区的手段。通过查看[Listing 8-12](ch08.xhtml#ch8exe12)中的实际循环，我知道调用对象实例的完整缓冲区存储在ESI+0x1C58处，完整的大小存储在ESI+0x3C58处，且EDI寄存器包含循环计数器。我在这些信息的基础上设计了钩子，最终创建了一个由两部分组成的钩子。
- en: 'The first part of my hook was a `reportEncode()` function that logs the entire
    buffer on the first loop iteration. Here’s the `reportEncode()` function in full:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我的钩子的第一部分是一个`reportEncode()`函数，它在第一次循环迭代时记录整个缓冲区。下面是完整的`reportEncode()`函数：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This function takes `buffer`, `size`, and `loopCounter` as parameters and returns
    the address of the function I dubbed `encode()`. Before fetching that address,
    however, the second part of my hook, a `myEncode()` function, does all of the
    dirty work to obtain `buffer`, `size`, and `loopCounter`, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受`buffer`、`size`和`loopCounter`作为参数，并返回我称之为`encode()`的函数的地址。然而，在获取该地址之前，我的钩子的第二部分，`myEncode()`函数，会完成所有的脏活，获取`buffer`、`size`和`loopCounter`，具体如下：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `myEncode()` function is a pure assembly function that replaces the original
    `encode()` function call using a near call hook. After storing ECX on the stack,
    `myEncode()` obtains `buffer`, `size`, and `loopCounter` and passes them to the
    `reportEncode()` function. After calling the `reportEncode()` function, the `myEncode()`
    function restores ECX and jumps directly into `encode()`, causing the original
    function to execute and return gracefully to the loop.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`myEncode()`函数是一个纯汇编函数，它通过一个近距离调用钩子替代了原始的`encode()`函数调用。在将ECX寄存器保存到堆栈后，`myEncode()`获取`buffer`、`size`和`loopCounter`，并将它们传递给`reportEncode()`函数。调用完`reportEncode()`函数后，`myEncode()`恢复ECX寄存器并直接跳转到`encode()`，使得原始函数得以执行，并优雅地返回到循环中。'
- en: 'Since `myEncode()` cleans everything it uses from the stack, the stack still
    contains the original parameters and return address in the correct spot after
    `myEncode()` runs. That’s why `myEncode()` jumps directly into `encode()` instead
    of using a function call: that stack is already set up with the proper return
    address and parameters, so the `encode()` function will think everything happened
    as normal.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`myEncode()`在执行时会清除它使用的所有堆栈数据，因此在`myEncode()`运行后，堆栈仍然保持原始参数和返回地址在正确的位置。这就是为什么`myEncode()`直接跳转到`encode()`而不是使用函数调用的原因：堆栈已经设置好了正确的返回地址和参数，因此`encode()`函数会认为一切都像正常一样发生。
- en: '***Hooking the RTMPS decode() Function***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***钩住RTMPS的decode()函数***'
- en: 'The function I named `decode()`, which is used to decrypt incoming data, was
    also a `__thiscall` that was called in a loop. It worked on chunks of 4,096 bytes
    and took a buffer and size as parameters. The loop was quite a bit more complex,
    containing multiple function calls, nested loops, and loop escapes, but hooking
    worked much the same as hooking the so-called `encode()` function. The reason
    for the added complexity is not relevant to hooking the function, but it makes
    the code difficult to summarize, so I won’t show the original function here. The
    bottom line is this: once all the complexity was rubbed away, the `decode()` loop
    was the `encode()` loop in reverse.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我命名为`decode()`的函数用于解密传入的数据，它也是一个`__thiscall`，并且在一个循环中被调用。它处理4,096字节的块，并以缓冲区和大小作为参数。这个循环要复杂得多，包含多个函数调用、嵌套循环和循环退出，但钩子工作原理与钩住所谓的`encode()`函数类似。增加的复杂性与钩住函数无关，但使得代码难以概括，因此我不会在此展示原始函数。最重要的是，一旦所有复杂性被去除，`decode()`的循环实际上就是`encode()`循环的逆过程。
- en: 'Once again, I devised a two-part near call hook. The first part, `reportDecode()`,
    is shown here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 再次地，我设计了一个由两部分组成的近距离调用钩子。第一部分，`reportDecode()`，如下所示：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The function logs each packet that comes through. I didn’t have a loop index
    at the time, so I decided that it was okay to log every single partial packet.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数记录每个通过的数据包。当时我没有循环索引，所以我决定记录每一个部分数据包。
- en: 'The second part of the hook, the `myDecode()` function, acts as the new callee
    and does all of the dirty work, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子的第二部分，`myDecode()`函数，充当新的调用者并执行所有脏活，具体如下：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: I knew the buffer was decrypted in place, meaning the encrypted chunk would
    be overwritten with the decrypted one once the call to `decode()` was complete.
    This meant that `myDecode()` had to call the original `decode()` function ➊ before
    calling the `reportDecode()` function, which would give the results of the decoding.
    Ultimately, `myDecode()` also needed to return with the same value that the original
    `decode()` function would and clean up the stack, and the final `POP` ➋ and `RETN`
    ➌ instructions took care of that.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道缓冲区是原地解密的，这意味着加密的块会在调用`decode()`完成后被解密的块覆盖。这意味着`myDecode()`必须在调用`reportDecode()`函数之前，先调用原始的`decode()`函数
    ➊，然后才会返回解码结果。最终，`myDecode()`还需要返回与原始`decode()`函数相同的值，并清理堆栈，最后的`POP` ➋和`RETN` ➌指令处理了这一部分。
- en: '***Placing the Hooks***'
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***放置钩子***'
- en: The next problem I ran into was that the hooks were for code inside the module
    *Adobe AIR.dll*, which was not the main module of the game. Because of the code’s
    location, I needed to find the base addresses for the hooks a bit differently.
    Additionally, since I needed these hooks to work across a few different versions
    of Adobe AIR, I also had to find the right addresses for each version. Instead
    of trying to get my hands on all of the different versions of Adobe AIR, I took
    another page out of airlog’s playbook and decided to programmatically locate the
    addresses by writing a small memory scanner. Before I could write the memory scanner,
    I needed both the base address and size of *Adobe AIR.dll* so I could limit my
    memory search to only that area.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到的下一个问题是，钩子是针对模块*Adobe AIR.dll*中的代码，而该模块并不是游戏的主模块。由于代码的位置，我需要以不同的方式找到钩子的基地址。此外，鉴于我需要这些钩子在多个不同版本的Adobe
    AIR中工作，我还必须找到每个版本的正确地址。我决定不去收集所有版本的Adobe AIR，而是从airlog的策略中借鉴，决定通过编写一个小型内存扫描器来程序化地定位地址。在编写内存扫描器之前，我需要获取*Adobe
    AIR.dll*的基地址和大小，以便将内存搜索限制在该区域。
- en: 'I found these values using `Module32First()` and `Module32Next()` as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`Module32First()`和`Module32Next()`找到了这些值，具体方法如下：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code loops through all modules in the process until it finds *Adobe AIR.dll*
    ➊. When it finds the correct module entry ➋, it fetches the `modBaseSize` and
    `modBaseAddr` properties from it and breaks out immediately.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会循环遍历进程中的所有模块，直到找到*Adobe AIR.dll* ➊。当它找到正确的模块条目 ➋ 时，它从中提取`modBaseSize`和`modBaseAddr`属性，然后立即跳出循环。
- en: The next step was finding a sequence of bytes I could use to identify the functions.
    I decided to use the byte code surrounding each call. I also had to make sure
    that each sequence was unique while avoiding the use of any constants in the patterns
    to ensure the code’s portability. [Listing 8-13](ch08.xhtml#ch8exe13) shows the
    byte sequences I ended up with.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是找到一个字节序列，我可以用它来识别这些函数。我决定使用每个调用周围的字节码。我还必须确保每个序列是唯一的，同时避免在模式中使用任何常量，以确保代码的可移植性。[列表
    8-13](ch08.xhtml#ch8exe13) 显示了我最终得到的字节序列。
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 8-13: The `encode()` and `decode()` byte sequences*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-13：`encode()` 和 `decode()` 字节序列*'
- en: 'Notice the `CALL` instruction in each pattern; these are the calls to the Adobe
    AIR functions I named `encode()` and `decode()`. I scanned for these sequences
    with the following function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个模式中的 `CALL` 指令；这些是我命名为 `encode()` 和 `decode()` 的 Adobe AIR 函数的调用。我使用以下函数扫描这些序列：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Treating the memory of *Adobe AIR.dll* as a byte array, the `findSequence()`
    function looks for a sequence of bytes as a subset of that byte array and returns
    the address of the first match it finds. With the `findSequence()` function written,
    finding the addresses I needed to hook `encode()` and `decode()` was simple. Here’s
    how those calls looked:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *Adobe AIR.dll* 的内存视为字节数组后，`findSequence()` 函数会查找该字节数组中的某个字节序列作为子集，并返回它找到的第一个匹配项的地址。编写完
    `findSequence()` 函数后，找到我需要钩住的 `encode()` 和 `decode()` 的地址变得简单了。这些调用是这样的：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since each target call was 2 bytes into its receptive search sequence, all I
    had to do was locate each sequence and add 2\. After that, the final step was
    to place the hooks using the method described in “[Call Hooking](ch08.xhtml#ch00lev1sec152)”
    on [page 153](ch08.xhtml#page_153).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个目标调用在其接受的搜索序列中相差 2 个字节，我所需要做的就是定位每个序列并加上 2。然后，最后一步是使用 “[调用钩子](ch08.xhtml#ch00lev1sec152)”
    方法在 [第 153 页](ch08.xhtml#page_153) 上放置钩子。
- en: With my hook finished, I could see every single piece of data that went between
    the game’s client and server. Moreover, since the RTMPS protocol sends serialized
    ActionScript objects, the data was basically self-documenting. Every single piece
    of information was accompanied by a variable name. Every variable existed as a
    member of a well-described object. Every object had a consistent name. Like I
    said—it was a gold mine.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成我的钩子后，我能够看到游戏客户端和服务器之间传输的每一块数据。而且，由于 RTMPS 协议发送序列化的 ActionScript 对象，数据本身就像文档一样自说明。每一块信息都有一个变量名。每个变量都是一个描述清晰的对象的成员。每个对象都有一个一致的名称。正如我所说——这简直是个宝藏。
- en: '**Applying Jump Hooks and VF Hooks to Direct3D**'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将跳转钩子和 VF 钩子应用于 Direct3D**'
- en: 'Unlike the Adobe AIR hook I just described, hooks for Direct3D (the 3D graphics
    component of Microsoft’s DirectX API) are very common and highly documented. Direct3D
    is ubiquitous in the world of gaming: a majority of PC games use the library,
    which means that hooking it gives you a very powerful method for intercepting
    data and manipulating the graphics layers of many different games. You can use
    a Direct3D hook for a number of tasks, such as detecting locations of hidden enemy
    players, increasing the lighting of dark in-game environments, and seamlessly
    displaying additional graphical information. Making effective use of a Direct3D
    hook requires you to learn about the API, but there’s more than enough information
    in this book to get you started.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与我刚刚描述的 Adobe AIR 钩子不同，Direct3D 钩子（微软 DirectX API 的 3D 图形组件）非常常见，并且有着高度的文档支持。Direct3D
    在游戏界中无处不在：大多数 PC 游戏都使用这个库，这意味着钩住它为你提供了一种非常强大的方法，用来截取数据并操控多个游戏的图形层。你可以使用 Direct3D
    钩子完成许多任务，比如检测隐藏敌人玩家的位置、增强游戏中昏暗环境的光照，或无缝地显示额外的图形信息。有效利用 Direct3D 钩子需要你了解 API，但这本书中有足够的信息帮助你入门。
- en: In this section, I’ll give you a high-level introduction to a game loop that
    uses Direct3D before diving right into the implementation of a Direct3D hook.
    Rather than detailing the internals and giving you the analytical backstory as
    I did with the Adobe AIR hook, I’ll go over the most popular Direct3D hook method,
    as it is well documented and used by the majority of game hackers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将为你简要介绍使用 Direct3D 的游戏循环，然后再深入实现 Direct3D 钩子的方法。与我在 Adobe AIR 钩子中所做的详细内部解析和分析背景不同，我将介绍最流行的
    Direct3D 钩子方法，因为它有大量文档支持，且被大多数游戏黑客使用。
- en: The online resources for this book include two pieces of example code for this
    section; find those files now if you want to follow along. The first part, an
    example Direct3D 9 application for you to hack on, can be found under *GameHackingExamples/Chapter8_Direct3DApplication*.
    The second part, the actual hook, is under *Chapter8_Direct3DHook*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的在线资源包括两个示例代码文件；如果你想跟着一起做，可以现在就找到这些文件。第一部分是一个 Direct3D 9 应用程序示例，供你进行修改，位于
    *GameHackingExamples/Chapter8_Direct3DApplication*。第二部分是实际的挂钩代码，位于 *Chapter8_Direct3DHook*。
- en: There are multiple versions of Direct3D in use at any given time, and there
    are ways to hook each one. For this book, I’ll focus on hooking Direct3D 9, because
    it is the only commonly used version that is supported by Windows XP.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 任何给定时间，都会使用多个版本的 Direct3D，并且有方法可以挂钩每一个版本。在本书中，我将重点讲解如何挂钩 Direct3D 9，因为它是唯一在
    Windows XP 上得到支持的常用版本。
- en: '**NOTE**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Even though XP has reached end of life, many people in less developed countries
    still use it as a primary gaming system. Direct3D 9 works on all versions of Windows
    and is nearly as powerful as its successors, so many game companies still prefer
    to use it over newer versions that don’t have as much backward compatibility.*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管 XP 已经结束生命周期，但许多发展中国家的人们仍然将其作为主要的游戏平台。Direct3D 9 支持所有版本的 Windows，并且几乎与其后继版本一样强大，因此许多游戏公司仍然更倾向于使用它，而不是那些不具备强大向后兼容性的更新版本。*'
- en: '***The Drawing Loop***'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制循环***'
- en: 'Let’s jump right in with a crash course on how Direct3D works. Inside a Direct3D
    game’s source code, you’ll find an infinite loop that processes input and renders
    graphics. Each iteration in this drawing loop is called a *frame*. If we cut out
    all the extraneous code and focus simply on a bare skeleton, we can visualize
    a game’s main loop with the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入 Direct3D 工作原理的速成课程。在 Direct3D 游戏的源代码中，你会发现一个无限循环，处理输入并渲染图形。这个绘制循环中的每次迭代称为一个
    *帧*。如果我们去掉所有多余的代码，仅关注基本骨架的话，我们可以通过以下代码来可视化一个游戏的主循环：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This function is the entry point of the game. Simply put, it initializes the
    game and then enters the game’s main loop. Inside the main loop, it executes code
    responsible for processing user input before calling `drawFrame()` to redraw the
    screen using Direct3D. (Check out the code in *GameHackingExamples/Chapter8_Direct3DApplication*
    to see a fully functional game loop.)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是游戏的入口点。简而言之，它初始化游戏，然后进入游戏的主循环。在主循环中，它执行处理用户输入的代码，然后调用 `drawFrame()` 使用
    Direct3D 重新绘制屏幕。（查看 *GameHackingExamples/Chapter8_Direct3DApplication* 中的代码，看看一个完整功能的游戏循环。）
- en: 'Each time it is called, the `drawFrame()` function redraws the entire screen.
    The code looks something like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用时，`drawFrame()` 函数会重新绘制整个屏幕。代码大致如下所示：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: After clearing the screen with `device->Clear` ➊, the `drawFrame()` function
    calls `device->BeginScene()` to unlock the scene for drawing. It then executes
    some drawing code (what that drawing code actually does isn’t important right
    now) and locks the scene with a `device->EndScene()` call. To finish up, it renders
    the scene to the screen by calling the `device->Present()` function.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `device->Clear` ➊ 清除屏幕之后，`drawFrame()` 函数调用 `device->BeginScene()` 解锁场景以便绘制。然后它执行一些绘制代码（这些绘制代码具体做什么现在不重要），并通过
    `device->EndScene()` 调用锁定场景。最后，它通过调用 `device->Present()` 函数将场景渲染到屏幕上。
- en: 'Notice that all of these functions are called as members of some instance called
    `device`. This is simply an object instance representing the Direct3D device,
    which is used to invoke all sorts of drawing calls. Also, notice that this function
    is devoid of any actual drawing code, but that’s okay. It’s really only important
    for you to understand the high-level concepts of drawing loops, frames, and the
    Direct3D device. To recap, games have a main loop with two responsibilities:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些函数都是作为名为 `device` 的实例的成员进行调用的。这个实例只是一个表示 Direct3D 设备的对象实例，用于调用各种绘制操作。此外，注意到这个函数并没有实际的绘制代码，但这没关系。现在重要的是你要理解绘制循环、帧和
    Direct3D 设备的高级概念。总结一下，游戏有一个主循环，负责两个任务：
- en: • Handling incoming messages
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: • 处理传入的消息
- en: • Drawing the game to the screen
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: • 将游戏绘制到屏幕上
- en: Each iteration in this loop is called a frame, and each frame is drawn by a
    device. Taking control of the device gives you access to the most sensitive and
    descriptive details of the game’s state; that is, you’ll be able to peek into
    the game’s state after the data has been parsed, processed, and rendered to the
    screen. Moreover, you’ll be able to modify the output of this state. These two
    superpowers enable you to pull off all kinds of awesome hacks.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 该循环中的每一次迭代称为一帧，每一帧由一个设备绘制。控制设备让你可以访问游戏状态的最敏感和最详细的细节；也就是说，你可以在数据解析、处理并渲染到屏幕后查看游戏状态。此外，你还可以修改这种状态的输出。这两种超级能力使你能够完成各种令人惊叹的黑客操作。
- en: '***Finding the Direct3D Device***'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找 Direct3D 设备***'
- en: To take control of a Direct3D device, you hook the member functions in the device’s
    VF table. Unfortunately, however, using the Direct3D API to instantiate your own
    instance of the same `device` class from injected code doesn’t mean you’ll share
    a VF table with the game’s instance. Direct3D devices use a customized runtime
    implementation of VF tables, and each device gets its own unique VF table. Additionally,
    devices sometimes rewrite their own VF tables, removing any hooks and restoring
    the original function addresses.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制一个 Direct3D 设备，你需要钩住设备 VF 表中的成员函数。不幸的是，使用 Direct3D API 从注入代码实例化相同的 `device`
    类并不意味着你会和游戏实例共享同一个 VF 表。Direct3D 设备使用定制的运行时 VF 表实现，每个设备都有自己独特的 VF 表。此外，设备有时会重写自己的
    VF 表，移除任何钩子并恢复原始函数地址。
- en: 'Both of these Direct3D quirks leave you with one inevitable option: you must
    find the address of the game’s device and modify its VF table directly. Here’s
    how:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 Direct3D 特性让你面临一个不可避免的选择：你必须找到游戏设备的地址，并直接修改它的 VF 表。方法如下：
- en: Create a Direct3D device and traverse its VF table to locate the true address
    of `EndScene()`.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Direct3D 设备并遍历其 VF 表以找到 `EndScene()` 的真实地址。
- en: Place a temporary jump hook on `EndScene()`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `EndScene()` 上放置一个临时跳转钩子。
- en: When the jump hook callback is executed, store the address of the device that
    was used to call the function, remove the hook, and restore execution normally.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当跳转钩子回调被执行时，存储调用该函数的设备地址，移除钩子，并恢复正常执行。
- en: From there, use VF hooks to hook any member function of the Direct3D device.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，使用 VF 钩子来钩住 Direct3D 设备的任何成员函数。
- en: '**Jump Hooking EndScene()**'
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**跳转钩住 EndScene()**'
- en: 'Since every device will call `EndScene()` at the end of each frame, you can
    hook `EndScene()` using a jump hook and intercept the game’s device from your
    hook callback. Unique devices may have their own unique VF tables, but the different
    tables still point to the same functions, so you can find the address of `EndScene()`
    in the VF table of any arbitrary device. Using standard Direct3D API calls, you
    can create your own device like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个设备会在每一帧结束时调用 `EndScene()`，你可以使用跳转钩子钩住 `EndScene()`，并在钩子回调中截取游戏的设备。独特的设备可能有自己独特的
    VF 表，但不同的表仍然指向相同的函数，因此你可以在任何设备的 VF 表中找到 `EndScene()` 的地址。使用标准的 Direct3D API 调用，你可以像这样创建自己的设备：
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Explaining how everything in Direct3D works is outside the scope of this book,
    so just know that you can copy this code to create a Direct3D device that contains
    the `EndScene()` function as a member. The `EndScene()` address is at index `42`
    in the VF table of `device` (see “The Meaning of Device, Direct3D, and VF Hooks”
    box to learn how to find that index), and you can read it using a subset of the
    VF table hooking code from “[Using a VF Table Hook](ch08.xhtml#ch00lev1sec159)”
    on [page 159](ch08.xhtml#page_159), as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 解释 Direct3D 中所有的工作原理超出了本书的范围，因此只需知道，你可以复制这段代码来创建一个包含 `EndScene()` 函数作为成员的 Direct3D
    设备。`EndScene()` 地址位于 `device` 的 VF 表中的索引 `42`（详见“设备、Direct3D 和 VF 钩子的含义”框，了解如何找到该索引），你可以使用来自“[使用
    VF 表钩子](ch08.xhtml#ch00lev1sec159)”第159页的 VF 表钩子代码子集来读取它，如下所示：
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once you’ve obtained the address, your discovery device has served its purpose,
    and it can be destroyed with a call to the `Release()` function:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了地址，你的发现设备就完成了它的使命，你可以通过调用 `Release()` 函数将其销毁：
- en: '[PRE50]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: With the address of `EndScene()` in hand, you’d be ready to start thinking about
    how to place your hook in memory. But since you just have a function address,
    your only option is to place a jump hook at the top of the function.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有 `EndScene()` 的地址后，你就准备好开始思考如何将钩子放置到内存中。但由于你只拥有一个函数地址，你唯一的选择是将跳转钩子放在函数的顶部。
- en: '**THE MEANING OF DEVICE, DIRECT3D, AND VF HOOKS**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备、Direct3D 和 VF 钩子的含义**'
- en: If you’re wondering how I know that the index of the `EndScene()` function is
    `42`, you’ve come to the right box. Since Direct3D 9 is a freely available library,
    you can actually see quite a bit of what goes on under the hood. The main header
    file for the library is *d3d9.h*. If you open this file in your editor and search
    for “EndScene,” you’ll end up in the middle of a large class definition that specifies
    several functions using C macros. This is the base class for all Direct3D 9 `device`
    implementations, and it defines the virtual functions used by the class.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想我怎么知道`EndScene()`函数的索引是`42`，那么你来对地方了。由于Direct3D 9是一个自由开放的库，你实际上可以看到很多底层的内容。这个库的主头文件是*d3d9.h*。如果你在编辑器中打开这个文件并搜索“EndScene”，你会看到一个大型类定义的中间部分，其中使用C宏定义了几个函数。这是所有Direct3D
    9 `device`实现的基类，它定义了类使用的虚拟函数。
- en: 'The VF table is constructed in the same order as the functions are defined
    in code, so you can determine the index of any member function by simply counting
    the lines. You can scroll to the top of the class definition (at line 426 in my
    version of the library, and probably yours too), note the line where the first
    function is declared (line 429), and then scroll to the `EndScene()` definition
    and note that line (line 473). Finally, count the number of blank or commented
    lines (two for me) and do some math: 473 – 429 – 2 = 42.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: VF表是按函数在代码中定义的顺序构建的，因此你可以通过简单地数行数来确定任何成员函数的索引。你可以滚动到类定义的顶部（在我版本的库中是第426行，可能你也一样），记下第一个函数声明的行（第429行），然后滚动到`EndScene()`的定义并记下该行（第473行）。最后，数一下空行或注释行的数量（我这里是两行），然后做个简单的数学运算：473
    – 429 – 2 = 42。
- en: Presto! The `EndScene()` function is the 43rd function declared, so it sits
    at the 42nd spot in the VF table. Another advantage to having this header is that
    you can see the name, argument types, argument names, and return type of every
    single function in the device class. So when you’re writing your own hooks in
    the future, you’ll know exactly where to look.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 预览！`EndScene()`函数是第43个声明的函数，因此它位于VF表的第42个位置。拥有这个头文件的另一个好处是，你可以看到设备类中每个函数的名称、参数类型、参数名称和返回类型。所以，当你将来编写自己的钩子时，你将确切知道该去哪里查看。
- en: '**Placing and Removing the Jump Hook**'
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**放置和移除跳转钩子**'
- en: 'Since you’re just using the hook to find the device, you need to call it only
    once. After obtaining the device, you’ll remove the jump hook and restore execution
    back to the start of `EndScene()` so that the drawing loop can carry on its work.
    Believe it or not, this makes your life much easier. Since the code will be restored
    immediately, there’s no need for your trampoline to execute the commands that
    are replaced by the jump, and there’s no need to pad the jump with NOPs. All you
    need to do is store the original bytes and place the hook. To do so, you use a
    slightly tweaked version of the jump-hooking code from [Listing 8-11](ch08.xhtml#ch8exe11):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你只是用钩子来查找设备，因此只需要调用一次它。获取设备后，你将移除跳转钩子，并将执行恢复到`EndScene()`的起始位置，这样绘制循环就可以继续工作。信不信由你，这会让你的生活轻松很多。由于代码会立即恢复，因此不需要你的跳板执行被跳转替换的命令，也不需要用NOP填充跳转。你需要做的就是存储原始字节并放置钩子。为此，你可以使用稍微调整过的[Listing
    8-11](ch08.xhtml#ch8exe11)中的跳转钩子代码：
- en: '[PRE51]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Like the function in [Listing 8-11](ch08.xhtml#ch8exe11), this function makes
    the memory writable ➊, places the hook ➌, and restores the memory protection.
    Before placing the hook, it allocates a 5-byte buffer called `originals` ➋ and
    fills it with the original bytes. After the hook is placed, it returns `originals`
    to the calling function.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 像[Listing 8-11](ch08.xhtml#ch8exe11)中的函数一样，这个函数使内存变为可写➊，放置钩子➌，然后恢复内存保护。在放置钩子之前，它分配了一个5字节的缓冲区，名为`originals`➋，并用原始字节填充它。放置钩子后，它将`originals`返回给调用函数。
- en: 'When it’s time to remove the hook, pass `originals` to the following function:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要移除钩子时，将`originals`传递给以下函数：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This code simply iterates over `originals` and quietly places those 5 bytes
    back where they were found so that everything is as expected when execution returns
    to the `EndScene()` function. When the time comes, you can place and remove your
    actual hook using two lines of code, like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简单地遍历`originals`，并悄悄地将那5个字节放回它们被找到的位置，这样当执行返回到`EndScene()`函数时，一切都如预期那样。当时机到来时，你可以使用两行代码来放置和移除你的实际钩子，像这样：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Once you have the `hookWithJump()` and `unhookWithJump()` functions, it’s time
    to prepare the callback and find the device.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有了`hookWithJump()`和`unhookWithJump()`函数，就可以准备回调并找到设备了。
- en: '**Writing the Callback and Trampoline**'
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**编写回调函数和跳转钩子**'
- en: Even though you can obtain the `EndScene()` address from a VF table, the `EndScene()`
    function doesn’t actually follow the `__thiscall` convention. Direct3D classes
    are simple wrappers around a C API, and all of the member function calls are forwarded
    to `__stdcall` functions that take a class instance as a first parameter. This
    means that your trampoline only needs to grab the device from the stack, pass
    it to the callback, and then jump back to `EndScene()`. The callback only has
    to remove the jump hook before returning to the trampoline.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以从 VF 表中获取`EndScene()`的地址，但`EndScene()`函数实际上并不遵循`__thiscall`约定。Direct3D
    类只是 C API 的简单封装，所有的成员函数调用都会转发到`__stdcall`函数，这些函数的第一个参数是类实例。这意味着你的跳转钩子只需要从栈中获取设备，将其传递给回调函数，然后跳回`EndScene()`函数。回调函数只需在返回到跳转钩子之前移除跳转钩子。
- en: 'The final code for the callback and trampoline to this jump hook looks something
    like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数和跳转钩子的最终代码如下所示：
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Using the `hookWithJump()` function, you can place a jump hook on `EndScene()`
    that calls the `endSceneTrampoline()` function. When the game’s device calls the
    `EndScene()` function, the trampoline function calls the `reportInitEndScene()`
    function ➊. The `reportInitEndScene()` function stores the captured device pointer
    to a global variable called `discoveredDevice`, removes the hook by calling `unhookWithJump()`,
    and returns the address of `EndScene()` to the trampoline. To finish up, the trampoline
    jumps directly to EAX, which will be holding the address that was returned from
    the reporting function.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`hookWithJump()`函数，你可以在`EndScene()`上放置一个跳转钩子，调用`endSceneTrampoline()`函数。当游戏的设备调用`EndScene()`函数时，跳转钩子函数会调用`reportInitEndScene()`函数
    ➊。`reportInitEndScene()`函数将捕获的设备指针存储到名为`discoveredDevice`的全局变量中，通过调用`unhookWithJump()`移除钩子，并返回`EndScene()`的地址给跳转钩子。最后，跳转钩子会直接跳转到
    EAX 寄存器，EAX 存储的是从报告函数返回的地址。
- en: '**NOTE**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can use jump hooks to completely skip the VF table hooking that I’ll show
    you, but it’s very unreliable to use “dumb” jump hooks on commonly hooked API
    functions. Consistently obtaining good results with only jump hooks requires professional
    hooking libraries, and I’d rather teach you how to do it completely on your own.*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以使用跳转钩子来完全跳过我将要展示的 VF 表钩子，但在常用的钩子 API 函数上使用“傻瓜式”跳转钩子非常不可靠。要仅使用跳转钩子获得稳定的效果需要专业的钩子库，我更愿意教你如何完全独立地完成这一过程。*'
- en: At this point, all that’s left to do is hook the VF table of `discoveredDevice`
    to hack the game. The next two sections will walk you through hooks on the `EndScene()`
    and `Reset()` functions, which are required if you want a stable hook.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，剩下的工作就是将`discoveredDevice`的 VF 表钩住，从而破解游戏。接下来的两个章节将带你走完`EndScene()`和`Reset()`函数的钩子过程，如果你想要一个稳定的钩子，这是必要的。
- en: '***Writing a Hook for EndScene()***'
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写 EndScene() 钩子***'
- en: 'A hook on `EndScene()` is useful because it allows you to intercept a completed
    frame just before it is rendered; you can effectively execute your own rendering
    code inside the game loop. As you saw when locating this function’s address in
    “[Jump Hooking `EndScene()`](ch08.xhtml#ch00lev1sec177)” on [page 178](ch08.xhtml#page_178),
    this function is at index `42` in the VF table. You can hook `EndScene()` using
    a VF hook as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`EndScene()`钩子非常有用，因为它允许你在渲染完成的帧即将被渲染时进行拦截；你可以有效地在游戏循环内执行你自己的渲染代码。正如你在“[跳转钩住`EndScene()`](ch08.xhtml#ch00lev1sec177)”中所看到的，在[第178页](ch08.xhtml#page_178)找到该函数的地址时，该函数位于
    VF 表的索引`42`处。你可以通过以下方式使用 VF 钩子钩住`EndScene()`：'
- en: '[PRE55]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This code uses the `hookVF()` function from “[Using a VF Table Hook](ch08.xhtml#ch00lev1sec159)”
    on [page 159](ch08.xhtml#page_159) to hook `EndScene()` at index `42` of `discoveredDevice`,
    using `myEndScene()` as the callback function. A direct Direct3D device will occasionally
    repatch its own VF table and restore the original function addresses. This typically
    happens from within the `EndScene()` function, meaning you also have to repatch
    the VF table after calling the original `EndScene()` function. There are a few
    changes you can make to this hook to handle that, as shown in [Listing 8-14](ch08.xhtml#ch8exe14).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了来自“[使用 VF 表钩子](ch08.xhtml#ch00lev1sec159)”中的`hookVF()`函数，在[第159页](ch08.xhtml#page_159)将`EndScene()`钩住，钩子的索引是`42`，并使用`myEndScene()`作为回调函数。直接的
    Direct3D 设备偶尔会重新修补自己的 VF 表，并恢复原始的函数地址。这通常发生在`EndScene()`函数内部，这意味着在调用原始的`EndScene()`函数后，你还需要重新修补
    VF 表。你可以对这个钩子进行一些修改来处理这种情况，具体方法见[清单 8-14](ch08.xhtml#ch8exe14)。
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*Listing 8-14: Final code to hook `EndScene()`*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单8-14：钩住`EndScene()`的最终代码*'
- en: The code to place the hook has been moved into a function called `placeHooks()`
    so it can be called multiple times with ease. The callback function still forwards
    the call to the original function, but it makes sure to call `placeHooks()` before
    returning. This ensures that the hook is always active, even if the original `EndScene()`
    function removes it.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 放置钩子的代码已被移入一个名为`placeHooks()`的函数中，以便可以轻松多次调用。回调函数仍然将调用转发到原始函数，但在返回之前会确保调用`placeHooks()`。这样可以确保钩子始终处于激活状态，即使原始的`EndScene()`函数将其移除。
- en: Another point to notice is that `placeHooks()` updates the address of `origEndScene()`
    every time the hook is replaced, as long as the address returned from `hookVF()`
    isn’t the address of the `myEndScene()` function. This does two distinct things.
    First, it allows other applications to hook `EndScene()` without stepping on their
    toes, since it will update `origEndScene()` to whatever is seen in the VF table.
    Second, it makes sure that the value of `origEndScene()` can never be the address
    of our callback, preventing a potential infinite loop. An infinite loop is possible
    otherwise, because `origEndScene()` doesn’t always fix the device’s VF table,
    meaning `placeHooks()` can be called when the VF table still contains the `myEndScene()`
    function.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的点是，每当钩子被替换时，`placeHooks()`都会更新`origEndScene()`的地址，只要从`hookVF()`返回的地址不是`myEndScene()`函数的地址。这做了两件不同的事情。首先，它允许其他应用程序钩住`EndScene()`而不会相互干扰，因为它会将`origEndScene()`更新为VF表中看到的任何内容。其次，它确保`origEndScene()`的值永远不会是我们回调的地址，从而防止潜在的无限循环。否则可能会出现无限循环，因为`origEndScene()`并不总是修复设备的VF表，这意味着当VF表仍然包含`myEndScene()`函数时，`placeHooks()`仍然可以被调用。
- en: '***Writing a Hook for Reset()***'
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***为Reset()编写钩子***'
- en: When you’re using a Direct3D hook in production, you’ll be doing all kinds of
    tasks like drawing custom text, displaying images related to your bot, and interacting
    with function calls from the game. These tasks will require you to create your
    own Direct3D objects that are tied to the game’s device, and that can be a problem.
    From time to time, the game may completely reset its device through a `Reset()`
    function. When a device is reset, you’ll need to update any objects (most commonly
    fonts and sprites) that you’ve created for the device, using their `OnLostDevice()`
    member functions.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在生产环境中使用Direct3D钩子时，你将执行各种任务，比如绘制自定义文本、显示与你的机器人相关的图像，以及与游戏中的函数调用进行交互。这些任务将要求你创建与游戏设备绑定的Direct3D对象，这可能会成为一个问题。因为游戏有时会通过`Reset()`函数完全重置其设备。当设备被重置时，你需要更新为该设备创建的任何对象（最常见的是字体和精灵），使用它们的`OnLostDevice()`成员函数。
- en: 'Since `Reset()` is called from the VF table of the device, you can use a hook
    on it to tell you when the device has been reset. `Reset()` takes two parameters
    and is at index `16` in the VF table. You can add this code to `placeHooks()`
    in [Listing 8-14](ch08.xhtml#ch8exe14) to hook the `Reset()` function:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Reset()`是从设备的VF表中调用的，你可以在它上面使用钩子来告诉你设备何时被重置。`Reset()`接受两个参数，并在VF表中位于索引`16`。你可以将这段代码添加到[清单8-14](ch08.xhtml#ch8exe14)中的`placeHooks()`来钩住`Reset()`函数：
- en: '[PRE57]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And this is the declaration to use for `origReset`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于`origReset`的声明：
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When a reset is successful, the original function returns `D3D_OK`. Your hook
    function recognizes this and calls `OnLostDevice()` accordingly:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当重置成功时，原始函数会返回`D3D_OK`。你的钩子函数会识别这一点并相应地调用`OnLostDevice()`：
- en: '[PRE59]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Once you fill in the contents of the `if()` statement, all of your objects are
    ready to use again.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你填充了`if()`语句的内容，所有的对象就可以重新使用了。
- en: '***What’s Next?***'
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***接下来是什么？***'
- en: Now that I’ve shown you how to take control of a game’s Direct3D device, you’re
    probably wondering what you can do with it. Unlike the other examples in the book,
    the code in this section and the example code don’t have a one-to-one correlation,
    but the functionality is still the same. Here’s a high-level view of the correlation
    between this chapter and the code in the *Chapter8_Direct3DHook* example project.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经向你展示了如何控制游戏的Direct3D设备，你可能在想你能用它做什么。与书中的其他示例不同，本节中的代码和示例代码没有一一对应的关系，但功能仍然相同。以下是本章与*Chapter8_Direct3DHook*示例项目中代码的高层次对应关系。
- en: The file *DirectXHookCallbacks.h* contains the callbacks for the `EndScene()`
    and `Reset()` functions, two callbacks for other common functions, and the trampoline
    and reporter functions for the temporary jump hook. These functions are all pretty
    much as described in this chapter, except they call into a singleton class defined
    in *DirectXHook.h* and *DirectXHook.cpp*. This singleton class is responsible
    for forwarding the calls to the original functions.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*DirectXHookCallbacks.h*包含`EndScene()`和`Reset()`函数的回调函数，另外还有两个常见函数的回调，以及用于临时跳转钩子的跳板函数和报告函数。这些函数基本上与本章中描述的相同，只不过它们调用了一个在*DirectXHook.h*和*DirectXHook.cpp*中定义的单例类。这个单例类负责将调用转发到原始函数。
- en: The class is also responsible for all of the heavy lifting, and it contains
    the code to create the discovery device, place the hooks, draw text, handle device
    resets, and display images. Furthermore, it allows external code to add custom
    callbacks for each hook, as you can see in *main.cpp*. Here, you’ll see a number
    of different callbacks that are drawing custom text, adding new images to the
    screen, and changing the textures of models that are drawn by the game. I recommend
    poking around in the code to get a better understanding of what’s going on, but
    don’t get too carried away. We’ll dive into this code in [Chapter 9](ch09.xhtml#ch09)
    to talk about all the cool hacks it can do.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类还负责所有的重型操作，它包含了创建发现设备、放置钩子、绘制文本、处理设备重置和显示图像的代码。此外，它允许外部代码为每个钩子添加自定义回调，如你在*main.cpp*中所看到的那样。在这里，你将看到许多不同的回调，它们绘制自定义文本、向屏幕添加新图像并改变游戏绘制的模型纹理。我建议你深入研究代码，以便更好地理解发生了什么，但不要过于投入。我们将在[第9章](ch09.xhtml#ch09)中深入探讨这段代码，讨论它所能做的所有有趣的破解。
- en: '**OPTIONAL FIXES FOR STABILITY**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**提高稳定性的可选修复**'
- en: The `Reset()` and `EndScene()` hooks described in this chapter should work well
    for any game running Direct3D 9, but it is slightly unstable. If the game tries
    to execute `EndScene()` when the jump hook is placed, it will crash because the
    bytes are being modified. There are two ways to fix this. First, you can place
    the jump hook from within an IAT hook on `PeekMessage()`. This will work because
    placing an IAT hook is a thread-safe operation, but it assumes that `PeekMessage()`
    is called only from the same thread that does the Direct3D drawing.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述的`Reset()`和`EndScene()`钩子应该能够在运行Direct3D 9的任何游戏中正常工作，但它稍微有些不稳定。如果游戏在放置跳转钩子时尝试执行`EndScene()`，它会因为字节被修改而崩溃。有两种方法可以解决这个问题。首先，你可以通过在`PeekMessage()`上放置一个IAT钩子来放置跳转钩子。这将有效，因为放置IAT钩子是线程安全的操作，但它假设`PeekMessage()`只会从执行Direct3D绘制的相同线程中调用。
- en: A safer, but more complex, alternative is to iterate over every thread in the
    game (similar to how it worked for thread hijacking) and use `SuspendThread()`
    to pause all threads in the game (except for the one placing the hook, of course).
    Before pausing a thread, you must make sure its `EIP` is not executing the first
    5 bytes of `EndScene()`. After the hook is placed, you must use `ResumeThread()`
    to restore execution with your hook in place.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更安全，但更复杂的替代方法是遍历游戏中的每个线程（类似于线程劫持的方式），并使用`SuspendThread()`来暂停游戏中的所有线程（当然，除非是放置钩子的线程）。在暂停一个线程之前，你必须确保它的`EIP`不会执行`EndScene()`的前5个字节。钩子安装完成后，你必须使用`ResumeThread()`来恢复执行，并且保持钩子生效。
- en: '**Closing Thoughts**'
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结束语**'
- en: Control flow manipulation is a very important skill in game hacking, and a lot
    of the hacks in this book rely on it. Throughout the next two chapters you’ll
    learn how to create common hacks using the Direct3D hook, and you’ll get a better
    idea of the general use cases of hooking. Even if you feel a little shaky, continue
    to [Chapter 9](ch09.xhtml#ch09). The code examples there center on the Direct3D
    hook and will get you even more familiar with hooking techniques.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流操作是游戏破解中的一项非常重要的技能，本书中的许多破解都依赖于它。在接下来的两章中，你将学习如何使用Direct3D钩子创建常见的破解技术，并且你将更好地了解钩子的常见使用场景。即使你感到有些不确定，也请继续阅读[第9章](ch09.xhtml#ch09)。那里的代码示例集中在Direct3D钩子，并将让你更加熟悉钩子技术。
