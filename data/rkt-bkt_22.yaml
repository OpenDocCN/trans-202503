- en: '**19'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**19'
- en: 'BIOS/UEFI FORENSICS: FIRMWARE ACQUISITION AND ANALYSIS APPROACHES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**BIOS/UEFI取证：固件获取与分析方法**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Recent rootkits targeting UEFI firmware have renewed interest in UEFI firmware
    forensics. Leaks of classified information on state-sponsored BIOS implants, as
    well as the security breach at Hacking Team mentioned in [Chapter 15](ch15.xhtml#ch15),
    have demonstrated the increasingly stealthy and powerful capabilities of malware
    that targets the BIOS and prompted the research community to dig deeper into firmware.
    We’ve already discussed some technical details of these BIOS threats in previous
    chapters. If you haven’t read [Chapters 15](ch15.xhtml#ch15) and [16](ch16.xhtml#ch16),
    we highly recommend doing so before continuing; those chapters cover important
    firmware security concepts that we assume you understand for this discussion.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最近针对UEFI固件的rootkit攻击重新激起了人们对UEFI固件取证的兴趣。有关国家支持的BIOS植入程序的机密信息泄露，以及在[第15章](ch15.xhtml#ch15)中提到的Hacking
    Team的安全泄露事件，展示了针对BIOS的恶意软件越来越隐蔽和强大的能力，并促使研究界深入探讨固件领域。我们在前几章中已经讨论了一些关于这些BIOS威胁的技术细节。如果你还没读过[第15章](ch15.xhtml#ch15)和[第16章](ch16.xhtml#ch16)，强烈建议你在继续之前阅读这两章；这两章涉及了固件安全的关键概念，我们假设你已经理解这些概念。
- en: '**NOTE**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this chapter, we use the terms* BIOS *and* UEFI firmware *interchangeably.*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们将* BIOS *和* UEFI固件 *交替使用。*'
- en: UEFI firmware forensics is currently an emerging area of research, so security
    researchers working in this field lack conventional tools and approaches. In this
    chapter, we’ll cover some firmware analysis techniques, including various approaches
    to firmware acquisition and methods of parsing and extracting useful information.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，UEFI固件取证是一个新兴的研究领域，因此从事该领域的安全研究人员缺乏传统的工具和方法。在本章中，我们将介绍一些固件分析技术，包括固件获取的不同方法以及解析和提取有用信息的技术。
- en: We first focus on acquiring firmware, which is usually the first step of a forensic
    analysis. We cover both a software and a hardware approach to obtaining a UEFI
    firmware image. Next, we compare these approaches and discuss the advantages and
    disadvantages of each. We then discuss the internal structure of the UEFI firmware
    image and how to parse it in order to extract forensic artifacts. In the context
    of this discussion, we show you how to use UEFITool, an indispensable open source
    firmware analysis tool for browsing and modifying UEFI firmware images. Finally,
    we discuss Chipsec, a tool with very extensive and powerful functionality, and
    consider its applications for forensics analysis. Both tools were introduced in
    [Chapter 15](ch15.xhtml#ch15).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先关注固件获取，这是取证分析的第一步。我们将介绍软件和硬件两种方法来获取UEFI固件镜像。接下来，我们将比较这些方法，并讨论每种方法的优缺点。然后，我们讨论UEFI固件镜像的内部结构，以及如何解析它以提取取证证据。在本次讨论中，我们将展示如何使用UEFITool，这是一款不可或缺的开源固件分析工具，用于浏览和修改UEFI固件镜像。最后，我们讨论Chipsec，这是一款功能非常强大且广泛的工具，并考虑它在取证分析中的应用。两款工具在[第15章](ch15.xhtml#ch15)中已有介绍。
- en: '**Limitations of Our Forensic Techniques**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**我们取证技术的局限性**'
- en: 'The material we present here does have some limitations. In modern platforms,
    there are many types of firmware: UEFI firmware, Intel ME firmware, hard drive
    controller firmware, and so on. This chapter is dedicated specifically to the
    analysis of UEFI firmware, which constitutes one of the largest parts of platform
    firmware.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里呈现的材料确实存在一些局限性。在现代平台上，固件种类繁多：UEFI固件、Intel ME固件、硬盘控制器固件等等。本章专门致力于UEFI固件的分析，它是平台固件中最大的一部分。
- en: Note also that firmware is very platform specific; that is, each platform has
    its own peculiarities. In this chapter, we’ll focus on UEFI firmware for Intel
    x86 systems, which constitute the majority of desktop, laptop, and server market
    segments.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，固件非常具有平台特性；也就是说，每个平台都有其独特性。在本章中，我们将重点讨论针对Intel x86系统的UEFI固件，这些系统占据了大多数桌面、笔记本和服务器市场份额。
- en: '**Why Firmware Forensics Matter**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为什么固件取证很重要**'
- en: In [Chapter 15](ch15.xhtml#ch15), we saw that modern firmware is a convenient
    place for embedding very powerful backdoors or rootkits, specifically in the BIOS.
    This type of malware is capable of surviving OS reinstallation or hard drive replacement,
    and it gives an attacker control over an entire platform. At the time of this
    writing, most state-of-the-art security software doesn’t take into account UEFI
    firmware threats at all, making them even more dangerous. This gives an attacker
    a big opportunity to implant malware that persists undetected on the target system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 15 章](ch15.xhtml#ch15)中，我们看到现代固件是嵌入非常强大的后门或 rootkit 的便捷位置，尤其是在 BIOS 中。这种类型的恶意软件能够在操作系统重装或硬盘更换后存活，并且使攻击者能够控制整个平台。在写作本文时，大多数最先进的安全软件根本没有考虑到
    UEFI 固件威胁，这使得它们更加危险。这为攻击者提供了一个重要机会，可以在目标系统上植入持久存在且未被检测到的恶意软件。
- en: Next, we outline a couple of specific ways attackers might use firmware rootkits.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们概述了攻击者可能利用固件 rootkit 的几种具体方式。
- en: '***Attacking the Supply Chain***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***攻击供应链***'
- en: Threats targeting UEFI firmware increase the risk of supply chain attacks, because
    attackers can install a malicious implant on a server before it is delivered to
    the data center or to a laptop before it gets to the IT department. And because
    these threats can impact a large number of a service provider’s clients by exposing
    all their secrets, big cloud-computing players like Google have recently started
    to use firmware forensic analysis techniques to ensure that their firmware isn’t
    compromised.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 针对 UEFI 固件的威胁增加了供应链攻击的风险，因为攻击者可以在服务器送往数据中心之前，或者在笔记本电脑送到 IT 部门之前，安装恶意植入物。而且，由于这些威胁可能通过暴露所有秘密影响大量服务提供商的客户，一些大型云计算公司，如
    Google，最近开始使用固件取证分析技术，以确保其固件没有被破坏。
- en: '**GOOGLE TITAN CHIP**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**GOOGLE TITAN 芯片**'
- en: In 2017, Google publicly introduced Titan, a chip that protects platform firmware
    by establishing a hardware root of trust. Trusting your hardware configuration
    is important, especially when it comes to cloud security, where the impact of
    an attack is multiplied by the number of affected clients.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2017 年，Google 公布了 Titan 芯片，这是一款通过建立硬件信任根来保护平台固件的芯片。信任硬件配置至关重要，尤其是在云安全领域，因为攻击的影响会因受影响的客户数量而成倍增加。
- en: Companies that work with big clouds and data, like Amazon, Google, Microsoft,
    Facebook, and Apple, are working on developing (or have developed) hardware to
    control the platform root of trust. Even if attackers use a firmware rootkit to
    compromise a platform, having an isolated root of trust will prevent Secure Boot
    attacks and firmware update attacks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与大型云和数据相关的公司，如 Amazon、Google、Microsoft、Facebook 和 Apple，正在开发（或已经开发）用于控制平台信任根的硬件。即使攻击者利用固件
    rootkit 攻击平台，拥有一个隔离的信任根也能防止 Secure Boot 攻击和固件更新攻击。
- en: '***Compromising BIOS Through Firmware Vulnerability***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过固件漏洞攻破 BIOS***'
- en: Attackers can compromise the platform firmware by exploiting a vulnerability
    in it to bypass BIOS write protection or authentication. For a refresher on this
    attack, return to [Chapter 16](ch16.xhtml#ch16), where we discuss different classes
    of vulnerabilities used to attack the BIOS. To detect these attacks, you could
    use the firmware forensic approaches discussed in this chapter to verify the integrity
    of a platform’s firmware or to help detect malicious firmware modules.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过利用固件中的漏洞，绕过 BIOS 写保护或认证，从而破坏平台固件。如需了解这种攻击，请参阅[第 16 章](ch16.xhtml#ch16)，我们在其中讨论了用于攻击
    BIOS 的不同类型的漏洞。为了检测这些攻击，可以使用本章讨论的固件取证方法来验证平台固件的完整性，或帮助检测恶意固件模块。
- en: '**Understanding Firmware Acquisition**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**理解固件获取**'
- en: The very first step in BIOS forensic analysis is the process of obtaining an
    image of the BIOS firmware to analyze. To better understand the location of BIOS
    firmware on modern platforms, refer to [Figure 19-1](ch19.xhtml#ch19fig01), which
    demonstrates the architecture of a typical PC system’s chipset.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS 取证分析的第一步是获取 BIOS 固件的映像进行分析。要更好地了解现代平台上 BIOS 固件的位置，请参阅[图 19-1](ch19.xhtml#ch19fig01)，该图展示了典型
    PC 系统芯片组的架构。
- en: 'There are two main components in the chipset: a CPU and a Platform Controller
    Hub (PCH) or South Bridge. The PCH provides a connection between the controllers
    of peripheral devices available on the platform and the CPU. In most modern systems
    based on Intel x86 architecture (including 64-bit platforms), the system firmware
    is located on a flash memory in the Serial Peripheral Interface (SPI) bus ➊, which
    is physically connected to the PCH. The SPI flash constitutes the main target
    for forensic analysis because it stores the firmware we want to analyze.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片组中有两个主要组件：一个CPU和一个平台控制器集线器（PCH）或南桥。PCH提供了平台上外设设备控制器与CPU之间的连接。在大多数基于Intel x86架构（包括64位平台）的现代系统中，系统固件位于串行外设接口（SPI）总线上的闪存中➊，该总线物理上与PCH连接。SPI闪存是法医分析的主要目标，因为它存储了我们想要分析的固件。
- en: '![image](../images/19fig01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig01.jpg)'
- en: '*Figure 19-1: A block diagram of a modern Intel chipset*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-1：现代Intel芯片组的框图*'
- en: The motherboard of a PC typically has one discrete physical SPI flash chip soldered
    onto it, but you might occasionally encounter systems with multiple SPI flash
    chips. This happens when a single chip doesn’t have enough capacity to store all
    the system firmware; in that case, the platform vendor uses two chips. We discuss
    this situation later in this chapter, in “[Locating the SPI Flash Memory Chip](ch19.xhtml#ch19lev2sec9)”
    on [page 376](ch19.xhtml#page_376).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一块PC主板通常有一个单独的物理SPI闪存芯片焊接在其上，但你可能偶尔会遇到有多个SPI闪存芯片的系统。这种情况发生在单个芯片没有足够的容量来存储所有系统固件时；在这种情况下，平台厂商使用两个芯片。我们将在本章稍后的“[定位SPI闪存芯片](ch19.xhtml#ch19lev2sec9)”中讨论这种情况，见[第376页](ch19.xhtml#page_376)。
- en: '**DUALBIOS TECHNOLOGY**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**双BIOS技术**'
- en: DualBIOS technology also uses multiple SPI flash chips on the motherboard of
    a computer. But unlike the approach just discussed, where multiple SPI flash chips
    store a single firmware image, DualBIOS technology uses multiple chips to store
    different firmware images or multiples of the same firmware image. This technology
    provides additional protection against firmware corruption, because if the firmware
    in one chip is corrupted, the system could boot from a second chip containing
    an identical firmware image.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 双BIOS技术也使用计算机主板上的多个SPI闪存芯片。但与刚才讨论的使用多个SPI闪存芯片存储单一固件镜像的方式不同，双BIOS技术使用多个芯片存储不同的固件镜像或相同固件镜像的多个副本。这项技术提供了额外的固件损坏保护，因为如果一个芯片中的固件损坏，系统可以从第二个包含相同固件镜像的芯片启动。
- en: To acquire the firmware image stored on the SPI flash, you need to be able to
    read the contents of the flash. Generally speaking, you can read the firmware
    using either a software or a hardware approach. In the software approach, you
    attempt to read the firmware image by communicating with the SPI controller using
    software running on the host CPU. In the hardware approach, you physically attach
    a special device called an SPI programmer to the SPI flash, then read the firmware
    image directly from the SPI flash. We’ll cover both approaches, starting with
    the software method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取存储在SPI闪存中的固件镜像，你需要能够读取闪存的内容。一般来说，你可以通过软件方法或硬件方法来读取固件。在软件方法中，你尝试通过与SPI控制器通信来读取固件镜像，通信是通过在主机CPU上运行的软件实现的。在硬件方法中，你物理连接一个叫做SPI编程器的特殊设备到SPI闪存，然后直接从SPI闪存读取固件镜像。我们将介绍这两种方法，首先从软件方法开始。
- en: 'Before we go into the description of the software approach, however, you should
    understand that each approach has its advantages and limitations. One of the benefits
    of dumping UEFI firmware using the software method is that you can do it remotely.
    A user of the target system can run an application to dump the contents of the
    SPI flash and send it to a forensic analyst. But this approach also has a major
    drawback: if an attacker has already compromised the system firmware, he or she
    could interfere with the process of firmware acquisition by forging the data read
    from the SPI flash. This makes the software approach somewhat unreliable.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们进入软件方法的描述之前，你应该明白每种方法都有其优缺点。使用软件方法转储UEFI固件的一个好处是可以远程操作。目标系统的用户可以运行一个应用程序，将SPI闪存的内容转储并发送给法医分析师。但这种方法也有一个主要缺点：如果攻击者已经妥协了系统固件，他或她可能通过伪造从SPI闪存读取的数据来干扰固件获取过程。这使得软件方法在一定程度上不可靠。
- en: The hardware approach doesn’t have the same drawback. Even though you must be
    physically present and it requires you to open the target system’s chassis, this
    method directly reads the contents of the powered-off system’s SPI flash without
    giving the attacker any opportunity to counterfeit the data (unless you’re dealing
    with a hardware implant, which we don’t cover in this book).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件方法没有这种缺点。尽管你必须亲自到场并且需要打开目标系统的机箱，但此方法直接读取关闭电源系统的 SPI 闪存内容，而不会给攻击者任何伪造数据的机会（除非你面对的是硬件植入物，但本书不讨论这一内容）。
- en: '**The Software Approach to Firmware Acquisition**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**固件获取的软方法**'
- en: In the software approach to dumping UEFI firmware from the target system, you
    read the contents of the SPI flash from the operating system. You can access modern
    systems’ SPI controllers through registers in the *PCI configuration space* (a
    block of registers that specify device configuration on the PCI bus). These registers
    are memory mapped, and you can read and write to them using regular memory read
    and write operations. In this section, we’ll demonstrate how to locate these registers
    and communicate with the SPI controller.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在从目标系统转储 UEFI 固件的软件方法中，你通过操作系统读取 SPI 闪存的内容。你可以通过 *PCI 配置空间*（指定 PCI 总线上设备配置的一组寄存器）中的寄存器访问现代系统的
    SPI 控制器。这些寄存器是内存映射的，你可以使用常规的内存读写操作对它们进行读写。在本节中，我们将演示如何定位这些寄存器并与 SPI 控制器进行通信。
- en: Before we proceed, you should know that the location of an SPI register is chipset
    specific, so in order to communicate with an SPI controller, we need to refer
    to the chipset dedicated to the platform we’re targeting. In this chapter, we’ll
    demonstrate how to read the SPI flash on chipsets in Intel’s 200 Series (the location
    of SPI registers can be found at *[https://www.intel.com/content/www/us/en/chipsets/200-series-chipset-pch-datasheet-vol-2.html](https://www.intel.com/content/www/us/en/chipsets/200-series-chipset-pch-datasheet-vol-2.html)*),
    which are the latest chipsets for desktop systems at the time of this writing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，你需要知道 SPI 寄存器的位置是芯片组特定的，因此为了与 SPI 控制器进行通信，我们需要参考专为我们目标平台设计的芯片组。在本章中，我们将演示如何读取英特尔
    200 系列芯片组（SPI 寄存器的位置可以在 *[https://www.intel.com/content/www/us/en/chipsets/200-series-chipset-pch-datasheet-vol-2.html](https://www.intel.com/content/www/us/en/chipsets/200-series-chipset-pch-datasheet-vol-2.html)*）的
    SPI 闪存，这些芯片组是本文写作时最新的桌面系统芯片组。
- en: It’s also worth mentioning that the memory locations that correspond to the
    registers exposed via the PCI configuration space are mapped in the kernel-mode
    address space and, as a result, aren’t accessible to code running in the user-mode
    address space. You would need to develop a kernel-mode driver to access the address
    range. The Chipsec tool discussed later in this chapter provides its own kernel-mode
    driver for accessing the PCI configuration space.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是，通过 PCI 配置空间暴露的寄存器对应的内存位置被映射到内核模式地址空间，因此无法访问在用户模式地址空间中运行的代码。你需要开发一个内核模式驱动程序来访问该地址范围。本章稍后讨论的
    Chipsec 工具提供了自己的内核模式驱动程序，用于访问 PCI 配置空间。
- en: '***Locating PCI Configuration Space Registers***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定位 PCI 配置空间寄存器***'
- en: First we need to locate the memory range where the SPI controller’s registers
    are mapped. This memory range is called the *Root Complex Register Block (RCRB)*.
    At offset 3800h in the RCRB, you’ll find the *SPI Base Address Register (SPIBAR)*,
    which holds the base address of memory-mapped SPI registers (see [Figure 19-2](ch19.xhtml#ch19fig02)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定位 SPI 控制器寄存器映射的内存范围。这个内存范围被称为 *根复合寄存器块（RCRB）*。在 RCRB 的 3800h 偏移处，你会找到
    *SPI 基地址寄存器（SPIBAR）*，它保存了内存映射 SPI 寄存器的基地址（参见 [图 19-2](ch19.xhtml#ch19fig02)）。
- en: '![image](../images/19fig02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig02.jpg)'
- en: '*Figure 19-2: The location of SPI control and status registers in system memory*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-2：系统内存中 SPI 控制和状态寄存器的位置*'
- en: '**PCIE BUS**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**PCIE 总线**'
- en: 'The PCI Express (PCIe) bus is a high-speed serial bus standard used on virtually
    all modern PCs across different market segments: consumer laptops and desktops,
    data center servers, and so on. The PCIe bus serves as an interconnection between
    various components and peripheral devices in the computer. Many integrated chipset
    devices (SPI flash, memory controller, and so forth) are represented as PCIe endpoints
    on the bus.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: PCI Express（PCIe）总线是一种高速串行总线标准，几乎在所有现代 PC 中都有使用，包括消费类笔记本电脑和台式机、数据中心服务器等。PCIe
    总线作为计算机内部各个组件和外部设备之间的互连。许多集成的芯片组设备（如 SPI 闪存、内存控制器等）作为 PCIe 总线上的端点设备存在。
- en: The RCRB address is stored in the *Root Complex Base Address (RCBA)* PCI register,
    which is located on bus 0, device 31h, function 0\. This is a 32-bit register,
    and the address of the RCRB is provided in bits 31:14\. We assume that the lower
    14 bits of the RCRB’s address are zeros, since RCRB is aligned at the boundary
    of 16Kb. Once we get the RCRB’s address, we can obtain the SPIBAR value by reading
    memory at the 3800h offset. In the next section, we discuss the SPI registers
    in more detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: RCRB 地址存储在 *根复合基址（RCBA）* PCI 寄存器中，该寄存器位于总线 0，设备 31h，功能 0。这是一个 32 位寄存器，RCRB 的地址存储在第
    31 位到第 14 位中。我们假设 RCRB 地址的低 14 位为零，因为 RCRB 按照 16Kb 边界对齐。一旦我们获得 RCRB 的地址，我们可以通过读取
    3800h 偏移量处的内存来获取 SPIBAR 值。在下一节中，我们将更详细地讨论 SPI 寄存器。
- en: '**SPI FLASH FIRMWARE**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**SPI FLASH 固件**'
- en: The SPI flash contains not only BIOS firmware but also other types of platform
    firmware, like Intel ME (Manageability Engine), Ethernet controller firmware,
    and vendor-specific firmware and data. The various types of firmware differ in
    their locations and access control permissions. For instance, the host OS can’t
    access Intel ME firmware, so the software approach for acquiring firmware won’t
    work for Intel ME.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SPI 闪存不仅包含 BIOS 固件，还包括其他类型的平台固件，如 Intel ME（管理引擎）、以太网控制器固件以及供应商特定的固件和数据。不同类型的固件在其位置和访问控制权限上有所不同。例如，主机操作系统无法访问
    Intel ME 固件，因此获取固件的软件方法对于 Intel ME 不适用。
- en: '***Calculating SPI Configuration Register Addresses***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算 SPI 配置寄存器地址***'
- en: Once we’ve obtained the SPIBAR value, which provides us with the location of
    the SPI registers in memory, we can program the registers to read the contents
    of an SPI flash. The offsets of the SPI registers may vary depending on the platform,
    so the best way to determine the actual values for a given hardware configuration
    is to look up the values in the platform chipset documentation. For instance,
    for platforms supporting Intel’s latest CPU at the time of this writing (Kaby
    Lake), we can consult the Intel 200 Series Chipset Family Platform Controller
    Hub datasheet to find the location of the SPI memory-mapped registers. The information
    is in the section called “Serial Peripheral Interface.” For each SPI register,
    the datasheet provides its offset from the SPIBAR value, register name, and the
    register default value at the platform reset. We’ll use this datasheet as a reference
    in this section to determine the addresses of the SPI registers we’re interested
    in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取了 SPIBAR 值，该值为我们提供了 SPI 寄存器在内存中的位置，我们就可以编程寄存器来读取 SPI 闪存的内容。SPI 寄存器的偏移量可能会根据平台有所不同，因此确定给定硬件配置的实际值的最佳方法是查阅平台芯片组文档。例如，对于本文写作时支持
    Intel 最新 CPU（Kaby Lake）的平台，我们可以查阅 Intel 200 系列芯片组家族平台控制器集线器数据手册，以查找 SPI 内存映射寄存器的位置。相关信息位于名为“串行外设接口”的章节中。对于每个
    SPI 寄存器，数据手册提供了从 SPIBAR 值的偏移量、寄存器名称以及平台重置时寄存器的默认值。我们将在本节中使用该数据手册作为参考，来确定我们感兴趣的
    SPI 寄存器的地址。
- en: '***Using the SPI Registers***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 SPI 寄存器***'
- en: Now that you know how to find the addresses of SPI registers, you can figure
    out which one you’ll use to read the contents of the SPI flash. [Table 19-1](ch19.xhtml#ch19tab01)
    lists all the registers we’ll need to obtain an image of the SPI flash.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何查找 SPI 寄存器的地址，你可以确定使用哪个寄存器来读取 SPI 闪存的内容。[表 19-1](ch19.xhtml#ch19tab01)
    列出了我们需要用来获取 SPI 闪存镜像的所有寄存器。
- en: '**Table 19-1:** SPI Registers for Firmware Acquisition'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 19-1：** 固件获取的 SPI 寄存器'
- en: '| **Offset from SPIBAR** | **Register name** | **Register description** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **从 SPIBAR 的偏移量** | **寄存器名称** | **寄存器描述** |'
- en: '| --- | --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 04h–05h | HSFS | Hardware sequencing flash status |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 04h–05h | HSFS | 硬件排序闪存状态 |'
- en: '| 06h–07h | HSFC | Hardware sequencing flash control register |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 06h–07h | HSFC | 硬件排序闪存控制寄存器 |'
- en: '| 08h–0Bh | FADDR | Flash address |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 08h–0Bh | FADDR | 闪存地址 |'
- en: '| 10h–4Fh | FDATAX | Array of flash data |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 10h–4Fh | FDATAX | 闪存数据数组 |'
- en: '| 58h–5Bh | FREG1 | Flash region 1 (BIOS descriptor) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 58h–5Bh | FREG1 | 闪存区域 1（BIOS 描述符） |'
- en: We’ll discuss each of these registers in the following sections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论这些寄存器。
- en: '**The FREG1 Register**'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**FREG1 寄存器**'
- en: The register we’ll start with is *flash region 1 (FREG1)*. It provides the location
    of the BIOS region on the SPI flash. The layout of this 32-bit-length register
    is presented in [Figure 19-3](ch19.xhtml#ch19fig03).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要介绍的寄存器是 *闪存区域 1（FREG1）*。它提供了 BIOS 区域在 SPI 闪存中的位置。此 32 位长度寄存器的布局见 [图 19-3](ch19.xhtml#ch19fig03)。
- en: '![image](../images/19fig03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig03.jpg)'
- en: '*Figure 19-3: The layout of FREG1 SPI register*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-3：FREG1 SPI 寄存器布局*'
- en: The Region Base field ➋ provides 24:12 bits of the base address for the BIOS
    region in the SPI flash. Since the BIOS region is aligned at 4Kb, the lowest 12
    bits of the region’s base address start at 0\. The Region Limit field ➊ provides
    24:12 bits for the BIOS region in the SPI flash. For instance, if the Region Base
    field contains a value of 0xaaa and Region Limit contains a value of 0xbbb, then
    the BIOS regions spans from 0xaaa000 to 0xbbbfff on the SPI flash.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Region Base 字段 ➋ 提供了 BIOS 区域在 SPI 闪存中的基地址的 24:12 位。由于 BIOS 区域是按 4KB 对齐的，因此该区域基地址的最低
    12 位从 0 开始。Region Limit 字段 ➊ 提供了 BIOS 区域在 SPI 闪存中的 24:12 位。例如，如果 Region Base 字段的值为
    0xaaa，Region Limit 字段的值为 0xbbb，则 BIOS 区域从 0xaaa000 到 0xbbbfff 之间。
- en: '**The HSFC Register**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**HSFC 寄存器**'
- en: The *hardware sequencing flash control (HSFC)* register allows us to send commands
    to the SPI controller. (In the specification, these commands are referred to as
    *cycles*.) You can see the layout of the HSFC register in [Figure 19-4](ch19.xhtml#ch19fig04).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*硬件顺序闪存控制 (HSFC)* 寄存器允许我们向 SPI 控制器发送命令。（在规格说明中，这些命令被称为 *周期*。）您可以在 [图19-4](ch19.xhtml#ch19fig04)
    中看到 HSFC 寄存器的布局。'
- en: '![image](../images/19fig04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig04.jpg)'
- en: '*Figure 19-4: The layout of HSFC SPI register*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-4：HSFC SPI 寄存器布局*'
- en: 'We use the HSFC register to send a read/write/delete cycle to the SPI flash.
    The 2-bit FCYCLE field ➌ encodes the operation to perform the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 HSFC 寄存器向 SPI 闪存发送读/写/删除周期。2 位的 FCYCLE 字段 ➌ 编码了要执行的操作：
- en: '**00** Read a block of data from the SPI flash'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**00** 从 SPI 闪存读取数据块'
- en: '**01** Write a block of data to the SPI flash'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**01** 向 SPI 闪存写入数据块'
- en: '**11** Erase a block of data on the SPI flash'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**11** 擦除 SPI 闪存中的数据块'
- en: '**10** Reserved'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**10** 保留'
- en: For read and write cycles, the FDBC field ➋ indicates the number of bytes that
    should be transferred to and from the SPI flash. The content of this field is
    zero based; a value of 000000b represents 1 byte, and a value of 111111b represents
    64 bytes. As a result, the number of bytes to transfer is the value of this field
    plus 1.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读写周期，FDBC 字段 ➋ 表示应传输到 SPI 闪存的字节数。此字段的内容是以零为基准的；000000b 表示 1 字节，111111b 表示
    64 字节。因此，要传输的字节数为该字段的值加 1。
- en: The FGO field ➍ is used to initiate the SPI flash operation. When the value
    of this field is 1b, the SPI controller will read, write, and erase the data based
    on the values written to the FCYCLE and FDBC fields. Before setting the FGO field,
    the software needs to have specified all the registers that indicate the type
    of the operation, the amount of data, and the SPI flash address.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: FGO 字段 ➍ 用于启动 SPI 闪存操作。当此字段的值为 1b 时，SPI 控制器将根据写入 FCYCLE 和 FDBC 字段的值进行读、写和擦除操作。在设置
    FGO 字段之前，软件需要指定所有指示操作类型、数据量和 SPI 闪存地址的寄存器。
- en: The final HSFC field that deserves our attention is *flash SPI SMI# enable (FSMIE)*
    ➊. When this field is set, the chipset generates a System Management Interrupt
    (SMI), which leads to the execution of the SMM code. As we’ll see in “[Considering
    the Drawbacks of the Software Approach](ch19.xhtml#ch19lev2sec7)” on [page 373](ch19.xhtml#page_373),
    you could use FSMIE to counteract the firmware image acquisition.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关注的最后一个 HSFC 字段是 *闪存 SPI SMI# 启用 (FSMIE)* ➊。当该字段被设置时，芯片组会生成系统管理中断（SMI），从而触发
    SMM 代码的执行。正如我们在 “[考虑软件方法的缺点](ch19.xhtml#ch19lev2sec7)” 的 [第373页](ch19.xhtml#page_373)
    中所看到的，您可以使用 FSMIE 来对抗固件映像获取。
- en: '**COMMUNICATING WITH THE SPI CONTROLLER**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**与 SPI 控制器通信**'
- en: 'Using the HSFC register isn’t the only way to send commands to the SPI controller.
    Generally, there are two ways to communicate with the SPI flash: hardware sequencing
    and software sequencing. With the hardware-sequencing method we’re showing here,
    we let the hardware pick the SPI commands that get sent for read/write operations
    (which is exactly what the HSFC register is used for). Software sequencing offers
    us more power to choose which specific commands get sent to read/write operations.
    In this section, we use hardware sequencing through the HSFC register because
    it’s easy and it provides us with the functionality we need to read the BIOS firmware.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HSFC寄存器并不是向SPI控制器发送命令的唯一方式。通常，与SPI闪存通信有两种方式：硬件序列和软件序列。在这里我们展示的硬件序列方法是通过让硬件选择发送用于读/写操作的SPI命令（这正是HSFC寄存器的作用）。软件序列则让我们有更多的选择，可以指定具体的命令来执行读/写操作。在本节中，我们通过HSFC寄存器使用硬件序列，因为它简单且能提供读取BIOS固件所需的功能。
- en: '**The FADDR Register**'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**FADDR寄存器**'
- en: We use the *flash address (FADDR)* register to specify the SPI flash linear
    address for read, write, and erase operations. This register is 32 bits, but we
    use only the lower 24 bits to specify a linear address for the operation. The
    upper 8 bits of this register are reserved and unused.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*闪存地址(FADDR)*寄存器来指定用于读、写和擦除操作的SPI闪存线性地址。该寄存器为32位，但我们只使用低24位来指定操作的线性地址。该寄存器的高8位是保留的且未使用。
- en: '**The HSFS Register**'
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**HSFS寄存器**'
- en: Once we’ve initiated the SPI cycle by setting the FGO field of the HSFC register,
    we can determine when the cycle has finished by looking at the *hardware sequencing
    flash status (HSFS)* register. This register is composed of multiple fields that
    provide information on the status of the requested operation. In [Table 19-2](ch19.xhtml#ch19tab02),
    you can see the HSFS fields used to read the SPI image.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过设置HSFC寄存器的FGO字段启动了SPI周期，就可以通过查看*硬件序列闪存状态（HSFS）*寄存器来确定周期是否已完成。该寄存器由多个字段组成，这些字段提供有关请求操作状态的信息。在[表19-2](ch19.xhtml#ch19tab02)中，您可以看到用于读取SPI映像的HSFS字段。
- en: '**Table 19-2:** The SPI Register HSFS Fields'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**表19-2：** SPI寄存器HSFS字段'
- en: '| **Field offset** | **Field size** | **Field name** | **Field description**
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **字段偏移** | **字段大小** | **字段名称** | **字段描述** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0h | 1 | FDONE | Flash cycle done |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 0h | 1 | FDONE | 闪存周期完成 |'
- en: '| 1h | 1 | FCERR | Flash cycle error |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 1h | 1 | FCERR | 闪存周期错误 |'
- en: '| 2h | 1 | AEL | Access error log |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 2h | 1 | AEL | 访问错误日志 |'
- en: '| 5h | 1 | SCIP | SPI cycle in progress |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 5h | 1 | SCIP | SPI周期进行中 |'
- en: 'The FDONE bit is set by the chipset when the previous flash cycle (initiated
    by the HSFC register’s FGO field) is complete. The FCERR and AEL bits indicate
    that an error has occurred during the SPI flash cycle and that the returned data
    may not contain valid values, respectively. The SCIP bit indicates that the flash
    cycle is in progress. We set the SCIP by setting the FGO bit, and the SCIP clears
    when the value of FDONE is 1\. Based on this information, we can determine that
    the operation we initiated has completed successfully when the following expression
    is true:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当上一个闪存周期（由HSFC寄存器的FGO字段启动）完成时，芯片组会设置FDONE位。FCERR和AEL位指示在SPI闪存周期中发生了错误，返回的数据可能不包含有效值。SCIP位指示闪存周期正在进行中。我们通过设置FGO位来设置SCIP，且当FDONE的值为1时，SCIP会被清除。根据这些信息，我们可以确定当以下表达式为真时，我们启动的操作已成功完成：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**The FDATAX Registers**'
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**FDATAX寄存器**'
- en: The *array of flash data (FDATAX)* registers hold the data to be read from or
    written to the SPI flash. Each register is 32 bits, and the total number of FDATAX
    registers in use depends on the amount of bytes to transfer, which is specified
    in the HSFC register’s FDBC field.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*闪存数据数组(FDATAX)*寄存器保存着从SPI闪存读取或写入的数据。每个寄存器是32位的，使用的FDATAX寄存器总数取决于要传输的字节数，这个字节数由HSFC寄存器的FDBC字段指定。'
- en: '***Reading Data from the SPI Flash***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从SPI闪存读取数据***'
- en: Now let’s put together all this information and see how to read data from the
    SPI flash using these registers. First, we locate the Root Complex Registers Block,
    from which we can determine the base address of SPI memory-mapped registers and
    get access to those registers. By reading the FREG1 SPI register, we can determine
    the location of the BIOS region on the flash—that is, the BIOS starting address
    and BIOS limit.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将所有这些信息汇总起来，看看如何使用这些寄存器从SPI闪存中读取数据。首先，我们定位根复合寄存器块，从中可以确定SPI内存映射寄存器的基地址，并获取对这些寄存器的访问权限。通过读取FREG1
    SPI寄存器，我们可以确定BIOS区域在闪存中的位置——即BIOS的起始地址和BIOS限制。
- en: Next, we read the BIOS region using the SPI registers just described. This step
    is demonstrated in [Figure 19-5](ch19.xhtml#ch19fig05).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用刚才描述的SPI寄存器读取BIOS区域。此步骤在[图19-5](ch19.xhtml#ch19fig05)中进行了演示。
- en: '![image](../images/19fig05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig05.jpg)'
- en: '*Figure 19-5: Reading data from the SPI flash*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-5：从SPI闪存读取数据*'
- en: First, we set FADDR to the linear address of the flash memory region that we
    want to read ➊. Then we specify the total number of bytes to read from flash memory
    by setting the FDBC field ➋ of the flash control register. (A value of 111111b
    would read 64 bytes per cycle.) Next we set the FCYCLE field ➌ with the 00b value,
    which indicates the read cycle and sets the FGO bit ➍ that starts our flash reading
    operation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将FADDR设置为我们要读取的闪存区域的线性地址 ➊。然后，我们通过设置闪存控制寄存器的FDBC字段 ➋ 来指定从闪存读取的总字节数。（111111b的值表示每次读取64字节。）接着，我们用00b值设置FCYCLE字段
    ➌，该值表示读取周期并设置启动我们闪存读取操作的FGO位 ➍。
- en: Once we set the FGO bit, we need to monitor the flash status register to know
    when the operation is complete. We can do this by checking the FDONE, FCERR, AEL,
    and SCIP fields ➎. Once the read operation is finished, we read flash data from
    the FDATAX registers ➏. The FDATAX[1] register provides us with the first 4 bytes
    of flash memory at the target address specified in the FADDR register; FDATAX[2]
    provides us with the second 4 bytes of flash memory, and so on. By repeating these
    steps and incrementing the FADDR value by 64 bytes in each iteration, we read
    the whole BIOS region from the SPI flash.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了FGO位，我们需要监控闪存状态寄存器，以了解操作何时完成。我们可以通过检查FDONE、FCERR、AEL和SCIP字段 ➎ 来做到这一点。读取操作完成后，我们从FDATAX寄存器
    ➏ 中读取闪存数据。FDATAX[1]寄存器提供我们目标地址（由FADDR寄存器指定）处的前4个字节闪存；FDATAX[2]提供第二组4个字节闪存，以此类推。通过重复这些步骤，并在每次迭代时将FADDR值增加64字节，我们可以从SPI闪存中读取整个BIOS区域。
- en: '***Considering the Drawbacks of the Software Approach***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***考虑到软件方法的缺点***'
- en: The software approach to BIOS firmware dumping is convenient because it doesn’t
    require you to be physically present; with this method, you can read the contents
    of the SPI flash remotely. But it isn’t robust against an attacker who has already
    compromised the system firmware and can execute malicious code in SMM.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS固件转储的软件方法很方便，因为它不需要你在场；通过这种方法，你可以远程读取SPI闪存的内容。但它对已经破坏了系统固件并能在SMM中执行恶意代码的攻击者来说并不稳健。
- en: As we’ve noted, the HSFC register has an FSMIE bit that triggers an SMI when
    the flash cycle completes. If an attacker has already compromised SMM and is able
    to set the FSMIE bit before the firmware acquisition software sets the FGO bit,
    then the attacker will receive control once the SMI is generated and will be able
    to modify the contents of the FDATAX registers. As a result, the firmware acquisition
    software will read forged values from FDATAX and won’t be able to get an original
    image of the BIOS region. [Figure 19-6](ch19.xhtml#ch19fig06) demonstrates this
    attack.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所注意到的，HSFC寄存器有一个FSMIE位，当闪存周期完成时，它会触发SMI。如果攻击者已经破坏了SMM并且能够在固件获取软件设置FGO位之前设置FSMIE位，那么攻击者将在SMI生成后控制系统，并能够修改FDATAX寄存器的内容。因此，固件获取软件将从FDATAX中读取伪造的值，无法获得BIOS区域的原始镜像。[图19-6](ch19.xhtml#ch19fig06)演示了这种攻击。
- en: '![image](../images/19fig06.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig06.jpg)'
- en: '*Figure 19-6: Subverting a software BIOS acquisition via SMI*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-6：通过SMI破坏软件BIOS获取*'
- en: Before the reader sets the FGO bit ➋ in the flash control register, the attacker
    writes 1 to the register’s FSMIE bit ➊. Once the cycle is finished and data is
    written back to the FDATAX registers, an SMI is triggered and the attacker receives
    control ➌. Then the attacker modifies the contents of the FDATAX registers ➍ to
    conceal the attack on the BIOS firmware. After regaining control, the reader will
    receive fake data ➎ and won’t detect the compromised firmware.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取器设置闪存控制寄存器中的FGO位➋之前，攻击者将1写入寄存器的FSMIE位➊。一旦循环结束并且数据被写回到FDATAX寄存器，触发了SMI，攻击者获得了控制权➌。接着，攻击者修改FDATAX寄存器的内容➍，以掩盖对BIOS固件的攻击。恢复控制后，读取器将收到伪造的数据➎，并且不会检测到固件被篡改。
- en: This attack demonstrates that the software approach doesn’t provide a 100 percent
    reliable solution for firmware acquisition. In the following section, we’ll discuss
    the hardware approach to obtaining system firmware for forensic analysis. Conducting
    forensic analysis by physically attaching a device to the SPI flash avoids the
    possibility of the attack depicted in [Figure 19-6](ch19.xhtml#ch19fig06).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该攻击展示了软件方法无法提供100%可靠的固件获取解决方案。在接下来的部分中，我们将讨论获取系统固件用于取证分析的硬件方法。通过物理连接设备到SPI闪存来进行取证分析，避免了[图19-6](ch19.xhtml#ch19fig06)中描述的攻击可能性。
- en: '**The Hardware Approach to Firmware Acquisition**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**固件获取的硬件方法**'
- en: To guarantee we have acquired the actual BIOS image stored on the SPI flash
    and not one already compromised by an attacker, we can use the hardware approach.
    With this approach, we physically attach a device to the SPI flash memory and
    read its contents directly. This is the best solution because it’s more trustworthy
    than the software approach. As an extra benefit, this approach allows us to obtain
    other firmware stored on the SPI flash, like ME and GBE firmware, which might
    not be accessible with the software approach due to restrictions enforced by the
    SPI controller.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们获取的是存储在SPI闪存上的实际BIOS镜像，而不是已经被攻击者篡改的版本，我们可以使用硬件方法。采用这种方法时，我们会将设备物理连接到SPI闪存，并直接读取其内容。这是最好的解决方案，因为它比软件方法更可靠。额外的好处是，这种方法还允许我们获取存储在SPI闪存上的其他固件，例如ME和GBE固件，而这些固件可能由于SPI控制器的限制无法通过软件方法访问。
- en: 'The SPI bus on modern systems allows multiple masters to communicate with the
    SPI flash. For instance, on systems based on the Intel chipset, there are generally
    three masters: the host CPU, the Intel ME, and GBE. These three masters have different
    access rights to different regions of the SPI flash. On most modern platforms,
    the host CPU can’t read and write to the SPI flash region containing the Intel
    ME and GBE firmware.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现代系统中的SPI总线允许多个主设备与SPI闪存通信。例如，在基于英特尔芯片组的系统中，通常有三个主设备：主机CPU、英特尔ME和GBE。这三个主设备对SPI闪存的不同区域具有不同的访问权限。在大多数现代平台上，主机CPU无法读写包含英特尔ME和GBE固件的SPI闪存区域。
- en: '[Figure 19-7](ch19.xhtml#ch19fig07) demonstrates a typical setup for obtaining
    the BIOS firmware image by reading the SPI flash.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[图19-7](ch19.xhtml#ch19fig07)展示了通过读取SPI闪存获取BIOS固件镜像的典型设置。'
- en: '![image](../images/19fig07.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig07.jpg)'
- en: '*Figure 19-7: A typical setup for dumping the SPI flash image*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-7：用于转储SPI闪存镜像的典型设置*'
- en: In order to read data from the flash memory, we need an additional device, called
    an *SPI programmer*, which we physically attach to the SPI flash memory chip on
    the target system. We also connect the SPI programmer via a USB or UART interface
    to a host that we use to obtain the BIOS firmware image. We would then run some
    particular software on the programmer to make it read data from the flash memory
    chip and transfer the data to the analyst’s computer. This might be proprietary
    software provided with a particular SPI programmer, or it could be an open source
    solution such as the Flashrom tool, which is discussed later in “[Reading the
    SPI Flash with the FT2232 Mini Module](ch19.xhtml#ch19lev2sec10)” on [page 377](ch19.xhtml#page_377).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从闪存中读取数据，我们需要一个额外的设备，叫做*SPI编程器*，我们将其物理连接到目标系统上的SPI闪存芯片。我们还通过USB或UART接口将SPI编程器连接到主机，使用主机获取BIOS固件镜像。然后，我们会在编程器上运行一些特定的软件，使其从闪存芯片读取数据并将数据传输到分析师的计算机。这些软件可能是随特定SPI编程器提供的专有软件，或者它也可能是一个开源解决方案，比如稍后在“[使用FT2232
    Mini模块读取SPI闪存](ch19.xhtml#ch19lev2sec10)”中讨论的Flashrom工具，[第377页](ch19.xhtml#page_377)有详细介绍。
- en: '***Reviewing a Lenovo ThinkPad T540p Case Study***'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***回顾联想ThinkPad T540p案例分析***'
- en: The hardware approach is even more specific than the software approach. It requires
    you to consult platform documentation in order to learn what kind of flash memory
    the platform uses to store the firmware and where the firmware is physically located
    in the system. In addition, there are numerous flash programming devices for specific
    hardware we could use to read the contents of the flash memory. We won’t discuss
    the various hardware and software options available for system firmware acquisition,
    because there are simply too many. Instead, we’ll go over one of the possible
    ways to dump firmware from the Lenovo ThinkPad T540p using the FT2232 SPI programmer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件方法比软件方法更为具体。它要求你查阅平台文档，以了解平台使用什么样的闪存来存储固件，以及固件在系统中的物理位置。此外，还有许多专用于特定硬件的闪存编程设备，我们可以使用它们来读取闪存的内容。由于可供选择的硬件和软件选项实在太多，我们不会讨论系统固件获取的各种方法。相反，我们将介绍使用
    FT2232 SPI 编程器从联想 ThinkPad T540p 提取固件的一种可能方法。
- en: We chose this SPI programmer because of its relatively low price (about $30)
    and flexibility, as well as our prior experience of working with it. As we’ve
    mentioned, there are many solutions, and each has its unique features, advantages,
    and drawbacks.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择这款 SPI 编程器是因为它的价格相对较低（大约 30 美元）且具有灵活性，此外我们之前也有使用过它的经验。正如我们所提到的，市面上有许多解决方案，每种方案都有其独特的特点、优点和缺点。
- en: '**DEDIPROG SF100 ISP IC PROGRAMMER**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**DEDIPROG SF100 ISP IC 编程器**'
- en: Another device we’d like to mention is the Dediprog SF100 ISP IC Programmer
    (shown in [Figure 19-8](ch19.xhtml#ch19fig08)). It’s popular in the security research
    community, supports many SPI flashes, and offers extensive functionality. Minnowboard,
    an open source reference board for hardware and firmware developers, has a good
    tutorial on using Dediprog for updating firmware at *[https://minnowboard.org/tutorials/updating-firmware-via-spi-flash-programmer/](https://minnowboard.org/tutorials/updating-firmware-via-spi-flash-programmer/).*
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想提到另一款设备，即 Dediprog SF100 ISP IC 编程器（如[图 19-8](ch19.xhtml#ch19fig08)所示）。它在安全研究社区中非常流行，支持许多
    SPI 闪存，并提供广泛的功能。Minnowboard 是一个开源参考板，供硬件和固件开发者使用，提供了一个关于如何使用 Dediprog 更新固件的好教程，教程地址为
    *[https://minnowboard.org/tutorials/updating-firmware-via-spi-flash-programmer/](https://minnowboard.org/tutorials/updating-firmware-via-spi-flash-programmer/)。*
- en: '![image](../images/19fig08.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig08.jpg)'
- en: '*Figure 19-8: A Dediprog SF100 ISP IC Programmer*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-8：Dediprog SF100 ISP IC 编程器*'
- en: '***Locating the SPI Flash Memory Chip***'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定位 SPI 闪存芯片***'
- en: Let’s start by physically reading the firmware image from the Lenovo ThinkPad
    T540p platform. First, to dump the system firmware from the target system, we
    need to find where, on the main board, the SPI flash memory chips are located.
    To do this, we consulted the Hardware Maintenance Manual (*[https://thinkpads.com/support/hmm/hmm_pdf/t540p_w540_hmm_en_sp40a26003_01.pdf](https://thinkpads.com/support/hmm/hmm_pdf/t540p_w540_hmm_en_sp40a26003_01.pdf)*)
    for this laptop model and took apart the target system’s hardware. In [Figures
    19-9](ch19.xhtml#ch19fig09) and [19-10](ch19.xhtml#ch19fig10), you can see the
    locations of the two flash memory chips. [Figure 19-9](ch19.xhtml#ch19fig09) shows
    a complete image of the system board. The SPI flash chips are located in the highlighted
    area.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从物理上读取联想 ThinkPad T540p 平台的固件镜像开始。首先，要从目标系统中提取系统固件，我们需要找出在主板上 SPI 闪存芯片的位置。为此，我们查阅了这款笔记本型号的硬件维护手册
    (*[https://thinkpads.com/support/hmm/hmm_pdf/t540p_w540_hmm_en_sp40a26003_01.pdf](https://thinkpads.com/support/hmm/hmm_pdf/t540p_w540_hmm_en_sp40a26003_01.pdf)*)，并拆开了目标系统的硬件。在[图
    19-9](ch19.xhtml#ch19fig09)和[图 19-10](ch19.xhtml#ch19fig10)中，你可以看到两个闪存芯片的位置。[图
    19-9](ch19.xhtml#ch19fig09)展示了系统板的完整图像，SPI 闪存芯片位于高亮区域。
- en: '**WARNING**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Don’t repeat the actions described in this section unless you are 100 percent
    sure of what you’re doing. An invalid or incorrect configuration of the tools
    may brick the target system.*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*除非你百分之百确定自己在做什么，否则不要重复本节中描述的操作。工具配置无效或不正确可能会使目标系统无法启动。*'
- en: '![image](../images/19fig09.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig09.jpg)'
- en: '*Figure 19-9: The Lenovo ThinkPad T540p mainboard with SPI flash modules*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-9：联想 ThinkPad T540p 主板与 SPI 闪存模块*'
- en: '[Figure 19-10](ch19.xhtml#ch19fig10) zooms in on the region highlighted in
    [Figure 19-9](ch19.xhtml#ch19fig09) so you can see the SPI flash chips more clearly.
    This laptop model uses two SOIC-8 flash memory modules to store the firmware—a
    64Mb (8MB) one and a 32Mb (4MB) one. This is a very popular solution on many modern
    desktops and laptops.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[图19-10](ch19.xhtml#ch19fig10)放大了[图19-9](ch19.xhtml#ch19fig09)中突出显示的区域，使你能更清楚地看到SPI闪存芯片。这款笔记本型号使用了两个SOIC-8闪存模块来存储固件——一个是64Mb（8MB），另一个是32Mb（4MB）。这是许多现代桌面和笔记本电脑中非常流行的解决方案。'
- en: '![image](../images/19fig10.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig10.jpg)'
- en: '*Figure 19-10: The location of the SPI flash modules on the mainboard of the
    laptop*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-10：笔记本主板上SPI闪存模块的位置*'
- en: Since two separate chips are used to store the system firmware, we’ll need to
    dump the contents of both. We’ll obtain the final firmware image by concatenating
    the images from the two flash memory chips into a single file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了两个独立的芯片来存储系统固件，我们需要将两个芯片的内容都转储。我们通过将两个闪存芯片的映像拼接成一个文件来获得最终的固件映像。
- en: '***Reading the SPI Flash with the FT2232 Mini Module***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用FT2232迷你模块读取SPI闪存***'
- en: Once we’ve identified the physical location of the chips, we can connect the
    SPI programmer’s pins to the flash module on the system board. The datasheet (*[http://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf](http://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf)*)
    for the FT2232H Mini Module shows us which pins we should use to attach the device
    to the memory chip. [Figure 19-11](ch19.xhtml#ch19fig11) demonstrates the layout
    of the pins for both the FT2232H Mini Module and the SPI flash chip.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了芯片的物理位置，就可以将SPI编程器的引脚连接到系统板上的闪存模块。FT2232H迷你模块的技术资料（*[http://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf](http://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf)*）向我们展示了应使用哪些引脚将设备连接到存储芯片。[图19-11](ch19.xhtml#ch19fig11)展示了FT2232H迷你模块和SPI闪存芯片的引脚布局。
- en: 'The FT2232H has two sets of pins, corresponding to two channels: Channel 2
    and Channel 3\. You may use either channel to read the contents of the SPI flash
    memory. In our experiment, we use Channel 3 to attach the FT2232H to the SPI memory
    chip. [Figure 19-11](ch19.xhtml#ch19fig11) shows which of the FT2232H pins we
    connected to the corresponding pins of the SPI flash memory chip.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: FT2232H有两组引脚，对应两个通道：通道2和通道3。你可以使用任一通道读取SPI闪存的内容。在我们的实验中，我们使用通道3将FT2232H连接到SPI存储芯片。[图19-11](ch19.xhtml#ch19fig11)展示了我们如何将FT2232H的引脚连接到SPI闪存芯片的相应引脚。
- en: 'In addition to connecting the FT2232H to the memory chip, we need to configure
    it to operate in USB bus-powered mode. The FT2232H Mini Module supports two modes
    of operating: *USB bus-powered* and *self-powered*. In the bus-powered mode, the
    mini module takes power from the USB bus it is attached to, and in self-powered
    mode, the power is provided independently of the USB bus connection.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将FT2232H连接到存储芯片，我们还需要将其配置为在USB总线供电模式下工作。FT2232H迷你模块支持两种工作模式：*USB总线供电*和*自供电*。在总线供电模式下，迷你模块从其连接的USB总线获取电源，而在自供电模式下，电源独立于USB总线连接提供。
- en: '![image](../images/19fig11.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig11.jpg)'
- en: '*Figure 19-11: The layout of the pins for the FT2232H Mini Module and SPI flash
    chip*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-11：FT2232H迷你模块和SPI闪存芯片的引脚布局*'
- en: To help us attach our SPI programmer to the SPI chip module, we use a SOIC-8
    clip, as shown in [Figure 19-12](ch19.xhtml#ch19fig12). This clip allows us to
    easily connect the mini module’s pins to the corresponding pins of the flash memory
    chip.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们将SPI编程器连接到SPI芯片模块，我们使用了一个SOIC-8夹具，如[图19-12](ch19.xhtml#ch19fig12)所示。这个夹具让我们能够轻松地将迷你模块的引脚连接到闪存芯片的相应引脚。
- en: '![image](../images/19fig12.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig12.jpg)'
- en: '*Figure 19-12: Attaching the FT2232H Mini Module to the SPI flash chip*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-12：将FT2232H迷你模块连接到SPI闪存芯片*'
- en: Once we connect all the components, we can read the contents of the SPI flash
    chip. To do this, we use an open source tool called *Flashrom* (*[https://www.flashrom.org/Flashrom](https://www.flashrom.org/Flashrom)*).
    This tool was developed specifically for identifying, reading, writing, verifying,
    and erasing flash chips. It supports a large number of flash chips and works with
    many different SPI programmers, including the FT2232H Mini Module.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们连接了所有组件，就可以读取 SPI 闪存芯片的内容。为此，我们使用一个名为 *Flashrom*（* [https://www.flashrom.org/Flashrom](https://www.flashrom.org/Flashrom)
    *）的开源工具。该工具专门用于识别、读取、写入、验证和擦除闪存芯片。它支持大量闪存芯片，并与许多不同的 SPI 编程器兼容，包括 FT2232H Mini
    模块。
- en: '[Listing 19-1](ch19.xhtml#ch19list01) shows the results of running Flashrom
    to read the contents of both SPI flash chips on the Lenovo ThinkPad T540p platform.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 19-1](ch19.xhtml#ch19list01) 显示了在 Lenovo ThinkPad T540p 平台上运行 Flashrom
    以读取两个 SPI 闪存芯片内容的结果。'
- en: '[PRE1]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 19-1: Dumping SPI flash images with the Flashrom tool*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 19-1：使用 Flashrom 工具导出 SPI 闪存镜像*'
- en: First, we run Flashrom to dump the contents of the first SPI flash chip, passing
    it a programmer type and port number as parameters ➊. The type we specify, 2232H,
    corresponds to our FT2232H Mini Module, and port B corresponds to Channel 3, the
    one we’re using to connect to the SPI flash chip. The `--read` parameter tells
    Flashrom to read the contents of the SPI flash memory into the *dump_1.bin* file.
    Once we run the tool, it displays the type of the detected SPI flash chip—in our
    case, Macronix MX25L6473E ➋. Once Flashrom finishes reading the flash memory,
    it outputs a confirmation ➌.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们运行 Flashrom 来导出第一个 SPI 闪存芯片的内容，并将编程器类型和端口号作为参数传递 ➊。我们指定的类型为 2232H，对应我们的
    FT2232H Mini 模块，而端口 B 对应通道 3，即我们用来连接 SPI 闪存芯片的端口。`--read` 参数告诉 Flashrom 读取 SPI
    闪存内存的内容并保存到 *dump_1.bin* 文件中。一旦我们运行该工具，它会显示检测到的 SPI 闪存芯片类型——在我们的例子中是 Macronix
    MX25L6473E ➋。等 Flashrom 完成读取闪存内存后，它会输出确认信息 ➌。
- en: After reading the first flash chip, we reconnect the clip to the second chip
    and run Flashrom again to dump the second chip’s contents into the *dump_2.bin*
    file. Once this operation is done, we create a complete image of the firmware
    by concatenating the two dumped images ➍.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取完第一个闪存芯片后，我们重新连接夹具到第二个芯片，并再次运行 Flashrom，将第二个芯片的内容导出到 *dump_2.bin* 文件中。完成此操作后，我们通过将两个导出的镜像拼接在一起，创建了一个完整的固件镜像
    ➍。
- en: We have now dumped a complete, trustworthy image of the firmware. Even if the
    BIOS is already infected and an attacker attempts to thwart our firmware acquisition,
    we’ll still obtain the actual firmware code and data. Next, we’ll analyze it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功导出了完整且可信的固件镜像。即使 BIOS 已经被感染且攻击者试图阻止我们获取固件，我们仍然能够获得实际的固件代码和数据。接下来，我们将对其进行分析。
- en: '**Analyzing the Firmware Image with UEFITool**'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 UEFITool 分析固件镜像**'
- en: Once we obtain a firmware image from the target system’s SPI flash, we can analyze
    it. In this section, we’ll cover the basic components of platform firmware, such
    as firmware volumes, volume files, and the sections necessary for understanding
    the layout of the UEFI firmware in the flash image. Then we’ll focus on the most
    important steps in the forensic analysis of firmware.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从目标系统的 SPI 闪存中获取了固件镜像，我们就可以对其进行分析。在本节中，我们将介绍平台固件的基本组件，如固件卷、卷文件以及理解闪存镜像中
    UEFI 固件布局所必需的各个部分。然后我们将重点关注固件取证分析中最重要的步骤。
- en: '**NOTE**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this section, we’ll provide high-level descriptions rather than detailed
    definitions of the data structures used, since this is too large a subject and
    in-depth coverage is beyond the scope of this chapter. We will, however, provide
    references to documentation containing definitions and the layout of the data
    structures if you’d like further information.*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本节中，我们将提供高层次的描述，而不是详细的结构定义，因为这涉及的内容过于庞大，深度探讨超出了本章的范围。不过，如果您需要更多信息，我们会提供参考文献，其中包含定义和数据结构布局。*'
- en: We’re going to revisit UEFITool (*[https://github.com/LongSoft/UEFITool/](https://github.com/LongSoft/UEFITool/)*),
    the open source tool for parsing, extracting, and modifying UEFI firmware images
    that was introduced in [Chapter 15](ch15.xhtml#ch15), to demonstrate theoretical
    concepts with the real firmware image we acquired in the previous section. The
    ability to look inside the firmware image to browse and extract various components
    is incredibly useful for forensic analysis. This tool doesn’t require installation;
    once downloaded, the application is ready to be executed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新审视UEFITool（*[https://github.com/LongSoft/UEFITool/](https://github.com/LongSoft/UEFITool/)*），这是一款用于解析、提取和修改UEFI固件映像的开源工具，已经在[第15章](ch15.xhtml#ch15)中介绍过，接下来我们将用前一节获得的真实固件映像来演示理论概念。查看固件映像内部并浏览提取不同组件的能力对于取证分析非常有用。此工具无需安装；下载后即可直接运行。
- en: '***Getting to Know the SPI Flash Regions***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***了解SPI闪存区域***'
- en: Before we look at the firmware image, we need to go over how the information
    stored on the SPI flash is organized. Generally, modern platforms based on the
    Intel chipset SPI flash consist of several regions. Each region is dedicated to
    storing firmware for a specific device available in the platform; for instance,
    UEFI BIOS firmware, Intel ME firmware, and Intel GBE (integrated LAN device) firmware
    are each stored in their own region. [Figure 19-13](ch19.xhtml#ch19fig13) demonstrates
    the layout of several regions of the SPI flash.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看固件映像之前，我们需要了解SPI闪存上存储的信息是如何组织的。通常，基于英特尔芯片组的现代平台SPI闪存由多个区域组成。每个区域专门用于存储平台中特定设备的固件；例如，UEFI
    BIOS固件、英特尔ME固件和英特尔GBE（集成LAN设备）固件都分别存储在自己的区域中。[图19-13](ch19.xhtml#ch19fig13)展示了SPI闪存的几个区域布局。
- en: '![image](../images/19fig13.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig13.jpg)'
- en: '*Figure 19-13: Regions of the SPI flash image*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-13：SPI闪存映像的区域*'
- en: The SPI flash in modern systems supports up to six regions, including the *descriptor*
    region, where flash images always start. The descriptor region contains information
    about the SPI flash’s layout; that is, it provides the chipset with information
    about the other regions present on the SPI flash, such as their location and access
    rights. The descriptor region also dictates the access rights of each master in
    the system that can communicate with the SPI flash controller. Multiple masters
    are able to communicate with the controller at the same time. We can find the
    complete layout of the descriptor region, including definitions of all the data
    structures located in it, in the chipset specification for the target platform.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现代系统中的SPI闪存支持最多六个区域，包括*描述符*区域，闪存映像总是从该区域开始。描述符区域包含有关SPI闪存布局的信息；即它向芯片组提供关于SPI闪存上其他区域的信息，如它们的位置和访问权限。描述符区域还决定了系统中每个主机与SPI闪存控制器通信的访问权限。多个主机可以同时与控制器通信。我们可以在目标平台的芯片组规格中找到描述符区域的完整布局，包括其中所有数据结构的定义。
- en: In this chapter, we’re primarily interested in the BIOS region, which contains
    firmware executed by the CPU at the reset vector. We can extract the location
    of the BIOS region from the descriptor region. Normally, BIOS is the last region
    on the SPI flash, and it constitutes the main target for forensic analysis.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们主要关注的是BIOS区域，该区域包含CPU在复位向量时执行的固件。我们可以从描述符区域提取BIOS区域的位置。通常，BIOS是SPI闪存中的最后一个区域，也是取证分析的主要目标。
- en: Let’s take a look at the different regions of the SPI image that we acquired
    with the hardware approach.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们通过硬件方法获得的SPI映像的不同区域。
- en: '***Viewing SPI Flash Regions with UEFITool***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用UEFITool查看SPI闪存区域***'
- en: First, launch UEFITool and select **File**▸**Open image file**. Then select
    the file with the SPI image you want to analyze—we’ve supplied one you can use
    with the book’s resources at *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*.
    [Figure 19-14](ch19.xhtml#ch19fig14) shows the result of this operation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动UEFITool并选择**文件**▸**打开映像文件**。然后选择包含您要分析的SPI映像的文件——我们已为您提供一个，可以通过书本资源使用，网址是*[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*。[图19-14](ch19.xhtml#ch19fig14)展示了此操作的结果。
- en: '![image](../images/19fig14.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig14.jpg)'
- en: '*Figure 19-14: Browsing SPI flash regions in UEFITool*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-14：在UEFITool中浏览SPI闪存区域*'
- en: 'When the firmware image loads, UEFITool automatically parses it and provides
    this information in a tree-like structure. In [Figure 19-14](ch19.xhtml#ch19fig14),
    the tool identified that the firmware image is from a system based on the Intel
    chipset ➊ with only four SPI regions: descriptor, ME, GbE, and BIOS. If we select
    the BIOS region in the Structure window, we can see information about it in the
    Information window. UEFITool shows the following items describing the region:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当固件映像加载时，UEFITool 会自动解析它，并以树状结构提供这些信息。在[图 19-14](ch19.xhtml#ch19fig14)中，工具识别到该固件映像来自基于英特尔芯片组的系统➊，并且只有四个
    SPI 区域：描述符、ME、GbE 和 BIOS。如果我们在结构窗口中选择 BIOS 区域，就可以在信息窗口中看到有关它的信息。UEFITool 显示以下描述该区域的项：
- en: '**Offset** ➋ The offset of the region from the beginning of the SPI flash image'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**偏移量** ➋ 区域相对于 SPI 闪存映像开始位置的偏移量'
- en: '**Full size** ➌ The size of the region in bytes'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整大小** ➌ 区域的字节大小'
- en: '**Memory address** ➍ The address of the region mapped into the physical memory'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存地址** ➍ 映射到物理内存的区域地址'
- en: '**Compressed** ➎ Whether the region contains compressed data'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**压缩** ➎ 区域是否包含压缩数据'
- en: The tool provides a convenient method for extracting individual regions (and
    any other object shown in the structure window) from the SPI image and saving
    them in a separate file, as shown in [Figure 19-15](ch19.xhtml#ch19fig15).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具提供了一种方便的方法，从 SPI 映像中提取单个区域（以及结构窗口中显示的任何其他对象）并将其保存为单独的文件，如[图 19-15](ch19.xhtml#ch19fig15)所示。
- en: '![image](../images/19fig15.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig15.jpg)'
- en: '*Figure 19-15: Extracting a BIOS region and saving it as a separate file*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-15：提取 BIOS 区域并将其保存为单独的文件*'
- en: To extract and save a region, right-click the region and select **Extract as
    is . . .** in the context menu. The tool will then show a regular dialog that
    lets you choose where you want to save your new file. Once you’ve done this, check
    the location you chose to confirm that the operation was successful.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取并保存一个区域，右键点击该区域并在上下文菜单中选择**按原样提取 . . .**。然后工具会显示一个常规对话框，让你选择要保存新文件的位置。完成后，检查所选位置以确认操作是否成功。
- en: '***Analyzing the BIOS Region***'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析 BIOS 区域***'
- en: Once we’ve identified the location of the BIOS region, we can proceed with our
    analysis. At a high level, the BIOS region is organized into *firmware volumes*,
    which are basic storage repositories for data and code. The exact definition of
    the firmware volume is provided in the EFI Firmware Volume Specification (*[https://www.intel.com/content/www/us/en/architecture-and-technology/unified-extensible-firmware-interface/efi-firmware-file-volume-specification.html](https://www.intel.com/content/www/us/en/architecture-and-technology/unified-extensible-firmware-interface/efi-firmware-file-volume-specification.html)*).
    Every volume starts with a header that provides the necessary volume attributes,
    such as the type of the volume filesystem, the volume size, and the checksum.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了 BIOS 区域的位置，就可以开始分析了。从高层次来看，BIOS 区域被组织成*固件卷*，它们是数据和代码的基本存储库。固件卷的具体定义见于
    EFI 固件卷规范（*[https://www.intel.com/content/www/us/en/architecture-and-technology/unified-extensible-firmware-interface/efi-firmware-file-volume-specification.html](https://www.intel.com/content/www/us/en/architecture-and-technology/unified-extensible-firmware-interface/efi-firmware-file-volume-specification.html)*）。每个卷都以一个头部开始，提供必要的卷属性，例如卷文件系统类型、卷大小和校验和。
- en: Let’s examine the firmware volumes available in the BIOS we’ve acquired. If
    we double-left-click the BIOS region in the UEFITool window (as in [Figure 19-15](ch19.xhtml#ch19fig15)),
    we get a list of firmware volumes available, as shown in [Figure 19-16](ch19.xhtml#ch19fig16).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们获取的 BIOS 中可用的固件卷。如果我们在 UEFITool 窗口中双击 BIOS 区域（如[图 19-15](ch19.xhtml#ch19fig15)所示），我们会看到一个可用的固件卷列表，如[图
    19-16](ch19.xhtml#ch19fig16)所示。
- en: '![image](../images/19fig16.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig16.jpg)'
- en: '*Figure 19-16: Browsing the firmware volumes available in the BIOS region*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-16：浏览 BIOS 区域中可用的固件卷*'
- en: There are four firmware volumes available in our BIOS region, and you’ll also
    notice two regions marked *Padding*. The padding regions don’t belong to any of
    the firmware volumes but rather represent empty space between them, filled with
    either 0x00 or 0xff values depending on the erase polarity of the SPI flash. Erase
    polarity determines values written to flash memory for erase operation. If erase
    polarity is 1, then erased bytes of the flash memory are set to the values of
    0xff; if erase polarity is 0, then erased bytes are set to 0x00\. As a result,
    when erase polarity is 1, the padding regions (the empty space) consists of 0xff
    values.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的BIOS区域中有四个固件卷，你还会注意到有两个区域标记为*填充*。填充区域不属于任何固件卷，而是表示它们之间的空白区域，填充的值为0x00或0xff，具体取决于SPI闪存的擦除极性。擦除极性决定写入闪存的擦除操作的值。如果擦除极性为1，则擦除的闪存字节会被设置为0xff的值；如果擦除极性为0，则擦除的闪存字节会被设置为0x00的值。因此，当擦除极性为1时，填充区域（空白区域）由0xff值构成。
- en: 'In the information tab to the right of the volumes in [Figure 19-16](ch19.xhtml#ch19fig16),
    we can see the attributes of the selected volume. Here are some of the important
    fields:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图19-16](ch19.xhtml#ch19fig16)中卷的右侧信息标签中，我们可以看到所选卷的属性。以下是一些重要的字段：
- en: '**Offset** ➊ The offset of the firmware volume from the beginning of the SPI
    image.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**偏移量** ➊ 固件卷相对于SPI映像起始位置的偏移量。'
- en: '**Signature** ➋ The signature of the firmware volume in the header. This field
    is used to identify volumes in the BIOS regions.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**签名** ➋ 固件卷头部的签名。此字段用于识别BIOS区域中的卷。'
- en: '**Filesystem GUID** ➌ The identifier of the filesystem used in the firmware
    volume. This Globally Unique Identifier (GUID) is displayed as the name of the
    volume in the structure window. If the GUID is documented, UEFITool displays its
    human-readable name (such as EfiFirmwareFileSystemGuid in [Figure 19-16](ch19.xhtml#ch19fig16))
    instead of the hexadecimal value.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件系统GUID** ➌ 固件卷中使用的文件系统的标识符。此全球唯一标识符（GUID）显示为结构窗口中卷的名称。如果GUID已被记录，UEFITool将显示其人类可读的名称（如[图19-16](ch19.xhtml#ch19fig16)中的EfiFirmwareFileSystemGuid），而不是十六进制值。'
- en: '**Header size** ➍ The size of the firmware volume header. The volume data follows
    the header.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**头部大小** ➍ 固件卷头部的大小。卷数据位于头部之后。'
- en: '**Body size** ➎ The size of the firmware volume body—that is, the size of the
    data stored in the volume.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**主体大小** ➎ 固件卷体的大小——即存储在该卷中的数据大小。'
- en: '**Getting to Know the Firmware Filesystem**'
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**了解固件文件系统**'
- en: The firmware volumes are organized as a filesystem, the type of which is indicated
    in a filesystem GUID in the firmware header. The filesystem most frequently used
    in firmware volumes is the *firmware filesystem (FFS)*, defined in the EFI FFS
    specification, but firmware volumes also use other filesystems, such as FAT32
    or NTFS. We’ll focus on the FFS as it is the most common.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 固件卷被组织为文件系统，其类型在固件头中的文件系统GUID中指明。固件卷中最常用的文件系统是*固件文件系统（FFS）*，该文件系统在EFI FFS规范中定义，但固件卷也使用其他文件系统，如FAT32或NTFS。我们将重点讨论FFS，因为它是最常见的。
- en: 'The FFS stores all the files in the root directory and contains no provision
    for any directory hierarchy. According to the EFI FFS specification, each file
    has an associated type, located in that file’s header, that describes the data
    stored in that file. Here is a list of some frequently encountered file types
    that may be useful in forensic analysis:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: FFS将所有文件存储在根目录中，并且不提供任何目录层次结构。根据EFI FFS规范，每个文件都有一个与之关联的类型，位于该文件的头部，描述存储在该文件中的数据。以下是一些在取证分析中可能有用的常见文件类型：
- en: '***EFI_FV_FILETYPE_RAW*** A raw file—no assumptions should be made about the
    data stored in the file.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_FV_FILETYPE_RAW*** 一个原始文件——对于文件中存储的数据不应做任何假设。'
- en: '***EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE*** A file that contains an encapsulated
    firmware volume. Even though FFS has no provision for directory hierarchy, we
    can use this file type to create a tree-like structure by encapsulating firmware
    modules in files.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_FV_FILETYPE_FIRMWARE_VOLUME_IMAGE*** 一个包含封装固件卷的文件。尽管FFS没有为目录层次结构提供规定，但我们可以使用此文件类型通过将固件模块封装在文件中来创建类似树形结构。'
- en: '***EFI_FV_FILETYPE_SECURITY_CORE*** A file with code and data that is executed
    at the Security (SEC) phase of the boot process. The SEC phase is the very first
    phase of the UEFI boot process.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_FV_FILETYPE_SECURITY_CORE*** 一个包含代码和数据的文件，在启动过程的安全（SEC）阶段执行。SEC阶段是UEFI启动过程的第一个阶段。'
- en: '***EFI_FV_FILETYPE_PEI_CORE*** An executable file that initiates the Pre-EFI
    Initialization (PEI) phase of the boot process. The PEI phase follows the SEC
    phase.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_FV_FILETYPE_PEI_CORE*** 是一个可执行文件，用于启动引导过程中的预 EFI 初始化（PEI）阶段。PEI 阶段紧随
    SEC 阶段之后。'
- en: '***EFI_FV_FILETYPE_PEIM*** The PEI modules, which are files with code and data
    executed at the PEI phase.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_FV_FILETYPE_PEIM*** 是 PEI 模块，它是包含代码和数据的文件，在 PEI 阶段执行。'
- en: '***EFI_FV_FILETYPE_DXE_CORE*** An executable file that initiates the *Driver
    Execution Environment* (*DXE)* phase of the boot process. The DXE phase follows
    the PEI phase.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_FV_FILETYPE_DXE_CORE*** 是一个可执行文件，用于启动引导过程中的 *驱动程序执行环境*（*DXE*）阶段。DXE
    阶段紧随 PEI 阶段之后。'
- en: '***EFI_FV_FILETYPE_DRIVER*** An executable file launched at the DXE phase.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_FV_FILETYPE_DRIVER*** 是在 DXE 阶段启动的可执行文件。'
- en: '***EFI_FV_FILETYPE_COMBINED_PEIM_DRIVER*** A file with code and data that can
    be executed at both the PEI and DXE phases.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_FV_FILETYPE_COMBINED_PEIM_DRIVER*** 是一个包含代码和数据的文件，可以在 PEI 和 DXE 阶段都执行。'
- en: '***EFI_FV_FILETYPE_APPLICATION*** A UEFI application, which is an executable
    that can be launched at the DXE phase.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_FV_FILETYPE_APPLICATION*** 是一个 UEFI 应用程序，它是一个可以在 DXE 阶段启动的可执行文件。'
- en: '***EFI_FV_FILETYPE_FFS_PAD*** A padding file.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_FV_FILETYPE_FFS_PAD*** 是一个填充文件。'
- en: Unlike the typical filesystems used in operating systems, where files have human-readable
    filenames, FFS files are identified by GUIDs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与操作系统中常见的文件系统不同，操作系统中文件具有可读的文件名，而 FFS 文件通过 GUID 进行标识。
- en: '**Getting to Know File Sections**'
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**了解文件部分**'
- en: Most firmware files stored in the FFS consist of a single part or multiple discrete
    parts, called *sections* (although some files, such as *EFI_FV_FILETYPE_RAW* files,
    don’t contain any sections).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数存储在 FFS 中的固件文件由单一部分或多个独立部分组成，称为 *部分*（尽管某些文件，如 *EFI_FV_FILETYPE_RAW* 文件，可能不包含任何部分）。
- en: 'There are two types of sections: leaf sections and encapsulation sections.
    *Leaf sections* directly contain data, the type of which is determined by a section
    type attribute in the section header. *Encapsulation sections* contain file sections,
    which may contain either leaf sections or encapsulation sections. This means that
    one encapsulation section can contain a nested encapsulation section.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的部分：叶部分和封装部分。*叶部分* 直接包含数据，其类型由部分头中的部分类型属性决定。*封装部分* 包含文件部分，这些文件部分可能包含叶部分或封装部分。这意味着一个封装部分可以包含嵌套的封装部分。
- en: 'The following list describes some types of leaf sections:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表描述了一些类型的叶部分：
- en: '***EFI_SECTION_PE32*** Contains a PE image.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_SECTION_PE32*** 包含一个 PE 映像。'
- en: '***EFI_SECTION_PIC*** Contains position-independent code (PIC).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_SECTION_PIC*** 包含位置无关代码（PIC）。'
- en: '***EFI_SECTION_TE*** Contains a Terse Executable (TE) image.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_SECTION_TE*** 包含一个简洁可执行（TE）映像。'
- en: '***EFI_SECTION_USER_INTERFACE*** Contains a user interface string. It is typically
    used to store a human-readable name for the file, in addition to the file GUID.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_SECTION_USER_INTERFACE*** 包含一个用户界面字符串。它通常用于存储文件的可读名称，以及文件的 GUID。'
- en: '***EFI_SECTION_FIRMWARE_VOLUME_IMAGE*** Contains an encapsulated firmware image.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_SECTION_FIRMWARE_VOLUME_IMAGE*** 包含一个封装的固件映像。'
- en: 'And here are a couple of the encapsulation sections defined in the FFS specification:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 FFS 规范中定义的几个封装部分：
- en: '***EFI_SECTION_COMPRESSION*** Contains compressed file sections.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_SECTION_COMPRESSION*** 包含压缩的文件部分。'
- en: '***EFI_SECTION_GUID_DEFINED*** Encapsulates other sections with respect to
    an algorithm that is identified by the section GUID. This type is used for signed
    sections, for example.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '***EFI_SECTION_GUID_DEFINED*** 根据由部分 GUID 标识的算法封装其他部分。此类型通常用于签名部分，例如。'
- en: These objects constitute the contents of the UEFI firmware on modern platforms.
    A forensic analyst must account for every component of the firmware, whether it
    is a section with executable code, like PE32, TE or PIC, or a data file with nonvolatile
    variables.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象构成了现代平台上的 UEFI 固件内容。法证分析员必须考虑固件的每个组成部分，无论它是具有可执行代码的部分，如 PE32、TE 或 PIC，还是包含非易失性变量的数据文件。
- en: To better understand the concepts presented here, see [Figure 19-17](ch19.xhtml#ch19fig17),
    which demonstrates the location of the `CpuInitDxe` driver in the firmware volume.
    This driver is responsible for CPU initialization at the DXE phase. We’ll go from
    the bottom to the top in the FFS hierarchy in order to describe its location in
    the firmware image.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这里介绍的概念，请参见 [图 19-17](ch19.xhtml#ch19fig17)，它展示了 `CpuInitDxe` 驱动程序在固件卷中的位置。该驱动程序负责在
    DXE 阶段初始化 CPU。我们将从 FFS 层次结构的底部开始，描述它在固件映像中的位置。
- en: '![image](../images/19fig17.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig17.jpg)'
- en: '*Figure 19-17: The location of the `CpuInitDxe` driver in the BIOS region*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-17：`CpuInitDxe`驱动程序在BIOS区域中的位置*'
- en: The driver’s executable image is located in the PE32 image section ➐. This section,
    along with other sections that contain the driver name ➑, version ➒, and dependencies
    ➏, are located in the file with the GUID `{62D171CB-78CD-4480-8678-C6A2A797A8DE}`
    ➎. The file is part of the encapsulated firmware volume ➍ stored in the compressed
    section ➌. The compressed section is located in the `{9E21FD93-9C72-4C15-8C4B-E77F1DB2D792}`
    file ➋ of the firmware volume image type, which is stored in the top-level firmware
    volume ➊.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序的可执行镜像位于PE32镜像区段➐中。这个区段与其他包含驱动程序名称➑、版本➒和依赖关系➏的区段一起，位于文件中，文件的GUID为`{62D171CB-78CD-4480-8678-C6A2A797A8DE}`➎。该文件是封装固件卷➍的一部分，存储在压缩区段➌中。压缩区段位于固件卷镜像类型中的`{9E21FD93-9C72-4C15-8C4B-E77F1DB2D792}`文件➋，该文件存储在顶级固件卷➊中。
- en: This example is primarily intended to demonstrate the hierarchy of objects that
    constitute the UEFI firmware, but this is just one possible approach to parsing
    it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例主要是为了展示构成UEFI固件的对象层次结构，但这仅仅是解析固件的一种可能方法。
- en: Now that we know how the BIOS region is organized, we’ll be able to navigate
    its hierarchy and search for various objects stored in the BIOS firmware.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了BIOS区域是如何组织的，我们就能浏览其层次结构，搜索存储在BIOS固件中的各种对象。
- en: '**Analyzing the Firmware Image with Chipsec**'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Chipsec分析固件镜像**'
- en: In this section, we’ll discuss firmware forensic analysis with the platform
    security assessment framework Chipsec (*[https://github.com/chipsec/](https://github.com/chipsec/)*),
    introduced in [Chapter 15](ch15.xhtml#ch15). In this section, we’ll explore the
    tool’s architecture in more detail; then, we’ll analyze some firmware, providing
    a few examples that demonstrate Chipsec’s functionality and utility.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论使用平台安全评估框架Chipsec进行固件法医分析（* [https://github.com/chipsec/](https://github.com/chipsec/)
    *），该框架在[第15章](ch15.xhtml#ch15)中介绍。在本节中，我们将更详细地探讨该工具的架构；然后，我们将分析一些固件，提供几个示例来展示Chipsec的功能和实用性。
- en: The tool provides a number of interfaces for accessing platform hardware resources,
    like physical memory, PCI registers, NVRAM variables, and the SPI flash. These
    interfaces are very useful to forensic analysts, and we’ll look at them more seriously
    later in this section.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具提供了多种接口来访问平台硬件资源，如物理内存、PCI寄存器、NVRAM变量和SPI闪存。这些接口对法医分析师非常有用，我们将在本节稍后更深入地探讨这些接口。
- en: Follow the installation guide in the Chipsec manual (*[https://github.com/chipsec/chipsec/blob/master/chipsec-manual.pdf](https://github.com/chipsec/chipsec/blob/master/chipsec-manual.pdf)*)
    to install and set up the tool. The manual also covers a multitude of functionality
    that you can use, but in this section, we’re focusing only on Chipsec’s forensic
    analysis capabilities.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照Chipsec手册中的安装指南（* [https://github.com/chipsec/chipsec/blob/master/chipsec-manual.pdf](https://github.com/chipsec/chipsec/blob/master/chipsec-manual.pdf)
    *）进行安装和设置。手册还涵盖了许多您可以使用的功能，但在本节中，我们仅关注Chipsec的法医分析功能。
- en: '***Getting to Know the Chipsec Architecture***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***了解Chipsec架构***'
- en: '[Figure 19-18](ch19.xhtml#ch19fig18) shows the tool’s high-level architecture.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[图19-18](ch19.xhtml#ch19fig18)展示了该工具的高层架构。'
- en: '![image](../images/19fig18.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/19fig18.jpg)'
- en: '*Figure 19-18: The Chipsec tool’s architecture*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-18：Chipsec工具的架构*'
- en: At the bottom, we can see modules that provide access to system resources, such
    as memory-mapped IO address ranges, PCI configuration space registers, and physical
    memory. These are platform-dependent modules implemented as kernel-mode drivers
    and EFI native code. (Currently, Chipsec provides kernel-mode drivers for Windows,
    Linux, and macOS.) Most of the modules are written in C and are intended to execute
    in kernel mode or in the EFI shell.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，我们可以看到提供访问系统资源的模块，如内存映射I/O地址范围、PCI配置空间寄存器和物理内存。这些是平台相关的模块，作为内核模式驱动程序和EFI本地代码实现。（目前，Chipsec为Windows、Linux和macOS提供了内核模式驱动程序。）大多数模块是用C语言编写的，旨在内核模式或EFI
    Shell中执行。
- en: '**NOTE**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The UEFI Shell is a UEFI application that provides a command line interface
    for firmware, allowing us to launch UEFI applications and execute commands. We
    can use the UEFI Shell to retrieve information on the platform, view and modify
    boot manager variables, load UEFI drivers, and more.*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*UEFI Shell 是一个UEFI应用程序，它提供了一个固件的命令行界面，允许我们启动UEFI应用程序并执行命令。我们可以使用UEFI Shell来检索平台信息，查看和修改启动管理器变量，加载UEFI驱动程序等等。*'
- en: On top of these low-level OS-dependent components is an OS-independent abstraction
    layer called OS Helper, comprising a number of modules that hide an OS-specific
    API for communicating with kernel-mode components from the rest of the application.
    The modules located at this level are implemented in Python. At the bottom, these
    modules interface with the kernel-mode components; at the top, they provide an
    OS-independent interface for another component, the hardware abstraction layer
    (HAL).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些低级依赖于操作系统的组件之上，是一个名为OS Helper的操作系统独立抽象层，它由多个模块组成，隐藏了与内核模式组件通信的操作系统特定API。这些位于该层的模块是用Python实现的。在底层，这些模块与内核模式组件进行交互；在顶部，它们为另一个组件——硬件抽象层（HAL）提供操作系统独立的接口。
- en: 'The HAL further abstracts the platform’s low-level concepts, like the PCI configuration
    registers and model-specific registers (MSRs), and it provides an interface for
    the Chipsec components located at the levels immediately above it: *Chipsec Main*
    and *Chipsec Util*. The HAL is also written in Python and relies on OSHelper to
    access the platform-specific hardware resources.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: HAL进一步抽象了平台的低级概念，如PCI配置寄存器和特定型号寄存器（MSRs），并为位于其上层的Chipsec组件提供接口：*Chipsec Main*和*Chipsec
    Util*。HAL同样是用Python编写的，并依赖于OSHelper来访问平台特定的硬件资源。
- en: The two remaining components, located at the top of the architecture, provide
    the main functionality available to users. The first interface, Chipsec Main,
    is available through the *chipsec_main.py* Python script in the tool’s root folder.
    It allows us to execute tests that check the security configuration of certain
    platform aspects, run PoCs to test for the presence of vulnerabilities in system
    firmware, and more. The second interface, Chipsec Util, is available through the
    *chipsec_util.py* script. We can use it to run individual commands and access
    platform hardware resources to read the SPI flash image, dump the UEFI NVRAM variables,
    and so on.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的两个组件位于架构的顶部，提供了用户可以使用的主要功能。第一个接口，Chipsec Main，通过工具根文件夹中的*chipsec_main.py*
    Python脚本提供。它允许我们执行测试，检查平台某些方面的安全配置，运行PoC测试以检查系统固件中的漏洞等。第二个接口，Chipsec Util，通过*chipsec_util.py*脚本提供。我们可以使用它来运行单独的命令，并访问平台硬件资源，读取SPI闪存镜像、转储UEFI
    NVRAM变量等。
- en: We’re primarily interested in the Chipsec Util interface because it provides
    rich functionality for working with UEFI firmware.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要关注Chipsec Util接口，因为它提供了丰富的功能，用于处理UEFI固件。
- en: '***Analyzing Firmware with Chipsec Util***'
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Chipsec Util分析固件***'
- en: 'You can find out the commands provided by Chipsec Util by running the *chipsec_util.py*
    script, located in the root directory of the tool’s repository, without specifying
    any arguments. Generally, commands are grouped into modules based on the platform
    hardware resources they work with. Here are some of the most useful modules:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行位于工具仓库根目录下的*chipsec_util.py*脚本，而不指定任何参数，来查找Chipsec Util提供的命令。通常，命令会根据它们操作的硬件资源被分组到不同的模块中。以下是一些最有用的模块：
- en: acpi Implements commands for working with *Advanced Configuration and Power
    Interface* tables.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: acpi 实现了与*高级配置与电源接口*表格相关的命令。
- en: cpu Implements commands related to the CPU, such as reading configuration registers
    and obtaining information about the CPU.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: cpu 实现了与CPU相关的命令，如读取配置寄存器和获取CPU信息。
- en: spi Implements a number of commands for working with the SPI flash, like reading,
    writing, and erasing data. There is also an option for disabling BIOS write protection
    on systems with unlocked write protection (as discussed in [Chapter 16](ch16.xhtml#ch16)).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: spi 实现了一些用于操作SPI闪存的命令，如读取、写入和擦除数据。还可以选择在解锁写保护的系统上禁用BIOS写保护（如[第16章](ch16.xhtml#ch16)中所讨论的）。
- en: uefi Implements commands for parsing UEFI firmware (the SPI flash BIOS region)
    to extract executables, NVRAM variables, and the like.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: uefi 实现了用于解析UEFI固件（SPI闪存BIOS区域）的命令，以提取可执行文件、NVRAM变量等。
- en: We can run `chipsec_util.py` command_name, where command_name is the name of
    the command we want to learn about, to output a description and usage information
    for that command. For instance, [Listing 19-2](ch19.xhtml#ch19list02) displays
    the output of `chipsec_util.py spi`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行`chipsec_util.py` command_name，其中command_name是我们想了解的命令名称，来输出该命令的描述和使用信息。例如，[列表19-2](ch19.xhtml#ch19list02)显示了`chipsec_util.py
    spi`的输出。
- en: '[PRE2]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 19-2: Description of and usage information for the `spi` module*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表19-2：`spi`模块的描述和使用信息*'
- en: This is useful when we want to know the supported options for commands with
    self-describing names, like `info`, `read`, `write`, `erase`, or `disable-wp`
    ➊. In the upcoming examples, we’ll primarily use the `spi` and `uefi` commands
    to acquire and unpack a firmware image.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要了解具有自描述名称的命令的支持选项时，像 `info`、`read`、`write`、`erase` 或 `disable-wp` ➊ 这样的命令就非常有用。在接下来的示例中，我们将主要使用
    `spi` 和 `uefi` 命令来获取并解包固件镜像。
- en: '**Dumping and Parsing the SPI Flash Image**'
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**转储与解析 SPI 闪存镜像**'
- en: 'First we’ll look at `spi`, which allows us to perform firmware acquisition.
    This command uses the software approach to dumping the contents of an SPI flash.
    To obtain an image of the SPI flash, we can run the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们来看一下 `spi`，它允许我们执行固件获取操作。这个命令使用软件方法来转储 SPI 闪存的内容。要获取 SPI 闪存的镜像，我们可以运行以下命令：
- en: '[PRE3]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: where path_to_file is a path to the location where we want to save the SPI image.
    Upon successful execution of this command, this file will contain the flash image.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `path_to_file` 是我们希望保存 SPI 镜像的位置的路径。成功执行此命令后，该文件将包含闪存镜像。
- en: 'Now that we have the SPI flash image, we can parse it and extract useful information
    using the `decode` command (it’s worth mentioning that the `decode` command by
    itself may be used to parse an SPI flash image obtained through the hardware method
    of firmware acquisition), like so:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了 SPI 闪存镜像，可以使用 `decode` 命令解析它并提取有用的信息（值得一提的是，`decode` 命令本身也可以用来解析通过硬件固件获取方法获得的
    SPI 闪存镜像），像这样：
- en: '[PRE4]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'where path_to_file points to a file with an SPI flash image. Chipsec will parse
    and extract data stored in the flash image and store it in a directory. We can
    also perform this task with the `uefi` command and `decode` option, like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `path_to_file` 指向一个包含 SPI 闪存镜像的文件。Chipsec 将解析并提取存储在闪存镜像中的数据，并将其存储在一个目录中。我们也可以使用
    `uefi` 命令和 `decode` 选项来执行这个任务，像这样：
- en: '[PRE5]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once we successfully execute the command, we obtain a set of objects extracted
    from the image, such as executable files, data files with NVRAM variables, and
    file sections.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们成功执行命令，我们将获得从镜像中提取的一组对象，如可执行文件、包含 NVRAM 变量的数据文件以及文件部分。
- en: '**Dumping UEFI NVRAM Variables**'
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**转储 UEFI NVRAM 变量**'
- en: Now we’ll use Chipsec to enumerate and extract UEFI variables from the SPI flash
    image. In [Chapter 17](ch17.xhtml#ch17), we briefly covered how to use `chipsec
    uefi var-list` to extract NVRAM variables. UEFI Secure Boot relies on NVRAM variables
    to store configuration data like its Secure Boot policy value, platform key, key
    exchange keys, and `db` and `dbx` data. Running this command will produce a list
    of all the UEFI NVRAM variables stored in the firmware image, along with their
    content and attributes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用 Chipsec 枚举并从 SPI 闪存镜像中提取 UEFI 变量。在[第17章](ch17.xhtml#ch17)中，我们简要介绍了如何使用
    `chipsec uefi var-list` 提取 NVRAM 变量。UEFI 安全启动依赖 NVRAM 变量来存储配置数据，如其安全启动策略值、平台密钥、密钥交换密钥，以及
    `db` 和 `dbx` 数据。运行此命令将生成一个包含固件镜像中所有 UEFI NVRAM 变量的列表，以及它们的内容和属性。
- en: These are just a few commands out of the Chipsec tool’s rich arsenal. A comprehensive
    list of all Chipsec use cases would require a book of its own, but if you’re interested
    in the tool, we suggest checking out its documentation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是 Chipsec 工具丰富功能中的一部分命令。Chipsec 所有用例的全面列表可能需要一本书的篇幅，但如果你对这个工具感兴趣，我们建议查看其文档。
- en: This concludes our analysis of a firmware image with Chipsec. After executing
    these commands, we get the extracted contents of the firmware image. The next
    step in forensic analysis would be to analyze the extracted components individually,
    using tools specific to the type of extracted object. For instance, you can analyze
    PEI and DXE modules using IDA Pro disassembler, while you can browse UEFI NVRAM
    variables in a hex editor.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们使用 Chipsec 分析固件镜像的过程。执行这些命令后，我们获得了固件镜像的提取内容。法医分析的下一步是使用特定于提取对象类型的工具单独分析这些提取的组件。例如，你可以使用
    IDA Pro 反汇编器分析 PEI 和 DXE 模块，而可以在十六进制编辑器中浏览 UEFI NVRAM 变量。
- en: This list of Chipsec commands serves as a good starting point for further exploration
    of UEFI firmware. We encourage you to play with this tool and refer to the manual
    to learn its other capabilities and features in order to deepen your knowledge
    of firmware forensic analysis.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这份 Chipsec 命令列表为进一步探索 UEFI 固件提供了一个良好的起点。我们鼓励你玩一下这个工具，并参考手册了解它的其他功能和特性，以便加深你对固件法医分析的理解。
- en: '**Conclusion**'
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: 'In this chapter, we discussed important approaches to UEFI firmware forensic
    analysis: acquiring firmware, and parsing and extracting information from a UEFI
    firmware image.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 UEFI 固件取证分析的重要方法：获取固件、解析固件镜像以及从 UEFI 固件镜像中提取信息。
- en: We discussed two different ways to acquire firmware—the software approach and
    the hardware approach. The software approach is convenient, but it doesn’t provide
    a completely trustworthy way of obtaining a firmware image from the target system.
    For this reason, we recommend the hardware approach, despite its higher difficulty.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了两种获取固件的不同方式——软件方法和硬件方法。软件方法方便，但它并不能提供一种完全可信的方式来从目标系统获取固件镜像。因此，尽管硬件方法更为困难，我们还是推荐使用硬件方法。
- en: 'We also demonstrated how to use two open source tools indispensable to analyzing
    and reverse engineering SPI flash images: UEFITool and Chipsec. UEFITool provides
    functionality for browsing, modifying, and extracting forensic data from an SPI
    flash image, and Chipsec is useful for performing many operations required in
    forensic analysis. The use of Chipsec also reveals how easily an attacker can
    modify the firmware image with a malicious payload, and so we expect interest
    in firmware forensics to significantly increase in the security industry.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还演示了如何使用两个在分析和逆向工程 SPI 闪存镜像时不可或缺的开源工具：UEFITool 和 Chipsec。UEFITool 提供了浏览、修改和从
    SPI 闪存镜像中提取取证数据的功能，而 Chipsec 对于执行取证分析所需的许多操作非常有用。使用 Chipsec 还展示了攻击者如何轻松地通过恶意负载修改固件镜像，因此我们预计固件取证在安全行业中的关注度将显著增加。
