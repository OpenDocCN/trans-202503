- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3'
- en: SOFTWARE DEVELOPMENT MODELS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发模型**
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: You don’t write great code by following a fixed set of rules for every project.
    For some projects, hacking out a few hundred lines of code might be all you need
    to produce a great program. Other projects, however, could involve millions of
    code lines, hundreds of project engineers, and several layers of management or
    other support personnel; in these cases, the software development process you
    use will greatly affect the project’s success.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会通过对每个项目都遵循一套固定的规则来编写出伟大的代码。对于某些项目，可能只需要编写几百行代码就能生产出一个优秀的程序。然而，其他项目可能涉及到数百万行代码，成百上千的项目工程师，以及几层管理或其他支持人员；在这些情况下，你所使用的软件开发过程将极大地影响项目的成功。
- en: In this chapter, we’ll look at various development models and when to use them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论各种开发模型以及何时使用它们。
- en: '**3.1 The Software Development Life Cycle**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.1 软件开发生命周期**'
- en: 'During its life, a piece of software generally goes through eight phases, collectively
    known as the *Software Development Life Cycle (SDLC)*:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件的生命周期中，一般会经历八个阶段，统称为*软件开发生命周期（SDLC）*：
- en: Product conceptualization
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产品构思
- en: Requirement development and analysis
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需求开发与分析
- en: Design
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计
- en: Coding (implementation)
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码（实现）
- en: Testing
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试
- en: Deployment
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署
- en: Maintenance
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 维护
- en: Retirement
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退役
- en: Let’s look at each phase in turn.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一看看每个阶段。
- en: '**Product conceptualization**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**产品构思**'
- en: A customer or manager develops an idea for some software and creates a business
    case justifying its development.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 客户或经理为某个软件构思一个想法，并创建一个业务案例，证明其开发的合理性。
- en: Often, a nonengineer envisions a need for the software and approaches a company
    or individual who can implement it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个非工程师会设想出对软件的需求，并寻求能够实现它的公司或个人。
- en: '**Requirement development and analysis**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**需求开发与分析**'
- en: Once you have a product concept, the product requirements must be outlined.
    Project managers, stakeholders, and clients (users) meet to discuss and formalize
    what the software system must do to satisfy everyone. Of course, users will want
    the software to do everything under the sun. Project managers will temper this
    expectation based on the available resources (for example, programmers), estimated
    development times, and costs. Other stakeholders might include venture capitalists
    (others financing the project), regulatory agencies (for example, the Nuclear
    Regulatory Commission if you’re developing software for a nuclear reactor), and
    marketing personnel who might provide input on the design to make it saleable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了产品构思，就必须制定产品需求。项目经理、利益相关者和客户（用户）会面，讨论并明确软件系统必须完成的任务，以满足各方需求。当然，用户希望软件能够做到任何事情。项目经理会根据可用资源（例如程序员）、估算的开发时间和成本来调整这一预期。其他利益相关者可能包括风险投资家（为项目提供资金的人）、监管机构（例如，如果你正在开发核反应堆的软件，可能需要核监管委员会的审批），以及可能为设计提供意见以使其具备销售潜力的市场人员。
- en: 'By meeting, discussing, negotiating, and so on, the interested parties develop
    requirements based on questions like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过会议、讨论、谈判等，相关方根据以下问题来制定需求：
- en: For whom is the system intended?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统是为谁设计的？
- en: What inputs should be provided to the system?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统应该提供什么输入？
- en: What output should the system produce (and in what format)?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统应该产生什么样的输出（以及以何种格式）？
- en: What types of calculations will be involved?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会涉及到什么类型的计算？
- en: If there is a video display, what screen layouts should the system use?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有视频显示，系统应该使用什么屏幕布局？
- en: What are the *expected* response times between input and output?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*预期*的输入与输出响应时间应该是多少？'
- en: From this discussion, the developers will put together the *System Requirements
    Specification (SyRS)* document, which specifies all the major requirements for
    hardware, software, and so on. Then the program management and system analysts
    use the SyRS to produce a *Software Requirements Specification (SRS)* document,^([1](ch19_footnote.xhtml#ch03fn1))
    which is the end result of this phase. As a rule, the SRS is for internal consumption
    only, used by the software development team, whereas the SyRS is an external document
    for customer reference. The SRS extracts all the software requirements from the
    SyRS and expands on them. [Chapter 10](ch10.xhtml) discusses these two documents
    in detail (see “[The System Requirements Specification Document](ch10.xhtml#lev-10.3)”
    on [page 193](ch10.xhtml#page_193) and “The Software Requirements Specification
    Document” on [page 194](ch10.xhtml#page_194)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一讨论，开发人员将编写*系统需求规格说明书（SyRS）*，该文档规定了所有硬件、软件等的主要需求。接着，项目管理和系统分析师使用SyRS来生成*软件需求规格说明书（SRS）*，^([1](ch19_footnote.xhtml#ch03fn1))这是本阶段的最终成果。一般而言，SRS是仅供内部使用的，由软件开发团队使用，而SyRS则是供客户参考的外部文档。SRS从SyRS中提取所有软件需求并进行扩展。[第10章](ch10.xhtml)详细讨论了这两份文档（请参见[《系统需求规格说明书》](ch10.xhtml#lev-10.3)，第193页和[《软件需求规格说明书》](ch10.xhtml#lev-10.4)，第194页）。
- en: '**Design**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计**'
- en: 'The software design architect (software engineer) uses the software requirements
    from the SRS to prepare the *Software Design Description (SDD)*. The SDD provides
    some combination, but not necessarily all, of the following items:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计架构师（软件工程师）根据SRS中的软件需求准备*软件设计描述（SDD）*。SDD提供了以下项目的某些组合，但不一定是全部：
- en: A system overview
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统概述
- en: Design goals
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计目标
- en: The data (via a *data dictionary*) and databases used
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的数据（通过*数据字典*）和数据库
- en: A data flow (perhaps using data flow diagrams)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据流（可能使用数据流图表示）
- en: An interface design (how the software interacts with other software and the
    software’s users)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口设计（软件如何与其他软件以及软件用户进行交互）
- en: Any standards that must be followed
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须遵循的任何标准
- en: Resource requirements (for example, memory, CPU cycles, and disk capacity)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源需求（例如，内存、CPU周期和磁盘容量）
- en: Performance requirements
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能要求
- en: Security requirements
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性要求
- en: See [Chapter 11](ch11.xhtml) for further details on the contents of the SDD.
    The design documentation becomes the input for the next phase, coding.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 详见[第11章](ch11.xhtml)，了解SDD内容的更多细节。设计文档将成为下一阶段——编码的输入。
- en: '**Coding**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码**'
- en: 'Coding—writing the actual software—is the step most familiar and fun to software
    engineers. A software engineer uses the SDD to write the software. *WGC5: Great
    Coding* will be dedicated to this phase.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '编码——编写实际的软件——是软件工程师最熟悉且最有趣的步骤。软件工程师使用SDD来编写软件。*WGC5: 伟大的编码*将专门讨论这一阶段。'
- en: '**Testing**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试**'
- en: 'In this phase, the code is tested against the SRS to ensure the product solves
    the problems listed in the requirements. There are several components in this
    phase, including:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，代码将针对SRS进行测试，以确保产品解决了需求中列出的所有问题。此阶段包含几个组成部分，包括：
- en: '**Unit testing** Checks the individual statements and modules in the program
    to verify that they behave as expected. This actually occurs during coding but
    logically belongs in the testing phase.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试** 检查程序中的各个语句和模块，以验证它们是否按预期工作。虽然这通常发生在编码阶段，但从逻辑上来说，它属于测试阶段。'
- en: '**Integration testing** Verifies that the individual subsystems in the software
    work well together. This also occurs during the coding phase, usually toward the
    end.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试** 验证软件中的各个子系统能够很好地协同工作。这个过程通常发生在编码阶段，通常是在接近尾声时。'
- en: '**System testing** Validates the implementation; that is, it shows that the
    software correctly implements the SRS.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统测试** 验证实现情况；即，证明软件正确地实现了SRS（软件需求规格说明书）。'
- en: '**Acceptance testing** Demonstrates to the customer that the software is suitable
    for its intended purpose.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**验收测试** 向客户展示软件是否适合其预期用途。'
- en: '*WGC6: Testing, Debugging, and Quality Assurance* will cover the testing phase
    in detail. [Chapter 12](ch12.xhtml) describes the software test case and software
    test procedure documents you’ll create to guide testing.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*WGC6: 测试、调试与质量保证*将详细讨论测试阶段。[第12章](ch12.xhtml)描述了你将在测试过程中创建的软件测试用例和软件测试程序文档。'
- en: '**Deployment**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**部署**'
- en: The software product is delivered to the customer(s) for their use.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 软件产品交付给客户用于使用。
- en: '**Maintenance**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**维护**'
- en: Once customers begin using the software, chances are fairly high that they’ll
    discover defects and request new functionality. During this time, the software
    engineers might fix the defects or add the new enhancements, and then deploy new
    versions of the software to the customer(s).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户开始使用软件，他们很有可能会发现缺陷并要求新增功能。在这个过程中，软件工程师可能会修复缺陷或增加新的功能，然后将软件的新版本部署给客户。
- en: '**Retirement**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**退休**'
- en: Eventually in some software’s life, development will cease, perhaps because
    the development organization decides to no longer support or work on it, it is
    replaced by a different version, the company making it goes out of business, or
    the hardware on which it runs becomes obsolete.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，在一些软件的生命周期中，开发将停止，可能是因为开发组织决定不再支持或开发它，或者它被不同版本的程序取代，或者开发它的公司倒闭，或者它运行的硬件变得过时。
- en: '**3.2 The Software Development Model**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.2 软件开发模型**'
- en: 'A *software development model* describes how all the phases of the SDLC combine
    in a software project. Different models are suitable for different circumstances:
    some emphasize certain phases and deemphasize others, some repeat various phases
    throughout the development process, and others skip some phases entirely.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件开发模型* 描述了 SDLC（软件开发生命周期）中的所有阶段如何在软件项目中结合。不同的模型适用于不同的情况：有些强调某些阶段，忽略其他阶段；有些在开发过程中反复进行各个阶段；还有一些完全跳过某些阶段。'
- en: There are eight well-respected software development models and dozens, if not
    hundreds, of variations of these eight models in use today. Why don’t developers
    just pick one popular model and use it for everything? The reason, as noted in
    [Chapter 1](ch01.xhtml), is that practices that work well for individuals or small
    teams don’t *scale up* well to large teams. Likewise, techniques that work well
    for large projects rarely *scale down* well for small projects. This book will
    focus on techniques that work well for individuals, but great programmers must
    be able to work within all design processes if they want to be great programmers
    on projects of all sizes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有八种受人尊敬的软件开发模型，且这些模型有数十种，甚至数百种变体在使用。那么，为什么开发者不选择一个流行的模型并用它来处理所有的事情呢？如[第1章](ch01.xhtml)中所述，适合个人或小团队的做法，在大型团队中不一定能有效扩展；同样，适合大项目的技术，往往不能很好地适用于小项目。本书将重点讨论适合个人的技术，但伟大的程序员必须能够在所有设计过程中工作，才能在各类项目中成为优秀的程序员。
- en: In this chapter I’ll describe the eight major software models—their advantages,
    disadvantages, and how to apply them appropriately. However, in practice, none
    of these models can be followed blindly or expected to guarantee a successful
    project. This chapter also discusses what great programmers can do to work around
    the limitations of a model forced on them and still produce great code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将描述八种主要的软件模型——它们的优缺点，以及如何正确地应用它们。然而，在实践中，这些模型中的任何一个都不能盲目跟随，也不能指望它们保证项目的成功。本章还将讨论伟大的程序员如何在被迫使用某个模型的局限性时，依然能够绕开这些限制，编写出优秀的代码。
- en: '***3.2.1 The Informal Model***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.1 非正式模型***'
- en: 'The Informal model describes software development with minimal process or discipline:
    no formal design, no formal testing, and a lack of project management. This model
    was originally known as *hacking*^([2](ch19_footnote.xhtml#ch03fn2)) and those
    who engaged in it were known as *hackers*. However, as those original hackers
    grew up and gained experience, education, and skills, they proudly retained the
    name “hacker,” so the term no longer refers to an inexperienced or unskilled programmer.^([3](ch19_footnote.xhtml#ch03fn3))
    I’ll still use the term *hacking* to mean an informal coding process, but I’ll
    use *informal coder* to describe a person who engages in hacking. This will avoid
    confusion with differing definitions of *hacker*.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式模型描述了软件开发过程中的最小化流程或纪律：没有正式的设计，没有正式的测试，缺乏项目管理。这个模型最初被称为 *黑客*^([2](ch19_footnote.xhtml#ch03fn2))，那些参与其中的人被称为
    *黑客*。然而，随着这些最初的黑客成长并获得经验、教育和技能，他们自豪地保留了“黑客”这个称号，所以这个术语不再指代一个缺乏经验或技能的程序员^([3](ch19_footnote.xhtml#ch03fn3))。我仍然会使用
    *黑客* 来表示一种非正式的编码过程，但我会用 *非正式编码者* 来描述那些参与黑客行为的人。这样可以避免与“黑客”一词不同定义的混淆。
- en: In the Informal model, the programmer moves directly from product conceptualization
    to coding, “hacking away” at the program until something is working (often not
    well), rather than designing a robust, flexible, readable program.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在非正式模型中，程序员直接从产品概念化进入编码阶段，不断“敲代码”，直到程序有些许功能（通常效果不好），而不是设计一个健壮、灵活、易读的程序。
- en: 'Hacking has a few advantages: it’s fun, done independently (though certainly
    many people participate in group events like hackathons), and the programmer is
    responsible for most design decisions and for moving the project along, so they
    can often get something working faster than could a software engineer following
    a formal development process.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客技术有几个优势：它很有趣，通常是独立完成的（虽然当然许多人参与像黑客马拉松这样的团体活动），程序员负责大多数设计决策并推动项目进展，因此他们通常能够比遵循正式开发过程的软件工程师更快地让某些东西工作。
- en: The problem with the Informal model is that its conscious lack of design may
    lead to an invalid system that doesn’t do what end users want, because their requests
    weren’t considered in the requirements and software specifications—if those even
    exist—and often the software isn’t tested or documented, which makes it difficult
    for anyone other than the original programmer to use it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式模型的问题在于它有意缺乏设计，这可能导致一个无效的系统，无法满足最终用户的需求，因为他们的要求没有被考虑到需求和软件规格中——如果这些需求和规格存在的话——而且通常软件没有经过测试或文档化，这使得除原始程序员外的任何人都很难使用它。
- en: Thus, the Informal model works for small, throwaway programs intended for use
    only by the programmer who coded them. For such projects, it’s far cheaper and
    more efficient to bang out a couple hundred lines of code for limited and careful
    use than to go through the full software development process. (Unfortunately,
    some “throwaway” programs can take on a life of their own and become popular once
    users discover them. Should this happen, the program should be redesigned and
    reimplemented so it can be maintained properly.)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，非正式模型适用于那些仅供编写程序的程序员使用的小型一次性程序。对于这样的项目，编写几百行代码用于有限且谨慎的使用，比起完整的软件开发过程要便宜得多且更高效。（不幸的是，一些“一次性”程序可能会因用户的发现而获得生命，并变得流行。发生这种情况时，程序应当重新设计并重新实现，以便能够正确地维护。）
- en: Hacking is also useful for developing small prototypes, especially screen displays
    intended to demonstrate a program in development to a prospective customer. One
    sticky problem here, though, is that clients and managers may look at the prototype
    and assume that a large amount of code is already in place, meaning they may push
    to further develop the hacked code rather than start the development process from
    the beginning, which will lead to problems down the road.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客技术也有助于开发小型原型，特别是那些旨在向潜在客户展示正在开发中的程序的屏幕显示。然而，这里有一个棘手的问题，那就是客户和经理可能会查看这个原型，并假设已经有大量代码就绪，这意味着他们可能会推动进一步开发被“破解”的代码，而不是从头开始开发，这会导致未来的问题。
- en: '***3.2.2 The Waterfall Model***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.2 瀑布模型***'
- en: The Waterfall model is the granddaddy of software development models, and most
    models are a variation of it. In the Waterfall model, each step of the SDLC is
    executed sequentially from beginning to end (see [Figure 3-1](ch03.xhtml#ch3fig1)),
    with the output from each step forming the input for the next step.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 瀑布模型是软件开发模型的祖父，大多数模型都是它的变体。在瀑布模型中，SDLC的每个步骤都是按顺序从头到尾执行的（参见[图3-1](ch03.xhtml#ch3fig1)），每个步骤的输出形成下一个步骤的输入。
- en: '![image](Images/fig3-1.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig3-1.jpg)'
- en: '*Figure 3-1: The Waterfall model*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：瀑布模型*'
- en: You begin the Waterfall model by producing the SyRS. Once the system requirements
    are specified, you produce the SRS from the SyRS. When the software requirements
    are specified, you produce the SDD from the SRS. You then produce source code
    from the SDD and test the software. Then you deploy and maintain the software.
    Everything in the SLDC happens in that order, without deviation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你从生成系统需求说明书（SyRS）开始使用瀑布模型。一旦系统需求被确定，你就可以从SyRS生成软件需求说明书（SRS）。当软件需求被确定后，你可以从SRS生成软件设计文档（SDD）。接着你从SDD生成源代码并进行软件测试。然后你将部署并维护软件。SLDC中的一切都按照这个顺序进行，没有任何偏差。
- en: As the original SDLC model, the Waterfall model is usually very simple to understand
    and apply to a software development project because each step is distinct, with
    well-understood inputs and deliverables. It’s also relatively easy to review work
    performed using this model and verify that the project is on track.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为原始的SDLC模型，瀑布模型通常非常简单，容易理解并应用于软件开发项目，因为每个步骤都是独立的，且有明确的输入和输出交付物。使用该模型进行的工作也相对容易审查，并且可以验证项目是否按计划进行。
- en: 'However, the Waterfall model suffers from some huge problems. The most important
    is that it assumes that you perform each step perfectly before progressing to
    the next step, and that you’ll find errors early in one step and make repairs
    before proceeding. In reality, this is rarely the case: defects in the requirements
    or design phases are typically not caught until testing or deployment. At that
    point, it can be very expensive to back up through the system and correct everything.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，瀑布模型存在一些重大问题。最重要的一点是，它假设你在进行到下一个步骤之前会完美地执行每个步骤，并且会在某个步骤的早期发现错误并进行修复。然而，现实情况是，这种情况很少发生：需求或设计阶段的缺陷通常要到测试或部署时才会被发现。到那时，倒退到系统中并修正所有问题可能非常昂贵。
- en: Another disadvantage is that the Waterfall model doesn’t allow you to produce
    a working system for customers to review until very late in the development process.
    I can’t count the number of times I’ve shown a client static screenshots or diagrams
    of how code would work, received their buy-in, and then had them reject the running
    result. That major disconnect in expectations could have been avoided had I produced
    a working prototype of the code that would have allowed customers to experiment
    with certain aspects of the system during the requirements phase.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，瀑布模型在开发过程的很晚阶段才能提供一个可供客户评审的工作系统。我数不清有多少次，我向客户展示静态截图或代码如何工作图示，获得了他们的认可，但最终他们却拒绝了运行结果。如果我在需求阶段就制作了一个可用的代码原型，让客户能够在某些系统功能上进行实验，这种重大期望上的差距本可以避免。
- en: Ultimately, this model is very risky. Unless you can *exactly* specify what
    the system will do before you start the process, the Waterfall model is likely
    inappropriate for your project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这个模型是非常有风险的。除非你能*准确*地在开始之前定义系统将要执行的任务，否则瀑布模型很可能不适合你的项目。
- en: The Waterfall model is appropriate for small projects of, say, less than a few
    tens of thousands of code lines involving only a couple of programmers; for very
    large projects (because nothing else works at that level); or when the current
    project is similar to a previous product that employed the Waterfall model during
    development (so you can use the existing documentation as a template).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 瀑布模型适用于小型项目，例如代码行数不到几万行，且仅涉及少数几名程序员的情况；或者适用于非常大型的项目（因为在那个层级，别的模型都无法适用）；又或者当当前项目与之前使用瀑布模型开发的产品相似时（因此你可以使用现有的文档作为模板）。
- en: '***3.2.3 The V Model***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.3 V 模型***'
- en: 'The V model, shown in [Figure 3-2](ch03.xhtml#ch3fig2), follows the same basic
    steps as the Waterfall model but emphasizes the development of testing criteria
    early in the development life cycle. The V model is organized so the earlier steps,
    requirements and design, produce two sets of outputs: one for the step that follows
    and one for a parallel step during the testing phase.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: V 模型，如[图 3-2](ch03.xhtml#ch3fig2)所示，遵循与瀑布模型相同的基本步骤，但强调在开发生命周期的早期制定测试标准。V 模型的结构使得早期的步骤——需求和设计——会产生两组输出：一组用于后续步骤，另一组用于测试阶段的平行步骤。
- en: '![image](Images/fig3-2.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig3-2.jpg)'
- en: '*Figure 3-2: The V model*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：V 模型*'
- en: 'In [Figure 3-2](ch03.xhtml#ch3fig2), the items on the left side of the V link
    straight across to the items on the right side: at each design stage, the programmer
    is thinking about how to test and use the concepts being modeled. For example,
    during the *requirements and architecture* phase, the system architect designs
    the system acceptance tests that will verify that the software correctly implements
    all the requirements. During the *design* phase, the system designer implements
    the software’s unit and integration tests.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 3-2](ch03.xhtml#ch3fig2)中，V 左侧的项目直接链接到右侧的项目：在每个设计阶段，程序员都在考虑如何测试并使用正在建模的概念。例如，在*需求和架构*阶段，系统架构师设计系统验收测试，以验证软件是否正确实现了所有需求。在*设计*阶段，系统设计师实施软件的单元测试和集成测试。
- en: The big difference here from the Waterfall model is that the engineer implements
    test cases and procedures early on, so by the time coding begins, the software
    engineer can use existing test procedures to verify the code’s behavior during
    development. Known as *test-driven development (TDD)*, in this approach the programmer
    constantly runs tests throughout the development process. Continuous testing allows
    you to find bugs much sooner and makes it cheaper and faster to correct them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与瀑布模型的最大区别在于，工程师在早期就实现了测试用例和程序，因此当编码开始时，软件工程师可以利用现有的测试程序在开发过程中验证代码行为。这种方法被称为*测试驱动开发（TDD）*，在这种方法中，程序员在整个开发过程中不断进行测试。持续的测试可以让你更早发现漏洞，并使修复这些漏洞变得更加便宜和迅速。
- en: That said, the V model is far from perfect. Like its parent, the Waterfall model,
    the V model is too simple, and requires too much perfection in the early stages
    in order to prevent disasters in the later stages. For example, a defect in the
    requirements and architecture phase might not surface until system testing and
    validation, resulting in expensive backtracking through the development. For this
    reason, the V model doesn’t work well for projects whose requirements are subject
    to change throughout a product’s lifetime.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，V模型并不完美。像其母模型瀑布模型一样，V模型过于简单，并且在早期阶段要求过多的完善，以避免后期的灾难。例如，需求和架构阶段的缺陷可能直到系统测试和验证时才显现出来，导致在开发过程中需要付出昂贵的返工成本。因此，V模型并不适用于需求在产品生命周期中可能发生变化的项目。
- en: The model often encourages verification at the expense of validation. *Verification*
    ensures that a product meets certain requirements (such as its software requirements).
    It’s easy to develop tests that show the software is fulfilling requirements laid
    out in the SRS and SyRS. In contrast, *validation* shows that the product meets
    the needs of its end users. Being more open-ended, validation is more difficult
    to achieve.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型通常鼓励验证，而牺牲了验证的效果。*验证*确保产品满足特定的需求（例如软件需求）。开发测试用例来证明软件符合SRS和SyRS中列出的要求是很容易的。相比之下，*确认*证明产品满足最终用户的需求。由于更加开放，确认更难以实现。
- en: It’s difficult, for example, to test that the software doesn’t crash because
    it tries to process a `NULL` pointer. For this reason, validation tests are often
    entirely missing in the test procedures. Most test cases are requirements-driven,
    and rarely are there requirements like “no divisions by zero in this section of
    code” or “no memory leaks in this module” (these are known as *requirement gaps*;
    coming up with test cases without any requirements to base them on can be challenging,
    especially for novices).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，测试软件是否会因试图处理`NULL`指针而崩溃是困难的。因此，验证测试通常在测试程序中完全缺失。大多数测试用例是需求驱动的，像“这一段代码中没有除以零的情况”或“这个模块没有内存泄漏”等需求则很少见（这些被称为*需求缺口*；在没有任何需求依据的情况下设计测试用例可能会非常具有挑战性，尤其对于初学者来说）。
- en: '***3.2.4 The Iterative Model***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.4 迭代模型***'
- en: Sequential models like Waterfall and V rely on the assumption that specification,
    requirements, and design are all perfect before coding occurs, meaning users won’t
    discover design problems until the software is first deployed. By then it’s often
    too costly (or too late) to repair the design, correct the software, and test
    it. The Iterative model overcomes this problem by taking multiple passes over
    the development model.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 像瀑布模型和V模型这样的顺序模型假设在编码之前，规格、需求和设计都已经完美无缺，这意味着用户在软件首次部署之前不会发现设计问题。而此时，通常修复设计、修正软件并进行测试的成本已经过高（或者为时已晚）。迭代模型通过多次遍历开发模型克服了这个问题。
- en: The hallmark of the Iterative model is user feedback. The system designers start
    with a general idea of the product from the users and stakeholders and create
    a minimal set of requirements and design documentation. The coders implement and
    test this minimal implementation. The users then play with this implementation
    and provide feedback. The system designers produce a new set of requirements and
    designs based on the user feedback, and the programmers implement and test the
    changes. Finally, users are given a second version for their evaluation. This
    process repeats until the users are satisfied or the software meets the original
    goals.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代模型的标志是用户反馈。系统设计师从用户和利益相关者那里获取产品的整体构想，并创建一个最小的需求和设计文档。编码人员实施并测试这个最小实现。然后，用户体验这个实现并提供反馈。系统设计师根据用户反馈产生新的需求和设计，程序员实施并测试这些更改。最后，用户会得到第二个版本进行评估。这个过程会重复，直到用户满意或软件达成最初的目标。
- en: One big advantage of the Iterative model is that it works reasonably well when
    it’s difficult to completely specify the software’s behavior at the beginning
    of the development cycle. System architects can work from a general road map to
    design enough of the system for end users to play with and determine which new
    features are necessary. This avoids spending considerable effort producing features
    end users want implemented differently or don’t want at all.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代模型的一个大优点是，当在开发周期开始时很难完全指定软件的行为时，它依然能很好地工作。系统架构师可以从一个大致的路线图出发，设计足够的系统部分，让最终用户可以进行操作并确定哪些新功能是必要的。这避免了花费大量精力去开发那些最终用户希望以不同方式实现或根本不需要的功能。
- en: Another advantage is that the Iterative model reduces *time to market* risk.
    To get the product to market quickly, you decide on a subset of features the final
    product will have and develop those first, get the product working (in a minimalist
    fashion), and ship this *minimum viable product (MVP)*. Then, you add functionality
    to each new iteration to produce a new enhanced version of the product.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优势是，迭代模型降低了*市场时间*风险。为了快速将产品推向市场，你会决定最终产品的一部分功能并优先开发这些功能，先让产品以最简化的方式工作，并发布这个*最小可行产品
    (MVP)*。然后，在每次新迭代中添加功能，生产出新版本的增强产品。
- en: 'Advantages of the Iterative model include:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代模型的优势包括：
- en: You can achieve minimal functionality very rapidly.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以非常迅速地实现最小功能。
- en: Managing risk is easier than in sequential models because you don’t have to
    complete the entire program to determine that it won’t do the job properly.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理风险比顺序模型更容易，因为你不需要完成整个程序就能确定它不能正常工作。
- en: Managing the project as it progresses (toward completion) is easier and more
    obvious than with sequential models.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着项目的进展（接近完成），管理变得比顺序模型更容易和更明显。
- en: Changing requirements is supported.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持需求变化。
- en: Changing requirements costs less.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变需求的成本更低。
- en: Parallel development is possible with two (or more) sets of teams working on
    alternate versions.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行开发是可能的，通过两组（或更多）团队交替工作在不同版本上。
- en: 'Here are some disadvantages of the Iterative model:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是迭代模型的一些缺点：
- en: Managing the project is more work.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理项目的工作量更多。
- en: It doesn’t scale down to smaller projects very well.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不太适合规模较小的项目。
- en: It might take more resources (especially if parallel development takes place).
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能需要更多资源（特别是当进行并行开发时）。
- en: Defining the iterations might require a “grander” road map of the system (that
    is, going back to specifying all the requirements before development starts).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义迭代可能需要一个“更宏大的”系统路线图（即，在开发开始前重新指定所有需求）。
- en: There might be no limit on the number of iterations; hence, it could be impossible
    to predict when the project will be complete.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代次数可能没有限制；因此，可能无法预测项目何时完成。
- en: '***3.2.5 The Spiral Model***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.5 螺旋模型***'
- en: 'The Spiral model is also an iterative model that repeats four phases: planning,
    design, evaluation/risk analysis, and construction (see [Figure 3-3](ch03.xhtml#ch3fig3)).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 螺旋模型也是一个迭代模型，它重复四个阶段：规划、设计、评估/风险分析和构建（见[图 3-3](ch03.xhtml#ch3fig3)）。
- en: '![image](Images/fig3-3.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig3-3.jpg)'
- en: '*Figure 3-3: The Spiral model*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：螺旋模型*'
- en: 'The Spiral model is heavily risk-based: each iteration assesses the risks of
    going forward with the project. Management chooses which features to add and omit
    and which approaches to take by analyzing the risk (that is, the likelihood of
    failure).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 螺旋模型极度依赖于风险：每个迭代都会评估继续推进项目的风险。管理层通过分析风险（即失败的可能性）来选择添加和省略哪些特性，并决定采取哪些方法。
- en: The Spiral is often called a *model generator* or *meta model* because you can
    use further development models—the same type or a different one—on each spiral.
    The drawback is that the resulting model becomes specific to that project, making
    it difficult to apply to others.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 螺旋模型常被称为*模型生成器*或*元模型*，因为你可以在每个螺旋中使用进一步发展的模型——相同类型的或不同类型的。缺点是，最终的模型会变得特定于该项目，难以应用于其他项目。
- en: One key advantage of the Spiral model is that it involves end users with the
    software early and continuously during development by producing working prototypes
    on a regular basis. The end user can play with these prototypes, determine if
    development is on the right track, and redirect the development process if needed.
    This addresses one of the great shortcomings of the Waterfall and V models.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 螺旋模型的一个关键优势是，它在开发过程中通过定期生成工作原型，早期且持续地让最终用户参与进来。最终用户可以与这些原型互动，判断开发是否走在正确的轨道上，并在需要时调整开发过程。这解决了瀑布模型和V模型的一大缺陷。
- en: A drawback of this approach is that it rewards “just good enough” design. If
    the code can be written “just fast enough” or “just small enough,” further optimization
    is delayed until a later phase when it’s necessary. Similarly, testing is done
    only to a level sufficient to achieve a minimal amount of confidence in the code.
    Additional testing is considered a waste of time, money, and resources. The Spiral
    model often leads to compromises in the early work, particularly when it’s managed
    poorly, which leads to problems later in development.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是它奖励“刚刚足够好”的设计。如果代码能写得“足够快”或“足够小”，那么进一步的优化会被推迟到后期阶段，直到确有必要时才进行。类似地，测试只会进行到足以对代码有最低程度信心的程度。额外的测试被认为是浪费时间、金钱和资源。螺旋模型往往会导致在早期工作的妥协，尤其是当管理不善时，这种情况会导致开发后期出现问题。
- en: Another downside is that the Spiral model increases management complexity. This
    model is complex, so project management requires risk analysis experts. Finding
    managers and engineers with this expertise is difficult, and substituting someone
    without appropriate experience is usually a disaster.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是螺旋模型增加了管理的复杂性。这个模型本身很复杂，因此项目管理需要风险分析专家。寻找具备此类专业知识的经理和工程师很困难，且通常无法找到合适的替代人选会导致灾难性后果。
- en: The Spiral model is suitable only for large, risky projects. The effort (especially
    with respect to documentation) expended is hard to justify for low-risk projects.
    Even on larger projects, the Spiral model might cycle indefinitely, never producing
    the final product, or the budget might be completely consumed while development
    is still on an intermediate spiral.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 螺旋模型仅适用于大型、高风险项目。为低风险项目投入的工作量（尤其是在文档方面）是难以证明合理的。即便是在更大的项目中，螺旋模型可能会无限循环，最终产品迟迟无法产生，或者预算在开发仍处于中间阶段时已被完全消耗。
- en: Another concern is that engineers spend considerable time developing prototypes
    and other code needed for intermediate versions that don’t appear in the final
    software release, meaning the Spiral model often costs more than developing software
    with other methodologies.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，工程师需要花费大量时间开发原型和其他中间版本的代码，而这些代码最终并不会出现在最终的软件版本中，这意味着螺旋模型通常比使用其他方法开发软件要花费更多。
- en: 'Nevertheless, the Spiral model offers some big advantages:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，螺旋模型还是提供了一些巨大的优势：
- en: The requirements don’t need to be fully specified before the project starts;
    the model is ideal for projects with changing requirements.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目开始之前，不需要完全明确需求；螺旋模型非常适合需求不断变化的项目。
- en: It produces working code early in the development cycle.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在开发周期的早期就能产生可用的代码。
- en: It works extremely well with *rapid prototyping* (see the next section, “The
    Rapid Application Development Model”), affording customers and other stakeholders
    a good level of comfort with the application early in its development.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与*快速原型开发*（见下节“快速应用开发模型”）配合得非常好，能让客户和其他利益相关者在应用程序开发的早期就能感到安心。
- en: Development can be divided up and the riskier portions can be created early,
    reducing the overall development risk.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发可以被分成若干部分，风险较大的部分可以提前完成，从而降低整体开发风险。
- en: Because requirements can be created as they’re discovered, they are more accurate.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于需求可以在发现时就创建，因此更加准确。
- en: As in the Iterative model, functionality can be spread out over time, enabling
    the addition of new features as time/budget allows without impacting the initial
    release.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和迭代模型一样，功能可以随着时间的推移逐步展开，允许在时间或预算允许的情况下添加新功能，而不会影响初始版本的发布。
- en: '***3.2.6 The Rapid Application Development Model***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.6 快速应用开发模型***'
- en: Like the Spiral model, the Rapid Application Development (RAD) model emphasizes
    continuous interaction with users during development. Devised by James Martin,
    a researcher at IBM in the 1990s, the original RAD model divides software development
    into four phases (see [Figure 3-4](ch03.xhtml#ch3fig4)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与螺旋模型类似，快速应用开发（RAD）模型强调在开发过程中与用户的持续互动。RAD 模型由 IBM 的研究员 James Martin 在 1990 年代提出，最初的
    RAD 模型将软件开发分为四个阶段（见[图 3-4](ch03.xhtml#ch3fig4)）。
- en: '![image](Images/fig3-4.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig3-4.jpg)'
- en: '*Figure 3-4: The RAD model*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-4：RAD 模型*'
- en: '**Requirements planning** A project’s stakeholders come together to discuss
    business needs, scope, constraints, and system requirements.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**需求规划** 项目的相关方聚集在一起讨论业务需求、范围、限制和系统需求。'
- en: '**User** **design** End users interact with the development team to produce
    models and prototypes for the system (detailing inputs, outputs, and computations),
    typically using *computer-aided software engineering (CASE)* tools.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户** **设计** 终端用户与开发团队合作，制作系统模型和原型（详细说明输入、输出和计算），通常使用 *计算机辅助软件工程（CASE）* 工具。'
- en: '**Construction** The development team builds the software using tools to automatically
    generate code from the requirements and user design. Users remain involved during
    this phase, suggesting changes as the UI comes to life.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建** 开发团队利用工具从需求和用户设计中自动生成代码来构建软件。在此阶段，用户仍然参与其中，随着用户界面的逐步完善，他们会提出修改建议。'
- en: '**Cutover** The software is deployed.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**切换** 软件被部署。'
- en: RAD is more lightweight than Spiral, with fewer risk mitigation techniques and
    fairly light documentation needs, meaning it works well for small to medium-sized
    projects. Unlike other models, traditional RAD heavily depends on very-high-level
    languages (VHLLs), user interface modeling tools, complex libraries and frameworks
    of existing code, and CASE tools to automatically generate code from requirements
    and user interface models. In general, RAD is practical only when there are CASE
    tools available for the specific project problems. Today, many generic language
    systems support a high degree of automatic code generation, including Microsoft’s
    Visual Basic and Visual Studio packages, Apple’s Xcode/Interface Builder package,
    Free Pascal/Lazarus, and Embarcadero’s Delphi (Object Pascal) package.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: RAD 比螺旋模型更轻量，风险缓解技术较少，文档需求也相对较轻，这使得它更适用于中小型项目。与其他模型不同，传统的 RAD 强烈依赖于高级语言（VHLL）、用户界面建模工具、复杂的现有代码库和框架，以及
    CASE 工具来根据需求和用户界面模型自动生成代码。一般来说，RAD 只有在针对特定项目问题可用 CASE 工具时才实际可行。今天，许多通用语言系统都支持高度自动化的代码生成，包括微软的
    Visual Basic 和 Visual Studio 包、苹果的 Xcode/Interface Builder 包、Free Pascal/Lazarus
    以及 Embarcadero 的 Delphi（Object Pascal）包。
- en: 'The advantages of the RAD model are similar to those of the Spiral model:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: RAD 模型的优点与螺旋模型类似：
- en: The customer is involved with the product throughout development, resulting
    in less risk.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户在整个开发过程中都参与其中，从而降低了风险。
- en: RAD reduces development time because less time is spent writing documentation
    that must be rewritten later when the specifications inevitably change.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAD 缩短了开发时间，因为写文档的时间减少了，避免了文档在规格变更时需要重新编写的情况。
- en: The RAD model encourages the fast delivery of working code, and testing (and
    defect mitigation) is more efficient. Developers spend more time running the code,
    testing for problems.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAD 模型鼓励快速交付可运行的代码，测试（和缺陷缓解）也更加高效。开发人员将更多时间花在运行代码上，测试问题。
- en: 'Like any development model, RAD has some disadvantages as well:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何开发模型一样，RAD 也有一些缺点：
- en: RAD requires Grand Master–level software engineers who have the experience to
    short-circuit much of the heavyweight development process found in other models.
    Such resources are scarce in many organizations.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAD 需要具备大宗师级别的开发经验的软件工程师，他们能够缩短其他开发模型中冗长的开发过程。然而，这类资源在许多组织中比较稀缺。
- en: RAD requires continuous interaction with end users, which may be limited on
    many projects.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAD 需要与终端用户持续互动，这在许多项目中可能会受到限制。
- en: RAD may be difficult to schedule and control. Managers who live and die by Microsoft
    Project will find it difficult to deal with the uncertainties in the RAD model.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAD 可能很难进行调度和控制。那些依赖 Microsoft Project 的经理会发现很难应对 RAD 模型中的不确定性。
- en: Unless carefully managed, RAD can rapidly devolve into hacking. Software engineers
    might forgo formal design methodologies and just hack away at the code to make
    changes. This can be especially troublesome when end users start making suggestions
    “just to see what the result will look like.”^([4](ch19_footnote.xhtml#ch03fn4))
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果管理不当，RAD 很容易变成拼凑式编程。软件工程师可能会放弃正式的设计方法，而直接在代码上“乱改”以实现更改。当最终用户开始提出“只是为了看看结果会是什么样”这样的建议时，这种情况尤为棘手^([4](ch19_footnote.xhtml#ch03fn4))。
- en: RAD doesn’t work well for large system development.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAD 不适用于大型系统开发。
- en: '***3.2.7 The Incremental Model***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.2.7 增量模型***'
- en: The Incremental model is very similar to the Iterative model, with the main
    difference being in planning and design. In the Iterative model, the system design
    is created first and software engineers implement various pieces at each iteration;
    the initial design defines only the first piece of working code. Once the program
    is running, new features are designed and added incrementally.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 增量模型与迭代模型非常相似，主要的区别在于规划和设计。在迭代模型中，首先创建系统设计，软件工程师在每次迭代中实现不同的部分；初始设计仅定义第一段工作代码。一旦程序运行，新功能会按阶段逐步设计并添加。
- en: The Incremental model emphasizes the “keep the code working” concept. When a
    base product is operational, the development team adds a minimal amount of new
    functionality at each iteration, and the software is tested and kept functional.
    By limiting new features, the team can more easily locate and solve development
    problems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 增量模型强调“保持代码可运行”的理念。当基础产品可操作时，开发团队在每次迭代中添加最少量的新功能，并对软件进行测试并保持其可用性。通过限制新功能，团队可以更容易地定位和解决开发中的问题。
- en: The advantage of the Incremental model is that you always maintain a working
    product. The model also comes naturally to programmers, especially on small projects.
    The disadvantage is that it doesn’t consider the product’s full design in the
    beginning. Often, new features are simply hacked on to the existing design. This
    could result in problems down the road when end users request features that were
    never considered in the original design. The Incremental model is sufficient for
    small projects but doesn’t scale well to large projects, where the Iterative model
    might be a better choice.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 增量模型的优点是始终保持一个可工作的产品。该模型对程序员来说也很自然，特别是在小型项目中。缺点是，它一开始并没有考虑到产品的完整设计。通常，新的功能只是简单地加在现有设计上。当最终用户请求在原始设计中未考虑到的功能时，这可能会导致未来的问题。增量模型适用于小型项目，但对于大型项目而言，扩展性较差，此时迭代模型可能是更好的选择。
- en: '**3.3 Software Development Methodologies**'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.3 软件开发方法论**'
- en: A software development model describes *what* work is done but leaves considerable
    leeway as to *how* it is done. This section looks at some development methodologies
    and processes you can apply to many of the models just discussed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发模型描述了*做什么*工作，但在*如何*做的方面留有相当大的余地。本节将介绍一些可以应用于许多前面提到的模型的开发方法论和过程。
- en: 'The Belitsoft company blog^([5](ch19_footnote.xhtml#ch03fn5)) describes software
    methodology as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Belitsoft 公司博客^([5](ch19_footnote.xhtml#ch03fn5))描述了软件方法论如下：
- en: A system of principles, as well as a set of ideas, concepts, methods, techniques,
    and tools that define the style of software development.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一套原则体系，以及一组定义软件开发风格的理念、概念、方法、技术和工具。
- en: 'Thus, we can reduce the concept of software methodology to one word: *style*.
    There are various styles you can use when developing software.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将软件方法论的概念归结为一个词：*风格*。在开发软件时，可以使用各种风格。
- en: '***3.3.1 Traditional (Predictive) Methodologies***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.3.1 传统（预测型）方法论***'
- en: The traditional methodology is *predictive*, meaning that management predicts
    which activities will take place, when they will take place, and who will do them.
    These methodologies work hand in hand with linear/sequential development models,
    like the Waterfall or V model. You could use prediction with other models, but
    those are designed to purposely avoid the problems that predictive methodologies
    are prone to.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的方法论是*预测性的*，这意味着管理层预测哪些活动将会发生，何时发生，以及由谁来执行。这些方法论与线性/顺序的开发模型（如瀑布模型或V模型）密切配合。你可以在其他模型中使用预测，但那些模型的设计本意就是为了避免预测方法论常见的问题。
- en: Predictive methodologies fail when it’s impossible to predict changes in future
    requirements, key personnel, or economic conditions (for example, did the company
    receive the expected additional financing at some milestone in the project?).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 预测性方法论在无法预测未来需求、关键人员或经济条件变化时会失败（例如，公司是否在项目的某个里程碑时获得了预期的额外融资？）。
- en: '***3.3.2 Adaptive Methodologies***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.3.2 自适应方法论***'
- en: The Spiral, RAD, Incremental, and Iterative models came about specifically because
    it’s usually difficult to correctly predict requirements for a large software
    system. Adaptive methodologies handle these unpredictable changes in the workflow
    and emphasize short-term planning. After all, if you’re planning only 30 days
    in advance on a large project, the worst that can happen is you have to replan
    for the next 30 days; this is nowhere near the disaster you’d face in the middle
    of a large Waterfall/Predictive-based project, when a change would force you to
    resync the entire project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 螺旋模型、RAD模型、增量模型和迭代模型的出现，正是因为通常很难正确预测大型软件系统的需求。自适应方法论处理这些工作流程中的不可预测变化，并强调短期规划。毕竟，如果你只提前30天规划一个大型项目，最糟糕的情况就是你需要重新规划接下来的30天；这远没有在大型瀑布/预测性项目中出现变化时所面临的灾难性后果，那时的变化会迫使你重新同步整个项目。
- en: '***3.3.3 Agile***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.3.3 敏捷***'
- en: Agile is an incremental methodology that focuses on customer collaboration,
    short development iterations that respond to changes quickly, working software,
    and support for individuals’ contributions and interactions. The Agile methodology
    was created as an umbrella to cover several different “lightweight” (that is,
    nonpredictive) methodologies, including Extreme Programming, Scrum, Dynamic System
    Development Model (DSDM), Adaptive Software Development (ASD), Crystal, Feature-Driven
    Development (FDD), Pragmatic Programming, and others. Most of these methodologies
    are considered “Agile,” although they often cover different aspects of the software
    development process. Agile has largely proven itself on real-world projects, making
    it one of the currently most popular methodologies, so we’ll dedicate a fair amount
    of space to it here.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷是一种增量方法论，专注于客户协作、快速响应变化的短期开发迭代、可工作的软件以及支持个人的贡献和互动。敏捷方法论作为一个总的框架，涵盖了几种不同的“轻量级”（即非预测性）方法论，包括极限编程、Scrum、动态系统开发模型（DSDM）、自适应软件开发（ASD）、Crystal、特性驱动开发（FDD）、务实编程等。这些方法论中的大多数被视为“敏捷”，尽管它们通常涵盖软件开发过程的不同方面。敏捷方法论已在现实项目中得到了充分验证，成为目前最流行的方法论之一，因此我们将在这里详细介绍它。
- en: '**NOTE**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意事项**'
- en: '*For a detailed list of the principles behind Agile, see the Agile Manifesto
    at [http://agilemanifesto.org/](http://agilemanifesto.org/)*.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关敏捷背后原则的详细列表，请参阅敏捷宣言：[http://agilemanifesto.org/](http://agilemanifesto.org/)*。'
- en: '**3.3.3.1 Agile Is Incremental in Nature**'
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.3.1 敏捷具有增量性质**'
- en: Agile development is incremental, iterative, and evolutionary in nature, and
    so works best with Incremental or Iterative models (using Spiral or RAD is also
    possible). A project is broken down into tasks that a team can complete in one
    to four weeks, which is often called a *sprint*. During each sprint, the development
    team plans, creates requirements, designs, codes, unit-tests, and acceptance-tests
    the software with the new features.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷开发本质上是增量的、迭代的和进化的，因此与增量模型或迭代模型最为契合（也可以使用螺旋模型或快速应用开发（RAD）模型）。一个项目被分解为团队可以在一到四周内完成的任务，这通常被称为*sprint*。在每个sprint期间，开发团队进行规划、创建需求、设计、编码、单元测试以及接受测试新功能的软件。
- en: At the end of the sprint, the deliverable is a working piece of software that
    demonstrates the new functionality with as few defects as possible.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在sprint结束时，交付成果是一块能展示新功能、且尽可能少缺陷的可工作软件。
- en: '**3.3.3.2 Agile Requires Face-to-Face Communication**'
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.3.2 敏捷要求面对面沟通**'
- en: Throughout the sprint, a customer representative must be available to answer
    questions that arise. Without this, the development process can easily veer off
    in the wrong direction or get bogged down while the team waits for responses.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个冲刺过程中，必须有一位客户代表随时待命，回答出现的任何问题。如果没有这位代表，开发过程很容易偏离正确方向或在团队等待回复时陷入困境。
- en: Efficient communication in Agile requires a face-to-face conversation.^([6](ch19_footnote.xhtml#ch03fn6))
    When a developer demonstrates a product directly to the customer, that customer
    often raises questions that would never come up in an email or if they’d just
    tried the feature on their own. Sometimes, offhand remarks in a demo can result
    in a burst of divergent thinking that would never happen if the conversation weren’t
    in person.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷开发中的高效沟通需要面对面的交流。^([6](ch19_footnote.xhtml#ch03fn6)) 当开发人员直接向客户展示产品时，客户常常会提出一些在邮件中或自己试用功能时无法想到的问题。有时，演示中的随意评论会激发出一阵不同的思维，这种思维如果没有面对面交流是难以产生的。
- en: '**3.3.3.3 Agile Is Focused on Quality**'
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.3.3 敏捷注重质量**'
- en: Agile emphasizes various quality-enhancing techniques, such as automated unit
    testing, TDD, design patterns, pair programming, code refactoring, and other well-known
    best software practices. The idea is to produce code with as few defects as possible
    (during initial design and coding).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷强调各种提升质量的技术，如自动化单元测试、TDD、设计模式、结对编程、代码重构以及其他广为人知的最佳软件实践。其核心思想是在初始设计和编码过程中尽可能减少缺陷。
- en: '*Automated unit testing* creates a test framework that a developer can automatically
    run to verify that the software runs correctly. It’s also important for *regression
    testing*, which tests to ensure the code still works properly after new features
    have been added. Manually running regression tests is too labor-intensive, so
    it generally won’t happen.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动化单元测试*创建了一个测试框架，开发人员可以自动运行该框架来验证软件是否正常运行。它对于*回归测试*也非常重要，回归测试用来确保在添加新功能后，代码仍然能够正常工作。手动运行回归测试太过繁琐，因此通常不会发生。'
- en: In TDD, developers write automated tests prior to writing the code, which means
    that the test will initially fail. The developer runs the tests, picks a test
    that fails, writes the software to fix that failure, and then reruns the tests.
    As soon as a test succeeds, the developer moves on to the next failing test. Successfully
    eliminating all the failed tests verifies that the software meets the requirements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD中，开发人员会先编写自动化测试用例，再编写代码，这意味着测试最初会失败。开发人员运行测试，选择一个失败的测试，编写软件来修复这个失败，然后重新运行测试。只要某个测试通过，开发人员就会继续处理下一个失败的测试。成功地消除所有失败的测试就验证了软件满足需求。
- en: '*Pair programming*, one of Agile’s more controversial practices, involves two
    programmers working on each section of code together. One programmer enters the
    code while the other watches, catching mistakes onscreen, offering design tips,
    providing quality control, and keeping the first programmer focused on the project.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*结对编程*是敏捷中较具争议的一项实践，它要求两名程序员共同编写每一段代码。一名程序员输入代码，另一名程序员观察，纠正屏幕上的错误，提供设计建议，进行质量控制，并帮助第一个程序员保持专注于项目。'
- en: '**3.3.3.4 Agile Sprints (Iterations) Are Short**'
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.3.4 敏捷冲刺（迭代）周期短**'
- en: Agile methodologies work best when the iterations are short—from one week to
    (at most) a couple of months. This is a nod to the old adage “If it weren’t for
    the last minute, nothing would ever get done.” By keeping iterations short, software
    engineers are always working during the last minute, reducing fatigue and procrastination
    and increasing project focus.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷方法最有效的方式是保持迭代周期短—从一周到最多几个月。这也呼应了那句老话：“如果没有最后一分钟，什么事都做不成。”通过保持迭代短小，软件工程师总是在“最后一分钟”工作，减少了疲劳和拖延，提升了项目的专注度。
- en: Hand in hand with short sprints are short feedback cycles. A common Agile feature
    is a brief daily stand-up meeting, typically no more than 15 minutes,^([7](ch19_footnote.xhtml#ch03fn7))
    where programmers concisely describe what they’re working on, what they’re stuck
    on, and what they’ve finished. This allows project management to rearrange resources
    and provide help if the schedule is slipping. The meetings catch any problems
    early rather than wasting several weeks before the issue comes to project management’s
    attention.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 短周期的冲刺与短周期的反馈紧密相连。一个常见的敏捷特性是简短的每日站会，通常不超过15分钟，^([7](ch19_footnote.xhtml#ch03fn7))，在会上，程序员简洁地描述他们正在做什么，遇到了什么问题，已经完成了什么。这使得项目管理可以重新安排资源并在进度滞后的情况下提供帮助。这些会议能及早发现问题，而不是等到问题积累数周才引起项目管理的注意。
- en: '**3.3.3.5 Agile Deemphasizes Heavyweight Documentation**'
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.3.5 敏捷不强调笨重文档**'
- en: 'One of the Waterfall model’s biggest problems is that it produces reams of
    documentation that is never again read. Overly comprehensive, *heavyweight* documentation
    has a few problems:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 瀑布模型的最大问题之一是，它会产生大量从未再被阅读的文档。过于全面的、*笨重的*文档有几个问题：
- en: Documentation must be maintained. Whenever a change is made in the software,
    the documentation must be updated. Changes in one document have to be reflected
    in many other documents, increasing workload.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档必须得到维护。每当软件进行更改时，文档也必须更新。一份文档中的更改必须反映在许多其他文档中，从而增加了工作量。
- en: Many documents are difficult to write prior to the code. More often than not,
    such documents are updated after the code is written and then never read again
    (a waste of time and money).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多文档在编写代码之前很难写。更多时候，这些文档是在代码写完后更新的，并且再也没有被阅读（浪费了时间和金钱）。
- en: An iterative development process quickly destroys coherence between code and
    documentation. Therefore, properly maintaining the documentation at each iteration
    doesn’t fit well with the Agile methodology.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代开发过程会迅速破坏代码与文档之间的一致性。因此，在每次迭代中正确地维护文档与敏捷方法论不太匹配。
- en: Agile emphasizes *just barely good enough (JBGE)* documentation—that is, enough
    documentation so the next programmer can pick up where you left off, but no more
    (in fact, Agile emphasizes JBGE for most concepts, including design/modeling).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷强调*恰到好处（JBGE）*的文档——也就是说，文档应该足够多，以便下一个程序员能接着你的工作继续，但不能过多（事实上，敏捷强调JBGE适用于大多数概念，包括设计/建模）。
- en: Many books have been written on Agile development (see “[For More Information](ch03.xhtml#lev-3.5)”
    on [page 69](ch03.xhtml#page_69)). This is not one of them, but we’ll look at
    a couple of the different methodologies under the Agile umbrella. These methodologies
    are not mutually exclusive; two or more can be combined and used on the same project.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 许多书籍都写了关于敏捷开发的内容（参见“[更多信息](ch03.xhtml#lev-3.5)”在[第69页](ch03.xhtml#page_69)）。这本书并不是其中之一，但我们将探讨敏捷方法下的几种不同方法论。这些方法论并不是互相排斥的；可以将两种或更多方法结合起来使用在同一个项目中。
- en: '***3.3.4 Extreme Programming***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.3.4 极限编程***'
- en: Extreme Programming (XP) is perhaps the most widely used Agile methodology.
    It aims to streamline development practices and processes to deliver working software
    that provides the desired feature set without unnecessary extras.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 极限编程（XP）可能是最广泛使用的敏捷方法论。它旨在简化开发实践和过程，交付能够提供所需功能集的工作软件，而不附加不必要的内容。
- en: 'XP is guided by five values:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: XP的指导原则有五个：
- en: '**Communication** Good communication between the customer and the team, among
    team members, and between the team and management is essential for success.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**沟通** 客户与团队之间、团队成员之间、团队与管理层之间的良好沟通对于成功至关重要。'
- en: '**Simplicity** XP strives to produce the simplest system today, even if it
    costs more to extend it tomorrow, rather than producing a complicated product
    that implements features that might never be used.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单性** XP力求今天产生最简单的系统，即使明天扩展它的成本更高，而不是产生一个复杂的产品，实现那些可能永远不会用到的功能。'
- en: '**Feedback** XP depends upon continuous feedback: unit and functional tests
    provide programmers with feedback when they make changes to their code; the customer
    provides immediate feedback when a new feature is added; and project management
    tracks the development schedule, providing feedback about estimates.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**反馈** XP依赖于持续的反馈：单元和功能测试在程序员更改代码时为其提供反馈；客户在添加新功能时提供即时反馈；项目管理跟踪开发进度，提供关于估算的反馈。'
- en: '**Respect** XP requires that team members respect one another. A programmer
    will never commit a change to the code base that breaks the compilation or existing
    unit tests (or do anything else that will delay the work of other team members).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**尊重** XP要求团队成员彼此尊重。程序员永远不会提交破坏代码库的更改，或者做出任何会拖延其他团队成员工作进度的行为。'
- en: '**Courage** XP’s rules and practices don’t line up with traditional software
    development practices. XP requires the commitment of resources (such as an “always
    available” customer representative or pair programmers) that can be expensive
    or difficult to justify in older methodologies. Some XP policies like “refactor
    early, refactor often” run counter to common practice such as “if it ain’t broke,
    don’t fix it.” Without the courage to fully implement its extreme policies, XP
    becomes less disciplined and can devolve into hacking.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**勇气** XP的规则和实践与传统的软件开发实践不一致。XP要求投入资源（例如“随时可用”的客户代表或配对程序员），这些资源在传统方法中可能成本高昂或难以证明其价值。一些XP的政策，如“早重构，常重构”，与常见做法（如“如果没有坏，就不要修”）相悖。如果没有勇气完全实施其极端政策，XP会变得不那么严谨，甚至可能退化为临时拼凑的编程方式。'
- en: '**3.3.4.1 The XP Team**'
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.4.1 XP团队**'
- en: 'Paramount to the XP process is the XP *whole team* concept: all members of
    the team work together to produce the final product. Team members are not specialists
    in one field, but often take on different responsibilities or roles, and different
    team members might perform the same role at different times. An XP team fills
    the following roles with various team members.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: XP过程中的关键概念是XP *全体团队*理念：团队的所有成员共同合作生产最终产品。团队成员并不是专门从事某一领域的专家，而是经常承担不同的责任或角色，不同的团队成员可能在不同时间执行相同的角色。XP团队由不同的成员填补以下角色。
- en: '**A customer representative**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户代表**'
- en: The customer representative is responsible for keeping the project on the right
    track, providing validation, writing *user stories* (requirements, features, and
    use cases) and *functional tests*, and deciding the *priorities* (release planning)
    for new functionality. The customer representative must be available whenever
    the team needs them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 客户代表负责确保项目按正确的轨道进行，提供验证，编写*用户故事*（需求、功能和用例）和*功能测试*，并决定新功能的*优先级*（发布规划）。客户代表必须在团队需要时随时可用。
- en: Not having an available customer representative is one of the largest impediments
    to successful XP projects. Without continuous feedback and direction from the
    customer, XP degenerates into hacking. XP doesn’t rely on requirements documentation;
    instead, the representative is a “living version” of that documentation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 没有可用的客户代表是成功的XP项目中最大的障碍之一。如果没有来自客户的持续反馈和指导，XP就会退化为临时拼凑的编程方式。XP不依赖于需求文档，而是将客户代表视为该文档的“活版本”。
- en: '**Programmers**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序员**'
- en: 'Programmers have several responsibilities on an XP team: working with the customer
    representative to produce user stories, estimating how resources should be allocated
    for those stories, estimating timelines and costs to implement stories, writing
    unit tests, and writing the code to implement the stories.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在XP团队中有多项责任：与客户代表合作编写用户故事，估算资源分配给这些故事的方式，估算实现这些故事的时间表和成本，编写单元测试，并编写代码来实现这些故事。
- en: '**Testers**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试人员**'
- en: Testers (programmers who implement or modify a given unit run unit tests) run
    the functional tests. Often, at least one of the testers is the customer representative.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 测试人员（实施或修改给定单元并运行单元测试的程序员）执行功能测试。通常，至少有一名测试人员是客户代表。
- en: '**Coach**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**教练**'
- en: The coach is the team leader, typically the lead programmer, whose job is to
    make sure the project succeeds. The coach ensures the team has the appropriate
    work environment; fosters good communication; shields the team from the rest of
    the organization by, for example, acting as a liaison to upper management; helps
    team members maintain self-discipline; and ensures the team maintains the XP process.
    When a programmer is having difficulty, coaches provide resources to help them
    overcome the problem.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 教练是团队领导，通常是首席程序员，负责确保项目的成功。教练确保团队拥有合适的工作环境；促进良好的沟通；通过充当上级管理层的联络人，保护团队免受组织其他部分的干扰；帮助团队成员保持自律；并确保团队维持XP过程的执行。当程序员遇到困难时，教练提供资源帮助他们克服问题。
- en: '**Manager/tracker**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**经理/追踪者**'
- en: The XP project manager is responsible for scheduling meetings and recording
    their results. The tracker is often, but not always, the same as the manager,
    and is responsible for tracking the project’s progress and determining whether
    the current iteration’s schedule can be met. To do so, the tracker checks with
    each programmer a couple of times a week.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: XP 项目经理负责安排会议并记录会议结果。跟踪员通常（但不总是）与经理是同一个人，负责跟踪项目的进度，并确定当前迭代的计划是否能够按时完成。为此，跟踪员每周会与每位程序员沟通几次。
- en: Different XP configurations often include additional team roles, such as analysts,
    designers, doomsayers, and so on. Because of the small size of XP teams (typically
    around 15 members) and the fact that (paired) programmers constitute the majority
    of the team, most roles are shared. See “[For More Information](ch03.xhtml#lev-3.5)”
    on [page 69](ch03.xhtml#page_69) for additional references.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 XP 配置通常包括额外的团队角色，如分析师、设计师、悲观者等。由于 XP 团队的规模较小（通常约 15 名成员），并且（配对）程序员占据团队的主要成员，因此大多数角色是共享的。有关更多信息，请参见[第
    69 页](ch03.xhtml#page_69)的“[更多信息](ch03.xhtml#lev-3.5)”部分。
- en: '**3.3.4.2 XP Software Development Activities**'
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.4.2 XP 软件开发活动**'
- en: 'XP uses four basic software development activities: coding, testing, listening,
    and designing.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: XP 使用四个基本的软件开发活动：编码、测试、倾听和设计。
- en: '**Coding**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码**'
- en: XP considers code to be the *only* important output of the development process.
    Contrary to the “think first, code later” philosophy of serial models like Waterfall,
    XP programmers start writing code at the beginning of the software development
    cycle. After all, “at the end of the day, there has to be a working program.”^([8](ch19_footnote.xhtml#ch03fn8))
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: XP 认为代码是开发过程中的*唯一*重要输出。与瀑布等串行模型中的“先思考，后编码”哲学相反，XP 程序员从软件开发周期开始时就开始编写代码。毕竟，“到头来，必须有一个可工作的程序。”^([8](ch19_footnote.xhtml#ch03fn8))
- en: XP programmers don’t immediately start coding, but are given a list of small
    and simple features to implement. They work on a basic design for a particular
    feature and then code that feature and make sure it’s working before expanding
    in increments, with each increment working correctly to ensure that the main body
    of code is always running. Programmers make only small changes to the project
    before integrating those changes into the larger system. XP minimizes all noncode
    output, such as documentation, because there is very little benefit to it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: XP 程序员不会立即开始编码，而是会得到一个小且简单的功能列表来实现。他们为特定功能制定基本设计，然后编写该功能并确保其正常工作，再逐步扩展每个增量，确保每个增量都能正确工作，从而确保主代码始终运行。程序员在将更改集成到更大的系统之前，通常只会对项目进行小幅度的修改。XP
    最大限度地减少了所有非代码输出，如文档，因为它几乎没有什么好处。
- en: '**Testing**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试**'
- en: 'XP emphasizes TDD using automated unit and functional tests. This allows XP
    engineers to develop the *product right* (verification via automated unit tests)
    and develop the *right product* (validation via functional tests). *WGC6: Testing,
    Debugging, and Quality Assurance* will deal more exclusively with testing, so
    we won’t go too far into it here; just know that TDD is very important to the
    XP process because it ensures that the system is always working.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'XP 强调通过自动化单元和功能测试来实现 TDD。这使得 XP 工程师能够开发出*正确的产品*（通过自动化单元测试进行验证）和开发出*合适的产品*（通过功能测试进行验证）。*WGC6:
    测试、调试和质量保证*将更专注于测试，因此我们在这里不会深入讨论；只需要知道 TDD 对 XP 过程非常重要，因为它确保系统始终正常运行。'
- en: Testing in XP is always automated. If adding one feature breaks an unrelated
    feature for some reason, it’s critical to immediately catch that. By running a
    full set of unit (and functional) tests when adding a new feature, you can ensure
    that your new code doesn’t cause a regression.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: XP 中的测试始终是自动化的。如果添加一个功能因某些原因破坏了无关的功能，那么及时发现这一点至关重要。通过在添加新功能时运行完整的单元（和功能）测试，可以确保新代码不会引起回归。
- en: '**Listening**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**倾听**'
- en: XP developers communicate almost constantly with their customers to ensure they’re
    developing the right product (validation).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: XP 开发人员几乎与客户进行持续沟通，确保他们开发的是正确的产品（验证）。
- en: XP is a *change-driven process*, meaning it expects changes in requirements,
    resources, technology, and performance, based on feedback from customers as they
    test the product throughout the process.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: XP 是一个*以变化为驱动的过程*，这意味着它期望在整个过程中根据客户的反馈，要求、资源、技术和性能发生变化。
- en: '**Designing**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计**'
- en: Design occurs constantly throughout the XP process—during release planning,
    iteration planning, refactoring, and so on. This focus prevents XP from devolving
    into hacking.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 设计在整个XP过程中不断发生——在发布规划、迭代规划、重构等阶段。这个关注点防止XP陷入乱搞代码的局面。
- en: '**3.3.4.3 The XP Process**'
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.4.3 XP过程**'
- en: Each cycle of XP produces a software *release*. Frequent releases ensure constant
    feedback from the customer. Each cycle consists of a couple of fixed-period blocks
    of time known as iterations (with no more than a couple of weeks for each iteration).
    Cycles, as shown in [Figure 3-5](ch03.xhtml#ch3fig5), are necessary for planning;
    the middle box in this figure represents one or more iterations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: XP的每个周期都会产生一个软件*发布*。频繁的发布确保了来自客户的持续反馈。每个周期由几个固定时间段组成，这些时间段被称为迭代（每个迭代的时间不超过几周）。如[图3-5](ch03.xhtml#ch3fig5)所示，周期对于规划是必需的；该图中的中间框代表一个或多个迭代。
- en: '![image](Images/fig3-5.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig3-5.jpg)'
- en: '*Figure 3-5: An XP cycle*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-5：XP周期*'
- en: In the planning game, the XP team decides which features to implement, estimates
    their costs, and plans the release. During the exploration step, the customer
    defines the feature set and developers estimate costs and time requirements for
    those features. The next section (under “User stories”) describes the mechanism
    customers use to specify features.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划游戏中，XP团队决定要实现哪些功能，估算其成本，并规划发布。在探索阶段，客户定义功能集，开发人员估算这些功能的成本和时间需求。接下来的部分（在“用户故事”下）描述了客户用来指定功能的机制。
- en: During release planning, the customer negotiates with the developers on the
    features to implement in the given iteration. The developers commit to the release
    plan, and engineers are assigned various tasks. At the end of release planning,
    the process enters the *steering* phase, during which the customer ensures that
    the project remains on track.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布规划阶段，客户与开发人员就本次迭代中要实现的功能进行协商。开发人员承诺执行发布计划，并分配各种任务。在发布规划结束时，过程进入*引导*阶段，在该阶段，客户确保项目按计划进行。
- en: 'After the overall plan is determined, the process for the current release enters
    an inner loop consisting of three steps: iteration planning, implementation, and
    functional testing. Iteration planning is the planning game scaled down for a
    single feature.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在总体计划确定后，当前发布的过程进入一个包含三个步骤的内循环：迭代规划、实施和功能测试。迭代规划是对单个功能的缩小版规划游戏。
- en: The implementation step is the coding and unit testing of the feature. The developer
    writes a set of unit tests, implements just enough code to make the unit tests
    succeed, refactors the code as necessary, and integrates the changes into the
    common code base.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 实施步骤是功能的编码和单元测试。开发人员编写一组单元测试，实施足够的代码以使单元测试通过，必要时对代码进行重构，并将更改集成到共享代码库中。
- en: During the last step of the iteration, customers perform functional testing.
    Then the process repeats for the next iteration, or a release is produced if all
    iterations are completed for the current release.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代的最后一步，客户进行功能测试。然后，如果当前版本的所有迭代都完成，则进入下一个迭代，或者发布新版本。
- en: '**3.3.4.4 XP Software Development Rules**'
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.4.4 XP软件开发规则**'
- en: XP implements the four software development activities—coding, testing, listening,
    and designing—using 12 simple rules:^([9](ch19_footnote.xhtml#ch03fn9))
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: XP通过12条简单规则来实现四项软件开发活动——编码、测试、倾听和设计：^([9](ch19_footnote.xhtml#ch03fn9))
- en: User stories (planning game)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户故事（规划游戏）
- en: Small releases (building blocks)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小规模发布（构建块）
- en: Metaphors (standardized naming schemes)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐喻（标准化命名方案）
- en: Collective ownership
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集体所有权
- en: Coding standard
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码标准
- en: Simple design
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单设计
- en: Refactoring
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构
- en: Testing
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Pair programming
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配对编程
- en: Onsite customer
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现场客户
- en: Continuous integration
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成
- en: Sustainable pace
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可持续节奏
- en: Each rule is described next, along with its advantages and disadvantages.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每个规则接下来都会描述，并列出其优缺点。
- en: '**User stories**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户故事**'
- en: User stories describe a simplified set of use cases, written by the customer,
    that define the system’s requirements. The project team uses this set, which should
    provide only enough detail to estimate how long it will take to implement the
    feature, to estimate the cost and plan the system’s development.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 用户故事描述了一组简化的用例，由客户编写，定义了系统的需求。项目团队使用这一套用户故事，它应该只提供足够的细节来估算实现该功能所需的时间，进而估算成本并规划系统的开发。
- en: At the beginning of a project, the customer generates 50 to 100 user stories
    to use during a release planning session. Then the customer and the team negotiate
    which features the team will implement in the next release. The customer, possibly
    with help from a developer, also creates functional tests from the user stories.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目开始时，客户会生成50到100个用户故事，用于发布计划会议中。然后，客户和团队会协商决定在下一次发布中由团队实现哪些功能。客户可能会在开发人员的帮助下，也会根据用户故事创建功能测试。
- en: '**Small releases**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**小范围发布**'
- en: Once a piece of software is functional, the team adds one feature at a time.
    Other features are not added until that new feature is written, tested, debugged,
    and incorporated into the main build. The team creates a new build of the system
    for each feature it adds.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一段软件实现了基本功能，团队会一次添加一个功能。在新功能编写、测试、调试并合并到主版本之前，不会添加其他功能。每添加一个新功能，团队都会创建一个新的系统构建版本。
- en: '**Metaphors**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐喻**'
- en: XP projects revolve around a story about the system’s operation that all stakeholders
    can understand. Metaphors are naming conventions used within the software to ensure
    that operations are obvious to everyone; they replace a complex business process
    name with a simple name. For example, “train conductor” might describe how a data
    acquisition system operates.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: XP项目围绕着一个所有利益相关者都能理解的系统操作故事展开。隐喻是软件中使用的命名约定，确保每个人都能清晰地理解操作；它们将复杂的业务流程名称替换为简单的名称。例如，“火车乘务员”可能用来描述数据采集系统的操作方式。
- en: '**Collective ownership**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**集体所有权**'
- en: In XP, the entire team owns and maintains all source code. At any time, any
    team member can check out code and modify it. During reviews, no one is singled
    out for coding mistakes. Collective code ownership prevents delays and means one
    person’s absence doesn’t hinder progress.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在XP中，整个团队共同拥有并维护所有源代码。在任何时候，任何团队成员都可以检出代码并进行修改。在评审过程中，不会因为编码错误而特别指责任何人。集体代码所有权避免了延误，并且意味着某个人的缺席不会妨碍进展。
- en: '**Coding standard**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码标准**'
- en: All XP members must adhere to common coding standards concerning styles and
    formats. The team can develop the standards or they can come from an outside source,
    but everyone must follow them. Coding standards make the system easier to read
    and understand, especially for newcomers getting up to speed with the project,
    and help the team avoid having to waste time later refactoring the code to bring
    it into compliance.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 所有XP成员必须遵守关于样式和格式的共同编码标准。团队可以制定这些标准，或者它们可以来自外部来源，但每个人都必须遵守。编码标准使得系统更易于阅读和理解，尤其是对于新加入的成员，他们需要迅速适应项目，并帮助团队避免以后浪费时间重构代码以符合标准。
- en: '**Simple design**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单设计**'
- en: The simplest design that meets all the requirements is always chosen. At no
    time does the design anticipate features that have yet to be added—for example,
    adding “hooks” or application programming interfaces (APIs) that allow future
    code to interface with the current code. Simple design means *just enough to get
    the current job done*. The simplest code will pass all the tests for the current
    iteration. This runs counter to traditional software engineering, where software
    is designed as generically as possible to handle any future enhancements.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 始终选择满足所有要求的最简单设计。设计中绝不会预见到尚未添加的功能——例如，添加“钩子”或应用程序编程接口（API），以便将来代码能够与当前代码进行接口。简单设计意味着*足够完成当前任务*。最简单的代码会通过当前迭代的所有测试。这与传统的软件工程相悖，后者通常将软件设计得尽可能通用，以便处理任何未来的增强功能。
- en: '**Refactoring**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**重构**'
- en: Refactoring code is the process of restructuring or rewriting the code without
    changing its external behavior, to make the code simpler, more readable, or better
    by some other improvement metric.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 重构代码是指在不改变外部行为的情况下，重构或重写代码，以使代码更简单、更易读，或通过其他改善指标来提高代码质量。
- en: '*WGC5: Great Coding* will go into refactoring in much greater detail. See “[For
    More Information](ch03.xhtml#lev-3.5)” on [page 69](ch03.xhtml#page_69) for additional
    references on refactoring.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*WGC5: 卓越编码*将更详细地讲解重构。有关重构的更多参考资料，请参见[第69页](ch03.xhtml#page_69)中的“[更多信息](ch03.xhtml#lev-3.5)”。'
- en: '**Testing**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试**'
- en: XP uses a TDD methodology, as discussed in “XP Software Development Activities”
    on [page 57](ch03.xhtml#page_57).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: XP采用TDD方法论，如[第57页](ch03.xhtml#page_57)的“XP软件开发活动”中所讨论的。
- en: '**Pair programming**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**结对编程**'
- en: In pair programming, one programmer (the *driver*) enters code, and the second
    programmer (the *navigator*) reviews each line of code as it’s written. The two
    engineers change roles throughout and pairs are often created and broken apart.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在配对编程中，一名程序员（*司机*）输入代码，第二名程序员（*导航员*）在每行代码编写时进行审查。两名工程师在整个过程中互换角色，并且配对通常会不断形成和解散。
- en: It’s often difficult to convince management that two programmers working together
    on the same code are more productive than they are working separately on different
    pieces of code. XP evangelists argue that because the navigator is constantly
    reviewing the driver’s code, a separate review session isn’t needed, among other
    benefits:^([10](ch19_footnote.xhtml#ch03fn10))
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 说服管理层相信两名程序员在同一份代码上合作工作比各自独立工作更具生产力，往往是很困难的。XP 传教士认为，由于导航员在不断审查司机的代码，因此不需要单独的审查会话，除此之外还有其他好处：^([10](ch19_footnote.xhtml#ch03fn10))
- en: '**Economic benefits** Pairs spend about 15 percent more time on programs than
    individuals, but the code has 15 percent fewer defects.^([11](ch19_footnote.xhtml#ch03fn11))'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**经济效益** 配对编程所花费的时间比个人多大约 15%，但代码的缺陷比个人少约 15%。^([11](ch19_footnote.xhtml#ch03fn11))'
- en: '**Design quality** Two programmers produce a better design because they bring
    more experiences to the project. They think about the problem in different ways,
    and they devise the solution differently based on their driver/navigator roles.
    A better design means the project requires less backtracking and redesign throughout
    its life cycle.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计质量** 两名程序员能产生更好的设计，因为他们为项目带来了更多经验。他们从不同的角度思考问题，并根据他们的司机/导航员角色以不同的方式设计解决方案。更好的设计意味着项目在整个生命周期中需要更少的回溯和重设计。'
- en: '**Satisfaction** A majority of programmers enjoy working in pairs rather than
    alone. They feel more confident in their work and, as a result, produce better
    code.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**满意度** 大多数程序员喜欢配对工作，而不是单独工作。他们对自己的工作更有信心，因此能够产生更好的代码。'
- en: '**Learning** Pair programming allows pair members to learn from each other,
    increasing their respective skills. This cannot happen in solo programming.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习** 配对编程使配对成员可以相互学习，提高各自的技能。这是单独编程无法实现的。'
- en: '**Team building and communication** Team members share problems and solutions,
    which helps spread the intellectual property (IP) around and makes it easier for
    others to work on a given code section.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**团队建设与沟通** 团队成员共享问题和解决方案，这有助于将知识产权（IP）传播开来，并使其他人在给定的代码部分上更容易进行工作。'
- en: 'Overall, the research on the effectiveness of pair programming is a mixed bag.
    Most published papers from industry sources talk about how well pair programming
    has worked, but papers describing its failure in industry (versus academic) settings
    generally don’t get published. Research by Kim Man Lui and Andreas Hofer considers
    three types of pairings in pair programming: expert–expert, novice–novice, and
    expert–novice.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，关于配对编程有效性的研究结果是喜忧参半的。大多数来自行业的已发布论文讨论了配对编程的成功案例，但描述其在行业（相对于学术界）环境中失败的论文通常不会被发布。Kim
    Man Lui 和 Andreas Hofer 的研究考虑了配对编程中的三种配对类型：专家–专家、初学者–初学者和专家–初学者。
- en: '*Expert–expert pairing* can produce effective results, but two expert programmers
    are likely to use “tried and true” methods without introducing any new insight,
    meaning the effectiveness of this pairing versus two solo expert programmers is
    questionable.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*专家–专家配对* 可以产生有效的结果，但两个专家程序员可能会使用“经验证的方法”，而不引入任何新的见解，这意味着这种配对相较于两个单独的专家程序员的有效性是值得质疑的。'
- en: '*Novice–novice pairing* is often more effective than having the partners work
    on solo projects. Novices will have greatly varying backgrounds and experiences,
    and their knowledge is more likely to be complementary than overlapping (as is
    the case for expert pairs). Two novices working together are likely to work faster
    on two projects serially rather than they would working independently on their
    own project in parallel.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*初学者–初学者配对* 通常比让合作伙伴独立做项目更有效。初学者的背景和经验差异很大，他们的知识更有可能是互补的，而不是重叠的（这与专家配对的情况不同）。两位初学者一起工作时，更可能在两个项目上按顺序工作，而不是独立地平行处理各自的项目。'
- en: '*Expert–novice pairing* is commonly called *mentoring*. Many XP adherents don’t
    consider this to be pair programming, but mentoring is an efficient way to get
    a junior programmer up to speed with the code base. In mentoring, it’s best to
    have the novice act as the driver so they can interact with and learn from the
    code.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*专家–新手配对*通常被称为*指导*。许多XP的拥护者认为这不是配对编程，但指导是一种高效的方式，能让初级程序员迅速熟悉代码库。在指导中，最好让新手担任驾驶员角色，这样他们就可以与代码互动并从中学习。'
- en: GUIDELINES FOR SIMPLE DESIGN
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 简单设计指南
- en: 'Common phrases associated with simple design include:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 与简单设计相关的常见短语包括：
- en: '**Don’t repeat yourself (DRY)** Duplicate code is complex code.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要重复自己（DRY）** 重复的代码是复杂的代码。'
- en: '**Once and only once (OAOO)** All unique functionality should exist as some
    method/procedure in the code and appear only once in the code (this last point
    is DRY).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**一次且仅一次（OAOO）** 所有独特的功能应该以某种方法/过程的形式存在于代码中，并且只出现一次（这一点是DRY的体现）。'
- en: '**You aren’t gonna need it (YAGNI)** Avoid speculative coding. When adding
    a feature to your code base, make sure it’s specified by a user story (requirement).
    Don’t add code in anticipation of future requirements.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**你不需要它（YAGNI）** 避免推测性编码。当你向代码库中添加功能时，确保它是由用户故事（需求）指定的。不要提前为未来的需求添加代码。'
- en: '**Limit APIs and (published) interfaces** If your code interfaces with other
    systems by publishing an API, limiting the number of interfaces to the bare minimum
    will make it easier to modify your code in the future (without breaking external
    code).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**限制API和（发布的）接口** 如果你的代码通过发布API与其他系统进行交互，将接口数量限制到最小，将使得未来修改代码时更容易（而不会破坏外部代码）。'
- en: 'Simple design is amazingly difficult to achieve. More often than not, you accomplish
    it only by writing complex code and then refactoring it repeatedly until you’re
    happy with the result. A few quotes from some famous computer scientists will
    help drive this point home:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 简单设计是极其困难的。往往你只能通过编写复杂的代码，并反复重构它，直到你对结果满意，才能实现它。一些著名计算机科学家的几句话将帮助你深刻理解这一点：
- en: 'There are two ways of constructing a software design: one way is to make it
    so simple that there are obviously no deficiencies, and the other way is to make
    it so complicated that there are no obvious deficiencies.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 构建软件设计有两种方式：一种是使其简单到明显没有缺陷，另一种是使其复杂到没有明显缺陷。
- en: —C. A. R. Hoare
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: —C. A. R. 霍尔
- en: The cheapest, fastest, and most reliable components are those that aren’t there.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最便宜、最快和最可靠的组件是那些不存在的组件。
- en: —Gordon Bell
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: —戈登·贝尔
- en: Deleted code is debugged code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 删除的代码就是已调试的代码。
- en: —Jeff Sickle
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: —杰夫·西克尔
- en: Debugging is twice as hard as writing the code in the first place. Therefore,
    if you write the code as cleverly as possible, you are, by definition, not smart
    enough to debug it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的难度是编写代码的两倍。因此，如果你编写的代码足够巧妙，那么按定义来说，你就不够聪明去调试它。
- en: —Brian Kernighan and P. J. Plauger
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: —布赖恩·肯尼汉和P. J. 普劳杰
- en: Any program that tries to be so generalized and configurable that it could handle
    any kind of task will either fall short of this goal or will be horribly broken.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 任何试图做到足够通用和可配置的程序，试图处理任何任务，要么无法达到这一目标，要么会被严重破坏。
- en: —Chris Wenham
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: —克里斯·温哈姆
- en: The cost of adding a feature isn’t just the time it takes to code it. The cost
    also includes the addition of an obstacle to future expansion. The trick is to
    pick the features that don’t fight each other.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个功能的成本不仅仅是编码所需的时间。成本还包括为未来扩展增加的障碍。诀窍在于挑选那些不会相互冲突的功能。
- en: —John Carmack
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: —约翰·卡马克
- en: Simplicity is hard to build, easy to use, and hard to charge for. Complexity
    is easy to build, hard to use, and easy to charge for.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的设计难以构建，容易使用，但很难收费。复杂的设计容易构建，难以使用，却容易收费。
- en: —Chris Sacca
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: —克里斯·萨卡
- en: Though supporting evidence for pair programming is anecdotal and essentially
    unproven, XP depends on pair programming to replace formal code reviews, structured
    walk-throughs, and—to a limited extent—design documentation, so it can’t be forgone.
    As is common in the XP methodology, certain heavyweight processes like code reviews
    are often folded into other activities like pair programming. Trying to eliminate
    one rule or subprocess will likely open a gap in the overall methodology.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管配对编程的支持证据主要是轶事，并且本质上未经过验证，但XP依赖配对编程来替代正式的代码审查、结构化的走查和—在一定程度上—设计文档，因此它不能被放弃。正如XP方法论中常见的，某些繁重的过程，如代码审查，往往会被融入到配对编程等其他活动中。试图消除某一条规则或子流程，很可能会在整体方法中留下空隙。
- en: Not all XP activities are done in pairs. Many nonprogramming activities are
    done solo—for example, reading (and writing) documentation, dealing with emails,
    and doing research on the web—and some are always done solo, like writing *code
    spikes* (throwaway code needed to test a theory or idea). Ultimately, *pair programming
    is essential for successful XP ventures*. If a team cannot handle pair programming
    well, it should use a different development methodology.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有XP活动都是以配对形式进行的。许多非编程活动是单独进行的——例如，阅读（和编写）文档、处理电子邮件和在网上进行研究——有些活动总是单独进行的，比如编写*代码突发*（用于测试某个理论或想法的临时代码）。归根结底，*结对编程对XP成功至关重要*。如果一个团队无法有效地进行结对编程，它应该采用不同的开发方法。
- en: '**Onsite customer**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**现场客户**'
- en: As noted many times previously, in XP the customer is part of the development
    team and must be available at all times.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在XP中，客户是开发团队的一部分，必须始终可用。
- en: The onsite customer rule is probably the most difficult to follow. Most customers
    aren’t willing or able to provide this resource. However, without the continuous
    availability of a customer representative, the software could go off track, encounter
    delays, or regress from previous working versions. These problems are all solvable,
    but their solution destroys the benefits of using XP.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现场客户规则可能是最难遵循的规则。大多数客户不愿意或无法提供这个资源。然而，如果没有客户代表的持续参与，软件可能会偏离轨道，遇到延迟，或从之前的工作版本中退步。这些问题都是可以解决的，但解决方案会破坏使用XP的好处。
- en: '**Continuous integration**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**'
- en: In a traditional software development system like Waterfall, individual components
    of the system, written by different developers, are not tested together until
    some big milestone in the project, and the integrated software may fail spectacularly.
    The problem is that the unit tests don’t behave the same as the code that must
    be integrated with the units, typically due to communication problems or misunderstood
    requirements.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的软件开发系统（如瀑布模型）中，系统的各个组件是由不同的开发人员编写的，直到项目中的某个重要里程碑才会进行整合测试，而集成后的软件可能会出现灾难性的失败。问题在于单元测试与必须与单元集成的代码行为不同，通常是由于通信问题或需求理解错误。
- en: There will always be miscommunication and misunderstandings, but XP makes integration
    problems easier to solve via *continuous integration*. As soon as a new feature
    is implemented, it’s merged with the main build and tested. Some tests might fail
    because a feature has not yet been implemented, but the entire program is run,
    testing linkages with other units in the application. Software builds are created
    frequently (several times per day). As a result, you’ll discover integration problems
    early when they’re less costly to correct.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一定会发生误解和沟通不畅，但XP通过*持续集成*使集成问题更容易解决。每当一个新功能实现时，它就会与主构建合并并进行测试。有些测试可能会失败，因为某个功能尚未实现，但整个程序都会运行，测试与应用中其他单元的链接。软件构建会频繁创建（每天多次）。因此，你可以在问题成本较低时，尽早发现集成问题。
- en: '**Sustainable pace**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**可持续的步伐**'
- en: Numerous studies show that creative people produce their best results when they’re
    not overworked. XP dictates a 40-hour workweek for software engineers. Sometimes
    a crisis might arise that requires a small amount of overtime. But if management
    keeps its programming team in constant crisis mode, the quality of the work suffers
    and the overtime becomes counterproductive.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 许多研究表明，创造性的人在没有过度工作的情况下会产出最好的成果。XP规定软件工程师的工作时间为每周40小时。有时可能会出现需要少量加班的紧急情况。但如果管理层让编程团队始终处于危机模式，工作的质量就会下降，加班也会变得适得其反。
- en: '**3.3.4.5 Other Common Practices**'
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.4.5 其他常见实践**'
- en: 'In addition to the previous 12 rules, XP promotes several other common practices:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前的12条规则，XP还推广了其他一些常见的实践：
- en: '**Open workspace and collocation**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放的工作空间和联合办公**'
- en: The XP methodology suggests open work areas for the entire team, who work in
    pairs at adjacent workstations. Having everyone together promotes constant communication
    and keeps the team focused.^([12](ch19_footnote.xhtml#ch03fn12)) Questions can
    be quickly asked and answered, and other programmers can inject comments into
    a discussion as appropriate.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: XP方法论建议整个团队使用开放的工作区域，团队成员在相邻的工作站进行结对工作。让大家聚在一起促进了持续的沟通，并保持了团队的专注。问题可以迅速提出并得到解答，其他程序员可以根据需要在讨论中加入评论。^([12](ch19_footnote.xhtml#ch03fn12))
- en: But open workspaces have their challenges. Some people are more easily distracted
    than others. Loud noise and conversations can be very annoying and break concentration.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 但开放式工作空间也有其挑战。一些人比其他人更容易分心。嘈杂的噪音和对话会非常烦人，并打破集中注意力的状态。
- en: Open workspaces are a “best practice” in XP, not an absolute rule. If this setup
    doesn’t work for a particular pair, they can use an office or cubicle and work
    without distractions.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 开放式工作空间在XP中是“最佳实践”，而不是绝对规则。如果这种设置对某个团队不适用，他们可以使用办公室或小隔间，在没有干扰的情况下工作。
- en: '**Retrospectives/debriefings**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**回顾/总结会议**'
- en: When a project is complete, the team meets to discuss the successes and failures,
    disseminating the information to help improve the next project.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个项目完成时，团队会聚在一起讨论成功和失败的经验，将这些信息传播以帮助改进下一个项目。
- en: '**Self-directed teams**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**自主团队**'
- en: A self-directed team works on a project without the usual managerial levels
    (project leads, senior and junior level engineers, and so forth). The team makes
    decisions on priorities by consensus. XP teams aren’t completely unmanaged, but
    the idea here is that given a set of tasks and appropriate deadlines, the team
    can manage the task assignments and project progress on its own.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 自主团队在没有通常管理层（项目负责人、高级和初级工程师等）的情况下工作。团队通过共识来决定优先事项。XP团队并非完全没有管理，但这里的观点是，给定一组任务和适当的截止日期，团队可以自行管理任务分配和项目进度。
- en: '**3.3.4.6 Problems with XP**'
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.4.6 XP方法的问题**'
- en: 'XP is not a panacea. There are several problems with it, including:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: XP不是万能的。它有几个问题，包括：
- en: Detailed specifications aren’t created or preserved. This makes it difficult
    to add new programmers later in the project or for a separate programming team
    to maintain the project.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有创建或保存详细的规格说明。这使得在项目后期很难加入新程序员，或者让另一个编程团队来维护项目。
- en: Pair programming is required, even if it doesn’t work. In some cases, it can
    be overkill. Having two programmers work on a relatively simple piece of code
    can double your development costs.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使不起作用，也要求进行结对编程。在某些情况下，这可能是过度的。两个程序员共同开发一个相对简单的代码片段可能会使开发成本翻倍。
- en: To be practical, XP typically requires that all team members be GMPs in order
    to handle the wide range of roles each member must support. This is rarely achievable
    in real life, except on the smallest of projects.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上，XP通常要求所有团队成员都具备GMP（通用多功能专业人员）的能力，以应对每个成员必须支持的广泛角色。除非在最小规模的项目中，这在现实中很少能实现。
- en: Constant refactoring can introduce as many problems (new bugs) as it solves.
    It can also waste time when programmers refactor code that doesn’t need it.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续重构可能带来与它解决的问题（新bug）一样多的麻烦。当程序员重构不需要重构的代码时，还会浪费时间。
- en: No Big Design Up Front (that is, non-Waterfall-like development) often leads
    to excessive redesign.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不进行前期大设计（即非瀑布式开发）通常会导致过度的重新设计。
- en: A customer representative is necessary. Often, the customer will assign a junior-level
    person to this position because of the perceived costs, resulting in a failure
    point. If the customer representative leaves before the project is complete, all
    the requirements that aren’t written down are lost.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要有客户代表。通常，客户会因考虑成本将一个初级人员安排到这个职位上，导致失败点。如果客户代表在项目完成前离开，所有未记录下来的需求都会丢失。
- en: XP is not scalable to large teams. The limit for a productive XP team is approximately
    a dozen engineers.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XP不适用于大团队。一个高效的XP团队的上限大约是十几个工程师。
- en: XP is especially susceptible to “feature creep.” The customer can inject new
    features into the system due to a lack of documented requirements/features.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XP尤其容易受到“功能蔓延”的影响。由于缺乏文档化的需求/功能，客户可能会将新功能注入系统。
- en: Unit tests, even those created by XP programmers, often fail to point out missing
    features. Unit tests test “the code that is present,” not “the code that *should*
    be present.”
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试，即使是XP程序员创建的，也常常无法指出缺失的功能。单元测试测试的是“已存在的代码”，而不是“*应该*存在的代码”。
- en: 'XP is generally considered an “all or nothing” methodology: if you don’t follow
    every tenet of the “XP religion,” the process fails. Most XP rules have weaknesses
    that are covered by the strengths of other rules. If you fail to apply one rule,
    another rule will likely break (because its weaknesses are no longer covered,
    and that broken rule will break another, ad nauseam).'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XP通常被认为是一种“全有或全无”的方法论：如果你不遵循“XP宗教”的每一条原则，过程就会失败。大多数XP规则都有缺陷，而这些缺陷会被其他规则的优点所弥补。如果你未能应用一条规则，另一条规则很可能会被打破（因为它的缺点不再得到弥补，这条破坏的规则又会破坏另一条规则，如此反复）。
- en: This small introduction to XP cannot do the topic justice. For more information
    on XP, see “[For More Information](ch03.xhtml#lev-3.5)” on [page 69](ch03.xhtml#page_69).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关于 XP 的简短介绍无法完全阐述该主题。有关 XP 的更多信息，请参阅 “[更多信息](ch03.xhtml#lev-3.5)” 以及 [第 69
    页](ch03.xhtml#page_69)。
- en: '***3.3.5 Scrum***'
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.3.5 Scrum***'
- en: The Scrum methodology is not a software development methodology per se, but
    an Agile mechanism for *managing* the software development process. More often
    than not, Scrum is used to manage some other model such as XP.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Scrum 方法论本身并不是一种软件开发方法论，而是一种*管理*软件开发过程的敏捷机制。通常，Scrum 用于管理其他模型，例如 XP。
- en: 'Beyond engineers, a Scrum team has two special members: the product owner and
    the scrum master. The *product owner* is responsible for guiding the team toward
    building the right product by, for example, maintaining requirements and features.
    The *scrum master* is a coach who guides the team members through the Scrum-based
    development process, managing team progress, maintaining lists of projects, and
    ensuring team members aren’t held up.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 除了工程师外，Scrum 团队还有两位特殊成员：产品负责人和 Scrum Master。*产品负责人* 负责引导团队构建正确的产品，例如，维护需求和功能。*Scrum
    Master* 是一位教练，指导团队成员通过基于 Scrum 的开发流程，管理团队进展，维护项目清单，并确保团队成员不受阻碍。
- en: Scrum is an iterative development process like all other Agile methodologies,
    and each iteration is a one- to four-week sprint. A sprint begins with a planning
    meeting where the team determines the work to be done. A list of items known as
    a *backlog* is assembled, and the team estimates how much time is required for
    each item on the backlog. Once the backlog is created, the sprint can begin.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Scrum 是一个迭代开发过程，像所有其他敏捷方法论一样，每个迭代都是一个为期一到四周的 sprint。sprint 从计划会议开始，团队在会议中确定要完成的工作。将组成一个被称为
    *待办事项清单* 的事项列表，团队估算每个待办事项需要的时间。待办事项清单一旦创建，sprint 就可以开始了。
- en: Each day the team has a short stand-up meeting during which the members briefly
    mention yesterday’s progress and their plans for today. The scrum master notes
    any progress problems and deals with them after the meeting. No detailed discussions
    about the project take place during the stand-up meeting.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 每天，团队都会召开简短的站会，在会上，成员简要提到昨天的进展和今天的计划。Scrum Master 记录下任何进度问题，并在会议后处理这些问题。站会期间不会进行项目的详细讨论。
- en: Team members pick items from the backlog and work on those items. As items are
    removed from the backlog, the scrum master maintains a Scrum *burn-down chart*
    that shows the current sprint’s progress. When all the items have been implemented
    to the product owner’s satisfaction, or the team determines that some items cannot
    be finished on time or at all, the team holds an *end meeting*.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 团队成员从待办事项清单中选择任务并开始工作。当任务从待办事项清单中移除时，Scrum Master 维护一个 Scrum *燃尽图*，显示当前 sprint
    的进展。当所有事项都已按产品负责人要求完成，或者团队认为某些事项无法按时完成或根本无法完成时，团队会召开 *结束会议*。
- en: At the end meeting, the team demonstrates the features that were implemented
    and explains the failures of the items not completed. If possible, the scrum master
    collects unfinished items for the next sprint.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在结尾会议上，团队展示已实现的功能，并解释未完成事项的失败。如果可能，Scrum Master 会收集未完成的事项以供下一个迭代使用。
- en: Also part of the end meeting is the sprint *retrospective*, where team members
    discuss their progress, suggest process improvements, and determine what went
    well and what went wrong.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 结尾会议的一部分是 sprint *回顾*会议，在会议上，团队成员讨论他们的进展，提出流程改进建议，并确定哪些做得好，哪些做得不好。
- en: Note that Scrum doesn’t dictate how the engineers perform their jobs or how
    the tasks are documented, and doesn’t provide a set of rules or best practices
    to follow during development. Scrum leaves these decisions to the development
    team. Many teams, for example, employ the XP methodology under Scrum. Any methodology
    compatible with iterative development will work fine.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Scrum 并不规定工程师如何执行他们的工作或如何记录任务，也没有提供开发过程中要遵循的一套规则或最佳实践。Scrum 将这些决策留给开发团队。例如，许多团队在
    Scrum 框架下采用 XP 方法论。任何与迭代开发兼容的方法论都可以很好地工作。
- en: Like XP, Scrum works well with small teams fewer than a dozen members and fails
    to scale to larger teams. Some extensions to Scrum have been made to support larger
    teams. Specifically, a “scrum-of-scrums” process allows multiple teams to apply
    a Scrum methodology to a large project. The large project is broken down into
    multiple teams, and then an ambassador from each team is sent to the daily scrum-of-scrums
    meeting to discuss their progress. This doesn’t solve all the communication problems
    of a large team, but it does extend the methodology to work for slightly larger
    projects.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 和极限编程（XP）类似，Scrum适用于小团队（成员少于十人），并且难以扩展到大型团队。为支持大型团队，Scrum进行了一些扩展。特别是，"scrum-of-scrums"过程允许多个团队将Scrum方法应用于大型项目。大型项目被拆分成多个团队，然后每个团队派出一名代表参加每日的scrum-of-scrums会议，讨论他们的进展。这虽然无法解决大型团队所有的沟通问题，但可以使该方法适用于稍大一些的项目。
- en: '***3.3.6 Feature-Driven Development***'
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***3.3.6 特性驱动开发***'
- en: Feature-driven development, one of the more interesting methodologies under
    the Agile umbrella, is specifically designed to scale up to large projects.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 特性驱动开发，作为敏捷方法中的一种有趣方法，专门设计用来扩展到大型项目。
- en: One common thread among most Agile methodologies is that they require expert
    programmers in order to succeed. FDD, on the other hand, allows for large teams
    where it is logistically impossible to ensure you have the best person working
    on every activity of the project, and is worth serious consideration on projects
    involving more than a dozen software engineers.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数敏捷方法论的共同点是，它们要求专家级程序员才能成功。另一方面，FDD允许有大型团队，在这种情况下，物流上不可能确保每个项目活动都有最合适的人来完成，因此在涉及十多个软件工程师的项目中，FDD值得认真考虑。
- en: 'FDD uses an iterative model. Three processes take place at the beginning of
    the project (often called *iteration zero*), and then the remaining two processes
    are iteratively carried out for the duration of the project. These processes are
    as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 特性驱动开发（FDD）采用迭代模型。项目开始时进行三个过程（通常称为*零迭代*），然后剩余的两个过程在项目持续过程中迭代进行。这些过程如下：
- en: Develop an overall model.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发一个整体模型。
- en: Build a features list.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建特性列表。
- en: Plan by feature.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按特性规划。
- en: Design by feature.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按特性设计。
- en: Build by feature.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按特性构建。
- en: '**3.3.6.1 Develop an Overall Model**'
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.6.1 开发整体模型**'
- en: Developing an overall model is a collaborative effort between all the stake­holders—clients,
    architects, and developers—where all team members work together to understand
    the system. Unlike the specifications and design documents in the serial methods,
    the overall model concentrates on breadth rather than depth to fill in as many
    generalized features as possible to define the entire project, and then fill in
    the depth of the model design’s future iterations, with the purpose of guiding
    the current project, not documenting it for the future.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 开发整体模型是所有利益相关者——客户、架构师和开发人员——之间的协作工作，所有团队成员共同努力理解系统。与串行方法中的规格和设计文档不同，整体模型侧重于广度而非深度，旨在尽可能多地填充通用特性，以定义整个项目，然后在模型设计的未来迭代中填充深度，目的是引导当前项目，而不是为未来进行文档化。
- en: The advantage of this approach versus other Agile approaches is that most features
    are planned from the beginning of the project. Therefore, the design can’t take
    off in a direction that makes certain features difficult or impossible to add
    at a later date, and new features cannot be added in an ad hoc fashion.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他敏捷方法相比，这种方法的优点在于，大多数特性从项目开始时就已经规划好。因此，设计无法朝着某个方向偏离，以至于某些特性在后期很难或不可能添加，同时也无法随意增加新的特性。
- en: '**3.3.6.2 Build a Features List**'
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.6.2 创建特性列表**'
- en: During the second step of FDD, the team documents the feature list devised in
    the model development step, which is then formalized by the chief programmer for
    use during design and development. The output of this process is a formal features
    document. Although not as heavyweight as the SRS document found in other models,
    the feature descriptions are formal and unambiguous.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在FDD的第二个步骤中，团队记录了在模型开发步骤中制定的特性列表，然后由首席程序员正式化，以便在设计和开发过程中使用。此过程的输出是正式的特性文档。虽然不像其他模型中的SRS文档那么繁重，但特性描述是正式且明确的。
- en: '**3.3.6.3 Plan by Feature**'
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.6.3 按特性规划**'
- en: The plan-by-feature process involves creating an initial schedule for the software
    development that dictates which features will be implemented initially and which
    features will be implemented on successive iterations.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 按特性计划过程包括为软件开发制定初步的时间表，决定哪些特性将首先实现，哪些特性将在后续迭代中实现。
- en: 'Plan by feature also assigns sets of features to various chief programmers
    who, along with their teams, are responsible for implementing them. The chief
    programmer and associated team members take ownership of these features and the
    associated code. This deviates somewhat from standard Agile practice, where the
    entire team owns the code. This is one of the reasons FDD works better for large
    projects than standard Agile processes: collective code ownership doesn’t scale
    well to large projects.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 按特性计划还将一组特性分配给不同的首席程序员，他们与各自的团队一起负责实施这些特性。首席程序员及其团队成员对这些特性及相关代码负有所有权。这与标准的敏捷实践有所不同，因为在标准敏捷中，整个团队都拥有代码。这也是FDD在大型项目中比标准敏捷流程更有效的原因之一：集体代码所有权对于大型项目的扩展性较差。
- en: As a rule, each feature is a small task that a three- to five-person team can
    develop in two or three weeks (and, more often, just days). Each feature class
    is independent of the others, so no feature depends on the development of features
    in classes owned by other teams.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个特性是一个小任务，由三到五人组成的团队可以在两到三周内开发完成（更常见的是几天内完成）。每个特性类是独立的，因此没有任何特性依赖于其他团队所拥有的特性类的开发。
- en: '**3.3.6.4 Design by Feature**'
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.6.4 按特性设计**'
- en: Once the features for a given iteration are selected, the chief programmer who
    owns each feature set forms a team to design the feature. Feature teams are not
    static; they’re formed and disbanded for each iteration of the design-by-feature
    and build-by-feature processes.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选定了给定迭代的特性，由每个特性集的首席程序员组成的团队会设计该特性。特性团队不是静态的；它们会在每次设计按特性和按特性构建的迭代过程中组建和解散。
- en: The feature team analyzes the requirements and designs the feature(s) for the
    current iteration. The teams decide on that feature’s implementation and its interaction
    with the rest of the system. If the feature is far-reaching, the chief programmer
    might involve other feature class owners to avoid conflicts with other feature
    sets.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 特性团队分析需求并设计当前迭代的特性。团队决定该特性的实现方式及其与系统其他部分的互动。如果特性影响范围较广，首席程序员可能会邀请其他特性类所有者以避免与其他特性集发生冲突。
- en: During the design phase, the feature teams decide on the algorithms and processes
    to use, and develop and document tests for the features. If necessary, the chief
    programmer (along with the original set of stakeholders) updates the overall model
    to reflect the design.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计阶段，特性团队决定使用哪些算法和流程，并为特性开发和记录测试。如果有必要，首席程序员（以及原始利益相关者）会更新整体模型以反映设计。
- en: '**3.3.6.5 Build by Feature**'
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.6.5 按特性构建**'
- en: The build-by-feature step involves coding and testing the feature. The developers
    unit-test their code and feature teams provide formal system testing of the features.
    FDD doesn’t mandate TDD, but it does insist that all features added to the system
    be tested and reviewed.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 按特性构建步骤包括编写代码和测试特性。开发人员会对自己的代码进行单元测试，特性团队则提供对特性的正式系统测试。FDD并不要求TDD，但确实要求对所有添加到系统中的特性进行测试和审查。
- en: FDD requires code reviews (a best practice, but not required by most Agile processes).
    As Steve McConnell points out in *Code Complete* (Microsoft Press, 2004), well-executed
    code inspections uncover many defects that testing alone will never find.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: FDD要求代码审查（这是最佳实践，但大多数敏捷流程并不要求）。正如Steve McConnell在《*Code Complete*》（Microsoft
    Press，2004）中指出的，执行良好的代码检查能发现很多仅靠测试无法发现的缺陷。
- en: '**3.4 Models and Methodologies for the Great Programmer**'
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.4 优秀程序员的模型和方法论**'
- en: A great programmer should be capable of adapting to any software development
    model or methodology in use by their team. That said, some models are more appropriate
    than others. If you’re given the choice of model, this chapter should guide you
    in choosing an appropriate one.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优秀的程序员应该能够适应团队使用的任何软件开发模型或方法论。也就是说，一些模型比其他模型更合适。如果你可以选择模型，本章将指导你选择一个合适的模型。
- en: No methodology is scalable up *or down*, so you’ll need to choose a suitable
    model and methodology based on the project size. For tiny projects, hacking or
    a documentation-less version of the Waterfall model is probably a good choice.
    For medium-sized projects, one of the iterative (Agile) models and methodologies
    is best. For large projects, the sequential models or FDD are the most successful
    (although often quite expensive).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何一种方法论可以在项目规模上进行*上下*扩展，因此你需要根据项目大小选择合适的模型和方法论。对于小型项目，黑客式开发或无文档版本的瀑布模型可能是一个不错的选择。对于中型项目，迭代（敏捷）模型和方法论是最佳选择。对于大型项目，顺序模型或FDD通常是最成功的（尽管通常非常昂贵）。
- en: More often than not, you won’t get to choose the developmental models for projects
    you work on unless they’re your personal projects. The key is to become familiar
    with the various models so you’re comfortable with any model you’re asked to use.
    The following section provides some resources for learning more about the different
    software development models and methodologies this chapter describes. As always,
    an internet search will provide considerable information on software development
    models and methodologies.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你无法选择你参与项目的开发模型，除非它们是你的个人项目。关键是要熟悉各种模型，这样你才能适应任何被要求使用的模型。以下部分提供了一些资源，帮助你进一步了解本章描述的不同软件开发模型和方法论。像往常一样，互联网搜索将提供大量关于软件开发模型和方法论的信息。
- en: '**3.5 For More Information**'
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.5 更多信息**'
- en: 'Astels, David R. *Test-Driven Development: A Practical Guide*. Upper Saddle
    River, NJ: Pearson Education, 2003.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Astels, David R. *测试驱动开发：实践指南*. 上萨德尔河，新泽西州：Pearson Education, 2003.
- en: 'Beck, Kent. *Test-Driven Development by Example.* Boston: Addison-Wesley Professional,
    2002.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Beck, Kent. *通过示例进行测试驱动开发.* 波士顿：Addison-Wesley Professional, 2002.
- en: 'Beck, Kent, with Cynthia Andres. *Extreme Programming Explained: Embrace Change*.
    2nd ed*.* Boston: Addison-Wesley, 2004.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Beck, Kent，和 Cynthia Andres. *极限编程解释：拥抱变化*. 第二版. 波士顿：Addison-Wesley, 2004.
- en: 'Boehm, Barry. *Spiral Development: Experience, Principles, and Refinements*.
    (Special Report CMU/SEI-2000-SR-008.) Edited by Wilfred J. Hansen. Pittsburgh:
    Carnegie Mellon Software Engineering Institute, 2000.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Boehm, Barry. *螺旋开发：经验、原则与改进*. （特别报告 CMU/SEI-2000-SR-008.）由Wilfred J. Hansen编辑.
    匹兹堡：卡内基梅隆软件工程研究所, 2000.
- en: 'Fowler, Martin. *Refactoring: Improving the Design of Existing Code*. Reading,
    MA: Addison-Wesley, 1999.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Fowler, Martin. *重构：改善现有代码的设计*. 雷丁，马萨诸塞州：Addison-Wesley, 1999.
- en: 'Kerievsky, Joshua. *Refactoring to Patterns*. Boston: Addison-Wesley, 2004.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Kerievsky, Joshua. *重构到模式*. 波士顿：Addison-Wesley, 2004.
- en: 'Martin, James. *Rapid Application Development*. Indianapolis: Macmillan, 1991.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Martin, James. *快速应用开发*. 印第安纳波利斯：Macmillan, 1991.
- en: 'Martin, Robert C. *Agile Software Development, Principles, Patterns, and Practices*.
    Upper Saddle River, NJ: Pearson Education, 2003.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Martin, Robert C. *敏捷软件开发，原则，模式与实践*. 上萨德尔河，新泽西州：Pearson Education, 2003.
- en: 'McConnell, Steve. *Code Complete*. 2nd ed. Redmond, WA: Microsoft Press, 2004.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: McConnell, Steve. *代码大全*. 第二版. 雷德蒙德，华盛顿：Microsoft Press, 2004.
- en: '———. *Rapid Development: Taming Wild Software Schedules*. Redmond, WA: Microsoft
    Press, 1996.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ———. *快速开发：驯服狂野的软件进度表*. 雷德蒙德，华盛顿：Microsoft Press, 1996.
- en: Mohammed, Nabil, Ali Munassar, and A. Govardhan. “A Comparison Between Five
    Models of Software Engineering.” *IJCSI International Journal of Computer Science
    Issues* 7, no. 5 (2010).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Mohammed, Nabil, Ali Munassar, 和 A. Govardhan. “五种软件工程模型的比较。” *IJCSI 国际计算机科学问题期刊*
    7，第5期（2010年）。
- en: 'Pressman, Robert S. *Software Engineering, A Practitioner’s Approach*. New
    York: McGraw-Hill, 2010.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Pressman, Robert S. *软件工程：实践者的方法*. 纽约：McGraw-Hill, 2010.
- en: 'Schwaber, Ken. *Agile Project Management with Scrum (Developer Best Practices)*.
    Redmond, WA: Microsoft Press, 2004.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: Schwaber, Ken. *Scrum敏捷项目管理（开发者最佳实践）*. 雷德蒙德，华盛顿：Microsoft Press, 2004.
- en: 'Shore, James, and Shane Warden. *The Art of Agile Development*. Sebastopol,
    CA: O’Reilly, 2007.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Shore, James，和 Shane Warden. *敏捷开发的艺术*. 塞巴斯托波尔，加利福尼亚州：O'Reilly, 2007.
- en: 'Stephens, Matt, and Doug Rosenberg. *Extreme Programming Refactored: The Case
    Against XP*. New York: Apress, 2003.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Stephens, Matt, 和 Doug Rosenberg. *极限编程重构：反对XP的案例*. 纽约：Apress, 2003.
- en: 'Wake, William C. *Refactoring Workbook*. Boston: Addison-Wesley Professional,
    2004.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Wake, William C. *重构工作簿*. 波士顿：Addison-Wesley Professional, 2004.
- en: 'Williams, Laurie, and Robert Kessler. *Pair Programming Illuminated*. Reading,
    MA: Addison-Wesley, 2003.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Williams, Laurie，和 Robert Kessler. *配对编程启示*. 雷丁，马萨诸塞州：Addison-Wesley, 2003.
