- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PROCESS-
    AND THREAD-CREATION NOTIFICATIONS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">进程和线程创建通知</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: Most modern EDR solutions rely heavily on functionality supplied through their
    *kernel-mode driver*, which is the sensor component running in a privileged layer
    of the operating system, beneath the user mode. These drivers give developers
    the ability to leverage features that are only available inside the kernel, supplying
    EDRs with many of their preventive features and telemetry.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代EDR解决方案在很大程度上依赖于其*内核模式驱动程序*提供的功能，内核模式驱动程序是运行在操作系统特权层下的传感器组件，位于用户模式之下。这些驱动程序使开发人员能够利用仅在内核中可用的功能，为EDR提供许多预防功能和遥测数据。
- en: While vendors can implement a vast number of security-relevant features in their
    drivers, the most common one is *notification callback routines*. These are internal
    routines that take actions when a designated system event occurs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然供应商可以在他们的驱动程序中实现大量与安全相关的功能，但最常见的功能是*通知回调例程*。这些是内部例程，当指定的系统事件发生时，它们会采取相应的措施。
- en: 'In the next three chapters, we’ll discuss how modern EDRs leverage notification
    callback routines to gain valuable insight into system events from the kernel.
    We’ll also cover the evasion techniques relevant to each type of notification
    and its related callback routines. This chapter focuses on two types of callback
    routines used very often in EDRs: those related to process creation and thread
    creation.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三章中，我们将讨论现代EDR如何利用通知回调例程，从内核中获取对系统事件的有价值的洞察力。我们还将介绍与每种通知类型及其相关回调例程相关的规避技术。本章重点讨论EDR中常用的两种回调例程：与进程创建和线程创建相关的回调例程。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Notification Callback Routines Work</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">通知回调例程的工作原理</samp>
- en: One of the most powerful features of drivers in the context of EDRs is the ability
    to be notified when a system event occurs. These system events might include creating
    or terminating new processes and threads, requesting to duplicate processes and
    threads, loading images, taking actions in the registry, or requesting a shutdown
    of the system. For example, a developer may want to know whether a process attempts
    to open a new handle to *lsass.exe*, because this is a core component of most
    credential-dumping techniques.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在EDR（端点检测和响应）领域，驱动程序的一个强大功能是能够在系统事件发生时获得通知。这些系统事件可能包括创建或终止新的进程和线程、请求复制进程和线程、加载图像、在注册表中执行操作或请求系统关闭。例如，开发人员可能想知道某个进程是否尝试打开一个新的*lsass.exe*句柄，因为这是大多数凭证转储技术的核心组件。
- en: To do this, the driver registers callback routines, which essentially just say,
    “Let me know if this type of event occurs on the system so I can do something.”
    As a result of these notifications, the driver can take action. Sometimes it might
    simply collect telemetry from the event notification. Alternatively, it might
    opt to do something like provide only partial access to the sensitive process,
    such as by returning a handle with a limited-access mask (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_QUERY_LIMITED_INFORMATION</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，驱动程序注册回调例程，这些例程基本上是在说：“如果系统发生这种类型的事件，请告诉我，这样我可以采取相应的行动。”由于这些通知，驱动程序可以采取相应的措施。有时它可能只是从事件通知中收集遥测数据。或者，它可能选择做一些事情，比如仅提供对敏感进程的部分访问权限，例如通过返回带有限制访问掩码的句柄（例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_QUERY_LIMITED_INFORMATION</samp>而不是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>）。
- en: Callback routines may be either *pre-operation*, occurring before the event
    completes, or *post-operation*, occurring after the operation. Pre-operation callbacks
    are more common in EDRs, as they give the driver the ability to interfere with
    the event or prevent it from completing, as well as other side benefits that we’ll
    discuss in this chapter. Post-operation callbacks are useful too, as they can
    provide information about the result of the system event, but they have some drawbacks.
    The largest of these is the fact that they’re often executed in an arbitrary thread
    context, making it difficult for an EDR to collect information about the process
    or thread that started the operation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 回调例程可以是*操作前*回调，发生在事件完成之前，或者是*操作后*回调，发生在操作完成之后。*操作前*回调在EDR中更为常见，因为它们赋予驱动程序干预事件或防止事件完成的能力，以及本章将讨论的其他附加好处。*操作后*回调也很有用，因为它们可以提供有关系统事件结果的信息，但也有一些缺点。最大的问题是，它们通常在任意线程上下文中执行，这使得EDR难以收集启动该操作的进程或线程的信息。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Process Notifications</samp>
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进程通知</samp>
- en: Callback routines can notify drivers whenever a process is created or terminated
    on the system. These notifications happen as an integral part of the process creation
    or termination. You can see this in [Listing 3-1](#list3-1), which shows the call
    stack for creation of a child process of *cmd.exe*, *notepad.exe*, that led to
    the notification of registered callback routines.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 回调例程可以在系统上创建或终止进程时通知驱动程序。这些通知作为进程创建或终止的一个重要组成部分发生。你可以在[清单 3-1](#list3-1)中看到这一点，该清单展示了创建*cmd.exe*、*notepad.exe*等子进程的调用堆栈，导致了已注册回调例程的通知。
- en: To obtain this call stack, use WinDbg to set a breakpoint (<samp class="SANS_TheSansMonoCd_W5Regular_11">bp</samp>)
    on <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspCallProcessNotifyRoutines()</samp>,
    the internal kernel function that notifies drivers with registered callbacks of
    process-creation events. When the breakpoint is hit, the <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>
    command returns the call stack for the process under which the break occurred.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得这个调用堆栈，可以使用WinDbg在<sup class="SANS_TheSansMonoCd_W5Regular_11">nt!PspCallProcessNotifyRoutines()</sup>上设置断点（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">bp</samp>），这是内核函数，用于通知注册的驱动程序进程创建事件。当断点被触发时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">k</samp>命令会返回发生断点的进程的调用堆栈。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 3-1: A process-creation call stack'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-1：进程创建调用堆栈
- en: Whenever a user wants to run an executable, *cmd.exe* calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd!ExecPgm()</samp>
    function. In this call stack, we can see this function calling the stub used to
    create a new process (at output line 07). This stub ends up making the syscall
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateUserProcess()</samp>,
    where control is transitioned to the kernel (at 04).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户想要运行一个可执行文件时，*cmd.exe*会调用<samp class="SANS_TheSansMonoCd_W5Regular_11">cmd!ExecPgm()</samp>函数。在这个调用堆栈中，我们可以看到这个函数调用了用于创建新进程的存根（在输出行07）。这个存根最终会调用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateUserProcess()</sup>的系统调用，控制权转交给内核（在04位置）。
- en: Now notice that, inside the kernel, another function is executed (at 00). This
    function is responsible for letting every registered callback know that a process
    is being created.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在注意，在内核内部，另一个函数被执行（在00位置）。这个函数负责通知每个已注册的回调，进程正在被创建。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering a Process
    Callback Routine</samp>
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">注册进程回调例程</samp>
- en: 'To register process callback routines, EDRs use one of the following two functions:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateProcessNotifyRoutineEx()</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateProcessNotifyRoutineEx2()</samp>.
    The latter can provide notifications about non-Win32 subsystem processes. These
    functions take a pointer to a callback function that will perform some action
    whenever a new process is created or terminated. [Listing 3-2](#list3-2) demonstrates
    how a callback function is registered.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注册进程回调例程，EDR使用以下两个函数之一：<samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateProcessNotifyRoutineEx()</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateProcessNotifyRoutineEx2()</samp>。后者可以提供有关非Win32子系统进程的通知。这些函数接受一个指向回调函数的指针，回调函数将在每次创建或终止新进程时执行。
    [清单 3-2](#list3-2)展示了如何注册回调函数。
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3-2: Registering a process-creation callback routine'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-2：注册进程创建回调例程
- en: This code registers the callback routine ❶ and passes three arguments to the
    registration function. The first, <samp class="SANS_TheSansMonoCd_W5Regular_11">PsCreateProcessNotifySubsystems</samp>,
    indicates the type of process notification that is being registered. At the time
    of this writing, “subsystems” is the only type that Microsoft documents. This
    value tells the system that the callback routine should be invoked for processes
    created across all subsystems, including Win32 and Windows Subsystem for Linux
    (WSL).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码注册回调例程❶并将三个参数传递给注册函数。第一个参数<samp class="SANS_TheSansMonoCd_W5Regular_11">PsCreateProcessNotifySubsystems</samp>指示正在注册的进程通知类型。在本文写作时，“子系统”是微软文档中唯一提到的类型。这个值告诉系统，回调例程应在所有子系统中创建的进程时被调用，包括Win32和Windows子系统Linux（WSL）。
- en: The next argument defines the entry point of the callback routine to be executed
    when the process is created. In our example, the code points to the internal <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ProcessNotifyCallbackRoutine()</samp>
    function. When process creation occurs, this callback function will receive information
    about the event, which we’ll discuss momentarily.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数定义了回调例程的入口点，该例程将在进程创建时执行。在我们的示例中，代码指向内部的<samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessNotifyCallbackRoutine()</samp>函数。当进程创建发生时，回调函数将接收有关该事件的信息，我们稍后将讨论这一点。
- en: The third argument is a Boolean value indicating whether the callback routine
    should be removed. Because we’re registering the routine in this example, the
    value is <samp class="SANS_TheSansMonoCd_W5Regular_11">FALSE</samp>. When we unload
    the driver, we’d set this to <samp class="SANS_TheSansMonoCd_W5Regular_11">TRUE</samp>
    to remove the callback from the system. After registering the callback routine,
    we define the callback function itself ❷.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是一个布尔值，表示是否应该移除回调例程。由于我们在这个示例中注册了回调例程，因此该值为<samp class="SANS_TheSansMonoCd_W5Regular_11">FALSE</samp>。当我们卸载驱动程序时，我们将其设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TRUE</samp>，以从系统中移除回调。注册回调例程后，我们定义回调函数本身❷。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Viewing the Callback
    Routines Registered on a System</samp>
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">查看系统上注册的回调例程</samp>
- en: You can use WinDbg to see a list of the process callback routines on your system.
    When a new callback routine is registered, a pointer to the routine is added to
    an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">EX_FAST_REF</samp> structures,
    which are 16-byte aligned pointers stored in an array at <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspCreateProcessNotifyRoutine</samp>,
    as shown in [Listing 3-3](#list3-3).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用WinDbg查看系统上进程回调例程的列表。当注册一个新的回调例程时，一个指向该例程的指针会被添加到一个<samp class="SANS_TheSansMonoCd_W5Regular_11">EX_FAST_REF</samp>结构体数组中，这些结构体是16字节对齐的指针，存储在位于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!PspCreateProcessNotifyRoutine</samp>的位置，如[清单
    3-3](#list3-3)所示。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 3-3: An array of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EX_FAST_REF</samp>
    structures containing the addresses of process- creation callback routines'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-3：一个包含进程创建回调例程地址的<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EX_FAST_REF</samp>结构体数组
- en: '[Listing 3-4](#list3-4) shows a way of iterating over this array of <samp class="SANS_TheSansMonoCd_W5Regular_11">EX_FAST_REF</samp>
    structures to enumerate drivers that implement process-notification callbacks.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-4](#list3-4)展示了遍历这个<samp class="SANS_TheSansMonoCd_W5Regular_11">EX_FAST_REF</samp>结构体数组的方法，以枚举实现进程通知回调的驱动程序。'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 3-4: Enumerating registered process-creation callbacks'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-4：枚举已注册的进程创建回调
- en: 'Here, we can see some of the routines registered on a default system. Note
    that some of these callbacks do not perform security functions. For instance,
    the one beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">tcpip</samp>
    is used in the TCP/IP driver. However, we do see that Microsoft Defender has a
    callback registered: <samp class="SANS_TheSansMonoCd_W5Regular_11">WdFilter</samp>+<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x45e00</samp>. (Microsoft doesn’t publish
    full symbols for the *WdFilter.sys* driver.) Using this technique, we could locate
    an EDR’s callback routine without needing to reverse engineer Microsoft’s driver.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一些在默认系统上注册的例程。请注意，其中一些回调并不执行安全功能。例如，以 <samp class="SANS_TheSansMonoCd_W5Regular_11">tcpip</samp>
    开头的回调用于 TCP/IP 驱动程序。然而，我们确实看到 Microsoft Defender 注册了一个回调：<samp class="SANS_TheSansMonoCd_W5Regular_11">WdFilter</samp>+<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x45e00</samp>。（Microsoft 没有发布 *WdFilter.sys*
    驱动程序的完整符号。）使用这种技术，我们可以在不需要逆向工程 Microsoft 驱动程序的情况下找到 EDR 的回调例程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Collecting Information
    from Process Creation</samp>
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">收集进程创建信息</samp>
- en: Once an EDR registers its callback routine, how does it access information?
    Well, when a new process is created, a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_CREATE_NOTIFY_INFO</samp>
    structure is passed to the callback. You can see the structure defined in [Listing
    3-5](#list3-5).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 EDR 注册了其回调例程，它如何访问信息呢？当新进程被创建时，一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_CREATE_NOTIFY_INFO</samp>
    结构的指针会传递给回调。你可以在[列表 3-5](#list3-5)中看到该结构的定义。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 3-5: The definition of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PS_CREATE_NOTIFY_INFO</samp>
    structure'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-5：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PS_CREATE_NOTIFY_INFO</samp>
    结构的定义
- en: 'This structure contains a significant amount of valuable data relating to process-creation
    events on the system. This data includes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构包含大量有关系统中进程创建事件的有价值数据。这些数据包括：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ParentProcessId</samp>   The parent
    process of the newly created process. This isn’t necessarily the one that created
    the new process.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ParentProcessId</samp>   新创建进程的父进程。这不一定是创建新进程的进程。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreatingThreadId</samp>   Handles
    to the unique thread and process responsible for creating the new process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreatingThreadId</samp>   指向负责创建新进程的唯一线程和进程的句柄。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FileObject</samp>   A pointer to
    the process’s executable file object (the image on disk).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FileObject</samp>   指向进程可执行文件对象的指针（磁盘上的镜像）。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ImageFileName</samp>   A pointer
    to a string containing the path to the newly created process’s executable file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ImageFileName</samp>   指向包含新创建进程可执行文件路径的字符串的指针。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CommandLine</samp>   The command
    line arguments passed to the creating process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CommandLine</samp>   传递给创建进程的命令行参数。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FileOpenNameAvailable</samp>   A
    value that specifies whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>
    member matches the filename used to open the new process’s executable file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FileOpenNameAvailable</samp>   一个值，指示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp> 成员是否与打开新进程可执行文件时使用的文件名匹配。
- en: One way that EDRs commonly interact with the telemetry returned from this notification
    is through Sysmon’s Event ID 1, the event for process creation, shown in [Figure
    3-1](#fig3-1).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: EDR 通常通过与此通知返回的遥测数据进行交互的方式之一是通过 Sysmon 的事件 ID 1，显示进程创建事件，如[图 3-1](#fig3-1)所示。
- en: '![](../images/Figure3-1.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: Sysmon Event ID
    1 showing process creation</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-1：显示进程创建的 Sysmon 事件 ID 1</samp>
- en: In this event, we can see some of the information from the <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_CREATE
    _NOTIFY_INFO</samp> structure passed to Sysmon’s callback routine. For example,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentProcessId</samp> properties
    in the event translate to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentProcessId</samp>
    members of the structure, respectively.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个事件中，我们可以看到从 <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_CREATE _NOTIFY_INFO</samp>
    结构体传递给 Sysmon 回调例程的一些信息。例如，事件中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentProcessId</samp>
    属性，分别对应结构体中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentProcessId</samp>
    成员。
- en: You may be wondering why there are so many more properties in this event than
    there are in the structure received by the callback. The driver collects these
    supplemental pieces of information by investigating the context of the thread
    under which the event was generated and expanding on members of the structure.
    For instance, if we know the ID of the process’s parent, we can easily find the
    parent’s image path to populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentImage</samp>
    property.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么这个事件中的属性比回调函数接收到的结构体中要多得多。驱动程序通过调查生成事件的线程上下文，并扩展结构体的成员，来收集这些额外的信息。例如，如果我们知道进程父进程的
    ID，就可以轻松找到父进程的图像路径，从而填充 <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentImage</samp>
    属性。
- en: By leveraging the data collected from this event and the associated structure,
    EDRs can also create internal mappings of process attributes and relationships
    in order to detect suspicious activity, such as Microsoft Word spawning a *powershell.exe*
    child. This data could also provide the agent with useful context for determining
    whether other activity is malicious. For example, the agent could feed process
    command line arguments into a machine learning model to figure out whether the
    command’s invocation is unusual in the environment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用从此事件及其相关结构体中收集的数据，EDR 还可以创建进程属性和关系的内部映射，以便检测可疑活动，例如 Microsoft Word 启动 *powershell.exe*
    子进程。此数据还可以为代理提供有用的上下文，以确定其他活动是否具有恶意性质。例如，代理可以将进程的命令行参数输入到机器学习模型中，以确定该命令在环境中的调用是否异常。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Thread Notifications</samp>
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">线程通知</samp>
- en: Thread-creation notifications are somewhat less valuable than process-creation
    events. They work relatively similarly, occurring during the creation process,
    but they receive less information. This is true despite the fact that thread creation
    happens substantially more often; after all, nearly every process supports multithreading,
    meaning that there will be more than one thread-creation notification for every
    process creation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 线程创建通知的价值稍逊于进程创建事件。它们的工作原理相似，发生在创建过程中，但接收到的信息较少。尽管线程创建发生得更为频繁，这一点依然成立；毕竟几乎每个进程都支持多线程，这意味着每个进程创建时都会有多个线程创建通知。
- en: Although thread-creation callbacks pass far less data to the callback, they
    do provide the EDR with another datapoint against which detections can be built.
    Let’s explore them a little further.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管线程创建回调传递给回调的数据显示得更少，但它们为 EDR 提供了另一个数据点，用于构建检测模型。让我们进一步探讨一下这些数据。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering a Thread
    Callback Routine</samp>
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">注册线程回调例程</samp>
- en: 'When a thread is created or terminated, the callback routine receives three
    pieces of data: the ID of the process to which the thread belongs, the unique
    thread ID, and a Boolean value indicating whether the thread is being created.
    [Listing 3-6](#list3-6) shows how a driver would register a callback routine for
    thread-creation events.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程被创建或终止时，回调例程会接收到三条数据：线程所属进程的 ID、唯一的线程 ID，以及一个布尔值，表示线程是否正在创建。[列表 3-6](#list3-6)
    显示了驱动程序如何为线程创建事件注册回调例程。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 3-6: Registration of a thread-creation notification routine'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-6：注册线程创建通知例程
- en: As with process creation, an EDR can receive notifications about thread creation
    or termination via its driver by registering a thread-notification callback routine
    with either <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateThreadNotifyRoutine()</samp>
    or the extended <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateThreadNotifyRoutineEx()</samp>,
    which adds the ability to define the notification type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与进程创建类似，EDR 可以通过其驱动程序接收有关线程创建或终止的通知，方法是通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateThreadNotifyRoutine()</samp>
    或扩展版的 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateThreadNotifyRoutineEx()</samp>
    注册线程通知回调例程，后者可以定义通知类型。
- en: This example driver first registers the callback routine ❶, passing in a pointer
    to the internal callback function, which receives the same three pieces of data
    passed to process callback routines. If the Boolean indicating whether the thread
    is being created or terminated is <samp class="SANS_TheSansMonoCd_W5Regular_11">TRUE</samp>,
    the driver performs some action defined by the developer ❷. Otherwise, the callback
    would simply ignore the thread events, as thread-termination events (which occur
    when a thread completes its execution and returns) are generally less valuable
    for security monitoring.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例驱动程序首先注册回调例程 ❶，传入指向内部回调函数的指针，该函数接收与处理回调例程相同的三项数据。如果表示线程是否正在创建或终止的布尔值为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TRUE</samp>，则驱动程序会执行开发者定义的一些操作 ❷。否则，回调函数将忽略线程事件，因为线程终止事件（即线程完成执行并返回时发生的事件）通常对安全监控的价值较低。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detecting Remote
    Thread Creation</samp>
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">检测远程线程创建</samp>
- en: 'Despite providing less information than process-creation callbacks, thread-creation
    notifications offer the EDR data about something other callbacks can’t detect:
    remote thread creation. *Remote thread creation* occurs when one process creates
    a thread inside another process. This technique is core to a ton of attacker tradecraft,
    which often relies on changing the execution context (as in going from user 1
    to user 2). [Listing 3-7](#list3-7) shows how an EDR could detect this behavior
    with its thread-creation callback routine.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管线程创建通知提供的信息少于进程创建回调，但它们为 EDR 提供了其他回调无法检测到的数据：远程线程创建。*远程线程创建*发生在一个进程在另一个进程内创建线程时。这种技术是许多攻击者技巧的核心，通常依赖于更改执行上下文（例如，从用户
    1 切换到用户 2）。[列表 3-7](#list3-7) 展示了 EDR 如何通过其线程创建回调例程检测此行为。
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 3-7: Detecting remote thread creation'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-7：检测远程线程创建
- en: 'Because the notification executes in the context of the process creating the
    thread, developers can simply check whether the current process ID matches the
    one passed to the callback routine ❶. If not, the thread is being created remotely
    and should be investigated. That’s it: a huge capability, provided through one
    or two lines of code. It doesn’t get much better than that. You can see this feature
    implemented in real life through Sysmon’s Event ID 8, shown in [Figure 3-2](#fig3-2).
    Notice that the <samp class="SANS_TheSansMonoCd_W5Regular_11">SourceProcessId</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetProcessId</samp> values
    differ.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因为通知是在创建线程的进程上下文中执行的，所以开发人员可以简单地检查当前的进程 ID 是否与传递给回调例程的 ID 相匹配 ❶。如果不匹配，则说明线程正在远程创建，需要进一步调查。就这样：一个巨大的能力，只需一两行代码就能实现。没有比这更简单的了。你可以通过
    Sysmon 的事件 ID 8 实际看到此功能的实现，如[图 3-2](#fig3-2)所示。注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">SourceProcessId</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetProcessId</samp> 的值不同。
- en: '![](../images/Figure3-2.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: Sysmon Event ID
    8 detecting remote thread creation</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-2：Sysmon 事件 ID 8 检测远程线程创建</samp>
- en: Of course, remote thread creation happens under a number of legitimate circumstances.
    One example is child process creation. When a process is created, the first thread
    executes in the context of the parent process. To account for this, many EDRs
    simply disregard the first thread associated with a process.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，远程线程创建也会在一些合法情况下发生。一个例子是子进程创建。当一个进程被创建时，第一个线程在父进程的上下文中执行。为了解决这个问题，许多 EDR
    会简单地忽略与进程关联的第一个线程。
- en: Certain internal operating system components also perform legitimate remote
    thread creation. An example of this is Windows Error Reporting (*werfault.exe*).
    When an error has occurred on the system, the operating system spawns *werfault.exe*
    as a child of *svchost.exe* (specifically, the *WerSvc* service) and then injects
    into the faulting process.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 某些操作系统内部组件也会执行合法的远程线程创建。一个例子是Windows错误报告（*werfault.exe*）。当系统发生错误时，操作系统会生成*werfault.exe*作为*svchost.exe*（特别是*WerSvc*服务）的子进程，然后将其注入故障进程。
- en: Thus, the fact that a thread was created remotely doesn’t automatically make
    it malicious. To determine this, the EDR has to collect supplemental information,
    as shown in Sysmon Event ID 8.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，线程是远程创建的这一事实并不自动意味着它是恶意的。要确定这一点，EDR需要收集补充信息，如Sysmon事件ID 8所示。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading Process- and Thread-Creation
    Callbacks</samp>
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">规避进程和线程创建回调</samp>
- en: Process and thread notifications have the most associated detections of all
    callback types. This is partly due to the fact that the information they provide
    is critical to most process-oriented detection strategies and is used by almost
    every commercial EDR product. They’re also generally the easiest to understand.
    This isn’t to say that they’re also easy to evade. However, there is no shortage
    of procedures we can follow to increase our chances of slipping through the cracks
    somewhere.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 进程和线程通知是所有回调类型中最常见的检测方式。这部分归因于它们提供的信息对于大多数面向进程的检测策略至关重要，并且几乎被所有商业化的EDR产品所使用。它们通常也是最容易理解的。这并不意味着它们也很容易被规避。然而，我们有很多方法可以增加在某些环节成功避开的机会。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Command Line Tampering</samp>
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">命令行篡改</samp>
- en: Some of the most commonly monitored attributes of process-creation events are
    the command line arguments with which the process was invoked. Certain detection
    strategies are even built entirely around specific command line arguments associated
    with a known offensive tool or piece of malware.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 进程创建事件中最常见的监控属性之一是启动进程时使用的命令行参数。某些检测策略甚至完全依赖于与已知攻击工具或恶意软件相关的特定命令行参数。
- en: EDRs can find arguments in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp>
    member of the structure passed to a process-creation callback routine. When a
    process is created, its command line arguments are stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    field of its process environment block (PEB). This field contains a pointer to
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">RTL_USER_PROCESS_PARAMETERS</samp>
    structure that contains, among other things, a <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>
    with the parameters passed to the process at invocation. [Listing 3-8](#list3-8)
    shows how we could manually retrieve a process’s command line arguments with WinDbg.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: EDR可以在传递给进程创建回调例程的结构体中的<samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp>成员中找到参数。当创建进程时，其命令行参数会存储在其进程环境块（PEB）的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>字段中。该字段包含指向<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RTL_USER_PROCESS_PARAMETERS</samp>结构体的指针，其中包含其他信息，包括在调用时传递给进程的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>参数。[清单3-8](#list3-8)展示了我们如何使用WinDbg手动获取进程的命令行参数。
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 3-8: Retrieving parameters from the PEB with WinDbg'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 清单3-8：使用WinDbg从PEB中提取参数
- en: In this example, we extract the parameters from the current process’s PEB by
    directly accessing the buffer member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>,
    which makes up the <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp>
    member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    field.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: "在这个示例中，我们通过直接访问<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">UNICODE_STRING</samp>的缓冲区成员，提取当前进程的PEB中的参数，这个缓冲区成员构成了<samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">ProcessParameters</samp>字段中的<\tsamp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">CommandLine</samp>成员。"
- en: However, because the PEB resides in the process’s user-mode memory space and
    not in the kernel, a process can change attributes of its own PEB. Adam Chester’s
    “How to Argue like Cobalt Strike” blog post details how to modify the command
    line arguments for a process. Before we cover this technique, you should understand
    what it looks like when a normal program creates a child process. [Listing 3-9](#list3-9)
    contains a simple example of this behavior.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 PEB 位于进程的用户模式内存空间中，而非内核中，进程可以更改其自身 PEB 的属性。Adam Chester 的《如何像 Cobalt Strike
    一样辩论》博客文章详细介绍了如何修改进程的命令行参数。在我们介绍这一技术之前，你应该了解当一个普通程序创建子进程时的表现。[列表 3-9](#list3-9)
    中包含了这一行为的一个简单示例。
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 3-9: Typical child-process creation'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-9：典型的子进程创建
- en: This basic implementation spawns a child process of *cmd.exe* with the arguments
    “These are my sensitive arguments.” When the process is executed, any standard
    process-monitoring tool should see this child process and its unmodified arguments
    by reading them from the PEB. For example, in [Figure 3-3](#fig3-3), we use a
    tool called Process Hacker to extract command line parameters.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本实现生成了一个带有参数“这些是我的敏感参数”的 *cmd.exe* 子进程。当该进程执行时，任何标准的进程监控工具都应能通过读取 PEB 中的内容看到该子进程及其未修改的参数。例如，在
    [图 3-3](#fig3-3) 中，我们使用名为 Process Hacker 的工具来提取命令行参数。
- en: '![](../images/Figure3-3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: Command line arguments
    retrieved from the PEB</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-3：从 PEB 中获取的命令行参数</samp>
- en: As expected, *cmd.exe* was spawned with our string of five arguments passed
    to it. Let’s keep this example in mind; it will serve as our benign baseline as
    we start trying to hide our malware.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，*cmd.exe* 被创建并传递给它五个参数的字符串。让我们记住这个例子；它将作为我们开始尝试隐藏恶意软件时的无害基准。
- en: Chester’s blog post describes the following process for modifying the command
    line arguments used to invoke a process. First, you create the child process in
    a suspended state using your malicious arguments. Next, you use <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryInformationProcess()</samp>
    to get the address of the child process’s PEB, and you copy it by calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!ReadProcessMemory()</samp>. You
    retrieve its <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    field and overwrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>
    represented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp>
    member pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    with spoofed arguments. Lastly, you resume the child process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Chester 的博客文章描述了修改用于调用进程的命令行参数的以下过程。首先，使用恶意参数以挂起状态创建子进程。接着，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryInformationProcess()</samp>
    获取子进程 PEB 的地址，并通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!ReadProcessMemory()</samp>
    复制该地址。然后，获取其 <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    字段，并用伪造的参数覆盖由 <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    指向的 <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp> 成员所表示的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>。最后，恢复子进程的执行。
- en: Let’s overwrite the original arguments from [Listing 3-9](#list3-9) with the
    argument string “Spoofed arguments passed instead.” [Listing 3-10](#list3-10)
    shows this behavior in action, with the updates in bold.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用参数字符串“伪造的参数传递替代原始参数”来覆盖 [列表 3-9](#list3-9) 中的原始参数。[列表 3-10](#list3-10) 展示了这一行为，更新部分以粗体显示。
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 3-10: Overwriting command line arguments'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-10：覆盖命令行参数
- en: When we create our process, we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_SUSPENDED</samp>
    flag to the function to start it in a suspended state. Next, we need to get the
    address of the process’s parameters in the PEB. We’ve omitted this code from [Listing
    3-10](#list3-10) for brevity, but the way to do this is to use <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryInformationProcess()</samp>,
    passing in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessBasicInformation</samp>
    information class. This should return a <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_BASIC_INFORMATION</samp>
    structure that contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">PebBaseAddress</samp>
    member.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建进程时，我们向函数传递了<samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_SUSPENDED</samp>标志以便在挂起状态下启动它。接下来，我们需要获取进程参数在PEB中的地址。为了简洁起见，我们省略了[清单
    3-10](#list3-10)中的这段代码，但做法是使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryInformationProcess()</samp>，并传递<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ProcessBasicInformation</samp>信息类。这应该会返回一个包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PebBaseAddress</samp>成员的<samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_BASIC_INFORMATION</samp>结构体。
- en: We can then read our child process’s PEB into a buffer that we allocate locally.
    Using this buffer, we extract the parameters and pass in the address of the PEB.
    Then we use <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    to copy it into another local buffer. In our code, this final buffer is called
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pParameters</samp> and is cast as
    a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">RTL_USER_PROCESS_PARAMETERS</samp>
    structure. We overwrite the existing parameters with a new string via a call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!WriteProcessMemory()</samp>.
    Assuming that this all completed without error, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!ResumeThread()</samp>
    to allow our suspended child process to finish initialization and begin executing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将子进程的PEB读取到我们本地分配的缓冲区中。使用这个缓冲区，我们提取参数并传入PEB的地址。接着，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>将其复制到另一个本地缓冲区中。在我们的代码中，这个最终的缓冲区叫做<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pParameters</samp>，并将其强制转换为指向<samp class="SANS_TheSansMonoCd_W5Regular_11">RTL_USER_PROCESS_PARAMETERS</samp>结构体的指针。我们通过调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!WriteProcessMemory()</samp>用一个新字符串覆盖现有参数。如果一切顺利完成没有错误，我们调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!ResumeThread()</samp>，让我们的挂起子进程完成初始化并开始执行。
- en: Process Hacker now shows the spoofed argument values, as you can see in [Figure
    3-4](#fig3-4).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Process Hacker 显示了伪造的参数值，正如你在[图 3-4](#fig3-4)中看到的那样。
- en: '![](../images/Figure3-4.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: Command line arguments
    overwritten with spoofed values</samp>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-4：命令行参数被伪造的值覆盖</samp>
- en: While this technique remains one of the more effective ways to evade detection
    based on suspicious command line arguments, it has a handful of limitations. One
    such limitation is that a process can’t change its own command line arguments.
    This means that if we don’t have control of the parent process, as in the case
    of an initial access payload, the process must execute with the original arguments.
    Additionally, the value used to overwrite the suspicious arguments in the PEB
    must be longer than the original value. If it is shorter, the overwrite will be
    incomplete, and portions of the suspicious arguments will remain. [Figure 3-5](#fig3-5)
    shows this limitation in action.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种技术仍然是基于可疑命令行参数避开检测的有效方式之一，但它也有一些局限性。其中一个局限是，进程不能更改自己的命令行参数。这意味着，如果我们不能控制父进程，比如在初始访问负载的情况下，进程必须使用原始参数执行。此外，用于覆盖PEB中可疑参数的值必须比原始值长。如果它较短，覆盖将不完整，可疑参数的部分内容将保留。[图
    3-5](#fig3-5)展示了这一局限的实际情况。
- en: '![](../images/Figure3-5.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-5: Command line arguments
    partially overwritten</samp>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-5：命令行参数部分被覆盖</samp>
- en: 'Here, we have shortened our arguments to the value “Spoofed arguments.” As
    you can see, it replaced only part of the original arguments. The inverse is also
    true: if the length of the spoofed value is greater than that of the original
    arguments, the spoofed arguments will be truncated.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将参数缩短为“伪造的参数”值。如你所见，它只替换了原始参数的一部分。反之亦然：如果伪造值的长度大于原始参数的长度，伪造的参数将被截断。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parent Process ID
    Spoofing</samp>
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">父进程ID伪造</samp>
- en: Nearly every EDR has some way of correlating parent–child processes on the system.
    This allows the agent to identify suspicious process relationships, such as Microsoft
    Word spawning *rundll32.exe*, which could indicate an attacker’s initial access
    or their successful exploitation of a service.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个EDR都有某种方式来关联系统上的父子进程。这使得代理能够识别可疑的进程关系，例如Microsoft Word生成*rundll32.exe*，这可能表明攻击者的初次访问或成功利用了某项服务。
- en: Thus, in order to hide malicious behavior on the host, attackers often wish
    to spoof their current process’s parent. If we can trick an EDR into believing
    that our malicious process creation is actually normal, we’re substantially less
    likely to be detected. The most common way to accomplish this is by modifying
    the child’s process and thread attribute list, a technique popularized by Didier
    Stevens in 2009\. This evasion relies on the fact that, on Windows, children inherit
    certain attributes from parent processes, such as the current working directory
    and environment variables. No dependencies exist between parent and child processes;
    therefore, we can specify a parent process somewhat arbitrarily, as this section
    will cover.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了隐藏主机上的恶意行为，攻击者通常希望伪造当前进程的父进程。如果我们能够欺骗EDR，使其认为我们的恶意进程创建实际上是正常的，那么我们被检测到的可能性将大大降低。实现这一点的最常见方法是修改子进程和线程的属性列表，这一技术是由Didier
    Stevens在2009年推广的。这种规避依赖于Windows上的一个事实，即子进程继承了来自父进程的某些属性，比如当前工作目录和环境变量。父进程和子进程之间没有依赖关系；因此，我们可以在某种程度上任意指定父进程，正如本节将要讨论的那样。
- en: To better understand this strategy, let’s dig into process creation on Windows.
    The primary API used for this purpose is the aptly named <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp>
    API. This function is defined in [Listing 3-11](#list3-11).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一策略，我们需要深入了解Windows上的进程创建。用于此目的的主要API是名副其实的<samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp>
    API。此函数在[清单3-11](#list3-11)中定义。
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 3-11: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!CreateProcess()</samp>
    API definition'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 清单3-11：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!CreateProcess()</samp>
    API定义
- en: The ninth parameter passed to this function is a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFO</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFOEX</samp> structure.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFOEX</samp> structure,
    which is defined in [Listing 3-12](#list3-12), extends the basic startup information
    structure by adding a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD_ATTRIBUTE_LIST</samp>
    structure.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给此函数的第九个参数是指向<samp class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFO</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFOEX</samp>结构的指针。<samp class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFOEX</samp>结构在[清单3-12](#list3-12)中定义，通过添加指向<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD_ATTRIBUTE_LIST</samp>结构的指针，扩展了基本的启动信息结构。
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 3-12: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">STARTUPINFOEX</samp>
    structure definition'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 清单3-12：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">STARTUPINFOEX</samp>结构定义
- en: When creating our process, we can make a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!InitializeProcThreadAttributeList()</samp>
    to initialize the attribute list and then make a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!UpdateProcThreadAttribute()</samp>
    to modify it. This allows us to set custom attributes of the process to be created.
    When spoofing the parent process, we’re interested in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</samp>
    attribute, which indicates that a handle to the desired parent process is being
    passed. To get this handle, we must obtain a handle to the target process, by
    either opening a new one or leveraging an existing one.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建进程时，我们可以调用<samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!InitializeProcThreadAttributeList()</samp>来初始化属性列表，然后调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!UpdateProcThreadAttribute()</samp>来修改它。这使我们能够设置要创建的进程的自定义属性。在伪造父进程时，我们关注的是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</samp>属性，该属性指示正在传递目标父进程的句柄。为了获得这个句柄，我们必须通过打开一个新进程或利用现有的进程来获取目标进程的句柄。
- en: '[Listing 3-13](#list3-13) shows an example of process spoofing to tie all these
    pieces together. We’ll modify the attributes of the Notepad utility so that VMware
    Tools appears to be its parent process.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-13](#list3-13)展示了一个进程伪装的示例，将这些内容结合在一起。我们将修改记事本工具的属性，使 VMware Tools 看起来像是它的父进程。'
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 3-13: An example of spoofing a parent process'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-13：伪装父进程的示例
- en: We first hardcode the process ID ❶ of *vmtoolsd.exe*, our desired parent. In
    the real world, we might instead use logic to find the ID of the parent we’d like
    to spoof, but I’ve opted not to include this code in the example for the sake
    of brevity. Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SpoofParent()</samp>
    function makes a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!OpenProcess()</samp>
    ❷. This function is responsible for opening a new handle to an existing process
    with the access rights requested by the developer. In most offensive tools, you
    may be used to seeing this function used with arguments like <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_READ</samp>,
    to read the process’s memory, or <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>,
    which gives us full control over the process. In this example, however, we request
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_CREATE_PROCESS</samp>. We’ll
    need this access right in order to use the target process as a parent with our
    externed startup information structure. When the function completes, we’ll have
    a handle to *vmtoolsd.exe* with the appropriate rights.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将*vmtoolsd.exe*的进程 ID ❶硬编码为我们想要的父进程。在实际应用中，我们可能会使用逻辑来查找我们想要伪装的父进程的 ID，但为了简洁起见，我没有在这个示例中包含这部分代码。接下来，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SpoofParent()</samp> 函数调用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!OpenProcess()</samp>
    ❷。这个函数负责以开发者请求的访问权限打开一个已存在进程的新句柄。在大多数攻击性工具中，你可能习惯看到这个函数使用诸如 <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_READ</samp>
    这样的参数来读取进程的内存，或者使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>，这会让我们对进程拥有完全控制。然而，在这个示例中，我们请求的是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_CREATE_PROCESS</samp>。我们需要这个访问权限，以便使用目标进程作为父进程，并与我们的外部启动信息结构一起使用。当函数执行完毕后，我们将拥有一个具有适当权限的
    *vmtoolsd.exe* 句柄。
- en: The next thing we need to do is create and populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD
    _ATTRIBUTE_LIST</samp> structure. To do this, we use a pretty common Windows programming
    trick to get the size of a structure and allocate the correct amount of memory
    to it. We call the function to initialize the attribute list ❸, passing in a null
    pointer instead of the address of the real attribute list. However, we still pass
    in a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">DWORD</samp>,
    which will hold the size required after completion. We then use the size stored
    in this variable to allocate memory on the heap with <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!HeapAlloc()</samp>
    ❹. Now we can call the attribute list initialization function again, passing in
    a pointer to the heap allocation we just created.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要做的是创建并填充 <samp class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD _ATTRIBUTE_LIST</samp>
    结构体。为此，我们使用一个常见的 Windows 编程技巧来获取结构体的大小并分配相应的内存。我们调用函数初始化属性列表 ❸，传入一个空指针，而不是传入实际属性列表的地址。然而，我们仍然会传入一个指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DWORD</samp> 类型的指针，用来存储完成后所需的大小。然后，我们使用这个变量中存储的大小，利用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!HeapAlloc()</samp> ❹ 在堆上分配内存。现在，我们可以再次调用属性列表初始化函数，传入刚刚创建的堆分配内存的指针。
- en: At this point, we’re ready to start spoofing. We do this by first calling the
    function for modifying the attribute list and passing in the attribute list itself,
    the flag indicating a handle to the parent process, and the handle we opened to
    *vmtoolsd.exe* ❺. This sets *vmtoolsd.exe* as the parent process of whatever we
    create using this attribute list. The last thing we need to do with our attribute
    list is pass it as input to the process-creation function, specifying the child
    process to create and the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXTENDED_STARTUPINFO_PRESENT</samp>
    flag. When this function is executed, *notepad.exe* will appear to be a child
    of *vmtoolsd.exe* in Process Hacker rather than a child of its true parent, *ppid-spoof.exe*
    ([Figure 3-6](#fig3-6)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们准备开始进行伪造。我们通过首先调用修改属性列表的函数，传递属性列表本身、指示父进程句柄的标志以及我们为*vmtoolsd.exe*打开的句柄❺来实现这一点。这将*vmtoolsd.exe*设置为我们使用此属性列表创建的任何进程的父进程。我们需要做的最后一件事是将属性列表作为输入传递给进程创建函数，指定要创建的子进程以及<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EXTENDED_STARTUPINFO_PRESENT</samp>标志。当这个函数被执行时，*notepad.exe*将出现在Process
    Hacker中作为*vmtoolsd.exe*的子进程，而不是其真实父进程*ppid-spoof.exe*的子进程（[图3-6](#fig3-6)）。
- en: '![](../images/Figure3-6.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-6: A spoofed parent
    process in Process Hacker</samp>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-6：Process Hacker中的伪造父进程</samp>
- en: 'Unfortunately for adversaries, this evasion technique is relatively simple
    to detect in a few ways. The first is by using the driver. Remember that the structure
    passed to the driver on a process-creation event contains two separate fields
    related to parent processes: <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentProcessId</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CreatingThreadId</samp>. While
    these two fields will point to the same process in most normal circumstances,
    when the parent process ID (PPID) of a new process is spoofed, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreatingThreadId.UniqueProcess</samp>
    field will contain the PID of the process that made the call to the process-creation
    function. [Listing 3-14](#list3-14) shows the output from a mock EDR driver captured
    by DbgView, a tool used to capture debug print messages.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于攻击者来说，这种规避技术有几种方法可以相对简单地检测到。首先是通过使用驱动程序。记住，在进程创建事件中传递给驱动程序的结构包含两个与父进程相关的独立字段：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ParentProcessId</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">CreatingThreadId</samp>。虽然在大多数正常情况下，这两个字段会指向相同的进程，但当新进程的父进程
    ID（PPID）被伪造时，<samp class="SANS_TheSansMonoCd_W5Regular_11">CreatingThreadId.UniqueProcess</samp>字段将包含调用进程创建函数的进程的PID。[列表
    3-14](#list3-14)显示了通过DbgView捕获的模拟EDR驱动程序的输出，DbgView是一个用于捕获调试打印消息的工具。
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 3-14: Capturing parent and creator process information from a driver'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-14：从驱动程序捕获父进程和创建者进程信息
- en: You can see here that the spoofed *vmtoolsd.exe* shows up as the parent process,
    but the creator (the true process that launched *notepad.exe*) is identified as
    *ppid-spoof.exe*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到，伪造的*vmtoolsd.exe*作为父进程出现，但创建者（真正启动*notepad.exe*的进程）被识别为*ppid-spoof.exe*。
- en: Another approach to detecting PPID spoofing uses ETW (a topic we’ll explore
    further in [Chapter 8](chapter8.xhtml)). F-Secure has extensively documented this
    technique in its “Detecting Parent PID Spoofing” blog post. This detection strategy
    relies on the fact that the process ID specified in the ETW event header is the
    creator of the process, rather than the parent process specified in the event
    data. Thus, in our example, defenders could use an ETW trace to capture process-creation
    events on the host whenever *notepad.exe* is spawned. [Figure 3-7](#fig3-7) shows
    the resulting event data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种检测PPID伪造的方法是使用ETW（我们将在[第8章](chapter8.xhtml)中进一步探讨）。F-Secure在其“检测父PID伪造”博客文章中详细记录了这一技术。这种检测策略依赖于ETW事件头中指定的进程ID是进程的创建者，而不是事件数据中指定的父进程。因此，在我们的例子中，防御者可以使用ETW跟踪捕获每当*notepad.exe*被启动时的进程创建事件。[图3-7](#fig3-7)显示了生成的事件数据。
- en: '![](../images/Figure3-7.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-7: A spoofed parent
    process in ETW event data</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-7：ETW事件数据中的伪造父进程</samp>
- en: Highlighted in [Figure 3-7](#fig3-7) is the process ID of *vmtoolsd.exe*, the
    spoofed parent. If you compare this to the event header, shown in [Figure 3-8](#fig3-8),
    you can see the discrepancy.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图3-7](#fig3-7)中高亮显示的是*vmtoolsd.exe*的进程ID，即伪造的父进程。如果你将其与[图3-8](#fig3-8)中显示的事件头进行比较，就能看到不一致之处。
- en: '![](../images/Figure3-8.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-8: A creator process
    ID captured in an ETW event header</samp>'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-8：在 ETW 事件头中捕获的创建者进程 ID</samp>
- en: Note the difference in the two process IDs. While the event data had the ID
    of *vmtoolsd.exe*, the header contains the ID of *ppid-spoof.exe*, the true creator.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意两个进程 ID 之间的差异。虽然事件数据中包含的是*vmtoolsd.exe*的 ID，但头部包含的是*ppid-spoof.exe*的 ID，即真正的创建者。
- en: 'The information from this ETW provider isn’t quite as detailed as the information
    provided to us by the mock EDR driver in [Listing 3-14](#list3-14). For example,
    we’re missing the image name for both the parent and creator processes. This is
    because the ETW provider doesn’t derive that information for us, like the driver
    does. In the real world, we’d likely need to add a step to retrieve that information,
    by either querying the process or pulling it from another data source. Regardless,
    we can still use this technique as a way to detect PPID spoofing, as we have the
    core piece of information needed for the strategy: mismatched parent and creator
    process IDs.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 来自该 ETW 提供程序的信息并不像[清单 3-14](#list3-14)中由模拟 EDR 驱动程序提供的信息那样详细。例如，我们缺少父进程和创建者进程的映像名称。这是因为
    ETW 提供程序没有为我们提取这些信息，就像驱动程序所做的那样。在实际情况中，我们可能需要添加一个步骤来检索这些信息，可以通过查询进程或从其他数据源中提取。无论如何，我们仍然可以使用这种技术来检测
    PPID 欺骗，因为我们拥有策略所需的核心信息：不匹配的父进程和创建者进程 ID。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Process-Image Modification</samp>
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">进程映像修改</samp>
- en: In many cases, malware wishes to evade *image-based* detection, or detections
    built on the name of the file being used to create the process. While there are
    many ways to accomplish this, one tactic, which we’ll call *process-image modification*,
    has gained substantial traction since 2017, although prolific threat groups have
    used it since at least 2014\. In addition to hiding the execution of the malware
    or tooling, this tactic could allow attackers to bypass application whitelisting,
    evade per-application host firewall rules, or pass security checks against the
    calling image before a server allows a sensitive operation to occur.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，恶意软件希望避开*基于映像*的检测，或者避开基于用于创建进程的文件名的检测。虽然有许多方法可以实现这一点，但一种策略——我们称之为*进程映像修改*——自
    2017 年以来获得了广泛关注，尽管至少从 2014 年起，就有一些活跃的威胁组织使用了这一手段。除了隐藏恶意软件或工具的执行外，这一策略还可能帮助攻击者绕过应用程序白名单、规避每应用程序的主机防火墙规则，或在服务器允许敏感操作发生之前通过安全检查。
- en: 'This section covers four process-image modification techniques, namely hollowing,
    doppelgänging, herpaderping, and ghosting, all of which achieve their goal in
    roughly the same way: by remapping the host process’s original image with its
    own. These techniques also all rely on the same design decision made by Microsoft
    while implementing the logic for notifying registered callbacks of a process being
    created.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖四种进程映像修改技术，即 hollowing、doppelgänging、herpaderping 和 ghosting，所有这些技术都通过大致相同的方式实现其目标：通过将宿主进程的原始映像重新映射为自己的映像。这些技术还都依赖于微软在实现通知已注册回调的进程创建逻辑时做出的相同设计决策。
- en: 'The design decision is this: process creation on Windows involves a complex
    set of steps, many of which occur before the kernel notifies any drivers. As a
    result, attackers have an opportunity to modify the process’s attributes in some
    way during those early steps. Here is the entire process-creation workflow, with
    the notification step shown in bold:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 设计决策如下：Windows 上的进程创建涉及一系列复杂的步骤，其中许多步骤发生在内核通知任何驱动程序之前。因此，攻击者有机会在这些早期步骤中以某种方式修改进程的属性。以下是整个进程创建工作流程，其中通知步骤以粗体显示：
- en: 1. Validate parameters passed to the process-creation API.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 验证传递给进程创建 API 的参数。
- en: 2. Open a handle to the target image.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 打开目标映像的句柄。
- en: 3. Create a section object from the target image.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 从目标映像创建一个节对象。
- en: 4. Create and initialize a process object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 创建并初始化进程对象。
- en: 5. Allocate the PEB.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 分配 PEB。
- en: 6\. Create and initialize the thread object.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 创建并初始化线程对象。
- en: '**7. Send the process-creation notification to the registered callbacks.**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**7. 将进程创建通知发送到已注册的回调。**'
- en: 8. Perform Windows subsystem-specific operations to finish initialization.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 8. 执行特定于 Windows 子系统的操作以完成初始化。
- en: 9. Start execution of the primary thread.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 9. 启动主线程的执行。
- en: 10. Finalize process initialization.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 10. 完成进程初始化。
- en: 11. Start execution at the image entry point.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 11. 从镜像入口点开始执行。
- en: 12. Return to the caller of the process-creation API.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 12. 返回进程创建 API 的调用者。
- en: The techniques outlined in this section take advantage of step 3, in which the
    kernel creates a section object from the process image. The memory manager caches
    this image section once it is created, meaning that the section can deviate from
    the corresponding target image. Thus, when the driver receives its notification
    from the kernel process manager, the <samp class="SANS_TheSansMonoCd_W5Regular_11">FileObject</samp>
    member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_CREATE_NOTIFY_INFO</samp>
    structure it processes may not point to the file truly being executed. Beyond
    exploiting this fact, each of the following techniques has slight variations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中概述的技术利用了第3步，其中内核从进程镜像创建节区对象。一旦创建，内存管理器会缓存该镜像节区，这意味着节区可能与相应的目标镜像有所偏差。因此，当驱动程序从内核进程管理器接收到通知时，它处理的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_CREATE_NOTIFY_INFO</samp> 结构的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FileObject</samp> 成员可能并不指向正在执行的文件。除了利用这一事实外，接下来的每种技术还有细微的变化。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hollowing</samp>
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hollowing</samp>
- en: '*Hollowing* is one of the oldest ways of leveraging section modification, dating
    back to at least 2011\. [Figure 3-9](#fig3-9) shows the execution flow of this
    technique.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*Hollowing* 是利用节区修改的最古老方法之一，至少可以追溯到2011年。[图 3-9](#fig3-9)展示了这种技术的执行流程。'
- en: '![](../images/Figure3-9.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-9: The execution flow
    of process hollowing</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-9：进程 hollowing 的执行流程</samp>
- en: Using this technique, the attacker creates a process in a suspended state, then
    unmaps its image after locating its base address in the PEB. Once the unmapping
    is complete, the attacker maps a new image, such as the adversary’s shellcode
    runner, to the process and aligns its section. If this succeeds, the process resumes
    execution.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此技术，攻击者创建一个处于挂起状态的进程，然后在定位其基址（PEB 中）后取消映射该镜像。一旦取消映射完成，攻击者将一个新的镜像（例如敌方的 shellcode
    执行器）映射到该进程，并对其节区进行对齐。如果成功，进程将恢复执行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Doppelgänging</samp>
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Doppelgänging</samp>
- en: 'In their 2017 Black Hat Europe presentation “Lost in Transaction: Process Doppelgänging,”
    Tal Liberman and Eugene Kogan introduced a new variation on process-image modification.
    Their technique, *process doppelgänging*, relies on two Windows features: Transactional
    NTFS (TxF) and the legacy process-creation API, <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateProcessEx()</samp>.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '在2017年黑帽欧洲大会的演讲《Lost in Transaction: Process Doppelgänging》中，Tal Liberman 和
    Eugene Kogan 介绍了一种新的进程镜像修改变种。他们的技术，*进程 Doppelgänging*，依赖于两个 Windows 特性：事务性 NTFS（TxF）和遗留的进程创建
    API，<samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateProcessEx()</samp>。'
- en: TxF is a now-deprecated method for performing filesystem actions as a single
    atomic operation. It allows code to easily roll back file changes, such as during
    an update or in the event of an error, and has its own group of supporting APIs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: TxF 是一种现已弃用的通过将文件系统操作作为单一原子操作来执行的方式。它允许代码轻松地回滚文件更改，例如在更新或发生错误时，并且有一组支持它的 API。
- en: The legacy process-creation API performed process creation prior to the release
    of Windows 10, which introduced the more robust <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateUserProcess()</samp>.
    While it’s deprecated for normal process creation, you’ll still find it used on
    Windows 10, in versions up to 20H2, to create minimal processes. It has the notable
    benefit of taking a section handle rather than a file for the process image but
    comes with some significant challenges. These difficulties stem from the fact
    that many of the process-creation steps, such as writing process parameters to
    the new process’s address space and creating the main thread object, aren’t handled
    behind the scenes. In order to use the legacy process-creation function, the developer
    must re-create those missing steps in their own code to ensure that the process
    can start.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留的进程创建API在Windows 10发布之前用于进程创建，Windows 10引入了更强大的<samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateUserProcess()</samp>。虽然它在正常的进程创建中已经被弃用，但在Windows
    10的版本（直到20H2）中，仍然可以用来创建最小化进程。它的一个显著优点是，进程镜像使用节句柄而非文件，但也带来了一些重要挑战。这些困难源于，许多进程创建步骤（例如将进程参数写入新进程的地址空间和创建主线程对象）并没有在幕后自动处理。为了使用遗留的进程创建函数，开发者必须在自己的代码中重新创建这些缺失的步骤，确保进程能够启动。
- en: '[Figure 3-10](#fig3-10) shows the complex flow of process doppelgänging.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-10](#fig3-10)展示了进程复制的复杂流程。'
- en: '![](../images/Figure3-10.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-10.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-10: The execution
    flow of process doppelgänging</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-10：进程复制执行流程</samp>
- en: In their proof of concept, Liberman and Kogan first create a transaction object
    and open the target file with <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateFileTransacted()</samp>.
    They then overwrite this transacted file with their malicious code, create an
    image section that points to the malicious code, and roll back the transaction
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!RollbackTransaction()</samp>.
    At this point, the executable has been restored to its original state, but the
    image section is cached with the malicious code. From here, the authors call <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateProcessEx()</samp>, passing
    in the section handle as a parameter, and create the main thread pointing to the
    entry point of their malicious code. After these objects are created, they resume
    the main thread, allowing the doppelgänged process to execute.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的概念验证中，Liberman和Kogan首先创建一个事务对象，并使用<samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateFileTransacted()</samp>打开目标文件。然后，他们用恶意代码覆盖该事务文件，创建一个指向恶意代码的镜像节，并通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!RollbackTransaction()</samp>回滚事务。此时，可执行文件已恢复到原始状态，但镜像节被缓存了恶意代码。从这里，作者调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateProcessEx()</samp>，将节句柄作为参数传入，创建一个指向恶意代码入口点的主线程。创建这些对象后，他们恢复主线程，允许被复制的进程执行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Herpaderping</samp>
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Herpaderping</samp>
- en: '*Process herpaderping*, invented by Johnny Shaw in 2020, leverages many of
    the same tricks as process doppelgänging, namely its use of the legacy process-creation
    API to create a process from a section object. While herpaderping can evade a
    driver’s image-based detections, its primary aim is to evade detection of the
    contents of the dropped executable. [Figure 3-11](#fig3-11) shows how this technique
    works.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程herpaderping*，由Johnny Shaw在2020年发明，利用了许多与进程复制相同的技巧，特别是通过使用遗留的进程创建API从节对象创建进程。虽然herpaderping可以避开驱动程序的基于镜像的检测，但其主要目的是避开被丢弃的可执行文件内容的检测。[图
    3-11](#fig3-11)展示了这一技术如何工作。'
- en: '![](../images/Figure3-11.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-11.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-11: The execution
    flow of process herpaderping</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-11：进程herpaderping执行流程</samp>
- en: To perform herpaderping, an attacker first writes the malicious code to be executed
    to disk and creates the section object, leaving the handle to the dropped executable
    open. They then call the legacy process-creation API, with the section handle
    as a parameter, to create the process object. Before initializing the process,
    they obscure the original executable dropped to disk using the open file handle
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!WriteFile()</samp>
    or a similar API. Finally, they create the main thread object and perform the
    remaining process spin-up tasks.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行herpaderping，攻击者首先将恶意代码写入磁盘，并创建区域对象，保持掉落的可执行文件的句柄打开。然后，他们调用传统的进程创建API，将区域句柄作为参数，以创建进程对象。在初始化进程之前，他们通过打开的文件句柄和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!WriteFile()</samp>或类似的API来隐藏最初写入磁盘的可执行文件。最后，他们创建主线程对象并执行剩余的进程启动任务。
- en: At this point, the driver’s callback receives a notification, and it can scan
    the file’s contents using the <samp class="SANS_TheSansMonoCd_W5Regular_11">FileObject</samp>
    member of the structure passed to the driver on process creation. However, because
    the file’s contents have been modified, the scanning function will retrieve bogus
    data. Additionally, closing the file handle will send an <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CLEANUP</samp>
    I/O control code to any filesystem minifilters that have been registered. If the
    minifilter wishes to scan the contents of the file, it will meet the same fate
    as the driver, potentially resulting in a false-negative scan result.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，驱动程序的回调收到通知，可以使用在进程创建时传递给驱动程序的结构中的<FileObject>成员扫描文件内容。然而，由于文件内容已被修改，扫描功能将检索到虚假的数据。此外，关闭文件句柄将向所有已注册的文件系统微筛选器发送一个<IRP_MJ_CLEANUP>
    I/O控制代码。如果微筛选器希望扫描文件内容，它将面临与驱动程序相同的命运，可能导致假阴性扫描结果。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Ghosting</samp>
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">幽灵化</samp>
- en: One of the newest variations on process-image modification is *process ghosting*,
    released in June 2021 by Gabriel Landau. Process ghosting relies on the fact that
    Windows only prevents the deletion of files *after* they’re mapped into an image
    section and doesn’t check whether an associated section actually exists during
    the deletion process. If a user attempts to open the mapped executable to modify
    or delete it, Windows will return an error. If the developer marks the file for
    deletion and then creates the image section from the executable, the file will
    be deleted when the file handle is closed, but the section object will persist.
    This technique’s execution flow is shown in [Figure 3-12](#fig3-12).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 进程映像修改的最新变体之一是*进程幽灵化*，由Gabriel Landau于2021年6月发布。进程幽灵化依赖于Windows仅在文件映像映射到图像区域后才防止文件删除，并且在删除过程中不会检查关联的区域是否实际存在。如果用户尝试打开映射的可执行文件进行修改或删除，Windows会返回一个错误。如果开发者将文件标记为删除，然后从可执行文件创建图像区域，那么在文件句柄关闭时，文件将被删除，但区域对象将保持存在。该技术的执行流程如[图3-12](#fig3-12)所示。
- en: '![](../images/Figure3-12.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure3-12.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-12: The process-ghosting
    workflow</samp>'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图3-12：进程幽灵化工作流</samp>
- en: To implement this technique in practice, malware might create an empty file
    on disk and then immediately put it into a delete-pending state using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtSetInformationFile()</samp> API.
    While the file is in this state, the malware can write its payload to it. Note
    that external requests to open the file will fail, with *ERROR_DELETE_PENDING*,
    at this point. Next, the malware creates the image section from the file and then
    closes the file handle, deleting the file but preserving the image section. From
    here, the malware follows the steps to create a new process from a section object
    described in previous examples. When the driver receives a notification about
    the process creation and attempts to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp>
    backing the process (the structure used by Windows to represent a file object),
    it will receive a *STATUS_FILE_DELETED* error, preventing the file from being
    inspected.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在实践中实现这一技术，恶意软件可能会在磁盘上创建一个空文件，然后立即使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtSetInformationFile()</samp>
    API 将其置于删除待定状态。当文件处于此状态时，恶意软件可以向文件写入其有效载荷。请注意，在此时，外部请求打开该文件会失败，并返回 *ERROR_DELETE_PENDING*
    错误。接下来，恶意软件从该文件创建映像节，然后关闭文件句柄，删除文件，但保留映像节。从这里开始，恶意软件遵循前述示例中的步骤，通过节对象创建新进程。当驱动程序收到有关进程创建的通知并尝试访问支持该进程的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp>（Windows 用于表示文件对象的结构）时，它将收到
    *STATUS_FILE_DELETED* 错误，防止文件被检查。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Detection</samp>
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">检测</samp>
- en: 'While process-image modification has a seemingly endless number of variations,
    we can detect all of these using the same basic methods due to the technique’s
    reliance on two things: the creation of an image section that differs from the
    reported executable, whether it is modified or missing, and the use of the legacy
    process-creation API to create a new, non-minimal process from the image section.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然进程映像修改有无数种变体，但由于该技术依赖于两点——创建与报告的可执行文件不同的映像节，无论是被修改还是缺失，以及使用传统的进程创建 API 从映像节创建新的非最小化进程——我们可以使用相同的基本方法来检测所有这些变体。
- en: 'Unfortunately, most of the detections for this tactic are reactive, occurring
    only as part of an investigation, or they leverage proprietary tooling. Still,
    by focusing on the basics of the technique, we can imagine multiple potential
    ways to detect it. To demonstrate these methods, Aleksandra Doniec (@hasherezade)
    created a public proof of concept for process ghosting that we can analyze in
    a controlled environment. You can find this file, *proc_ghost64.exe*, at [*https://<wbr>github<wbr>.com<wbr>/hasherezade<wbr>/process<wbr>_ghosting<wbr>/releases*](https://github.com/hasherezade/process_ghosting/releases).
    Verify that its SHA-256 hash matches the following: <samp class="SANS_TheSansMonoCd_W5Regular_11">8a74a522e9a91b777080d3cb95d8bbeea84cb71fda487bc3d4489188e3fd6855</samp>.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，大多数对这种策略的检测是反应性的，通常仅在调查过程中进行，或者利用专有工具。然而，通过关注该技术的基本原理，我们可以设想出多种潜在的检测方法。为了演示这些方法，Aleksandra
    Doniec（@hasherezade）创建了一个公开的进程幽灵证明概念，我们可以在受控环境中分析。你可以在 [*https://<wbr>github<wbr>.com<wbr>/hasherezade<wbr>/process<wbr>_ghosting<wbr>/releases*](https://github.com/hasherezade/process_ghosting/releases)
    下载这个文件 *proc_ghost64.exe*。请验证它的 SHA-256 哈希值是否与以下值匹配：<samp class="SANS_TheSansMonoCd_W5Regular_11">8a74a522e9a91b777080d3cb95d8bbeea84cb71fda487bc3d4489188e3fd6855</samp>。
- en: First, in kernel mode, the driver could search for information related to the
    process’s image either in the PEB or in the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp>
    structure, the structure that represents a process object in the kernel. Because
    the user can control the PEB, the process structure is a better source. It contains
    process-image information in a number of locations, described in [Table 3-1](#tab3-1).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在内核模式下，驱动程序可以在 PEB 中或相应的 <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp>
    结构中查找与进程映像相关的信息，该结构表示内核中的进程对象。由于用户可以控制 PEB，因此进程结构是更好的信息来源。它在多个位置包含进程映像信息，具体描述见
    [表 3-1](#tab3-1)。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp> <samp class="SANS_Futura_Std_Book_11">Process-Image
    Information Contained in the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp>
    <samp class="SANS_Futura_Std_Book_11">Structure</samp>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-1：</samp> <samp class="SANS_Futura_Std_Book_11">包含在</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp> <samp class="SANS_Futura_Std_Book_11">结构中的进程映像信息</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Location</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Process-image
    information</samp> |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">位置</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">进程-图像信息</samp>
    |'
- en: '| --- | --- |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp> | <samp
    class="SANS_Futura_Std_Book_11">Contains only the filename</samp> |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp> | <samp
    class="SANS_Futura_Std_Book_11">仅包含文件名</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFilePointer.FileName</samp>
    | <samp class="SANS_Futura_Std_Book_11">Contains the rooted Win32 filepath</samp>
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFilePointer.FileName</samp>
    | <samp class="SANS_Futura_Std_Book_11">包含根目录的 Win32 文件路径</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAuditProcessCreationInfo.ImageFileName</samp>
    | <samp class="SANS_Futura_Std_Book_11">Contains the full NT path but may not
    always be populated</samp> |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAuditProcessCreationInfo.ImageFileName</samp>
    | <samp class="SANS_Futura_Std_Book_11">包含完整的 NT 路径，但可能并不总是填充</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ImagePathHash</samp> | <samp
    class="SANS_Futura_Std_Book_11">Contains the hashed NT, or canonicalized, path
    via</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PfCalculateProcessHash()</samp>
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ImagePathHash</samp> | <samp
    class="SANS_Futura_Std_Book_11">通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PfCalculateProcessHash()</samp>
    计算得到的哈希化 NT 或规范化路径</samp> |'
- en: Drivers may query these paths by using APIs such as <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!SeLocateProcessImageName()</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!ZwQueryInformationProcess()</samp>
    to retrieve the true image path, at which point they still need a way to determine
    whether the process has been tampered with. Despite being unreliable, the PEB
    provides a point of comparison. Let’s walk through this comparison using WinDbg.
    First, we attempt to pull the image’s filepath from one of the process structure’s
    fields ([Listing 3-15](#list3-15)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序可以通过使用如 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!SeLocateProcessImageName()</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!ZwQueryInformationProcess()</samp>
    等 API 查询这些路径，以检索真实的图像路径，但此时它们仍需要一种方法来确定进程是否被篡改。尽管不可靠，PEB 提供了一个比较的依据。让我们通过 WinDbg
    来演示这一比较。首先，我们尝试从进程结构的一个字段中提取图像的文件路径（[列表 3-15](#list3-15)）。
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 3-15: Pulling the filepath from <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SeAuditProcessCreationInfo</samp>'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-15：从 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SeAuditProcessCreationInfo</samp>
    中提取文件路径
- en: Interestingly, WinDbg returns an empty string as the image name. This is atypical;
    for example, [Listing 3-16](#list3-16) returns what you’d expect to see in the
    case of an unmodified *notepad.exe*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，WinDbg 返回的图像名称是空字符串。这是不典型的；例如，[列表 3-16](#list3-16) 返回的是你在未修改的 *notepad.exe*
    的情况下预期看到的内容。
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 3-16: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">UNICODE_STRING</samp>
    field populated with the NT path of the image'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-16：用图像的 NT 路径填充的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">UNICODE_STRING</samp>
    字段
- en: Let’s also check another member of the process structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>.
    While this field won’t return the full image path, it still provides valuable
    information, as you can see in [Listing 3-17](#list3-17).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查进程结构的另一个成员 <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>。虽然此字段不会返回完整的图像路径，但它仍然提供了有价值的信息，正如你在
    [列表 3-17](#list3-17) 中看到的那样。
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 3-17: Reading the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImageFileName</samp>
    member of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EPROCESS</samp>
    structure'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-17：读取 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImageFileName</samp>
    成员，位于 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EPROCESS</samp> 结构中
- en: 'The returned filename should have already attracted attention, as *.tmp* files
    aren’t very common executables. To determine whether image tampering might have
    taken place, we’ll query the PEB. A few locations in the PEB will return the image
    path: <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters.ImagePathName</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Ldr.InMemoryOrderModuleList</samp>*.*
    Let’s use WinDbg to demonstrate this ([Listing 3-18](#list3-18)).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的文件名应该已经引起了注意，因为 *.tmp* 文件不是常见的可执行文件。为了确定是否可能发生了图像篡改，我们将查询 PEB。PEB 中的几个位置会返回图像路径：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters.ImagePathName</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Ldr.InMemoryOrderModuleList</samp>。让我们使用
    WinDbg 来演示这一点（[列表 3-18](#list3-18)）。
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 3-18: Extracting the process image’s path from <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImagePathName</samp>'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-18：从 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImagePathName</samp>
    提取进程图像路径
- en: As shown in the WinDbg output, the PEB reports the process image’s path as *C:\Windows\System32\notepad.exe*.
    We can verify this by querying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ldr.InMemoryOrderModuleList</samp>
    field, shown in [Listing 3-19](#list3-19).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如 WinDbg 输出所示，PEB 报告的进程图像路径为 *C:\Windows\System32\notepad.exe*。我们可以通过查询 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ldr.InMemoryOrderModuleList</samp> 字段来验证这一点，如
    [列表 3-19](#list3-19) 所示。
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 3-19: Extracting the process image’s path from <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InMemoryOrderModuleList</samp>'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-19：从 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InMemoryOrderModuleList</samp>
    提取进程图像路径
- en: You can see here that *notepad.exe* is the first image in the module list ❶.
    In my testing, this should always be the case. If an EDR found a mismatch like
    this between the image name reported in the process structures and in the PEB,
    it could reasonably say that some type of process-image tampering had occurred.
    It couldn’t, however, determine which technique the attacker had used. To make
    that call, it would have to collect additional information.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里 *notepad.exe* 是模块列表中的第一个图像 ❶。在我的测试中，这应该始终是这种情况。如果 EDR 在进程结构中报告的图像名称与
    PEB 中的名称不匹配，它可以合理地判断某种类型的进程图像篡改已发生。然而，它无法确定攻击者使用了哪种技术。为了做出这一判断，它需要收集更多的信息。
- en: The EDR might first try to investigate the file directly, such as by scanning
    its contents through the pointer stored in the process structure’s <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFilePointer</samp>
    field. If malware created the process by passing an image section object through
    the legacy process-creation API, as in the proof of concept, this member will
    be empty ([Listing 3-20](#list3-20)).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: EDR 可能首先尝试直接调查文件，例如通过进程结构中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFilePointer</samp>
    字段扫描其内容。如果恶意软件通过传递图像部分对象来创建进程，使用的是传统的进程创建 API，如概念验证中所示，那么该成员将为空（[列表 3-20](#list3-20)）。
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 3-20: The empty <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImageFilePointer</samp>
    field'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-20：空的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImageFilePointer</samp>
    字段
- en: The use of the legacy API to create a process from a section is a major indicator
    that something weird is going on. At this point, the EDR can reasonably say that
    this is what happened. To support this assumption, the EDR could also check whether
    the process is minimal or *pico* (derived from a minimal process), as shown in
    [Listing 3-21](#list3-21).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统 API 从一个部分创建进程是一个重要的指示，表明某些异常情况正在发生。此时，EDR 可以合理地判断这是发生的情况。为了支持这一假设，EDR 还可以检查进程是否为最小进程或
    *pico*（派生自最小进程），如 [列表 3-21](#list3-21) 所示。
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 3-21: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Minimal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PicoCreated</samp>
    members set to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">false</samp>'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-21：将 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Minimal</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PicoCreated</samp> 成员设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">false</samp>
- en: Another place to look for anomalies is the virtual address descriptor (VAD)
    tree used for tracking a process’s contiguous virtual memory allocations. The
    VAD tree can provide very useful information about loaded modules and the permissions
    of memory allocations. The root of this tree is stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">VadRoot</samp>
    member of the process structure, which we can’t directly retrieve through a Microsoft-supplied
    API, but you can find a reference implementation in Blackbone, a popular driver
    used for manipulating memory.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以检查异常的地方是虚拟地址描述符（VAD）树，用于跟踪进程的连续虚拟内存分配。VAD 树可以提供有关已加载模块和内存分配权限的非常有用的信息。该树的根存储在进程结构的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VadRoot</samp> 成员中，我们无法通过 Microsoft
    提供的 API 直接检索该信息，但可以在流行的驱动程序 Blackbone 中找到参考实现，Blackbone 用于操作内存。
- en: To detect process-image modifications, you’ll probably want to look at the mapped
    allocation types, which include *READONLY* file mappings, such as the COM+ catalog
    files (for example, *C:\Windows\Registration\Rxxxxxxx1.clb*), and *EXECUTE_WRITECOPY*
    executable files. In the VAD tree, you’ll commonly see the Win32-rooted path for
    the process image (in other words, the executable file that backs the process
    as the first mapped executable). [Listing 3-22](#list3-22) shows the truncated
    output of WinDbg’s <samp class="SANS_TheSansMonoCd_W5Regular_11">!vad</samp> command.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 若要检测进程映像修改，您可能需要查看映射的分配类型，其中包括 *READONLY* 文件映射，如 COM+ 目录文件（例如 *C:\Windows\Registration\Rxxxxxxx1.clb*），以及
    *EXECUTE_WRITECOPY* 可执行文件。在 VAD 树中，您通常会看到进程映像的 Win32 根路径（换句话说，作为第一个映射可执行文件的进程支持的可执行文件）。[列表
    3-22](#list3-22) 显示了 WinDbg 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">!vad</samp>
    命令的截断输出。
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 3-22: The output of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">!vad</samp>
    command in WinDbg for a normal process'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-22：WinDbg 中对于正常进程的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">!vad</samp>
    命令输出
- en: The output of this tool shows mapped allocations for an unmodified *notepad.exe*
    process. Now let’s see how they look in a ghosted process ([Listing 3-23](#list3-23)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具的输出显示了未修改的 *notepad.exe* 进程的映射分配。现在让我们来看一下它们在伪装进程中的表现（[列表 3-23](#list3-23)）。
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 3-23: The output of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">!vad</samp>
    command for a ghosted process'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-23：伪装进程的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">!vad</samp>
    命令输出
- en: This mapped allocation shows the path to the *.tmp* file instead of the path
    to *notepad.exe*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个映射分配显示了 *.tmp* 文件的路径，而不是 *notepad.exe* 的路径。
- en: Now that we know the path to the image of interest, we can investigate it further.
    One way to do this is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryInformationFile()</samp>
    API with the <samp class="SANS_TheSansMonoCd_W5Regular_11">FileStandardInformation</samp>
    class, which will return a <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_STANDARD_INFORMATION</samp>
    structure. This structure contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeletePending</samp>
    field, which is a Boolean indicating whether the file has been marked for deletion.
    Under normal circumstances, you could also pull this information from the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DeletePending</samp> member of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp> structure. Inside the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp> structure for the
    relevant process, this is pointed to by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFilePointer</samp>
    member. In the case of the ghosted process, this pointer will be null, so the
    EDR can’t use it. [Listing 3-24](#list3-24) shows what a normal process’s image
    file pointer and deletion status should look like.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了感兴趣的映像路径，就可以进一步调查它。做这件事的一种方法是使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryInformationFile()</samp>
    API 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">FileStandardInformation</samp>
    类，它将返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_STANDARD_INFORMATION</samp>
    结构。该结构包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">DeletePending</samp> 字段，这是一个布尔值，指示文件是否已标记为删除。在正常情况下，您也可以从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp> 结构的 <samp class="SANS_TheSansMonoCd_W5Regular_11">DeletePending</samp>
    成员中提取此信息。在相关进程的 <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp>
    结构内部，这由 <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFilePointer</samp>
    成员指向。在伪装进程的情况下，该指针将为空，因此 EDR 无法使用它。[列表 3-24](#list3-24) 显示了正常进程的映像文件指针和删除状态应如何表现。
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 3-24: Normal <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImageFilePointer</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">DeletePending</samp>
    members'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-24：正常的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImageFilePointer</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">DeletePending</samp>
    成员
- en: This listing is from a *notepad.exe* process executed under normal conditions.
    In a ghosted process, the image file pointer would be an invalid value, and thus,
    the deletion status flag would also be invalid.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表来自一个在正常条件下执行的 *notepad.exe* 进程。在一个被伪装的进程中，映像文件指针将是一个无效值，因此，删除状态标志也将是无效的。
- en: 'After observing the difference between a normal instance of *notepad.exe* and
    one that has been ghosted, we’ve identified a few indicators:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察正常的 *notepad.exe* 实例和被伪装的实例之间的差异，我们已经识别出了一些指示器：
- en: There will be a mismatch between the paths in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImagePathName</samp>
    inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    member of the process’s PEB and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>
    in its <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp> structure.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进程的PEB中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    成员内的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ImagePathName</samp> 路径与其 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp> 结构中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>
    路径不匹配。
- en: The process structure’s image file pointer will be null and its <samp class="SANS_TheSansMonoCd_W5Regular_11">Minimal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PicoCreated</samp> fields will
    be <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程结构的图像文件指针将为null，并且其 <samp class="SANS_TheSansMonoCd_W5Regular_11">Minimal</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">PicoCreated</samp> 字段将为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp>。
- en: The filename may be atypical (this isn’t a requirement, however, and the user
    can control this value).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名可能不常见（不过这并不是要求，用户可以控制该值）。
- en: When the EDR driver receives the new process-creation structure from its process-creation
    callback, it will have access to the key information needed to build a detection.
    Namely, in the case of process ghosting, it can use <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FileObject</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">IsSubsystemProcess</samp>
    to identify potentially ghosted processes. [Listing 3-25](#list3-25) shows what
    this driver logic could look like.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当EDR驱动程序从其进程创建回调中接收到新的进程创建结构时，它将能够访问构建检测所需的关键信息。也就是说，在进程幽灵化的情况下，它可以使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>、 <samp class="SANS_TheSansMonoCd_W5Regular_11">FileObject</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">IsSubsystemProcess</samp> 来识别潜在的幽灵进程。[清单
    3-25](#list3-25)展示了该驱动程序逻辑的实现方式。
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 3-25: Detecting ghosted processes with the driver'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 清单3-25：使用驱动程序检测幽灵进程
- en: We first check whether the file pointer is null even though the process being
    created isn’t a subsystem process ❶, meaning it was likely created with the legacy
    process-creation API. Next, we use two mock helper functions ❷ to return the process
    image path from the PEB and convert it to the NT path. We then repeat this process
    using the image filename from the process structure for the newly created process
    ❸. After that, we compare the image paths in the PEB and process structure. If
    they’re not equal, we’ve likely found a suspicious process, and it’s time for
    the EDR to take some action.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查文件指针是否为null，即使创建的进程不是子系统进程❶，这意味着它可能是通过传统的进程创建API创建的。接下来，我们使用两个模拟辅助函数❷从PEB中返回进程图像路径，并将其转换为NT路径。然后，我们使用进程结构中为新创建的进程提供的图像文件名❸重复此过程。之后，我们比较PEB和进程结构中的图像路径。如果它们不相等，则很可能发现了可疑进程，此时EDR需要采取行动。
- en: '<samp class="SANS_Futura_Std_Bold_B_11">A Process Injection Case Study: fork&run</samp>'
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进程注入案例研究：fork&run</samp>
- en: Over time, shifts in attacker tradecraft have affected the importance, to EDR
    vendors, of detecting suspicious process-creation events. After gaining access
    to a target system, attackers may leverage any number of command-and-control agents
    to perform their post-exploitation activities. Each malware agent’s developers
    must decide how to handle communications with the agent so that they can execute
    commands on the infected system. While there are numerous approaches to tackling
    this problem, the most common architecture is referred to as *fork&run*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间推移，攻击者的技术手段发生了变化，这也影响了EDR厂商对于检测可疑进程创建事件的重要性。在成功入侵目标系统后，攻击者可能会利用任何数量的命令与控制代理来执行其后期利用活动。每个恶意软件代理的开发者必须决定如何处理与代理的通信，以便在被感染的系统上执行命令。虽然有许多方法可以解决这个问题，但最常见的架构被称为*fork&run*。
- en: Fork&run works by spawning a sacrificial process into which the primary agent
    process injects its post-exploitation tasking, allowing the task to execute independently
    of the agent. This comes with the advantage of stability; if a post-exploitation
    task running inside the primary agent process has an unhandled exception or fault,
    it could cause the agent to exit. As a result, the attacker could lose access
    to the environment.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Fork&run 的工作原理是启动一个牺牲进程，代理的主进程将其后期利用任务注入该进程，使任务能够独立于代理执行。这样做的一个好处是稳定性；如果在主代理进程中运行的后期利用任务遇到未处理的异常或故障，可能会导致代理退出，从而使攻击者失去对环境的访问权限。
- en: The architecture also streamlines the agent’s design. By providing a host process
    and a means of injecting its post-exploitation capabilities, the developer makes
    it easier to integrate new features into the agent. Additionally, by keeping post-exploitation
    tasking contained in another process, the agent doesn’t need to worry too much
    about cleanup and can instead terminate the sacrificial process altogether.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构还简化了代理的设计。通过提供主机进程和注入其后期利用功能的方式，开发者使得将新功能集成到代理中变得更加容易。此外，通过将后期利用任务限制在另一个进程中，代理无需过多担心清理问题，而是可以直接终止牺牲进程。
- en: Leveraging fork&run in an agent is so simple that many operators might not even
    realize they’re using it. One of the most popular agents that makes heavy use
    of fork&run is Cobalt Strike’s Beacon. Using Beacon, the attacker can specify
    a sacrificial process, either through their Malleable profile or through Beacon’s
    integrated commands, into which they can inject their post-exploitation capabilities.
    Once the target is set, Beacon will spawn this sacrificial process and inject
    its code whenever a post-exploitation job that requires fork&run is queued. The
    sacrificial process is responsible for running the job and returning output before
    exiting.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理中利用 fork&run 是如此简单，以至于许多操作人员可能甚至没有意识到他们正在使用它。一个广泛使用 fork&run 的流行代理是 Cobalt
    Strike 的 Beacon。通过 Beacon，攻击者可以指定一个牺牲进程，无论是通过其可塑性配置文件（Malleable profile）还是通过 Beacon
    集成命令，这个进程将作为注入后期利用功能的目标。一旦目标进程设置好，Beacon 就会启动该牺牲进程，并在队列中有需要 fork&run 的后期利用任务时注入其代码。该牺牲进程负责运行任务并在退出前返回输出。
- en: However, this architecture poses a large risk to operational security. Attackers
    now have to evade so many detections that leveraging the built-in features of
    an agent like Beacon often isn’t viable. Instead, many teams now use their agent
    only as a method for injecting their post-exploitation tooling code and maintaining
    access to the environment. An example of this trend is the rise of offensive tooling
    written in C# and primarily leveraged through Beacon’s *execute-assembly*, a way
    to execute .NET assemblies in memory that makes use of fork&run under the hood.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种架构对操作安全构成了较大的风险。攻击者现在必须躲避如此多的检测，以至于利用像 Beacon 这样的代理的内置功能通常不可行。相反，许多团队现在只将其代理作为注入后期利用工具代码和保持对环境访问的一种方式。这一趋势的一个例子是，使用
    C# 编写的进攻性工具的兴起，主要通过 Beacon 的*execute-assembly*进行利用，后者是一种在内存中执行 .NET 程序集的方法，底层使用了
    fork&run。
- en: Because of this shift in tradecraft, EDRs highly scrutinize process creation
    from numerous angles, ranging from the relative frequency of the parent–child
    relationship in the environment to whether the process’s image is a .NET assembly.
    Yet, as EDR vendors became better at detecting the “create a process and inject
    into it” pattern, attackers have begun to consider spawning a new process to be
    highly risky and have looked for ways to avoid doing it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种战术手段的转变，EDR 对进程创建的监控变得更加严格，从环境中父子进程关系的相对频率到进程镜像是否为 .NET 程序集等方面进行了多角度审查。然而，随着
    EDR 厂商在检测“创建进程并注入”模式方面变得更加精准，攻击者开始认为启动新进程具有很高的风险，并开始寻找规避该操作的方法。
- en: One of the biggest challenges for EDR vendors came in version 4.1 of Cobalt
    Strike, which introduced Beacon Object Files (BOFs). BOFs are small programs written
    in C that are meant to be run in the agent process, avoiding fork&run entirely.
    Capability developers could continue to use their existing development process
    but leverage this new architecture to achieve the same results in a safer manner.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 EDR（端点检测与响应）厂商来说，最大的挑战之一出现在 Cobalt Strike 的 4.1 版本中，该版本引入了 Beacon 对象文件（BOFs）。BOFs
    是用 C 语言编写的小型程序，旨在在代理进程中运行，完全避免了 fork&run。功能开发人员可以继续使用现有的开发过程，但利用这种新架构以更安全的方式实现相同的结果。
- en: If attackers remove the artifacts from fork&run, EDR vendors must rely on other
    pieces of telemetry for their detections. Fortunately for vendors, BOFs only remove
    the process-creation and injection telemetry related to the sacrificial process
    creation. They don’t do anything to hide the post-exploitation tooling’s artifacts,
    such as network traffic, filesystem interactions, or API calls. This means that,
    while BOFs do make detection more difficult, they are not a silver bullet.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者从fork&run中移除伪装，EDR供应商必须依赖其他遥测数据来进行检测。幸运的是，对于供应商来说，BOFs仅移除与牺牲进程创建相关的进程创建和注入遥测数据。它们不会隐藏后期利用工具的痕迹，比如网络流量、文件系统交互或API调用。这意味着，尽管BOFs确实使检测变得更加困难，但它们并不是解决问题的灵丹妙药。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结论</samp>
- en: Monitoring the creation of new processes and threads is an immensely important
    capability for any EDR. It facilitates the mapping of parent–child relationships,
    the investigation of suspect processes prior to their execution, and the identification
    of remote thread creation. Although Windows provides other ways to obtain this
    information, process- and thread-creation callback routines inside the EDR’s driver
    are by far the most common. In addition to having a great deal of visibility into
    activity on the system, these callbacks are challenging to evade, relying on gaps
    in coverage and blind spots rather than fundamental flaws in the underlying technology.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 监控新进程和线程的创建是任何EDR（端点检测与响应）系统中极其重要的功能。它有助于映射父子关系、在进程执行之前调查可疑进程，并识别远程线程的创建。尽管Windows提供了其他获取这些信息的方式，但在EDR的驱动程序内部，进程和线程创建回调例程仍然是最常见的方式。除了能够深入了解系统上的活动外，这些回调也很难被规避，它们依赖于覆盖的漏洞和盲点，而不是底层技术的根本缺陷。
