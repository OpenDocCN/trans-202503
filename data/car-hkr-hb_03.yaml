- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: '**VEHICLE COMMUNICATION WITH SOCKETCAN**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 SocketCAN 进行车辆通信**'
- en: '![image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/common-01.jpg)'
- en: When you begin using a CAN for vehicle communications, you may well find it
    to be a hodgepodge of different drivers and software utilities. The ideal would
    be to unify the CAN tools and their different interfaces into a common interface
    so we could easily share information between tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始使用 CAN 进行车辆通信时，您可能会发现它是不同驱动程序和软件工具的大杂烩。理想情况是将 CAN 工具及其不同的接口统一为一个通用接口，以便我们可以轻松地在工具之间共享信息。
- en: Luckily, there’s a set of tools with a common interface, and it’s free! If you
    have Linux or install Linux on a virtual machine (VM), you already have this interface.
    The interface, called SocketCAN, was created on the Open Source development site
    BerliOS in 2006\. Today, the term *SocketCAN* is used to refer to the implementation
    of CAN drivers as network devices, like Ethernet cards, and to describe application
    access to the CAN bus via the network socket–programming interface. In this chapter
    we’ll set up SocketCAN so that we’re more easily able to communicate with the
    vehicle.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一套具有共同接口的工具，并且是免费的！如果您使用 Linux 或在虚拟机（VM）上安装了 Linux，您已经拥有这个接口。这个接口称为 SocketCAN，于
    2006 年在开源开发网站 BerliOS 上创建。今天，术语 *SocketCAN* 用于指代将 CAN 驱动程序实现为网络设备（如以太网卡），并描述应用程序通过网络套接字编程接口访问
    CAN 总线的实现。在本章中，我们将设置 SocketCAN，以便更轻松地与车辆进行通信。
- en: Volkswagen Group Research contributed the original SocketCAN implementation,
    which supports built-in CAN chips and card drivers, external USB and serial CAN
    devices, and virtual CAN devices. The `can-utils` package provides several applications
    and tools to interact with the CAN network devices, CAN-specific protocols, and
    the ability to set up a virtual CAN environment. In order to test many of the
    examples in this book, install a recent version in a Linux VM on your system.
    The newest versions of Ubuntu have `can-utils` in their standard repositories.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大众集团研究贡献了最初的 SocketCAN 实现，支持内置 CAN 芯片和卡驱动程序，外部 USB 和串行 CAN 设备，以及虚拟 CAN 设备。`can-utils`
    软件包提供了几个应用程序和工具，用于与 CAN 网络设备交互、CAN 特定协议，并能设置虚拟 CAN 环境。为了测试本书中的许多示例，请在您系统上的 Linux
    虚拟机中安装最新版本。最新版本的 Ubuntu 中已经包含了`can-utils`。
- en: SocketCAN ties into the Linux networking stack, which makes it very easy to
    create tools to support CAN. SocketCAN applications can use standard C socket
    calls with a custom network protocol family, `PF_CAN`. This functionality allows
    the kernel to handle CAN device drivers and to interface with existing networking
    hardware to provide a common interface and user-space utilities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: SocketCAN 与 Linux 网络堆栈紧密结合，这使得创建支持 CAN 的工具变得非常容易。SocketCAN 应用程序可以使用标准的 C 套接字调用与自定义网络协议族
    `PF_CAN`，这种功能允许内核处理 CAN 设备驱动程序，并与现有的网络硬件进行接口，提供一个通用的接口和用户空间实用工具。
- en: '[Figure 3-1](ch03.html#ch3fig1) compares the implementation of traditional
    CAN software with that of a unified SocketCAN.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](ch03.html#ch3fig1) 比较了传统 CAN 软件的实现与统一的 SocketCAN。'
- en: '![image](graphics/f03-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f03-01.jpg)'
- en: '*Figure 3-1: SocketCAN layout (left) and traditional CAN software (right)*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：SocketCAN 布局（左）和传统 CAN 软件（右）*'
- en: With traditional CAN software, the application has its own protocol that typically
    talks to a character device, like a serial driver, and then the actual hardware
    driver. On the left of the figure, SocketCAN is implemented in the Linux kernel.
    By creating its own CAN protocol family, SocketCAN can integrate with the existing
    network device drivers, thus enabling applications to treat a CAN bus interface
    as if it’s a generic network interface.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统的 CAN 软件，应用程序通常具有自己的协议，通常与字符设备（如串行驱动程序）和实际的硬件驱动程序交流。在图的左侧，SocketCAN 是在 Linux
    内核中实现的。通过创建自己的 CAN 协议族，SocketCAN 可以与现有的网络设备驱动程序集成，从而使应用程序能够将 CAN 总线接口视为通用网络接口。
- en: '**Setting Up can-utils to Connect to CAN Devices**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设置 can-utils 以连接到 CAN 设备**'
- en: In order to install `can-utils`, you must be running a Linux distribution from
    2008 or later or one running the 2.6.25 Linux kernel or higher. First we’ll install
    `can-utils`, then cover how to configure it for your particular setup.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 `can-utils`，您必须使用 2008 年或更新的 Linux 发行版，或者运行 2.6.25 或更高版本的 Linux 内核。首先我们将安装
    `can-utils`，然后介绍如何配置它以适应您的特定设置。
- en: '***Installing can-utils***'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装 can-utils***'
- en: 'You should be able to use your package manager to install `can-utils`. Here’s
    a Debian/Ubuntu example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够使用包管理器安装`can-utils`。这里有一个 Debian/Ubuntu 的示例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you don’t have `can-utils` in your package manager, install it from source
    with the `git` command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的包管理器中没有 `can-utils`，可以通过 `git` 命令从源代码安装：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As of this writing, `can-utils` has *configure*, *make*, and *make install*
    files, but in older versions, you’d just enter `make` to install from source.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文写作时，`can-utils` 包含 *configure*、*make* 和 *make install* 文件，但在旧版本中，你只需输入 `make`
    来从源代码安装。
- en: '***Configuring Built-In Chipsets***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置内建芯片组***'
- en: 'The next step depends on your hardware. If you’re looking for a CAN sniffer,
    you should check the list of supported Linux drivers to ensure your device is
    compatible. As of this writing, the Linux built-in CAN drivers support the following
    chipsets:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步取决于你的硬件。如果你正在寻找 CAN 嗅探器，应该检查受支持的 Linux 驱动程序列表，以确保你的设备兼容。截至本文写作时，Linux 内建的
    CAN 驱动程序支持以下芯片组：
- en: • Atmel AT91SAM SoCs
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: • Atmel AT91SAM SoC
- en: • Bosch CC770
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: • 博世 CC770
- en: • ESD CAN-PCI/331 cards
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: • ESD CAN-PCI/331 卡
- en: • Freescale FlexCAN
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: • Freescale FlexCAN
- en: • Freescale MPC52xx SoCs (MSCAN)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: • Freescale MPC52xx SoC（MSCAN）
- en: • Intel AN82527
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: • 英特尔 AN82527
- en: • Microchip MCP251x
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: • Microchip MCP251x
- en: • NXP (Philips) SJA1000
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: • NXP（飞利浦）SJA1000
- en: • TI’s SoCs
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: • TI SoC
- en: CAN controllers, like the SJA1000, are usually built into ISA, PCI, and PCMCIA
    cards or other embedded hardware. For example, the EMS PCMCIA card driver implements
    access to its SJA1000 chip. When you insert the EMS PCMCIA card into a laptop,
    the `ems_pcmcia` module loads into the kernel, which then requires the `sja1000`
    module and the `can_dev` module to be loaded. The `can_dev` module provides standard
    configuration interfaces—for example, for setting bit rates for the CAN controllers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 像 SJA1000 这样的 CAN 控制器通常集成在 ISA、PCI、PCMCIA 卡或其他嵌入式硬件中。例如，EMS PCMCIA 卡驱动程序实现对其
    SJA1000 芯片的访问。当你将 EMS PCMCIA 卡插入笔记本电脑时，`ems_pcmcia` 模块会加载到内核中，随后需要加载 `sja1000`
    模块和 `can_dev` 模块。`can_dev` 模块提供标准配置接口——例如，用于设置 CAN 控制器的比特率。
- en: The Linux kernel’s modular concept also applies to CAN hardware drivers that
    attach CAN controllers via bus hardware, such as the `kvaser_pci`, `peak_pci`,
    and so on. When you plug in a supported device, these modules should automatically
    load, and you should see them when you enter the `lsmod` command. USB drivers,
    like `usb8dev`, usually implement a proprietary USB communication protocol and,
    therefore, do not load a CAN controller driver.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核的模块化概念同样适用于通过总线硬件连接 CAN 控制器的 CAN 硬件驱动程序，如 `kvaser_pci`、`peak_pci` 等。当你插入一个受支持的设备时，这些模块应该会自动加载，你可以通过输入
    `lsmod` 命令看到它们。USB 驱动程序，如 `usb8dev`，通常实现一个专有的 USB 通信协议，因此不会加载 CAN 控制器驱动程序。
- en: 'For example, when you plug in a PEAK-System PCAN-USB adapter, the `can_dev`
    module loads and the `peak_usb` module finalizes its initialization. Using the
    display message command `dmesg`, you should see output similar to this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你插入一个 PEAK-System PCAN-USB 适配器时，`can_dev` 模块会加载，`peak_usb` 模块会完成初始化。使用显示消息命令
    `dmesg`，你应该看到类似如下的输出：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can verify the interface loaded properly with `ifconfig` and ensure a `can0`
    interface is now present:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `ifconfig` 验证接口是否加载成功，并确保现在存在一个 `can0` 接口：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now set the CAN bus speed. (You’ll find more information on bus speeds in [Chapter
    5](ch05.html#ch05).) The key component you need to set is the bit rate. This is
    the speed of the bus. A typical value for high-speed CAN (HS-CAN) is 500Kbps.
    Values of 250Kbps or 125Kbps are typical for lower-speed CAN buses.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设置 CAN 总线速度。（你可以在 [第5章](ch05.html#ch05) 找到有关总线速度的更多信息。）你需要设置的关键组件是比特率，这是总线的速度。典型的高速
    CAN（HS-CAN）值为 500Kbps。250Kbps 或 125Kbps 通常用于低速 CAN 总线。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once you bring up the `can0` device, you should be able to use the tools from
    `can-utils` on this interface. Linux uses netlink to communicate between the kernel
    and user-space tools. You can access netlink with the `ip link` command. To see
    all the netlink options, enter the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你启动了 `can0` 设备，就应该能在这个接口上使用 `can-utils` 提供的工具。Linux 使用 netlink 在内核和用户空间工具之间进行通信。你可以通过
    `ip link` 命令访问 netlink。要查看所有 netlink 选项，请输入以下命令：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you begin to see odd behavior, such as a lack of packet captures and packet
    errors, the interface may have stopped. If you’re working with an external device,
    just unplug or reset. If the device is internal, run these commands to reset it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始看到异常行为，比如没有数据包捕获或数据包错误，接口可能已经停止。如果你正在使用外部设备，只需拔掉电源或重置。如果设备是内部的，可以运行以下命令来重置它：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***Configuring Serial CAN Devices***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置串行 CAN 设备***'
- en: External CAN devices usually communicate via serial. In fact, even USB devices
    on a vehicle often communicate through a serial interface—typically an FTDI chip
    from Future Technology Devices International, Ltd.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 外部CAN设备通常通过串口进行通信。实际上，即使是车辆上的USB设备，通常也通过串行接口进行通信——通常是来自Future Technology Devices
    International, Ltd.的FTDI芯片。
- en: 'The following devices are known to work with SocketCAN:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下设备已知与SocketCAN兼容：
- en: • Any device that supports the LAWICEL protocol
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: • 任何支持LAWICEL协议的设备
- en: • CAN232/CANUSB serial adapters (*[http://www.can232.com/](http://www.can232.com/)*)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: • CAN232/CANUSB串行适配器 (*[http://www.can232.com/](http://www.can232.com/)*)
- en: • VSCOM USB-to-serial adapter (*[http://www.vscom.de/usb-to-can.htm](http://www.vscom.de/usb-to-can.htm)*)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: • VSCOM USB转串口适配器 (*[http://www.vscom.de/usb-to-can.htm](http://www.vscom.de/usb-to-can.htm)*)
- en: • CANtact (*[http://cantact.io](http://cantact.io)*)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: • CANtact (*[http://cantact.io](http://cantact.io)*)
- en: '**NOTE**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re using an Arduino or building your own sniffer, you must implement
    the LAWICEL protocol—also known as the SLCAN protocol—in your firmware in order
    for your device to work. For details, see* [http://www.can232.com/docs/canusb_manual.pdf](http://www.can232.com/docs/canusb_manual.pdf)
    *and* [https://github.com/linux-can/can-misc/blob/master/docs/SLCAN-API.pdf](https://github.com/linux-can/can-misc/blob/master/docs/SLCAN-API.pdf).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您正在使用Arduino或自己构建嗅探器，必须在固件中实现LAWICEL协议——也称为SLCAN协议——才能使您的设备正常工作。有关详细信息，请参见*
    [http://www.can232.com/docs/canusb_manual.pdf](http://www.can232.com/docs/canusb_manual.pdf)
    *和* [https://github.com/linux-can/can-misc/blob/master/docs/SLCAN-API.pdf](https://github.com/linux-can/can-misc/blob/master/docs/SLCAN-API.pdf)。'
- en: 'In order to use one of the USB-to-serial adapters, you must first initialize
    both the serial hardware and the baud rate on the CAN bus:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用USB转串口适配器，您必须首先初始化串行硬件和CAN总线上的波特率：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `slcand` daemon provides the interface needed to translate serial communication
    to the network driver, `slcan0`. The following options can be passed to `slcand`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`slcand`守护进程提供了将串行通信转换为网络驱动程序`slcan0`所需的接口。以下选项可以传递给`slcand`：'
- en: '`-o` Opens the device'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o` 打开设备'
- en: '`-s6` Sets the CAN bus baud rate and speed (see [Table 3-1](ch03.html#ch3tab1))'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`-s6` 设置CAN总线的波特率和速度（参见[表3-1](ch03.html#ch3tab1)）'
- en: '`-t hw` Specifies the serial flow control, either `HW` (hardware) or `SW` (software)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t hw` 指定串行流控制，选择`HW`（硬件）或`SW`（软件）'
- en: '`-S 3000000` Sets the serial baud, or bit rate, speed'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`-S 3000000` 设置串口波特率或比特率速度'
- en: '`/dev/ttyUSB0` Your USB FTDI device'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/ttyUSB0` 您的USB FTDI设备'
- en: '[Table 3-1](ch03.html#ch3tab1) lists the numbers passed to `-s` and the corresponding
    baud rates.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3-1](ch03.html#ch3tab1)列出了传递给`-s`的数字及其对应的波特率。'
- en: '**Table 3-1:** Numbers and Corresponding Baud Rates'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-1：** 编号与对应的波特率'
- en: '| **Number** | **Baud** |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **编号** | **波特率** |'
- en: '| --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | 10Kbps |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 10Kbps |'
- en: '| 1 | 20Kbps |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 20Kbps |'
- en: '| 2 | 50Kbps |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 50Kbps |'
- en: '| 3 | 100Kbps |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 100Kbps |'
- en: '| 4 | 125Kbps |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 125Kbps |'
- en: '|  5  | 250Kbps |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  5  | 250Kbps |'
- en: '| 6 | 500Kbps |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 500Kbps |'
- en: '| 7 | 800Kbps |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 800Kbps |'
- en: '| 8 | 1Mbps |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1Mbps |'
- en: As you can see, entering `-s6` prepares the device to communicate with a 500Kbps
    CAN bus network.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输入`-s6`会使设备准备好与500Kbps的CAN总线网络通信。
- en: 'With these options set, you should now have an `slcan0` device. To confirm,
    enter the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这些选项后，您应该现在拥有一个`slcan0`设备。要确认，请输入以下命令：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Most of the information returned by `ifconfig` is set to generic default values,
    which may be all 0s. This is normal. We’re simply making sure that we can see
    the device with `ifconfig`. If we see an `slcan0` device, we know that we should
    be able to use our tools to communicate over serial with the CAN controller.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifconfig`返回的大部分信息都被设置为通用默认值，可能都是0。这是正常的。我们只是确保能够通过`ifconfig`看到设备。如果我们看到`slcan0`设备，说明我们应该能够使用工具通过串行端口与CAN控制器通信。'
- en: '**NOTE**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*At this point, it may be good to see whether your physical sniffer device
    has additional lights. Often a CAN sniffer will have green and red lights to signify
    that it can communicate correctly with the CAN bus. Your CAN device must be plugged
    in to your computer and the vehicle in order for these lights to function properly.
    Not all devices have these lights. (Check your device’s manual.)*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*此时，查看您的物理嗅探器设备是否有额外的指示灯可能会很有帮助。通常，CAN嗅探器会有绿灯和红灯，用来表示它是否能与CAN总线正确通信。您的CAN设备必须插入计算机和车辆，才能使这些指示灯正常工作。并非所有设备都有这些指示灯。（请检查您的设备手册。）*'
- en: '***Setting Up a Virtual CAN Network***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置虚拟CAN网络***'
- en: If you don’t have CAN hardware to play with, fear not. You can set up a virtual
    CAN network for testing. To do so, simply load the `vcan` module.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 CAN 硬件进行实验，不用担心。你可以设置一个虚拟 CAN 网络进行测试。只需加载 `vcan` 模块即可。
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you check `dmesg`, you shouldn’t see much more than a message like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查 `dmesg`，你不应该看到比这样的消息更多的内容：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now you just set up the interface as discussed in “[Configuring Built-In Chipsets](ch03.html#ch03lev2sec2)”
    on [page 37](ch03.html#page_37) but without specifying a baud rate for the virtual
    interface.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需按照 [“配置内置芯片组”](ch03.html#ch03lev2sec2) 第 37 页 ([page 37](ch03.html#page_37))
    中的内容设置接口，但不需要为虚拟接口指定波特率。
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To verify your setup, enter the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证你的设置，请输入以下内容：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As long as you see a `vcan0` in the output, you’re ready to go.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你在输出中看到 `vcan0`，就可以开始使用了。
- en: '**The CAN Utilities Suite**'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**CAN 工具套件**'
- en: With our CAN device up and running, let’s take a high-level look at the `can-utils`.
    They’re listed and described briefly here; we’ll use them throughout the book,
    and we’ll explore them in greater detail as we use them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动我们的 CAN 设备，接下来我们从高层次了解 `can-utils`。它们在此简要列出和描述，我们将在全书中使用它们，并随着使用深入探讨它们的细节。
- en: '`asc2log` This tool parses ASCII CAN dumps in the following form into a standard
    SocketCAN logfile format:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`asc2log` 此工具将以下格式的 ASCII CAN 转储解析为标准的 SocketCAN 日志文件格式：'
- en: 0.002367 1 390x Rx d 8 17 00 14 00 C0 00 08 00
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 0.002367 1 390x Rx d 8 17 00 14 00 C0 00 08 00
- en: '`bcmserver` Jan-Niklas Meier’s proof-of-concept (PoC) broadcast manager server
    takes commands like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`bcmserver` Jan-Niklas Meier 的概念验证（PoC）广播管理服务器接受如下命令：'
- en: vcan1 A 1 0 123 8 11 22 33 44 55 66 77 88
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: vcan1 A 1 0 123 8 11 22 33 44 55 66 77 88
- en: By default, it listens on port 28600\. It can be used to handle some busy work
    when dealing with repetitive CAN messages.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它监听端口 28600。它可以用于处理一些重复的 CAN 消息时的繁重工作。
- en: '`canbusload` This tool determines which ID is most responsible for putting
    the most traffic on the bus and takes the following arguments:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`canbusload` 此工具确定哪个 ID 对总线上的流量贡献最大，并接受以下参数：'
- en: interface@bitrate
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: interface@bitrate
- en: You can specify as many interfaces as you like and have `canbusload` display
    a bar graph of the worst bandwidth offenders.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定任意数量的接口，并让 `canbusload` 显示带宽占用最严重的条形图。
- en: '`can-calc-bit-timing` This command calculates the bit rate and the appropriate
    register values for each CAN chipset supported by the kernel.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`can-calc-bit-timing` 此命令计算内核支持的每个 CAN 芯片组的比特率和相应的寄存器值。'
- en: '`candump` This utility dumps CAN packets. It can also take filters and log
    packets.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`candump` 此工具转储 CAN 数据包，也可以接受过滤器并记录数据包。'
- en: '`canfdtest` This tool performs send and receive tests over two CAN buses.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`canfdtest` 此工具执行两个 CAN 总线的发送和接收测试。'
- en: '`cangen` This command generates CAN packets and can transmit them at set intervals.
    It can also generate random packets.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`cangen` 此命令生成 CAN 数据包，并可以按设定的间隔进行传输。它还可以生成随机数据包。'
- en: '`cangw` This tool manages gateways between different CAN buses and can also
    filter and modify packets before forwarding them on to the next bus.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`cangw` 此工具管理不同 CAN 总线之间的网关，还可以在转发数据包到下一个总线之前对数据包进行过滤和修改。'
- en: '`canlogserver` This utility listens on port 28700 (by default) for CAN packets
    and logs them in standard format to `stdout`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`canlogserver` 此工具监听端口 28700（默认情况下）以接收 CAN 数据包，并将它们以标准格式记录到 `stdout`。'
- en: '`canplayer` This command replays packets saved in the standard SocketCAN “compact”
    format.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`canplayer` 此命令重放以标准 SocketCAN “紧凑”格式保存的数据包。'
- en: '`cansend` This tool sends a single CAN frame to the network.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`cansend` 此工具向网络发送一个单独的 CAN 帧。'
- en: '`cansniffer` This interactive sniffer groups packets by ID and highlights changed
    bytes.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`cansniffer` 此交互式嗅探器按 ID 分组数据包，并突出显示更改的字节。'
- en: '`isotpdump` This tool dumps ISO-TP CAN packets, which are explained in “[Sending
    Data with ISO-TP and CAN](ch04.html#ch04lev2sec4)” on [page 55](ch04.html#page_55).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`isotpdump` 此工具转储 ISO-TP CAN 数据包，详细说明见 [“使用 ISO-TP 和 CAN 发送数据”](ch04.html#ch04lev2sec4)
    第 55 页 ([page 55](ch04.html#page_55))。'
- en: '`isotprecv` This utility receives ISO-TP CAN packets and outputs to `stdout`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`isotprecv` 此工具接收 ISO-TP CAN 数据包并输出到 `stdout`。'
- en: '`isotpsend` This command sends ISO-TP CAN packets that are piped in from `stdin`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`isotpsend` 此命令发送从 `stdin` 输入的 ISO-TP CAN 数据包。'
- en: '`isotpserver` This tool implements TCP/IP bridging to ISO-TP and accepts data
    packets in the format `1122334455667788`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`isotpserver` 此工具实现了 TCP/IP 与 ISO-TP 的桥接，并接受格式为 `1122334455667788` 的数据包。'
- en: '`isotpsniffer` This interactive sniffer is like `cansniffer` but designed for
    ISO-TP packets.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`isotpsniffer` 此交互式嗅探器类似于 `cansniffer`，但专为 ISO-TP 数据包设计。'
- en: '`isotptun` This utility creates a network tunnel over the CAN network.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`isotptun` 这个工具在 CAN 网络上创建一个网络隧道。'
- en: '`log2asc` This tool converts from standard compact format to the following
    ASCII format:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`log2asc` 这个工具将标准紧凑格式转换为以下 ASCII 格式：'
- en: 0.002367 1 390x Rx d 8 17 00 14 00 C0 00 08 00
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 0.002367 1 390x Rx d 8 17 00 14 00 C0 00 08 00
- en: '`log2long` This command converts from standard compact format to a user readable
    format.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`log2long` 这个命令将标准紧凑格式转换为用户可读格式。'
- en: '`slcan_attach` This is a command line tool for serial-line CAN devices.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`slcan_attach` 这是一个用于串行线 CAN 设备的命令行工具。'
- en: '`slcand` This daemon handles serial-line CAN devices.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`slcand` 这个守护进程处理串行线 CAN 设备。'
- en: '`slcanpty` This tool creates a Linux psuedoterminal interface (PTY) to communicate
    with a serial-based CAN interface.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`slcanpty` 这个工具创建一个 Linux 虚拟终端接口（PTY），以便与基于串行的 CAN 接口进行通信。'
- en: '***Installing Additional Kernel Modules***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装额外的内核模块***'
- en: 'Some of the more advanced and experimental commands, such as the ISO-TP–based
    ones, require you to install additional kernel modules, such as `can-isotp`, before
    they can be used. As of this writing, these additional modules haven’t been included
    with the standard Linux kernels, and you’ll likely have to compile them separately.
    You can grab the additional CAN kernel modules like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更高级和实验性的命令，例如基于 ISO-TP 的命令，要求你安装额外的内核模块，例如 `can-isotp`，才能使用。截止目前，这些额外的模块并未包含在标准
    Linux 内核中，你可能需要单独编译它们。你可以通过以下方式获取额外的 CAN 内核模块：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once `make` finishes, it should create a *can-isotp.ko* file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `make` 完成，它应该会创建一个 *can-isotp.ko* 文件。
- en: 'If you run `make` in the root folder of the repository, it’ll try to compile
    some out-of-sync modules, so it’s best to compile only the module that you need
    in the current directory. To load the newly compiled `can-isotp.ko` module, run
    `insmod`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在仓库的根文件夹中运行 `make`，它会尝试编译一些不同步的模块，因此最好只编译当前目录下需要的模块。要加载新编译的 `can-isotp.ko`
    模块，运行 `insmod`：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`dmesg` should show that it loaded properly:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`dmesg` 应该显示它已经正确加载：'
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**NOTE**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Once the ISO-TP driver has proven to be stable, it should be moved into the
    stable kernel branch in Linux. Depending on when you’re reading this, it may already
    have been moved, so be sure to check whether it’s already installed before compiling
    your own.*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦 ISO-TP 驱动程序证明稳定，它应该被移入 Linux 的稳定内核分支。根据你阅读的时间，它可能已经被移入，所以在编译自己的版本之前，务必检查它是否已经安装。*'
- en: '***The can-isotp.ko Module***'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***can-isotp.ko 模块***'
- en: 'The `can-isotp.ko` module is a CAN protocol implementation inside the Linux
    network layer that requires the system to load the `can.ko` core module. The `can.ko`
    module provides the network layer infrastructure for all in-kernel CAN protocol
    implementations, like `can_raw.ko`, `can_bcm.ko`, and `can-gw.ko`. If it’s working
    correctly, you should see this output in response to the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`can-isotp.ko` 模块是 Linux 网络层中的一个 CAN 协议实现，它要求系统加载 `can.ko` 核心模块。`can.ko` 模块为所有内核中的
    CAN 协议实现提供网络层基础设施，比如 `can_raw.ko`、`can_bcm.ko` 和 `can-gw.ko`。如果它正常工作，你应该会看到以下命令的输出：'
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When `can.ko` is not loaded, you get the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `can.ko` 没有加载时，你会看到以下内容：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you’ve forgotten to attach your CAN device or load the CAN kernel module,
    this is the strange error message you’ll see. If you were to enter `dmesg` for
    more information, you’d see a series of missing symbols referenced in the error
    messages.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记连接你的 CAN 设备或加载 CAN 内核模块，你会看到这个奇怪的错误消息。如果你输入 `dmesg` 以获取更多信息，你会看到错误消息中引用的一系列缺失符号。
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `dmesg` output shows a lot of `Unknown symbol` messages, especially around
    `can_``x` methods. (Ignore the `(err 0)` messages.) These messages tell us that
    the `_isotop` module can’t find methods related to standard CAN functions. These
    messages indicate that you need to load the `can.ko` module. Once loaded, everything
    should work fine.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`dmesg` 输出显示了大量的 `Unknown symbol` 消息，特别是在 `can_``x` 方法周围。（忽略 `(err 0)` 消息。）这些消息告诉我们
    `_isotop` 模块无法找到与标准 CAN 功能相关的方法。这些消息表明你需要加载 `can.ko` 模块。一旦加载，所有功能应该就能正常工作。'
- en: '**Coding SocketCAN Applications**'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写 SocketCAN 应用程序**'
- en: While `can-utils` is very robust, you’ll find that you want to write custom
    tools to perform specific actions. (If you’re not a developer, you may want to
    skip this section.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `can-utils` 非常强大，但你会发现你可能需要编写自定义工具来执行特定操作。（如果你不是开发人员，可能希望跳过这一部分。）
- en: '***Connecting to the CAN Socket***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***连接到 CAN 套接字***'
- en: In order to write your own utilities, you first need to connect to the CAN socket.
    Connecting to a CAN socket on Linux is the same as connecting to any networking
    socket that you might know from TCP/IP network programming. The following shows
    C code that’s specific to CAN as well as the minimum required code to connect
    to a CAN socket. This code snippet will bind to `can0` as a raw CAN socket.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写你自己的工具，首先需要连接到 CAN 套接字。在 Linux 上连接到 CAN 套接字和连接到任何你可能知道的 TCP/IP 网络套接字是一样的。以下显示的是特定于
    CAN 的 C 代码，以及连接到 CAN 套接字所需的最小代码。这段代码会将套接字绑定到 `can0` 作为原始 CAN 套接字。
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s dissect the sections that are specific to CAN:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来剖析一下特定于 CAN 的部分：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This line specifies the protocol family, `PF_CAN`, and defines the socket as
    `CAN_RAW`. You can also use `CAN_BCM` if you plan on making a broadcast manager
    (BCM) service. A BCM service is a more complex structure that can monitor for
    byte changes and the queue of cyclic CAN packet transmissions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这行指定了协议族 `PF_CAN`，并将套接字定义为 `CAN_RAW`。如果你打算创建一个广播管理器（BCM）服务，你也可以使用 `CAN_BCM`。BCM
    服务是一种更复杂的结构，可以监控字节变化和循环 CAN 数据包传输的队列。
- en: 'These two lines name the interface:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行命名了接口：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These lines set up the CAN family for `sockaddr` and then bind to the socket,
    allowing you to read packets off the network:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行设置 `sockaddr` 的 CAN 家族，并绑定到套接字，允许你从网络读取数据包：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***Setting Up the CAN Frame***'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置 CAN 帧***'
- en: 'Next we want to setup the CAN frame and read the bytes off the CAN network
    into our newly defined structure:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要设置 CAN 帧，并将 CAN 网络上的字节读取到我们新定义的结构中：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `can_frame` is defined in *linux/can.h* as:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`can_frame` 在 *linux/can.h* 中定义为：'
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Writing to the CAN network is just like the `read` command but in reverse. Simple,
    eh?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 CAN 网络就像 `read` 命令，但方向相反。简单吧？
- en: '***The Procfs Interface***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Procfs 接口***'
- en: 'The SocketCAN network-layer modules implement a *procfs* interface as well.
    Having access to information in *proc* can make bash scripting easier and also
    provide a quick way to see what the kernel is doing. You’ll find the provided
    network-layer information in */proc/net/can/* and */proc/net/can-bcm/*. You can
    see a list of hooks into the CAN receiver by searching the *rcvlist_all* file
    with `cat`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: SocketCAN 网络层模块也实现了 *procfs* 接口。访问 *proc* 中的信息可以让 bash 脚本编写更容易，并提供一种快速查看内核活动的方式。你可以在
    */proc/net/can/* 和 */proc/net/can-bcm/* 中找到提供的网络层信息。你可以通过 `cat` 搜索 *rcvlist_all*
    文件，查看 CAN 接收器的挂钩列表：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Some other useful *procfs* files include the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些有用的 *procfs* 文件包括以下内容：
- en: '***stats*** CAN network-layer stats'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '***统计*** CAN 网络层统计'
- en: '***reset_stats*** Resets the stats (for example, for measurements)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '***重置统计*** 重置统计（例如，用于测量）'
- en: '***version*** SocketCAN version'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '***版本*** SocketCAN 版本'
- en: 'You can limit the maximum length of transmitted packets in *proc*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *proc* 中限制传输数据包的最大长度：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Set this value to whatever you feel will be the maximum packet length for your
    application. You typically won’t need to change this value, but if you find that
    you’re having throttling issues, you may want to fiddle with it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将此值设置为你认为适合你应用程序的最大数据包长度。通常情况下，你不需要更改这个值，但如果你发现有流量限制问题，可以尝试调整它。
- en: '**The Socketcand Daemon**'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Socketcand 守护进程**'
- en: Socketcand (*[https://github.com/dschanoeh/socketcand](https://github.com/dschanoeh/socketcand)*)
    provides a network interface into a CAN network. Although it doesn’t include `can-utils`,
    it can still be very useful, especially when developing an application in a programming
    language like Go that can’t set the CAN low-level socket options described in
    this chapter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Socketcand (*[https://github.com/dschanoeh/socketcand](https://github.com/dschanoeh/socketcand)*)
    提供了一个进入 CAN 网络的网络接口。虽然它不包括 `can-utils`，但仍然非常有用，特别是在开发类似 Go 这样的编程语言应用时，Go 语言无法设置本章中描述的
    CAN 低级套接字选项。
- en: 'Socketcand includes a full protocol to control its interaction with the CAN
    bus. For example, you can send the following line to socketcand to open a loopback
    interface:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Socketcand 包含一个完整的协议，用于控制与 CAN 总线的交互。例如，你可以向 socketcand 发送以下命令来打开回环接口：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The protocol for socketcand is essentially the same as that of Jan-Niklas Meier’s
    BCM server mentioned earlier; it’s actually a fork of the BCM server. (Socketcand,
    however, is a bit more robust than the BCM server.)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: socketcand 的协议本质上与前面提到的 Jan-Niklas Meier 的 BCM 服务器相同；实际上它是 BCM 服务器的一个分支。（不过，Socketcand
    比 BCM 服务器更为健壮。）
- en: '**Kayak**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Kayak**'
- en: Kayak (*[http://kayak.2codeornot2code.org/](http://kayak.2codeornot2code.org/)*),
    a Java-based GUI for CAN diagnostics and monitoring (see [Figure 3-2](ch03.html#ch3fig2)),
    is one of the best tools for use with socketcand. Kayak links with OpenStreetMaps
    for mapping and can handle CAN definitions. As a Java-based application, it’s
    platform independent, so it leans on socketcand to handle communication to the
    CAN transceivers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Kayak (*[http://kayak.2codeornot2code.org/](http://kayak.2codeornot2code.org/)*),
    一个基于 Java 的 CAN 诊断和监控 GUI（参见[图 3-2](ch03.html#ch3fig2)），是与 socketcand 一起使用的最佳工具之一。Kayak
    与 OpenStreetMaps 连接进行地图显示，并能处理 CAN 定义。作为一个基于 Java 的应用程序，它是平台无关的，因此依赖 socketcand
    来处理与 CAN 收发器的通信。
- en: 'You can download a binary package for Kayak or compile from source. In order
    to compile Kayak, install the latest version of Apache Maven, and clone the Kayak
    git repository (*[git://github.com/dschanoeh/Kayak](http://git://github.com/dschanoeh/Kayak)*).
    Once the clone is complete, run the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以下载 Kayak 的二进制包或从源码编译。为了编译 Kayak，安装最新版本的 Apache Maven，并克隆 Kayak 的 Git 仓库 (*[git://github.com/dschanoeh/Kayak](http://git://github.com/dschanoeh/Kayak)*)。克隆完成后，运行以下命令：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You should find your binary in the *Kayak/application/target/kayak/bin* folder.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能在 *Kayak/application/target/kayak/bin* 文件夹中找到你的二进制文件。
- en: '![image](graphics/f03-02.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f03-02.jpg)'
- en: '*Figure 3-2: The Kayak GUI*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：Kayak GUI 界面*'
- en: 'Before you launch Kayak, start socketcand:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 Kayak 之前，先启动 socketcand：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**NOTE**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can attach as many CAN devices as you want to socketcand, separated by
    commas.*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以将任意多个 CAN 设备连接到 socketcand，用逗号分隔。*'
- en: 'Next, start Kayak and take the following steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动 Kayak 并执行以下步骤：
- en: Create a new project with CTRL-N and give it a name.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 CTRL-N 创建一个新项目并为其命名。
- en: Right-click the project and choose **Newbus**; then, give your bus a name (see
    [Figure 3-3](ch03.html#ch3fig3)).
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击项目并选择 **Newbus**；然后为你的总线命名（参见[图 3-3](ch03.html#ch3fig3)）。
- en: '![image](graphics/f03-03.jpg)'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f03-03.jpg)'
- en: '*Figure 3-3: Creating a name for the CAN bus*'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 3-3：为 CAN 总线创建名称*'
- en: Click the **Connections** tab at the right; your socketcand should show up under
    Auto Discovery (see [Figure 3-4](ch03.html#ch3fig4)).
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右侧的 **连接** 标签；你的 socketcand 应该会出现在自动发现下（参见[图 3-4](ch03.html#ch3fig4)）。
- en: '![image](graphics/f03-04.jpg)'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f03-04.jpg)'
- en: '*Figure 3-4: Finding Auto Discovery under the Connections tab*'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 3-4：在连接标签下找到自动发现*'
- en: 'Drag the socketcand connection to the bus connection. (The bus connection should
    say *Connection: None* before it’s set up.) To see the bus, you may have to expand
    it by clicking the drop-down arrow next to the bus name, as shown in [Figure 3-5](ch03.html#ch3fig5).'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 socketcand 连接拖动到总线连接上。（在设置之前，总线连接应该显示为 *连接：无*。）要查看总线，你可能需要通过点击总线名称旁的下拉箭头来展开，如[图
    3-5](ch03.html#ch3fig5)所示。
- en: '![image](graphics/f03-05.jpg)'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f03-05.jpg)'
- en: '*Figure 3-5: Setting up the bus connection*'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 3-5：设置总线连接*'
- en: Right-click the bus and choose **Open RAW view**.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击总线并选择 **打开 RAW 视图**。
- en: Press the play button (circled in [Figure 3-6](ch03.html#ch3fig6)); you should
    start to see packets from the CAN bus.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下播放按钮（见[图 3-6](ch03.html#ch3fig6)中的圆圈部分）；你应该会开始看到来自 CAN 总线的数据包。
- en: '![image](graphics/f03-06.jpg)'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](graphics/f03-06.jpg)'
- en: '*Figure 3-6: Open RAW view and press the play button to see packets from the
    CAN bus.*'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 3-6：打开 RAW 视图并按播放按钮查看来自 CAN 总线的数据包。*'
- en: Choose **Colorize** from the toolbar to make it easier to see and read the changing
    packets.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从工具栏中选择 **颜色化**，使你更容易看到和读取变化的数据包。
- en: Kayak can easily record and play back packet capture sessions, and it supports
    CAN definitions (stored in an open KDC format). As of this writing, the GUI doesn’t
    support creating definitions, but I’ll show how to create definitions later.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Kayak 可以轻松地记录和回放数据包捕获会话，并支持 CAN 定义（以开放的 KDC 格式存储）。截至目前，GUI 不支持创建定义，但我稍后会展示如何创建定义。
- en: Kayak is a great open source tool that can work on any platform. In addition,
    it has a friendly GUI with advanced features that allow you to define the CAN
    packets you see and view them graphically.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Kayak 是一个很棒的开源工具，可以在任何平台上运行。此外，它拥有一个友好的 GUI 和先进的功能，允许你定义所看到的 CAN 数据包并以图形方式查看它们。
- en: '**Summary**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned how to use SocketCAN as a unified interface for
    CAN devices and how to set up your device and apply the appropriate bit rate for
    your CAN bus. I reviewed all of the default CAN utilities in the `can-utils` package
    that come with SocketCAN support, and I showed you how to write low-level C code
    to directly interface with the CAN sockets. Finally, you learned how to use socketcand
    to allow remote interaction with your CAN devices and set up Kayak to work with
    socketcand. Now that you’ve set up communication with your vehicle, you’re just
    about ready to try out some attacks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 SocketCAN 作为 CAN 设备的统一接口，以及如何设置你的设备并为你的 CAN 总线应用适当的比特率。我回顾了所有带有
    SocketCAN 支持的默认 `can-utils` 工具包，并展示了如何编写低级 C 代码直接与 CAN 套接字进行交互。最后，你学习了如何使用 socketcand
    来实现远程与 CAN 设备的交互，并设置 Kayak 以便与 socketcand 配合使用。现在你已经设置好了与车辆的通信，接下来你就可以尝试一些攻击了。
