- en: '**8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8**'
- en: 'VIRTUAL SHADES: DRAWING AND DRAGGING IMAGES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟太阳镜：绘制和拖动图像**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: For the “Fruit Loot” and “Tic Tac Toe” games in [Chapters 3](ch03.xhtml#ch03)
    and [6](ch06.xhtml#ch06), you animated the `Canvas` and `ImageSprite` components
    from App Inventor’s Drawing and Animation drawer by programming `EdgeReached`,
    `TouchDown`, and other event handlers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第3章](ch03.xhtml#ch03) 和 [第6章](ch06.xhtml#ch06) 的“Fruit Loot”和“井字游戏”中，你通过编写
    `EdgeReached`、`TouchDown` 和其他事件处理程序，使用 App Inventor 的绘图和动画组件动画化了 `Canvas` 和 `ImageSprite`。
- en: In this chapter, we’ll program `Canvas` and `ImageSprite` moving, drawing, and
    dragging methods and event handlers to create an app that lets users draw, type,
    and drag images across a smartphone or tablet screen. Developers use similar functions
    to build apps that allow users to move elements, take handwritten notes, and doodle
    on the screen.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写 `Canvas` 和 `ImageSprite` 的移动、绘制、拖动方法以及事件处理程序，创建一个允许用户在智能手机或平板电脑屏幕上绘画、输入文本和拖动图像的应用程序。开发人员使用类似的功能来构建允许用户移动元素、手写笔记和在屏幕上涂鸦的应用。
- en: '**BUILDING THE “VIRTUAL SHADES” APP**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建“虚拟太阳镜”应用**'
- en: The “Virtual Shades” app lets users take pictures of themselves with their cameras
    and then drag images of sunglasses over their selfies to try them on virtually.
    As you build the app, you’ll learn to use the `Camera` to create the `Canvas`
    background, the `Slider` to adjust other components, and the `Notifier` to collect
    user input. You’ll also practice using many programming concepts you’ve already
    learned.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: “虚拟太阳镜”应用让用户通过相机拍摄自己的照片，然后将太阳镜的图像拖动到自拍照上，进行虚拟试戴。在构建这个应用的过程中，你将学习如何使用 `Camera`
    来创建 `Canvas` 背景，使用 `Slider` 调整其他组件，并使用 `Notifier` 收集用户输入。你还将练习使用已经学过的许多编程概念。
- en: To get started, log in to App Inventor and create a new project named VirtualShades.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请登录到 App Inventor 并创建一个名为 VirtualShades 的新项目。
- en: '**DECOMPOSING “VIRTUAL SHADES”**'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**分解“虚拟太阳镜”**'
- en: For this app, users should be able to take a picture that becomes the `Canvas`
    background, drag various pairs of sunglasses over the picture, and change the
    size of the sunglasses to get the right fit. They also should be able to doodle
    and add text to the photo; save it as a graphic that they can view, email, or
    text later; and erase the sunglasses as well as all drawing and text at any time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用，用户应能够拍摄一张照片作为 `Canvas` 背景，将不同的太阳镜图像拖到照片上，并调整太阳镜的大小以适应。用户还应能够在照片上涂鸦并添加文本；将其保存为可查看、发送邮件或短信的图像；并且可以随时清除太阳镜以及所有绘画和文本。
- en: 'We can break this action into eight steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个操作分解为八个步骤：
- en: When the user clicks the picture button, open the device’s camera. Set the picture
    the user takes as the `Canvas` background.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击拍照按钮时，打开设备的相机。将用户拍摄的照片设置为 `Canvas` 背景。
- en: When the user clicks the `ListPicker`, show the list of available sunglasses.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击 `ListPicker` 时，显示可用太阳镜的列表。
- en: After the user selects a pair of sunglasses, display them on the `Canvas`.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户选择一副太阳镜后，将其显示在 `Canvas` 上。
- en: When the user drags the sunglasses around the `Canvas`, move them where the
    user drags. When the user moves the `Slider`’s thumb, adjust the size of the sunglasses.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在 `Canvas` 上拖动太阳镜时，将它们移动到用户拖动的位置。当用户移动 `Slider` 的滑块时，调整太阳镜的大小。
- en: When the user clicks the draw button, show a `Notifier` alert letting the user
    know where to draw. When the user drags a finger around the `Canvas`, draw on
    the `Canvas` where the user drags.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击绘制按钮时，显示一个 `Notifier` 提示，告知用户在哪里绘制。当用户在 `Canvas` 上拖动手指时，在用户拖动的地方进行绘制。
- en: When the user clicks the type button, show a `Notifier` with a text box where
    the user can enter text. After the user submits the text, display it at the bottom
    of the `Canvas`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击输入按钮时，显示一个带有文本框的 `Notifier`，用户可以在其中输入文本。用户提交文本后，将其显示在 `Canvas` 底部。
- en: After the user clicks the save button, store a picture of the `Canvas` on the
    device, and show a `Notifier` alert letting the user know the storage location.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击保存按钮后，将 `Canvas` 的图片存储到设备中，并显示一个 `Notifier` 提示，告知用户存储位置。
- en: When the user clicks the trash button, erase all sunglasses, marks, and typing
    from the `Canvas`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击垃圾桶按钮时，清除 `Canvas` 上的所有太阳镜、标记和文本。
- en: 'You’ll need the following components:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下组件：
- en: Button (5) for the user to click to open the camera, draw, type, save, and erase
    the `Canvas`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮（5）供用户点击以打开相机、绘画、输入文本、保存和清除 `Canvas`。
- en: Camera to open the device’s camera
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Camera` 打开设备的相机
- en: Canvas to enable dragging and drawing
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Canvas` 来实现拖动和绘制
- en: HorizontalArrangement (2) to hold the `Label`, `Slider`, and `Button`s
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平排列（HorizontalArrangement）(2)，用于容纳 `Label`、`Slider` 和 `Button`
- en: ImageSprite (4) for the user to drag around the `Canvas`
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageSprite`（4），用户可以在 `Canvas` 上拖动'
- en: Label to provide `Slider` directions
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签，用于提供 `Slider` 方向
- en: ListPicker for the user to click to choose sunglasses `ImageSprite`s
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表选择器（ListPicker），供用户点击选择太阳镜 `ImageSprite`
- en: Notifier to show alerts and capture user text input
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知器，用于显示警报并捕获用户的文本输入
- en: Procedure to clear images from the `Canvas` and reset the `Slider`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除 `Canvas` 上图像并重置 `Slider` 的过程
- en: Slider for the user to adjust the size of `ImageSprite`s
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于调整 `ImageSprite` 大小的 Slider
- en: Variable (2) to store the `ImageSprite`s and their descriptions
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 (2)，用于存储 `ImageSprite` 和它们的描述
- en: VerticalArrangement to hold all visible components except the picture `Button`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VerticalArrangement`，用于包含除拍照 `Button` 外的所有可见组件'
- en: '**LAYING OUT “VIRTUAL SHADES” IN THE DESIGNER**'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在设计器中布局“虚拟遮阳板”**'
- en: Now let’s start laying out the app in the Designer by adjusting the app screen.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始在设计器中布局应用程序，调整应用屏幕。
- en: '**Adjusting the Screen**'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**调整屏幕**'
- en: First, change the screen’s horizontal alignment to center all contents. Then,
    to give users the most space to “try on” sunglasses, make the screen stay in portrait
    mode even when the user rotates the device. To do this, select **Portrait** under
    ScreenOrientation. Also, hide the status bar and screen title so they won’t take
    up space by unclicking the checkboxes under both ShowStatusBar and TitleVisible.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将屏幕的水平对齐方式改为居中所有内容。然后，为了给用户提供更多的空间“试戴”太阳镜，在用户旋转设备时，保持屏幕处于纵向模式。为此，选择屏幕方向下的**纵向**。同时，隐藏状态栏和屏幕标题，以免占用空间，通过取消勾选状态栏和标题可见性选框。
- en: '**Adding the Canvas and ImageSprites**'
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加 Canvas 和 ImageSprites**'
- en: Let’s place most of the visible components on the screen in a `VerticalArrangement`
    so that we can set their visibility as a group. When the app opens, only the `Button`
    to take a picture should show; the other components will go in the `VerticalArrangement`
    so we can hide them until later.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将大多数可见组件放在一个 `VerticalArrangement` 中，这样我们就可以将它们作为一组设置可见性。应用程序启动时，只有用于拍照的 `Button`
    应该显示，其它组件将放在 `VerticalArrangement` 中，以便我们可以在稍后隐藏它们。
- en: 'Drag a VerticalArrangement from the Layout drawer onto the Viewer. In the Properties
    pane, click the drop-down arrow under AlignHorizontal and select **Center: 3**,
    and set its height and width to **Fill parent** to make it cover the entire screen.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '从布局面板中拖动一个 `VerticalArrangement` 到 Viewer 中。在属性面板中，点击水平对齐下的下拉箭头并选择**居中: 3**，将其高度和宽度设置为**填充父级**，使其覆盖整个屏幕。'
- en: 'Now add components to the `VerticalArrangement` in the order in which we want
    them to appear. Start by dragging a Canvas from the Drawing and Animation drawer
    onto the Viewer inside of VerticalArrangement1. In the Properties pane, remove
    the `Canvas`’s background color by clicking the box under BackgroundColor and
    selecting **None**. Change its text size to 25 in the text box under FontSize.
    Make its height and width **Fill parent**, and increase the width of the line
    that can be drawn on it to 4 in the text box under LineWidth. Remove its paint
    color by clicking the box under PaintColor and selecting **None**. Lastly, left-align
    its text by clicking the drop-down arrow under TextAlignment and selecting **left:
    0**.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '现在按照我们希望它们出现的顺序，将组件添加到`VerticalArrangement`中。首先，从“绘图和动画”面板中拖动一个 Canvas 到 VerticalArrangement1
    内的 Viewer 中。在属性面板中，通过点击背景色下的框并选择**无**，移除 `Canvas` 的背景颜色。将其文本大小调整为 25，在字体大小框中输入。将其高度和宽度设置为**填充父级**，并在线宽框中将可绘制线条的宽度增加到
    4。通过点击绘画颜色下的框并选择**无**，移除其绘画颜色。最后，通过点击文本对齐方式下的下拉箭头并选择**左对齐: 0**，使其文本左对齐。'
- en: Now, drag four ImageSprites from the Drawing and Animation drawer onto the `Canvas`,
    click them in the Components pane, and rename them Sunglasses1, Sunglasses2, Sunglasses3,
    and Sunglasses4. Upload the images *tanSunglasses.png*, *purpleSunglasses.png*,
    *redSunglasses.png*, and *blackSunglasses.png*, all of which come with the resources
    for this book, to the `ImageSprite`s by clicking **Picture** in the Properties
    pane for each. Also, make each `ImageSprite` invisible by deselecting the box
    under **Visible**, and change both the X and Y property for each to 0 so that
    they appear at the top left of the `Canvas` when they show up in the app.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从绘图和动画面板中拖动四个ImageSprite到`Canvas`上，在组件面板中点击它们，并将它们重命名为Sunglasses1、Sunglasses2、Sunglasses3和Sunglasses4。上传*tanSunglasses.png*、*purpleSunglasses.png*、*redSunglasses.png*和*blackSunglasses.png*四张图片，这些图片都来自本书的资源，点击每个`ImageSprite`的**图片**选项，上传图片。然后，通过取消选择**Visible**选项来使每个`ImageSprite`不可见，并将每个`ImageSprite`的X和Y属性都设置为0，以便它们在应用程序中显示时出现在`Canvas`的左上角。
- en: '**Adding User Buttons and Controls**'
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加用户按钮和控件**'
- en: Drag a ListPicker from the User Interface drawer into VerticalArrangement1 under
    the `Canvas` and make its background color red, its font bold, its height 35 pixels,
    and its width **Fill parent**. Also, change the default text to Choose Glasses
    and make the text white.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户界面面板中拖动一个列表选择器（ListPicker）到`Canvas`下的VerticalArrangement1，并将其背景颜色设置为红色，字体设置为粗体，高度设置为35像素，宽度设置为**填充父项**。同时，将默认文本改为“选择眼镜”，并将文本颜色设置为白色。
- en: 'Now we’ll add a `Label` and `Slider`, which we want to position side by side
    to save space. That means we need to place them within a `HorizontalArrangement`.
    Drag a HorizontalArrangement from the Layout drawer into VerticalArrangement1
    under the `ListPicker` and rename it SliderArrangement. Then, select **Center:
    3** under AlignHorizontal and make its width **Fill parent**.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们将添加一个`Label`和一个`Slider`，它们将并排放置以节省空间。这意味着我们需要将它们放入一个`HorizontalArrangement`中。从布局面板中拖动一个HorizontalArrangement到VerticalArrangement1下的`ListPicker`位置，并将其重命名为SliderArrangement。然后，在AlignHorizontal下选择**Center:
    3**，并将其宽度设置为**填充父项**。'
- en: Drag a Label and a Slider from the User Interface drawer into SliderArrangement,
    with the `Label` on the left. Make the `Label`’s font bold, change its default
    text to Adjust Sunglasses Width:, center-align its text, and make the text red.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户界面面板中拖动一个标签（Label）和一个滑动条（Slider）到SliderArrangement中，并将`Label`放在左侧。将`Label`的字体设置为粗体，改变其默认文本为“调整太阳镜宽度：”，将文本居中对齐，并将文本颜色设置为红色。
- en: Make `Slider1`’s ColorLeft red to match the color scheme and **Width** 40 percent
    so it will fit next to the `Label`. Also, so the user can change the width of
    the sunglasses from 150 to 250 pixels, make the `Slider`’s MaxValue 250 and MinValue
    150. Then set the ThumbPosition to 200 so the `Slider`’s thumb will sit in the
    middle of the slider when it appears. Next, disable the `Slider`’s thumb by unclicking
    the checkbox under ThumbEnabled, which will keep the `Slider` from moving until
    we program it to work after a user drags sunglasses onto the `Canvas`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Slider1`的ColorLeft设置为红色以匹配颜色方案，**宽度**设置为40%，使其能够与`Label`并排放置。同时，为了让用户能够将太阳镜的宽度从150像素调整到250像素，将`Slider`的MaxValue设置为250，MinValue设置为150。接下来，将ThumbPosition设置为200，这样当滑块显示时，滑块的指示器将位于滑块的中间。然后，通过取消选中ThumbEnabled下的复选框来禁用`Slider`的指示器，这样滑块就不会移动，直到我们编写程序使它在用户将太阳镜拖到`Canvas`上后开始工作。
- en: 'Now let’s add the `Button`s. We’ll place the first four `Button`s side by side
    in a second `HorizontalArrangement`, also to save space. Place this HorizontalArrangement
    under SliderArrangement in VerticalArrangement1 and name it ButtonArrangement,
    center its contents by selecting **Center: 3** under AlignHorizontal, and make
    its width **Fill parent**.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们添加`Button`按钮。我们将把前四个`Button`按钮并排放置在第二个`HorizontalArrangement`中，同样是为了节省空间。将这个HorizontalArrangement放在SliderArrangement下的VerticalArrangement1中，并将其命名为ButtonArrangement，通过选择AlignHorizontal下的**Center:
    3**来使其中的内容居中，并将其宽度设置为**填充父项**。'
- en: Drag four buttons from the User Interface drawer into ButtonArrangement and
    rename them, from left to right, DrawBtn, TypeBtn, SaveBtn, and TrashBtn. Then,
    in the Properties pane for each, under **Image**, upload *DrawBtn.png*, *TypeBtn.png*,
    *SaveBtn.png*, and *TrashBtn.png*, respectively, all of which come with the resources
    for this book. Set the height of each `Button` to 50 pixels and remove each `Button`’s
    default text from the text box under **Text**. Note that the four buttons may
    not be fully visible in the Viewer, but you should see them when you test on a
    device.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户界面抽屉中拖动四个按钮到 ButtonArrangement 中，并按从左到右的顺序分别重命名为 DrawBtn、TypeBtn、SaveBtn
    和 TrashBtn。然后，在每个按钮的属性面板中，在 **Image** 下上传 *DrawBtn.png*、*TypeBtn.png*、*SaveBtn.png*
    和 *TrashBtn.png*，这些文件都包含在本书的资源中。将每个 `Button` 的高度设置为 50 像素，并从 **Text** 下的文本框中移除每个
    `Button` 的默认文本。请注意，四个按钮在 Viewer 中可能无法完全显示，但在设备上测试时应能看到它们。
- en: Now that we’ve placed all the components we need inside of `VerticalArrangement1`,
    we need to hide it until after the user takes a picture. To make it invisible,
    in its Properties pane, unclick the checkbox under **Visible**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有需要的组件放置在 `VerticalArrangement1` 内，我们需要在用户拍照之前将其隐藏。要使其不可见，在其属性面板中，取消选中
    **Visible** 下的复选框。
- en: Finally, add the last `Button`, which is the only visible component we’ll place
    outside of `VerticalArrangement1`. Users click this Button to open the camera
    when they first enter the app. Drag the new Button from the User Interface drawer
    onto the Viewer, and rename it TakePicBtn in the Components pane. Make its height
    and width **Fill parent** to cover the entire screen. Next, add a background image
    to the `Button` by clicking the text box under **Image** and uploading *TakePictureBtn.png*,
    which comes with the resources for this book. Also remove the `Button`’s default
    text.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加最后一个 `Button`，这是唯一一个我们会放置在 `VerticalArrangement1` 外的可见组件。用户点击这个按钮来打开相机，当他们第一次进入应用时。将新的按钮从用户界面抽屉拖动到
    Viewer 中，并在组件面板中将其重命名为 TakePicBtn。将其高度和宽度设置为 **Fill parent**，以覆盖整个屏幕。接下来，点击 **Image**
    下的文本框上传 *TakePictureBtn.png*，这是本书资源的一部分，为按钮添加背景图片。同时，移除 `Button` 的默认文本。
- en: '**Preparing the Non-Visible Components**'
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**准备不可见组件**'
- en: Now let’s add and adjust the non-visible components. Drag a Camera component
    from the Media drawer and a Notifier component from the User Interface drawer.
    Change the Notifier’s BackgroundColor to red.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加并调整不可见组件。从媒体抽屉中拖动一个 Camera 组件，从用户界面抽屉中拖动一个 Notifier 组件。将 Notifier 的 BackgroundColor
    更改为红色。
- en: At this point, your screen should look like [Figure 8-1](ch08.xhtml#ch8fig1).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你的屏幕应该像 [图 8-1](ch08.xhtml#ch8fig1) 所示。
- en: '![Image](../images/08fig01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/08fig01.jpg)'
- en: '*Figure 8-1: The Viewer, Components, and partial Media panes after you’ve laid
    out “Virtual Shades”*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：在你布置“虚拟遮阳”后，Viewer、组件和部分媒体面板*'
- en: Now that you’ve laid out all components, move to the Blocks Editor to program
    the app.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经布置好所有组件，接下来转到块编辑器编程应用程序。
- en: '**PROGRAMMING “VIRTUAL SHADES” IN THE BLOCKS EDITOR**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在块编辑器中编程“虚拟遮阳”**'
- en: For “Virtual Shades,” we’ll create two list variables and a procedure, and we’ll
    program 15 event handlers with three conditionals and one `for each` loop.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“虚拟遮阳”，我们将创建两个列表变量和一个过程，并编程 15 个事件处理器，包含三个条件判断和一个 `for each` 循环。
- en: '**STEP 1: SETTING THE SELFIE AS THE CANVAS BACKGROUND**'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤 1：设置自拍作为画布背景**'
- en: In this step, we want the user to take a photo that will become the `Canvas`
    background for the user to drag and draw on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们希望用户拍摄一张照片，作为 `Canvas` 背景，供用户拖动和绘制。
- en: '**Taking the Photo**'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**拍摄照片**'
- en: We start by having the app open the camera when a user clicks `TakePicBtn`.
    Here is the event handler for this.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先让应用在用户点击 `TakePicBtn` 时打开相机。以下是这个事件处理器的代码。
- en: '![Image](../images/f0146-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0146-01.jpg)'
- en: In the Blocks pane, click TakePicBtn and drag the whenTakePicBtn.Click event
    handler block ➊ to the Viewer. Then, drag Camera1’s callCamera1.TakePicture method
    call block ➋ next to the word `do`. When the user clicks `TakePicBtn`, these blocks
    open the camera so the user can take the photo.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在块面板中，点击 TakePicBtn 并将 whenTakePicBtn.Click 事件处理器块 ➊ 拖动到 Viewer 中。然后，将 Camera1
    的 callCamera1.TakePicture 方法调用块 ➋ 拖动到 `do` 字旁边。当用户点击 `TakePicBtn` 时，这些块将打开相机，供用户拍摄照片。
- en: '**Setting the Canvas Background and Showing App Controls**'
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设置画布背景并显示应用控件**'
- en: After the user takes the selfie, we need the picture to become the `Canvas`
    background, `TakePicBtn` to disappear, and the `VerticalArrangement` that holds
    the `Canvas` and other user interface components to appear. The `Camera`’s `AfterPicture`
    event handler programs this action.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户拍完自拍后，我们需要将照片设为`Canvas`背景，`TakePicBtn`消失，并且包含`Canvas`和其他用户界面组件的`VerticalArrangement`出现。`Camera`的`AfterPicture`事件处理程序会编写这个动作。
- en: '![Image](../images/f0146-02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0146-02.jpg)'
- en: Drag Camera1’s whenCamera1.AfterPicture event handler block ➊ to the Viewer.
    This event handler reports the value for the `image` event parameter, which is
    the picture taken by the `Camera`. We’ll set the `Canvas` background to that value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将Camera1的whenCamera1.AfterPicture事件处理程序块 ➊拖到查看器中。该事件处理程序报告`image`事件参数的值，即由`Camera`拍摄的照片。我们将把`Canvas`的背景设置为这个值。
- en: Drag Canvas1’s setCanvas1.BackgroundImageto block ➋ into the whenCamera1.AfterPicture
    block. Then mouse over the image event parameter and snap its get image block
    ➌ to the right of the setCanvas1.BackgroundImageto block. These blocks set the
    user’s picture as the `Canvas` background.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将Canvas1的setCanvas1.BackgroundImageto块 ➋拖到whenCamera1.AfterPicture块中。然后，将鼠标悬停在图像事件参数上，将其get
    image块 ➌拖到setCanvas1.BackgroundImageto块的右侧。这些块将用户的照片设置为`Canvas`的背景。
- en: Now, to make `TakePicBtn` disappear, drag its setTakePicBtn.Visibleto block
    ➍ into the event handler block and snap in a false block ➎.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了让`TakePicBtn`消失，将其setTakePicBtn.Visibleto块 ➍拖到事件处理程序块中，并插入一个false块 ➎。
- en: Next, we’ll make the `Canvas` and components in the `VerticalArrangement` visible
    so the user can drag and “try on” the sunglasses and draw and type on the `Canvas`.
    Drag VerticalArrangement1’s setVerticalArrangement1.Visibleto block ➏ into the
    event handler and attach a true block to it ➐.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使`Canvas`和`VerticalArrangement`中的组件可见，这样用户就可以拖动并“试戴”太阳镜，还可以在`Canvas`上绘画和输入文字。将VerticalArrangement1的setVerticalArrangement1.Visibleto块
    ➏拖到事件处理程序中，并将一个true块附加到它 ➐。
- en: Put together, the blocks in step 1 open the camera when the user clicks the
    picture button and, after the user takes a picture, set the `Canvas` background
    to that picture, hide the button by setting its `Visible` property to `false`,
    and show the `VerticalArrangement` containing the `Canvas` and app controls by
    setting its `Visible` property to `true`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将步骤1中的这些块组合在一起，当用户点击拍照按钮时，打开相机，用户拍照后，将`Canvas`背景设置为该照片，通过将按钮的`Visible`属性设置为`false`来隐藏按钮，并通过将`VerticalArrangement`的`Visible`属性设置为`true`来显示包含`Canvas`和应用控件的`VerticalArrangement`。
- en: To see how these blocks work, live-test with a device. You should see the full-screen
    `TakePicBtn` when you open the app. When you click it, your camera should open,
    and the picture you take should become the background of the top portion of your
    app screen, where you placed the `Canvas`. If the picture is rotated the wrong
    way in the app, close and reopen the app, rotate your camera, and take another
    photo until it displays the way you want.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这些块如何工作，可以通过设备进行实时测试。打开应用时，你应该看到全屏的`TakePicBtn`。点击它时，相机应该会打开，拍摄的照片应成为你应用屏幕顶部区域的背景，这里是你放置`Canvas`的地方。如果照片在应用中显示的方向不对，关闭并重新打开应用，旋转相机，再拍一张照片，直到它以你希望的方式显示。
- en: Below the picture, you should see the `ListPicker` with the app’s Slider and
    the draw, type, save, and trash buttons beneath it, but none of these controls
    should work yet. Leave the app open on your device to keep live-testing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在照片下方，你应该看到带有应用程序Slider的`ListPicker`，以及其下方的绘图、输入文字、保存和删除按钮，但这些控件目前都无法使用。保持应用程序在设备上打开，以继续实时测试。
- en: '**STEP 2: ADDING SUNGLASSES TO CHOOSE FROM**'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤2：添加可选择的太阳镜**'
- en: Now let’s program step 2 of the app, the `ListPicker`’s `BeforePicking` event
    handler, which will set the options for the `ListPicker` that the user clicks
    to select each pair of sunglasses.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写应用程序的步骤2，即`ListPicker`的`BeforePicking`事件处理程序，它将设置用户点击的`ListPicker`选项来选择每副太阳镜。
- en: To provide these options, we’ll create a global variable called `glassesDescriptions`
    to hold descriptions of the four pairs of sunglasses. We’ll also create a related
    global list variable, `glassesSprites`, which will hold the `ImageSprite`s that
    display the sunglasses. Creating these as global variables allows us to use them
    in every event handler and procedure in the app.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这些选项，我们将创建一个名为`glassesDescriptions`的全局变量，用于存储四副太阳镜的描述。我们还将创建一个相关的全局列表变量`glassesSprites`，它将存储显示太阳镜的`ImageSprite`。将这些作为全局变量创建，可以让我们在应用中的每个事件处理程序和过程里使用它们。
- en: '**Creating the glassesDescriptions and glassesSprites List Variables**'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建glassesDescriptions和glassesSprites列表变量**'
- en: The following blocks create `glassesDescriptions`, the variable that holds the
    options we’ll add to the `ListPicker` to describe each pair of sunglasses, and
    `glassesSprites`, the variable that holds the `ImageSprites` (`Sunglasses1` through
    `Sunglasses4`) that display the corresponding pictures of the sunglasses.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下块创建了 `glassesDescriptions`，这是一个保存我们将在 `ListPicker` 中添加的项目的变量，用于描述每副太阳镜，以及
    `glassesSprites`，这是一个保存显示相应太阳镜图片的 `ImageSprites`（`Sunglasses1` 到 `Sunglasses4`）的变量。
- en: '![Image](../images/f0147-01.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0147-01.jpg)'
- en: To create the variables, drag two initialize global name blocks ➊ from the Variables
    block drawer to the Viewer and name one variable glassesDescriptions and the other
    glassesSprites. Then attach a make a list block ➋ from the Lists drawer to each
    initialize global block.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建变量，从变量块抽屉中拖动两个初始化全局名称块 ➊ 到查看器，并将其中一个命名为glassesDescriptions，另一个命名为glassesSprites。然后，从列表块抽屉中将一个创建列表块
    ➋ 附加到每个初始化全局块。
- en: Add two more sockets to each make a list block’s two default inputs by clicking
    the blue mutator icon to the left of the words make a list and dragging the additional
    item blocks to the make a list block in the dialog that opens. Finally, for `glassesDescriptions`,
    drag in four empty string blocks ➌, snap them into the sockets of the make a list
    block, and enter the text shown. For `glassesSprites`, click `Sunglasses1` through
    `Sunglasses4` in the Blocks pane and drag each `ImageSprite`’s getter block ➍
    into its socket in the `make a list` block. These blocks create the two variables
    so that each item in `glassesSprites` corresponds with the item at the same index
    position in `glassesDescriptions`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击位于“创建列表”文字左侧的蓝色变异器图标，为每个创建列表块的两个默认输入添加两个插槽，并将额外的项目块拖到打开的对话框中的创建列表块中。最后，对于
    `glassesDescriptions`，拖动四个空字符串块 ➌，将它们连接到创建列表块的插槽中，并输入显示的文本。对于 `glassesSprites`，在块面板中点击
    `Sunglasses1` 到 `Sunglasses4`，并将每个 `ImageSprite` 的获取块 ➍ 拖动到 `创建列表` 块的插槽中。这些块创建了两个变量，使得
    `glassesSprites` 中的每个项目与 `glassesDescriptions` 中相同索引位置的项目相对应。
- en: '**Setting the ListPicker Options**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设置 ListPicker 选项**'
- en: Next, we’ll code the `ListPicker`’s `BeforePicker` event handler, which sets
    the `ListPicker`’s elements to the items in `glassesDescriptions`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写 `ListPicker` 的 `BeforePicker` 事件处理程序，它将 `ListPicker` 的元素设置为 `glassesDescriptions`
    中的项目。
- en: '![Image](../images/f0148-01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0148-01.jpg)'
- en: To add the blocks, drag ListPicker1’s whenListPicker1.BeforePicking event handler
    block ➊ to the Viewer. Then drag its setListPicker1.Elementsto block ➋ inside
    the event handler block, and snap the get global glassesDescriptions block ➌ to
    the right of the setListPicker1.Elementsto block.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加这些块，拖动 `ListPicker1` 的 whenListPicker1.BeforePicking 事件处理程序块 ➊ 到查看器。然后将其
    setListPicker1.Elementsto 块 ➋ 拖入事件处理程序块内，并将获取全局变量 glassesDescriptions 块 ➌ 拖到 setListPicker1.Elementsto
    块的右侧。
- en: Live-test the app to see how these blocks work. When you click the `ListPicker`,
    you should see the selection options, which are descriptions of each pair of sunglasses.
    Nothing should happen yet when you select a pair, except that the `ListPicker`
    should close. Leave the app open on your device to keep live-testing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 进行实时测试，看看这些块是如何工作的。当你点击 `ListPicker` 时，应该会看到选择选项，它们是每副太阳镜的描述。此时选择一副太阳镜时应该没有任何反应，除了
    `ListPicker` 会关闭。保持应用在设备上打开，继续实时测试。
- en: '**STEP 3: SELECTING A PAIR OF SUNGLASSES TO TRY**'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤 3：选择要试戴的太阳镜**'
- en: Let’s now program the `ListPicker`’s `AfterPicking` event handler, which tells
    the app what to do after the user picks a pair of sunglasses. At that point, if
    there’s already a pair of sunglasses on the `Canvas`, the app should remove it
    and reset the `Slider` that adjusts the width of the sunglasses, in case the user
    previously adjusted it. If, on the other hand, it’s the user’s first pick from
    the `ListPicker`, we want the app to enable the `Slider`. Then, we want the app
    to show the pair of sunglasses the user selected.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写 `ListPicker` 的 `AfterPicking` 事件处理程序，它告诉应用在用户选择一副太阳镜后该做什么。此时，如果 `Canvas`
    上已经有一副太阳镜，应用应将其移除，并重置调节太阳镜宽度的 `Slider`，以防用户之前已调整过。如果这是用户第一次从 `ListPicker` 中选择，我们希望应用启用
    `Slider`。然后，我们希望应用显示用户选择的那副太阳镜。
- en: '**Creating the clearSprite Procedure**'
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建 clearSprite 过程**'
- en: To clear an existing `ImageSprite` and reset the `Slider`, we’ll use a procedure
    called `clearSprite`, which we’ll call in the `ListPicker`’s `AfterPicking` event
    handler and later in the handler we’ll create to clear the `Canvas`. The `clearSprite`
    procedure uses a conditional block to test whether there’s an image on the `Canvas`.
    If there is, it removes the image and moves the `Slider` thumb back to its starting
    position.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清除现有的`ImageSprite`并重置`Slider`，我们将使用一个名为`clearSprite`的过程，在`ListPicker`的`AfterPicking`事件处理程序中调用它，稍后在我们创建的处理程序中也会调用该过程来清除`Canvas`。`clearSprite`过程使用一个条件块来测试`Canvas`上是否有图像。如果有，它会移除该图像，并将`Slider`滑块恢复到初始位置。
- en: '![Image](../images/f0149-01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0149-01.jpg)'
- en: Click the **Procedures** blocks drawer in the Blocks pane, drag the to procedure
    do block ➊ to the Viewer, and name the procedure clearSprite. Next, we’ll test
    whether there’s an `ImageSprite` on the `Canvas` by determining whether the current
    `ListPicker` selection index is `1` or greater. Since the four sunglasses `ImageSprite`s
    have the index positions `1` through `4`, we’ll know by checking the index whether
    one of them is showing on the `Canvas`. If it is, then the app needs to clear
    it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 点击块面板中的**Procedures**块抽屉，拖动到过程do块 ➊ 到查看器中，并命名该过程为clearSprite。接下来，我们将通过检查当前的`ListPicker`选择索引是否为`1`或更大，来测试`Canvas`上是否有`ImageSprite`。由于四个太阳镜的`ImageSprite`索引位置为`1`至`4`，我们可以通过检查索引来知道它们中的某个是否显示在`Canvas`上。如果是，那么应用程序需要清除它。
- en: Snap an if then block ➋ inside the clearSprite procedure block and a `≥` comparison
    block ➌ into the if then block’s if socket. Fill the comparison block’s left operand
    socket with the ListPicker.SelectionIndex block ➍ and its right socket with a
    1 number block ➎. So far, the `if then` block sets up the test condition by saying,
    “If the `ListPicker1` selection index is greater than or equal to `1`” and the
    sentence stops there. The next blocks complete the sentence by telling the app
    what to do if the condition is met.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`clearSprite`过程块内插入一个if then块 ➋，并将一个`≥`比较块 ➌ 插入if then块的if插槽。将比较块的左操作数插槽填充为ListPicker.SelectionIndex块
    ➍，右操作数插槽填充为数字块1 ➎。到目前为止，`if then`块通过说“如果`ListPicker1`选择索引大于或等于`1`”来设置测试条件，句子到这里为止。接下来的块通过告诉应用程序在条件满足时应该做什么来完成这个句子。
- en: '**Clearing All ImageSprites and Resetting the Slider**'
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**清除所有ImageSprites并重置Slider**'
- en: If the `ListPicker1` selection index is greater than or equal to `1`, the following
    blocks loop through and hide all `ImageSprite`s and reset the `Slider`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ListPicker1`选择索引大于或等于`1`，接下来的块会循环遍历并隐藏所有的`ImageSprite`，并重置`Slider`。
- en: '![Image](../images/f0149-02.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0149-02.jpg)'
- en: To place the blocks, drag a for each item block ➊ inside the if then block’s
    then socket, and change item to sprite. Then snap a get global glassesSprites
    block ➋ to the right of the for each block next to the word `list`. Next, click
    the plus sign to the left of **Any component** near the bottom of the Blocks pane,
    click the **Any ImageSprite** drawer, and drag a setImageSprite.Visible block
    ➌ inside the for each block. Fill the setter block’s top socket by mousing over
    the sprite item and dragging in a get sprite block ➍, and fill its bottom socket
    with a false block ➎. Now, when the procedure is called, all `ImageSprite`s will
    become invisible.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要放置这些块，拖动一个for each item块 ➊ 到if then块的then插槽，并将item更改为sprite。然后，在for each块右侧拖入一个get
    global glassesSprites块 ➋，紧接着是`list`一词。接下来，点击块面板底部**Any component**旁的加号，点击**Any
    ImageSprite**抽屉，然后将一个setImageSprite.Visible块 ➌ 拖入for each块内。通过鼠标悬停在sprite项上并拖动一个get
    sprite块 ➍，填充设置块的上插槽，并将其下插槽填充为false块 ➎。现在，当调用此过程时，所有`ImageSprite`都会变得不可见。
- en: Next we’ll add the blocks that reset the `Slider`. We need to do this because,
    later in the code, we’ll program an `ImageSprite`’s width to change when a user
    changes the `Slider`’s `ThumbPosition`. Just in case the user has changed the
    `ThumbPosition` for one of the `ImageSprite`s when it was showing on the `Canvas`,
    the next blocks change the `Slider`’s `ThumbPosition` and the `ImageSprite`’s
    width back to the `200` we set in the Designer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加重置`Slider`的块。我们需要这样做，因为在后续代码中，当用户更改`Slider`的`ThumbPosition`时，我们将编程使`ImageSprite`的宽度发生变化。为了防止用户在`ImageSprite`显示在`Canvas`上的时候改变了某个`ImageSprite`的`ThumbPosition`，接下来的块会将`Slider`的`ThumbPosition`和`ImageSprite`的宽度恢复到我们在设计器中设置的`200`。
- en: Drag Slider1’s setSlider1.ThumbPosition block ➏ inside the if then block under
    the for each block, and snap a 200 number block ➐ to its right. Now, when the
    procedure is called, these blocks reset the `Slider`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Slider1 的 setSlider1.ThumbPosition 块 ➏ 拖到 for each 块下的 if then 块内，然后将一个 200
    的数字块 ➐ 拖到它的右侧。现在，当调用过程时，这些块会重置 `Slider`。
- en: '**Calling clearSprite and Enabling the Slider**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**调用 clearSprite 并启用滑块**'
- en: Now that we’ve created the procedure, let’s build the `AfterPicker` event handler.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了过程，让我们构建 `AfterPicker` 事件处理器。
- en: '![Image](../images/f0150-01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0150-01.jpg)'
- en: The `AfterPicker` event handler will first call the `clearSprite` procedure
    we just created to clear any `ImageSprite`s from the screen and reset the `Slider`.
    It will then enable the `Slider`, if necessary, and show the selected pair of
    sunglasses.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`AfterPicker` 事件处理器将首先调用我们刚才创建的 `clearSprite` 过程，清除屏幕上的任何 `ImageSprite` 并重置
    `Slider`。然后，它将启用 `Slider`（如果有必要），并显示选中的太阳镜。'
- en: Drag ListPicker1’s whenListPicker1.AfterPicking block ➊ to the Viewer. Then,
    drag the call clearSprite block ➋ into the event handler block. These blocks call
    the `clearSprite` procedure after the user selects a pair of sunglasses in the
    `ListPicker`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ListPicker1 的 whenListPicker1.AfterPicking 块 ➊ 拖到 Viewer。然后，将 call clearSprite
    块 ➋ 拖到事件处理器块中。这些块在用户在 `ListPicker` 中选择一副太阳镜后调用 `clearSprite` 过程。
- en: Next, we’ll add the conditional block that lets the app know when to turn on
    the `Slider`, which we turned off in the Designer by unclicking the `ThumbEnabled`
    property. We disabled the thumb so that a user can’t move it before selecting
    a pair of sunglasses, which would cause an error.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个条件块，让应用程序知道何时启用 `Slider`，我们在设计器中通过取消选中 `ThumbEnabled` 属性来关闭它。我们禁用了滑块的按钮，以防用户在选择太阳镜之前移动它，这样会导致错误。
- en: It’s possible, though, that the user has already enabled the `Slider` by previously
    selecting a pair of sunglasses, so we must check for that. In the Blocks pane,
    drag an if then block ➌ into the event handler under the call clearSprite block.
    Then, fill the if socket with an = comparison operator block ➍, and fill the operator
    block’s left operand socket by dragging in Slider1’s Slider1.ThumbEnabled block
    ➎. Fill its right operand socket with a false block ➏.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有可能用户已经通过之前选择过一副太阳镜启用了 `Slider`，所以我们必须检查这一点。在 Blocks 面板中，将一个 if then 块 ➌
    拖到事件处理器的 call clearSprite 块下方。然后，将 if 插座填充为一个 = 比较运算符块 ➍，并将运算符块的左操作数插座填充为 Slider1
    的 Slider1.ThumbEnabled 块 ➎。将右操作数插座填充为一个 false 块 ➏。
- en: Next, fill the if then block’s then socket with a setSlider1.ThumbEnabled block
    ➐ and drag a true block ➑ to its right. Now, after the user selects a pair of
    sunglasses, this `if then` block will enable the `Slider`’s thumb *only if* it’s
    currently not enabled. Although the app will check this condition each time the
    user selects a pair of sunglasses, it will enable the `Slider`’s thumb only once,
    after the user’s first selection.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 if then 块的 then 插座填充为一个 setSlider1.ThumbEnabled 块 ➐，并将一个 true 块 ➑ 拖到它的右侧。现在，在用户选择一副太阳镜后，这个
    `if then` 块将只在 `Slider` 的按钮当前未启用时启用滑块的按钮。尽管每次用户选择一副太阳镜时，应用程序都会检查这个条件，但它只会在用户第一次选择后启用滑块的按钮一次。
- en: '**Showing the Selected ImageSprite**'
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**显示选中的 ImageSprite**'
- en: Finally, the `AfterPicker` event handler will display the selected pair of sunglasses
    on the `Canvas`. When added to the event handler, the following blocks will make
    this happen.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`AfterPicker` 事件处理器将显示选中的太阳镜在 `Canvas` 上。添加到事件处理器后的以下块将实现这一功能。
- en: '![Image](../images/f0151-01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0151-01.jpg)'
- en: These blocks set the `Visible` property of the user’s selected `ImageSprite`
    to `true` after they identify the correct `ImageSprite` by matching its index
    position in the `glassesSprites` list with the index of the selected `ListPicker1`
    option.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块在用户通过将其在 `glassesSprites` 列表中的索引位置与选定的 `ListPicker1` 选项的索引匹配后，设置用户选定的 `ImageSprite`
    的 `Visible` 属性为 `true`。
- en: To place these blocks, click the **Any ImageSprite** drawer and drag a setImageSprite.Visible
    block ➊ inside the event handler block under the if then block. Fill the setImageSprite.Visible
    block’s top socket with a select list item block ➋ from the Lists blocks drawer.
    Next, fill the select list item block’s list socket with a get global glassesSprites
    block ➌ and its index socket with ListPicker1’s ListPicker1.SelectionIndex block
    ➍. Now, fill the setImageSprite.Visible block’s bottom socket with a true block
    ➎.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要放置这些积木，请点击**任何ImageSprite**抽屉，并将一个setImageSprite.Visible积木 ➊ 拖到事件处理程序块下的if
    then块内。将setImageSprite.Visible积木的顶部插槽填充为来自列表积木抽屉的select list item积木 ➋。接下来，将select
    list item积木的list插槽填充为get global glassesSprites积木 ➌，并将其index插槽填充为ListPicker1的ListPicker1.SelectionIndex积木
    ➍。现在，将setImageSprite.Visible积木的底部插槽填充为一个true积木 ➎。
- en: That’s it for step 3\. After the user selects a pair of sunglasses, the blocks
    for this step clear any existing `ImageSprite` from the `Canvas` and reset the
    `Slider`, enable the `Slider` if it’s the user’s first time picking from the `ListPicker`,
    and show the selected sunglasses on the `Canvas`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第3步的内容。当用户选择了一副太阳镜后，本步骤的积木会清除`Canvas`上的任何现有`ImageSprite`，并重置`Slider`，如果这是用户第一次从`ListPicker`中选择，将启用`Slider`，并在`Canvas`上显示选中的太阳镜。
- en: Let’s live-test the blocks for this step. When you click the `ListPicker` and
    make a selection, the sunglasses you selected should show on the `Canvas` after
    the `ListPicker` closes. You won’t be able to move the glasses around on the screen
    yet—not until we program step 4\. Leave the app open on the screen to keep live-testing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行本步骤的实时测试。当你点击`ListPicker`并做出选择时，选中的太阳镜应该在`ListPicker`关闭后显示在`Canvas`上。你还不能在屏幕上移动太阳镜——直到我们编程完成第4步。保持应用程序打开以继续实时测试。
- en: '**STEP 4: TRYING ON SUNGLASSES**'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**第4步：试戴太阳镜**'
- en: 'In this step, we’ll program two event handlers: the `ImageSprite Dragged` event
    handler that moves the sunglasses around the `Canvas` when the user drags them
    and the `Slider PositionChanged` event handler that makes the sunglasses bigger
    or smaller when the user adjusts the `Slider`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤中，我们将编写两个事件处理程序：`ImageSprite Dragged`事件处理程序，当用户拖动太阳镜时，移动它们在`Canvas`上的位置；`Slider
    PositionChanged`事件处理程序，当用户调整`Slider`时，使太阳镜变大或变小。
- en: '**Setting the Sunglasses1 X- and Y-Coordinates After Dragging**'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**拖动后设置Sunglasses1的X和Y坐标**'
- en: We’ll have to program a `Dragged` event handler that moves the `ImageSprites`
    when the user drags the sunglasses around the screen. The following blocks move
    `Sunglasses1`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写一个`Dragged`事件处理程序，当用户拖动太阳镜时，能够移动`ImageSprites`。以下积木会移动`Sunglasses1`。
- en: Drag Sunglasses1’s whenSunglasses1.Dragged block ➊ to the Viewer. Then drag
    its callSunglasses1.MoveTo block ➋ into the event handler block. These blocks
    call the `MoveTo` method to move `Sunglasses1` to a given point when a user drags
    `Sunglasses1`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将Sunglasses1的whenSunglasses1.Dragged积木 ➊ 拖到Viewer中。然后，将其callSunglasses1.MoveTo积木
    ➋ 拖入事件处理程序块。这些积木会调用`MoveTo`方法，将`Sunglasses1`移动到指定的位置，当用户拖动`Sunglasses1`时。
- en: '![Image](../images/f0152-01.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0152-01.jpg)'
- en: To use this method, we need to provide the coordinates for that point as the
    arguments for the method’s `x` and `y` parameters. We’ll set those coordinates
    using the `Dragged` event handler’s reported event parameter arguments for the
    coordinates at which the user’s drag of the `ImageSprite` ended (`currentX` and
    `currentY`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个方法，我们需要提供该点的坐标作为方法的`x`和`y`参数的参数。我们将使用`Dragged`事件处理程序报告的事件参数来设置这些坐标，这些坐标表示用户拖动`ImageSprite`结束时的位置（`currentX`和`currentY`）。
- en: To add the blocks for the `x` parameter, snap a - operator block ➌ to the right
    of the letter x. Then, mouse over the currentX event parameter and drag its get
    currentX block ➍ into the subtraction block’s first operand socket.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`x`参数添加积木，请将一个减法运算符积木 ➌ 拖到字母x的右侧。然后，将鼠标悬停在currentX事件参数上，并将其获取currentX积木 ➍
    拖到减法积木的第一个操作数插槽中。
- en: Next, we need to subtract half the `ImageSprite`’s width from its x-coordinate
    to shift it to the left, so that users can drag it from its top-center point,
    which is easier than dragging it from the default position, the top-left edge.
    To do this, drag a × operator block ➎ into the subtraction block’s second operand
    socket. Then, fill the multiplication block’s left operand socket by dragging
    in Sunglasses1’s Sunglasses1.Width block ➏ and its right operand socket with a
    0.5 number block ➐. These blocks tell the app that, when a user drags `Sunglasses1`,
    it should move `Sunglasses1` to the x-coordinate of the point to which the user
    dragged it, minus half the sprite’s width.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从太阳镜的 `ImageSprite` 的 x 坐标中减去它宽度的一半，以便将其向左移动，这样用户可以从顶部中心点拖动它，这比从默认位置（左上角）拖动更容易。为此，拖动一个
    × 运算符积木 ➎ 到减法积木的第二个操作数插槽中。然后，将乘法积木的左操作数插槽填充上太阳镜1的 `Sunglasses1.Width` 积木 ➏，右操作数插槽填充上一个
    0.5 数字积木 ➐。这些积木告诉应用程序，当用户拖动 `Sunglasses1` 时，它应该将 `Sunglasses1` 移动到用户拖动到的点的 x 坐标，减去精灵宽度的一半。
- en: To add the blocks for the `MoveTo` block’s `y` parameter, mouse over the currentY
    event parameter and snap its get currentY block ➑ in next to the letter `y`. These
    blocks tell the app that, when a user drags `Sunglasses1`, it should move `Sunglasses1`
    to the y-coordinate of the point to which the user dragged it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 `MoveTo` 积木的 `y` 参数添加积木，将鼠标悬停在当前的 `currentY` 事件参数上，并将其获取 `currentY` 积木 ➑
    拖放到字母 `y` 旁边。这些积木告诉应用程序，当用户拖动 `Sunglasses1` 时，它应该将 `Sunglasses1` 移动到用户拖动到的点的 y
    坐标。
- en: '**Creating a Dragged Event Handler for All Sunglasses ImageSprites**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**为所有太阳镜的图像精灵创建拖拽事件处理程序**'
- en: We now need to program the exact same `Dragged` event response for `Sunglasses2`,
    `Sunglasses3`, and `Sunglasses4`. The following generic event handler accomplishes
    this task.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要为 `Sunglasses2`、`Sunglasses3` 和 `Sunglasses4` 编写完全相同的 `被拖动` 事件响应。以下的通用事件处理程序完成了这个任务。
- en: '![Image](../images/f0152-02.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0152-02.jpg)'
- en: To create this any `ImageSprite Dragged` event handler, right-click the `Sunglasses1
    Dragged` event handler that we just placed and select **Make Generic**. Now the
    blocks for step 4 move the four sunglasses `ImageSprite`s around the `Canvas`
    when the user drags them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个通用的 `ImageSprite 被拖动` 事件处理程序，右键点击我们刚刚放置的 `Sunglasses1 被拖动` 事件处理程序，并选择 **Make
    Generic**。现在，步骤 4 的积木会在用户拖动时，将四副太阳镜的 `ImageSprite` 在 `画布` 上移动。
- en: Let’s live-test to see these blocks work. Once you select a pair of sunglasses,
    they should move around the `Canvas` where you drag them. If they’re not moving
    correctly, debug and test again. Before you test again, you may need to refresh
    the app in your Companion to make sure your changes take effect. You can refresh
    by making any change to the app in the Designer. Once this part of step 4 is working,
    move to the next part of the step, where we’ll program the `Slider` to allow a
    user to change the sunglasses’ sizes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行实时测试，查看这些积木是否有效。一旦你选择了一副太阳镜，它们应该会随着你拖动的`画布`而移动。如果它们没有正确移动，调试并再次测试。在再次测试之前，你可能需要在你的
    Companion 中刷新应用程序，以确保你的更改生效。你可以通过在设计器中对应用程序做任何更改来刷新它。一旦步骤 4 的这一部分有效后，继续进行下一部分，在这一部分中，我们将编程
    `Slider` 以允许用户更改太阳镜的大小。
- en: '**Adjusting the Width of the Selected Sunglasses**'
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**调整选定太阳镜的宽度**'
- en: Since the 200-pixel-wide sunglasses might not fit correctly on a user’s photo,
    we’ll program the app to let the user adjust the size of the sunglasses by moving
    the `Slider`. The `Slider1 PositionChanged` event handler accomplishes this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于宽度为 200 像素的太阳镜可能无法正确适应用户的照片，我们将编程让应用程序允许用户通过移动 `Slider` 来调整太阳镜的大小。`Slider1
    PositionChanged` 事件处理程序完成了这一任务。
- en: '![Image](../images/f0153-01.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0153-01.jpg)'
- en: These blocks handle the action that takes place when the thumb position of the
    `Slider` changes from the initial value of `200` that we set in the Designer.
    Once the `Slider` position changes, the `whenSlider1.PositionChanged` block provides
    the argument for a `thumbPosition` event parameter, which holds the numerical
    value of the thumb position after the change.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些积木处理的是当 `Slider` 的拇指位置从我们在设计器中设置的初始值 `200` 改变时发生的动作。一旦 `Slider` 的位置发生变化，`whenSlider1.PositionChanged`
    积木提供了一个 `thumbPosition` 事件参数，这个参数包含了变化后拇指位置的数值。
- en: We’ll first place the blocks that set the selected `ImageSprite`’s new width
    to the value of `thumbPosition`, which will be somewhere between a minimum of
    150 and maximum of 250, the `MinValue` and `MaxValue` properties we set for the
    `Slider` in the Designer. Drag Slider1’s whenSlider1.PositionChanged block ➊ to
    the Viewer. Next, drag a setImageSprite.Width block ➋ from the Any ImageSprite
    drawer into the event handler block. Fill the setImageSprite.Width block’s top
    socket with a select list item block ➌, and fill that select list item block’s
    top socket with a get global glassesSprites block ➍ and its bottom socket with
    the ListPicker1.SelectionIndex block ➎. Now, fill the setImageSprite.Width block’s
    bottom socket by mousing over the thumbPosition event parameter and dragging in
    a get thumbPosition block ➏.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先放置一些代码块，将所选的`ImageSprite`的新宽度设置为`thumbPosition`的值，这个值将在150到250之间，分别是我们在设计器中为`Slider`设置的`MinValue`和`MaxValue`属性。将Slider1的`whenSlider1.PositionChanged`代码块➊拖动到查看器中。接着，将`setImageSprite.Width`代码块➋从任何`ImageSprite`抽屉中拖动到事件处理代码块中。将`setImageSprite.Width`代码块的顶部插槽填充为`select
    list item`代码块➌，并将该代码块的顶部插槽填充为`get global glassesSprites`代码块➍，底部插槽填充为`ListPicker1.SelectionIndex`代码块➎。现在，通过将鼠标移到`thumbPosition`事件参数上，拖动`get
    thumbPosition`代码块➏并将其放入`setImageSprite.Width`代码块的底部插槽中。
- en: '**Adjusting the Height of the Selected Sunglasses**'
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**调整所选太阳镜的高度**'
- en: The next blocks set the height of the selected sunglasses when the `Slider`
    position changes. This is the second half of the `Slider1 PositionChanged` event
    handler.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码块在`Slider`位置变化时设置所选太阳镜的高度。这是`Slider1 PositionChanged`事件处理程序的后半部分。
- en: '![Image](../images/f0154-01.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0154-01.jpg)'
- en: These blocks set the pixel height of the selected sunglasses to the value of
    the `thumbPosition` multiplied by 0.4\. Since the height of each pair of sunglasses
    is 80 pixels, which is 0.4 times the default 200-pixel width, we use this formula
    to maintain the same proportion between the sunglasses’ height and width when
    the width changes. This will keep the glasses from looking distorted when a user
    moves the `Slider`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码块将所选太阳镜的像素高度设置为`thumbPosition`乘以0.4的值。由于每副太阳镜的高度为80像素，等于默认200像素宽度的0.4倍，我们使用此公式来保持太阳镜的高度和宽度之间的比例不变，以防宽度发生变化时，太阳镜看起来不失真。这将防止用户在移动`Slider`时，太阳镜的比例出现失真。
- en: To place these blocks, duplicate the `setImageSprite.Width` block. In the copy,
    change Width to Height, and snap the setImageSprite.Height block ➊ into the event
    handler block. Then replace the block in the to socket with a × operator block
    ➋. Fill that multiplication block’s left operand socket by dragging in a get thumbPosition
    block ➌ and its right socket with a 0.4 number block ➍.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要放置这些代码块，请复制`setImageSprite.Width`代码块。在复制的代码块中，将Width改为Height，并将setImageSprite.Height代码块➊连接到事件处理代码块中。然后，用×运算符代码块➋替换“to”插槽中的代码块。通过拖动`get
    thumbPosition`代码块➌并将其放入乘法代码块的左操作数插槽中，再将右操作数插槽填充为0.4的数字代码块➍。
- en: You’ve now completed step 4\. Let’s live-test again to see how these blocks
    work. You should be able to drag your selected pair of sunglasses around the `Canvas`
    and move the `Slider` to the left to make the glasses smaller and to the right
    to make them larger. If the sunglasses aren’t changing size correctly or proportionally,
    debug and test again. Once step 4 is working, move on to step 5, where we’ll program
    the app to let users draw on the picture.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经完成了第4步。让我们再次进行实时测试，看看这些代码块如何工作。你应该能够在`Canvas`上拖动选中的太阳镜，并将`Slider`向左拖动使太阳镜变小，向右拖动使太阳镜变大。如果太阳镜的大小没有正确或成比例地变化，调试并重新测试。完成第4步后，继续进入第5步，我们将在此步骤中编写代码，允许用户在图片上绘制。
- en: '**STEP 5: LETTING USERS DRAW ON THE CANVAS**'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**步骤5：让用户在画布上绘制**'
- en: Let’s now program step 5 of the app. When a user clicks the draw button, the
    app should display a notification that the user can draw anywhere on the `Canvas`.
    Also, when the user drags a finger on the `Canvas`, the app should draw on the
    `Canvas` along the finger’s path, unless the user is dragging one of the sunglasses
    `ImageSprite`s at the same time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始编写应用的第5步。当用户点击绘制按钮时，应用应该显示通知，告诉用户可以在`Canvas`上任意绘制。此外，当用户在`Canvas`上拖动手指时，应用应沿着手指的路径进行绘制，除非用户同时在拖动其中一副太阳镜的`ImageSprite`。
- en: '**Letting Users Know They Can Draw**'
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**让用户知道他们可以绘制**'
- en: Here is the code that tells the user where to draw on the app screen.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是告诉用户在哪里绘制的代码。
- en: '![Image](../images/f0154-02.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0154-02.jpg)'
- en: Drag the whenDrawBtn.Click block ➊ to the Viewer and then drag Notifier1’s callNotifier1.ShowAlert
    method call block ➋ inside it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将`whenDrawBtn.Click`块 ➊ 拖动到查看器中，然后将`Notifier1`的`callNotifier1.ShowAlert`方法调用块
    ➋ 拖动到其中。
- en: The `ShowAlert` method that we’re calling requires an argument for its `notice`
    parameter, which holds the information we want the `Notifier` to display. To provide
    that argument, snap in an empty string block ➌ and enter Drag on the screen anywhere
    above the buttons to draw. into its text area. Now, when the user clicks the draw
    button, these blocks will display an alert saying the user can drag on the `Canvas`
    to draw.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用的`ShowAlert`方法需要为其`notice`参数提供一个参数，该参数保存我们希望`Notifier`显示的信息。为了提供该参数，将一个空字符串块
    ➌ 快速插入，并在其文本区域中输入“在屏幕上任何按钮上方拖动以绘制。”现在，当用户点击绘制按钮时，这些块会显示一个警报，告知用户可以在`Canvas`上拖动以绘制。
- en: '**Drawing Lines on the Canvas**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在画布上绘制线条**'
- en: Next, we’ll tell the app where to draw when a user drags the `Canvas` and in
    what color. The following blocks handle this `Canvas1 Dragged` event.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将告诉应用程序在用户拖动`Canvas`时在哪里绘制以及使用什么颜色。以下的块处理这个`Canvas1 Dragged`事件。
- en: '![Image](../images/f0155-01.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0155-01.jpg)'
- en: 'Drag the whenCanvas1.Dragged block ➊ to the Viewer. When the user drags the
    `Canvas`, this event handler will store the following seven event parameters as
    arguments: the x- and y-coordinates for the point at which the user first touched
    the `Canvas` (`startX` and `startY`), the point at which the current drag began
    (`prevX` and `prevY`), the point at which the current drag ended (`currentX` and
    `currentY`), and a Boolean value for whether the drag also dragged an `ImageSprite`
    (`draggedAnySprite`). We’ll use a number of these values in the blocks we add
    to the `Dragged` event handler.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将`whenCanvas1.Dragged`块 ➊ 拖动到查看器。当用户拖动`Canvas`时，这个事件处理程序将把以下七个事件参数作为参数存储：用户第一次触摸`Canvas`的点的x和y坐标（`startX`和`startY`）、当前拖动开始的点（`prevX`和`prevY`）、当前拖动结束的点（`currentX`和`currentY`），以及一个布尔值，表示拖动过程中是否还拖动了`ImageSprite`（`draggedAnySprite`）。我们将在添加到`Dragged`事件处理程序的块中使用这些值中的一些。
- en: To add the blocks to make the app draw a line where the user dragged, drag the
    callCanvas1.DrawLine method call block ➋ into the event handler block. This method
    requires us to provide arguments for its `x1` and `y1` parameters, which hold
    the x- and y-coordinates for the point at which the app should start drawing,
    and `x2` and `y2` parameters, which hold the x- and y-coordinates for the point
    at which the app should stop drawing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加使应用绘制用户拖动的线条的块，将`callCanvas1.DrawLine`方法调用块 ➋ 拖动到事件处理程序块中。此方法要求我们为其`x1`和`y1`参数提供参数，这些参数保存应用程序开始绘制时的x和y坐标；同时为`x2`和`y2`参数提供参数，这些参数保存应用程序停止绘制时的x和y坐标。
- en: We’ll get these arguments from the `whenCanvas1.Dragged` block. Mouse over the
    block’s parameters and drag a get prevX block ➌ into the callCanvas1.DrawLine
    block’s top socket, a get prevY block ➍ into its second socket, a get currentX
    block ➎ into its third socket, and a get currentY block ➏ into its last socket.
    Now, when the user drags on the `Canvas`, these blocks direct the app to draw
    a line from the point at which the user begins to drag the `Canvas` to the point
    at which the user stops.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`whenCanvas1.Dragged`块获取这些参数。将鼠标悬停在块的参数上，然后将`get prevX`块 ➌ 拖动到`callCanvas1.DrawLine`块的第一个插槽，将`get
    prevY`块 ➍ 拖动到第二个插槽，将`get currentX`块 ➎ 拖动到第三个插槽，将`get currentY`块 ➏ 拖动到最后一个插槽。现在，当用户拖动`Canvas`时，这些块会指示应用程序从用户开始拖动`Canvas`的点绘制一条线到用户停止的点。
- en: '**Determining the Canvas Line Color**'
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**确定画布线条颜色**'
- en: Right now, despite the blocks we just placed, the user’s lines won’t show up.
    That’s because we set the `PaintColor` for `Canvas1` to None in the Designer.
    To update this, we’ll have the app draw a transparent line if the user also drags
    an `ImageSprite` along with the `Canvas` and a red line if the user drags only
    the `Canvas`. The following `if then else` block directs this behavior.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，尽管我们放置了这些块，用户的线条仍然不会显示出来。这是因为我们在设计器中将`Canvas1`的`PaintColor`设置为None。为了更新这一点，我们将让应用在用户同时拖动`ImageSprite`和`Canvas`时绘制一条透明线，在用户只拖动`Canvas`时绘制一条红色线。以下的`if
    then else`块指示了这种行为。
- en: '![Image](../images/f0156-01.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0156-01.jpg)'
- en: Drag an if then block to the Viewer, click the blue mutator icon to add an else
    input to the block, and then snap the if then else block ➊ inside the event handler
    block. Now, mouse over the event handler’s draggedAnySprite parameter, and drag
    a get draggedAnySprite block ➋ into the if then else block’s if socket, which
    checks whether the user has dragged one of the `ImageSprite`s. Then, drag a setCanvas1.PaintColor
    block ➌ into the if then else block’s then socket and snap a 1 number block ➍
    to its right to make the color transparent. The blocks in this `then` socket dictate
    what happens if the user has also dragged an `ImageSprite`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个if-then块拖到Viewer中，点击蓝色的修改图标为该块添加一个else输入，然后将if-then-else块➊放入事件处理块中。现在，将鼠标悬停在事件处理器的draggedAnySprite参数上，并将一个get
    draggedAnySprite块➋拖入if-then-else块的if插槽，这样可以检查用户是否拖动了一个`ImageSprite`。然后，将一个setCanvas1.PaintColor块➌拖入if-then-else块的then插槽，并将一个数字块1
    ➍拖到它的右侧，使颜色变得透明。`then`插槽中的这些块决定了如果用户也拖动了一个`ImageSprite`时会发生什么。
- en: Next duplicate the setCanvas1.PaintColor block ➎ and drag the copy into the
    if then else block’s else socket, which determines what happens if the user hasn’t
    dragged an `ImageSprite`. Replace the 1 number block with a red color block ➏
    from the Colors drawer.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，复制setCanvas1.PaintColor块➎并将复制块拖入if-then-else块的else插槽，该插槽决定了如果用户没有拖动`ImageSprite`时会发生什么。用来自Colors抽屉的红色颜色块➏替换数字块1。
- en: Now, each time a user drags the `Canvas`, the app tests whether the user is
    also dragging a sunglasses `ImageSprite`. If so, the app draws an invisible line
    because of the `1` value we set. If the user’s not dragging an `ImageSprite`,
    the app draws a red line.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次用户拖动`Canvas`时，应用程序会测试用户是否也在拖动太阳镜`ImageSprite`。如果是这样，应用程序会绘制一条不可见的线，因为我们设置的值是`1`。如果用户没有拖动`ImageSprite`，应用程序会绘制一条红线。
- en: Let’s live-test to see how these blocks work. When you click `DrawBtn`, you
    should see an alert letting you know you can draw on the screen by dragging your
    finger above the buttons. When you drag on the `Canvas`, you should see your drawing
    in red on the device screen, unless you’re also dragging a pair of sunglasses.
    If you’re dragging a pair of sunglasses, you shouldn’t see any lines drawn. If
    any part of this step isn’t working correctly, debug and test again. Once step
    5 is working, continue on to the next step, where we’ll program the app to let
    users type on the picture.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行实时测试，看看这些模块是如何工作的。当你点击`DrawBtn`时，应该会看到一个警告，提示你可以通过在按钮上方拖动手指来在屏幕上绘画。当你在`Canvas`上拖动时，应该能在设备屏幕上看到你用红色绘制的图形，除非你同时也在拖动一副太阳镜。如果你在拖动太阳镜，你不应该看到任何绘制的线条。如果此步骤的任何部分无法正常工作，请进行调试并再次测试。一旦第5步工作正常，继续进行下一步，我们将编程让用户在图片上输入文字。
- en: '**STEP 6: LETTING USERS TYPE ON THE CANVAS**'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**第6步：让用户在画布上输入文本**'
- en: When a user clicks `TypeBtn`, the app’s `Notifier` should open a text dialog
    in which the user can enter the desired text to display on the `Canvas`. After
    the user clicks OK to close the dialog, the app should display any text entered
    into the dialog in blue near the bottom of the `Canvas`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击`TypeBtn`时，应用程序的`Notifier`应该打开一个文本对话框，用户可以在其中输入希望显示在`Canvas`上的文本。当用户点击确定关闭对话框后，应用程序应该在`Canvas`底部附近以蓝色显示用户输入的文本。
- en: '**Opening the Text Dialog for Input**'
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**打开文本对话框进行输入**'
- en: The `TypeBtn.Click` event handler opens the text dialog to collect the entered
    text when the user clicks `TypeBtn`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypeBtn.Click`事件处理器会在用户点击`TypeBtn`时打开文本对话框以收集输入的文本。'
- en: '![Image](../images/f0157-01.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0157-01.jpg)'
- en: Drag the whenTypeBtn.Click block ➊ to the Viewer, then drag the callNotifier1.ShowTextDialog
    method call block ➋ into it. This `ShowTextDialog` method call requires an argument
    for its `message` parameter, which holds the message we’ll show the user in the
    text dialog that opens; its `title` parameter, which holds a title that will show
    at the top of the text dialog; and its `cancelable` parameter. If the `cancelable`
    parameter were set to `true`, the app would add an OK and a Cancel button to the
    text dialog. Then, when we program the app to display the user’s response later
    in this step, the app would display the word “Cancel” on the `Canvas` if the user
    clicked Cancel. We’ll set the `cancelable` parameter to `false` instead, which
    adds only an OK button to the dialog. After we program the second part of this
    step, pressing the OK button should place the user’s text on the `Canvas`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将whenTypeBtn.Click块 ➊ 拖动到Viewer中，然后将callNotifier1.ShowTextDialog方法调用块 ➋ 拖入其中。这个`ShowTextDialog`方法调用需要为其`message`参数提供一个值，这个参数包含我们将在打开的文本对话框中显示给用户的消息；其`title`参数包含将在文本对话框顶部显示的标题；以及其`cancelable`参数。如果将`cancelable`参数设置为`true`，则应用程序会在文本对话框中添加“确定”和“取消”按钮。然后，当我们在此步骤中稍后编程以显示用户的响应时，如果用户点击了取消按钮，应用程序将在`Canvas`上显示“取消”字样。我们将`cancelable`参数设置为`false`，这样对话框中只会添加一个“确定”按钮。在我们编写此步骤的第二部分时，按下“确定”按钮应将用户的文本显示在`Canvas`上。
- en: For the `message` parameter, snap an empty string block ➌ into the message socket
    and enter Type your brief message below. Click OK to close this box. For the `title`
    parameter, snap an empty string block ➍ into the title socket and enter Type on
    the Screen; then, set the `cancelable` parameter by changing the default true
    block to false ➎.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`message`参数，将一个空字符串块 ➌ 拖入消息插槽，并输入“在下方输入简短的消息。点击确定以关闭此框。”对于`title`参数，将一个空字符串块
    ➍ 拖入标题插槽，并输入“在屏幕上输入”；然后，通过将默认的`true`块更改为`false` ➎ 来设置`cancelable`参数。
- en: '**Displaying the User’s Input on the Canvas**'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在画布上显示用户输入**'
- en: Now we’ll program the `Notifier AfterTextInput` event handler, which tells the
    app how and where to display the user’s message (reported as the response event
    parameter) on the `Canvas`. Once the user clicks OK in the dialog, the app should
    set the paint color to blue and print the response at specific coordinates on
    the `Canvas`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写`Notifier AfterTextInput`事件处理器，它告诉应用程序如何以及在哪里在`Canvas`上显示用户的消息（以响应事件参数的形式报告）。一旦用户在对话框中点击“确定”，应用程序应将绘制颜色设置为蓝色，并将响应内容在`Canvas`上的特定坐标处显示。
- en: '![Image](../images/f0157-02.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0157-02.jpg)'
- en: Drag the whenNotifier1.AfterTextInput block ➊ to the Viewer. Then, to set the
    paint color, drag the setCanvas1.PaintColor block ➋ into the event handler block
    and snap a blue color block ➌ into its right socket. After the user closes the
    text dialog, these blocks will change the `Canvas` paint color to blue.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将whenNotifier1.AfterTextInput块 ➊ 拖动到Viewer中。然后，为了设置绘制颜色，将setCanvas1.PaintColor块
    ➋ 拖动到事件处理器块中，并将蓝色颜色块 ➌ 拖入其右侧插槽中。在用户关闭文本对话框后，这些块将把`Canvas`的绘制颜色更改为蓝色。
- en: Next, to call the method that draws the text on the `Canvas`, drag the callCanvas1.DrawText
    method call block into the whenNotifier1.AfterTextInput event handler block ➍.
    This `DrawText` method takes arguments for its `text` parameter, which is the
    user input it should display on the screen, and for its `x` and `y` parameters,
    which are the x- and y-coordinates for the point at which the input should begin
    to show on the `Canvas`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了调用在`Canvas`上绘制文本的方法，将callCanvas1.DrawText方法调用块拖入whenNotifier1.AfterTextInput事件处理器块
    ➍ 中。这个`DrawText`方法需要为其`text`参数提供参数，即它应该在屏幕上显示的用户输入内容，并为其`x`和`y`参数提供坐标值，即文本应开始显示的`Canvas`上的x和y坐标。
- en: To provide the argument for the method’s `text` parameter, mouse over the AfterTextInput
    handler’s response event parameter and drag its get response block ➎ into the
    text socket. For the text location, we’ll set it at 10 pixels in from the `Canvas`’s
    left edge and 20 pixels up from the bottom so that it will display close to the
    bottom of the picture.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要为方法的`text`参数提供参数，鼠标悬停在AfterTextInput处理器的响应事件参数上，并将其获取响应块 ➎ 拖动到文本插槽中。对于文本位置，我们将其设置为从`Canvas`的左边缘向右偏移10像素，从底部向上偏移20像素，这样它将显示在图片的底部附近。
- en: To do this, for the `callCanvas1.DrawText` block’s `x` parameter, drag in a
    10 number block ➏, and for its `y` parameter, drag in a - operator block ➐. Fill
    the subtraction block’s left operand socket by dragging in the Canvas1.Height
    block ➑ and fill its right operand socket by dragging in a 20 number block ➒.
    This sets the `x` parameter to `10` and the `y` parameter to the height of the
    `Canvas` minus 20 pixels—or, in other words, 20 pixels from the bottom of the
    `Canvas`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，对于 `callCanvas1.DrawText` 块的 `x` 参数，将一个数字块 ➏ 拖入，设置为 10，对于其 `y` 参数，将一个减号运算块
    ➐ 拖入。将减法块的左操作数插槽填入 Canvas1.Height 块 ➑，将右操作数插槽填入数字块 ➒，其值为 20。这将 `x` 参数设置为 `10`，并将
    `y` 参数设置为 `Canvas` 的高度减去 20 像素——换句话说，就是距离 `Canvas` 底部 20 像素的位置。
- en: Now test these blocks. When you click `TypeBtn`, a dialog should open in which
    you can enter the text you want typed on the `Canvas`. Enter some text and click
    **OK**. You should see the text typed in blue at the left side of the `Canvas`,
    near the bottom. If any part of this step isn’t working correctly, debug and test
    again. Once step 6 is working, let’s program the app to allow users to save the
    `Canvas`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试这些块。当你点击 `TypeBtn` 时，应该会弹出一个对话框，你可以在其中输入希望在 `Canvas` 上输入的文本。输入一些文本并点击 **OK**。你应该能看到文本以蓝色显示在
    `Canvas` 的左侧，接近底部。如果这一步有任何问题，进行调试并重新测试。一旦第 6 步正常工作，我们就可以编写程序允许用户保存 `Canvas`。
- en: '**STEP 7: LETTING USERS SAVE A PICTURE OF THE CANVAS**'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**第 7 步：允许用户保存 Canvas 的图片**'
- en: In this step, we’ll let a user save a picture of the `Canvas`, along with any
    selected sunglasses, drawing, and typing, to a device as an image file. The `SaveBtn.click`
    event handler saves the user’s creation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们将允许用户将 `Canvas` 及任何选中的太阳镜、绘画和文字保存为图像文件到设备中。`SaveBtn.click` 事件处理程序将保存用户的创作。
- en: '![Image](../images/f0158-01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0158-01.jpg)'
- en: First, we’ll tell the app to show an alert when the user clicks the save button.
    Drag the whenSaveBtn.click block ➊ to the Viewer and then place the callNotifier1.ShowAlert
    method call block ➋ inside of it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们会让应用在用户点击保存按钮时显示一个提示框。将 whenSaveBtn.click 块 ➊ 拖到查看器中，然后将 callNotifier1.ShowAlert
    方法调用块 ➋ 放入其中。
- en: The next blocks provide the argument for the `ShowAlert` method’s `notice` parameter,
    which is the notice we want the `Notifier` to show. We want that notice to tell
    the user where on the device the picture is saved and call the method that saves
    the picture while displaying the storage location.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的块提供了 `ShowAlert` 方法的 `notice` 参数的参数，我们希望通过这个提示告诉用户图像保存的位置，并调用保存图片的方法，同时显示存储位置。
- en: To place these blocks, drag a join block ➌ into the callNotifier1.ShowAlert
    block’s notice socket. Then fill the join block’s top socket with an empty string
    block ➍ and enter The Canvas is saved at, including the final space, into its
    text area. Next, fill the join block’s bottom socket by dragging in a callCanvas1.Save
    method call block ➎.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要放置这些块，将一个 join 块 ➌ 拖到 callNotifier1.ShowAlert 块的提示插槽中。接着，将一个空字符串块 ➍ 拖入 join
    块的上插槽，并在其文本区域输入 "The Canvas is saved at"（包括最后一个空格）。然后，将一个 callCanvas1.Save 方法调用块
    ➎ 拖入 join 块的下插槽。
- en: Let’s test these blocks. When you click `SaveBtn`, you should see an alert reading,
    “The Canvas is saved at <*file location*>.” You should be able to find the file
    when you go to that location or look in the device’s File Manager, but you may
    need to close the app before the file appears. Once this step works as it should,
    close the app on your device and move on to program the app’s last step, which
    allows the user to clear the `Canvas`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试这些块。当你点击 `SaveBtn` 时，应该会看到一个提示框，显示 “The Canvas is saved at <*file location*>”。你应该能在该位置找到文件，或者在设备的文件管理器中查看，但你可能需要关闭应用程序，文件才会显示。一旦这一步正常工作，关闭设备上的应用程序，并进入编写应用程序的最后一步，允许用户清除
    `Canvas`。
- en: '**STEP 8: LETTING USERS CLEAR THE CANVAS**'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**第 8 步：允许用户清除 Canvas**'
- en: In this final step, we’ll program the app to let the user clear the sunglasses,
    as well as all drawings and typed text, from the `Canvas`, so that only the background
    image remains. The `TrashBtn.click` event handler clears the `Canvas`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们将编写程序，让用户清除 `Canvas` 上的太阳镜以及所有的绘画和输入的文本，只保留背景图片。`TrashBtn.click` 事件处理程序将清除
    `Canvas`。
- en: '![Image](../images/f0159-01.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0159-01.jpg)'
- en: These blocks call the `clearSprite` procedure, which hides all `ImageSprite`s,
    like it did when we used it in the `AfterPicker` event handler. Then they call
    the built-in `Canvas Clear` method, which clears all text and drawings from the
    `Canvas`, when the user clicks the trash button.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块调用了 `clearSprite` 程序，该程序隐藏所有的 `ImageSprite`，就像我们在 `AfterPicker` 事件处理程序中使用它时一样。然后，它们调用内置的
    `Canvas Clear` 方法，该方法在用户点击垃圾桶按钮时清除 `Canvas` 上的所有文本和图形。
- en: Drag the whenTrashBtn.click block ➊ to the Viewer and then drag the call clearSprite
    block ➋ into it. Next drag a callCanvas1.Clear block ➌ into the event handler
    block under the call clearSprite block.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `whenTrashBtn.click` 块 ➊ 拖动到查看器中，然后将调用 `clearSprite` 块 ➋ 拖到其中。接着，将 `callCanvas1.Clear`
    块 ➌ 拖到事件处理程序块中，放在调用 `clearSprite` 块下面。
- en: Now let’s test the completed app! Open the app on your device. You should see
    the `TakePicBtn`. Click it, and your camera should open. When you take a picture,
    that picture should become the background of the top portion of your app screen.
    Below the picture, you should see the `ListPicker`, with the `Slider` and the
    draw, type, save, and trash buttons beneath it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试完成的应用程序！在你的设备上打开该应用程序。你应该能看到 `TakePicBtn` 按钮。点击它后，摄像头应该打开。当你拍摄一张照片时，这张照片应该成为应用屏幕顶部部分的背景。在照片下方，你应该能看到
    `ListPicker`，其下方是 `Slider`，以及绘制、输入、保存和垃圾桶按钮。
- en: When you click Choose Glasses, you should see all four sunglasses options listed,
    and, when you select a pair, the `ListPicker` should close and your selected sunglasses
    should appear at the top of the `Canvas`. You should be able to drag the glasses
    around the `Canvas` and use the `Slider` to change their size.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击“选择眼镜”时，你应该看到列出所有四种太阳镜选项，并且当你选择一副眼镜时，`ListPicker` 应该关闭，你选择的太阳镜应该出现在 `Canvas`
    的顶部。你应该能够将眼镜拖动到 `Canvas` 上，并使用 `Slider` 来调整它们的大小。
- en: Test each button. When you click `DrawBtn`, the app should display the notice
    telling you that you can draw on the `Canvas`, and when you drag your finger along
    the `Canvas` at any place except on the `ImageSprite`, a red line should appear.
    When you click `TypeBtn`, a dialog should open prompting you to type a message,
    and after you type it and click OK, your message should appear in blue at the
    bottom of the `Canvas`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 测试每个按钮。当你点击 `DrawBtn` 时，应用程序应该显示一个通知，告诉你可以在 `Canvas` 上绘画，当你在 `Canvas` 上拖动手指（不在
    `ImageSprite` 上时），应该会出现一条红色的线。当你点击 `TypeBtn` 时，应该会弹出一个对话框，提示你输入消息，输入并点击确定后，你的消息应该以蓝色显示在
    `Canvas` 底部。
- en: When you click `SaveBtn`, you should see a notice alerting you that a picture
    of the `Canvas` has been saved at a given location on your device. When you click
    `TrashBtn`, the `ImageSprite` and all text and drawing should disappear from the
    `Canvas`. If you placed your blocks correctly, you’ve successfully created the
    “Virtual Shades” app!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击 `SaveBtn` 时，你应该看到一个通知，提醒你 `Canvas` 的图片已保存在设备的指定位置。当你点击 `TrashBtn` 时，`ImageSprite`
    以及所有文本和图形应该从 `Canvas` 上消失。如果你正确放置了块，那么你已经成功创建了“虚拟眼镜”应用程序！
- en: '**SUMMARY**'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you built the “Virtual Shades” app, which lets users try on
    sunglasses, draw and type on the `Canvas`, and save a picture of the `Canvas`
    to their devices to keep and share.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你构建了“虚拟眼镜”应用程序，允许用户试戴太阳镜，在 `Canvas` 上绘画和输入文字，并将 `Canvas` 上的图片保存到他们的设备上，供保存和分享。
- en: Along the way, you learned how to set the `Canvas` line size and colors to prepare
    for drawing, let users take a selfie through the app and make it the app background,
    let users adjust components with the `Slider`, and use the `Notifier` component
    to not only display information but also collect user input.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，你学会了如何设置 `Canvas` 的线条大小和颜色，为绘图做准备，让用户通过应用拍摄自拍并将其作为应用背景，让用户通过 `Slider`
    调整组件，并使用 `Notifier` 组件不仅显示信息，还收集用户输入。
- en: You also practiced declaring and initializing list variables, creating procedures,
    providing required arguments for built-in methods with parameters, using comparison
    operators to test conditions, and adding conditionals and loops to control app
    flow.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你还练习了声明和初始化列表变量，创建程序，提供内置方法所需的带参数的参数，使用比较运算符测试条件，并添加条件和循环来控制应用程序流程。
- en: '**ON YOUR OWN**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**自主练习**'
- en: Modify and extend the “Virtual Shades” app by working on the following exercises.
    Be sure to adjust your algorithm to plan the changes before you add any components
    or blocks, and save the new versions of the apps you create. You can find solutions
    online at *[https://nostarch.com/programwithappinventor/](https://nostarch.com/programwithappinventor/)*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成以下练习来修改和扩展“Virtual Shades”应用程序。务必在添加任何组件或模块之前调整你的算法来规划这些变化，并保存你创建的新版本应用。你可以在*［https://nostarch.com/programwithappinventor/](https://nostarch.com/programwithappinventor/)*
    在线找到解决方案。
- en: Change the app so that it allows users to choose the `Canvas` paint color to
    draw and type on the `Canvas`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改应用程序，使其允许用户选择`Canvas`绘画颜色以便在`Canvas`上绘制和输入文字。
- en: Change the app so that it allows users to speak the words they want entered
    on the `Canvas`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改应用程序，使其允许用户通过语音输入他们希望显示在`Canvas`上的文字。
- en: Extend the app so that users can opt not to take a background photo and instead
    create art on a blank `Canvas`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展应用程序，使用户可以选择不拍摄背景照片，而是在空白的`Canvas`上创作艺术作品。
