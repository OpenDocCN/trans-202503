- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**ADVANCED WIRESHARK FEATURES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Wireshark高级功能**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Once you master the basics of Wireshark, the next step is to delve into its
    analysis and graphing capabilities. In this chapter, we’ll look at some of these
    powerful features, including the Endpoints and Conversations windows, the finer
    points of name resolution, protocol dissection, stream interpretation, IO graphing,
    and more. These features, which are unique to Wireshark as a graphical analysis
    tool, are useful at multiple stages in the analysis process. Make sure to at least
    attempt to use all the features listed here before moving on, because we’ll revisit
    them frequently as we look at practical analysis scenarios throughout the rest
    of the book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦掌握了Wireshark的基础知识，下一步就是深入了解它的分析和图形化功能。在本章中，我们将探讨一些强大的功能，包括端点和会话窗口、名称解析的细节、协议解析、流量解读、IO图形分析等。这些功能是Wireshark作为图形化分析工具的独特之处，在分析过程中多个阶段都很有用。在继续之前，确保至少尝试使用本章列出的所有功能，因为我们将在书中的后续章节中频繁地回顾这些功能，并探讨实际的分析场景。
- en: '**Endpoints and Network Conversations**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**端点和网络会话**'
- en: For network communication to take place, data must be flowing between at least
    two devices. Each device sending or receiving data on the network represents what
    Wireshark calls an *endpoint*. The communication between two endpoints is called
    a *conversation*. Wireshark describes endpoints and conversations based on the
    attributes of the communication, specifically in terms of the addresses used within
    various protocols.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行网络通信，数据必须在至少两个设备之间流动。每个在网络上发送或接收数据的设备都代表了Wireshark所称的*端点*。两个端点之间的通信被称为*会话*。Wireshark根据通信的属性，特别是各种协议中使用的地址，描述端点和会话。
- en: Endpoints are identified by multiple addresses, which are assigned at different
    layers of the OSI model. For example, at the data link layer, an endpoint will
    have a MAC address, which is a unique address built into the device (although
    it can be modified, potentially making it no longer required). At the network
    layer, however, the endpoint will have an IP address, which can be changed at
    any point. We’ll discuss in the next few chapters how these types of addresses
    are used.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 端点通过多个地址进行识别，这些地址分配在OSI模型的不同层次上。例如，在数据链路层，端点将具有MAC地址，这是设备内置的唯一地址（尽管它可以修改，可能使其不再是唯一的）。然而，在网络层，端点将具有IP地址，该地址可以随时更改。我们将在接下来的几章中讨论这些地址类型是如何使用的。
- en: '[Figure 5-1](ch05.xhtml#ch05fig1) shows two examples of how addresses are used
    to identify endpoints in conversations. Conversation A in the figure consists
    of two endpoints communicating at the data link (MAC) layer. Endpoint A has a
    MAC address of 00:ff:ac:ce:0b:de, and Endpoint B has a MAC address of 00:ff:ac:e0:dc:0f.
    Conversation B is defined by two devices communicating at the network (IP) layer.
    Endpoint A has an IP address of 192.168.1.25, and Endpoint B has an address of
    192.168.1.30.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-1](ch05.xhtml#ch05fig1)展示了两种如何使用地址来识别会话中的端点的示例。图中的会话A由在数据链路（MAC）层通信的两个端点组成。端点A的MAC地址为00:ff:ac:ce:0b:de，端点B的MAC地址为00:ff:ac:e0:dc:0f。会话B由两个在网络（IP）层通信的设备定义。端点A的IP地址为192.168.1.25，端点B的IP地址为192.168.1.30。'
- en: '![image](../images/f78-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f78-01.jpg)'
- en: '*Figure 5-1: Endpoints and conversations on a network*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：网络中的端点和会话*'
- en: Let’s look at how Wireshark can provide information about network communication
    on a per endpoint or conversation basis.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Wireshark如何提供按端点或会话划分的网络通信信息。
- en: '***Viewing Endpoint Statistics***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看端点统计信息***'
- en: '*lotsofweb.pcapng*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*lotsofweb.pcapng*'
- en: When analyzing traffic, you may find that you can pinpoint a problem as being
    at a specific endpoint on a network. For example, open the capture file *lotsofweb.pcapng*
    and open Wireshark’s Endpoints window (**Statistics** ▶ **Endpoints**). This window
    shows several helpful statistics for each endpoint, as shown in [Figure 5-2](ch05.xhtml#ch05fig2),
    including the address, number of packets, and bytes transmitted and received.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析流量时，你可能会发现能够准确定位问题发生在网络的特定端点。例如，打开捕获文件*lotsofweb.pcapng*，然后打开Wireshark的端点窗口（**统计**
    ▶ **端点**）。这个窗口展示了每个端点的几个有用统计信息，如[图 5-2](ch05.xhtml#ch05fig2)所示，包括地址、数据包数量、传输和接收的字节数等。
- en: '![image](../images/f79-01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f79-01.jpg)'
- en: '*Figure 5-2: The Endpoints window lets you view each endpoint in a capture
    file.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：端点窗口让你查看捕获文件中的每个端点。*'
- en: The tabs at the top of the window (TCP, Ethernet, IPv4, IPv6, and UDP) show
    the number of endpoints organized by protocol. To display only endpoints for a
    specific protocol, click one of these tabs. You can add additional protocol-filtering
    tabs by clicking the Endpoint Types box at the bottom right of the screen and
    selecting the protocol to add. If you would like to use name resolution to view
    endpoint addresses (see “Name Resolution” on [page 84](ch05.xhtml#page_84)), check
    the Name resolution checkbox. If you’re dealing with a large capture and want
    to filter the endpoints displayed, you can apply a display filter in the main
    Wireshark window and select the Limit to display filter option in the Endpoints
    window. This option will make the window show only the endpoints matching the
    display filter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口顶部的标签（TCP、以太网、IPv4、IPv6 和 UDP）显示按协议组织的端点数量。要仅显示特定协议的端点，点击这些标签中的一个。你可以通过点击屏幕右下角的端点类型框，并选择要添加的协议，来添加额外的协议过滤标签。如果你希望使用名称解析来查看端点地址（请参见[第
    84 页](ch05.xhtml#page_84)中的“名称解析”），勾选名称解析复选框。如果你正在处理一个较大的捕获文件并且想要筛选显示的端点，可以在主
    Wireshark 窗口中应用显示过滤器，并在端点窗口中选择“限制到显示过滤器”选项。此选项将使窗口仅显示与显示过滤器匹配的端点。
- en: Another handy feature of the Endpoints window is the ability to filter out specific
    packets for display in the Packet List pane. This is a quick way to drill down
    into the packets of an individual endpoint. Right-click an end-point to select
    the available filtering options. The dialog that appears will let you show or
    exclude packets related to the selected input. You can also choose the Colorize
    option in this dialog to export the endpoint address directly into a colorization
    rule (coloring rules are discussed in [Chapter 4](ch04.xhtml#ch04)). In this way,
    you can quickly highlight packets related to a given endpoint so you can spot
    them quickly during analysis.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 端点窗口的另一个实用功能是可以过滤显示特定的数据包到数据包列表窗格中。这是一种快速深入查看单个端点数据包的方式。右键点击一个端点，选择可用的过滤选项。出现的对话框将允许你显示或排除与选定输入相关的数据包。你还可以在此对话框中选择“着色”选项，将端点地址直接导出为着色规则（着色规则在[第
    4 章](ch04.xhtml#ch04)中有讨论）。通过这种方式，你可以快速突出显示与给定端点相关的数据包，从而在分析时迅速识别它们。
- en: '***Viewing Network Conversations***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看网络会话***'
- en: '*lotsofweb.pcapng*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*lotsofweb.pcapng*'
- en: With *lotsofweb.pcapng* still open, access the Wireshark Conversations window
    **Statistics** ▶ **Conversations** ([Figure 5-3](ch05.xhtml#ch05fig3)) to display
    all the conversations in the capture file. The Conversations window is similar
    to the Endpoints window, but the Conversations window shows two addresses per
    line to represent a conversation, as well as the packets and bytes transmitted
    to and from each device. The column *Address A* is the origin endpoint, and *Address
    B* is the destination.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *lotsofweb.pcapng* 文件仍然打开的状态下，访问 Wireshark 会话窗口 **统计** ▶ **会话** ([图 5-3](ch05.xhtml#ch05fig3))
    以显示捕获文件中的所有会话。会话窗口与端点窗口相似，但会话窗口每行显示两个地址，表示一个会话，并且显示每个设备传输的包和字节。列 *地址 A* 是源端点，*地址
    B* 是目标端点。
- en: '![image](../images/f80-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f80-01.jpg)'
- en: '*Figure 5-3: The Conversations window lets you dissect each conversation in
    a capture file.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3: 会话窗口让你可以剖析捕获文件中的每个会话。*'
- en: The Conversation window is organized by protocol. To see only conversations
    using a particular protocol, click one of the tabs at the top of the window (as
    with the Endpoints window) or add other protocol types by clicking the Conversation
    Types button at the lower right. As with the Endpoints window, you can use name
    resolution, limit the visible conversations using a display filter, and right-click
    a specific conversation to create filters based on specific conversations. Conversation-based
    filters are useful for digging into the details of interesting communication sequences.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 会话窗口按协议组织。要查看仅使用特定协议的会话，点击窗口顶部的标签（与端点窗口类似），或者点击右下角的会话类型按钮添加其他协议类型。与端点窗口一样，你可以使用名称解析、使用显示过滤器限制可见的会话，或者右键点击特定会话以基于特定会话创建过滤器。基于会话的过滤器对于深入挖掘有趣的通信序列的细节非常有用。
- en: '***Identifying Top Talkers with Endpoints and Conversations***'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***识别顶级会话者与端点和会话***'
- en: '*lotsofweb.pcapng*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*lotsofweb.pcapng*'
- en: The Endpoints and Conversations windows are helpful in network troubleshooting,
    especially when you’re trying to locate the source of a significant amount of
    traffic on the network.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 端点和会话窗口在网络故障排除中非常有用，特别是当你试图找到网络中大量流量的源头时。
- en: As an example, let’s look again at *lotsofweb.pcapng*. As the name implies,
    this capture file contains HTTP traffic generated by multiple clients browsing
    the internet. [Figure 5-4](ch05.xhtml#ch05fig4) shows a list of endpoints in this
    capture file sorted by number of bytes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，我们再看一下 *lotsofweb.pcapng*。顾名思义，这个捕获文件包含多个客户端浏览互联网时生成的 HTTP 流量。[图 5-4](ch05.xhtml#ch05fig4)
    显示了这个捕获文件中的端点列表，按字节数排序。
- en: Notice that the endpoint responsible for the most traffic (by bytes) is the
    address 172.16.16.128\. This is an internal network address (we’ll cover how that
    is determined in [Chapter 7](ch07.xhtml#ch07)), and, as the device responsible
    for the most communication in this capture, it is given the designation *top talker*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，负责最多流量（按字节计算）的端点是地址 172.16.16.128。 这是一个内部网络地址（我们将在 [第 7 章](ch07.xhtml#ch07)
    讨论如何确定这一点），作为本次捕获中负责最多通信的设备，它被称为 *top talker*。
- en: '![image](../images/f81-01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f81-01.jpg)'
- en: '*Figure 5-4: The Endpoints window shows which hosts are talking the most.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：端点窗口显示了哪些主机的通信量最大。*'
- en: The address with the second highest amount of traffic is 74.125.103.163, an
    external (internet) address. When you encounter external addresses that you don’t
    know anything about, you can search the WHOIS registry to find the registered
    owner. In this case, the American Registry for Internet Numbers (*[https://whois.arin.net/ui/](https://whois.arin.net/ui/)*)
    reveals that Google owns this IP address, as seen in [Figure 5-5](ch05.xhtml#ch05fig5).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第二高流量的地址是 74.125.103.163，一个外部（互联网）地址。当你遇到一些你不了解的外部地址时，可以搜索 WHOIS 注册表来查找注册的所有者。在这种情况下，来自美国互联网号码注册局（*
    [https://whois.arin.net/ui/](https://whois.arin.net/ui/) *）的结果显示，Google 拥有这个 IP
    地址，正如 [图 5-5](ch05.xhtml#ch05fig5) 所示。
- en: '![image](../images/f81-02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f81-02.jpg)'
- en: '*Figure 5-5: Viewing WHOIS results for 74.125.103.163 points to a Google IP.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：查看 74.125.103.163 的 WHOIS 结果显示该 IP 属于 Google。*'
- en: '**DETERMING IP ADDRESS OWNERSHIP WITH WHOIS**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过 WHOIS 确定 IP 地址所有权**'
- en: IP address assignments are managed by different entities based on their geographic
    location. ARIN is responsible for IP address assignment in the United States and
    some surrounding areas, while AfriNIC manages those in Africa, RIPE handles Europe,
    and APNIC manages Asia/Pacific. Generally, you would perform a WHOIS for an IP
    at the website of the registry responsible for that IP. Of course, just by looking
    at an address, you are unlikely to know which regional registry is responsible
    for it. Websites like Robtex (*[http://robtex.com/](http://robtex.com/)*) will
    do the hard work for you and query the correct registry to provide results. However,
    if you at first query the wrong registry, you will typically be pointed to the
    correct one.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址的分配由不同的实体根据其地理位置进行管理。ARIN 负责美国及其周边地区的 IP 地址分配，AfriNIC 管理非洲地区的 IP 地址，RIPE
    负责欧洲，APNIC 负责亚洲/太平洋地区。通常，你会在负责该 IP 的注册机构的网站上执行 WHOIS 查询。当然，仅通过查看一个地址，你通常无法知道哪个区域注册机构负责它。像
    Robtex 这样的站点（* [http://robtex.com/](http://robtex.com/) *）会为你完成这项工作，查询正确的注册机构并提供结果。然而，如果你第一次查询了错误的注册机构，通常会被引导到正确的注册机构。
- en: Given this information, you could assume either that 172.16.16.128 and 74.125.103.163
    are communicating a lot with multiple other devices on their own or that both
    endpoints are communicating with each other. In fact, as is often the case with
    top-talking endpoint pairs, the endpoints are communicating with each other. To
    confirm this, open the Conversations window, select the IPv4 tab, and sort the
    list by bytes. You should see that these two endpoints comprise the conversation
    with the highest number of transferred bytes. The pattern of transfer suggests
    a large download, because the number of bytes transmitted from external Address
    A (74.125.103.163) is much greater than the number of bytes transmitted from internal
    Address B (172.16.16.128), as shown in [Figure 5-6](ch05.xhtml#ch05fig6).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，你可以假设172.16.16.128和74.125.103.163要么与多个其他设备进行大量通信，要么它们之间相互通信。实际上，正如大多数顶级通信端点对所示，这两个端点是在互相通信。为了确认这一点，打开“对话”窗口，选择IPv4标签，并按字节数对列表进行排序。你应该能看到这两个端点构成了数据传输字节数最多的对话。传输模式表明这是一次大规模的下载，因为来自外部地址A（74.125.103.163）传输的字节数远大于来自内部地址B（172.16.16.128）传输的字节数，如[图5-6](ch05.xhtml#ch05fig6)所示。
- en: '![image](../images/f82-01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f82-01.jpg)'
- en: '*Figure 5-6: The Conversations window confirms that the two top talkers are
    communicating with each other.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-6：对话窗口确认这两个主要通信端点正在相互通信。*'
- en: 'You can examine this conversation by applying this display filter:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过应用以下显示过滤器来检查此对话：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you scroll through the list of packets, you’ll see several DNS requests to
    the *[youtube.com](http://youtube.com)* domain in the Info column of the Packet
    List window. This is consistent with our finding that 74.125.103.163 is a Google-owned
    IP address, because Google owns YouTube.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览数据包列表，你会看到在数据包列表窗口的“信息”列中有几个针对*youtube.com*域的DNS请求。这与我们发现74.125.103.163是谷歌拥有的IP地址相符，因为谷歌拥有YouTube。
- en: You’ll see how to use the Endpoints and Conversations windows in practical scenarios
    throughout the remaining chapters of this book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书的剩余章节中看到如何在实际场景中使用端点和对话窗口。
- en: '**Protocol Hierarchy Statistics**'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**协议层次统计**'
- en: '*lotsofweb.pcapng*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*lotsofweb.pcapng*'
- en: When dealing with unfamiliar capture files, you’ll sometimes need to determine
    the distribution of traffic by protocol. That is, what percentage of a capture
    is TCP, IP, DHCP, and so on? Rather than counting packets and totaling the results,
    Wireshark’s Protocol Hierarchy Statistics window can provide this information
    for you.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理不熟悉的捕获文件时，有时需要确定流量按协议的分布情况。也就是说，捕获文件中有多少比例是TCP、IP、DHCP等协议？与其逐一统计数据包并汇总结果，不如使用Wireshark的“协议层次统计”窗口，它可以为你提供这些信息。
- en: For example, with the *lotsofweb.pcapng* file still open and any previously
    applied filters cleared, open the Protocol Hierarchy Statistics window, as shown
    in [Figure 5-7](ch05.xhtml#ch05fig7), by choosing **Statistics** ▶ **Protocol
    Hierarchy**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，保持*lotsofweb.pcapng*文件打开并清除之前应用的任何过滤器后，选择**统计** ▶ **协议层次**，如[图5-7](ch05.xhtml#ch05fig7)所示，打开“协议层次统计”窗口。
- en: '![image](../images/f83-01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f83-01.jpg)'
- en: '*Figure 5-7: The Protocol Hierarchy Statistics window shows the distribution
    of traffic by protocol.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-7：协议层次统计窗口显示流量按协议的分布情况。*'
- en: The Protocol Hierarchy Statistics window gives you a snapshot of the type of
    activity occurring on a network. In [Figure 5-7](ch05.xhtml#ch05fig7), 100 percent
    is Ethernet traffic, 99.7 percent is IPv4, 98 percent is TCP, and 13.5 percent
    is HTTP from web browsing. This information provides a great way to benchmark
    your network, especially once you have a mental picture of what your network traffic
    usually looks like. For instance, if you know that 10 percent of your network
    traffic is normally ARP traffic, but you see 50 percent ARP traffic in a recent
    capture, then something might be wrong. In some cases, the mere existence of a
    protocol could be of interest. If you don’t have any devices configured to use
    Spanning Tree Protocol (STP), seeing it in a protocol hierarchy might mean that
    a device is misconfigured.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 协议层次统计窗口为您提供网络上发生的活动类型的快照。在[图5-7](ch05.xhtml#ch05fig7)中，100%为以太网流量，99.7%为IPv4，98%为TCP，13.5%为来自网页浏览的HTTP流量。这些信息为您提供了一个很好的方式来基准测试您的网络，尤其是在您已经对网络流量的常见模式有了直观了解的情况下。例如，如果您知道您的网络流量中通常有10%是ARP流量，但在最近的捕获中看到50%的ARP流量，那么可能有问题。在某些情况下，协议的存在本身就可能引起注意。如果您没有任何设备配置使用生成树协议（STP），那么在协议层次结构中看到它可能意味着某个设备配置错误。
- en: Over time, you’ll find that you can use the Protocol Hierarchy Statistics window
    to profile the users and devices on a network simply by looking at the distribution
    of protocols in use. For example, a higher amount of HTTP traffic will tell you
    that there’s a lot of web browsing going on. You may also find that you can identify
    specific devices on the network simply by looking at the traffic from a network
    segment belonging to a business unit. For example, the IT department might use
    more administrative protocols such as ICMP or SNMP, customer service might be
    responsible for a high volume of SMTP (email) traffic, and the pesky intern in
    the corner might be flooding the network with *World of Warcraft* traffic!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，您会发现通过查看协议使用情况的分布，您可以仅凭协议层次统计窗口来分析网络中的用户和设备。例如，更高的HTTP流量会告诉您有大量的网页浏览活动。您还可能发现，仅凭查看属于某个业务部门的网络段的流量，您就能识别出网络中的特定设备。例如，IT部门可能使用更多的管理协议，如ICMP或SNMP，客户服务部门可能负责大量的SMTP（电子邮件）流量，而角落里那个烦人的实习生可能正用*魔兽世界*流量占满整个网络！
- en: '**Name Resolution**'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**名称解析**'
- en: Network data is sent between endpoints with the help of various alphanumeric
    addressing systems that are often too long or complicated to remember, such as
    MAC address 00:16:ce:6e:8b:24, IPv4 address 192.168.47.122, or IPv6 address 2001:db8:a0b:12f0::1\.
    *Name resolution* (also called *name lookup*) converts one identifying address
    into another, mostly for the sake of making the address easier to remember. For
    example, it’s much easier to remember *[google.com](http://google.com)* than to
    remember 216.58.217.238\. By associating easy-to-read names with these cryptic
    addresses, we make them easier to remember and identify.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 网络数据通过各种字母数字地址系统在端点之间传输，这些地址通常过长或过于复杂，不容易记住，例如MAC地址00:16:ce:6e:8b:24，IPv4地址192.168.47.122或IPv6地址2001:db8:a0b:12f0::1。*名称解析*（也称为*名称查找*）将一个标识地址转换为另一个地址，主要是为了使地址更容易记住。例如，记住*
    [google.com](http://google.com) *比记住216.58.217.238要容易得多。通过将易读的名称与这些晦涩的地址关联起来，我们使它们更容易记住和识别。
- en: '***Enabling Name Resolution***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启用名称解析***'
- en: 'Wireshark can use name resolution when it displays packet data to make analysis
    easier. To have Wireshark use name resolution, choose **Edit** ▶ **Preferences**
    ▶ **Name Resolution**. This window is shown in [Figure 5-8](ch05.xhtml#ch05fig8).
    Here are the primary options available in Wireshark for name resolution:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark可以在显示数据包时使用名称解析来简化分析。要启用Wireshark的名称解析，请选择**编辑** ▶ **首选项** ▶ **名称解析**。该窗口如[图5-8](ch05.xhtml#ch05fig8)所示。以下是Wireshark中与名称解析相关的主要选项：
- en: '**Resolve MAC addresses**   Uses the ARP protocol to attempt to convert layer
    2 MAC addresses, such as 00:09:5b:01:02:03, into layer 3 addresses, such as 10.100.12.1\.
    If attempts at these conversions fail, Wireshark will use the *ethers* file in
    its program directory to attempt conversion. Wireshark’s last resort is to convert
    the first 3 bytes of the MAC address into the device’s IEEE-specified manufacturer
    name, such as *Netgear_01:02:03*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**解析MAC地址**  使用ARP协议尝试将二层MAC地址（例如00:09:5b:01:02:03）转换为三层地址（例如10.100.12.1）。如果这些转换失败，Wireshark会使用程序目录中的*ethers*文件进行转换尝试。Wireshark的最后手段是将MAC地址的前三个字节转换为设备的IEEE指定的制造商名称，例如*Netgear_01:02:03*。'
- en: '**Resolve transport names**   Attempts to convert a port number into a name
    associated with it, for example, to display port 80 as *http*. This is handy when
    you encounter an uncommon port and don’t know what service is typically associated
    with it.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**解析传输名称**  尝试将端口号转换为与之相关的名称，例如，将端口 80 显示为 *http*。当你遇到一个不常见的端口并不知道它通常关联的服务时，这个功能很有用。'
- en: '**Resolve network (IP) addresses**   Attempts to convert a layer 3 address,
    such as 192.168.1.50, into an easy-to-read DNS name, such as *[MarketingPC1.domain.com](http://MarketingPC1.domain.com)*.
    This is helpful for identifying the purpose or owner of a system, assuming it
    has a descriptive name.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**解析网络（IP）地址**  尝试将第 3 层地址（如 192.168.1.50）转换为易于阅读的 DNS 名称，例如 *[MarketingPC1.domain.com](http://MarketingPC1.domain.com)*。这对于识别系统的用途或所有者非常有帮助，前提是该系统有一个描述性的名称。'
- en: '![image](../images/f85-01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f85-01.jpg)'
- en: '*Figure 5-8: Enabling name resolution in the Preferences dialog. Only Resolve
    MAC addresses is selected amongst the first three checkboxes pertaining to types
    of name resolution.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-8：在首选项对话框中启用名称解析。第一组三个与名称解析类型相关的复选框中，只有“解析 MAC 地址”被选中。*'
- en: 'The Name Resolution preferences dialog in [Figure 5-8](ch05.xhtml#ch05fig8)
    includes a few other useful options:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-8](ch05.xhtml#ch05fig8) 中的名称解析首选项对话框包括一些其他有用的选项：'
- en: '**Use captured DNS packet data for address resolution**   Parses DNS data from
    captured DNS packets to resolve IP addresses to DNS names.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用捕获的 DNS 数据包数据进行地址解析**  从捕获的 DNS 数据包中解析 DNS 数据，以将 IP 地址解析为 DNS 名称。'
- en: '**Use an external network name resolver**   Allows Wireshark to generate queries
    to the DNS server used by your analysis machine in order to resolve IP addresses
    to DNS names. This is helpful if you want to use DNS name resolution but the capture
    you are analyzing doesn’t contain the relevant DNS packets.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用外部网络名称解析器**  允许 Wireshark 向分析机器使用的 DNS 服务器生成查询，以将 IP 地址解析为 DNS 名称。如果您希望使用
    DNS 名称解析，但正在分析的捕获数据包中没有相关的 DNS 数据包，这将非常有帮助。'
- en: '**Maximum concurrent requests**   Rate limits the number of concurrent DNS
    queries that can be outstanding at once. Use this option if your capture will
    generate a lot of DNS requests and you’re concerned about taking up too much bandwidth
    on your network or DNS server.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**最大并发请求数**  限制了可以同时进行的并发 DNS 查询的数量。如果你的捕获操作会生成大量的 DNS 请求，且你担心会占用过多的网络带宽或 DNS
    服务器资源，可以使用此选项。'
- en: '**Only use the profile “hosts” file**   Limits DNS resolution to the host file
    associated with the active Wireshark profile. I’ll describe how to use this file
    later in this section.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅使用“hosts”文件配置**  限制 DNS 解析仅使用与当前 Wireshark 配置文件关联的主机文件。我将在本节稍后介绍如何使用此文件。'
- en: The changes made in the Preferences screen will persist after Wireshark is closed
    and reopened. To make name resolution changes on the fly without them being persistent,
    toggle name resolution settings on or off by clicking View ▶ Name Resolution on
    the main drop-down menu. You have the option of enabling or disabling name resolution
    for physical, transport, and network addresses.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在首选项屏幕中所做的更改将在关闭并重新打开 Wireshark 后保持不变。若要临时更改名称解析设置而不使其保持，您可以通过点击主菜单中的“查看 ▶ 名称解析”来切换名称解析的启用或禁用。您可以选择启用或禁用物理、传输和网络地址的名称解析。
- en: You can leverage the various name resolution tools to make your capture files
    more readable and to save a lot of time in certain situations. For example, you
    can use DNS name resolution to help readily identify the name of a computer you
    are trying to pinpoint as the source of a particular packet.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用各种名称解析工具，使捕获的文件更易于阅读，并在某些情况下节省大量时间。例如，您可以使用 DNS 名称解析帮助快速识别您正在定位的计算机的名称，该计算机是某个特定数据包的来源。
- en: '***Potential Drawbacks to Name Resolution***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***名称解析的潜在缺点***'
- en: Given its benefits, using name resolution may seem like a no-brainer, but there
    are some potential drawbacks. First, network name resolution can fail if there
    is no DNS server available to provide the name associated with an IP address.
    Name resolution information is not saved with the capture file, so the resolution
    process must take place every time you open a file. If you capture packets on
    one network and then open the capture on another network, then your system might
    not be able to access the DNS servers from the source network and name resolution
    will fail.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于其优点，使用名称解析可能看起来是显而易见的，但也存在一些潜在的缺点。首先，如果没有DNS服务器提供与IP地址相关联的名称，网络名称解析可能会失败。名称解析信息不会随捕获文件一起保存，因此每次打开文件时都必须进行解析。如果您在一个网络上捕获数据包，然后在另一个网络上打开该捕获文件，则您的系统可能无法访问源网络的DNS服务器，导致名称解析失败。
- en: In addition, name resolution requires additional processing overhead. When dealing
    with a very large capture file, you may want to forgo name resolution to conserve
    system resources. If you try to open a large capture and find your system struggling
    to load it or Wireshark crashes, disabling name resolution might help.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，名称解析需要额外的处理开销。当处理非常大的捕获文件时，您可能希望放弃名称解析，以节省系统资源。如果您尝试打开一个大型捕获文件，发现系统无法加载它，或者Wireshark崩溃，禁用名称解析可能会有所帮助。
- en: One further issue is that network name resolution’s reliance on DNS may generate
    unwanted packets that will cloud your capture file as traffic is sent to DNS servers
    to resolve addresses. Complicating things further, if the capture file you are
    analyzing contains malicious IP addresses, attempting to resolve them could generate
    queries to attacker-controlled infrastructure that could tip off an attacker that
    you are aware of their actions, possibly making you a target. To reduce the risk
    of clouding your packet file or of unwittingly communicating with an attacker,
    disable the Use an external network name resolver option in the Name Resolution
    Preferences dialog.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，网络名称解析依赖于DNS，这可能会生成不必要的数据包，从而使捕获文件变得混乱，因为流量会发送到DNS服务器以解析地址。更复杂的是，如果你分析的捕获文件包含恶意IP地址，尝试解析它们可能会生成向攻击者控制的基础设施发送的查询，这可能会让攻击者意识到你已经发现了他们的行动，甚至可能让你成为攻击目标。为了减少污染数据包文件或无意间与攻击者通信的风险，请在“名称解析首选项”对话框中禁用“使用外部网络名称解析器”选项。
- en: '***Using a Custom hosts File***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用自定义hosts文件***'
- en: It can be tedious to keep track of traffic from multiple hosts in large capture
    files, especially when external host resolution isn’t available. One way to help
    is to manually label systems based on their IP addresses with a Wireshark *hosts*
    file, which is a text file with a list of IP address to name mappings. You can
    use a *hosts* file to label addresses in Wireshark with names for quick reference.
    These names will be shown in the Packet List pane.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型捕获文件中，尤其是当外部主机解析不可用时，跟踪来自多个主机的流量可能会变得繁琐。帮助的方法之一是使用Wireshark的*hosts*文件手动标记系统，文件是一个包含IP地址与名称映射的文本文件。你可以使用*hosts*文件为Wireshark中的地址标记名称，以便快速参考。这些名称将显示在数据包列表窗格中。
- en: 'To use a *hosts* file, follow these steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用*hosts*文件，请按照以下步骤操作：
- en: Choose **Edit** ▶ **Preferences** ▶ **Name Resolution** and select **Only use
    the profile “hosts” file**.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**编辑** ▶ **首选项** ▶ **名称解析**，然后选择**仅使用“hosts”配置文件**。
- en: Create a new file using Windows Notepad or a similar text editor. The file should
    contain one entry per line with an IP address and the name to resolve to, as shown
    in [Figure 5-9](ch05.xhtml#ch05fig9). The name you choose on the right will be
    what is shown in the packet list window whenever Wireshark encounters the IP address
    on the left.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Windows记事本或类似的文本编辑器创建一个新文件。文件应包含每行一个条目，其中包括一个IP地址和需要解析的名称，如[图5-9](ch05.xhtml#ch05fig9)所示。你在右侧选择的名称将在Wireshark遇到左侧的IP地址时显示在数据包列表窗口中。
- en: '![image](../images/f87-01.jpg)'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f87-01.jpg)'
- en: '*Figure 5-9: Creating a Wireshark* hosts *file*'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图5-9: 创建Wireshark* hosts *文件*'
- en: Save the file as a plaintext file with the name *hosts* to the appropriate directory,
    as listed below. Be sure that the file has no extension!
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存为纯文本文件，并命名为*hosts*，存储到适当的目录中，如下所示。确保文件没有扩展名！
- en: '•     Windows: *<USERPROFILE>\Application Data\Wireshark\hosts*'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '•     Windows: *<USERPROFILE>\Application Data\Wireshark\hosts*'
- en: '•     OS X: */Users/<username>/.wireshark/hosts*'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '•     OS X: */Users/<username>/.wireshark/hosts*'
- en: '•     Linux: */home/<username>/.wireshark/hosts*'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '•     Linux: */home/<username>/.wireshark/hosts*'
- en: Now open a capture, and any IP addresses in your *hosts* file should resolve
    to the specified names, as shown in [Figure 5-10](ch05.xhtml#ch05fig10). Instead
    of IP addresses in the Source and Destination columns of the packet list window,
    more meaningful names are shown.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开一个捕获文件，你的*hosts*文件中的任何IP地址应该会解析为指定的名称，如[图 5-10](ch05.xhtml#ch05fig10)所示。取代数据包列表窗口中的源地址和目的地址列显示的IP地址，会显示更有意义的名称。
- en: '![image](../images/f87-02.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f87-02.jpg)'
- en: '*Figure 5-10: Name resolution from a* hosts *file in Wireshark*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-10：Wireshark中* hosts *文件的名称解析*'
- en: Using *hosts* files in this way can dramatically improve your ability to recognize
    certain hosts during analysis. When working with a team of analysts, consider
    sharing a *hosts* file of known assets among your networking staff. This will
    help your team quickly recognize systems with static addresses, such as servers
    and routers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用*hosts*文件可以显著提高你在分析过程中识别特定主机的能力。当与分析团队合作时，考虑在你的网络工作人员之间共享已知资产的*hosts*文件。这将帮助你的团队快速识别具有静态地址的系统，如服务器和路由器。
- en: '**NOTE**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If your* hosts *file doesn’t appear to be working, make sure that you haven’t
    accidentally added a file extension to the filename. The file’s name should simply
    be* hosts.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你的* hosts *文件似乎没有正常工作，请确保你没有不小心为文件名添加文件扩展名。文件名应该只是* hosts。'
- en: '***Manually Initiated Name Resolution***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***手动启动名称解析***'
- en: Wireshark also has the ability to force name resolution on a temporary, on-demand
    basis. This is done by right-clicking a packet in the Packet List pane and choosing
    the Edit Resolved Name option. The window that pops up will allow you to specify
    a name for an address, like a label. This resolution will be lost once the capture
    file is closed, making this a quick way to label an address without making any
    permanent changes that would have to be reverted later. I use this technique often
    because it is a little easier than manually editing a *hosts* file for every packet
    capture I look at.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark还具有在临时按需基础上强制进行名称解析的能力。这是通过右键单击数据包列表窗格中的一个数据包，然后选择编辑已解析名称选项来完成的。弹出的窗口允许你为地址指定一个名称，类似于标签。此解析在捕获文件关闭后会丢失，因此这是一种快速标记地址的方法，而无需进行永久性更改，也不必担心以后撤销更改。我经常使用这种技术，因为它比每次查看数据包捕获时手动编辑*hosts*文件更简单。
- en: '**Protocol Dissection**'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**协议分解**'
- en: One of Wireshark’s biggest strengths is its support for the analysis of over
    a thousand protocols. Wireshark has this capability because it is open source,
    thus providing a framework for creating *protocol dissectors*. These allow Wireshark
    to recognize and decode a protocol into various fields so the protocol can be
    displayed in the user interface. Wireshark uses several dissectors in unison to
    interpret each packet. For example, the ICMP protocol dissector allows Wireshark
    to recognize that an IP packet contains ICMP data, pull out the ICMP type and
    code, and format those fields for display in the Info column of the Packet List
    pane.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark最大的优势之一是它支持分析超过一千种协议。Wireshark之所以具有这种能力，是因为它是开源的，从而提供了一个框架来创建*协议分解器*。这些分解器使Wireshark能够识别并解码协议为各种字段，以便在用户界面中显示该协议。Wireshark使用多个分解器协同工作来解释每个数据包。例如，ICMP协议分解器使Wireshark能够识别IP数据包包含ICMP数据，提取ICMP类型和代码，并将这些字段格式化后显示在数据包列表窗格的“信息”列中。
- en: You can think of a dissector as the translator between raw data and the Wireshark
    program. For a protocol to be supported by Wireshark, it must have a dissector
    (or you can write your own).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将分解器看作是原始数据与Wireshark程序之间的翻译器。为了让Wireshark支持某个协议，该协议必须有一个分解器（或者你可以自己编写一个）。
- en: '***Changing the Dissector***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***更改分解器***'
- en: '*wrongdissector.pcapng*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*wrongdissector.pcapng*'
- en: Wireshark uses dissectors to detect individual protocols and decide how to display
    network information. Unfortunately, Wireshark doesn’t always make the right choices
    when selecting the dissector to use on a packet. This is especially true when
    a protocol on the network is using a nonstandard configuration, such as a non-default
    port (which is often configured by network administrators as a security precaution
    or by employees trying to circumvent access controls).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark使用分解器来检测各个协议并决定如何显示网络信息。不幸的是，Wireshark在选择应用于数据包的分解器时并不总是做出正确的选择。当网络上的协议使用非标准配置时，尤其如此，例如非默认端口（这通常由网络管理员作为安全预防措施配置，或由员工试图规避访问控制时使用）。
- en: When Wireshark incorrectly applies dissectors, it’s possible to override this
    selection. For example, open the trace file *wrongdissector.pcapng*. This file
    contains a bunch of SSL communication between two computers. SSL is the Secure
    Socket Layer protocol, which is used for encrypted communication between hosts.
    Under most normal circumstances, viewing SSL traffic in Wireshark won’t yield
    much usable information due to its encrypted nature. However, there is something
    definitely wrong here. If you peruse the contents of several of these packets
    by clicking them and examining the Packet Bytes pane, you will find plaintext
    traffic. In fact, if you look at packet 4, you will find mention of the FileZilla
    FTP server application. The next few packets clearly display a request and response
    for both a username and a password.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当Wireshark错误地应用了解析器时，可以覆盖此选择。例如，打开追踪文件*wrongdissector.pcapng*。该文件包含两台计算机之间的大量SSL通信。SSL是安全套接字层协议，用于主机之间的加密通信。在大多数正常情况下，由于其加密性质，在Wireshark中查看SSL流量不会获得太多可用信息。然而，这里显然有些问题。如果你通过点击这些数据包并检查数据包字节面板来浏览其中的几个数据包内容，你会发现明文流量。事实上，如果你查看数据包4，你会发现提到了FileZilla
    FTP服务器应用程序。接下来的几个数据包清楚地显示了用户名和密码的请求和响应。
- en: If this were actually SSL traffic, you wouldn’t be able to read any of the data
    contained in the packets, and you certainly wouldn’t see all the user-names and
    passwords transmitted in clear text, as in [Figure 5-11](ch05.xhtml#ch05fig11).
    Given the information shown here, it’s safe to assume that this is probably FTP
    traffic, rather than SSL traffic. Wireshark is likely interpreting this traffic
    as SSL because it is using port 443, as seen under the Info column, and port 443
    is the standard port used for HTTPS (HTTP over SSL).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这真的是SSL流量，你将无法读取数据包中包含的任何数据，而且你肯定不会看到明文传输的所有用户名和密码，如[图5-11](ch05.xhtml#ch05fig11)所示。根据这里显示的信息，可以安全地假设这可能是FTP流量，而不是SSL流量。Wireshark可能会将此流量解释为SSL，因为它使用的是端口443，如在“信息”列中看到的那样，而端口443是HTTPS（基于SSL的HTTP）的标准端口。
- en: '![image](../images/f89-01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f89-01.jpg)'
- en: '*Figure 5-11: Plaintext usernames and passwords? This looks more like FTP than
    SSL!*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-11：明文用户名和密码？这看起来更像是FTP而不是SSL！*'
- en: 'To fix this problem, you can apply a *forced decode* to Wireshark to use the
    FTP protocol dissector on these packets. Here are the steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，你可以对Wireshark应用*强制解码*，使用FTP协议解析器来解析这些数据包。以下是步骤：
- en: Right-click an SSL packet (such as packet 30) in the Protocol column and select
    **Decode As**, which opens a new dialog.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击协议列中的一个SSL数据包（例如数据包30），然后选择**解码为**，这将打开一个新对话框。
- en: Tell Wireshark to decode all TCP port 443 traffic as FTP by selecting TCP port
    in the Field column, entering 443 in the Value column, and selecting FTP from
    the drop-down menu in the Current column, as shown in [Figure 5-12](ch05.xhtml#ch05fig12).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉Wireshark将所有TCP端口443流量解码为FTP，通过选择“字段”列中的TCP端口，在“值”列中输入443，并从“当前”列的下拉菜单中选择FTP，如[图5-12](ch05.xhtml#ch05fig12)所示。
- en: '![image](../images/f89-02.jpg)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f89-02.jpg)'
- en: '*Figure 5-12: The Decode As... dialog allows you to create forced decodes.*'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图5-12：解码为...对话框允许你创建强制解码。*'
- en: Click **OK** to see the changes immediately applied to the capture file.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**，立即将更改应用到捕获文件中。
- en: The data will be decoded as FTP traffic so you can analyze it from the Packet
    List pane without needing to dig deep into individual bytes ([Figure 5-13](ch05.xhtml#ch05fig13)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 数据将作为FTP流量进行解码，这样你就可以在数据包列表面板中分析它，而无需深入查看单个字节（[图5-13](ch05.xhtml#ch05fig13)）。
- en: '![image](../images/f90-01.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f90-01.jpg)'
- en: '*Figure 5-13: Viewing properly decoded FTP traffic*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-13：查看正确解码的FTP流量*'
- en: The forced decode feature can be used multiple times in the same capture file.
    Wireshark will keep track of your forced decodes for you in the Decode As... dialog,
    where you can view and edit all of the forced decodes you have created so far.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 强制解码功能可以在同一个捕获文件中多次使用。Wireshark会在“解码为...”对话框中跟踪你强制解码的记录，在那里你可以查看和编辑迄今为止创建的所有强制解码。
- en: By default, forced decodes are not saved when you close a capture. You can remedy
    this by clicking the Save button in the Decode As... dialog. This will save the
    protocol-decoding rules to your current Wireshark user profile; they will be applied
    when you open any capture using that profile. Saved decode rules can be removed
    by clicking the minus button in the dialog.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，强制解码不会在你关闭捕获时保存。你可以通过在“解码为...”对话框中点击保存按钮来解决这个问题。这会将协议解码规则保存到你当前的 Wireshark
    用户配置文件中；当你使用该配置文件打开任何捕获文件时，这些规则将会被应用。保存的解码规则可以通过点击对话框中的减号按钮来移除。
- en: It’s very easy to save decoding rules and forget about them. This can lead to
    a lot of confusion when you aren’t prepared for it, so be mindful of forced decodes.
    To prevent myself from falling victim to this oversight, I generally avoid saving
    forced decodes to my primary Wireshark profile.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易保存解码规则后就忘记它们。当你没有准备好时，这可能会导致很多困惑，所以要留心强制解码。为了避免自己犯这个疏忽，我通常避免将强制解码保存到我的主 Wireshark
    配置文件中。
- en: '***Viewing Dissector Source Code***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看解剖器源代码***'
- en: The beauty of working with an open source application is that, if you are confused
    about why something is happening, you can look at the source code and find out
    why. This really comes in handy when you are trying to determine why a particular
    protocol has been interpreted incorrectly, because you can examine individual
    protocol dissectors.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用开源应用程序的好处在于，如果你对某些事情发生的原因感到困惑，你可以查看源代码，找出原因。当你尝试确定某个特定协议为什么被错误解读时，这非常有用，因为你可以检查各个协议解剖器。
- en: Examining the source code of protocol dissectors can be done directly from the
    Wireshark website by clicking the Develop link and clicking Browse the Code. This
    link will send you to the Wireshark code repository, where you can view the release
    code for recent Wireshark versions. The protocol dissectors are in the *epan/dissectors*
    folder, and each dissector is labeled *packets-<protocolname>.c*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击 Wireshark 网站上的“开发”链接并点击“浏览代码”，可以直接查看协议解剖器的源代码。此链接将把你带到 Wireshark 代码仓库，在那里你可以查看最新
    Wireshark 版本的发布代码。协议解剖器位于*epan/dissectors*文件夹中，每个解剖器都标注为*packets-<protocolname>.c*。
- en: These files can be rather complex, but they all follow a standard template and
    tend to be commented very well. You don’t need to be an expert C programmer to
    understand the basic function of each dissector. If you want to get a deep understanding
    of what you are seeing in Wireshark, I recommend taking a look at dissectors for
    some of the simpler protocols.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件可能相当复杂，但它们都遵循标准模板，并且通常注释得非常好。你不需要是一个专家级的 C 程序员就能理解每个解剖器的基本功能。如果你想深入理解在 Wireshark
    中看到的内容，我建议你查看一些简单协议的解剖器。
- en: '**Following Streams**'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**跟踪流**'
- en: '*http_google.pcapng*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*http_google.pcapng*'
- en: One of Wireshark’s most satisfying analysis features is its ability to reassemble
    data from multiple packets into a consolidated, easily readable format, often
    called a *packet transcript*. So you don’t have to view data being sent from client
    to server in a bunch of small chunks while clicking from packet to packet, *stream
    following* sorts the data to make it easier to view.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 最令人满意的分析功能之一是其能够将来自多个数据包的数据重新组合成一个合并的、易于阅读的格式，这通常被称为*数据包转录*。这样，你就不需要在点击数据包之间时查看客户端到服务器的数据的小块，*流跟随*功能会将数据排序，便于查看。
- en: 'Four types of streams are available to follow:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种类型的流可供跟随：
- en: '**TCP stream**   Assembles data from protocols that utilize TCP, such as HTTP
    and FTP.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCP 流** 组装来自使用 TCP 的协议的数据，例如 HTTP 和 FTP。'
- en: '**UDP stream**   Assembles data from protocols that utilize UDP, such as DNS.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**UDP 流** 组装来自使用 UDP 的协议的数据，例如 DNS。'
- en: '**SSL stream**   Assembles data from protocols that are encrypted, such as
    HTTPS. You must supply keys to decrypt the traffic.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSL 流** 组装来自加密协议的数据，例如 HTTPS。你必须提供密钥来解密流量。'
- en: '**HTTP stream**   Assembles and decompresses data from the HTTP protocol. This
    is useful when following HTTP data via TCP stream doesn’t decode the HTTP payload
    fully.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP 流** 组装和解压来自 HTTP 协议的数据。当通过 TCP 流跟踪 HTTP 数据时，无法完全解码 HTTP 负载时，这非常有用。'
- en: As an example, consider a simple HTTP transaction in the file *http_google.pcapng*.
    Click any of the TCP or HTTP packets in the file, right-click the packet, and
    choose **Follow TCP Stream**. This will consolidate the TCP stream and open the
    conversation transcript in a separate window, as in [Figure 5-14](ch05.xhtml#ch05fig14).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，考虑文件*http_google.pcapng*中的一个简单HTTP事务。点击文件中的任意TCP或HTTP数据包，右键点击数据包并选择**跟踪TCP流**。这将整合TCP流并在一个单独的窗口中打开对话记录，如[图5-14](ch05.xhtml#ch05fig14)所示。
- en: The text displayed in this window is in two colors, with red text (shown here
    with the lighter gray shading) signifying traffic from source to destination and
    blue text (shown here with the darker gray shading) identifying traffic in the
    opposite direction, from destination to source. The color relates to which side
    initiated the communication. In our example, the client initiated the connection
    to the web server, so it’s displayed in red.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口中显示的文本使用了两种颜色，红色文本（在这里用较浅的灰色阴影表示）表示源到目的地的流量，蓝色文本（在这里用较深的灰色阴影表示）则表示目的地到源的流量。颜色的不同与通信的发起方有关。在我们的例子中，客户端发起了与Web服务器的连接，因此显示为红色。
- en: The communication in the TCP stream begins with an initial `GET` request for
    the web root directory (`/`) and a response from the server that the request was
    successful in the form of an `HTTP/1.1 200 OK`. A similar pattern is repeated
    throughout other streams in the packet capture as the client requests individual
    files and the server responds with them. You are seeing a user browsing to the
    Google home page, but instead of having to step through every packet, you’re able
    to scroll through the transcript with ease. You’re actually seeing what the end
    user is seeing, but from the inside out.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: TCP流中的通信以一个初始的`GET`请求开始，请求访问网站根目录（`/`），并且服务器以`HTTP/1.1 200 OK`形式响应，表示请求成功。在数据包捕获中的其他流中也重复出现类似的模式，客户端请求单个文件，服务器相应返回。这实际上是一个用户在浏览Google主页的过程，不过您不需要逐个查看每个数据包，而是能够轻松滚动浏览记录。您所看到的是用户所看到的内容，但从内部视角。
- en: '![image](../images/f92-01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f92-01.jpg)'
- en: '*Figure 5-14: The Follow TCP Stream window reassembles the communication in
    an easily readable format.*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-14：跟踪TCP流窗口将通信重新组装成易于阅读的格式。*'
- en: In addition to viewing the raw data in this window, you can search within the
    text; save it as a file; print it; or choose to view the data in ASCII, EBCDIC,
    hex, or C array format. These options, which make digging through larger sets
    of data easier, can be found at the bottom of the Follow Stream window.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在此窗口中查看原始数据外，您还可以在文本中进行搜索；将其保存为文件；打印；或者选择以ASCII、EBCDIC、十六进制或C数组格式查看数据。这些选项位于跟踪流窗口的底部，有助于在处理大量数据时更加便捷。
- en: '***Following SSL Streams***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***跟踪SSL流***'
- en: 'Following TCP and UDP streams is a simple two-click operation, but viewing
    SSL streams in a readable format requires a few additional steps. Because the
    traffic is encrypted, you are required to supply the private key associated with
    the server responsible for the encrypted traffic. The method you will use to retrieve
    this key varies depending on the server technology in use and is beyond the scope
    of this book, but once you have it, you will have to load it into Wireshark using
    the following process:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪TCP和UDP流是一个简单的两步操作，但要以可读格式查看SSL流则需要几个额外的步骤。由于流量被加密，您需要提供与负责加密流量的服务器关联的私钥。获取此密钥的方法取决于使用的服务器技术，超出了本书的范围，但一旦您获得了该密钥，您需要按照以下过程将其加载到Wireshark中：
- en: Access your Wireshark preferences by clicking **Edit** ▶ **Preferences**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**编辑** ▶ **首选项**来访问Wireshark的首选项设置。
- en: Expand the **Protocols** section and click the **SSL** protocol heading (shown
    in [Figure 5-15](ch05.xhtml#ch05fig15)). Click the **Edit** button next to the
    RSA keys list label.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**协议**部分，点击**SSL**协议标题（如[图5-15](ch05.xhtml#ch05fig15)所示）。点击RSA密钥列表标签旁的**编辑**按钮。
- en: Click the plus (+) button.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击加号（+）按钮。
- en: Supply the required information. This includes the IP address of the server
    responsible for the encryption, the port, the protocol, the location of the key
    file, and a password for the key file if one was used.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供所需的信息。这包括负责加密的服务器的IP地址、端口、协议、密钥文件的位置，如果使用了密码，还需提供密钥文件的密码。
- en: Restart Wireshark.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启Wireshark。
- en: '![image](../images/f93-01.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f93-01.jpg)'
- en: '*Figure 5-15: Adding SSL decryption information*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-15：添加SSL解密信息*'
- en: Once this process is complete, you should be able to capture encrypted traffic
    between a client and server. Right-click an HTTPS packet and click **Follow SSL
    Stream** to see the clear text transcript.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦此过程完成，你应该能够捕获客户端和服务器之间的加密流量。右键点击一个HTTPS数据包，然后点击**跟踪SSL流**以查看明文转录。
- en: The ability to view packet transcripts is one of the most commonly used analysis
    features in Wireshark, and you will come to rely on it to quickly determine what
    specific protocols are being used to do. We’ll cover several additional scenarios
    in later chapters that rely on viewing packet transcripts.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 查看数据包转录的能力是Wireshark中最常用的分析功能之一，你会依赖它来快速确定正在使用哪些特定协议。我们将在后续章节中介绍几个依赖于查看数据包转录的额外场景。
- en: '**Packet Lengths**'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据包长度**'
- en: '*download-slow.pcapng*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*download-slow.pcapng*'
- en: The size of a single packet or group of packets can tell you a lot about a situation.
    Under normal circumstances, the maximum size of a frame on an Ethernet network
    is 1,518 bytes. When you subtract the Ethernet, IP, and TCP headers from this
    number, you are left with 1,460 bytes that can be used for the transmission of
    a layer 7 protocol header or for data. If you know the minimum requirements for
    packet transmission, you can begin to look at the distribution of packet lengths
    in a capture to make educated guesses about the makeup of the traffic. This is
    immensely helpful for attempting to understand the composition of large capture
    files. Wireshark provides the Packet Lengths dialog for you to view the distribution
    of packets based on length.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 单个数据包或数据包组的大小可以告诉你很多关于网络状况的信息。在正常情况下，以太网网络中一个帧的最大大小是1,518字节。当你从这个数值中减去以太网、IP和TCP头部后，你剩下的是1,460字节，这些字节可以用于传输第七层协议头部或数据。如果你知道数据包传输的最小要求，就可以开始查看捕获中数据包长度的分布，以合理推测流量的构成。这对理解大型捕获文件的组成非常有帮助。Wireshark提供了数据包长度对话框，供你查看根据长度分布的数据包。
- en: Let’s look at an example by opening the file *download-slow.pcapng*. Once it
    is open, select **Statistics** ▶ **Packet Lengths**. The result is the Packet
    Lengths dialog shown in [Figure 5-16](ch05.xhtml#ch05fig16).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过打开文件*download-slow.pcapng*来举个例子。打开后，选择**统计** ▶ **数据包长度**。结果会显示[图 5-16](ch05.xhtml#ch05fig16)中的数据包长度对话框。
- en: '![image](../images/f94-01.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f94-01.jpg)'
- en: '*Figure 5-16: The Packet Lengths dialog helps you make educated guesses about
    the traffic in the capture file.*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-16：数据包长度对话框帮助你对捕获文件中的流量做出合理的推测。*'
- en: Pay special attention to the row showing statistics for packets ranging from
    1,280 to 2,559 bytes. Larger packets like these typically indicate the transfer
    of data, whereas smaller packets indicate protocol control sequences. In this
    case, we have a large percentage of bigger packets (66.43 percent). Without seeing
    the packets in the file, we can make the educated guess that the capture contains
    one or more transfers of data. This could be in the form of an HTTP download,
    an FTP upload, or any other type of network communication in which data is transferred
    between hosts.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意显示统计信息的行，其中数据包长度在1,280到2,559字节之间。像这样的较大数据包通常表示数据传输，而较小的数据包则表示协议控制序列。在这种情况下，我们看到较大数据包的比例很高（66.43%）。即使没有查看文件中的数据包，我们也可以合理推测，捕获文件中包含一个或多个数据传输。这些传输可能是HTTP下载、FTP上传或其他类型的网络通信，其中数据在主机之间传输。
- en: Most of the remaining packets (33.44 percent) are in the 40- to 79-byte range.
    Packets in this range are usually TCP control packets that don’t carry data. Let’s
    consider the typical size of protocol headers. The Ethernet header is 14 bytes
    (plus a 4-byte CRC), the IP header is a minimum of 20 bytes, and a TCP packet
    with no data or options is also 20 bytes. This means that standard TCP control
    packets—such as SYN, ACK, RST, and FIN packets—will be around 54 bytes and fall
    in this range. Of course, the addition of IP or TCP options will increase this
    size. We’ll dig into IP and TCP in [Chapters 7](ch07.xhtml#ch07) and [8](ch08.xhtml#ch08),
    respectively.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的大多数数据包（33.44%）的长度在40到79字节之间。这个范围内的数据包通常是TCP控制数据包，不携带数据。让我们考虑一下协议头的典型大小。以太网头部是14字节（加上4字节的CRC），IP头部至少是20字节，且一个没有数据或选项的TCP数据包也是20字节。这意味着标准的TCP控制数据包——如SYN、ACK、RST和FIN数据包——大约是54字节，符合这个范围。当然，IP或TCP选项的加入会增加这个大小。我们将在[第7章](ch07.xhtml#ch07)和[第8章](ch08.xhtml#ch08)中深入讨论IP和TCP。
- en: Examining packet lengths is a great way to get a bird’s-eye view of a large
    capture. If there are a lot of large packets, it may be safe to assume that data
    is being transferred. If the majority of packets are small, indicating that not
    much data is being passed, you may assume that the capture consists of protocol
    control commands. These are not hard-and-fast rules, but making such assumptions
    is helpful before diving deeper.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 检查数据包长度是快速查看大型捕获的好方法。如果有很多大数据包，可以假设正在传输数据。如果大多数数据包较小，说明传输的数据量不多，可以推测捕获的数据主要是协议控制命令。这些并不是硬性规则，但在深入分析之前做出这样的假设会很有帮助。
- en: '**Graphing**'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**绘制图表**'
- en: Graphs are the bread and butter of analysis and one of the best ways to get
    a summary overview of a data set. Wireshark includes several graphing features
    to assist in understanding capture data, the first of which are its IO graphing
    capabilities.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图表是分析的基础，是获得数据集概览的最佳方式之一。Wireshark包括了多个图表功能来帮助理解捕获的数据，其中最重要的功能之一就是它的IO图表功能。
- en: '***Viewing IO Graphs***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看IO图表***'
- en: '*download-fast.pcapng, download-slow.pcapng, http_espn.pcapng*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*download-fast.pcapng, download-slow.pcapng, http_espn.pcapng*'
- en: Wireshark’s IO Graph window allows you to graph the throughput of data on a
    network. You can use such graphs to find spikes and lulls in data throughput,
    discover performance lags in individual protocols, and compare simultaneous data
    streams.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark的IO图表窗口允许你绘制网络上数据的吞吐量。你可以使用这些图表来查找数据吞吐量的峰值和低谷，发现单个协议中的性能滞后，或比较同时进行的数据流。
- en: To view an example of the IO graph of a computer as it downloads a file from
    the internet, open *download-fast.pcapng*. Click any TCP packet to highlight it
    and then select **Statistics** ▶ **IO Graph**.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看计算机从互联网下载文件时的IO图表示例，请打开*download-fast.pcapng*。点击任何TCP数据包以突出显示它，然后选择**统计**
    ▶ **IO图表**。
- en: The IO Graph window shows a graphical view of the flow of data over time. In
    the example in [Figure 5-17](ch05.xhtml#ch05fig17), you can see that the download
    this graph represents averages around 500 packets per second and stays somewhat
    consistent throughout its duration before tapering off at the end.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: IO图表窗口显示了数据流随时间变化的图形视图。在[图 5-17](ch05.xhtml#ch05fig17)的例子中，你可以看到这个图表所代表的下载平均约为每秒500个数据包，并且在下载的过程中保持相对一致，直到最后有所下降。
- en: '![image](../images/f95-01.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f95-01.jpg)'
- en: '*Figure 5-17: The IO graph of the fast download is mostly consistent.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-17：快速下载的IO图表大致一致。*'
- en: Let’s compare this to an example of a slower download. Leaving the current file
    open, open *download-slow.pcapng* in another instance of Wireshark. Bring up the
    IO graph of this download, and you’ll see a much different story, as shown in
    [Figure 5-18](ch05.xhtml#ch05fig18).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其与一个下载速度较慢的例子进行比较。在保持当前文件打开的情况下，在另一个Wireshark实例中打开*download-slow.pcapng*。调出该下载的IO图表，你会看到一个完全不同的情况，如[图
    5-18](ch05.xhtml#ch05fig18)所示。
- en: '![image](../images/f96-01.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f96-01.jpg)'
- en: '*Figure 5-18: The IO graph of the slow download is not consistent at all.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-18：慢速下载的IO图表完全不一致。*'
- en: This download has a transfer rate between 0 and 100 packets per second, and
    its rate is far from consistent, sometimes nearing 0 packets per second. You can
    see these inconsistencies more clearly if you place the IO graphs of the two files
    next to each other (see [Figure 5-19](ch05.xhtml#ch05fig19)). When comparing two
    graphs, pay attention to the x-and y-axis values to ensure that you’re comparing
    apples to apples. The scale will automatically adjust based on the number of packets
    and/or data transmitted, which is a key difference between the two graphs in [Figure
    5-19](ch05.xhtml#ch05fig19). The slower download shows a scale between 0 and 100
    packets per second, while the faster download’s scale has a range of 0 to 700
    packets per second.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个下载的传输速率介于每秒0到100个数据包之间，并且其速率远远不一致，有时接近每秒0个数据包。如果你将这两个文件的IO图表并排放置（见[图 5-19](ch05.xhtml#ch05fig19)），你可以更清楚地看到这些不一致性。在比较两个图表时，请注意x轴和y轴的数值，以确保你在做公平的比较。图表的比例会根据数据包的数量和/或传输的数据量自动调整，这是[图
    5-19](ch05.xhtml#ch05fig19)中两个图表的一个重要区别。较慢的下载显示的比例在每秒0到100个数据包之间，而较快的下载比例则在每秒0到700个数据包之间。
- en: '![image](../images/f96-02.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f96-02.jpg)'
- en: '*Figure 5-19: Viewing multiple IO graphs side by side can be helpful in spotting
    variance.*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-19：并排查看多个IO图表有助于发现变化。*'
- en: The configurable options at the bottom of this window allow you to use multiple
    unique filters (using the same syntax as for a display or capture filter) and
    specify display colors for those filters. For instance, you can create filters
    for specific IP addresses and assign unique colors to them to view the variance
    in throughput for each device. Let’s try that out.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口底部的可配置选项允许你使用多个唯一过滤器（使用与显示或捕获过滤器相同的语法），并为这些过滤器指定显示颜色。例如，你可以为特定IP地址创建过滤器，并为其分配独特的颜色，以便查看每个设备的吞吐量差异。我们来试试看。
- en: Open *http_espn.pcapng*, which was captured while a device was visiting the
    ESPN home page. If you look at the Conversations window, you’ll see that the top-talking
    external IP address is 205.234.218.129\. From this, we can deduce that this host
    is likely the primary content provider we are receiving data from when visiting
    *[espn.com](http://espn.com)*. However, there are also several other IPs participating
    in conversations, likely because additional content is being downloaded from external
    content providers and advertisers. We can show the disparity between the direct
    and third-party content delivery using the IO graph shown in [Figure 5-20](ch05.xhtml#ch05fig20).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*http_espn.pcapng*，这是在某设备访问ESPN主页时捕获的。如果你查看“会话”窗口，你会看到最活跃的外部IP地址是205.234.218.129\。由此我们可以推断，当访问*[espn.com](http://espn.com)*时，数据很可能来自于这个主机作为主要内容提供者。然而，还有其他多个IP地址参与会话，这很可能是因为额外的内容是从外部内容提供者和广告商处下载的。我们可以使用[图
    5-20](ch05.xhtml#ch05fig20)中的IO图来展示直接内容和第三方内容交付之间的差异。
- en: '![image](../images/f97-01.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f97-01.jpg)'
- en: '*Figure 5-20: An IO graph showing IO of two separate devices.*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-20：显示两个独立设备IO的IO图。*'
- en: The two filters applied in this chart are represented by the rows on the bottom
    of the IO Graph window. The filter named Top Talker shows IO only for the IP address
    205.234.218.129, our primary content provider. It will graph this value in black
    using the stacked-bar style. The second filter, named Everything Else, will show
    IO for everything in the capture file except for the 205.234.218.129 address and
    thus includes all of the third-party content providers. This value will be graphed
    in red (shown here as the lighter gray) using the stacked bar. Notice that we’ve
    changed the y-axis unit to bytes per second. With these changes applied, it’s
    very easy to see the difference between primary and third-party content providers
    and just how much content is actually from a third-party source. This is a fun
    exercise to repeat on your frequently visited websites and a useful strategy for
    comparing the IO of different network hosts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表中应用的两个过滤器通过IO图窗口底部的行表示。名为“Top Talker”的过滤器仅显示IP地址205.234.218.129（我们的主要内容提供者）的IO流量。它将以堆叠条形图样式用黑色绘制此值。第二个过滤器，名为“Everything
    Else”，将显示捕获文件中除了205.234.218.129地址之外的所有内容，因此包括所有第三方内容提供者。这一数值将以红色（此处为较浅的灰色）使用堆叠条形图绘制。请注意，我们已经将y轴的单位更改为字节/秒。应用这些更改后，轻松看出主要内容提供者和第三方内容提供者之间的差异，并且可以清楚地看到来自第三方源的实际内容量。这是一个有趣的练习，可以在你常访问的网站上重复进行，也是比较不同网络主机IO的有用策略。
- en: '***Round-Trip Time Graphing***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***往返时间图***'
- en: '*download-fast.pcapng*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*download-fast.pcapng*'
- en: Another graphing feature of Wireshark is the ability to view a plot of round-trip
    times for a given capture file. The *round-trip time (RTT)* is the time it takes
    for an acknowledgment to be received for a packet. Effectively, this is the time
    it took your packet to get to its destination and for the acknowledgment of that
    packet to be sent back to you. Analysis of RTTs is often done to find slow points
    or bottlenecks in communication and to determine whether there is any latency.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark的另一个图形功能是能够查看给定捕获文件的往返时间图。*往返时间（RTT）*是接收到数据包确认所需的时间。实际上，这是数据包到达目标并收到该数据包确认后返回给你的时间。RTT分析通常用于查找通信中的慢点或瓶颈，并确定是否存在延迟。
- en: Let’s try out this feature. Open the file *download-fast.pcapng*. View the RTT
    graph of this file by selecting a TCP packet and then choosing **Statistics**
    ▶ **TCP Stream Graphs** ▶ **Round Trip Time Graph**. The RTT graph for *download-fast.pcapng*
    is shown in [Figure 5-21](ch05.xhtml#ch05fig21).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个功能。打开文件*download-fast.pcapng*。通过选择一个TCP数据包，然后选择**统计** ▶ **TCP流图** ▶ **往返时间图**来查看该文件的RTT图。*download-fast.pcapng*的RTT图如[图
    5-21](ch05.xhtml#ch05fig21)所示。
- en: '![image](../images/f98-01.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f98-01.jpg)'
- en: '*Figure 5-21: The RTT graph of the fast download appears mostly consistent,
    with only a few stray values.*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-21：快速下载的RTT图表看起来大部分保持一致，只有少数偏离值。*'
- en: Each point in the graph represents the RTT of a packet. The default view shows
    these values sorted by sequence number. You can click a plotted point within the
    graph to be taken directly to that packet in the Packet List pane.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的每个点表示一个包的RTT。默认视图将这些值按序列号排序。你可以点击图表中的某个点，直接跳转到“数据包列表”面板中的对应包。
- en: '**NOTE**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The RTT graph is unidirectional, so it’s important to select the proper direction
    of the traffic you’d like to analyze. If your graph doesn’t look like the one
    in [Figure 5-21](ch05.xhtml#ch05fig21), you might need to click the Switch Direction
    button twice.*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*RTT图是单向的，因此选择正确的流量方向非常重要。如果你的图表看起来不像[图5-21](ch05.xhtml#ch05fig21)中的图形，你可能需要点击“切换方向”按钮两次。*'
- en: It appears as though the RTT graph for the fast download has RTT values mostly
    under 0.05 seconds, with a few slower points between 0.10 and 0.25 seconds. Although
    there are quite a few higher values, the majority of the RTT values are okay,
    so this would be considered an acceptable RTT for a file download. When examining
    the RTT graph for throughput issues, you want to look for high latency times,
    which are indicated by multiple points plotted at higher y-axis values.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来快速下载的RTT图表大多数RTT值都在0.05秒以下，只有一些较慢的点位于0.10到0.25秒之间。尽管有相当多的较高值，但大多数RTT值都还可以，因此这将被认为是一个可接受的文件下载RTT。当检查吞吐量问题的RTT图时，应该寻找高延迟时间，这些高延迟时间通过在y轴较高位置绘制多个点来表示。
- en: '***Flow Graphing***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***流量图***'
- en: '*dns_recursivequery_server.pcapng*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*dns_recursivequery_server.pcapng*'
- en: The flow graph feature is useful for visualizing connections and showing the
    flow of data over time, information that makes it easier to understand how devices
    are communicating. A flow graph contains a column-based view of a connection between
    hosts and organizes the traffic so you can interpret it visually.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 流量图功能对于可视化连接和展示随时间变化的数据流非常有用，这些信息使得理解设备之间如何通信变得更加容易。流量图包含一个基于列的连接视图，并组织流量数据，以便可以通过视觉方式进行解读。
- en: To create a flow graph, open the file *dns_recursivequery_server.pcapng* and
    select **Statistics** ▶ **Flow Graph**. The resulting graph is shown in [Figure
    5-22](ch05.xhtml#ch05fig22).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建流量图，请打开文件 *dns_recursivequery_server.pcapng*，然后选择 **统计信息** ▶ **流量图**。生成的图表显示在[图5-22](ch05.xhtml#ch05fig22)中。
- en: '![image](../images/f99-01.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f99-01.jpg)'
- en: '*Figure 5-22: The TCP flow graph allows us to visualize the connection much
    better.*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-22：TCP流量图让我们能更好地可视化连接。*'
- en: This flow graph is a recursive DNS query, which is a DNS query that is received
    by one host and forwarded to another (we’ll cover DNS in [Chapter 9](ch09.xhtml#ch09)).
    Each vertical line in the graph represents an individual host. The flow graph
    is a great way to visualize back-and-forth communication between two devices or,
    as in this example, the relationship between the communication of multiple devices.
    It’s also useful for understanding the normal flow of communication with protocols
    that you are less experienced with.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流量图是一个递归DNS查询，它是由一个主机接收并转发到另一个主机的DNS查询（我们将在[第9章](ch09.xhtml#ch09)中讲解DNS）。图中的每一条垂直线表示一个独立的主机。流量图是可视化两个设备之间来回通信的好方法，或者像本例中一样，展示多个设备之间的通信关系。它对于理解与不太熟悉的协议的正常通信流动也非常有用。
- en: '**Expert Information**'
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**专家信息**'
- en: '*download-slow.pcapng*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*download-slow.pcapng*'
- en: The dissectors for each protocol in Wireshark define *expert info* that can
    be used to alert you about particular states within packets of that protocol.
    These states are separated into four categories.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark中每个协议的解析器定义了*专家信息*，该信息可用于提醒你协议包中的特定状态。这些状态被分为四类。
- en: '**Chat**   Basic information about the communication'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**聊天** 基本的通信信息'
- en: '**Note**   Unusual packets that may be part of normal communication'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** 可能属于正常通信的异常包'
- en: '**Warning**   Unusual packets that are most likely not part of normal communication'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告** 可能不属于正常通信的异常包'
- en: '**Error**   An error in a packet or the dissector interpreting it'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误** 包中的错误或解析器在解释它时的错误'
- en: For example, open the file *download-slow.pcapng*. Then click **Analyze** and
    select **Expert Information** to bring up the Expert Information window. Once
    there, deselect Group by summary to organize the output by severity (see [Figure
    5-23](ch05.xhtml#ch05fig23)).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，打开文件 *download-slow.pcapng*，然后点击 **分析** 并选择 **专家信息**，以调出专家信息窗口。在此窗口中，取消选择按总结分组，按严重性整理输出（参见
    [图 5-23](ch05.xhtml#ch05fig23)）。
- en: '![image](../images/f100-01.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f100-01.jpg)'
- en: '*Figure 5-23: The Expert Information window shows information from the expert
    system programmed within the protocol dissectors.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-23：专家信息窗口显示协议解剖器中编程的专家系统信息。*'
- en: The window has sections for each classification of information. Here there are
    no errors, 3 warnings, 19 notes, and 3 chats.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口包含针对每种信息分类的部分。此处没有错误，3 条警告，19 条提示信息，和 3 条聊天信息。
- en: Most of the messages within this capture file are TCP related, simply because
    the expert information system has traditionally been most used with that protocol.
    At this time, there are 29 expert info messages configured for TCP, and they will
    be useful when you are troubleshooting capture files. These messages will flag
    an individual packet when it meets certain criteria, as listed below. (The meaning
    of these messages will become clearer as we study TCP in [Chapter 8](ch08.xhtml#ch08)
    and troubleshooting slow networks in [Chapter 11](ch11.xhtml#ch11).)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该捕获文件中的大部分信息都与 TCP 相关，这是因为专家信息系统传统上主要与该协议配合使用。目前，为 TCP 配置了 29 条专家信息消息，在排查捕获文件时非常有用。当某个数据包满足特定条件时，这些消息将标记该数据包，条件如下所列。（随着我们在
    [第 8 章](ch08.xhtml#ch08) 研究 TCP 和在 [第 11 章](ch11.xhtml#ch11) 排查慢速网络时，这些消息的含义将变得更加清晰。）
- en: '**Chat Messages**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**聊天信息**'
- en: '*Window Update*   Sent by a receiver to notify a sender that the size of the
    TCP receive window has changed.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*窗口更新* 接收方发送给发送方，通知其 TCP 接收窗口大小已发生变化。'
- en: '**Note Messages**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示信息**'
- en: '*TCP Retransmission*   Results from packet loss. Occurs when a duplicate ACK
    is received or the retransmission timer of a packet expires.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*TCP 重传* 由于数据包丢失导致。当收到重复的 ACK 或数据包的重传计时器到期时，发生重传。'
- en: '*Duplicate ACK*   When a host doesn’t receive the next sequence number it is
    expecting, it generates a duplicate ACK of the last data it received.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*重复的 ACK* 当主机未收到期望的下一个序列号时，它会生成一个重复的 ACK，确认最后接收到的数据。'
- en: '*Zero Window Probe*   Monitors the status of the TCP receive window after a
    zero window packet has been transmitted (covered in [Chapter 11](ch11.xhtml#ch11)).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*零窗口探测* 在发送零窗口数据包后，监控 TCP 接收窗口的状态（详见 [第 11 章](ch11.xhtml#ch11)）。'
- en: '*Keep Alive ACK*   Sent in response to keep-alive packets.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*保持连接 ACK* 响应保持连接数据包时发送的 ACK。'
- en: '*Zero Window Probe ACK*   Sent in response to zero-window-probe packets.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*零窗口探测 ACK* 响应零窗口探测数据包时发送的 ACK。'
- en: '*Window Is Full*   Notifies a transmitting host that the receiver’s TCP receive
    window is full.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*窗口已满* 通知发送方接收方的 TCP 接收窗口已满。'
- en: '**Warning Messages**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告信息**'
- en: '*Previous Segment Lost*   Indicates packet loss. Occurs when an expected sequence
    number in a data stream is skipped.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*丢失的前一个段* 表示数据包丢失。当数据流中期望的序列号被跳过时发生。'
- en: '*ACKed Lost Packet*   Occurs when an ACK packet is seen but the packet it is
    acknowledging is not.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*确认丢失的数据包* 当看到一个 ACK 数据包，但它所确认的数据包未出现时，发生此情况。'
- en: '*Keep Alive*   Triggered when a connection keep-alive packet is seen.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*保持连接* 当检测到连接保持活动包时触发。'
- en: '*Zero Window*   Seen when the size of the TCP receive window is reached and
    a zero window notice is sent out, requesting that the sender stop sending data.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*零窗口* 当 TCP 接收窗口大小已满并发送零窗口通知，请求发送方停止发送数据时，出现该信息。'
- en: '*Out-of-Order*   Utilizes sequence numbers to detect when packets are received
    out of sequence.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*乱序* 利用序列号检测数据包是否乱序接收。'
- en: '*Fast Retransmission*   A retransmission that occurs within 20 milliseconds
    of a duplicate ACK.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*快速重传* 在收到重复的 ACK 后 20 毫秒内发生的重传。'
- en: '**Error Messages**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误信息**'
- en: '*No Error Messages*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*没有错误信息*'
- en: Although some of the features discussed in this chapter may seem as if they
    would be used only in obscure situations, you will probably find yourself using
    them more than you might expect. It’s important that you familiarize yourself
    with these windows and options; I will be referencing them a lot in the next few
    chapters.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章讨论的某些特性可能看起来仅在特定情况下使用，但你可能会发现自己比预期更频繁地使用它们。熟悉这些窗口和选项非常重要；在接下来的几章中，我会频繁提到它们。
