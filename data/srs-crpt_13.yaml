- en: '12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '12'
- en: ELLIPTIC CURVES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: The introduction of *elliptic curve cryptography (ECC)* in 1985 revolutionized
    the way we do public-key cryptography. ECC is more powerful and efficient than
    alternatives like RSA and classical Diffie–Hellman (ECC with a 256-bit key is
    stronger than RSA with a 4096-bit key), but it’s also more complex.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 1985年引入的*椭圆曲线密码学（ECC）*彻底改变了我们进行公钥密码学的方法。与RSA和经典的Diffie–Hellman等替代方案相比，ECC更强大且高效（例如，使用256位密钥的ECC比使用4096位密钥的RSA更强大），但它也更复杂。
- en: Like RSA, ECC multiplies large numbers, but unlike RSA it does so in order to
    combine points on a mathematical curve, called an *elliptic curve* (which has
    nothing to do with an ellipse, by the way). To complicate matters, there are many
    different types of elliptic curves—simple and sophisticated ones, efficient and
    inefficient ones, and secure and insecure ones.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 像RSA一样，ECC通过乘法运算处理大数字，但不同于RSA，它是通过在数学曲线上结合点来完成的，这条曲线叫做*椭圆曲线*（顺便说一下，它与椭圆无关）。更复杂的是，椭圆曲线有很多不同类型——简单的和复杂的，高效的和低效的，安全的和不安全的。
- en: 'Although first introduced in 1985, ECC wasn’t adopted by standardization bodies
    until the early 2000s, and it wasn’t seen in major toolkits until much later:
    OpenSSL added ECC in 2005, and the OpenSSH secure connectivity tool waited until
    2011\. But modern systems have few reasons not to use ECC, and you’ll find it
    used in Bitcoin and many security components in Apple devices. Indeed, elliptic
    curves allow you to perform common public-key cryptography operations such as
    encryption, signature, and key agreement faster than their classical counterparts.
    Most cryptographic applications that rely on the discrete logarithm problem (DLP)
    will also work when based on its elliptic curve counterpart, ECDLP, with one notable
    exception: the Secure Remote Password (SRP) protocol.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管椭圆曲线密码学（ECC）在1985年首次被提出，但直到2000年代初，标准化组织才开始采纳它，并且直到更晚的时候，主要工具包才开始支持：OpenSSL在2005年添加了ECC，而OpenSSH安全连接工具则等到2011年才支持ECC。但现代系统几乎没有理由不使用ECC，你会在比特币和许多苹果设备的安全组件中看到它。实际上，椭圆曲线使你能够比传统算法更快地执行常见的公钥密码学操作，如加密、签名和密钥协商。大多数依赖离散对数问题（DLP）的加密应用在基于其椭圆曲线对手ECDLP时也能正常工作，唯一的显著例外是：安全远程密码（SRP）协议。
- en: This chapter focuses on applications of ECC and discusses why you would use
    ECC rather than RSA or classical Diffie–Hellman, as well as how to choose the
    right elliptic curve for your application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍ECC的应用，并讨论为什么选择ECC而不是RSA或经典的Diffie–Hellman，以及如何为你的应用选择合适的椭圆曲线。
- en: What Is an Elliptic Curve?
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是椭圆曲线？
- en: An elliptic curve is a *curve* on a plane—a group of points with *x* and *y*
    coordinates. A curve’s equation defines all the points that belong to that curve.
    For example, the curve *y* = 3 is a horizontal line with the vertical coordinate
    3, curves of the form *y* = *ax* + *b* with fixed numbers *a* and *b* are straight
    lines, *x*² + *y*² = 1 is a circle of radius 1 centered on the origin, and so
    on. Whatever the type of curve, the points on a curve are all (*x*, *y*) pairs
    that satisfy the curve’s equation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线是平面上的一条*曲线*——一组具有*x*和*y*坐标的点。曲线的方程定义了所有属于该曲线的点。例如，曲线*y* = 3是一个横坐标为3的水平线，形式为*y*
    = *ax* + *b*的曲线是直线，*x*² + *y*² = 1是一个半径为1、以原点为中心的圆，依此类推。无论曲线的类型如何，曲线上的点都是满足曲线方程的(*x*,
    *y*)对。
- en: An elliptic curve as used in cryptography is typically a curve whose equation
    is of the form *y*² = *x*³ + *ax* + *b* (known as the *Weierstrass form*), where
    the constants *a* and *b* define the shape of the curve. For example, [Figure
    12-1](ch12.xhtml#ch12fig1) shows the elliptic curve that satisfies the equation
    *y*² = *x*³ – 4*x*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 用于加密的椭圆曲线通常是其方程形式为*y*² = *x*³ + *ax* + *b*（即*魏尔斯特拉斯形式*），其中常数*a*和*b*定义了曲线的形状。例如，[图12-1](ch12.xhtml#ch12fig1)展示了满足方程*y*²
    = *x*³ – 4*x*的椭圆曲线。
- en: '![image](../images/f12-01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f12-01.jpg)'
- en: '*Figure 12-1: An elliptic curve with the equation y*² = *x*³ – 4*x, shown over
    the real numbers*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1：具有方程y*² = *x*³ – 4*x的椭圆曲线，显示在实数范围内*'
- en: '**NOTE**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this chapter, I focus on the simplest, most common type of elliptic curves—namely,
    those with an equation that looks like* y² = x³ + ax + b—*but there are types
    of elliptic curves with equations in other forms. For example,* Edwards curves
    *are elliptic curves whose equation is of the form* x² + y² = 1 + dx²y². *Edwards
    curves are sometimes used in cryptography (for example, in the Ed25519 scheme)*.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我将重点介绍最简单、最常见的椭圆曲线类型——即其方程类似于* y² = x³ + ax + b——*但也有其他形式的椭圆曲线。例如，*爱德华兹曲线*是方程为*
    x² + y² = 1 + dx²y² 的椭圆曲线。*爱德华兹曲线有时用于密码学（例如，在 Ed25519 方案中）*。'
- en: '[Figure 12-1](ch12.xhtml#ch12fig1) shows all the points that make up the curve
    for *x* between –3 and 4, be they points on the left side of the curve, which
    looks like a circle, or on the right side, which looks like a parabola. All these
    points have (*x*, *y*) coordinates that satisfy the curve’s equation *y*² = *x*³
    – 4*x*. For example, when *x* = 0, then *y*² = *x*³ – 4*x* = 0³ – 4 × 0 = 0; hence,
    *y* = 0 is a solution, and the point (0, 0) belongs to the curve. Likewise, if
    *x* = 2, the solution to the equation is *y* = 0, meaning that the point (2, 0)
    belongs to the curve.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-1](ch12.xhtml#ch12fig1) 显示了组成 *x* 从 -3 到 4 之间曲线的所有点，无论是位于左侧的圆形曲线上的点，还是位于右侧的抛物线曲线上的点。所有这些点的
    (*x*, *y*) 坐标都满足曲线方程 *y*² = *x*³ – 4*x*。例如，当 *x* = 0 时，*y*² = *x*³ – 4*x* = 0³
    – 4 × 0 = 0；因此，*y* = 0 是一个解，点 (0, 0) 属于该曲线。同样地，如果 *x* = 2，方程的解是 *y* = 0，这意味着点
    (2, 0) 属于该曲线。'
- en: It is crucial to distinguish points that belong to the curve from other points,
    because when using elliptic curves for cryptography, we’ll be working with points
    from the curve, and points off the curve often present a security risk. However,
    note that the curve’s equation doesn’t always admit solutions, at least not in
    the natural number plane. For example, to find points with the horizontal coordinate
    *x* = 1, we solve *y*² = *x*³ – 4*x* for *y*² with *x*³ – 4*x* = 1³ – 4 × 1, giving
    a result of –3\. But *y*² = –3 doesn’t have a solution because there is no number
    for which *y*² = –3\. (There is a solution in the complex numbers, but elliptic
    curve cryptography will only deal with natural numbers—more precisely, integers
    modulo a prime.) Because there is no solution to the curve’s equation for *x*
    = 1, the curve has no point at that position on the x-axis, as you can see in
    [Figure 12-1](ch12.xhtml#ch12fig1).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 区分属于曲线的点和其他点非常重要，因为在使用椭圆曲线进行密码学时，我们将使用来自曲线的点，而曲线外的点往往会带来安全风险。然而，请注意，曲线的方程并不总是有解，至少在自然数平面中没有解。例如，要找到横坐标为
    *x* = 1 的点，我们需要解 *y*² = *x*³ – 4*x*，对于 *x*³ – 4*x* = 1³ – 4 × 1，结果为 –3。但 *y*²
    = –3 没有解，因为没有一个数满足 *y*² = –3。（在复数中有解，但椭圆曲线密码学只处理自然数——更准确地说，是模素数的整数。）因为曲线方程在 *x*
    = 1 时没有解，所以在 x 轴上该位置没有点，如图 [12-1](ch12.xhtml#ch12fig1) 所示。
- en: What if we try to solve for *x* = –1? In this case, we get the equation *y*²
    = –1 + 4 = 3, which has two solutions (*y* = √3 and *y* = –√3), the square root
    of three and its negative value. Squaring a number always gives a positive number,
    so *y*² = (–*y*)² for any real number *y*, and as you can see, the curve in [Figure
    12-1](ch12.xhtml#ch12fig1) is symmetric with respect to the x-axis for all points
    that solve its equation (as are all elliptic curves of the form *y*² = *x*³ +
    *ax* + *b*).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试求解 *x* = –1 呢？在这种情况下，我们得到方程 *y*² = –1 + 4 = 3，方程有两个解（*y* = √3 和 *y* =
    –√3），即三的平方根及其负值。平方一个数总是得到一个正数，因此对于任何实数 *y*，都有 *y*² = (–*y*)²，正如你所看到的，图 [12-1](ch12.xhtml#ch12fig1)
    中的曲线对于所有解其方程的点相对于 x 轴是对称的（所有形式为 *y*² = *x*³ + *ax* + *b* 的椭圆曲线都是如此）。
- en: '*Elliptic Curves over Integers*'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*整数上的椭圆曲线*'
- en: 'Now here’s a bit of a twist: the curves used in elliptic curve cryptography
    actually don’t look like the curve shown in [Figure 12-1](ch12.xhtml#ch12fig1).
    They look instead like [Figure 12-2](ch12.xhtml#ch12fig2), which is a cloud of
    points rather than a curve. What’s going on here?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，稍微有点意外：在椭圆曲线密码学中使用的曲线实际上看起来并不像图 [12-1](ch12.xhtml#ch12fig1) 中所示的曲线。它们更像是
    [图 12-2](ch12.xhtml#ch12fig2)，这是一团点而不是曲线。这是怎么回事呢？
- en: '[Figures 12-1](ch12.xhtml#ch12fig1) and [12-2](ch12.xhtml#ch12fig2) are actually
    based on the same curve equation, *y*² = *x*³ – 4*x*, but they show the curve’s
    points with respect to different sets of numbers: [Figure 12-1](ch12.xhtml#ch12fig1)
    shows the curve’s points over the set of *real numbers*, which includes negative
    numbers, decimals, and so on. For example, as a continuous curve, it shows the
    points at *x* = 2.0, *x* = 2.1, *x* = 2.00002, and so on. [Figure 12-2](ch12.xhtml#ch12fig2),
    on the other hand, shows only *integers* that satisfy this equation, which excludes
    decimal numbers. Specifically, [Figure 12-2](ch12.xhtml#ch12fig2) shows the curve
    *y*² = *x*³ – 4*x* with respect to the integers *modulo 191*: 0, 1, 2, 3, up to
    190\. This set of numbers is denoted **Z**[191]. (There’s nothing special with
    191 here, except that it’s a prime number. I picked a small number to avoid having
    too many points on the graph.) The points shown on [Figure 12-2](ch12.xhtml#ch12fig2)
    therefore all have *x* and *y* coordinates that are integers modulo 191 and that
    satisfy the equation *y*² = *x*³ – 4*x*. For example, for *x* = 2, we have *y*²
    = 0, for which *y* = 0 is a valid solution. This tells us that the point (2, 0)
    belongs to the curve.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-1](ch12.xhtml#ch12fig1) 和 [12-2](ch12.xhtml#ch12fig2) 实际上是基于相同的曲线方程 *y*²
    = *x*³ – 4*x*，但它们显示的是相对于不同数集的曲线点：[图 12-1](ch12.xhtml#ch12fig1) 显示的是实数集上的曲线点，其中包括负数、小数等。例如，作为连续曲线，它显示了
    *x* = 2.0、*x* = 2.1、*x* = 2.00002 等点。另一方面，[图 12-2](ch12.xhtml#ch12fig2) 只显示满足该方程的
    *整数*，这排除了小数。例如，[图 12-2](ch12.xhtml#ch12fig2) 显示的是方程 *y*² = *x*³ – 4*x* 相对于模 191
    的整数：0, 1, 2, 3，一直到 190。这个数集被表示为 **Z**[191]。（这里没有特别之处，除非 191 是一个质数。我选了一个小数字，以避免图表上出现太多点。）因此，[图
    12-2](ch12.xhtml#ch12fig2) 上显示的所有点都有满足方程 *y*² = *x*³ – 4*x* 的整数坐标 *x* 和 *y*，且这些坐标是模
    191 的整数。例如，当 *x* = 2 时，*y*² = 0，*y* = 0 是一个有效解。这告诉我们点 (2, 0) 属于该曲线。'
- en: '![image](../images/f12-02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f12-02.jpg)'
- en: '*Figure 12-2: The elliptic curve with the equation* y² = x³ – 4*x over **Z**[191],
    the set of integers modulo 191*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-2：方程 y² = x³ – 4*x 在 **Z**[191] 上的椭圆曲线，**Z**[191] 是模 191 的整数集合*'
- en: What if *x* = 3? We get the equation *y*² = 27 – 12 = 15, which admits two solutions
    to *y*² = 15 (namely, 46 and 145), because 46² mod 191 = 15 and 145² mod 191 =
    15 both equal 15 in **Z**[191]. Thus, the points (3, 46) and (3, 145) belong to
    the curve and appear as shown in [Figure 12-2](ch12.xhtml#ch12fig2) (the two points
    highlighted at the left).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *x* = 3 会怎么样？我们得到方程 *y*² = 27 – 12 = 15，这个方程有两个解 *y*² = 15（即 46 和 145），因为
    46² mod 191 = 15 和 145² mod 191 = 15 都等于 15，属于 **Z**[191]。因此，点 (3, 46) 和 (3, 145)
    属于该曲线，并如 [图 12-2](ch12.xhtml#ch12fig2) 所示（左侧突出显示的两个点）。
- en: '**NOTE**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*[Figure 12-2](ch12.xhtml#ch12fig2) considers points from the set denoted **Z***[191]
    = *{0, 1, 2, … , 190}, which includes zero. This differs from the groups denoted
    **Z***[p]^* *(with a star superscript) that we discussed in the context of RSA
    and Diffie–Hellman. The reason for this difference is that we’ll both multiply
    and add numbers, and we therefore need to ensure that the set of numbers includes
    addition’s identity element (namely 0, such that* x + 0 = x *for every* x *in
    **Z***[191]). *Also, every number x has an inverse with respect to addition, denoted*
    –x, *such that* x + (–x) = 0\. *For example, the inverse of 100 in **Z***[191]
    *is 91, because 100 + 91 mod 191 = 0\. Such a set of numbers, where addition and
    multiplication are possible and where each element* x *admits an inverse with
    respect to addition (denoted* –x) *as well as an inverse with respect to multiplication
    (denoted 1* / x), *is called a* field. *When a field has a finite number of elements,
    as in **Z***[191] *and as with all fields used for elliptic curve cryptography,
    it is called a* finite field.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*[图 12-2](ch12.xhtml#ch12fig2) 考虑的是来自集合 **Z**[191] = *{0, 1, 2, … , 190} 的点，这个集合包括零。这与我们在讨论
    RSA 和 Diffie-Hellman 时提到的带星号上标的 **Z**[p]^*（星号上标）集合不同。之所以有这种差异，是因为我们将进行加法和乘法运算，因此需要确保数集包含加法的单位元素（即
    0，确保 *x + 0 = x* 对于 **Z**[191] 中的每个 *x*）。*此外，每个数字 *x* 都有一个相对于加法的逆元，记作 *–x*，使得
    *x + (–x) = 0*。例如，100 在 **Z**[191] 中的逆元是 91，因为 100 + 91 mod 191 = 0。这样的数集，其中加法和乘法都可行，并且每个元素
    *x* 都有一个相对于加法的逆元（记作 *–x*）以及一个相对于乘法的逆元（记作 1* / x），被称为一个*域*。当一个域有有限个元素时，如 **Z**[191]，并且所有用于椭圆曲线加密的域都是如此，它被称为一个*有限域*。'
- en: '*Adding and Multiplying Points*'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*添加和乘法运算*'
- en: We’ve seen that the points on an elliptic curve are all coordinates (*x*, *y*)
    that satisfy the curve’s equation, *y*² = *x*³ + *ax* + *b*. In this section,
    we look at how to add elliptic curve points, a rule called the *addition law*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，椭圆曲线上的点都是满足曲线方程 *y*² = *x*³ + *ax* + *b* 的坐标 (*x*, *y*)。在本节中，我们将讨论如何加椭圆曲线上的点，这条规则称为
    *加法定律*。
- en: Adding Two Points
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 加法两个点
- en: 'Say that we want to add two points on the elliptic curve, *P* and *Q*, to give
    a new point, *R*, that is the sum of these two points. The simplest way to understand
    point addition is to determine the position of *R* = *P* + *Q* on the curve relative
    to *P* and *Q* based on a geometric rule: draw the line that connects *P* and
    *Q*, find the other point of the curve that intersects with this line, and *Q*
    is the reflection of this point with respect to the x-axis. For example, in [Figure
    12-3](ch12.xhtml#ch12fig3), the line connecting *P* and *Q* intersects the curve
    at a third point between *P* and *Q*, and the point *P* + *Q* is the point at
    the same *x* coordinate but the inverse *y* coordinate.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要将椭圆曲线上的两点 *P* 和 *Q* 相加，得到一个新的点 *R*，它是这两点的和。理解点加法的最简单方法是根据几何规则确定 *R* = *P*
    + *Q* 在曲线上相对于 *P* 和 *Q* 的位置：画出连接 *P* 和 *Q* 的直线，找到这条直线与曲线相交的另一个点，并且 *Q* 是该点关于 x
    轴的反射。例如，在[图 12-3](ch12.xhtml#ch12fig3)中，连接 *P* 和 *Q* 的直线与曲线相交于 *P* 和 *Q* 之间的第三个点，点
    *P* + *Q* 是与之具有相同 *x* 坐标，但 *y* 坐标相反的点。
- en: '![image](../images/f12-03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f12-03.jpg)'
- en: '*Figure 12-3: A general case of the geometric rule for adding points over an
    elliptic curve*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-3：在椭圆曲线上加点的一般几何规则*'
- en: This geometric rule is simple, but it won’t directly give you the coordinates
    of the point *R*. We compute the coordinates (*x*[*R*], *y*[*R*]) of *R* using
    the coordinates (*x*[*P*] , *y*[*P*]) of *P* and the coordinates (*x*[*Q*], *y*[*Q*])
    of *Q* using the formulas *x*[*R*] = *m*² – *x*[*P*] – *x*[*Q*] and *y*[*R*] *=
    m(x*[*P*] – *x*[*R*]) – *y*[*P*] , where the value *m* = (*y*[*Q*] – *y*[*P*])
    / (*x*[*Q*] – *x*[*P*]) is the slope of the line connecting *P* and *Q*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个几何规则很简单，但它不会直接给出点 *R* 的坐标。我们使用点 *P* 的坐标 (*x*[*P*], *y*[*P*]) 和点 *Q* 的坐标 (*x*[*Q*],
    *y*[*Q*])，通过公式 *x*[*R*] = *m*² – *x*[*P*] – *x*[*Q*] 和 *y*[*R*] = *m*( *x*[*P*]
    – *x*[*R*]) – *y*[*P*]，计算点 *R* 的坐标 (*x*[*R*], *y*[*R*])，其中 *m* = (*y*[*Q*] – *y*[*P*])
    / (*x*[*Q*] – *x*[*P*]) 是连接点 *P* 和 *Q* 的直线的斜率。
- en: Unfortunately, these formulas and the line-drawing trick shown in [Figure 12-3](ch12.xhtml#ch12fig3)
    don’t always work. If, for example, *P* = *Q*, you can’t draw a line between two
    points (there’s only one), and if *P* = –*P*, the line doesn’t cross the curve
    again, so there is no point on the curve to mirror. We’ll explore these in the
    next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些公式以及[图 12-3](ch12.xhtml#ch12fig3)中展示的画线技巧并不总是有效。例如，如果 *P* = *Q*，你无法在两点之间画一条直线（只有一条），而且如果
    *P* = –*P*，这条线不会再次穿过曲线，因此没有与曲线相交的点可以进行镜像反射。我们将在下一节探讨这些情况。
- en: Adding a Point and Its Negative
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 加点与其负点
- en: The negative of a point *P* = (*x*[*P*] , *y*[*P*]) is the point –*P* = (*x*[*P*]
    , –*y*[*P*]), which is the point mirrored around the x-axis. For any *P*, we say
    that *P* + (–*P*) = *O*, where *O* is called the *point at infinity*. And as you
    can see in [Figure 12-4](ch12.xhtml#ch12fig4), the line between *P* and –*P* runs
    to infinity and never intersects the curve. (The point at infinity is a virtual
    point that belongs to any elliptic curve; it is to elliptic curves what zero is
    to integers.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 点 *P* = (*x*[*P*], *y*[*P*]) 的负点是点 –*P* = (*x*[*P*], –*y*[*P*])，即关于 x 轴对称的点。对于任何点
    *P*，我们有 *P* + (–*P*) = *O*，其中 *O* 称为 *无穷远点*。如[图 12-4](ch12.xhtml#ch12fig4)所示，点
    *P* 和 –*P* 之间的直线延伸至无穷大，并且永远不会与曲线相交。（无穷远点是一个虚拟点，属于任何椭圆曲线；它对于椭圆曲线的意义就像零对于整数的意义。）
- en: '![image](../images/f12-04.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f12-04.jpg)'
- en: '*Figure 12-4: The geometric rule for adding points on an elliptic curve with
    the operation* P + (–P) = O *when the line between the points never intersects
    the curve*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-4：在椭圆曲线上加点的几何规则，操作为* P + (–P) = O *当连接点的直线永远不会与曲线相交时*'
- en: Doubling a Point
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 点的倍加
- en: When *P* = *Q* (that is, *P* and *Q* are at the same position), adding *P* and
    *Q* is equivalent to computing *P* + *P*, also denoted 2*P*. This addition operation
    is therefore called a *doubling*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *P* = *Q*（即 *P* 和 *Q* 处于相同的位置）时，*P* 和 *Q* 的相加等价于计算 *P* + *P*，也表示为 2*P*。因此，这个加法运算称为
    *倍加*。
- en: However, to find the coordinates of the result *R* = 2*P*, we can’t use the
    geometric rule from the previous section, because we can’t draw a line between
    *P* and itself. Instead, we draw the line *tangent* to the curve at *P*, and *2P*
    is the negation of the point where this line intersects the curve, as shown on
    [Figure 12-5](ch12.xhtml#ch12fig5).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要找出结果 *R* = 2*P* 的坐标，我们不能使用前一节的几何规则，因为我们无法画出 *P* 和它自身之间的连线。相反，我们画出一条在 *P*
    处与曲线相切的线，*2P* 是这条线与曲线相交点的对称点，如[图12-5](ch12.xhtml#ch12fig5)所示。
- en: '![image](../images/f12-05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f12-05.jpg)'
- en: '*Figure 12-5: The geometric rule for adding points over an elliptic curve using
    the doubling operation* P + P'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-5：使用加倍操作在椭圆曲线上加法的几何规则* P + P'
- en: The formula for determining the coordinates (*x*[*R*], *y*[*R*]) of *R* = *P*
    + *P* is slightly different from the formula we would use for a distinct *P* and
    *Q*. Again, the basic formula is *x*[*R*] = *m*² – *x*[*P*] – *x*[*Q*] and *y*[*R*]
    = *m*(*x*[*P*] – *x*[*R*]) – *y*[*P*], but the value of *m* is different; it becomes
    (3*x*[*P*]² + *a*) / 2*y*[*P*], where *a* is the curve’s parameter, as in *y*²
    = *x*³ + *ax* + *b*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 用来确定 *R* = *P* + *P* 的坐标 (*x*[*R*]，*y*[*R*]) 的公式与我们用来处理不同的 *P* 和 *Q* 的公式略有不同。同样，基本公式是
    *x*[*R*] = *m*² – *x*[*P*] – *x*[*Q*] 和 *y*[*R*] = *m*(*x*[*P*] – *x*[*R*]) –
    *y*[*P*]，但是 *m* 的值不同；它变为 (3*x*[*P*]² + *a*) / 2*y*[*P*]，其中 *a* 是曲线的参数，如 *y*² =
    *x*³ + *ax* + *b* 中所示。
- en: Multiplication
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 乘法
- en: In order to multiply points on elliptic curves by a given number *k*, where
    *k* is an integer, we determine the point *kP* by adding *P* to itself *k* – 1
    times. In other words, 2*P* = *P* + *P*, 3*P* = *P* + *P* + *P*, and so on. To
    obtain the *x* and *y* coordinates of *kP*, repeatedly add *P* to itself and apply
    the preceding addition law.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过给定的整数 *k* 来乘椭圆曲线上的点，我们通过将 *P* 加到自身 *k* – 1 次来确定点 *kP*。换句话说，2*P* = *P* +
    *P*，3*P* = *P* + *P* + *P*，以此类推。为了获得 *kP* 的 *x* 和 *y* 坐标，我们反复将 *P* 加到自身并应用前述的加法法则。
- en: To compute *kP* efficiently, however, the naive technique of adding *P* by applying
    the addition law *k* – 1 times is far from optimal. For example, if *k* is large
    (of the order of, say, 2^(256)) as it occurs in elliptic curve–based crypto schemes,
    then computing *k* – 1 additions is downright infeasible.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了高效地计算 *kP*，使用通过应用加法法则 *k* – 1 次来加 *P* 的朴素技巧远非最佳。例如，如果 *k* 很大（比如 2^(256)
    级别），如在基于椭圆曲线的加密方案中出现的那样，那么计算 *k* – 1 次加法是完全不可行的。
- en: 'But there’s a trick: you can gain an exponential speed-up by adapting the technique
    discussed in [“Fast Exponentiation Algorithm: Square-and-Multiply”](ch10.xhtml#lev2sec130)
    on page 192 to compute *x*^(*e*) mod *n*. For example, to compute 8*P* in three
    additions instead of seven using the naive method, you would first compute *P*[2]
    = *P* + *P*, then *P*[4] = *P*[2] + *P*[2], and finally *P*[4] + *P*[4] = 8*P*.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个技巧：通过采用在[“快速幂算法：平方加倍”](ch10.xhtml#lev2sec130)第192页讨论的技巧，可以显著加速计算 *x*^(*e*)
    mod *n*。例如，为了用三次加法而不是七次计算8*P*，你首先计算 *P*[2] = *P* + *P*，然后 *P*[4] = *P*[2] + *P*[2]，最后
    *P*[4] + *P*[4] = 8*P*。
- en: '*Elliptic Curve Groups*'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*椭圆曲线群*'
- en: Because points can be added together, the set of points on an elliptic curve
    forms a group. According to the definition of a group (see [“What Is a Group?”](ch09.xhtml#lev2sec121)
    on page 174), if the points *P* and *Q* belong to a given curve, then *P* + *Q*
    also belongs to the curve.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于点可以相加，椭圆曲线上的点集形成一个群。根据群的定义（见[“什么是群？”](ch09.xhtml#lev2sec121)第174页），如果点 *P*
    和 *Q* 属于给定的曲线，那么 *P* + *Q* 也属于该曲线。
- en: Furthermore, because addition is *associative*, we have (*P* + *Q*) + *R* =
    *P* + (*Q* + *R*) for any points *P*, *Q*, and *R*. In a group of elliptic curve
    points, the identity element is called the point at infinity, and denoted *O*,
    such that *P* + *O* = *P* for any *P*. Every point *P* = (*x*[*P*] , *y*[*P*])
    has an inverse, –*P* = (*x*[*P*] , –*y*[*P*]), such that *P* + (–*P*) = *O*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于加法是*结合律*的，我们有 (*P* + *Q*) + *R* = *P* + (*Q* + *R*)，对于任何点 *P*、*Q* 和 *R*
    都成立。在椭圆曲线点的群体中，单位元称为无穷远点，记作 *O*，使得 *P* + *O* = *P* 对于任何 *P* 都成立。每个点 *P* = (*x*[*P*]
    , *y*[*P*]) 都有一个逆元素，–*P* = (*x*[*P*] , –*y*[*P*])，使得 *P* + (–*P*) = *O*。
- en: In practice, most elliptic curve–based cryptosystems work with *x* and *y* coordinates
    that are numbers modulo a prime number, *p* (in other words, numbers in the finite
    field **Z**[*p*]). Just as the security of RSA depends on the size of the numbers
    used, the security of an elliptic curve–based cryptosystem depends on the number
    of points on the curve. But how do we know the number of points on an elliptic
    curve, or its *cardinality*? Well, it depends on the curve and the value of *p*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，大多数基于椭圆曲线的加密系统使用的是模一个质数*p*的*x*和*y*坐标（换句话说，使用的是有限域**Z**[*p*]中的数）。就像RSA的安全性依赖于所用数字的大小一样，基于椭圆曲线的加密系统的安全性也依赖于曲线上的点的数量。但是，我们如何知道椭圆曲线上的点的数量，或者它的*基数*呢？嗯，这取决于曲线和*p*的值。
- en: One rule of thumb is that there are approximately *p* points on the curve, but
    you can compute the exact number of points with Schoof’s algorithm, which counts
    points on elliptic curves over finite fields. You’ll find this algorithm built
    in to SageMath. For example, [Listing 12-1](ch12.xhtml#ch12list1) shows how to
    use this algorithm to count the number of points on the curve *y*² = *x*³ – 4*x*
    over **Z**[191] shown in [Figure 12-1](ch12.xhtml#ch12fig1).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则是，曲线上大约有*p*个点，但你可以使用Schoof算法来计算精确的点数，该算法用于计算有限域上的椭圆曲线的点数。你会发现这个算法已经内置在SageMath中。例如，[列表
    12-1](ch12.xhtml#ch12list1)展示了如何使用该算法计算曲线*y*² = *x*³ – 4*x*上**Z**[191]的点数，具体见[图
    12-1](ch12.xhtml#ch12fig1)。
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 12-1: Computing the cardinality, or number of points on a curve*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-1：计算基数或曲线上的点数*'
- en: In [Listing 12-1](ch12.xhtml#ch12list1), we’ve first defined the variable `Z`
    as the set over integers modulo 191; then we defined the variable `E` as the elliptic
    curve over `Z` with the coefficients –4 and 0\. Finally, we computed the number
    of points on the curve, also known as its *cardinality*, *group* *order*, or just
    *order*. Note that this count includes the point at infinity *O*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 12-1](ch12.xhtml#ch12list1)中，我们首先将变量`Z`定义为模191的整数集合；然后，我们将变量`E`定义为以系数–4和0定义的`Z`上的椭圆曲线。最后，我们计算了曲线上的点的数量，也就是它的*基数*、*群*
    *阶*，或者简称*阶*。请注意，这个计数包括了无穷远的点*O*。
- en: The ECDLP Problem
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ECDLP问题
- en: '[Chapter 9](ch09.xhtml#ch9) introduced the DLP: that of finding the number
    *y* given some base number *g*, where *x* = *g*^(*y*) mod *p* for some large prime
    number *p*. Cryptography with elliptic curves has a similar problem: the problem
    of finding the number *k* given a base point *P* where the point *Q* = *kP*. This
    is called the *elliptic curve discrete logarithm problem*, or *ECDLP*. (Instead
    of numbers, the elliptic curve’s problems operate on points, and multiplication
    is used instead of exponentiation.)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](ch09.xhtml#ch9)介绍了DLP：即给定某个基数*g*，找到数字*y*，使得*x* = *g*^(*y*) mod *p*，其中*p*是一个大的质数。椭圆曲线密码学有一个类似的问题：给定基点*P*，找到数字*k*，使得点*Q*
    = *kP*。这个问题叫做*椭圆曲线离散对数问题*，简称*ECDLP*。（与数字不同，椭圆曲线的问题作用于点，且使用乘法而不是指数运算。）'
- en: All elliptic curve cryptography is built on the ECDLP problem, which, like DLP,
    is believed to be hard and has withstood cryptanalysis since its introduction
    into cryptography in 1985\. One important difference between ECDLP and the classical
    DLP is that ECDLP allows you to work with smaller numbers and still enjoy a similar
    level of security.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所有椭圆曲线密码学都是建立在ECDLP问题上的，这个问题就像DLP一样，被认为是困难的，并且自1985年引入密码学以来经受住了密码分析的考验。ECDLP与经典的DLP之间一个重要的区别是，ECDLP允许使用更小的数字，同时仍然享有类似的安全级别。
- en: Generally, when *p* is *n* bits, you’ll get a security level of about *n*/2
    bits. For example, an elliptic curve taken over numbers modulo *p*, with a 256-bit
    *p*, will give a security level of about 128 bits. For the sake of comparison,
    to achieve a similar security level with DLP or RSA, you would need to use numbers
    of several thousands of bits. The smaller numbers used for ECC arithmetic are
    one reason why it’s often faster than RSA or classical Diffie–Hellman.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当*p*是*n*位时，你会获得大约*n*/2位的安全性。例如，取一个模*p*的椭圆曲线，其中*p*为256位，将提供大约128位的安全性。为了对比，若使用DLP或RSA来实现相似的安全性，你需要使用几千位的数字。ECC算术使用较小的数字，这是它通常比RSA或经典Diffie–Hellman更快的原因之一。
- en: One way of solving ECDLP is to find a collision between two outputs, *c*[1]*P*
    + *d*[1]*Q* and *c*[2]*P* + *d*[2]*Q*. The points *P* and *Q* in these equations
    are such that *Q* = *kP* for some unknown *k*, and *c*[1], *d*[1], *c*[2], and
    *d*[2] are the numbers you will need in order to find *k*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 解决ECDLP的一种方法是找到两个输出之间的碰撞，*c*[1]*P* + *d*[1]*Q* 和 *c*[2]*P* + *d*[2]*Q*。这些方程中的点*P*和*Q*是满足*Q*
    = *kP*（其中*k*为某个未知值）的点，而*c*[1]、*d*[1]、*c*[2]和*d*[2]是你需要的数字，以便找到*k*。
- en: 'As with the hash function discussed in [Chapter 6](ch06.xhtml#ch6), a collision
    occurs when two different inputs produce the same output. Therefore, in order
    to solve ECDLP, we need to find points where the following is true:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第6章](ch06.xhtml#ch6)中讨论的哈希函数类似，当两个不同的输入产生相同的输出时，就会发生碰撞。因此，为了解决ECDLP问题，我们需要找到满足以下条件的点：
- en: '*c*[1]*P* + *d*[1]*Q* = *c*[2]*P* + *d*[2]*Q*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*[1]*P* + *d*[1]*Q* = *c*[2]*P* + *d*[2]*Q*'
- en: 'In order to find these points, we replace *Q* with the value *kP*, and we have
    the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到这些点，我们将*Q*替换为值*kP*，得到以下结果：
- en: '*c*[1]*P* + *d*[1]*kP* = (*c*[1] + *d*[1]*k*)*P* = *c*[2]*P* + *d*[2]*kP* =
    (*c*[2] + *d*[2]*k*)*P*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*[1]*P* + *d*[1]*kP* = (*c*[1] + *d*[1]*k*)*P* = *c*[2]*P* + *d*[2]*kP* =
    (*c*[2] + *d*[2]*k*)*P*'
- en: This tells us that (*c*[1] + *d*[1]*k*) equals (*c*[2] + *d*[2]*k*) when taken
    modulo the number of points on the curve, which is not a secret.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，当对曲线上的点数取模时，(*c*[1] + *d*[1]*k*) 等于 (*c*[2] + *d*[2]*k*)，这并不是什么秘密。
- en: 'From this, we can deduce the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以推导出以下内容：
- en: '![image](../images/f0225-01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0225-01.jpg)'
- en: And we’ve found *k*, the solution to ECDLP.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 而我们已经找到了*k*，即ECDLP的解。
- en: Of course, that’s only the big picture—the details are more complex and interesting.
    In practice, elliptic curves extend over numbers of at least 256 bits, which makes
    attacking elliptic curve cryptography by finding a collision impractical because
    doing so takes up to 2^(128) operations (the cost of finding a collision over
    256-bit numbers, as you learned in [Chapter 6](ch06.xhtml#ch6)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是宏观视角，细节要复杂且更有趣。在实际操作中，椭圆曲线的数字至少扩展到256位，这使得通过寻找碰撞来攻击椭圆曲线密码学变得不切实际，因为这需要最多2^(128)次操作（这是找到256位数字的碰撞所需的代价，正如你在[第6章](ch06.xhtml#ch6)中学到的）。
- en: Diffie–Hellman Key Agreement over Elliptic Curves
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 椭圆曲线Diffie–Hellman密钥协商
- en: Recall from [Chapter 11](ch11.xhtml#ch11) that in the classical Diffie–Hellman
    (DH) key agreement protocol, two parties establish a shared secret by exchanging
    non-secret values. Given some fixed number *g*, Alice picks a secret random number
    *a*, computes *A* = *g*^(*a*), sends *A* to Bob, and Bob picks a secret random
    *b* and sends *B* = *g*^(*b*) to Alice. Both then combine their secret key with
    the other’s public key to produce the same *A*^(*b*) = *B*^(*a*) = *g*^(*ab*).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第11章](ch11.xhtml#ch11)中提到的经典Diffie–Hellman (DH) 密钥协商协议，其中两方通过交换非秘密的值来建立共享秘密。给定某个固定数值*g*，爱丽丝选择一个秘密的随机数*a*，计算出*A*
    = *g*^(*a*)，然后将*A*发送给鲍勃，而鲍勃选择一个秘密的随机数*b*，计算出*B* = *g*^(*b*)，然后将*B*发送给爱丽丝。然后，两方将各自的私钥与对方的公钥结合，得到相同的共享密钥*A*^(*b*)
    = *B*^(*a*) = *g*^(*ab*)。
- en: The elliptic curve version of DH is identical to that of classical DH but with
    different notations. In the case of ECC, for some fixed point *G*, Alice picks
    a secret random number *d*[*A*], computes *P*[*A*] = *d*[*A*]*G* (the point *G*
    multiplied by *d*[A]), and sends *P*[A] to Bob. Bob picks a secret random *d*[B],
    computes the point *P*[B] = *d*[B]*G*, and sends it to Alice. Then both compute
    the same shared secret, *d*[*A*]*P*[*B*] = *d*[*B*]*P*[*A*] = *d*[*A*]*d*[*B*]*G*.
    This method is called *elliptic curve Diffie–Hellman*, or *ECDH*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线版本的DH与经典DH完全相同，只是符号不同。在ECC的情况下，对于某个固定点*G*，爱丽丝选择一个秘密的随机数*d*[*A*]，计算出*P*[*A*]
    = *d*[*A*]*G*（即点*G*乘以*d*[*A*]），并将*P*[*A*]发送给鲍勃。鲍勃选择一个秘密的随机数*d*[*B*]，计算出点*P*[*B*]
    = *d*[*B*]*G*，并将其发送给爱丽丝。然后，两方计算出相同的共享秘密，*d*[*A*]*P*[*B*] = *d*[*B*]*P*[*A*] =
    *d*[*A*]*d*[*B*]*G*。这种方法称为*椭圆曲线Diffie–Hellman*，或*ECDH*。
- en: 'ECDH is to the ECDLP problem what DH is to DLP: it’s secure as long as ECDLP
    is hard. DH protocols that rely on DLP can therefore be adapted to work with elliptic
    curves and rely on ECDLP as a hardness assumption. For example, authenticated
    DH and Menezes–Qu–Vanstone (MQV) will also be secure when used with elliptic curves.
    (In fact, MQV was first defined as working over elliptic curves.)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ECDH与ECDLP问题的关系，就像DH与DLP问题的关系一样：它在ECDLP难解的前提下是安全的。因此，依赖DLP的DH协议可以改编为使用椭圆曲线，并依赖ECDLP作为难度假设。例如，认证的DH和Menezes–Qu–Vanstone
    (MQV)也将在使用椭圆曲线时保持安全。（事实上，MQV最初就是定义为在椭圆曲线上工作的。）
- en: '*Signing with Elliptic Curves*'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*使用椭圆曲线签名*'
- en: The standard algorithm used for signing with ECC is *ECDSA*, which stands for
    *elliptic curve digital signature algorithm*. This algorithm has replaced RSA
    signatures and classical DSA signatures in many applications. It is, for example,
    the only signature algorithm used in Bitcoin and is supported by many TLS and
    SSH implementations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 用于使用椭圆曲线加密（ECC）签名的标准算法是 *ECDSA*，即 *椭圆曲线数字签名算法*。该算法已经在许多应用中取代了 RSA 签名和经典 DSA
    签名。例如，它是比特币中唯一使用的签名算法，并且得到了许多 TLS 和 SSH 实现的支持。
- en: As with all signature schemes, ECDSA consists of a *signature generation* algorithm
    that the signer uses to create a signature using their private key and a *verification*
    algorithm that a verifier uses to check a signature’s correctness given the signer’s
    public key. The signer holds a number, *d*, as a private key, and verifiers hold
    the public key, *P* = *dG*. Both know in advance what elliptic curve to use, its
    order (*n*, the number of points in the curve), as well as the coordinates of
    a base point, *G*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有签名方案一样，ECDSA 包含一个 *签名生成* 算法，签名者使用该算法结合自己的私钥生成签名，以及一个 *验证* 算法，验证者使用该算法结合签名者的公钥检查签名的正确性。签名者持有一个数字
    *d* 作为私钥，验证者持有公钥 *P* = *dG*。双方都预先知道使用的椭圆曲线、其阶（*n*，即曲线上的点数），以及基点 *G* 的坐标。
- en: ECDSA Signature Generation
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ECDSA 签名生成
- en: In order to sign a message, the signer first hashes the message with a cryptographic
    hash function such as SHA-256 or BLAKE2 to generate a hash value, *h*, that is
    interpreted as a number between 0 and *n* – 1\. Next, the signer picks a random
    number, *k*, between 1 and *n* – 1 and computes *kG*, a point with the coordinates
    (*x*, *y*). The signer now sets *r* = *x* mod *n* and computes *s* = (*h* + *rd*)
    / *k* mod *n*, and then uses these values as the signature (*r*, *s*).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对消息进行签名，签名者首先使用加密哈希函数（如 SHA-256 或 BLAKE2）对消息进行哈希处理，生成哈希值 *h*，该值被解释为介于 0 和
    *n* – 1 之间的数字。接着，签名者选择一个介于 1 和 *n* – 1 之间的随机数 *k*，并计算 *kG*，即坐标为（*x*，*y*）的点。签名者现在设置
    *r* = *x* mod *n*，并计算 *s* = (*h* + *rd*) / *k* mod *n*，然后将这些值作为签名（*r*，*s*）。
- en: The length of the signature will depend on the coordinate lengths being used.
    For example, when you’re working with a curve where coordinates are 256-bit numbers,
    *r* and *s* would both be 256 bits long, yielding a 512-bit-long signature.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 签名的长度将取决于所使用的坐标长度。例如，当使用 256 位数值的坐标时，*r* 和 *s* 都将是 256 位长，从而生成一个 512 位长的签名。
- en: ECDSA Signature Verification
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ECDSA 签名验证
- en: The ECDSA verification algorithm uses a signer’s public key to verify the validity
    of a signature.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ECDSA 验证算法使用签名者的公钥来验证签名的有效性。
- en: 'In order to verify an ECDSA signature (*r*, *s*) and a message’s hash, *h*,
    the verifier first computes *w* = 1 / *s*, the inverse of *s* in the signature,
    which is equal to *k* / (*h* + *rd*) mod *n*, since *s* is defined as *s* = (*h*
    + *rd*) / *k*. Next, the verifier multiplies *w* with *h* to find *u* according
    to the following formula:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证 ECDSA 签名（*r*，*s*）和消息的哈希值 *h*，验证者首先计算 *w* = 1 / *s*，即签名中 *s* 的逆元，等于 *k*
    / (*h* + *rd*) mod *n*，因为 *s* 定义为 *s* = (*h* + *rd*) / *k*。接着，验证者将 *w* 与 *h* 相乘，按以下公式计算
    *u*：
- en: '*wh* = *hk* (*h* + *rd*) = *u*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*wh* = *hk* (*h* + *rd*) = *u*'
- en: 'The verifier then multiplies *w* with *r* to find *v*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，验证者将 *w* 与 *r* 相乘来计算 *v*：
- en: '*wr* = *rk*(*h* + *rd*) = *v*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*wr* = *rk* (*h* + *rd*) = *v*'
- en: 'Given *u* and *v*, the verifier computes the point *Q* according to the following
    formula:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 *u* 和 *v*，验证者按照以下公式计算点 *Q*：
- en: '*Q* = *uG* + *vP*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*Q* = *uG* + *vP*'
- en: Here, *P* is the signer’s public key, which is equal to *dG*, and the verifier
    only accepts the signature if the *x* coordinate of *Q* is equal to the value
    *r* from the signature.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*P* 是签名者的公钥，等于 *dG*，并且验证者只有在 *Q* 的 *x* 坐标等于签名中的 *r* 值时才接受该签名。
- en: 'This process works because, as a last step, we compute the point *Q* by substituting
    the public key *P* with its actual value *dG*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这一过程之所以有效，是因为在最后一步，我们通过将公钥 *P* 替换为其实际值 *dG* 来计算点 *Q*：
- en: '*uG* + *vdG* = (*u* + *vd*)*G*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*uG* + *vdG* = (*u* + *vd*)*G*'
- en: 'When we replace *u* and *v* with their actual values, we obtain the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 *u* 和 *v* 替换为其实际值时，得到以下结果：
- en: '*u* + *vd* = *hk* (*h* + *rd*) + *drk* / (*h* + *rd*) = (*hk* + *drk*) / (*h*
    + *rd*) = *k* (*h* + *dr*) / (*h* + *rd*) = *k*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*u* + *vd* = *hk* (*h* + *rd*) + *drk* / (*h* + *rd*) = (*hk* + *drk*) / (*h*
    + *rd*) = *k* (*h* + *dr*) / (*h* + *rd*) = *k*'
- en: This tells us that (*u* + *vd*) is equal to the value *k*, chosen during signature
    generation, and that *uG* + *vdG* is equal to the point *kG*. In other words,
    the verification algorithm succeeds in computing point *kG*, the same point computed
    during signature generation. Validation is complete once a verifier confirms that
    *kG*’s *x* coordinate is equal to the *r* received; otherwise, the signature is
    rejected as invalid.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们（*u* + *vd*）等于在签名生成过程中选择的值 *k*，而 *uG* + *vdG* 等于点 *kG*。换句话说，验证算法成功计算了点
    *kG*，这是在签名生成过程中计算出的同一点。一旦验证者确认 *kG* 的 *x* 坐标等于接收到的 *r*，验证完成；否则，签名将被视为无效并被拒绝。
- en: ECDSA vs. RSA Signatures
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ECDSA 与 RSA 签名
- en: Elliptic curve cryptography is often viewed as an alternative to RSA for public-key
    cryptography, but ECC and RSA don’t have much in common. RSA is only used for
    encryption and signatures, whereas ECC is a family of algorithms that can be used
    to perform encryption, generate signatures, perform key agreement, and offer advanced
    cryptographic functionalities such as identity-based encryption (a kind of encryption
    that uses encryption keys derived from a personal identifier, such as an email
    address).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线密码学通常被视为RSA的替代方案，用于公钥密码学，但ECC和RSA没有太多相似之处。RSA仅用于加密和签名，而ECC是一系列算法，可以用于执行加密、生成签名、进行密钥协商，并提供先进的加密功能，如基于身份的加密（这是一种使用从个人标识符（例如电子邮件地址）派生的加密密钥的加密方式）。
- en: When comparing RSA and ECC’s signature algorithms, recall that in RSA signatures,
    the signer uses their private key *d* to compute a signature as *y* = *x*^(*d*)
    mod *n*, where *x* is the data to be signed and *y* is the signature. Verification
    uses the public key *e* to confirm that *y*^(*e*) mod *n* equals *x*—a process
    that’s clearly simpler than that of ECDSA.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较RSA和ECC的签名算法时，请记住，在RSA签名中，签名者使用他们的私钥 *d* 来计算签名，公式为 *y* = *x*^(*d*) mod *n*，其中
    *x* 是要签名的数据，*y* 是签名。验证使用公钥 *e* 来确认 *y*^(*e*) mod *n* 是否等于 *x* ——这一过程显然比ECDSA的过程简单。
- en: 'RSA’s verification process is often faster than ECC’s signature generation
    because it uses a small public key *e*. But ECC has two major advantages over
    RSA: shorter signatures and signing speed. Because ECC works with shorter numbers,
    it produces shorter signatures than RSA (hundreds of bits long, not thousands
    of bits), which is an obvious benefit if you have to store or transmit numerous
    signatures. Signing with ECDSA is also much faster than signing with RSA (though
    signature verification is about as fast) because ECDSA works with much smaller
    numbers than RSA does for a similar security level. For example, [Listing 12-2](ch12.xhtml#ch12list2)
    shows that ECDSA is about 150 times faster at signing and a little faster at verifying.
    Note that ECDSA signatures are also shorter than RSA signatures because they’re
    512 bits (two elements of 256 bits each) rather than 4096 bits.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: RSA的验证过程通常比ECC的签名生成过程更快，因为它使用了一个较小的公钥 *e*。但ECC相对于RSA有两个主要优势：更短的签名和更快的签名速度。因为ECC使用更短的数字，它生成的签名比RSA更短（只有几百位，而不是几千位），如果你需要存储或传输大量签名，这是一个明显的好处。使用ECDSA签名的速度也比RSA签名更快（尽管验证签名的速度差不多），因为ECDSA使用的数字比RSA小得多，且安全级别相似。例如，[示例
    12-2](ch12.xhtml#ch12list2)显示，ECDSA在签名时大约快150倍，在验证时稍微快一些。请注意，ECDSA签名也比RSA签名更短，因为它们是512位（两个256位的元素），而RSA签名是4096位。
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 12-2: Comparing the speed of 4096-bit RSA signatures with 256-bit
    ECDSA signatures*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-2：比较4096位RSA签名和256位ECDSA签名的速度*'
- en: It’s fair to compare the performance of these differently sized signatures because
    they provide a similar security level. However, in practice, many systems use
    RSA signatures with 2048 bits, which is orders of magnitude less secure than 256-bit
    ECDSA. Thanks to its smaller modulus size, 2048-bit RSA is faster than 256-bit
    ECDSA at verifying, yet still slower at signing, as shown in [Listing 12-3](ch12.xhtml#ch12list3).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些不同大小的签名进行性能比较是公平的，因为它们提供了相似的安全级别。然而，在实践中，许多系统使用2048位的RSA签名，这比256位的ECDSA安全性低几个数量级。由于其较小的模数大小，2048位RSA在验证时比256位ECDSA更快，但在签名时仍然较慢，如[示例
    12-3](ch12.xhtml#ch12list3)所示。
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 12-3: The speed of 2048-bit RSA signatures*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-3：2048位RSA签名的速度*'
- en: The upshot is that you should prefer ECDSA to RSA except when signature verification
    is critical *and* you don’t care about signing speed, as in a sign-once, verify-many
    situation (for example, when a Windows executable application is signed once and
    then verified by all the systems executing it).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，除了签名验证至关重要*且*你不在乎签名速度的情况（例如，在一个Windows可执行应用程序被签名一次然后在所有执行该程序的系统中进行验证时），你应该选择ECDSA而非RSA。
- en: '*Encrypting with Elliptic Curves*'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*椭圆曲线加密*'
- en: 'Although elliptic curves are more commonly used for signing, you can still
    encrypt with them. But you’ll rarely see people do so in practice due to restrictions
    in the size of the plaintext that can be encrypted: you can fit only about 100
    bits of plaintext, as compared to almost 4000 in RSA with the same security level.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管椭圆曲线更常用于签名，但你仍然可以用它们进行加密。不过，由于可以加密的明文大小的限制，在实际应用中很少有人这么做：与RSA在相同安全等级下可加密约4000位的明文相比，椭圆曲线加密最多只能加密约100位的明文。
- en: One simple way to encrypt with elliptic curves is to use the *i**ntegrated encryption
    scheme (IES)*, a hybrid asymmetric–symmetric key encryption algorithm based on
    the Diffie–Hellman key exchange. Essentially, IES encrypts a message by generating
    a Diffie–Hellman key pair, combining the private key with the recipient’s own
    public key, deriving a symmetric key from the shared secret obtained, and then
    using an authenticated cipher to encrypt the message.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 用椭圆曲线加密的一种简单方法是使用*集成加密方案（IES）*，这是一种基于Diffie-Hellman密钥交换的混合非对称–对称密钥加密算法。本质上，IES通过生成一个Diffie-Hellman密钥对，将私钥与接收者的公钥结合，从共享的秘密中派生出对称密钥，然后使用认证加密算法加密消息。
- en: 'When used with elliptic curves, IES relies on ECDLP’s hardness and is called
    *elliptic-curve integrated encryption scheme (ECIES)*. Given a recipient’s public
    key, *P*, ECIES encrypts a message, *M*, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在椭圆曲线中使用时，IES依赖于ECDLP的难度，并称为*椭圆曲线集成加密方案（ECIES）*。给定接收者的公钥 *P*，ECIES按以下方式加密消息
    *M*：
- en: Pick a random number, *d*, and compute the point *Q* = *dG*, where the base
    point *G* is a fixed parameter. Here, (*d*, *Q*) acts as an ephemeral key pair,
    used only for encrypting *M*.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个随机数，*d*，并计算点 *Q* = *dG*，其中基点 *G* 是一个固定的参数。在这里，(*d*, *Q*) 作为一个临时密钥对，仅用于加密
    *M*。
- en: Compute an ECDH shared secret by computing *S* = *dP*.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过计算 *S* = *dP* 来计算ECDH共享密钥。
- en: Use a key derivation scheme (KDF) to derive a symmetric key, *K*, from *S*.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用密钥派生方案（KDF）从 *S* 派生出对称密钥 *K*。
- en: Encrypt *M* using *K* and a symmetric authenticated cipher, obtaining a ciphertext,
    *C*, and an authentication tag, *T*.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *K* 和对称认证加密算法加密 *M*，得到密文 *C* 和认证标签 *T*。
- en: 'The ECIES ciphertext then consists of the ephemeral public key *Q* followed
    by *C* and *T*. Decryption is straightforward: the recipient computes *S* by multiplying
    *R* with their private exponent to obtain *S*, and then derives the key *K* and
    decrypts *C* and verifies *T*.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ECIES密文由临时公钥 *Q*，然后是 *C* 和 *T* 组成。解密过程非常直接：接收者通过将 *R* 与其私钥指数相乘来计算 *S*，然后派生出密钥
    *K* 并解密 *C*，同时验证 *T*。
- en: Choosing a Curve
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择曲线
- en: Criteria used to assess the safety of an elliptic curve include the order of
    the group used (that is, its number of points), its addition formulas, and its
    origins.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 用于评估椭圆曲线安全性的标准包括所用群的阶数（即其点的数量）、加法公式以及其起源。
- en: 'There are several types of elliptic curves, but not all are equally good for
    cryptographic purposes. When making your selection, be sure to choose coefficients
    *a* and *b* in the curve’s equation *y*² = *x*³ + *ax* + *b* carefully; otherwise,
    you may end up with an insecure curve. In practice, you’ll use some de facto standard
    curve for encryption, but knowing what makes a safe curve will help you choose
    among the several available ones and better understand any associated risks. Here
    are some points to keep in mind:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线有多种类型，但并非所有曲线都同样适合加密用途。在选择时，务必小心选择曲线方程 *y*² = *x*³ + *ax* + *b* 中的系数 *a*
    和 *b*；否则，你可能会选择一个不安全的曲线。在实际应用中，你会使用某种事实上的标准曲线进行加密，但了解什么构成安全的曲线将帮助你在多种曲线中做出选择，并更好地理解相关风险。以下是一些需要牢记的要点：
- en: The order of the group should not be a product of small numbers; otherwise solving
    ECDLP becomes much easier.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 群的阶数不应为小数字的乘积；否则，解ECDLP问题会变得容易得多。
- en: In [“Adding and Multiplying Points”](ch12.xhtml#lev2sec148) on page 221, you
    learned that adding points *P* + *Q* required a specific addition formula when
    *Q* = *P*. Unfortunately, treating this case differently from the general one
    may leak critical information if an attacker is able to distinguish doublings
    from additions between distinct points. Some curves are secure *because* they
    use a single formula for all point addition. (When a curve does not require a
    specific formula for doublings, we say that it admits a *unified* addition law.)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[“添加和乘法点”](ch12.xhtml#lev2sec148)第221页中，你学到，添加点*P* + *Q*时，当*Q* = *P*时需要使用特定的加法公式。不幸的是，如果将这种情况与一般情况区别对待，可能会泄漏关键信息，尤其是当攻击者能够区分倍加和不同点之间的加法时。一些曲线之所以安全，*因为*它们对所有点加法使用相同的公式。（当曲线不需要特定的倍加公式时，我们说它符合*统一*的加法规则。）
- en: If the creators of a curve don’t explain the origin of *a* and *b*, they may
    be suspected of foul play because you can’t know whether they may have chosen
    weaker values that enable some yet-unknown attack on the cryptosystem.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果曲线的创作者没有解释*a*和*b*的来源，他们可能会被怀疑有所隐瞒，因为我们无法知道他们是否选择了较弱的值，从而可能导致一些尚未发现的加密系统攻击。
- en: Let’s review some of the most commonly used curves, especially ones used for
    signatures or Diffie–Hellman key agreement.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些最常用的曲线，特别是用于签名或Diffie–Hellman密钥协商的曲线。
- en: '**NOTE**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You’ll find more criteria and more details about curves on the dedicated website*
    [https://safecurves.cr.yp.to/](https://safecurves.cr.yp.to/).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在专门的网站上找到更多关于曲线的标准和细节* [https://safecurves.cr.yp.to/](https://safecurves.cr.yp.to/)。'
- en: '*NIST Curves*'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*NIST曲线*'
- en: In 2000, the NIST curves were standardized by the US NIST in the FIPS 186 document
    under “Recommended Elliptic Curves for Federal Government Use.” Five NIST curves
    work modulo a prime number (as discussed in [“Elliptic Curves over Integers”](ch12.xhtml#lev2sec147)
    on page 219), called *prime curves*. Ten other NIST curves work with binary polynomials,
    which are mathematical objects that make implementation in hardware more efficient.
    (We won’t cover binary polynomials in further detail because they’re seldom used
    with elliptic curves.)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 2000年，美国国家标准与技术研究院（NIST）在FIPS 186文档中对NIST曲线进行了标准化，文件标题为“联邦政府使用的推荐椭圆曲线”。五条NIST曲线在素数模（如[《整数上的椭圆曲线》](ch12.xhtml#lev2sec147)第219页所讨论）下工作，被称为*素数曲线*。另外十条NIST曲线使用二进制多项式，这是一种数学对象，它能使硬件实现更加高效。（我们不会进一步讨论二进制多项式，因为它们很少与椭圆曲线一起使用。）
- en: The most common NIST curves are the prime curves. Of these, one of the most
    common is P-256, a curve that works over numbers modulo the 256-bit number *p*
    = 2^(256) – 2^(224) + 2^(192) + 2^(96) – 1\. The equation for P-256 is *y*² =
    *x*³ – 3*x* + *b*, where *b* is a 256-bit number. NIST also provides prime curves
    of 192 bits, 224 bits, 384 bits, and 521 bits.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的NIST曲线是素数曲线。在这些曲线中，最常见的之一是P-256，它在模256位数*p* = 2^(256) – 2^(224) + 2^(192)
    + 2^(96) – 1的数上工作。P-256的方程是*y*² = *x*³ – 3*x* + *b*，其中*b*是一个256位的数字。NIST还提供192位、224位、384位和521位的素数曲线。
- en: 'NIST curves are sometimes criticized because only the NSA, creator of the curves,
    knows the origin of the *b* coefficient in their equations. The only explanation
    we’ve been given is that *b* results from hashing a random-looking constant with
    SHA-1\. For example, P-256’s *b* parameter comes from the following constant:
    `c49d3608 86e70493 6a6678e1 139d26b7 819f7e90`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: NIST曲线有时受到批评，因为只有NSA（曲线的创作者）知道它们方程中*b*系数的来源。我们所得到的唯一解释是，*b*是通过使用SHA-1对一个看起来是随机的常数进行哈希处理得出的。例如，P-256的*b*参数来自以下常数：`c49d3608
    86e70493 6a6678e1 139d26b7 819f7e90`。
- en: No one knows why the NSA picked this particular constant, but most experts don’t
    believe the curve’s origin hides any weakness.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人知道NSA为什么选择这个特定的常数，但大多数专家认为曲线的起源并不隐藏任何弱点。
- en: '*Curve25519*'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Curve25519*'
- en: Daniel J. Bernstein brought Curve25519 (pronounced *curve-twenty-five-five-**nineteen*)
    to the world in 2006\. Motivated by performance, he designed Curve25519 to be
    faster and use shorter keys than the standard curves. But Curve25519 also brings
    security benefits, because unlike the NIST curves it has no suspicious constants
    and can use the same unified formula for adding distinct points or for doubling
    a point.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Daniel J. Bernstein于2006年将Curve25519（读作*curve-twenty-five-five-**nineteen*）带给了世界。出于性能考虑，他设计了Curve25519，使其比标准曲线更快，并且使用较短的密钥。但Curve25519还带来了安全性上的好处，因为与NIST曲线不同，它没有可疑的常数，并且可以使用相同的统一公式来进行不同点的加法或点的倍加。
- en: The form of Curve25519’s equation, *y*² = *x*³ + 486662*x*² + *x*, is slightly
    different from that of the other equations you’ve seen in this chapter, but it
    still belongs to the elliptic curve family. The unusual form of this equation
    allows for specific implementation techniques that make Curve25519 fast in software.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Curve25519 方程的形式，*y*² = *x*³ + 486662*x*² + *x*，与本章中你所见的其他方程略有不同，但它仍属于椭圆曲线家族。这个方程的不寻常形式允许使用特定的实现技术，使
    Curve25519 在软件中运行非常快速。
- en: Curve25519 works with numbers modulo the prime number 2^(255) – 19, a 256-bit
    prime number that is as close as possible to 2^(255). The *b* coefficient 486662
    is the smallest integer that satisfies the security criteria set by Bernstein.
    Taken together, these features make Curve25519 more trust­worthy than NIST curves
    and their fishy coefficients.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Curve25519 使用的是以素数 2^(255) – 19 为模的数字，这是一个 256 位素数，尽可能接近 2^(255)。*b* 系数 486662
    是满足 Bernstein 安全标准的最小整数。综合这些特性，使得 Curve25519 比 NIST 曲线及其可疑系数更值得信任。
- en: 'Curve25519 is used everywhere: in Google Chrome, Apple systems, OpenSSH, and
    many other systems. However, because Curve25519 isn’t a NIST standard, some applications
    stick to NIST curves.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Curve25519 已经被广泛使用：在 Google Chrome、Apple 系统、OpenSSH 和许多其他系统中。然而，由于 Curve25519
    不是一个 NIST 标准，一些应用仍坚持使用 NIST 曲线。
- en: '**NOTE**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To learn all the details and rationale behind Curve25519, view the 2016 presentation
    “The first 10 years of Curve25519” by Daniel J. Bernstein, available at* [http://cr.yp.to/talks.html#2016.03.09/](http://cr.yp.to/talks.html#2016.03.09/).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*要了解 Curve25519 的所有细节和背后的原理，请查看 Daniel J. Bernstein 于 2016 年做的讲座“Curve25519
    的前 10 年”，可通过此链接访问* [http://cr.yp.to/talks.html#2016.03.09/](http://cr.yp.to/talks.html#2016.03.09/)。'
- en: '*Other Curves*'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*其他曲线*'
- en: 'As I write this, most cryptographic applications use NIST curves or Curve25519,
    but there are other legacy standards in use, and newer curves are being promoted
    and pushed within standardization committees. Some of the old national standards
    include France’s ANSSI curves and Germany’s Brainpool curves: two families that
    don’t support complete addition formulas and that use constants of unknown origins.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我写这篇文章时，大多数加密应用都使用 NIST 曲线或 Curve25519，但仍有其他遗留标准在使用，并且一些新曲线正在标准化委员会中被推广和推动。一些旧的国家标准包括法国的
    ANSSI 曲线和德国的 Brainpool 曲线：这两种曲线不支持完整的加法公式，并且使用未知来源的常数。
- en: Some newer curves are more efficient than the older ones and are clear of any
    suspicion; they offer different security levels and various efficiency optimizations.
    Examples include Curve41417, a variant of Curve25519, which works with larger
    numbers and offers a higher level of security (approximately 200 bits); Ed448-Goldilocks,
    a 448-bit curve first proposed in 2014 and considered to be an internet standard;
    as well as six curves proposed by Aranha et al. in “A note on high-security general-purpose
    elliptic curves” (see *[http://eprint.iacr.org/2013/647/](http://eprint.iacr.org/2013/647/)*),
    though these curves are rarely used. The details specific to all these curves
    are beyond the scope of this book.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更新的曲线比旧的曲线更高效，并且没有任何怀疑；它们提供了不同的安全级别和各种效率优化。例子包括 Curve41417，它是 Curve25519 的一个变种，使用更大的数字并提供更高的安全性（大约
    200 位）；Ed448-Goldilocks，它是一个448位曲线，首次提出于2014年，并被认为是互联网标准；以及 Aranha 等人在《A note
    on high-security general-purpose elliptic curves》中提出的六条曲线（见 *[http://eprint.iacr.org/2013/647/](http://eprint.iacr.org/2013/647/)*），尽管这些曲线很少被使用。这些曲线的具体细节超出了本书的讨论范围。
- en: How Things Can Go Wrong
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事情可能出错的方式
- en: Elliptic curves have their downsides due to their complexity and large attack
    surface. Their use of more parameters than classical Diffie–Hellman brings with
    it a greater attack surface with more opportunities for mistakes and abuse—and
    possible software bugs that might affect their implementation. Elliptic curve
    software may also be vulnerable to side-channel attacks due to the large numbers
    used in their arithmetic. If the speed of calculations depends on inputs, attackers
    may be able to obtain information about the formulas being used to encrypt.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于椭圆曲线的复杂性和较大的攻击面，它们也有一些缺点。它们使用比经典 Diffie–Hellman 更多的参数，这带来了更大的攻击面，更多的出错和滥用的机会——以及可能影响其实现的软件漏洞。由于其运算中使用了大量的数字，椭圆曲线软件也可能容易受到侧信道攻击。如果计算的速度依赖于输入，攻击者可能能够获得关于加密所用公式的信息。
- en: In the following sections, I discuss two examples of vulnerabilities that can
    occur with elliptic curves, even when the implementation is safe. These are protocol
    vulnerabilities rather than implementation vulnerabilities.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将讨论即使实现是安全的，椭圆曲线仍然可能出现的两种漏洞。这些是协议漏洞，而不是实现漏洞。
- en: '*ECDSA with Bad Randomness*'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*ECDSA 随机性差的问题*'
- en: 'ECDSA signing is randomized, as it involves a secret random number *k* when
    setting *s* = (*h* + *rd*) / *k* mod *n*. However, if the same *k* is reused to
    sign a second message, an attacker could combine the resulting two values, *s*[1]
    = (*h*[1] + *rd*) / *k* and *s*[2] = (*h*[2] + *rd*) / *k,* to get *s*[1] – *s*[2]
    = (*h*[1] – *h*[2]) / *k* and then *k* = (*h*[1] – *h*[2]) / (*s*[1] – *s*[2]).
    When *k* is known, the private key *d* is easily recovered by computing the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ECDSA 签名是随机的，因为在设置 *s* = (*h* + *rd*) / *k* mod *n* 时涉及一个秘密的随机数 *k*。然而，如果相同的
    *k* 被重复用于签名第二条消息，攻击者可以将得到的两个值 *s*[1] = (*h*[1] + *rd*) / *k* 和 *s*[2] = (*h*[2]
    + *rd*) / *k* 结合起来，得到 *s*[1] – *s*[2] = (*h*[1] – *h*[2]) / *k*，然后 *k* = (*h*[1]
    – *h*[2]) / (*s*[1] – *s*[2])。当 *k* 被知道时，私钥 *d* 可以通过以下计算轻松恢复：
- en: (*ks*[1] − *h*[1]) / *r* = ((*h*[1] + *rd*) − *h*[1]) / *r* = *rd* / *r* = *d*
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: (*ks*[1] − *h*[1]) / *r* = ((*h*[1] + *rd*) − *h*[1]) / *r* = *rd* / *r* = *d*
- en: Unlike RSA signatures, which won’t allow the key to be recovered if a weak pseudorandom
    number generator (PRNG) is used, the use of non-random numbers can lead to ECDSA’s
    *k* being recoverable, as happened with the attack on the PlayStation 3 game console
    in 2010, presented by the fail0verflow team at the 27th Chaos Communication Congress
    in Berlin, Germany.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与 RSA 签名不同，如果使用弱的伪随机数生成器（PRNG），RSA 签名不会允许恢复密钥，但非随机数的使用可能导致 ECDSA 的 *k* 可以被恢复，就像
    2010 年 PlayStation 3 游戏机遭遇的攻击那样，这次攻击由 fail0verflow 团队在德国柏林举办的第 27 届 Chaos Communication
    Congress 上展示。
- en: '*Breaking ECDH Using Another Curve*'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*使用另一条曲线破解 ECDH*'
- en: ECDH can be elegantly broken if you fail to validate input points. The primary
    reason is that the formulas that give the coordinates for the sum of points *P*
    + *Q* never involve the *b* coefficient of the curve; instead, they rely only
    on the coordinates of *P* and *Q* and the *a* coefficient (when doubling a point).
    The unfortunate consequence of this is that when adding two points, you can never
    be sure that you’re working on the right curve because you may actually be adding
    points on a different curve with a different *b* coefficient. That means you can
    break ECDH as described in the following scenario, called the *invalid curve attack*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有验证输入点，ECDH 可以被优雅地破解。主要原因是，给出点 *P* + *Q* 和坐标的公式从来不涉及曲线的 *b* 系数；它们仅依赖于 *P*
    和 *Q* 的坐标以及 *a* 系数（当对一个点进行加倍时）。不幸的是，结果就是，当你加两个点时，你永远不能确定自己正在使用正确的曲线，因为你实际上可能在使用一个不同
    *b* 系数的曲线。也就是说，你可以像下面的场景所描述的那样，通过所谓的 *无效曲线攻击* 来破解 ECDH。
- en: Say that Alice and Bob are running ECDH and have agreed on a curve and a base
    point, *G*. Bob sends his public key *d*[B]*G* to Alice. Alice, instead of sending
    a public key *d*[A]*G* on the agreed upon curve, sends a point on a different
    curve, either intentionally or accidentally. Unfortunately, this new curve is
    weak and allows Alice to choose a point *P* for which solving ECDLP is easy. She
    chooses a point of low order, for which there is a relatively small *k* such that
    *kP* = *O*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Alice 和 Bob 正在运行 ECDH，并且已经就一条曲线和一个基点 *G* 达成一致。Bob 将他的公钥 *d*[B]*G* 发送给 Alice。Alice
    并没有在商定的曲线上发送公钥 *d*[A]*G*，而是发送了一个不同曲线上的点，无论是故意还是无意。遗憾的是，这条新曲线较弱，允许 Alice 选择一个点
    *P*，使得解决 ECDLP 变得容易。她选择了一个低阶的点，对于这个点，存在一个相对较小的 *k*，使得 *kP* = *O*。
- en: Now Bob, believing that he has a legitimate public key, computes what he thinks
    is the shared secret *d*[B]*P*, hashes it, and uses the resulting key to encrypt
    data sent to Alice. The problem is that when Bob computes *d*[B]*P*, he is unknowingly
    computing on the weaker curve. As a result, because *P* was chosen to belong to
    a small subgroup within the larger group of points, the result *d*[B]*P* will
    also belong to that small subgroup, allowing an attacker to determine the shared
    secret *d*[B]*P* efficiently if they know the order of *P*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Bob 认为自己拥有一个合法的公钥，他计算了自己认为的共享秘密 *d*[B]*P*，对其进行哈希处理，并使用得到的密钥加密发送给 Alice 的数据。问题在于，当
    Bob 计算 *d*[B]*P* 时，他在不知情的情况下实际上是在较弱的曲线上进行计算。因此，由于 *P* 是从较大点群中的一个小子群中选择的，结果 *d*[B]*P*
    也将属于这个小子群，这使得攻击者如果知道 *P* 的阶，就能有效地确定共享秘密 *d*[B]*P*。
- en: One way to prevent this is to make sure that points *P* and *Q* belong to the
    right curve by ensuring that their coordinates satisfy the curve’s equation. Doing
    so would prevent this attack by making sure that you’re only able to work on the
    secure curve.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这种情况的一种方法是确保点*P*和*Q*属于正确的曲线，通过确保它们的坐标满足曲线方程来实现。这样可以防止这种攻击，确保你只能在安全曲线上进行操作。
- en: Such an invalid curve attack was found in 2015 on certain implementations of
    the TLS protocol, which uses ECDH to negotiate session keys. (For details, see
    the paper “Practical Invalid Curve Attacks on TLS-ECDH” by Jager, Schwenk, and
    Somorovsky.)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年发现某些TLS协议实现存在无效曲线攻击，该协议使用ECDH来协商会话密钥。（详情请参阅Jager、Schwenk和Somorovsky的论文《TLS-ECDH上的实用无效曲线攻击》）。
- en: Further Reading
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Elliptic curve cryptography is a fascinating and complex topic that involves
    lots of mathematics. I’ve not discussed important notions such as a point’s order,
    a curve’s cofactor, projective coordinates, torsion points, and methods for solving
    the ECDLP problem. If you are mathematically inclined, you’ll find information
    on these and other related topics in the *Handbook of Elliptic and Hyperelliptic
    Curve Cryptography* by Cohen and Frey (Chapman and Hall/CRC, 2005). The 2013 survey
    “Elliptic Curve Cryptography in Practice” by Bos, Halderman, Heninger, Moore,
    Naehrig, and Wustrow also gives a good illustrated introduction with practical
    examples (*[https://eprint.iacr.org/2013/734/](https://eprint.iacr.org/2013/734/)*).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线密码学是一个迷人且复杂的主题，涉及大量数学内容。我没有讨论一些重要的概念，如点的阶、曲线的余因子、射影坐标、扭曲点以及解决ECDLP问题的方法。如果你对数学有兴趣，你可以在Cohen和Frey编著的《椭圆曲线与超椭圆曲线密码学手册》（Chapman
    and Hall/CRC, 2005）中找到有关这些和其他相关主题的信息。2013年由Bos、Halderman、Heninger、Moore、Naehrig和Wustrow编写的《椭圆曲线密码学实践中的应用》调查报告，也提供了一个很好的插图介绍，包含实际例子（*[https://eprint.iacr.org/2013/734/](https://eprint.iacr.org/2013/734/)*）。
