- en: '**B**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**B**'
- en: '**BITCOIN PROGRAMMING WITH BITCOINJ**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 BITCOINJ 进行比特币编程**'
- en: In [Appendix A](../Text/app01.html#app01), we dabbled with JavaScript code that
    could perform some basic actions with a Bitcoin wallet by automating a preexisting
    wallet. In this appendix, we’ll write far more powerful programs that directly
    insert themselves into the Bitcoin network. As discussed previously, Bitcoin programs
    written this way—meaning those that do not rely on APIs from external companies
    and avoid dependencies on separate wallet programs—are usually the smartest solution
    for serious Bitcoin development projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[附录 A](../Text/app01.html#app01)中，我们尝试了 JavaScript 代码，通过自动化现有的钱包来执行一些基本的比特币钱包操作。在本附录中，我们将编写更强大的程序，直接将自己插入到比特币网络中。正如之前所讨论的那样，以这种方式编写的比特币程序——也就是说，那些不依赖于外部公司
    API、避免依赖独立钱包程序的程序——通常是进行严肃比特币开发项目的最佳解决方案。
- en: '**The Best Programming Language for Connecting to the Bitcoin Network**'
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**连接到比特币网络的最佳编程语言**'
- en: If you’re an experienced programmer, most likely you have a favorite programming
    language you would prefer to use to write your Bitcoin programs. However, only
    a few mature libraries currently exist that can connect directly to the Bitcoin
    network. One is the C++ reference implementation with which all the first full
    clients of the Bitcoin system were written.^([1](../Text/footnote.html#footnote37))
    Large enterprise companies interested in supporting bitcoins should use this library.
    However, working with C++ is difficult for novices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个经验丰富的程序员，很可能你有一个偏爱的编程语言来编写比特币程序。然而，目前只有少数成熟的库可以直接连接到比特币网络。其中一个是 C++ 参考实现，所有比特币系统的第一个完整客户端都是用它编写的。^([1](../Text/footnote.html#footnote37))
    有意支持比特币的大型企业公司应使用此库。然而，C++ 对初学者来说相对较难。
- en: Another mature library is written in Java and is called bitcoinJ.^([2](../Text/footnote.html#footnote38))
    Because Java is easier to work with than C++, it is the library we’ll use. (The
    bitcoinJ library can also be used easily from languages built on top of the Java
    Virtual Machine, such as Scala or Clojure.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个成熟的库是用 Java 编写的，名为 bitcoinJ。^([2](../Text/footnote.html#footnote38)) 由于 Java
    比 C++ 更易于使用，因此我们将使用这个库。（bitcoinJ 库也可以很容易地通过构建在 Java 虚拟机上的其他语言（如 Scala 或 Clojure）使用。）
- en: Currently, the options for other languages are rather limited. By searching
    the Internet, you *will* find Bitcoin libraries for other languages, such as Ruby,
    C#, and Python. However, most of these libraries are either in extremely early
    development or simply use the more limited JSON-RPC interface, which was discussed
    in [Appendix A](../Text/app01.html#app01).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，其他语言的选项相当有限。通过搜索互联网，你*会*找到适用于其他语言的比特币库，如 Ruby、C# 和 Python。然而，这些库大多数都处于极其早期的开发阶段，或者仅仅使用更为有限的
    JSON-RPC 接口，这在[附录 A](../Text/app01.html#app01)中有讨论。
- en: '**NOTE**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some serious attempts are being made to offer full Bitcoin client support
    within the Go programming language. However, at the time of this writing, these
    libraries are either still in early development (such as gocoin^([3](../Text/footnote.html#footnote39)))
    or are missing major features (such as btcd ^([4](../Text/footnote.html#footnote40))).*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*目前正在进行一些严肃的尝试，旨在为 Go 编程语言提供完整的比特币客户端支持。然而，在撰写本文时，这些库要么仍处于早期开发阶段（例如 gocoin^([3](../Text/footnote.html#footnote39)))，要么缺少主要功能（例如
    btcd ^([4](../Text/footnote.html#footnote40)))。*'
- en: No matter which library you choose, keep in mind that you must be vigilant about
    security. Essentially, when you use any of these libraries, you’ll be giving the
    library authors the keys to your Bitcoin kingdom. As we warned previously, technically
    it would be relatively easy to introduce rogue code into one of these libraries
    to steal all your money!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪个库，请记住，必须保持警惕以确保安全。实际上，当你使用这些库时，你相当于将比特币王国的钥匙交给了库的作者。正如我们之前所警告的，技术上来说，将恶意代码引入这些库以窃取所有资金是相对容易的！
- en: '**Installing Java, Maven, and the BitcoinJ Library**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安装 Java、Maven 和 BitcoinJ 库**'
- en: 'Let’s ready your computer to do Java and bitcoinJ programming. The following
    steps should work on any major OS: Windows, Mac, or Linux.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为你的计算机准备好进行 Java 和 bitcoinJ 编程。以下步骤应适用于任何主要操作系统：Windows、Mac 或 Linux。
- en: '***Step 1: Installing Java***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 1：安装 Java***'
- en: The Java programming language is maintained by Oracle Corporation. Your computer
    may already have Java installed, but if you’ve never done Java development, your
    computer may only contain the Java JRE (Java Runtime Engine), which can run Java
    programs but is not adequate for developing them. Instead, you need the Java JDK
    (Java Development Kit). To download the JDK, do a Google search for *Java JDK*.
    The first link (which should be a link on the official Oracle website) should
    direct you to the right place to access the download.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java 编程语言由 Oracle 公司维护。你的电脑可能已经安装了 Java，但如果你从未进行过 Java 开发，电脑上可能只包含 Java JRE（Java
    运行时环境），它能够运行 Java 程序，但不足以进行开发。你需要的是 Java JDK（Java 开发工具包）。要下载 JDK，可以在 Google 上搜索
    *Java JDK*。第一个链接（应该是 Oracle 官方网站的链接）会把你引导到正确的下载页面。
- en: '**NOTE**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '***Linux developers:** Some versions of Linux may install the OpenJDK version
    of Java by default. At the time of this writing, this unofficial Java variant
    is missing some components that this tutorial depends on. Instead, look online
    for information about installing the Oracle JDK on your version of Linux and make
    it the default Java version on your system.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '***Linux 开发者：**某些版本的 Linux 可能默认安装 OpenJDK 版本的 Java。在撰写本文时，这种非官方的 Java 变体缺少一些本教程所依赖的组件。因此，请在线查找有关在你的
    Linux 版本上安装 Oracle JDK 的信息，并将其设置为系统默认的 Java 版本。*'
- en: '***Step 2: Installing Maven***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 2：安装 Maven***'
- en: Maven is a packaging tool for Java. Essentially, you specify which libraries
    your program needs, and Maven automatically downloads them from the Internet and
    makes them available to your program. This is analogous to the Node Package Manager
    used in [Appendix A](../Text/app01.html#app01).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 是一个用于 Java 的打包工具。基本上，你指定程序需要哪些库，Maven 会自动从互联网上下载它们并使其可供你的程序使用。这类似于在[附录
    A](../Text/app01.html#app01)中使用的 Node 包管理器。
- en: You can download Maven and find instructions for installing Maven on each OS
    at *[https://maven.apache.org/](https://maven.apache.org/)*. Just follow the instructions
    at the main Maven website to install it or search Google for tutorials. Because
    more than a million other people have had to install Maven, if you run into installation
    problems, just type your problem into Google. It is very likely you’ll get helpful
    information on how to solve your problem.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *[https://maven.apache.org/](https://maven.apache.org/)* 下载 Maven 并找到各操作系统的安装说明。只需按照
    Maven 官方网站上的说明进行安装，或者在 Google 上搜索教程。由于已有超过一百万人遇到并解决了安装 Maven的问题，如果你遇到安装问题，只需将问题输入
    Google，极有可能会找到有用的解决方案。
- en: '**NOTE**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '***Windows users:** At the time of this writing, detailed instructions for
    installing Maven on Windows are cleverly hidden at the very bottom of* [http://maven.apache.org/download.cgi](http://maven.apache.org/download.cgi).
    ***Mac/Linux users:** You can use your package managers here: brew install maven
    for Mac and sudo apt-get install maven for Debian Linux*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '***Windows 用户：**在撰写本文时，关于 Windows 安装 Maven 的详细说明巧妙地隐藏在* [http://maven.apache.org/download.cgi](http://maven.apache.org/download.cgi)的最底部。
    ***Mac/Linux 用户：**你可以在此使用你的包管理器：Mac 使用 brew install maven，Debian Linux 使用 sudo
    apt-get install maven。*'
- en: To ensure Maven is properly installed, a version message should display when
    you type `mvn --version` from a console.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保 Maven 正确安装，在控制台中输入 `mvn --version` 时应该会显示版本信息。
- en: For typical Java programming, we could stop here because any needed additional
    libraries could be downloaded through the Maven package system. However, because
    we’re writing programs that work with money, the bitcoinJ maintainers require
    all developers to take a few extra precautions and install a couple of additional
    tools that directly relate to security issues.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型的 Java 编程，我们可以到此为止，因为任何额外需要的库都可以通过 Maven 包系统下载。然而，由于我们正在编写与金钱相关的程序，bitcoinJ
    的维护者要求所有开发者采取一些额外的预防措施，并安装几个直接与安全问题相关的工具。
- en: '***Step 3: Installing Git***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 3：安装 Git***'
- en: For security reasons, we’ll install Git, which is a popular source code management
    tool. But it also offers features for securely downloading source code from online
    repositories that we’ll rely on. Download Git from *[http://git-scm.com/](http://git-scm.com/)*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，我们将安装 Git，这是一款流行的源代码管理工具。它还提供了从在线代码库安全下载源代码的功能，我们将依赖这些功能。可以从 *[http://git-scm.com/](http://git-scm.com/)*
    下载 Git。
- en: '**NOTE**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Once again, Mac and Linux users can use their package managers: brew install
    git and apt-get install git, respectively. Do you see a pattern?*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*再一次，Mac 和 Linux 用户可以使用他们的包管理器：分别使用 brew install git 和 apt-get install git。你看到了一个规律吗？*'
- en: '***Step 4: Installing BitcoinJ***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 4：安装 BitcoinJ***'
- en: BitcoinJ is a Bitcoin library that can “talk bitcoin” and can connect directly
    to the Bitcoin network. By calling functions in this library, we can send and
    receive bitcoins in real time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: BitcoinJ 是一个比特币库，能够“理解比特币”，并且可以直接连接到比特币网络。通过调用该库中的函数，我们可以实时发送和接收比特币。
- en: We’ll build bitcoinJ directly from its authoritative source. Navigate to a directory
    from the console where you want to install the bitcoinJ library (your *Home* directory
    would be a good place).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接从其权威源构建 bitcoinJ。通过控制台导航到你希望安装 bitcoinJ 库的目录（你的*Home*目录是一个不错的选择）。
- en: '**NOTE**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A new subdirectory will be created, so other existing files in this directory
    will not be affected by this installation.*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*将会创建一个新的子目录，因此该目录中的其他现有文件不会受到此安装的影响。*'
- en: 'Enter the following into your console (on Windows you may need to use the special
    Git Bash console that was installed when you installed Git):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中输入以下内容（在 Windows 上，你可能需要使用安装 Git 时提供的特殊 Git Bash 控制台）：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line downloads the bitcoinJ code from the authoritative website ➊.
    Then, we use git to switch to an older version of this library using the `git
    checkout` command ➋. During this tutorial, this command will shield us from any
    problems that might be caused by newer versions of the library. However, when
    you’ve completed the tutorials, you can switch to the newest version of bitcoinJ
    (`git checkout master`) to experiment with its shiny new features. The last line
    installs the package into the local Maven package repository ➌. When we reference
    bitcoinJ from our programs, Maven will fetch it from this repository (instead
    of grabbing it from the Internet), and we can be confident we’re using an uncorrupted
    version of this library.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行从权威网站 ➊ 下载 bitcoinJ 代码。然后，我们使用 git 切换到该库的一个旧版本，使用`git checkout`命令 ➋。在本教程中，该命令将帮助我们避免因库的更新版本而可能出现的任何问题。然而，当你完成教程后，你可以切换到
    bitcoinJ 的最新版本（`git checkout master`）来尝试其新特性。最后一行将该包安装到本地 Maven 包仓库 ➌。当我们从程序中引用
    bitcoinJ 时，Maven 将从该仓库中获取，而不是从互联网上获取，这样我们可以确保使用的是未被篡改的库版本。
- en: Now we can finally start programming!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于可以开始编程了！
- en: '**Creating a Starter Project for hello-money**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为 hello-money 创建一个启动项目**'
- en: In [Appendix A](../Text/app01.html#app01), we created a JavaScript program called
    `Hello Money!` that detects when money is sent to a Bitcoin address. Now, we’ll
    write a more sophisticated program with Java and bitcoinJ that accomplishes the
    same task. From the console, navigate to a directory where you want your new program
    to live, such as your computer’s *Home* or *Documents* folder. A subdirectory
    will be created in this place.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[附录 A](../Text/app01.html#app01)中，我们创建了一个名为`Hello Money!`的 JavaScript 程序，用于检测何时向比特币地址发送资金。现在，我们将使用
    Java 和 bitcoinJ 编写一个更复杂的程序，完成相同的任务。从控制台中，导航到你希望新程序所在的目录，比如你的计算机的*Home*或*Documents*文件夹。该目录下将会创建一个子目录。
- en: 'Now type the following to have Maven create an empty starter project:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入以下命令让 Maven 创建一个空的启动项目：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These commands create a directory called *hello-money* at the current location
    with the `hello-money` starter project.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将在当前位置创建一个名为*hello-money*的目录，并放置`hello-money`启动项目。
- en: '**NOTE**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If Maven prompts you for answers during this process, just keep pressing ENTER
    to use the default setting.*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果 Maven 在此过程中提示你输入答案，只需不断按 ENTER 键以使用默认设置。*'
- en: 'Next, we need to inform Maven that this program will use a couple of external
    libraries. We do this by editing the file *pom.xml*, which should now exist in
    the new directory. Also in this file should be a section named `<dependencies>`
    where we’ll add bitcoinJ as a new dependency. After the previous dependency (i.e.,
    *after* the line that reads `</dependency>` singular), add the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉 Maven 这个程序将使用一些外部库。我们通过编辑*pom.xml*文件来实现这一点，该文件现在应该已经存在于新目录中。在这个文件中，还应该有一个名为`<dependencies>`的部分，我们将在其中添加
    bitcoinJ 作为新的依赖项。在之前的依赖项之后（即在`</dependency>`这一行*之后*），添加以下内容：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we’ll add a plug-in called `exec-maven-plugin` to our program. A *plug-in*
    is a special type of library. The `exec-maven-plugin` will make it easier to run
    our finished program from the command line.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将向程序中添加一个名为`exec-maven-plugin`的插件。*插件*是一种特殊类型的库。`exec-maven-plugin`将使我们能够更轻松地从命令行运行已完成的程序。
- en: 'At the very bottom of the projects in *pom.xml* (i.e., *after* the line that
    reads `</dependencies>` plural), add the following lines:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在*pom.xml*文件的最底部（即在`</dependencies>`这一行*之后*），添加以下内容：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we’re ready to run this *empty* program for the first time as a test. To
    do this, execute the following lines from the console in the program’s directory:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好第一次运行这个*空的*程序作为测试了。要做到这一点，请在程序的目录中从控制台执行以下几行：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first line ➊ loads all the necessary libraries into the project and builds
    the program into a Java bytecode file. The second line ➋ actually runs the program.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行 ➊ 将所有必要的库加载到项目中，并将程序构建成Java字节码文件。第二行 ➋ 实际上运行程序。
- en: If the program runs successfully, you should see `Hello World!` printed on the
    screen. This means Maven has successfully created a functioning Java program and
    that we’re now ready to start writing the core Bitcoin code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序成功运行，屏幕上应该会显示`Hello World!`。这意味着Maven已经成功创建了一个功能正常的Java程序，我们现在可以开始编写核心的比特币代码。
- en: '**Writing the Code for hello-money**'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写hello-money代码**'
- en: 'The entirety of the code for our `hello-money` program follows. To add this
    to the project, open the file *src/main/java/hellomoney/App.java* and replace
    its contents with this program:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`hello-money`程序的完整代码如下。要将其添加到项目中，请打开文件*src/main/java/hellomoney/App.java*并将其内容替换为该程序：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, run the command `mvn install`, which checks the syntax of this new program
    code and builds it into a program file. If the build works, the message `BUILD
    SUCCESS` should appear (along with tons of other esoteric messages).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行命令`mvn install`，该命令会检查新程序代码的语法并将其构建成程序文件。如果构建成功，应该会显示`BUILD SUCCESS`的消息（以及大量其他复杂的消息）。
- en: Before we run the program, let’s walk through it step-by-step to see what it
    does.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行程序之前，让我们一步一步地了解它是如何工作的。
- en: '***Declarations at the Top of the Program***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***程序顶部的声明***'
- en: 'The first line in the program declares the name of the package:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一行声明了包的名称：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we declare all the libraries the program will reference:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明程序将引用的所有库：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Three of these references are for Bitcoin classes: First, we’ll use the core
    libraries to access basic Bitcoin classes (such as classes for wallets and keys).
    Second, we need classes for storing the blockchain (called a *block store* in
    BitcoinJ lingo). Third, we need to use the `DnsDiscovery` class, which helps us
    find other nodes participating in the Bitcoin network. We import the `java.io.File`
    class because we’ll be writing our block store to a file, and we import the `java.math.BigInteger`
    class to work with, well, big integers.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 其中三项引用是比特币相关的类：首先，我们将使用核心库来访问基本的比特币类（例如钱包和密钥的类）。其次，我们需要用于存储区块链的类（在BitcoinJ术语中称为*区块存储*）。第三，我们需要使用`DnsDiscovery`类，它帮助我们找到参与比特币网络的其他节点。我们导入`java.io.File`类，因为我们将把区块存储写入文件，并且导入`java.math.BigInteger`类来处理大整数。
- en: 'Now let’s define the Java class that holds the program:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一个Java类来保存这个程序：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The program code is stored in a new class called `App`, which contains a single
    member function `main`. We mentioned this `hellomoney.App` class in the *pom.xml*
    file, declaring it as the *main class* of the program.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 程序代码存储在一个名为`App`的新类中，该类包含一个名为`main`的成员函数。我们在*pom.xml*文件中提到过这个`hellomoney.App`类，将其声明为程序的*主类*。
- en: Let’s look at individual lines in the main function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行看看主函数中的代码。
- en: '***Initializing Our Java Objects***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***初始化我们的Java对象***'
- en: Here is the code that initializes the Java object we need from the bitcoinJ
    library.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从bitcoinJ库中初始化我们需要的Java对象的代码。
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We start by fetching the network parameters for the main, production Bitcoin
    network ➊. Although only one true Bitcoin network is actually used for transactions,
    it’s difficult to test the Bitcoin system thoroughly with real money; therefore,
    Bitcoin developers also maintain a second Bitcoin network called *TestNet* for
    testing only. The `NetworkParameters` structure contains information about the
    genesis block (the first block in the block-chain) as well as information about
    the maximum number of coins and several other assorted details, which may differ
    between the main Bitcoin network and the TestNet. By having all this information
    packed in the `NetworkParameters` data structure, it’s easy to connect our program
    to another network besides the main Bitcoin network, such as the TestNet, as desired.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取主生产比特币网络的网络参数➊。虽然实际用于交易的只有一个真正的比特币网络，但使用真实货币彻底测试比特币系统是困难的；因此，比特币开发者还维护了一个名为*TestNet*的第二个比特币网络，仅供测试使用。`NetworkParameters`结构包含有关创世区块（区块链中的第一个区块）以及最大硬币数量等多个其他细节的信息，这些信息在主比特币网络和TestNet之间可能有所不同。通过将所有这些信息打包在`NetworkParameters`数据结构中，我们可以轻松地将程序连接到除主比特币网络之外的其他网络，如TestNet。
- en: Next, we create a new, empty wallet that we’ll set up to receive our coins ➋.
    As discussed earlier, Bitcoin wallets contain one or more Bitcoin addresses, and
    each Bitcoin address consists of a public and a private key. Here ➌, the bitcoinJ
    library creates a new key pair for us. Then, we print out the public address and
    private keys that were generated ➍➎. Finally, we add our new key pair to the wallet
    ➏.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的空钱包，并将其设置为接收我们的比特币➋。如前所述，比特币钱包包含一个或多个比特币地址，每个比特币地址由公钥和私钥组成。这里➌，bitcoinJ库为我们创建了一对新的密钥对。然后，我们打印出生成的公钥地址和私钥
    ➍➎。最后，我们将新的密钥对添加到钱包中 ➏。
- en: '**WARNING**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Usually, when using bitcoinJ, you should reuse the same wallet every time
    the program runs and load/save it every time the program starts/stops or your
    program can lose track of money. This is not an issue for the simple hello-money
    program. However, before you build more sophisticated bitcoinJ programs, read
    “[Gotchas When Using Wallets in BitcoinJ](../Text/app02.html#ch00leve1sec173)”
    on [page 239](../Text/app02.html#page_239).*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*通常，在使用bitcoinJ时，你应该每次运行程序时重用相同的钱包，并在每次程序启动/停止时加载/保存它，否则程序可能会丢失资金。这对简单的hello-money程序不是问题。但是，在构建更复杂的bitcoinJ程序之前，请阅读“[使用比特币钱包时的陷阱](../Text/app02.html#ch00leve1sec173)”[第239页](../Text/app02.html#page_239)。*'
- en: 'Not only does a Bitcoin app need a wallet, it also needs a blockchain. The
    following lines initialize a new blockchain for us:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币应用不仅需要一个钱包，还需要一个区块链。以下几行代码为我们初始化一个新的区块链：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because blockchains consume lots of space, we’ll write it to a file named *my-blockchain*
    ➊. Next, we create a block store, which is an object that manages the data for
    our copious blockchain data ➋. BitcoinJ offers several block store types, all
    with different feature and performance trade-offs. In this example, we’ll use
    an `SPVBlockStore` object, which is usually the best choice for most apps.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于区块链消耗大量空间，我们将其写入一个名为*my-blockchain*的文件➊。接下来，我们创建一个区块存储，它是一个管理我们庞大区块链数据的对象➋。BitcoinJ
    提供了几种不同类型的区块存储，每种类型在特性和性能上都有不同的权衡。在这个示例中，我们将使用一个`SPVBlockStore`对象，它通常是大多数应用的最佳选择。
- en: So what are the trade-offs you need to know about? Well, the biggest performance
    challenge any app that works with bitcoins has to deal with is that the official
    Bitcoin blockchain is larger than 10GB in size. Do most Bitcoin apps *really*
    need all 10GB of the blockchain?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你需要了解哪些权衡呢？最大的性能挑战是，任何与比特币相关的应用都必须处理官方比特币区块链的大小，这个区块链的体积已经超过10GB。大多数比特币应用*真的*需要这10GB的区块链数据吗？
- en: 'To answer this question, let’s consider why the blockchain exists. At a simplified
    level, a Bitcoin blockchain is responsible for two main jobs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，让我们考虑区块链存在的原因。从简化的角度来看，比特币区块链负责两项主要工作：
- en: 1\. Figuring out how much money everyone on the network has
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 确定网络中每个人拥有多少比特币
- en: 2\. Figuring out whether new transactions broadcast across the network are valid
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 确定通过网络广播的新交易是否有效
- en: For the first task, the blockchain allows us to examine all the historical blocks
    in the blockchain and compile comprehensive data about every Bitcoin address ever
    used and how much money each contains. For the second task, it allows us to examine
    new blocks of transactions created by the network and then to verify that these
    blocks have the appropriate hashing information that proves they are correctly
    mined blocks according to the latest difficulty requirements.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个任务，区块链允许我们检查所有历史区块并汇总关于每个比特币地址的综合数据，了解每个地址中包含了多少资金。对于第二个任务，它允许我们检查由网络创建的新交易区块，然后验证这些区块是否包含适当的哈希信息，以证明它们是根据最新难度要求正确挖掘的区块。
- en: 'But consider the first job of the blockchain: Do most apps need to discern
    how much money is in every wallet in existence? No, most apps only need to identify
    the amount of money in *one* or a small number of wallets. Therefore, not all
    10GB of data are needed. The prescient Satoshi, in his original Bitcoin whitepaper,
    was able to see that in this case, an optimization called *Simplified Payment
    Verification (SPV)* was possible.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但考虑一下区块链的第一个任务：大多数应用程序需要辨别每个钱包中的资金数量吗？不，大多数应用程序只需要确定*一个*或少数几个钱包中的资金数量。因此，并不需要全部的
    10GB 数据。先知般的中本聪在他原始的比特币白皮书中能够预见到，在这种情况下，可能会有一种名为 *简化支付验证（SPV）* 的优化方法。
- en: '**NOTE**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We also covered SPV a bit in [Chapter 9](../Text/ch09.html#ch09), when comparing
    different types of Bitcoin wallets.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们在[第九章](../Text/ch09.html#ch09)中也简要介绍了 SPV，讨论了不同类型的比特币钱包时。*'
- en: 'Here’s a quick refresher of how SPV works: If you know you’re interested in
    a single wallet ahead of time, you can just tally up how much money is in that
    one wallet as you pull the entire historical blockchain off the Bitcoin network.
    At that point, you only need to store header information of blocks and can ignore
    information in older blocks entirely in most situations, which is what `SPVBlockStore`
    does. In doing so, the `SPVBlockStore` (as of 2014) is less than 1GB in size,
    less than a one-tenth the size of the official blockchain, and this is why we
    use `SPVBlockChain` to store our data.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是关于 SPV 工作原理的简要回顾：如果你提前知道自己对一个单一钱包感兴趣，你可以在从比特币网络拉取整个历史区块链时，直接统计该钱包中的金额。到那时，你只需要存储区块的头部信息，并且在大多数情况下可以完全忽略旧区块中的信息，这正是
    `SPVBlockStore` 所做的事情。通过这样做，`SPVBlockStore`（截至 2014 年）的大小不到 1GB，只有官方区块链的十分之一，这就是为什么我们使用
    `SPVBlockChain` 来存储我们的数据。
- en: Once we’ve created the block store, we can use it to create a `BlockChain` object
    ➌. Notice that when we create this `BlockChain` object, we must pass in our wallet
    as created. Because we’re not downloading all 10GB, the block-chain object needs
    to know ahead of time which wallets (and their addresses) are important to us
    so it can select the right blockchain data to download.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了区块存储，我们就可以用它来创建一个 `BlockChain` 对象 ➌。请注意，当我们创建这个 `BlockChain` 对象时，我们必须传入我们创建的钱包。因为我们不需要下载全部的
    10GB 数据，区块链对象需要提前知道哪些钱包（及其地址）对我们来说很重要，以便它可以选择正确的区块链数据进行下载。
- en: '**NOTE**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Even though SPVBlockStore is much smaller than the full blockchain, it can
    still take a long time for your app to download all the needed data from the network—usually,
    about 20 minutes. However, it will write this data to a file, and an SPVBlockStore
    object is smart enough to check the supplied file to see whether any data has
    already been downloaded since the last time the program was run. If so, it downloads
    only new data that has arrived after the program was last run.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管 SPVBlockStore 的大小远小于完整的区块链，但仍然可能需要很长时间才能从网络下载所有需要的数据——通常大约需要 20 分钟。然而，它会将这些数据写入文件，并且
    SPVBlockStore 对象足够智能，可以检查提供的文件，看看自上次运行程序以来是否有数据已经下载。如果有，它只会下载自程序上次运行以来到达的新数据。*'
- en: '***Connecting to the Bitcoin Network***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***连接到比特币网络***'
- en: 'With a wallet and a place to store the blockchain data, we can now connect
    to the actual Bitcoin network. A Bitcoin node connects to the Bitcoin network
    by connecting to several semirandom peer nodes. Here is the code that fires up
    a connection to several peers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个钱包和存储区块链数据的位置后，我们现在可以连接到实际的比特币网络。比特币节点通过连接到几个半随机的对等节点来连接到比特币网络。以下是启动与多个对等节点连接的代码：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First we create a `PeerGroup` object ➊ that manages these connections. Next,
    we choose some random peers to connect to. We do this by adding a peer discovery
    algorithm to the `PeerGroup` ➋. The `DnsDiscovery` class basically uses the URLs
    of some well-established and trusted nodes as a starting point to discover peers
    that are willing to accept new connections. Then we add our wallet to the `PeerGroup`
    object ➌.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`PeerGroup`对象 ➊ 来管理这些连接。接下来，我们选择一些随机的节点进行连接。我们通过向`PeerGroup`添加一个节点发现算法来实现这一点
    ➋。`DnsDiscovery`类基本上使用一些经过验证的、可信的节点的URL作为起点，来发现愿意接受新连接的节点。然后，我们将钱包添加到`PeerGroup`对象中
    ➌。
- en: Now we’re finally ready to inject the app into the Bitcoin network! We do this
    by calling `PeerGroup.start` ➍, which will find and connect to some nodes and
    perform the appropriate handshake operations via network sockets. And, like any
    Bitcoin node, we request that the peers send us the blockchain so we can become
    a fully functional node ➎. As mentioned previously, this step will take a while
    to run, but only the first time we run the program.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于准备好将应用程序注入到比特币网络中了！我们通过调用`PeerGroup.start` ➍来实现，这将找到并连接到一些节点，并通过网络套接字执行适当的握手操作。而且，就像任何比特币节点一样，我们要求对等节点向我们发送区块链数据，以便我们能够成为一个完全功能的节点
    ➎。正如之前所提到的，这一步骤需要一些时间来运行，但仅在我们第一次运行程序时需要。
- en: '***Listening for New Money***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***监听新资金***'
- en: 'One last feature we need to add to the `hello-money` program is a hook to detect
    when money has arrived:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向`hello-money`程序添加的最后一个功能是一个钩子，用于检测资金何时到达：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The bitcoinJ wallet object has an `addEventListener` member function, and we
    can create an anonymous class of type `EventListener`, which intercepts and listens
    to different events that might happen to a wallet ➊. In our app, we’re interested
    in the `onCoinsReceived` function ➋, which will be called every time money is
    received by this wallet. Let’s explore in more detail exactly what this means.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: bitcoinJ钱包对象具有一个`addEventListener`成员函数，我们可以创建一个匿名的`EventListener`类，来拦截并监听可能发生在钱包上的不同事件
    ➊。在我们的应用程序中，我们关心的是`onCoinsReceived`函数 ➋，它将在每次收到资金时被调用。让我们更详细地探讨一下这究竟意味着什么。
- en: Because the program lives directly in the Bitcoin network, it can listen to
    the *bitcoin firehose*, a stream of data that contains every Bitcoin transaction
    happening anywhere in the world in close to real time. Each transaction is examined
    to see whether it involves receiving money into any Bitcoin address contained
    in our wallet. In our app, the wallet contains only one address. As soon as this
    transaction arrives (even before it has been incorporated into a mined block),
    our function `onCoinsReceved` will be called.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该程序直接运行在比特币网络中，它可以监听*比特币火流*，这是一个包含全球任何地方发生的每一笔比特币交易的实时数据流。每一笔交易都会被检查，以确定它是否涉及到向我们钱包中的任何比特币地址接收资金。在我们的应用程序中，钱包只包含一个地址。只要这笔交易到达（即使它还没有被纳入挖矿区块），我们的函数`onCoinsReceved`就会被调用。
- en: '**NOTE**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the hello-money program, we won’t worry about capturing confirmation events
    on the money received; we’ll only listen for the transmission of new, unconfirmed
    transactions. However, if we were interested in confirmations, we could capture
    them via the onTransactionConfidenceChanged function. Because we’re running a
    full Bitcoin client, we can do what we want, whereas in [Appendix A](../Text/app01.html#app01)
    we were* forced *to look only at confirmed transactions due to the limitations
    of the JSON-RPC interface.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*在hello-money程序中，我们不需要担心捕获已接收资金的确认事件；我们只会监听新交易（未确认交易）的传输。然而，如果我们对确认感兴趣，我们可以通过onTransactionConfidenceChanged函数捕获它们。因为我们运行的是完整的比特币客户端，我们可以做任何事情，而在[附录A](../Text/app01.html#app01)中，我们*被迫*仅查看已确认的交易，这是由于JSON-RPC接口的限制。*'
- en: 'The `onCoinsReceived` function has four parameters passed into it ➋: the wallet
    object, a transaction object, the previous balance in the wallet, and the new
    balance. The bitcoinJ library uses the Java `BigInteger` class to encode Bitcoin
    balances, because this numerical type can handle very large integers precisely.
    If you’ve written financial software before, you’ll know why the `BigInteger`
    class is used (or you may recall how the bank heist was done in the movie *Office
    Space*). The fact is that it’s very easy to botch a financial transaction due
    to rounding errors, and using big, precise integers prevents this problem. Hence,
    bitcoinJ performs all Bitcoin math using satoshis, the smallest unit of bitcoins,
    which are worth one one-hundred-millionth of a bitcoin.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCoinsReceived` 函数有四个传入参数 ➋：钱包对象、交易对象、钱包中的之前余额和新的余额。bitcoinJ 库使用 Java 的 `BigInteger`
    类来编码比特币余额，因为这种数值类型能够精确处理非常大的整数。如果你之前写过金融软件，你就知道为什么使用 `BigInteger` 类（或者你可能还记得电影
    *Office Space* 中如何策划银行抢劫）。事实上，由于四舍五入错误，金融交易很容易搞砸，而使用大且精确的整数可以防止这个问题。因此，bitcoinJ
    在进行所有比特币数学运算时，都会使用 satoshi——比特币的最小单位，价值为比特币的亿分之一。'
- en: '**NOTE**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Because we added the event listener* after *we downloaded the initial blockchain,
    the onCoinsReceived function will be called* only *when new transactions appear
    as the program is running. If we had declared it before downloading the initial
    blockchain, the design of bitcoinJ is such that onCoinsReceived would also have
    been called on relevant historical transactions.*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*因为我们在* *下载初始区块链后添加了事件监听器，所以 onCoinsReceived 函数只有在程序运行时出现新交易时才会被调用。如果我们在下载初始区块链之前声明它，bitcoinJ
    的设计会导致 onCoinsReceived 也会在相关历史交易中被调用。*'
- en: 'Finally, we put the program into an infinite loop, so the program continues
    running as we wait for money to arrive:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将程序置于一个无限循环中，这样程序会持续运行，直到我们等待钱款到账：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Running and Testing the hello-money Java Program**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运行和测试 hello-money Java 程序**'
- en: 'We’re ready to run and test the program! As before, we first compile and then
    run the program:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好运行并测试程序了！和之前一样，我们首先编译程序，然后运行：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Some messages should then appear as your program connects to the Bitcoin network
    and downloads the blockchain. The first time the program is run, this may take
    a while:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序连接到比特币网络并下载区块链时，一些信息应该会显示出来。第一次运行程序时，这可能需要一些时间：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After the blockchain has finished downloading, you can test the `hello-money`
    program and send it some tiny sum from your favorite wallet app. Simply send 0.0002
    BTC to the public address and record the private key (we’ll be using this money
    in the follow-up example program later in this appendix). The program should detect
    when the money arrives and display a message like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链下载完成后，你可以测试 `hello-money` 程序，并从你喜欢的钱包应用发送少量资金。只需将 0.0002 BTC 发送到公开地址，并记录下私钥（我们将在后续的示例程序中使用这些资金）。程序应该能够检测到资金到账并显示类似以下信息：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The new balance in the wallet should display in satoshis (divide by 100,000,000
    to see that this number is indeed 0.0002 BTC).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 钱包中的新余额应该以 satoshis 显示（除以 100,000,000 即可看到该数值确实为 0.0002 BTC）。
- en: You’ve successfully written a bitcoinJ program that creates a Bitcoin wallet
    and reports on any money received. Now let’s write a second program that uses
    the newly stored money!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功编写了一个 bitcoinJ 程序，它创建了一个比特币钱包，并报告任何收到的资金。现在，让我们编写第二个程序，使用新存储的资金！
- en: '**Bye-Bye Money**'
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**拜拜，钱**'
- en: 'Now, let’s write a brand-new program that can *send* money from an arbitrary
    Bitcoin address. To create a new `bye-bye-money` program, run the following from
    your top-level program directory:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个全新的程序，可以从任意比特币地址*发送*资金。要创建一个新的 `bye-bye-money` 程序，请在顶层程序目录中运行以下命令：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then, make the exact additions to the *pom.xml* file as we did in the `hello-money`
    example, except for the line that reads `<mainClass>hellomoney.App</mainClass>`.
    Change that line to `<mainClass>byebyemoney.App</mainClass>`. (These steps are
    analogous to those we followed for our `hello-money` program in “[Creating a Starter
    Project for hello-money](../Text/app02.html#ch00leve1sec161)” on [page 228](../Text/app02.html#page_228).)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照我们在`hello-money`示例中所做的，准确地对 *pom.xml* 文件进行相同的添加，只是将 `<mainClass>hellomoney.App</mainClass>`
    这一行改为 `<mainClass>byebyemoney.App</mainClass>`。（这些步骤类似于我们在 “[为 hello-money 创建一个启动项目](../Text/app02.html#ch00leve1sec161)”
    中的操作，见[第 228 页](../Text/app02.html#page_228)）
- en: 'Just as before, open the file *src/main/java/byebyemoney/App.java* and replace
    its contents with the following program:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就像以前一样，打开文件*src/main/java/byebyemoney/App.java*，并将其内容替换为以下程序：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Many of the lines in this new program are shared with our previous `hello-money`
    program, but let’s look carefully at the new parts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 新程序中的许多行与我们之前的`hello-money`程序共享，但让我们仔细看一下新的部分。
- en: '***Importing a Private Key***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导入私钥***'
- en: 'To send money from our program, we need to import the private key of the Bitcoin
    address from the previous example. Here is the code that does this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的程序发送资金，我们需要导入前一个示例中的比特币地址的私钥。下面是执行此操作的代码：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the first lines, we’re explicitly adding a new, preexisting private key to
    our wallet ➊➋. This is the key associated with the Bitcoin address that received
    the money in the `hello-money` program. You need to replace the private key shown
    on this line with the private key you wrote down when running the previous example.
    Also, in this new program we’re not using the `SPVBlockStore` function; instead,
    we’re using bitcoinJ’s `MemoryBlockStore` ➌ function for variety. This block store
    won’t create a file, but by using it, our program will need to redownload the
    blockchain every time the program runs. (This also guarantees that bitcoinJ will
    assign the correct balance to the wallet. We’ll discuss why in “Gotchas When Using
    Wallets in BitcoinJ” on [page 239](../Text/app02.html#page_239).)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几行中，我们显式地将一个新的、已有的私钥添加到我们的钱包中 ➊➋。这是与在`hello-money`程序中接收资金的比特币地址相关的私钥。你需要将这一行中显示的私钥替换为你在运行之前示例时写下的私钥。此外，在这个新程序中，我们不使用`SPVBlockStore`功能；相反，我们使用bitcoinJ的`MemoryBlockStore`
    ➌功能作为变体。这个块存储不会创建文件，但通过使用它，我们的程序每次运行时都需要重新下载区块链。（这也保证了bitcoinJ会将正确的余额分配给钱包。我们将在《使用BitcoinJ钱包时的陷阱》一节中讨论原因，见[第239页](../Text/app02.html#page_239)。）
- en: '***Sending the Money***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***发送资金***'
- en: 'Now let’s look at the code that actually sends the money:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看实际上发送资金的代码：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we get the balance contained in the wallet ➊ and display it ➋. Next,
    we declare the destination address the money should be sent to ➌. In this example,
    we input the main donation address for the Bitcoin Foundation; feel free to substitute
    a public address of one of your own wallets.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取钱包中包含的余额 ➊ 并显示它 ➋。接下来，我们声明资金应该发送到的目标地址 ➌。在此示例中，我们输入比特币基金会的主要捐赠地址；你可以自由替换为你自己钱包的公开地址。
- en: Nowadays, it’s best to include a transaction fee when sending bitcoins, which
    we declare to be 10,000 satoshis ➍. Next, we create a `SendRequest` object ➎,
    which is a structure to hold the basic information about what we’re sending and
    includes the destination address and the amount to be sent (which is the balance
    minus the fee). Then, we set the fee on this object ➏ and send our money ➐!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，发送比特币时最好包含交易费用，我们声明费用为10,000聪 ➍。接下来，我们创建一个`SendRequest`对象 ➎，这是一个结构体，用于保存我们正在发送的基本信息，包括目标地址和要发送的金额（即余额减去费用）。然后，我们在这个对象上设置费用
    ➏，并发送我们的资金 ➐！
- en: '***Ensuring the Money Transmission***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***确保资金传输***'
- en: 'If we try to send more money than we have, if the fee is inadequate, or if
    the Internet connection drops out at the wrong moment, the money might never be
    accepted by the network. Therefore, we need to write code that waits and ensures
    that the money we sent is transmitted to the network. Here’s what we’ll add to
    do this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试发送比我们拥有的更多资金，如果费用不足，或者如果在错误的时刻互联网连接中断，资金可能永远不会被网络接受。因此，我们需要编写代码，等待并确保我们发送的资金传输到网络。以下是我们为此添加的代码：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first line of code ➊ retrieves a Java *future* object, which indicates that
    the send transaction has been properly broadcast to the network. (A standard in
    Java, futures retrieve information about a separate execution thread—in this case
    the thread that monitors communication with the Bitcoin network.) If this line
    completes without throwing an exception, we display a message indicating that
    the money was sent ➋.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行 ➊ 获取一个Java *future*对象，这表明发送的交易已经正确地广播到网络。（Java中的标准，future用于获取关于单独执行线程的信息——在此情况下，是监控与比特币网络通信的线程。）如果这一行没有抛出异常，则我们会显示一条消息，表示资金已发送
    ➋。
- en: '***Running bye-bye-money***'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行 bye-bye-money***'
- en: 'We can run `bye-bye-money` in the usual way (remember to input your own private
    key):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像往常一样运行`bye-bye-money`（记得输入你自己的私钥）：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**EXCEPTION TYPES IN BITCOINJ**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**比特币J中的异常类型**'
- en: 'One feature we skimped on in this example is error handling: The main function
    simply rethrows a variety of different exceptions for operations that can go wrong
    as we attempt to send our money. These include the following exceptions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们省略了一个功能：错误处理。主函数简单地重新抛出了一些不同的异常，处理在发送资金时可能出现的错误。这些包括以下异常：
- en: '• `BlockStoreException`: This is thrown when the block store cannot be created
    (most commonly, this happens with block store types that write to a file when
    something corrupts the file).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: • `BlockStoreException`：当无法创建区块存储时，会抛出此异常（最常见的情况是，使用写入文件的区块存储类型时，文件损坏导致无法创建）。
- en: '• `AddressFormatException`: This is thrown when the format of the address is
    incorrect.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: • `AddressFormatException`：当地址格式不正确时，会抛出此异常。
- en: '• `InterruptedException`: This is thrown when network connection problems occur.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: • `InterruptedException`：当发生网络连接问题时，会抛出此异常。
- en: '• `ExecutionException`: This is thrown when we’re using a future object and
    an exception occurs in the other thread (as happens when we check for completion
    of the transaction broadcast).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: • `ExecutionException`：当我们使用 future 对象并且在其他线程中发生异常时，会抛出此异常（例如，当我们检查交易广播是否完成时）。
- en: In a more sophisticated Bitcoin app, you should catch all of these exception
    types separately and add more descriptive error messages for your app’s users.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的比特币应用中，你应该单独捕获所有这些异常类型，并为应用用户添加更具描述性的错误信息。
- en: Because this program churns through the blockchain in memory, you’ll need to
    wait a few minutes or more for it to complete (even when you rerun it). If the
    program is successful, you’ll see the message *The money was sent!*, and the money
    should arrive at the destination wallet. You can also access a blockchain information
    site (such as *[http://blockchain.info/](http://blockchain.info/)*), enter the
    source or destination address, and see that the details of the transaction are
    part of the public record.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该程序在内存中处理区块链，因此你需要等待几分钟或更长时间才能完成（即使你重新运行它）。如果程序成功，你将看到消息*资金已发送！*，资金应该到达目标钱包。你还可以访问区块链信息网站（如
    *[http://blockchain.info/](http://blockchain.info/)*），输入源地址或目标地址，查看交易的详细信息是否已成为公共记录的一部分。
- en: Congratulations! You now understand the basics of writing a Bitcoin application!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经了解了编写比特币应用的基础知识！
- en: '**Gotchas When Using Wallets in BitcoinJ**'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Wallets 在 BitcoinJ 中的注意事项**'
- en: To the novice, the way wallets and the `BlockChain` object work in bitcoinJ
    can be very confusing. If you don’t fully understand bitcoinJ’s behavior, bitcoinJ
    can also report incorrect wallet balances.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新手来说，钱包和 `BlockChain` 对象在 bitcoinJ 中的工作方式可能非常令人困惑。如果你没有完全理解 bitcoinJ 的行为，bitcoinJ
    可能会报告不正确的钱包余额。
- en: 'This happens because bitcoinJ is optimized around the concept of an SPV blockchain.
    The performance benefits of SPV blockchains were discussed earlier, but because
    they contain only limited blockchain data, you need to follow a few basic rules
    to ensure they work properly for you in bitcoinJ:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这发生的原因是 bitcoinJ 针对 SPV 区块链的概念进行了优化。我们之前讨论过 SPV 区块链的性能优势，但由于它们只包含有限的区块链数据，你需要遵循一些基本规则，以确保它们在
    bitcoinJ 中正常工作：
- en: 1\. If your app’s wallet already has money in it, bitcoinJ needs to know the
    amount *before* the blockchain is downloaded from the network.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 如果你的应用钱包中已经有余额，bitcoinJ 需要在从网络下载区块链之前，了解余额的数量*。
- en: 2\. After the blockchain is loaded, bitcoinJ will perform the necessary tasks
    to ensure the wallet’s accuracy as new transactions appear on the network.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 区块链加载完成后，bitcoinJ 将执行必要的任务，以确保钱包在网络上出现新交易时的准确性。
- en: 3\. If you use a block store type that supports saving to a disk file, your
    app is responsible for saving the wallet to a file, as well (it is also responsible
    for loading the block store and wallet data).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 如果你使用的是支持保存到磁盘文件的区块存储类型，那么你的应用也需要负责将钱包保存到文件（同样，它还需要负责加载区块存储和钱包数据）。
- en: 'As you saw when we constructed a `BlockChain` object, bitcoinJ expects the
    app to pass in a wallet object. This allows the wallet to be updated when relevant
    *historical* transactions are found in downloaded blocks and allows rule #1 to
    be enforced: *Be sure not to add additional keys to your wallet after the fact
    and expect your wallet to work without redownloading the blockchain.*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们在构造 `BlockChain` 对象时所看到的，bitcoinJ 期望应用程序传递一个钱包对象。这使得当下载的区块中发现相关的*历史*交易时，可以更新钱包，并确保规则
    #1 被执行：*确保在事后不向钱包中添加额外的密钥，并期望钱包在不重新下载区块链的情况下正常工作*。'
- en: 'Similarly, when we initialized the `PeerGroup` object, we called `addWallet()`
    to add our wallet to the peer group. By doing so, bitcoinJ keeps the wallet balance
    in sync with any *new* transactions that appear in the Bitcoin network as the
    program is running, enforcing rule #2.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们初始化`PeerGroup`对象时，我们调用了`addWallet()`将我们的钱包添加到对等组中。通过这样做，bitcoinJ保持钱包余额与比特币网络中出现的任何*新*交易同步，同时遵循规则#2。
- en: 'To make sure rule #3 is adhered to, you can use the `Wallet.loadFromFile()`
    and `Wallet.saveToFile()`functions. A `Wallet.autoSaveToFile()` function is also
    available that can help with loading and saving the block store and wallet data.
    To learn how to use these functions properly, look at the example programs in
    the bitcoinJ repository.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保遵循规则#3，你可以使用`Wallet.loadFromFile()`和`Wallet.saveToFile()`函数。同时，还有一个`Wallet.autoSaveToFile()`函数，它可以帮助加载和保存区块存储和钱包数据。要了解如何正确使用这些函数，请查看bitcoinJ库中的示例程序。
- en: If you keep the previously listed three basic tenets in mind, you’ll avoid most
    of the pitfalls that accompany mastering bitcoinJ.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记住之前列出的三个基本原则，你将避免大多数掌握bitcoinJ过程中可能遇到的陷阱。
- en: '**Conclusion**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: We hope you’ve enjoyed this tour of bitcoinJ programming, and we look forward
    to seeing any awesome new apps that you build. After all, the app you build just
    might completely reinvent how people interact with their money in the Internet
    age!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你享受了这次关于bitcoinJ编程的旅程，我们期待看到你所开发的任何精彩新应用。毕竟，你构建的应用可能会彻底改变人们在互联网时代与金钱互动的方式！
