- en: '**8**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8**'
- en: MAKE SECRET MESSAGES A PHONE APP TO SHARE WITH FRIENDS!
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将“秘密消息”做成手机应用与朋友分享！
- en: '![Image](../images/circle.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/circle.jpg)'
- en: In this chapter, we’ll complete our Secret Messages app experience by building
    a mobile app version that can send secret messages by text or email and can even
    post to social media.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过构建一个可以通过文本或电子邮件发送秘密消息并可以发布到社交媒体的移动应用版本，完成我们的秘密消息应用体验。
- en: The app will look similar to the GUI version in [Chapter 7](ch7.xhtml#ch7),
    with labels, text fields, and the ability to slide through different key values
    to quickly encode and decode messages. You’ll also be able to copy and paste messages
    from the app into emails and text messages, but by the end of the chapter, you’ll
    be able to send an email or text directly from the Secret Messages app itself!
    [Figure 8-1](ch8.xhtml#ch8fig1) shows the app in action on a real Android device.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用将类似于[第 7 章](ch7.xhtml#ch7)中的 GUI 版本，具有标签、文本框，并能够滑动不同的密钥值，以便快速编码和解码消息。您还可以将应用中的消息复制并粘贴到电子邮件和短信中，但在本章结束时，您将能够直接从“秘密消息”应用内发送电子邮件或短信！[图
    8-1](ch8.xhtml#ch8fig1)展示了该应用在真实 Android 设备上的运行效果。
- en: '![Image](../images/f0176-01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0176-01.jpg)'
- en: '*Figure 8-1: The Secret Messages encoder/decoder app (left) can send secret
    text and email messages directly from inside the app, at just the touch of a button
    (right).*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：秘密消息编码器/解码器应用（左）可以直接从应用内发送秘密文本和电子邮件消息，只需按一下按钮（右）。*'
- en: We’ll reuse the working code from the desktop app by keeping the names of the
    GUI components in the Android version and by taking advantage of Java’s consistent
    language and structure across multiple platforms.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过保持 Android 版本中 GUI 组件的名称，并利用 Java 在多个平台上保持一致的语言和结构，重用桌面应用中的工作代码。
- en: Setting Up the Mobile GUI
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置移动端 GUI
- en: Let’s begin building the Secret Messages app with Android Studio. Android Studio
    may ask you to perform updates as you open the program, which is usually a good
    idea. Updating carries a bit of risk, as it can change the look and feel of the
    program by moving icons or menu items, but the updates also include important
    new security fixes and the latest Android features.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用 Android Studio 构建“秘密消息”应用。打开 Android Studio 时，程序可能会要求您进行更新，这通常是一个好主意。更新存在一定风险，因为它可能会通过移动图标或菜单项改变程序的外观和感觉，但更新也包括重要的安全修复和最新的
    Android 特性。
- en: When you first open Android Studio, you may see the most recent project you
    were working on—in our case, the Hi-Lo guessing game app. You can close it by
    selecting **File** ▸ **Close Project**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次打开 Android Studio 时，您可能会看到您最近正在处理的项目——在我们的例子中是 Hi-Lo 猜数字游戏应用。您可以通过选择**文件**
    ▸ **关闭项目**来关闭它。
- en: To begin building the new Secret Messages app, either select **File** ▸ **New
    Project** from inside Android Studio or choose **Start a new Android Studio project**
    from the Welcome screen.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建新的“秘密消息”应用，您可以在 Android Studio 内部选择**文件** ▸ **新建项目**，或者从欢迎界面选择**开始一个新的
    Android Studio 项目**。
- en: Name the new project `SecretMessages`, save it in your preferred location, and
    click **Next**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将新项目命名为`SecretMessages`，保存在您首选的位置，然后点击**下一步**。
- en: 'On the Target Android Devices screen, choose **API 16: Android 4.1 (Jelly Bean)**
    for the **Phone and Tablet Minimum SDK**, as we did for the Hi-Lo guessing game
    app, and then click **Next**. Choose **Basic Activity** on the Add an Activity
    screen and click **Next**. On the Customize the Activity screen, keep all the
    default names and click **Finish**.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '在目标 Android 设备屏幕上，选择**API 16: Android 4.1 (Jelly Bean)**作为**手机和平板最低 SDK**，就像我们在
    Hi-Lo 猜数字游戏应用中所做的那样，然后点击**下一步**。在添加活动屏幕上选择**基本活动**，然后点击**下一步**。在自定义活动屏幕上，保持所有默认名称并点击**完成**。'
- en: It may take a moment for the new project to configure and open. When the new
    project opens, double-click the *content_main.xml* file under *app* ▸ *res* ▸
    *layout* in the Project Explorer on the left. You may need to close a pop-up message
    about the floating action button (we’ll use that later).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 新项目配置并打开可能需要一段时间。当新项目打开时，双击项目资源管理器左侧的*content_main.xml*文件，路径为*app* ▸ *res* ▸
    *layout*。你可能需要关闭关于浮动操作按钮的弹出消息（我们稍后会用到它）。
- en: Your screen should look similar to [Figure 8-2](ch8.xhtml#ch8fig2). (You may
    have to click the Design tab to see the GUI preview.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您的屏幕应该类似于[图 8-2](ch8.xhtml#ch8fig2)所示。（您可能需要点击设计标签才能查看 GUI 预览。）
- en: '![Image](../images/f0177-01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0177-01.jpg)'
- en: '*Figure 8-2: The starting view of the app in Android Studio*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：应用在 Android Studio 中的初始视图*'
- en: Designing the Mobile GUI
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计移动端 GUI
- en: 'Now that we have a new project set up, let’s start designing the layout of
    our app. First, delete the “Hello World!” text shown in the design preview by
    clicking to select it and then pressing the DELETE key. Then, as we did in the
    previous app, let’s add a RelativeLayout to hold our GUI elements: in the Palette
    pane, under Layouts, select **RelativeLayout** and drag it onto the Preview pane
    or onto the ConstraintLayout under the Component Tree.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个新项目，让我们开始设计应用的布局。首先，通过点击选择设计预览中的“Hello World!”文本，然后按DELETE键删除它。接下来，像在之前的应用中一样，我们将添加一个RelativeLayout来容纳我们的GUI元素：在“调色板”面板中，选择“布局”下的**RelativeLayout**并将其拖动到预览面板或组件树下的ConstraintLayout中。
- en: Next, let’s add a title to the top of the app by selecting the **TextView**
    widget under Widgets in the Palette. Place the `TextView` widget at the top center
    of the screen, change the text to `Your Name``'s Secret Messages App`, and then
    change the `textAppearance` property in the Properties pane to **Material.Large**,
    as I’ve done in [Figure 8-3](ch8.xhtml#ch8fig3).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过选择“调色板”中小部件下的**TextView**小部件，在应用的顶部添加一个标题。将`TextView`小部件放置在屏幕的顶部居中位置，文本更改为`Your
    Name``'s Secret Messages App`，然后将“属性”面板中的`textAppearance`属性更改为**Material.Large**，如我在[图
    8-3](ch8.xhtml#ch8fig3)中所做的那样。
- en: '![Image](../images/f0178-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0178-01.jpg)'
- en: '*Figure 8-3: Add a Large text title to the top center of your app, customizing
    it with your name.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：为应用的顶部中心添加一个大号文本标题，使用你的名字进行自定义。*'
- en: In the Properties pane, expand **textAppearance** to find **textStyle** and
    click the **bold** checkbox to make the title text stand out more.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在“属性”面板中，展开**textAppearance**以找到**textStyle**，然后勾选**bold**复选框，使标题文本更加突出。
- en: Now, let’s place the `EditText` text fields for the user’s input message. In
    the Palette, under Text, select **Multiline Text**. Zoom in on the design preview
    and place the text field about 30 dp below the title. Change the text to `Secret
    messages \n are so cool, \n aren't they?` as shown in [Figure 8-4](ch8.xhtml#ch8fig4).
    The `\n` escape sequence will add *newline characters*; these characters don’t
    show up onscreen, but they represent the new line you get by pressing ENTER on
    the keyboard. Putting the text across multiple lines shows the user they can enter
    a multiline message as well.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们放置`EditText`文本字段以接收用户的输入消息。在“调色板”中，选择“文本”下的**Multiline Text**。放大设计预览，将文本字段放置在标题下方大约30
    dp的位置。将文本更改为`Secret messages \n are so cool, \n aren't they?`，如[图 8-4](ch8.xhtml#ch8fig4)所示。`\n`转义序列将添加*换行符*；这些字符不会显示在屏幕上，但它们表示按下键盘上的ENTER键时获得的新行。将文本分成多行可以向用户显示他们也可以输入多行消息。
- en: '![Image](../images/f0178-02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0178-02.jpg)'
- en: '*Figure 8-4: Add a Multiline Text field for the user’s input message, using
    the \n escape sequence to span multiple lines of text.*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：为用户的输入消息添加一个多行文本字段，使用\n转义序列跨越多行文本。*'
- en: You can also change the number of lines of text that a user can see at any one
    time. Under the expanded Properties pane for the Multiline Text, you can change
    the `lines` property to `4`, for example. To be able to see the multiline message
    across all devices, select the **textMultiLine** checkbox in the `inputType` property’s
    drop-down list.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以更改用户一次可以看到的文本行数。在Multiline Text的扩展“属性”面板下，你可以将`lines`属性更改为`4`，例如。为了确保在所有设备上都能看到多行消息，请在`inputType`属性的下拉列表中选中**textMultiLine**复选框。
- en: Finally, let’s change the input text field’s `id` property to `txtIn`, both
    to help us use it in the code later and to maintain naming consistency with the
    GUI desktop version of the app. Now drag the left and right borders of the text
    field to stretch it to the full width of the app, as shown in [Figure 8-5](ch8.xhtml#ch8fig5).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将输入文本字段的`id`属性更改为`txtIn`，这不仅有助于我们稍后在代码中使用它，而且还保持与GUI桌面版本应用的一致命名。现在，拖动文本字段的左、右边界，将其拉伸到应用的整个宽度，如[图
    8-5](ch8.xhtml#ch8fig5)所示。
- en: '![Image](../images/f0179-01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0179-01.jpg)'
- en: '*Figure 8-5: Change the id of the input text field to txtIn so that we can
    code with it later.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-5：将输入文本字段的id更改为txtIn，以便我们稍后可以在代码中使用它。*'
- en: 'We’re going to add four components to the middle of the Secret Messages app:
    a `SeekBar` for the user to swipe a bar to find a key, a label, a text field to
    display the secret key, and an Encode/Decode button. The `SeekBar` will function
    similarly to the `JSlider` in the desktop version of the app. Don’t worry if all
    your components don’t line up perfectly when you first place them—we’ll be able
    to fix that later.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向秘密信息应用的中间部分添加四个组件：一个`SeekBar`，让用户滑动条来查找密钥，一个标签，一个显示秘密密钥的文本字段，以及一个编码/解码按钮。`SeekBar`的功能类似于桌面版应用中的`JSlider`。如果你刚开始放置组件时它们没有完全对齐，不要担心——我们稍后会修复这个问题。
- en: First, find the `SeekBar` in the Widgets section of the Palette pane. Place
    it a comfortable margin, 30 dp or so, below the input text field along the left
    margin, as shown in [Figure 8-6](ch8.xhtml#ch8fig6). You can set the top margin
    manually in the Properties pane by going to **View all properties** (the left
    and right double-arrows at the top of the Properties pane). Under **Layout_Margin**,
    enter `30dp` for the **layout_marginTop**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在调色板面板的“Widgets”部分找到`SeekBar`。将其放置在输入文本字段下方30dp左右的合适间距位置，沿左边缘，如[图8-6](ch8.xhtml#ch8fig6)所示。你可以在属性面板中通过点击**查看所有属性**（属性面板顶部的左右双箭头）手动设置顶部边距。在**Layout_Margin**下，将`layout_marginTop`设置为`30dp`。
- en: '![Image](../images/f0180-01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0180-01.jpg)'
- en: '*Figure 8-6: The SeekBar will function like the slider in the GUI desktop version
    of the app, allowing the user to slide among different key values.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-6：SeekBar将像应用的桌面版中的滑块一样运行，允许用户在不同的密钥值之间滑动。*'
- en: Next, add a `TextView` widget beside the `SeekBar` to serve as a label for the
    text field of the user’s secret key value. Change the `textAppearance` property
    to **Material.Medium** and the `text` property to **Key:** in the Properties pane.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`SeekBar`旁边添加一个`TextView`小部件，作为用户秘密密钥值文本字段的标签。在属性面板中，将`textAppearance`属性更改为**Material.Medium**，并将`text`属性更改为**Key:**。
- en: Then, select a **Number** text field for the user’s secret key value and center
    it horizontally, with a text property of `13` or another default key value of
    your choice. Modify the width of the text field to fit the number comfortably
    by changing its `width` property (under **View all properties**) to approximately
    `40dp`, and then change the `id` property to `txtKey`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择一个**Number**文本字段作为用户的秘密密钥值，并将其水平居中，文本属性设置为`13`或你选择的其他默认密钥值。通过更改文本字段的`width`属性（在**查看所有属性**下）大约设置为`40dp`，使其宽度适应数字，然后将`id`属性更改为`txtKey`。
- en: With the `txtKey` text field in place, you should be able to drag the `Key:`
    label over to be directly beside it. You should also be able to stretch the `SeekBar`
    to fill the gap, as shown in [Figure 8-7](ch8.xhtml#ch8fig7).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将`txtKey`文本字段放置好后，你应该能够将`Key:`标签拖动到它旁边。你也应该能够拉伸`SeekBar`以填充空隙，如[图8-7](ch8.xhtml#ch8fig7)所示。
- en: Complete the middle row of the layout by adding the Encode/Decode button. Choose
    **Button** under Widgets in the Palette and insert the button along the right
    margin beside the text field. Change the `text` property to `Encode/Decode`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加编码/解码按钮来完成布局的中间行。在调色板中的“Widgets”下选择**Button**，并将按钮插入到文本字段旁边的右边缘。将`text`属性更改为`Encode/Decode`。
- en: Finally, create a text field for the output message by copying the `txtIn` text
    field and pasting it below the middle row of widgets. Delete the text in the text
    field, stretch it to the width of the app window, and rename the `id` property
    to `txtOut`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过复制`txtIn`文本字段并将其粘贴到中间行小部件下方来创建输出消息的文本字段。删除文本字段中的文本，拉伸它以适应应用窗口的宽度，并将`id`属性重命名为`txtOut`。
- en: '![Image](../images/f0181-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0181-01.jpg)'
- en: '*Figure 8-7: After placing the txtKey text field, adjust the placement of the
    Key: label and stretch the SeekBar*.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-7：放置`txtKey`文本字段后，调整`Key:`标签的位置并拉伸SeekBar。*'
- en: That’s it—the finished GUI layout is shown in [Figure 8-8](ch8.xhtml#ch8fig8).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——完成的GUI布局如[图8-8](ch8.xhtml#ch8fig8)所示。
- en: '![Image](../images/f0181-02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0181-02.jpg)'
- en: '*Figure 8-8: The finished layout for the Secret Messages mobile app*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-8：完成的秘密信息移动应用布局*'
- en: Before moving on, make sure your input text field has an `id` of `txtIn`, the
    output text is `txtOut`, and the middle text field for the key is `txtKey`. We’ll
    need all of these elements to be correctly named in order for the code to work
    in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，确保你的输入文本字段的`id`为`txtIn`，输出文本字段为`txtOut`，中间的密钥文本字段为`txtKey`。为了确保代码在下一部分正常工作，我们需要正确命名这些元素。
- en: Wiring the GUI to the Java Code
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将GUI连接到Java代码
- en: It’s time to connect the GUI layout to the Java source code to begin programming
    the behavior of the Secret Messages mobile app. Switch to the *MainActivity.java*
    file by clicking the tab at the upper left of the main content window.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将 GUI 布局连接到 Java 源代码，开始编程秘密消息移动应用的行为了。通过点击主内容窗口左上角的标签切换到 *MainActivity.java*
    文件。
- en: 'Add the following five lines directly to the `public class` `MainActivity`
    declaration:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下五行代码直接添加到 `public class` `MainActivity` 声明中：
- en: public class MainActivity extends AppCompatActivity {
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: public class MainActivity extends AppCompatActivity {
- en: EditText txtIn;
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: EditText txtIn;
- en: EditText txtKey;
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: EditText txtKey;
- en: EditText txtOut;
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: EditText txtOut;
- en: SeekBar sb;
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SeekBar sb;
- en: Button btn;
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Button btn;
- en: You may need to press ALT-ENTER or OPTION-ENTER after each line to import the
    widgets into the Java code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要在每行后按 ALT-ENTER 或 OPTION-ENTER 来导入小部件到 Java 代码中。
- en: 'These five variables point to the GUI components in the visual layout for the
    app. We can connect these variable names to the actual widgets by adding five
    lines of code to the `onCreate()` method, right below the `setSupportActionBar(toolbar);`
    statement:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个变量指向应用视觉布局中的 GUI 组件。我们可以通过向 `onCreate()` 方法中添加五行代码，将这些变量名连接到实际的小部件，代码放在 `setSupportActionBar(toolbar);`
    语句下方：
- en: protected void onCreate(Bundle savedInstanceState) {
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: protected void onCreate(Bundle savedInstanceState) {
- en: super.onCreate(savedInstanceState);
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: super.onCreate(savedInstanceState);
- en: setContentView(R.layout.*activity_main*);
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: setContentView(R.layout.*activity_main*);
- en: Toolbar toolbar = (Toolbar) findViewById(R.id.*toolbar*);
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Toolbar toolbar = (Toolbar) findViewById(R.id.*toolbar*);
- en: setSupportActionBar(toolbar);
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: setSupportActionBar(toolbar);
- en: txtIn = (EditText)findViewById(R.id.*txtIn*);
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: txtIn = (EditText)findViewById(R.id.*txtIn*);
- en: txtKey = (EditText)findViewById(R.id.*txtKey*);
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: txtKey = (EditText)findViewById(R.id.*txtKey*);
- en: txtOut = (EditText)findViewById(R.id.*txtOut*);
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: txtOut = (EditText)findViewById(R.id.*txtOut*);
- en: sb = (SeekBar)findViewById(R.id.*seekBar*);
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: sb = (SeekBar)findViewById(R.id.*seekBar*);
- en: btn = (Button)findViewById(R.id.*button*);
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: btn = (Button)findViewById(R.id.*button*);
- en: You can rely on Android Studio’s code assist to autocomplete most of these entries—all
    you have to do is type the first few characters, then click the entry from the
    list or press ENTER to accept the code recommendation. It’s faster and will help
    you avoid common typing errors.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以依赖 Android Studio 的代码助手来自动完成这些输入——你只需输入前几个字符，然后从列表中点击选项，或者按 ENTER 接受代码推荐。这更快，并且能帮助你避免常见的输入错误。
- en: '*Connecting the Encode Button to the encode() Method*'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*将 Encode 按钮连接到 encode() 方法*'
- en: Now that we have the code connected to the components in the GUI layout, we
    can copy the `encode()` method from the desktop version of the app from [Chapter
    7](ch7.xhtml#ch7). We’ll paste the method into the `public class MainActivity`
    declaration, right below the five lines you added declaring the variables that
    point to the GUI components in the layout.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将代码连接到 GUI 布局中的组件，可以从应用的桌面版本的 [第 7 章](ch7.xhtml#ch7) 中复制 `encode()` 方法。我们将这个方法粘贴到
    `public class MainActivity` 声明中，紧接在你添加的五行代码之后，这些代码用于声明指向布局中 GUI 组件的变量。
- en: 'Open your *SecretMessagesGUI* desktop project in Eclipse and highlight the
    entire `encode()` method. Copy this code and paste it into the `public class MainActivity`
    declaration in Android Studio:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你在 Eclipse 中的 *SecretMessagesGUI* 桌面项目，选中整个 `encode()` 方法。复制这段代码并将其粘贴到 Android
    Studio 中的 `public class MainActivity` 声明部分：
- en: public class MainActivity extends AppCompatActivity {
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: public class MainActivity extends AppCompatActivity {
- en: EditText txtIn;
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: EditText txtIn;
- en: EditText txtKey;
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: EditText txtKey;
- en: EditText txtOut;
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: EditText txtOut;
- en: SeekBar sb;
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: SeekBar sb;
- en: Button btn;
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Button btn;
- en: public String encode( String message, int keyVal ) {
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: public String encode( String message, int keyVal ) {
- en: String output = "";
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: String output = "";
- en: char key = (char) keyVal;
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: char key = (char) keyVal;
- en: for ( int x = 0; x < message.length(); x++ ) {
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: for ( int x = 0; x < message.length(); x++ ) {
- en: char input = message.charAt(x);
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: char input = message.charAt(x);
- en: if (input >= 'A' && input <= 'Z')
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: if (input >= 'A' && input <= 'Z')
- en: '{'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += key;
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: input += key;
- en: if (input > 'Z')
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: if (input > 'Z')
- en: input -= 26;
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: input -= 26;
- en: if (input < 'A')
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: if (input < 'A')
- en: input += 26;
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: input += 26;
- en: '}'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if (input >= 'a' && input <= 'z')
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: else if (input >= 'a' && input <= 'z')
- en: '{'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += key;
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: input += key;
- en: if (input > 'z')
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: if (input > 'z')
- en: input -= 26;
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: input -= 26;
- en: if (input < 'a')
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: if (input < 'a')
- en: input += 26;
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: input += 26;
- en: '}'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else if (input >= '0' && input <= '9')
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: else if (input >= '0' && input <= '9')
- en: '{'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: input += (keyVal % 10);
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: input += (keyVal % 10);
- en: if (input > '9')
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: if (input > '9')
- en: input -= 10;
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: input -= 10;
- en: if (input < '0')
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: if (input < '0')
- en: input += 10;
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: input += 10;
- en: '}'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: output += input;
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: output += input;
- en: '}'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return output;
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: return output;
- en: '}'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Now that we have the `encode()` method in place, we just need to call that method
    whenever the Encode/Decode button is clicked. We’ll create an `OnClickListener`
    for the Encode/Decode button and call the `encode()` method from there.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了`encode()`方法，我们只需要在点击Encode/Decode按钮时调用该方法。我们将为Encode/Decode按钮创建一个`OnClickListener`并从那里调用`encode()`方法。
- en: Inside the `onCreate()` method in *MainActivity.java*, start typing the code
    `btn.setOnCl` until a code recommendation list pops up, as shown in [Figure 8-9](ch8.xhtml#ch8fig9).
    On the list, choose `setOnClickListener()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity.java`的`onCreate()`方法内，开始输入代码`btn.setOnCl`，直到弹出一个代码推荐列表，如[图 8-9](ch8.xhtml#ch8fig9)所示。在列表中，选择`setOnClickListener()`。
- en: '![Image](../images/f0184-01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0184-01.jpg)'
- en: '*Figure 8-9: You can rely on code recommendations from Android Studio to autofill
    code for you, as shown here with the setOnClickListener() for the Encode/Decode
    button.*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-9：你可以依靠Android Studio的代码推荐来自动填充代码，如这里显示的Encode/Decode按钮的setOnClickListener()。*'
- en: 'After clicking the `setOnClickListener()` code recommendation, click inside
    the parentheses of that method and begin typing `new OnClickListener`, as shown
    in [Figure 8-10](ch8.xhtml#ch8fig10), double-clicking the first code recommendation
    that pops up:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击`setOnClickListener()`代码推荐后，点击该方法的括号内并开始输入`new OnClickListener`，如[图 8-10](ch8.xhtml#ch8fig10)所示，双击弹出的第一个代码推荐：
- en: '![Image](../images/f0184-02.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0184-02.jpg)'
- en: '*Figure 8-10: Use the code assist once more to fill in the OnClickListener*.
    *This time, Android Studio provides several lines of code.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-10：再次使用代码助手来填充OnClickListener*。*这次，Android Studio提供了几行代码。*'
- en: 'You’ll notice that Android Studio fills in several lines of code for you for
    the `OnClickListener()` event handler:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，Android Studio为你填充了`OnClickListener()`事件处理程序的几行代码：
- en: btn.setOnClickListener(new View.OnClickListener() {
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: btn.setOnClickListener(new View.OnClickListener() {
- en: '@Override'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public void onClick(View v) {
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: public void onClick(View v) {
- en: '}'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: These few lines create an event listener using an anonymous inner class of type
    `View.OnClickListener()`, with an `onClick()` event handler to respond when the
    user clicks the button.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这几行代码创建了一个事件监听器，使用匿名内部类`View.OnClickListener()`，并通过`onClick()`事件处理程序来响应用户点击按钮时的操作。
- en: Next we’ll set up the `encode()` method. `encode()` doesn’t care what’s happening
    in the rest of our code as long as we give it two arguments that are the right
    data types. This means we don’t have to change `encode()` to fit our new app,
    but we do need to set up new values to give it as arguments.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置`encode()`方法。`encode()`方法并不关心我们代码的其他部分，只要我们传给它的两个参数的数据类型正确。这意味着我们不需要修改`encode()`来适应我们的新应用，但我们确实需要设置新的值并将其作为参数传给它。
- en: To encode the message the user typed into `txtIn`, we’ll first need to retrieve
    the key value they entered into `txtKey`. Then, we’ll get the string of text the
    user entered into `txtIn`. We’ll pass both of those values to the `encode()` method
    as arguments and store the encoded result in a variable called `output`. Finally,
    we’ll set the text of the `txtOut` field to the encoded output string `output`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要对用户输入的`txtIn`中的消息进行编码，我们首先需要获取用户输入的`txtKey`中的密钥值。然后，我们将获取用户输入的`txtIn`中的文本字符串。我们将这两个值作为参数传递给`encode()`方法，并将编码结果存储在一个名为`output`的变量中。最后，我们将`txtOut`字段的文本设置为编码后的输出字符串`output`。
- en: 'Add the following four lines within the braces of the `onClick()` method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onClick()`方法的花括号内添加以下四行代码：
- en: btn.setOnClickListener(new View.OnClickListener() {
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: btn.setOnClickListener(new View.OnClickListener() {
- en: public void onClick(View v) {
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: public void onClick(View v) {
- en: ➊ int key = Integer.parseInt(txtKey.getText().toString());
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ int key = Integer.parseInt(txtKey.getText().toString());
- en: ➋ String message = txtIn.getText().toString();
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ String message = txtIn.getText().toString();
- en: ➌ String output = encode(message, key);
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ String output = encode(message, key);
- en: ➍ txtOut.setText(output);
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ txtOut.setText(output);
- en: '}'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: 'At ➊, we’ve used the `Integer.parseInt()` method to convert text from the user
    into an integer value `key`. The only difference between this `parseInt()` and
    others we’ve used before is that `txtKey` is followed by two methods: `getText()`
    and `toString()`. In Android, the `getText()` method on an `EditText` (that is,
    a text field) doesn’t return a string directly—it returns a flexible type called
    `Editable`. All of the `EditText` types, from Plain to Password to Number, return
    an `Editable` object, because the text inside an `EditText` is meant to change
    and be editable by the user. We use the `toString()` method to turn the text from
    the `EditText` into a string that we can parse, to find the number the user entered.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们使用了`Integer.parseInt()`方法将用户输入的文本转换为整数值`key`。这个`parseInt()`与之前使用过的其他方法的唯一区别是，`txtKey`后面跟着两个方法：`getText()`和`toString()`。在
    Android 中，`EditText`（即文本框）上的`getText()`方法并不会直接返回一个字符串，而是返回一个叫做`Editable`的灵活类型。所有的`EditText`类型，从普通文本到密码再到数字，都会返回一个`Editable`对象，因为`EditText`中的文本是可变的，并且可以由用户编辑。我们使用`toString()`方法将`EditText`中的文本转换为一个可以解析的字符串，以便找到用户输入的数字。
- en: 'The same is true at ➋: we need both methods, `getText()` and `toString()`,
    to get the input message from `txtIn` and turn it into a string that we can encode.
    At ➌, we use the `encode()` method on the `message` and `key` value the user provided
    to encode the message, then store the result in `output`. Finally, at ➍, we set
    the text of the `txtOut` text field to display the encoded `output` message.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➋ 处也是如此：我们需要`getText()`和`toString()`两个方法来获取`txtIn`中的输入消息，并将其转换为我们可以编码的字符串。在
    ➌ 处，我们使用用户提供的`message`和`key`值调用`encode()`方法来对消息进行编码，然后将结果存储在`output`中。最后，在 ➍ 处，我们设置`txtOut`文本框的文本，以显示编码后的`output`消息。
- en: Now, our app is functional enough for a first test. Let’s run the app in the
    Android Emulator to see the Encode/Decode button at work.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序足够功能化，进行第一次测试。让我们在 Android 模拟器中运行应用，看看编码/解码按钮的效果。
- en: '*Testing the App*'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*测试应用*'
- en: Save your progress so far. Then, go to **Run** ▸ **Run ‘app’**. Select an emulator
    you set up back in [Chapter 4](ch4.xhtml#ch4), such as My Nexus 6P, as shown in
    [Figure 8-11](ch8.xhtml#ch8fig11).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 保存到目前为止的进度。然后，点击**运行** ▸ **运行‘app’**。选择你在[第 4 章](ch4.xhtml#ch4)中设置的模拟器，比如我的
    Nexus 6P，如[图 8-11](ch8.xhtml#ch8fig11)所示。
- en: '![Image](../images/f0185-01.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0185-01.jpg)'
- en: '*Figure 8-11: Choosing an emulator*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-11：选择一个模拟器*'
- en: The emulator may take a few minutes to run the first time—remember, you can
    leave it running while working in Android Studio to avoid the long startup each
    time you want to run the app. You can also run the app directly on your Android
    device, as we did in [Chapter 4](ch4.xhtml#ch4), and skip the emulator if you
    wish.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器第一次运行可能需要几分钟的时间——记住，你可以在 Android Studio 中让它保持运行，这样每次想运行应用时就不需要再等待长时间的启动过程。如果你愿意，也可以像我们在[第
    4 章](ch4.xhtml#ch4)中做的那样，直接在 Android 设备上运行应用，跳过模拟器。
- en: When the emulator starts up and the Secret Messages app loads, you’ll see the
    initial layout, as shown in [Figure 8-12](ch8.xhtml#ch8fig12) (left). Type in
    a key value, then press the Encode/Decode button, and you’ll see Android convert
    the message into ciphertext, as shown in [Figure 8-12](ch8.xhtml#ch8fig12) (right).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟器启动并加载秘密消息应用时，你会看到初始布局，如[图 8-12](ch8.xhtml#ch8fig12)（左）。输入一个密钥值，然后按下编码/解码按钮，你会看到
    Android 将消息转换为密文，如[图 8-12](ch8.xhtml#ch8fig12)（右）。
- en: '![Image](../images/f0186-01.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0186-01.jpg)'
- en: '*Figure 8-12: The Secret Messages app running on the Nexus 6P Android Emulator
    (left); clicking the Encode/Decode button creates the encoded text (right).*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-12：秘密消息应用在 Nexus 6P Android 模拟器上运行（左）；点击编码/解码按钮后生成的编码文本（右）。*'
- en: You can copy and paste between the fields, but the slider/`SeekBar` doesn’t
    work yet. The floating action button—the email envelope symbol in the lower right—also
    doesn’t do anything yet. Don’t worry; we’ll work on those shortly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在字段之间复制和粘贴，但滑块/`SeekBar`还没有实现。右下角的浮动操作按钮——电子邮件信封图标——也暂时没有功能。别担心，我们很快会处理这些问题。
- en: 'Notice there’s one other user experience issue: the encoded message (`Frperg
    zrffntrf...`) is underlined because it looks like misspelled text to the computer.
    To turn off spellcheck, go back to the *content_main.xml* layout file and select
    the **txtOut** text field. Under the Properties pane, expand `inputType` and select
    the **textNoSuggestions** property. You can also turn off spelling suggestions
    for the `txtIn` text field, if you’d like, either separately or by selecting both
    text fields while holding down SHIFT in the layout view and then selecting the
    **textNoSuggestions** property. Now rerun the app on the emulator. No more spellcheck!'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有一个用户体验问题：编码后的消息（`Frperg zrffntrf...`）被下划线标记，因为计算机认为它像是拼写错误的文本。为了关闭拼写检查，回到
    *content_main.xml* 布局文件中，选择 **txtOut** 文本字段。在属性面板下，展开 `inputType` 并选择 **textNoSuggestions**
    属性。如果你愿意，你也可以为 `txtIn` 文本字段关闭拼写建议，方法是单独操作，或者在布局视图中按住 SHIFT 键选择两个文本字段，然后选择 **textNoSuggestions**
    属性。现在重新在模拟器上运行应用程序，不再有拼写检查了！
- en: With this small tweak, we’re ready to bring the `SeekBar` online so we can slide
    among different key values easily and quickly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个小调整，我们准备好了将 `SeekBar` 上线，以便我们能够轻松快速地在不同的键值之间滑动。
- en: '*Working with the SeekBar*'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*使用 SeekBar*'
- en: We’re going to wire the `SeekBar` to change the output message whenever the
    user slides left or right, so we need to modify a few of its properties to get
    it ready for use.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把 `SeekBar` 连接起来，每当用户向左或向右滑动时，改变输出信息，因此我们需要修改它的一些属性，使其准备好使用。
- en: First, let’s learn a little about the `SeekBar` widget. You’ve probably seen
    a `SeekBar` when playing a video on your mobile device. For example, on a YouTube
    video the `SeekBar` shows where you are in a video, and it allows you to skip
    forward or backward—this is sometimes called *seeking*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解一下 `SeekBar` 小部件。你可能在手机上播放视频时见过 `SeekBar`。例如，在 YouTube 视频中，`SeekBar`
    显示你在视频中的位置，并允许你快进或快退——这有时被称为 *查找*。
- en: The `SeekBar` differs from a `JSlider` in a few ways. First, a `SeekBar` can
    have only positive values. Zero is the minimum, but we can set the maximum to
    any positive value, like `26`. Also, a `SeekBar` doesn’t show increment marks
    or labels on the bar itself. This means that if we want to allow our users to
    use negative key values, we’ll have to use a bit of math to convert positive values
    to negative so that the user can slide the key value through the range of values
    from, say, `-13` to `+13`. To do this, we’ll make the `SeekBar` range from `0`
    to `26`. And we’ll need to update the `txtKey` field to show the values changing
    as the user slides the `SeekBar` to let them know the `SeekBar`’s current value.
    Let’s begin by changing some of the properties of the `SeekBar` in the GUI layout.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`SeekBar` 与 `JSlider` 有一些不同之处。首先，`SeekBar` 只能拥有正值。零是最小值，但我们可以将最大值设置为任意正值，例如
    `26`。此外，`SeekBar` 不会在条形上显示增量标记或标签。这意味着，如果我们想允许用户使用负的键值，我们需要使用一些数学运算将正值转换为负值，这样用户就可以在例如从
    `-13` 到 `+13` 的值范围内滑动键值。为了实现这一点，我们将 `SeekBar` 的范围设置为从 `0` 到 `26`。并且，我们需要更新 `txtKey`
    字段，以便在用户滑动 `SeekBar` 时显示值的变化，让他们知道 `SeekBar` 的当前值。我们从修改 `SeekBar` 在 GUI 布局中的一些属性开始。'
- en: Switch back to the *content_main.xml* layout file and select the `SeekBar` in
    the design preview. Under the Properties pane for the `SeekBar`, find `max` and
    `progress` and change both to `26`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 *content_main.xml* 布局文件，选择设计预览中的 `SeekBar`。在 `SeekBar` 的属性面板中，找到 `max` 和
    `progress`，并将两者都改为 `26`。
- en: The `max` property is the maximum value the `SeekBar` will display. For the
    Secret Messages app, we need at least 26 values to cover the whole alphabet. We
    want the range to be `-13` to `+13` so that encoding and decoding is easy for
    the user. That would be 27 values total, so we’ll choose `26` as the `max` (since
    that makes for 27 values when 0 is included). The `progress` property is the current
    value of the `SeekBar`, similar to the value property of a `JSlider`. We’ll use
    the `getProgress()` method on the `SeekBar` to get the value the `SeekBar` is
    currently pointing to.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`max` 属性是 `SeekBar` 显示的最大值。对于秘密消息应用程序，我们至少需要 26 个值来涵盖整个字母表。我们希望范围是 `-13` 到
    `+13`，以便用户能够轻松地进行编码和解码。总共有 27 个值，所以我们选择 `26` 作为 `max`（因为当包含 0 时，总共是 27 个值）。`progress`
    属性是 `SeekBar` 的当前值，类似于 `JSlider` 的 value 属性。我们将使用 `SeekBar` 的 `getProgress()`
    方法来获取 `SeekBar` 当前指向的值。'
- en: Save your changes and then switch back to the *MainActivity.java* source code
    file. Inside the `onCreate()` method, right below the closing line `});` of the
    `btn.setOnClickListener()` code, begin typing `sb.set` and use the code recommender
    to find `setOnSeekBarChangeListener()`. This will store your `SeekBar` in the
    variable `sb`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的更改，然后切换回*MainActivity.java*源代码文件。在`onCreate()`方法内，紧接着`btn.setOnClickListener()`代码的闭合行`});`下，开始输入`sb.set`并使用代码推荐工具查找`setOnSeekBarChangeListener()`。这将把你的`SeekBar`存储到变量`sb`中。
- en: The code for the `SeekBar` listener is different from that for the Encode/Decode
    button. We want to listen for more than just click events on the `SeekBar`. We
    want to listen for all changes, including the user pressing the `SeekBar` and
    sliding it left or right. For that, we need an `OnSeekBarChangeListener`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`SeekBar`监听器的代码与Encode/Decode按钮的代码不同。我们不仅仅要监听`SeekBar`的点击事件。我们还要监听所有的变化，包括用户按下`SeekBar`并左右滑动它。为此，我们需要一个`OnSeekBarChangeListener`。'
- en: Just as with the button code, though, we’ll use the code recommender to automatically
    generate the new `OnSeekBarChangeListener`. Inside the parentheses after `sb.setOnSeekBarChangeListener()`,
    begin typing `new OnSeekBar` and use the code recommendation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与按钮代码一样，我们将使用代码推荐工具自动生成新的`OnSeekBarChangeListener`。在`sb.setOnSeekBarChangeListener()`后面的括号中，开始输入`new
    OnSeekBar`并使用代码推荐工具。
- en: 'Android Studio will fill in the `OnSeekBarChangeListener` code with three methods:
    `onProgressChanged()`, `onStartTrackingTouch()`, and `onStopTrackingTouch()`.
    We want to use `onProgressChanged()`, as this will tell us when the user has changed
    the value of the `SeekBar`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio会自动填充`OnSeekBarChangeListener`代码，包括三个方法：`onProgressChanged()`、`onStartTrackingTouch()`和`onStopTrackingTouch()`。我们要使用`onProgressChanged()`，因为它会告诉我们用户何时改变了`SeekBar`的值。
- en: 'The steps we want to program into the `SeekBar` event listener are similar
    to the code for the Encode/Decode button, except that we need to calculate the
    key based on the `SeekBar`’s value. We also need to show the key in the `txtKey`
    field. Add the following lines of code to the `onProgressChanged()` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在`SeekBar`事件监听器中编写的步骤与Encode/Decode按钮的代码类似，唯一不同的是我们需要根据`SeekBar`的值来计算密钥。我们还需要在`txtKey`字段中显示密钥。将以下代码添加到`onProgressChanged()`方法中：
- en: sb.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: sb.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
- en: '@Override'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser)
    {
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser)
    {
- en: ➊ int key = sb.getProgress() - 13;
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ int key = sb.getProgress() - 13;
- en: String message = txtIn.getText().toString();
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: String message = txtIn.getText().toString();
- en: String output = encode(message, key);
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: String output = encode(message, key);
- en: txtOut.setText(output);
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: txtOut.setText(output);
- en: ➋ txtKey.setText("" + key);
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ txtKey.setText("" + key);
- en: '}'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: At ➊, we create a variable named `key`. We get the progress value from the `SeekBar`
    `sb` variable, and we subtract `13` from that value. The `SeekBar` can go only
    from `0` to `26`, so subtracting `13` will give a range from `-13` to `+13`, perfect
    for encoding and decoding messages. The next three lines are identical to those
    in the Encode/Decode button event handler code, which get the message, encode
    the message using the `encode()` method, and then display the encoded text in
    `txtOut`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们创建了一个名为`key`的变量。我们从`SeekBar`变量`sb`中获取进度值，然后从该值中减去`13`。`SeekBar`的值范围仅限于`0`到`26`，因此减去`13`后将得到从`-13`到`+13`的范围，这非常适合用于编码和解码消息。接下来的三行代码与Encode/Decode按钮事件处理程序中的代码相同，它们获取消息、使用`encode()`方法对消息进行编码，然后将编码后的文本显示在`txtOut`中。
- en: The line at ➋ is new. When the user moves the `SeekBar` slider, we want the
    `txtKey` readout to change. Since `key` is an integer, we add an empty string
    (`""`) to it to convert the result to a text string that will be displayed to
    the user. You could have also used the command `Integer.toString(key)` to convert
    the `key` value into a string using the `Integer` class’s `toString()` method,
    but adding an empty string to an `int` is just a handy shortcut.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋处的代码是新增的。当用户移动`SeekBar`滑块时，我们希望`txtKey`的显示值发生变化。由于`key`是一个整数，我们将其与空字符串（`""`）相加，从而将结果转换为文本字符串并显示给用户。你也可以使用`Integer.toString(key)`命令，通过`Integer`类的`toString()`方法将`key`值转换为字符串，但将空字符串添加到整数`int`中是一种简便的快捷方式。
- en: Running the App on the Emulator and on an Android Device
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在模拟器和安卓设备上运行应用
- en: Save your changes and then try running the app again on the emulator. You can
    now slide the `SeekBar` left and right and see the ciphertext change immediately
    with each key value, as shown in [Figure 8-13](ch8.xhtml#ch8fig13).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的更改后，再次尝试在模拟器中运行应用。现在，你可以左右滑动 `SeekBar`，并看到每个键值对应的密文立即变化，如[图 8-13](ch8.xhtml#ch8fig13)所示。
- en: It’s been a few chapters since we connected a physical Android device, so let’s
    review that quickly. First, connect a compatible USB cable between your Android
    device and your computer. When a pop-up appears asking whether you want to allow
    USB Debugging, click **Yes**.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们连接了物理 Android 设备已经有几个章节了，接下来我们快速回顾一下。首先，通过兼容的 USB 数据线将你的 Android 设备与电脑连接。当弹出窗口询问是否允许
    USB 调试时，点击**是**。
- en: '![Image](../images/f0189-01.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0189-01.jpg)'
- en: '*Figure 8-13: The SeekBar*  *is now fully functional,  as shown on the Android
    Emulator, with a key  value of 5*.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-13：SeekBar* *现在完全功能化，如在 Android 模拟器上所示，键值为 5*。'
- en: In Android Studio, click the run button, and you’ll see a Select Deployment
    Target dialog. (You may need to close the app in your emulator window to get the
    dialog to show up.) Find the entry for the Android device you’ve connected and
    click **OK**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，点击运行按钮，你将看到一个选择部署目标的对话框。（你可能需要关闭模拟器中的应用才能让对话框显示出来。）找到你连接的
    Android 设备的条目，然后点击**确定**。
- en: When you run the app on your real Android device, you’ll notice the `SeekBar`
    is more responsive, and you have access to a few options when you click certain
    parts of the app. When you click the ciphertext and choose **Select All**, a context
    menu will appear, as shown in [Figure 8-14](ch8.xhtml#ch8fig14), offering you
    the option to Cut, Copy, Share, or Assist.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在真实的 Android 设备上运行应用时，你会发现 `SeekBar` 更加响应，并且当你点击应用的某些部分时会看到一些选项。当你点击密文并选择**全选**时，将出现一个上下文菜单，如[图
    8-14](ch8.xhtml#ch8fig14)所示，提供剪切、复制、共享或协助等选项。
- en: 'If you click Share, the selected text can be sent via email, text message,
    chat, Bluetooth, Twitter, Facebook, or any other app you have configured for sharing
    on your device, as shown in [Figure 8-15](ch8.xhtml#ch8fig15) (left). With the
    Share option, you can send encoded messages to anyone from inside the app! You
    can even email a secret message to a friend who has the desktop GUI version of
    the Secret Messages app, as shown in [Figure 8-15](ch8.xhtml#ch8fig15) (right).
    All they have to do is copy the ciphertext from the email you send them into the
    Secret Messages GUI app while it’s running, then use the opposite of the secret
    key to decode the message: for example, `-8` would decode a message sent with
    a key value of `8`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击共享，所选文本可以通过电子邮件、短信、聊天、蓝牙、Twitter、Facebook 或任何你在设备上配置的共享应用发送，如[图 8-15](ch8.xhtml#ch8fig15)（左）所示。使用共享选项，你可以从应用内部向任何人发送编码的消息！你甚至可以通过电子邮件将一条秘密消息发送给拥有桌面
    GUI 版本的秘密消息应用的朋友，如[图 8-15](ch8.xhtml#ch8fig15)（右）所示。他们只需在运行中的秘密消息 GUI 应用中将你发送给他们的电子邮件中的密文复制进去，然后使用相反的密钥解码消息：例如，`-8`将解码用键值`8`发送的消息。
- en: '![Image](../images/f0189-02.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0189-02.jpg)'
- en: '*Figure 8-14: The context menu allows you to Cut, Copy, or Share your encoded
    messages.*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-14：上下文菜单允许你剪切、复制或共享你的编码消息。*'
- en: '![Image](../images/f0190-01.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0190-01.jpg)'
- en: '*Figure 8-15: The Share option allows you to share your message via email,
    text message, Twitter, Facebook, or any other app you’ve configured for sharing
    (left). Selecting the email option will automatically create an email message
    with your encoded text (right).*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-15：共享选项允许你通过电子邮件、短信、Twitter、Facebook 或任何其他你已配置的共享应用来分享你的消息（左）。选择电子邮件选项将自动创建一封包含已编码文本的电子邮件（右）。*'
- en: So now we have a fully functional Secret Messages mobile app that allows us
    to share our messages by email, text, or social media with anyone.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们有了一个功能完全的秘密消息移动应用，允许我们通过电子邮件、短信或社交媒体与任何人分享我们的消息。
- en: 'There’s only one feature left to make our app complete: adding our own custom
    action to the floating action button. This will enable us to let the user share
    their messages at the touch of a finger!'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下一个功能可以让我们的应用完整：将我们自定义的操作添加到浮动操作按钮。这将使我们能够让用户通过触摸屏幕分享他们的消息！
- en: 'Bonus: Customizing the Floating Action Button'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加功能：自定义浮动操作按钮
- en: So far, we’ve been ignoring the floating action button (also known as the *fab
    icon*), the circular email envelope symbol in the lower-right corner of the app
    screen, shown in [Figure 8-16](ch8.xhtml#ch8fig16).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直忽略了浮动操作按钮（也称为*fab图标*），它是应用程序屏幕右下角的圆形电子邮件信封符号，如[图 8-16](ch8.xhtml#ch8fig16)所示。
- en: The fab icon gives us a way to provide the user with a shortcut to perform a
    specific action, such as sharing their message via email, text, or social media.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: fab图标为我们提供了一种方式，让用户可以通过快捷方式执行特定操作，例如通过电子邮件、短信或社交媒体分享他们的信息。
- en: '![Image](../images/f0190-02.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0190-02.jpg)'
- en: '*Figure 8-16: The floating action button*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-16：浮动操作按钮*'
- en: 'Android Studio automatically includes some code for the fab icon that displays
    a new type of pop-up message—called a “Snackbar” in Android lingo—in the `onCreate()`
    method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio会自动在`onCreate()`方法中包含一些代码，用于fab图标显示一种新的弹出消息类型—在Android术语中称为“Snackbar”：
- en: FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
- en: fab.setOnClickListener(new View.OnClickListener() {
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: fab.setOnClickListener(new View.OnClickListener() {
- en: '@Override'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public void onClick(View view) {
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: public void onClick(View view) {
- en: Snackbar.*make*(view, "Replace with your own action", Snackbar.*LENGTH_LONG*`)`
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Snackbar.*make*(view, "替换为您自己的操作", Snackbar.*LENGTH_LONG*`)`
- en: .setAction("Action", null).show();
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: .setAction("操作", null).show();
- en: '}'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: All we need to do is replace the code in the `onClick()` method of the `fab.setOnClickListener()`
    with code that does what we want.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是用实现我们想要操作的代码替换`fab.setOnClickListener()`方法中的代码。
- en: 'First, delete the code between the braces of the `onClick()` method. Next,
    type the following code into the `onClick()` method:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，删除`onClick()`方法中大括号之间的代码。接下来，将以下代码输入到`onClick()`方法中：
- en: FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
- en: fab.setOnClickListener(new View.OnClickListener() {
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: fab.setOnClickListener(new View.OnClickListener() {
- en: '@Override'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public void onClick(View view) {
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: public void onClick(View view) {
- en: ➊ Intent shareIntent = new Intent(Intent.*ACTION_SEND*);
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ Intent shareIntent = new Intent(Intent.*ACTION_SEND*);
- en: ➋ shareIntent.setType("text/plain");
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ shareIntent.setType("text/plain");
- en: ➌ shareIntent.putExtra(Intent.*EXTRA_SUBJECT*, "Secret Message "+
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ shareIntent.putExtra(Intent.*EXTRA_SUBJECT*, "秘密信息："+ '
- en: DateFormat.*getDateTimeInstance*().format(new Date()));
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: DateFormat.*getDateTimeInstance*().format(new Date()));
- en: ➍ shareIntent.putExtra(Intent.*EXTRA_TEXT*, txtOut.getText().toString());
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ shareIntent.putExtra(Intent.*EXTRA_TEXT*, txtOut.getText().toString());
- en: ➎ try {
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ try {
- en: startActivity(Intent.*createChooser*(shareIntent, "Share message..."));
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: startActivity(Intent.*createChooser*(shareIntent, "分享信息..."));
- en: finish();
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: finish();
- en: '}'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ➏ catch (android.content.ActivityNotFoundException ex) {
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ catch (android.content.ActivityNotFoundException ex) {
- en: 'Toast.*makeText*(MainActivity.this, "Error: Couldn''t share.",'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Toast.*makeText*(MainActivity.this, "错误：无法分享。",
- en: Toast.*LENGTH_SHORT*).show();
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Toast.*LENGTH_SHORT*).show();
- en: '}'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: Now let’s look at what each line does. At ➊, we create an `Intent` called `shareIntent`.
    An `Intent` in Android is an activity that we want to start or launch, such as
    email, Twitter, or the camera. The `shareIntent` uses `ACTION_SEND`, which means
    we want to send some information to another app on the Android device.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看每行代码的作用。在 ➊ 处，我们创建了一个名为`shareIntent`的`Intent`。在Android中，`Intent`是一种我们想启动或启动的活动，例如电子邮件、Twitter或相机。`shareIntent`使用`ACTION_SEND`，意味着我们想将一些信息发送到Android设备上的另一个应用。
- en: We set the type of the `Intent` to `text/plain` ➋, which is what we need for
    an email, tweet, or social media post, and then add a subject line to the activity
    ➌. If the user chooses to share their message by email or via another app that
    uses a subject line, it will read “Secret Message” plus the date. The `DateFormat`
    class will format the date in text form based on your region, like `"Dec 7, 2017
    4:33:12 PM"`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Intent`的类型设置为`text/plain` ➋，这正是发送电子邮件、推文或社交媒体帖子所需要的类型，然后在活动中添加了主题行 ➌。如果用户选择通过电子邮件或其他使用主题行的应用分享他们的消息，主题将是“秘密信息”加上日期。`DateFormat`类将根据您的地区以文本形式格式化日期，例如`"2017年12月7日下午4:33:12"`。
- en: The line at ➍ sends the encoded message from `txtOut` as the body of an email,
    tweet, or post, depending on which app the user chooses to share their message
    through.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 的那行代码将从`txtOut`中编码的消息作为电子邮件、推文或帖子内容发送，具体取决于用户选择通过哪个应用分享信息。
- en: Next is a `try` statement ➎. Lots of things could go wrong when we try to call
    one app from inside another. What if the user doesn’t have an email app installed?
    What if the app is busy or the network can’t be reached? The `try` statement is
    made for situations like this. The first line of code inside the `try` statement
    attempts to start the activity the user selected (like email, text messaging,
    or Twitter), then passes the information to the selected app, and finally finishes
    the activity in the next line.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `try` 语句 ➎。在我们尝试从一个应用中调用另一个应用时，可能会出现很多问题。如果用户没有安装电子邮件应用怎么办？如果应用正在忙碌或无法连接到网络怎么办？`try`
    语句正是为这种情况而设计的。`try` 语句中的第一行代码尝试启动用户选择的活动（例如电子邮件、短信或 Twitter），然后将信息传递给所选应用，最后在下一行结束该活动。
- en: 'If there’s an error or exception, the `catch` statement ➏ will display a Toast
    message (a kind of pop-up) that reads `"Error: Couldn''t share."`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '如果出现错误或异常，`catch`语句 ➏ 将显示一个 Toast 消息（类似弹出窗口），内容为 `"Error: Couldn''t share."`。'
- en: That’s all we need to get the fab icon working. Remember to import new classes
    by pressing ALT-ENTER (or OPTION-ENTER) while typing the lines of code. Remember,
    if Android Studio underlines a new class in red, it’s often because the class
    hasn’t been imported, so pressing ALT-ENTER (or OPTION-ENTER) will automatically
    add the correct `import` statement, just as we did in [Chapter 4](ch4.xhtml#ch4).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是让 fab 图标正常工作的所有步骤。记得在输入代码行时，按下 ALT-ENTER（或 OPTION-ENTER）来导入新的类。记住，如果 Android
    Studio 将新类标记为红色，通常是因为该类没有被导入，所以按下 ALT-ENTER（或 OPTION-ENTER）会自动添加正确的`import`语句，就像我们在[第
    4 章](ch4.xhtml#ch4)中所做的那样。
- en: Once you’ve added the code and imported the classes, run the app again.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了代码并导入了类，再次运行应用。
- en: After you encode a message, hide the keyboard by pressing the down triangle
    at the bottom of your screen. Then, tap the fab icon on the bottom right of the
    screen, as shown in [Figure 8-17](ch8.xhtml#ch8fig17) (left). Select your email
    app from the apps under **Share message...**, and the app should start, with a
    subject line and the encoded message in the body of the email, as shown in [Figure
    8-17](ch8.xhtml#ch8fig17) (right).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码完消息后，通过点击屏幕底部的下三角形来隐藏键盘。然后，点击屏幕右下角的 fab 图标，如[图 8-17](ch8.xhtml#ch8fig17)（左）所示。从
    **共享消息...** 中选择你的电子邮件应用，应用应该会启动，电子邮件的主题行和编码后的消息会显示在邮件正文中，如[图 8-17](ch8.xhtml#ch8fig17)（右）所示。
- en: '![Image](../images/f0192-01.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0192-01.jpg)'
- en: '*Figure 8-17: Pressing the fab icon in the lower right pops up a sharing menu
    (left). Choosing the email app from the sharing menu automatically creates an
    email with the secret message as the body and today’s date and time in the subject
    line (right).*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-17：按下右下角的 fab 图标会弹出一个共享菜单（左）。从共享菜单中选择电子邮件应用会自动创建一封包含秘密信息作为正文、日期和时间作为主题的电子邮件（右）。*'
- en: Now we can send secret messages from the app with just the touch of an icon!
    But to make this app truly worthy of the Google Play Store, we need to give it
    the ability to *receive* secret messages from outside the app.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需轻触一个图标，就能通过应用发送秘密信息！但为了让这个应用真正符合 Google Play 商店的标准，我们需要让它具备从应用外部*接收*秘密信息的能力。
- en: Receiving Secret Messages from Other Apps
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从其他应用接收秘密信息
- en: Let’s make one last upgrade to the mobile version of the Secret Messages app.
    We can share, email, or tweet encoded messages from the app, but what if we want
    to *receive* text *from* emails, tweets, and posts without copying and pasting
    into the app? To address this, we can add our app to the Share list in Android
    so that other apps can send text directly to the Secret Messages app—and it only
    takes a few lines of code!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为移动版的秘密信息应用做最后一次升级。我们可以分享、发送电子邮件或推特编码后的消息，但如果我们想要*接收*来自电子邮件、推特和帖子中的文本，而不需要复制粘贴到应用中该怎么办？为了解决这个问题，我们可以将我们的应用添加到
    Android 的共享列表中，这样其他应用就可以直接向秘密信息应用发送文本——而且只需要几行代码！
- en: This is an advanced technique, so let’s walk through the process step-by-step.
    First, open your app’s *AndroidManifest.xml* file under **manifests** ▸  **AndroidManifest.xml**
    in the Project Explorer pane. The manifest file stores the “shipping” information
    for your app, much as a ship’s manifest lists all the cargo traveling on the ship.
    You can declare properties for your entire app and include the details an Android
    device needs to run the app, just as you can declare the contents of a crate or
    package when you ship it overseas.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个高级技巧，让我们一步一步地走过这个过程。首先，在项目资源管理器面板中，打开你的应用程序的*AndroidManifest.xml*文件，路径是**manifests**
    ▸  **AndroidManifest.xml**。清单文件存储着应用程序的“出货”信息，就像船只的货单列出了所有航行在船上的货物一样。你可以声明应用程序的属性，并包含运行该应用程序所需的Android设备信息，就像你可以在运输时声明货物箱或包裹的内容一样。
- en: 'In order to do this, you’ll need to edit some XML. XML files contain *tags*
    to label information held in the file. Usually a tag is formatted with its name
    between angled brackets, like `<tag>`. In this case, we need to modify the manifest’s
    `intent-filter` tag entry, which has information about what data the app will
    accept. Add the following five lines of XML near the end of your *AndroidManifest.xml*
    file, before the `</activity>` tag:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你需要编辑一些XML。XML文件包含*标签*，用于标记文件中包含的信息。通常，标签格式是将其名称放在尖括号之间，如`<tag>`。在这种情况下，我们需要修改清单文件中的`intent-filter`标签项，该项包含应用程序将接受的数据的信息。在你的*AndroidManifest.xml*文件末尾的`</activity>`标签之前，添加以下五行XML：
- en: <intent-filter>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: <intent-filter>
- en: <action android:name="android.intent.action.MAIN" />
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <action android:name="android.intent.action.MAIN" />
- en: <category android:name="android.intent.category.LAUNCHER" />
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <category android:name="android.intent.category.LAUNCHER" />
- en: </intent-filter>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: </intent-filter>
- en: ➊ <intent-filter>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ <intent-filter>
- en: ➋ <action android:name="android.intent.action.SEND" />
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ <action android:name="android.intent.action.SEND" />
- en: ➌ <category android:name="android.intent.category.DEFAULT" />
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ <category android:name="android.intent.category.DEFAULT" />
- en: ➍ <data android:mimeType="text/*" />
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ <data android:mimeType="text/*" />
- en: ➎ </intent-filter>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ </intent-filter>
- en: </activity>
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: </activity>
- en: </application>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: </application>
- en: </manifest>
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: </manifest>
- en: At ➊, we add a new `intent-filter` to the app. Earlier we used an `Intent` object
    to send text out to another app, such as email, Twitter, or Facebook. In this
    case, we’re creating a filter to *receive* `Intent` objects sent from other apps
    on our phone ➋. (We used `Intent.ACTION_SEND` in the fab icon code on [page 191](ch8.xhtml#page_191)
    to send `Intent` messages to other apps; here we’re doing the opposite.)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在第➊行，我们为应用程序添加了一个新的`intent-filter`。之前我们使用`Intent`对象将文本发送到另一个应用程序，如电子邮件、Twitter或Facebook。在这种情况下，我们创建了一个过滤器来*接收*从我们手机上的其他应用程序发送的`Intent`对象
    ➋。（我们在第191页的fab图标代码中使用了`Intent.ACTION_SEND`将`Intent`消息发送到其他应用程序；在这里我们做的是相反的操作。）
- en: The line at ➌ uses the `DEFAULT` sharing category to add the Secret Messages
    app to the list of apps on your phone that you can share with. With the `DEFAULT`
    category, your app can receive data from any app. (There are other categories
    for when you want to filter or restrict the types of apps that can send data to
    your app. For example, the `BROWSABLE` category is used by apps that should receive
    data from only a web browser.) At ➍, we tell Android that the Secret Messages
    app should receive any kind of text data from other apps. (If you write an app
    that accepts images as input, your `mimeType` might be `"image/*"`, or `"image/png"`
    for just PNG images. For video, there’s `"video/mp4"`, and so on.)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第➌行使用`DEFAULT`共享类别，将“秘密消息”应用程序添加到你手机上可以共享的应用程序列表中。使用`DEFAULT`类别，你的应用程序可以接收来自任何应用的数据。（如果你想要筛选或限制能够向你的应用发送数据的应用类型，还可以使用其他类别。例如，`BROWSABLE`类别是用于仅接收来自网页浏览器数据的应用程序。）在第➍行，我们告诉Android，“秘密消息”应用程序应该接收来自其他应用的任何文本数据。（如果你编写一个接受图片作为输入的应用程序，`mimeType`可能是`"image/*"`，或者是仅针对PNG图片的`"image/png"`。对于视频，`mimeType`则是`"video/mp4"`，依此类推。）
- en: Finally, we close the `intent-filter` entry ➎ in your app’s manifest. XML tags
    need to be *closed*, which is usually done with a forward slash and the name of
    the XML tag that’s being closed, as in `</intent-filter>`. This lets the computer
    know you’ve completed code for the `intent-filter`. Save your *AndroidManifest.xml*
    file and then open the *MainActivity.java* file to begin editing the Java source
    code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在应用程序的清单文件中关闭`intent-filter`项 ➎。XML标签需要被*关闭*，通常通过一个正斜杠和正在关闭的XML标签名称来实现，如`</intent-filter>`。这让计算机知道你已经完成了`intent-filter`的代码。保存你的*AndroidManifest.xml*文件，然后打开*MainActivity.java*文件，开始编辑Java源代码。
- en: 'Scroll down inside *MainActivity.java* to find the `onCreate()` method. Immediately
    after the code that connects the GUI components to the variables from `txtIn`
    through `btn`, add the four statements shown here:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动至 *MainActivity.java* 中找到 `onCreate()` 方法。紧接着连接 GUI 组件到 `txtIn` 到 `btn`
    的代码后，添加以下四个语句：
- en: protected void onCreate(Bundle savedInstanceState) {
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: protected void onCreate(Bundle savedInstanceState) {
- en: super.onCreate(savedInstanceState);
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: super.onCreate(savedInstanceState);
- en: setContentView(R.layout.*activity_main*);
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: setContentView(R.layout.*activity_main*);
- en: Toolbar toolbar = (Toolbar) findViewById(R.id.*toolbar*);
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Toolbar toolbar = (Toolbar) findViewById(R.id.*toolbar*);
- en: setSupportActionBar(toolbar);
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: setSupportActionBar(toolbar);
- en: txtIn = (EditText)findViewById(R.id.*txtIn*);
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: txtIn = (EditText)findViewById(R.id.*txtIn*);
- en: txtKey = (EditText)findViewById(R.id.*txtKey*);
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: txtKey = (EditText)findViewById(R.id.*txtKey*);
- en: txtOut = (EditText)findViewById(R.id.*txtOut*);
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: txtOut = (EditText)findViewById(R.id.*txtOut*);
- en: sb = (SeekBar)findViewById(R.id.*seekBar*);
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: sb = (SeekBar)findViewById(R.id.*seekBar*);
- en: btn = (Button)findViewById(R.id.*button*);
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: btn = (Button)findViewById(R.id.*button*);
- en: ➊ Intent receivedIntent = getIntent();
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ Intent receivedIntent = getIntent();
- en: ➋ String receivedText = receivedIntent.getStringExtra(Intent.*EXTRA_TEXT*);
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ String receivedText = receivedIntent.getStringExtra(Intent.*EXTRA_TEXT*);
- en: ➌ if (receivedText != null)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ if (receivedText != null)
- en: ➍ txtIn.setText(receivedText);
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ txtIn.setText(receivedText);
- en: btn.setOnClickListener(new View.OnClickListener() {
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: btn.setOnClickListener(new View.OnClickListener() {
- en: At ➊, we create a variable called `receivedIntent` to accept the incoming `Intent`
    message shared from another app. Then, we get the text from the `Intent` message
    by calling the `getStringExtra()` method ➋. The parts of a message sent by an
    `Intent` are referred to as *extra* data. An `if` statement ➌ checks to make sure
    the `receivedText` variable isn’t `null` and, if so, changes the text in the `txtIn`
    text field at the top of the Secret Messages app to the received text ➍.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们创建了一个名为 `receivedIntent` 的变量，用来接收从其他应用共享过来的 `Intent` 消息。然后，我们通过调用 `getStringExtra()`
    方法 ➋ 获取 `Intent` 消息中的文本。`Intent` 发送的消息部分被称为 *extra* 数据。一个 `if` 语句 ➌ 用来确保 `receivedText`
    变量不为 `null`，如果是，就将接收到的文本 ➍ 设置到 Secret Messages 应用顶部的 `txtIn` 文本框中。
- en: Believe it or not, that’s all the work necessary to accept messages shared from
    other apps into the Secret Messages app! Now, you can not only send encoded messages
    from the app but also decode messages from email, tweets, and posts directly.
    [Figure 8-18](ch8.xhtml#ch8fig18) shows what it looks like to share a message
    from email to the Secret Messages app for quick decoding.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这就是将来自其他应用的消息接收到 Secret Messages 应用中所需的所有工作！现在，你不仅可以从应用中发送编码的消息，还能直接从电子邮件、推文和帖子中解码消息。[图
    8-18](ch8.xhtml#ch8fig18) 显示了如何从电子邮件共享消息到 Secret Messages 应用进行快速解码的样子。
- en: '![Image](../images/f0195-01.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0195-01.jpg)'
- en: '*Figure 8-18: Now the Secret Messages app can send and receive messages back
    and forth with other apps on your phone, including your email.*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-18：现在 Secret Messages 应用可以与手机上的其他应用发送和接收消息，包括电子邮件。*'
- en: Select text in your favorite email app, or in Twitter or Facebook, and press
    the **Share** button. The Secret Messages app will appear on the list of apps
    that accept a shared message. Select **SecretMessages** as the app to share with,
    and the selected text will be shown in the input text field of the Secret Messages
    app. You can encode or decode with ease; just remember you may need to change
    the key value depending on how the message was encoded.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在你喜欢的电子邮件应用中，或者在 Twitter 或 Facebook 中选择文本，并按下 **Share** 按钮。Secret Messages 应用会出现在接受共享消息的应用列表中。选择
    **SecretMessages** 作为共享应用，所选的文本将显示在 Secret Messages 应用的输入文本框中。你可以轻松进行编码或解码；只要记住，你可能需要根据消息的编码方式更改密钥值。
- en: Congratulations! You’ve built a fully social Secret Messages mobile app. Enjoy
    it and share it with a friend!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你已经完成了一个完整的社交版 Secret Messages 移动应用。尽情享受它，并与朋友分享吧！
- en: Let’s take a look at the skills you developed in this chapter and try a couple
    of additional programming challenges.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看你在本章中发展出来的技能，并尝试一些额外的编程挑战。
- en: What You Learned
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'We reused code in this app from the GUI desktop version of the Secret Messages
    app, and we added so much more to make this a truly complete mobile app. Here
    are some of the new things you’ve learned and some of the skills you’ve reinforced
    in this chapter:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个应用中复用了来自 Secret Messages 桌面版 GUI 的代码，并添加了更多功能，使其成为一个真正完整的移动应用。以下是你在本章中学到的一些新内容以及你强化的一些技能：
- en: • Writing event handlers for Android components, including buttons, `SeekBar`s,
    and the floating action button
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: • 编写 Android 组件的事件处理程序，包括按钮、`SeekBar` 和浮动操作按钮
- en: • Customizing Android GUI components
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: • 自定义 Android GUI 组件
- en: • Using multiline text inputs in an Android app
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: • 在 Android 应用中使用多行文本输入
- en: • Adding a `SeekBar` and using it like a slider interface
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: • 添加一个`SeekBar`并将其用作滑动条界面
- en: • Running Android apps on both the emulator and real devices
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: • 在模拟器和真实设备上运行 Android 应用
- en: • Customizing the action of the floating action button
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: • 自定义浮动操作按钮的动作
- en: • Creating custom `Intent` objects to call special activities, including sending
    data to other apps, from inside an app
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: • 创建自定义的`Intent`对象以调用特殊的活动，包括从应用内发送数据到其他应用
- en: • Creating custom `Intent` filters to receive text (or image or video) data
    sent from other apps
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: • 创建自定义的`Intent`过滤器，以接收从其他应用发送的文本（或图像或视频）数据
- en: Programming Challenges
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程挑战
- en: Try these programming challenges to review and practice what you’ve learned,
    and to expand your programming skills by trying something new. Visit the book’s
    website at *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    for sample solutions.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 试试这些编程挑战，以回顾和练习你所学的知识，并通过尝试新事物来扩展你的编程技能。访问本书的网站 *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    获取示例解决方案。
- en: '*#1: Creating a Move Up Button*'
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#1: 创建一个向上移动按钮*'
- en: 'This programming challenge is to create a Move Up ^ button similar to the one
    in [Chapter 7](ch7.xhtml#ch7) (Programming Challenge #1 on [page 172](ch7.xhtml#page_172))
    that moves text up from the output field into the input field.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '这个编程挑战是创建一个向上移动 ^ 按钮，类似于[第七章](ch7.xhtml#ch7)中的那个按钮（[第172页](ch7.xhtml#page_172)的编程挑战
    #1），它将文本从输出字段移动到输入字段。'
- en: Place the Move Up ^ button below the `txtOut` text field. Then add an event
    handler that gets the text from the `txtOut` text field and sets it as the text
    of the `txtIn` text field. As an added bonus, you could have the event handler
    for the Move Up ^ button also change the `SeekBar` to the opposite of its value.
    An encryption key of `7` would become `-7`, the decryption key. The result will
    be that clicking the button swaps the encoded message up and automatically decodes
    it!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 将向上移动 ^ 按钮放置在`txtOut`文本字段的下方。然后添加一个事件处理程序，它从`txtOut`文本字段获取文本，并将其设置为`txtIn`文本字段的文本。作为额外的奖励，你可以让向上移动
    ^ 按钮的事件处理程序也改变`SeekBar`的值为其相反数。加密密钥 `7` 将变为 `-7`，即解密密钥。点击按钮后，编码的消息将被交换并自动解码！
- en: '*#2: Changing the SeekBar’s Progress*'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*#2: 改变 SeekBar 的进度*'
- en: A second improvement you could make to the user experience would be to change
    the `SeekBar`’s progress property whenever the user enters a key value manually
    in the `txtKey` field. Give it a try!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对用户体验做出的第二个改进是，当用户手动在`txtKey`字段中输入一个值时，改变`SeekBar`的进度属性。试试看！
- en: '**HINT**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '*Instead of creating an event handler for the txtKey field, modify the code
    for the Encode/Decode button to change the SeekBar’s progress to match the value
    in txtKey + 13—remember the SeekBar goes from 0 to 26, not -13 to +13*. *One or
    two lines of code should be all you need.*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以尝试修改 Encode/Decode 按钮的代码，而不是为 txtKey 字段创建事件处理程序，将 SeekBar 的进度值设置为 txtKey
    + 13 的值——记住，SeekBar 的值范围是从 0 到 26，而不是从 -13 到 +13*。*一两行代码就足够了。*'
