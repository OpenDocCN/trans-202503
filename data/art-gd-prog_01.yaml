- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The Fundamentals of Drawing
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制基础
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: 'Sketch 1: A Circle'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 1：一个圆
- en: Drawing a circle requires quite a bit of code in C or Java, but it’s one of
    the simplest programs in Processing. There isn’t a circle function in Processing,
    so to draw a circle we draw an ellipse that has equal width and height, which
    is the same thing as a circle.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 或 Java 中绘制一个圆需要相当多的代码，但在 Processing 中，它是最简单的程序之一。Processing 中没有圆形函数，因此为了绘制一个圆，我们绘制一个宽度和高度相等的椭圆，这与圆形是一样的。
- en: Example A
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 A
- en: The `setup()` function calls the predefined `size()` function to open a sketch
    window with a width of 400 pixels and a height of 300 pixels 1.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()` 函数调用预定义的 `size()` 函数来打开一个宽度为 400 像素，高度为 300 像素的草图窗口 1。'
- en: The `draw()` function draws a circle every time it’s called (60 times per second
    by default) with the `ellipse()` function, which has four parameters. The first
    and second parameters specify the pixel coordinates of the ellipse’s center. The
    third and fourth parameters specify the ellipse’s width and height. The call `ellipse
    (200, 150, 50, 50)` 2 draws an ellipse centered at (200, 100) that is 50 pixels
    wide and 50 pixels high, which is essentially a circle with a diameter of 50 pixels.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()` 函数每次被调用时（默认每秒 60 次）都会绘制一个圆形，使用 `ellipse()` 函数，它有四个参数。前两个参数指定椭圆中心的像素坐标。后两个参数指定椭圆的宽度和高度。调用
    `ellipse (200, 150, 50, 50)` 2 绘制一个中心位于 (200, 100) 的椭圆，宽度和高度都是 50 像素，实际上是一个直径为
    50 像素的圆。'
- en: By default, the background color is set to a medium grey, and the color that
    fills the circle is white. The circle is outlined by a black line.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，背景颜色设置为中灰色，填充圆形的颜色为白色。圆形的轮廓由黑色线条勾画。
- en: Example B
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 B
- en: This example is much like Example A, but now the background color is set to
    white, and the color that fills the circle (and any other basic closed shape)
    is set to black.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例与示例 A 很相似，但现在背景颜色设置为白色，填充圆圈（以及其他任何基本的闭合形状）的颜色设置为黑色。
- en: The `background()` function 1 specifies the background color with a single number
    parameter ranging from 0 to 255 that indicates levels of gray, where 0 is black
    and 255 is white. Numerical values outside of this range are illegal. In this
    case the color is set to white (`255`). The `background()` function is specified
    in the `draw()` function so that the background is redrawn each time. If `background()`
    was called in `setup()`, the background would only be drawn once, at the beginning
    of execution.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`background()` 函数 1 用一个单一的数字参数指定背景颜色，范围从 0 到 255，表示灰度级别，其中 0 为黑色，255 为白色。范围之外的数值是非法的。在这个例子中，颜色设置为白色（`255`）。`background()`
    函数在 `draw()` 函数中被调用，这样每次都会重新绘制背景。如果 `background()` 在 `setup()` 中被调用，背景只会在执行开始时绘制一次。'
- en: The `fill()` function 2 specifies the fill color of basic closed shapes with
    the same single number parameter as the `background()` function. In this case
    the fill color is set to black (`0`), and it remains so until changed by another
    call to `fill()`. Thus, `fill()` could have been called just once within `setup()`
    and the effect would have been the same.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill()` 函数 2 指定基本闭合形状的填充颜色，使用与 `background()` 函数相同的单一数字参数。在这个例子中，填充颜色设置为黑色（`0`），直到通过另一次调用
    `fill()` 改变。因此，`fill()` 本可以仅在 `setup()` 中调用一次，效果也将相同。'
- en: Example C
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 C
- en: In this case the background color (white = `255`) 1 and fill color (black =
    `0`) 2 are specified in `setup()`. This sketch draws two ellipses, not circles,
    in the `draw()` function to show how the width and height parameters are used.
    The first call to `ellipse()` 3 draws the leftmost ellipse, which is 100 pixels
    wide and 50 pixels high. The second call to `ellipse()` 4 draws the rightmost
    ellipse, which is 50 pixels wide and 100 pixels high.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，背景颜色（白色 = `255`）1 和填充颜色（黑色 = `0`）2 在 `setup()` 中被指定。这个草图在 `draw()` 函数中绘制了两个椭圆，而不是圆形，以展示宽度和高度参数是如何使用的。第一次调用
    `ellipse()` 3 绘制最左边的椭圆，宽度为 100 像素，高度为 50 像素。第二次调用 `ellipse()` 4 绘制最右边的椭圆，宽度为 50
    像素，高度为 100 像素。
- en: The `noFill()` function causes ellipses and other objects to be drawn without
    any fill color so that the background color shows inside the object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`noFill()` 函数使得椭圆和其他对象绘制时没有填充颜色，以便背景颜色能够显示在物体内部。'
- en: 'Sketch 2: Colors'
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 2：颜色
- en: 'We can specify a shade of grey with a single numerical component, but we can
    also specify a color by providing three numerical components to the same function.
    These components are given in the traditional order: red, then green, then blue.
    Each component fits in a single byte (8 bits), and it is represented by a number
    ranging from 0 to 255 that determines the shade of the component. Smaller values
    yield a darker color.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过单一的数值分量来指定灰色的色调，但我们也可以通过提供三个数值分量来指定颜色，这些分量的顺序是传统的：红色、绿色、蓝色。每个分量都占用一个字节（8
    位），并且它由一个范围从 0 到 255 的数字表示，决定了该分量的色调。数值越小，颜色越暗。
- en: The numbers (255, 0, 0) specify the brightest shade of red, while the numbers
    (254, 0, 0) specify a slightly darker shade of red. Green would be (0, 255, 0)
    and blue would be (0, 0, 255). Yellow is red and green, so a set of RGB coordinates
    for yellow would be (255, 255, 0). Magenta is red and blue, so it would be written
    as (255, 0, 255). Grey values have the three components nearly equal.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数字（255, 0, 0）指定了最亮的红色，而数字（254, 0, 0）指定了稍微暗一点的红色。绿色是（0, 255, 0），蓝色是（0, 0, 255）。黄色是红色和绿色的组合，因此黄色的
    RGB 坐标是（255, 255, 0）。品红色是红色和蓝色的组合，因此它表示为（255, 0, 255）。灰色的值则是三个分量几乎相等的情况。
- en: This is the RGB representation of color. There are other representations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是颜色的 RGB 表示法。还有其他的表示方法。
- en: Example A
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 A
- en: 'This sketch draws circles of various colors. In the `draw()` function, the
    first three calls to `fill()` and `ellipse()` draw the first row of circles: red
    1, green 2, and blue 3. The fill color changes prior to drawing each circle.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图绘制了不同颜色的圆圈。在 `draw()` 函数中，前三次调用 `fill()` 和 `ellipse()` 绘制了第一行圆圈：红色 1、绿色
    2 和蓝色 3。每次绘制圆圈之前，填充颜色都会发生变化。
- en: The second row of circles is filled with yellow 4, magenta 5, and cyan 6. Each
    color here has two nonzero color values.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行的圆圈分别填充了黄色 4、品红色 5 和青色 6。每种颜色都有两个非零的色值。
- en: The final row contains circles filled with increasingly brighter grey values
    7. Each color here has three equal color values.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行包含一组填充颜色逐渐变亮的灰色圆圈 7。这里的每种颜色都有三个相等的色值。
- en: Example B
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 B
- en: We can also use a fourth color component that represents transparency, sometimes
    referred to as the alpha channel. The components (255, 0, 0, 128) indicate that
    red is 255, green and blue are 0, and transparency is 128, or 50 percent. Higher
    numerical values indicate lower transparency. We can give any color any legal
    transparency value in addition to R, G, and B values.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用第四个颜色分量来表示透明度，通常称为 alpha 通道。分量（255, 0, 0, 128）表示红色是 255，绿色和蓝色是 0，透明度是
    128，或 50%。数值越大，透明度越低。我们可以为任何颜色指定任何合法的透明度值，除了 R、G 和 B 分量。
- en: This sketch draws sets of overlapping red, green, and blue circles to show transparency.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图绘制了一些重叠的红色、绿色和蓝色圆圈来展示透明度。
- en: In the `draw()` function, the first three calls to `fill()` and `ellipse()`
    1 draw the upper-left set of circles with a fill color transparency value of 20\.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `draw()` 函数中，前三次调用 `fill()` 和 `ellipse()` 绘制左上方的一组圆圈，填充颜色的透明度值为 20\。
- en: The second three calls 2 draw the upper-right set of circles with a transparency
    value of 100\.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 后三次调用绘制右上方的一组圆圈，透明度值为 100\。
- en: The third three calls 3 draw the lower-left set with a transparency value of
    180.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次调用 3 绘制了左下方的一组圆圈，透明度值为 180。
- en: The final three calls 4 draw the lower-right set of circles with a transparency
    value of 255, which means the color is completely opaque.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三次调用 4 绘制了右下方的一组圆圈，透明度值为 255，这意味着颜色是完全不透明的。
- en: 'Sketch 3: if Statements—Changing Colors Conditionally'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 3：if 语句—有条件地改变颜色
- en: 'In daily life, people often deal with conditional actions, although little
    if any thought is given to the idea. We express the conditions in human language,
    of course:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常生活中，人们经常处理有条件的行为，虽然很少有意识地去思考这个概念。我们当然用人类语言表达这些条件：
- en: “If it is raining, we’ll watch TV, but if it is sunny, we’ll go skiing.”
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “如果下雨，我们看电视；如果是晴天，我们去滑雪。”
- en: “If the light is red, then stop, but if it is green, just drive on through.”
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “如果红灯亮了，那就停；如果绿灯亮了，那就继续开。”
- en: We can also use conditional actions when programming a computer. If some situation
    is true, we execute a certain section of code. The condition or situation has
    to be expressed in numerical terms, and the result is a `true` or `false` result.
    Such conditions are frequently the result of comparisons between numbers, such
    as “is *i* equal to 10” or “is the x-coordinate less than the width.”
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编程时也可以使用条件动作。如果某种情况为真，我们执行某段代码。条件或情况必须以数字形式表达，结果是`true`或`false`。这样的条件通常是数字之间比较的结果，比如“*i*是否等于10”或“x坐标是否小于宽度”。
- en: 'Conditional code is dealt with using an `if` statement, which has the following
    syntax:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 条件代码通过`if`语句来处理，其语法如下：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Conditions can be comparisons between numbers, so the following are all conditions:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 条件可以是数字之间的比较，因此以下都是条件：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are some special symbols in use here. The `=` symbol means assignment,
    so to compare for equality a different symbol must be used: Processing uses `==`.
    To compare for inequality, the symbol `!=` is used, meaning “not equal.”'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些特殊符号在使用。`=`符号表示赋值，因此要比较是否相等，必须使用另一个符号：Processing使用`==`。要比较不相等，使用符号`!=`，表示“不等于”。
- en: Example A
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例A
- en: This sketch uses an `if` statement to increase an integer variable, `count`,
    every time `draw()` is called, and it changes the background color from red to
    green when the count reaches 100 1.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图使用`if`语句，每次调用`draw()`时增加一个整数变量`count`，并在`count`达到100时将背景颜色从红色变为绿色。
- en: Example B
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例B
- en: 'The previous English condition examples illustrate a normal use of another
    idea: otherwise. One example was “If it is raining, we’ll watch TV, but if it
    is sunny, we’ll go skiing.” That example could also be phrased as “If it is raining,
    we’ll watch TV; otherwise we’ll go skiing,” meaning that if it’s not raining,
    we’ll go skiing. In most computer languages this is written as an `else` part
    to an `if` statement with the following syntax:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的英语条件示例展示了另一种常见的使用方式：否则。一个例子是“如果下雨，我们就看电视；如果是晴天，我们就去滑雪。”这个例子也可以这样表达：“如果下雨，我们就看电视；否则我们就去滑雪，”意思是如果没有下雨，我们就去滑雪。在大多数编程语言中，这通常写作`else`部分，作为`if`语句的附加部分，语法如下：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example B uses an `else` to accomplish the same task as Example A 1.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 示例B使用`else`来实现与示例A相同的任务。
- en: Example C
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例C
- en: The third code example alternates between red and green each time `draw()` is
    called, creating a colored flashing effect.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个代码示例在每次调用`draw()`时交替使用红色和绿色，产生一个颜色闪烁效果。
- en: 'Sketch 4: Loops—Drawing 20 Circles'
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图4：循环——绘制20个圆
- en: Programmers often need to execute the same code over and over again, sometimes
    with small variations. A program that draws 50 ellipses within the sketch window
    could be written using fifty calls to the `ellipse()` function, one for each ellipse
    drawn. Another way is to have one statement with a call to `ellipse(),` and execute
    it 50 times in a loop.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员通常需要反复执行相同的代码，有时会有一些小的变化。一个绘制50个椭圆的程序可以写成五十次调用`ellipse()`函数，每次绘制一个椭圆。另一种方法是使用一个语句调用`ellipse()`，并在循环中执行50次。
- en: A loop in a program is a collection of statements that executes repeatedly from
    the first statement to the last, in the same order. You must specify the condition
    upon which the loop will exit. It’s pretty common to know in advance how many
    times the loop should execute, as in the example of drawing 50 ellipses. Sometimes
    you won’t know the number ahead of time, but you can calculate it, so the loop
    will execute *N* times, and *N* depends on some other thing. In either case, a
    counting loop is called a `for` loop in Processing because the reserved word `for`
    is used to begin the loop. For example,
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的循环是一个语句集合，它从第一个语句执行到最后一个语句，并且按相同的顺序重复执行。你必须指定一个条件，来决定循环何时退出。通常情况下，你知道循环应该执行多少次，比如绘制50个椭圆的例子。有时你不知道次数，但可以通过计算来得出，那么循环将执行*N*次，*N*取决于其他因素。在这两种情况下，计数循环在Processing中称为`for`循环，因为预留字`for`用于开始循环。例如：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This loop executes 10 times: once when the variable `i=0`, again when `i=1`,
    again when `i=2`, and so on until `i=9`. When `i` is 10, the condition (`i<10`)
    becomes false and the loop ends. As a result, `statementA` executes 10 times,
    once for each value of `i` from 0 to 9\.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环执行10次：当变量`i=0`时执行一次，当`i=1`时再执行一次，当`i=2`时再执行一次，依此类推直到`i=9`。当`i`为10时，条件（`i<10`）变为假，循环结束。因此，`statementA`执行了10次，每次对应`i`从0到9的值。
- en: 'The `for` loop has four parts:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环有四个部分：'
- en: '`i=0` The initialization is executed the first time through the loop.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`i=0` 初始化操作在循环的第一次执行时进行。'
- en: '`i<10` The loop will continue to execute so long as the continuation condition
    is true.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`i<10` 只要循环条件为真，循环将继续执行。'
- en: '`i=i+1` At the end of each iteration, after the statement is executed, the
    increment will be executed.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`i=i+1` 在每次迭代结束时，语句执行完后，递增操作会执行。'
- en: '`statementA` This is the code that gets executed repeatedly.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`statementA` 这是反复执行的代码。'
- en: If the expression is false at the beginning, the loop does not execute even
    once.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在开始时条件为假，则循环一次也不会执行。
- en: The statement that executes can be a compound statement, which is a collection
    of statements enclosed in braces. In fact, any time I refer to a *statement*,
    it can mean a compound statement.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的语句可以是复合语句，即一组由大括号括起来的语句。事实上，每当我提到*语句*时，它都可以指代复合语句。
- en: Example A
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 A
- en: A simple loop in Processing can draw 20 ellipses 1 starting at (20, 40) and
    ending at (210, 40). The ellipses are circles and are drawn next to each other.
    The `draw()` function exists but does not do anything 2.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Processing中，一个简单的循环可以绘制20个椭圆，起点为(20, 40)，终点为(210, 40)。这些椭圆是圆形的，并且彼此相邻。`draw()`函数存在但不执行任何操作。
- en: Example B
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 B
- en: We can make the color change for each circle by using a compound statement.
    Let’s change the green value by 10 each time a circle is drawn, starting with
    `green = 10` 1. Red and blue both stay at their maximum of 255\. The code within
    the loop needs to set the fill color, draw the circle, and adjust the fill color
    for the next iteration 2.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用复合语句来使每个圆的颜色发生变化。每次绘制一个圆时，将绿色值增加10，从`green = 10`开始。红色和蓝色的值保持在最大值255。循环中的代码需要设置填充颜色、绘制圆形，并在下一次迭代时调整填充颜色。
- en: 'The loop executes for 20 values of `i`: 0 to 19 inclusive. If we were to expand
    the code to show what was being executed, it would look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 循环会执行20次，即`i`的值从0到19（包括19）。如果我们展开代码以展示执行的内容，它会如下所示：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Sketch 5: Lines'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 5：线条
- en: Drawing lines is a basic thing to do in graphics. A line in Processing is really
    a line segment, and it is specified by identifying two endpoints that are to be
    connected by the line. The function that draws a line is named `line()`, and it
    takes the coordinates of the endpoints as parameters (for a total of four parameters).
    The call `line (10,10, 20,20)` will draw a line in the window between coordinates
    (10, 10) and (20, 20).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制线条是图形绘制中的基本操作。在Processing中，线条实际上是线段，通过标识两个要连接的端点来指定。绘制线条的函数名为`line()`，它接受两个端点的坐标作为参数（共四个参数）。调用`line
    (10,10, 20,20)`将在窗口中绘制一条从坐标(10, 10)到(20, 20)的线。
- en: Example A
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 A
- en: 'Let’s draw some note paper. We can draw a horizontal line that runs the full
    width of the sketch window using this call, for some vertical position `y`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来画一些便签纸。我们可以通过以下调用绘制一条水平线，这条线将横跨整个草图窗口的宽度，`y`表示垂直位置：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The width of the window is given by the variable `width`, and the height of
    the window is given by the variable `height`. The start of the line is `(0, y)`
    at the left of the image window `y` pixels down from the top; the end of the line
    is at `(width, y)` at the right of the window and the same *y* value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的宽度由变量`width`给出，窗口的高度由变量`height`给出。线的起点是`(0, y)`，位于图像窗口的左侧，距离顶部`y`像素；线的终点是`(width,
    y)`，位于窗口的右侧，且`y`值保持不变。
- en: The color for drawing lines can be specified using a call to `stroke()` with
    a color as the parameter. For example, `stroke (255,0,0`) 1 specifies that red
    lines will be drawn.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制线条的颜色可以通过调用`stroke()`并传入颜色参数来指定。例如，`stroke (255,0,0)` 表示将绘制红色线条。
- en: Example B
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 B
- en: Processing will tell you where the mouse cursor is within the window using the
    built-in variables `mouseX` and `mouseY` 1. Whenever a mouse button is pressed,
    Processing calls a function called `mousePressed()`, if it exists. You have to
    write it if you want to use the mouse. When a mouse button is released, Processing
    calls the `mouseReleased()` function 2. You have to write that one too. The `mousePressed()`
    and `mouseReleased()` functions are referred to as callbacks, and they offer a
    very simple way to access button presses. Additionally, press and release amount
    to touches on a touch screen device, so the program will work on touch screen
    devices as well.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Processing会通过内建变量`mouseX`和`mouseY` 1告诉你鼠标光标在窗口中的位置。每当按下鼠标按钮时，Processing会调用一个名为`mousePressed()`的函数（如果它存在）。如果你希望使用鼠标，必须编写这个函数。当鼠标按钮释放时，Processing会调用`mouseReleased()`函数
    2。你也必须编写这个函数。`mousePressed()`和`mouseReleased()`函数被称为回调函数，它们提供了一种非常简单的方式来访问按钮按下事件。此外，按下和释放操作相当于触摸屏设备上的触摸操作，因此该程序也可以在触摸屏设备上运行。
- en: This example uses clicks (presses and releases) to draw lines. The first mouse
    click defines the starting point for the line (`x0`, `y0`) 3. The second click
    (when `x1 < 0`) 4 defines the endpoint of the line. A third click (when `x1 >=
    0`) 5 clears the endpoints and starts again.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用鼠标点击（按下和释放）来绘制线条。第一次鼠标点击定义了线条的起点（`x0`，`y0`）3。第二次点击（当`x1 < 0`时）4定义了线条的终点。第三次点击（当`x1
    >= 0`时）5清除终点并重新开始。
- en: 'Sketch 6: Arrays—Drawing Many Circles'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图6：数组——绘制多个圆形
- en: 'A variable can hold a value, such as a single number. If we want more values,
    we can use more variables. For example, to draw two circles, we could have two
    sets of coordinate variables, say `x0`, `y0` and `x1`, `y1`, and we could draw
    the two circles with two calls:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以保存一个值，比如一个数字。如果我们需要更多的值，可以使用更多的变量。例如，若要绘制两个圆形，我们可以有两组坐标变量，分别是`x0`、`y0`和`x1`、`y1`，然后我们可以通过两次调用来绘制这两个圆形：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But what if we wanted to draw a circle every time the mouse button was clicked,
    and to draw it where the cursor is on the screen? We don’t know how many circles
    to draw in advance, so we don’t know how many variables to declare. Instead, we
    can keep track of *x* and *y* using what Processing calls an array. An array is
    a collection of values all having the same type. The syntax for declaring an array
    is
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们希望每次点击鼠标时都绘制一个圆形，并且把圆形绘制在光标所在的屏幕位置呢？我们无法提前知道要绘制多少个圆形，因此也不知道要声明多少个变量。相反，我们可以使用Processing所称的数组来跟踪*x*和*y*。数组是一个包含相同类型值的集合。声明数组的语法是
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This declaration defines an array named `x` that can hold 100 integers. The
    phrase `int [] x` means “define a new array named x,” and the phrase `new int[100]`
    defines the size, where 100 could be replaced by any constant. The preceding declaration
    could also be done in two parts:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明定义了一个名为`x`的数组，它可以存储100个整数。`int [] x`表示“定义一个名为x的新数组”，`new int[100]`表示数组的大小，其中100可以被任何常量替代。上述声明也可以分两部分进行：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You access the values in the array using an index, a number that specifies
    which of the values you want, starting from 0: `x[0]` is the first element (value)
    in the array with an index of `0`, `x[1]` is the second with an index of `1`,
    and so on to the last one, `x[99]`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过索引访问数组中的值，索引是一个数字，用来指定你想要的值，索引从0开始：`x[0]`是数组中的第一个元素（值），索引为`0`，`x[1]`是第二个元素，索引为`1`，以此类推，直到最后一个元素`x[99]`。
- en: The example sketch uses two arrays, one for `x` and one for `y`, and it draws
    a circle at the coordinates where the mouse button is clicked (pressed and released).
    Initially each element in the `x` and `y` array is given the value −1 1 in `setup()`.
    This is called a sentinel value, and it indicates that there is no circle defined
    at that index. The `ncircles` variable indicates how many circles have been defined,
    which is how many mouse clicks have been recorded; it starts at 0 and is incremented
    up to the maximum number of circles (`MAXCIRCLES`, a constant defined to be 100).
    When the mouse button is released, the system calls the `mouseReleased()` callback
    function 3, which saves the current value of the mouse coordinates in the arrays
    `x` and `y` at the current position (`ncircles`) and increases `ncircles` by 1\.
    If `ncircles` becomes equal to `MAXCIRCLES`, it is reset to 0 4, which means that
    new circles will be saved over the earliest ones drawn. The old ones will, of
    course, be lost.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 示例草图使用了两个数组，一个用于`x`，一个用于`y`，并在鼠标点击（按下和释放）时绘制圆圈的坐标。最初在`setup()`中，`x`和`y`数组的每个元素被赋值为-1
    1。这称为哨兵值，它表示该索引位置没有定义圆圈。`ncircles`变量表示已经定义了多少个圆圈，即记录了多少次鼠标点击；它从0开始，并递增至最大圆圈数量（`MAXCIRCLES`，一个定义为100的常量）。当鼠标按钮释放时，系统调用`mouseReleased()`回调函数
    3，保存当前鼠标坐标的值到`x`和`y`数组的当前位点（`ncircles`），并将`ncircles`增加1。如果`ncircles`等于`MAXCIRCLES`，它会被重置为0
    4，这意味着新的圆圈将覆盖最早绘制的圆圈。旧的圆圈自然会丢失。
- en: 'The `draw()` function first sets the background and then draws a circle at
    the mouse coordinates. Then all the elements of the `x` array are examined, and
    if the value of element `i` is greater than 0, a circle is drawn at `x[i], y[i]`
    2 using this call:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()`函数首先设置背景，然后在鼠标坐标处绘制一个圆圈。接着检查`x`数组的所有元素，如果元素`i`的值大于0，就会使用以下调用在`x[i],
    y[i]`的位置绘制一个圆圈：'
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The constant value `MAXCIRCLES` is defined using a special `final` property
    in its declaration:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 常量值`MAXCIRCLES`在声明时使用特殊的`final`属性进行定义：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The value of `MAXCIRCLES` can’t be changed anywhere in the program because
    it is `final`. It can (and should) be used to define the size of the two arrays:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAXCIRCLES`的值在程序中不能被更改，因为它是`final`。它可以（并且应该）用于定义两个数组的大小：'
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Defining the size of the arrays using a constant means that to increase the
    number of circles allowed, you only need to change the value of `MAXCIRCLES`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常量定义数组的大小意味着，要增加允许的圆圈数量，只需要更改`MAXCIRCLES`的值。
- en: 'Sketch 7: Lines with Rubber Banding'
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 7：带有橡皮筋的线条
- en: We are going to use the mouse to draw lines again. A line consists of a starting
    point and an endpoint, each having an x and a y component. We previously drew
    a line when the mouse was clicked on start and end points on the screen, but it
    only drew *one* line. What if we wanted to be able to draw many lines like this?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用鼠标绘制线条。一条线由一个起点和一个终点组成，每个点都有x和y坐标。我们之前在鼠标点击屏幕上的起点和终点时绘制了一条线，但它只绘制了*一*条线。如果我们想能够像这样绘制多条线，该怎么办呢？
- en: We can define a starting point when the mouse button is pressed 3 and the endpoint
    when the button is released 4, as we did before. But now we can store these points
    in arrays and draw them all during each screen update. The array `x0` saves the
    starting x-coordinate of a line, and `y0` has the corresponding y-coordinate.
    The arrays `x1` and `y1` will store the end coordinates. When the mouse button
    is pressed, we save the starting point (`x0[n]`, `y0[n]`), andwhen the mouse button
    is released, we save the endpoint as `x1[n]` and `y1[n]` and increment the value
    of `n`. This program will allow us to draw 256 lines because of the fixed size
    of the arrays.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像之前一样，当鼠标按下时定义起点 3，释放按钮时定义终点 4。但现在我们可以将这些点存储在数组中，并在每次屏幕更新时绘制它们。数组`x0`保存线条的起始x坐标，`y0`保存对应的y坐标。数组`x1`和`y1`将存储终点坐标。当鼠标按下时，我们保存起点(`x0[n]`,
    `y0[n]`)，当鼠标释放时，我们保存终点为`x1[n]`和`y1[n]`，并将`n`的值递增。由于数组的固定大小，该程序将允许我们绘制256条线。
- en: When the starting point has been selected, we draw a line from that point to
    the current mouse coordinates to show how the line *would* look 2. This is called
    rubber banding because the line appears to stretch and contract as the mouse moves.
    When the mouse button is released, we finalize the end coordinates and draw the
    final line.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当起始点被选择后，我们从该点画一条线到当前的鼠标坐标，以显示这条线*应该*如何呈现。这被称为橡皮带效果，因为线条在鼠标移动时看起来像是伸展和收缩。当鼠标按钮被释放时，我们确定最终坐标并画出最终的线条。
- en: 'During each frame (the default is 30 frames per second) we draw all of the
    saved lines by calling `line (x0[i], y0[i], x1[i], y1[i])` for all `i` from `0`
    to `n-1` 1. We then draw the rubber band line if the mouse button is currently
    depressed (when `down` is set to `true`). Setting `down` to `true` happens in
    `mousePressed`, and it is set to `false` when the button is released, within `mouseReleased`.
    If `down` is `true`, a line is drawn from the last selected point to the mouse
    coordinates:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中（默认是每秒 30 帧），我们通过调用 `line (x0[i], y0[i], x1[i], y1[i])` 来绘制所有保存的线条，`i`
    从 `0` 到 `n-1`。然后，如果鼠标按钮当前被按下（当 `down` 被设置为 `true` 时），我们将绘制橡皮带线。在 `mousePressed`
    中设置 `down` 为 `true`，在 `mouseReleased` 中将其设置为 `false`。如果 `down` 为 `true`，则从最后选定的点到鼠标坐标之间绘制一条线：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This implements the rubber banding.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这实现了橡皮带效果。
- en: As a new idea, the sketch implements an *erase* feature. If the user types the
    backspace key, the most recent line is deleted. When the system detects a key
    press, Processing calls a user-defined function named `keyPressed()` 5. A variable
    named `key` provides the value of the key that was pressed, so inside `keyPressed()`
    we check if the key is backspace, and if so we decrease the value of `n` (the
    number of lines so far) by 1\. As a result, the last line will not be drawn, and
    the next line will be saved over the erased line in the coordinate arrays.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种新功能，草图实现了一个 *擦除* 特性。如果用户按下退格键，最近的线条将被删除。当系统检测到按键时，Processing 会调用一个用户定义的名为
    `keyPressed()` 的函数。一个名为 `key` 的变量提供了被按下的键的值，因此在 `keyPressed()` 内，我们检查按下的键是否是退格键，如果是，则将变量
    `n`（到目前为止的线条数）减 1。结果是，最后一条线不会被绘制，下一条线将覆盖被擦除的线条在坐标数组中的位置。
- en: 'Sketch 8: Random Circles'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 8：随机圆圈
- en: This sketch draws circles at random places on the screen, with random colors.
    Randomness refers to unpredictability, and it is a complex concept. If you try
    to draw straight lines with a pencil, it is impossible that any two of them will
    be identical. There are variations that creep in and cause minor changes in each
    line. The same is true of brush strokes when painting. No two human activities
    will be exactly the same, and the differences will be unpredictable but apparent.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图在屏幕上随机位置绘制圆圈，并使用随机颜色。随机性指的是不可预测性，它是一个复杂的概念。如果你尝试用铅笔画直线，那么不可能有两条完全相同的直线。总会有些微小的变化，导致每条线有所不同。画画时也一样，笔触不会完全一致。没有两个人类活动会完全相同，差异虽不可预测，但是显而易见的。
- en: When using a computer, a random number generator creates numbers that are random
    with respect to each other. Random numbers can be used to simulate random events
    in games like dice or poker, to do things that a user would find unpredictable,
    or to simulate complex real-world situations. For example, things like the spacing
    between cars on a road and the appearance of raindrops on a window appear random
    because we do not understand all of the complex factors that went into the situation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算机时，随机数生成器会创建彼此间相对随机的数字。随机数可用于模拟游戏中的随机事件，比如骰子或扑克牌，用来做一些用户难以预测的事情，或模拟复杂的现实世界情境。例如，道路上车辆之间的间距以及窗户上雨滴的出现看似随机，因为我们并不了解所有涉及到的复杂因素。
- en: The random number generator in Processing is named `random`. The call `random
    (100)` will generate a real number between 0 and 100, not including 100\. The
    call `random (10, 20)` will return a real number between 10 and 20, but less than
    20\. The call `random (0, width)` generates a random *x* position within the sketch
    window, and `random (0, height)` generates a random *y* position.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 中的随机数生成器被命名为 `random`。调用 `random (100)` 将生成一个介于 0 和 100 之间的实数，但不包括
    100。调用 `random (10, 20)` 将返回一个介于 10 和 20 之间的实数，但小于 20。调用 `random (0, width)` 会生成一个介于
    0 和窗口宽度之间的随机 *x* 坐标，而 `random (0, height)` 会生成一个介于 0 和窗口高度之间的随机 *y* 坐标。
- en: 'Like Sketch 6, this sketch stores coordinates in arrays and uses them to draw
    circles with calls to `ellipse()`, but instead of drawing circles when the mouse
    is clicked, a new circle is created automatically every second. To do this, we
    set the rate at which `draw()` is called (the frame rate) to 1 using the call
    `frameRate(1)` 1 in `setup()`. Each time `draw()` is called, we generate a new
    x- and y-coordinate using `random()` and save it in the `x` and `y` arrays 2:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Sketch 6 一样，这个草图将坐标存储在数组中，并通过调用 `ellipse()` 来绘制圆形，但不是在点击鼠标时绘制圆形，而是每秒自动创建一个新的圆形。为此，我们在
    `setup()` 中通过调用 `frameRate(1)` 将 `draw()` 的调用频率设置为 1。每次调用 `draw()` 时，我们使用 `random()`
    生成一个新的 x 和 y 坐标，并将其保存在 `x` 和 `y` 数组中：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `(int)` in front of the calls to random converts the result, a `float`,
    into a new type, `int`. This is called a cast, and we are changing the floating-point
    value into an integer because we can’t use values with decimal points as coordinates.
    This can also be done using a call to the function `int()`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `random` 时前面的 `(int)` 将结果（`float` 类型）转换为新类型 `int`。这叫做类型转换，我们将浮点值转换为整数，因为不能使用带小数点的值作为坐标。也可以使用调用函数
    `int()` 来实现这一点：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Sketch 9: A Rectangle'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 9：一个矩形
- en: You could draw a rectangle by drawing four lines that represent the edges, but
    the Processing system would not consider this to be a rectangle; it has no way
    to know that the four lines are a single object. Instead, Processing has a function
    for drawing rectangles, called `rect()`. Rectangles will be filled using the current
    fill color, just as circles were.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过绘制四条代表矩形边缘的线来绘制一个矩形，但 Processing 系统不会认为这是一种矩形；它无法知道这四条线是一个单独的对象。相反，Processing
    提供了一个绘制矩形的函数，叫做 `rect()`。矩形会使用当前的填充颜色，就像绘制圆形时一样。
- en: 'The default way to specify a rectangle is `CORNER` mode, where the first two
    parameters you supply are the coordinates of the upper-left corner of the rectangle,
    followed by the width and the height, in pixels. If you specify `CENTER` mode,
    the first two parameters are the coordinates of the center of the rectangle. `CORNERS`
    mode specifies the coordinates of the first corner, then the coordinates of the
    diagonally opposite corner. You can change the mode using one of the following
    calls:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 指定矩形的默认方式是 `CORNER` 模式，在这种模式下，你提供的前两个参数是矩形左上角的坐标，后面跟着矩形的宽度和高度（以像素为单位）。如果你指定
    `CENTER` 模式，前两个参数是矩形中心的坐标。`CORNERS` 模式指定的是第一个角的坐标，然后是对角线另一角的坐标。你可以使用以下调用之一来更改模式：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this sketch we’ll use `CORNERS` mode 1, as specified in the `setup` function,
    and fill the rectangle with a shade of purple: `(200, 0, 160)`. As in the previous
    sketches, the `mousePressed()` function sets a Boolean `flag` variable to `true`
    when the mouse button is pressed 3, and `mouseReleased()` clears the variable
    (sets it to `false`) 5.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个草图中，我们将使用 `CORNERS` 模式 1，正如在 `setup` 函数中指定的那样，并将矩形填充为一种紫色的色调：（`200, 0, 160`）。与之前的草图一样，当鼠标按钮被按下时，`mousePressed()`
    函数将布尔值 `flag` 变量设置为 `true` 3，而 `mouseReleased()` 则清除该变量（将其设置为 `false`） 5。
- en: The global variables `x` and `y` represent the first corner of the rectangle
    and are initialized to −1\. When the mouse button is pressed, we set `x` and `y`
    to the current value of `mouseX` and `mouseY` 4, and the `flag` variable is set
    to indicate that `x` has been set. Then the `draw()` function will draw a rectangle
    with `(x, y)` as one corner and the current mouse position `(mouseX, mouseY)`
    as the other 2. This implements the rubber band effect.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量 `x` 和 `y` 代表矩形的第一个角，并初始化为 -1。当鼠标按钮被按下时，我们将 `x` 和 `y` 设置为当前的 `mouseX` 和
    `mouseY` 值 4，并将 `flag` 变量设置为表示 `x` 已设置。然后，`draw()` 函数将绘制一个矩形，以 `(x, y)` 作为一个角，当前鼠标位置
    `(mouseX, mouseY)` 作为另一个角 2。这样就实现了橡皮筋效果。
- en: Global variables `x1` and `y1` are the coordinates of the second corner of the
    rectangle. When the mouse is released, we see the values of `x1` and `y1` to the
    current mouse coordinates 6, and this completes the rectangle. The `draw()` function
    will draw the rectangle with the value of `x1` and `y1` as the opposite corner
    because `flag` is now false.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量 `x1` 和 `y1` 是矩形第二个角的坐标。当鼠标释放时，我们将 `x1` 和 `y1` 的值设置为当前鼠标坐标 6，这样矩形就完成了。`draw()`
    函数将使用 `x1` 和 `y1` 作为对角线的另一角来绘制矩形，因为 `flag` 现在为假。
- en: 'Sketch 10: Triangles and Motion'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 10：三角形与运动
- en: 'Just as rectangles are drawn using the built-in `rect()` function, triangles
    are drawn using the built-in `triangle()` function. Triangles can’t be drawn using
    a height and width; their shape is determined by their three angles. As a result,
    the `triangle()` function has six arguments: the x, y coordinates of the three
    vertices (corners).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用内置的`rect()`函数绘制矩形一样，三角形是通过内置的`triangle()`函数绘制的。三角形不能通过高度和宽度来绘制；它们的形状由三个角度决定。因此，`triangle()`函数有六个参数：三个顶点（角点）的x,
    y坐标。
- en: This sketch draws triangles using the mouse. Like the previous sketches that
    draw rectangles and lines, this sketch uses `mouseReleased()` 3 to determine when
    a point has been selected. After three clicks, a triangle will be drawn using
    the three selected points as the vertices.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图使用鼠标绘制三角形。与前面绘制矩形和线条的草图一样，这个草图使用`mouseReleased()` 3来确定何时选择一个点。经过三次点击后，三角形将使用这三个选择的点作为顶点绘制出来。
- en: After the triangle is drawn, it begins to move downward, as if it had been pushed
    slightly. It continues to move downward until it hits the bottom border of the
    sketch window, where it disappears.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形绘制完成后，它开始向下移动，好像被轻轻推了一下。它继续向下移动，直到碰到草图窗口的底部边界，在那里它消失了。
- en: We accomplish the motion by adding a small value 1 (`delta` = 1) to the y-coordinates
    of the triangle after each time it is drawn. This draws the triangle at successively
    lower locations in the window until it appears to pass beyond the bottom edge
    of the window. In fact, the triangle still exists to the Processing system, and
    its coordinates continue to update even though it can’t be seen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在每次绘制三角形后，将一个小值1（`delta` = 1）添加到三角形的y坐标来实现这个运动。这样，三角形会在窗口中依次绘制在较低的位置，直到它似乎越过了窗口的底边。事实上，三角形仍然存在于Processing系统中，尽管它无法被看到，其坐标仍在更新。
- en: If the user of this program clicks the mouse after the triangle is drawn, the
    triangle disappears and the drawing process begins again. We restart the drawing
    process by re-initializing all of the vertices to −1 4, which indicates that they
    have not been defined yet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该程序的用户在三角形绘制后点击鼠标，三角形会消失，绘图过程重新开始。我们通过将所有顶点重新初始化为−1 4来重新启动绘图过程，这表示它们还没有被定义。
- en: 'The following line of code is commented out inside of `draw()`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行在`draw()`内部被注释掉：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you remove the `//` at the beginning of the line, the line will execute and
    the triangle will fall faster and faster, as if being pulled by a force (for example,
    gravity). Remove the // from the line near the end of `mouseReleased()` as well
    and the initial speed will reset to 1 with each new triangle drawn.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你删除行首的`//`，该行代码将会执行，三角形将会加速下落，就像受到某种力（例如重力）的作用一样。也删除`mouseReleased()`末尾附近的`//`，这样每次绘制新的三角形时，初始速度将重置为1。
- en: 'Sketch 11: Displaying Text'
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 11：显示文本
- en: Text is essential in nearly all practical computational programs and in many
    generative art and net art programs as well. Text is a primary way that humans
    communicate, and while we say that “a picture is worth a thousand words,” it is
    frequently true that a few carefully chosen words can make an otherwise incomprehensible
    image into a valuable communications tool. Think of the labels along the axis
    of a graph, for instance.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 文本在几乎所有实用的计算程序中都是必不可少的，在许多生成艺术和网络艺术程序中也是如此。文本是人类沟通的主要方式，尽管我们常说“一张图胜过千言万语”，但实际上，几句精心挑选的话常常能把一幅本来难以理解的图像变成有价值的沟通工具。例如，想想图表轴上的标签。
- en: We draw text in the sketch window in the same way that we draw lines and ellipses,
    using a simple function. The first thing you need to know is that text is drawn
    starting at a particular (*x*, *y*) location, where *x* and *y* represent the
    coordinates of the lower-left corner of the box that encloses the text *when not
    considering descenders*. Characters such as *y* and *j* extend below this box,
    and they so have *y* values greater than the value specified.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在草图窗口中绘制文本的方式与绘制线条和椭圆的方式相同，使用一个简单的函数。首先，你需要知道的是，文本的绘制是从特定的(*x*, *y*)位置开始的，其中
    *x* 和 *y* 表示包围文本的框的左下角的坐标（*不考虑下行字形*）。像 *y* 和 *j* 这样的字符会延伸到这个框的下方，因此它们的 *y* 值大于指定的值。
- en: 'We will draw text using a call to the function `text()` 2:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过调用`text()`函数来绘制文本 2：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, the coordinates of the lower left of the string are `(100, 20)`.
    The initial font and size are defaults, and these defaults are system dependent.
    Size is easy to specify using the `textSize(n)` function 1, passing the desired
    size of the characters *in pixels* (not points). The color used to draw the text
    is the current fill color, not the stroke color.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，字符串左下角的坐标是`(100, 20)`。初始字体和大小是默认值，这些默认值依赖于系统。可以使用`textSize(n)`函数轻松指定大小，传递所需的字符大小*以像素为单位*（不是点数）。绘制文本的颜色是当前的填充颜色，而不是描边颜色。
- en: The alignment of the text can be specified using calls to the `textAlign()`
    function 3. Horizontal alignment can be `LEFT`, `CENTER`, or `RIGHT` with respect
    to the x- and y-coordinates specified in the `text()` function call; the default
    is `LEFT`. Vertical alignment can be `TOP`, `CENTER`, `BOTTOM`, or `BASELINE`
    with respect to the x- and y-coordinates specified in the `text()` function call;
    the default is `BASELINE`. `BOTTOM` is the line that defines the lowest *y* value
    for any character, such as the bottom of a descender. `BASELINE` defines the lowest
    point of a typical character with no descender. So, the call
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 文本的对齐可以通过调用`textAlign()`函数来指定。水平对齐可以是`LEFT`、`CENTER`或`RIGHT`，相对于在`text()`函数调用中指定的x和y坐标；默认值是`LEFT`。垂直对齐可以是`TOP`、`CENTER`、`BOTTOM`或`BASELINE`，相对于在`text()`函数调用中指定的x和y坐标；默认值是`BASELINE`。`BOTTOM`是定义任何字符最低*y*值的行，例如下降部分的底部。`BASELINE`定义了没有下降部分的典型字符的最低点。因此，调用
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: will center the current text from left to right (the specified *x* value is
    the center of the string) and aligned so that the specified *y* value is the bottom
    of the string.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 会使当前文本从左到右居中（指定的*x*值是字符串的中心），并使其对齐，以便指定的*y*值是字符串的底部。
- en: Example A illustrates how to display text in two different sizes. Example B
    shows a line drawn horizontally on each x-coordinate and vertically down each
    y-coordinate specified in the `text()` call. It shows the alignment of the text
    with respect to the specified coordinates.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 示例A展示了如何以两种不同的大小显示文本。示例B显示了一条在每个x坐标上水平绘制并在每个y坐标上垂直绘制的线。它展示了文本相对于指定坐标的对齐情况。
- en: 'Sketch 12: Manipulating Text Strings'
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例12：操作文本字符串
- en: The previous sketch is really an introduction to character strings, which are
    a natural way for a human to communicate with a computer. A string is a sequence
    of characters; so is a word, a sentence, or a paragraph. At a high level, a string
    consists of a collection of characters in a specific order. There is a first character,
    a second, and so on until the final one is reached. The number of characters in
    this sequence is the length of the string.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例实际上是对字符字符串的介绍，字符字符串是一种人与计算机交流的自然方式。字符串是字符的序列；单词、句子或段落也是如此。从高层次来看，字符串由按特定顺序排列的字符集合组成。它有第一个字符、第二个字符，以此类推，直到到达最后一个字符。这个序列中字符的数量就是字符串的长度。
- en: 'String constants are character sequences enclosed in double quotes like this:
    `"To be or not to be"`. We can use string constants to declare variables that
    are `String`s and assign values to them. At 1, for example, we declare two string
    variables and assign string constants to them:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串常量是用双引号括起来的字符序列，如：`"To be or not to be"`。我们可以使用字符串常量声明`String`类型的变量并为其赋值。例如，在1中，我们声明了两个字符串变量并为其赋值字符串常量：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Strings can be constructed by sticking other strings together. The `+` operator,
    when applied to strings, means concatenate or append, so the quote can be completed
    by concatenating these two strings:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以通过将其他字符串拼接在一起来构造。当对字符串应用`+`运算符时，意味着连接或附加，因此可以通过拼接这两个字符串来完成引号：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This makes `s1` become `"To be or not to bethat is the question."` Unfortunately,
    this is not quite right, because we need a comma and a space between the two strings.
    This would be better:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`s1`变成了`"To be or not to bethat is the question."` 不幸的是，这样不太对，因为我们需要在两个字符串之间加上一个逗号和一个空格。这样会更好：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first character, “T”, in this new string has an index of 0, meaning it is
    in the 0 position in the string. The character “o” is in position 1, and so on.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新字符串中的第一个字符“T”在索引位置0，意味着它在字符串的第0位置。字符“o”在位置1，以此类推。
- en: 'A substring is a sequence of characters within the string specified by indices.
    The substring of `s1` from index 6 to 11 is the string `"or not"`, and it is found
    in Processing as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 子字符串是由索引指定的字符串中的字符序列。`s1`从索引6到11的子字符串是字符串`"or not"`，可以在Processing中如下找到：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The length of this string is six characters, and that length is returned by
    the function `length()`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串的长度是六个字符，`length()`函数返回这个长度：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The character at a specific location can be found with the `charAt()` function.
    For example, `s1.charAt(3)` is “b” and `s1.charAt(18)` is “,”.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`charAt()`函数在特定位置找到字符。例如，`s1.charAt(3)`是“b”，`s1.charAt(18)`是“,”。
- en: 'Strings cannot be compared using the standard relational operators (because
    they are really class instances, which will be discussed later). Instead, there
    are functions for comparison. Comparing `s1` and `s2` could be accomplished like
    this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串不能使用标准的关系运算符进行比较（因为它们实际上是类实例，稍后会讨论）。相反，有用于比较的函数。比较`s1`和`s2`可以通过以下方式实现：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This sketch shows some string operations and their results, drawn using the
    `text()` function discussed in Sketch 11\. The sketch includes examples of `length()`
    3, `charAt()` 4, and `substring()` 5.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图展示了一些字符串操作及其结果，这些操作是使用第11个草图中讨论的`text()`函数绘制的。草图包括`length()` 3、`charAt()`
    4和`substring()` 5的示例。
