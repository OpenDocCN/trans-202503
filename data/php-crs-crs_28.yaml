- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 23 ERROR HANDLING WITH EXCEPTIONS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 23 使用异常处理错误
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Applications don’t always function the way you want. For example, a file may
    not upload because of a network error, or data from a user or web API may be malformed
    in some way. In this chapter, you’ll learn to use *exceptions* to anticipate these
    sorts of problems and recover from them, so your application doesn’t always crash
    when something goes wrong. You’ll work with PHP’s generic Exception class, along
    with other, more specialized exception classes built into the language. You’ll
    also see how to design your own custom exception classes, as well as how to design
    your applications to safely handle any and all exceptions that may arise.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序并不总是按你想要的方式运行。例如，文件可能因为网络错误而无法上传，或者来自用户或Web API的数据可能以某种方式被破坏。在本章中，你将学习如何使用*异常*来预见这些问题并从中恢复，这样当出现问题时，你的应用程序就不会总是崩溃。你将使用PHP的通用Exception类，以及内置语言中其他更专业化的异常类。你还将看到如何设计自己的自定义异常类，以及如何设计应用程序以安全地处理可能发生的所有异常。
- en: '### The Basics of Exceptions'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### 异常基础'
- en: '*Exceptions* are classes that provide a sophisticated and customizable approach
    to handling and recovering from anticipated, problematic circumstances in OOP.
    They differ from *errors*, which arise from circumstances or events that can’t
    be recovered from, such as the computer system running out of memory or a class
    declaration attempting to use a constant that can’t be found. PHP has a built-in
    Exception class for handling generic problems, along with other more specialized
    exception classes that cater to particular types of errors. You can also develop
    your own custom exception classes.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常*是类，提供了一种复杂且可定制的方式来处理和恢复面向对象编程（OOP）中预期的、具有问题的情况。它们不同于*错误*，后者通常是无法恢复的情况或事件，例如计算机系统内存不足或类声明尝试使用一个找不到的常量。PHP具有一个内置的Exception类，用于处理通用问题，以及其他更多针对特定类型错误的专业化异常类。你还可以开发自己的自定义异常类。'
- en: Exception-based software design allows you to write code in the most natural
    sequence, assuming it will all work fine, and then to separately write code to
    capture and address any typical problems that may occur. This involves writing
    tests into the methods of a class that generate exception objects and disrupt
    the flow of program control whenever an unusual or invalid situation occurs, such
    as providing invalid arguments for a constructor or setter method. Thanks to these
    tests, code appearing later in a method can be written with the safe assumption
    that if execution gets that far, the exception-throwing conditions haven’t occurred,
    and the code is working as it should.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 基于异常的软件设计允许你按最自然的顺序编写代码，假设一切都会正常工作，然后单独编写代码来捕获并解决可能发生的任何典型问题。这涉及到将测试写入类的方法中，这些方法会生成异常对象，并在发生异常或无效情况时打断程序控制的流程，例如为构造函数或设置方法提供无效的参数。由于有这些测试，可以安全地假设方法中后续出现的代码，如果执行到那一步，表示没有触发抛出异常的条件，代码按预期工作。
- en: Central to exception-based application programming are throw and catch statements.
    A method uses a throw statement to create an exception object when a problem occurs.
    This is called *throwing an exception*. The throw statement halts the execution
    of the method and disrupts the flow of the program. By itself, throwing an exception
    can lead to a fatal error, unless you *catch* the exception with a catch statement.
    The catch statement features code that’s intended to be executed when an exception
    is thrown; such code may allow the application to recover from the issue, or if
    non-recoverable, then the problem can be logged and execution ended gracefully.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 异常应用编程的核心是throw和catch语句。方法使用throw语句在发生问题时创建异常对象，这叫做*抛出异常*。throw语句会中止方法的执行并打断程序的流程。仅仅抛出异常可能会导致致命错误，除非你用catch语句*捕获*异常。catch语句包含的代码是当异常被抛出时执行的代码；这些代码可能允许应用程序从问题中恢复，或者如果无法恢复，则可以记录问题并优雅地结束执行。
- en: In this section, we’ll explore the basics of throwing and catching exceptions.
    We’ll also look at finally statements, pieces of code that are executed at the
    end of a process, regardless of whether an exception has been thrown.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨抛出和捕获异常的基础知识。我们还将介绍finally语句，它是在过程结束时执行的代码块，无论是否抛出了异常。
- en: Throwing an Exception
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 抛出异常
- en: First, we’ll consider how to throw an uncaught exception to cause a fatal error,
    halting an application. We’ll examine the common use case of throwing an exception
    when an invalid argument is provided to the setter method of a class. We’ll create
    a variation of the Food and Dessert classes from [Chapter 19](chapter19.xhtml),
    adding exception-based validation behavior in the setCalories() method of the
    Dessert class. An exception will be thrown if a negative value is provided as
    the number of calories for a new Dessert object. The project we’ll create is illustrated
    in the UML class diagram in [Figure 23-1](#fig23-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将考虑如何抛出未捕获的异常，以导致致命错误并终止应用程序。我们将研究一个常见用例，即当向类的 setter 方法提供无效参数时抛出异常。我们将创建一个变体版本的
    Food 和 Dessert 类，基于 [第 19 章](chapter19.xhtml)，在 Dessert 类的 setCalories() 方法中添加基于异常的验证行为。如果为新的
    Dessert 对象提供负数的 calories 值，则会抛出异常。我们将创建的项目在 [图 23-1](#fig23-1) 的 UML 类图中有所展示。
- en: '![](../images/figure23-1.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure23-1.jpg)'
- en: 'Figure 23-1: A diagram showing an exception thrown by the Dessert class'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23-1：一个展示 Dessert 类抛出异常的图示
- en: Recall that Dessert is a subclass of Food, with its own __toString() method
    and a calories property. The diagram indicates that an invalid calories value
    will throw an exception.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，Dessert 是 Food 的一个子类，具有自己的 __toString() 方法和 calories 属性。图示表明，如果 calories
    值无效，将抛出异常。
- en: First, we’ll declare the Food class. Create a new project with *src/Food.php*
    containing the code in [Listing 23-1](#lis23-1).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明 Food 类。创建一个新项目，并将 [列表 23-1](#lis23-1) 中的代码放入 *src/Food.php*。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 23-1: The Food superclass'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23-1：Food 超类
- en: We assign the Food class to the Mattsmithdev namespace and give it a name property
    with protected visibility so that all subclasses can directly access it. The class
    has a straightforward constructor to initialize name when each new object is created,
    and a __toString() method to return a string in the form "(FOOD) name".
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 Food 类分配到 Mattsmithdev 命名空间，并为其提供一个 name 属性，该属性的访问权限为 protected，以便所有子类可以直接访问。该类有一个简单的构造函数，用于在创建每个新对象时初始化
    name，并有一个 __toString() 方法，用于返回 "(FOOD) name" 格式的字符串。
- en: Let’s now declare the Dessert subclass of Food. Create *src/Dessert.php* and
    enter the contents of [Listing 23-2](#lis23-2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们声明 Dessert 作为 Food 的子类。创建 *src/Dessert.php* 并输入 [列表 23-2](#lis23-2) 的内容。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 23-2: The Dessert class, which throws an exception if the calories
    value is invalid'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23-2：Dessert 类，如果 calories 值无效，则抛出异常
- en: The Dessert class has a calories property assigned in the constructor via the
    setCalories() method ❶. This way, we reserve any validation logic for the setter
    method itself, so every new calories value will be vetted, regardless of whether
    it’s provided at the time of object construction or via the setter at a later
    point.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Dessert 类有一个 calories 属性，在构造函数中通过 setCalories() 方法进行赋值❶。这样，我们将所有的验证逻辑保留在 setter
    方法中，因此每一个新的 calories 值都会经过验证，无论是在对象构造时提供，还是通过 setter 在之后的某个时间点提供。
- en: Within setCalories(), we perform the validation with an if statement ❷. If the
    provided integer argument $calories is less than 0, we throw a new Exception object,
    with the message 'attempting to set calories to a negative value'. If the $calories
    argument is 0 or more and no exception is thrown, the code continues by storing
    the provided value in the Dessert object’s calories property ❸.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 setCalories() 中，我们使用 if 语句进行验证❷。如果提供的整数参数 $calories 小于 0，则抛出一个新的 Exception
    对象，错误信息为 '试图将 calories 设置为负值'。如果 $calories 参数大于或等于 0，并且没有抛出异常，则代码会继续执行，并将提供的值存储在
    Dessert 对象的 calories 属性中❸。
- en: Notice the syntax for throwing the exception. We begin with the throw keyword,
    which tells PHP to disrupt the flow of the program if the if statement is true.
    Then we use the new keyword to create a new object of the Exception class, passing
    the error message we want to display as an argument. We have to prefix the Exception
    class with a backslash (\) because it’s part of PHP’s root namespace, whereas
    Dessert is part of the Mattsmithdev namespace. Without the backslash, Exception
    would be assumed to be in the Mattsmithdev namespace as well.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意抛出异常的语法。我们以 throw 关键字开始，这告诉 PHP 如果 if 语句为真，就中断程序流程。接着我们使用 new 关键字来创建一个新的 Exception
    类对象，并传递我们想要显示的错误信息作为参数。由于 Exception 类属于 PHP 的根命名空间，我们必须在前面加上反斜杠（\），而 Dessert 类属于
    Mattsmithdev 命名空间。如果没有反斜杠，Exception 会被认为也属于 Mattsmithdev 命名空间。
- en: We next need to write a *composer.json* file to autoload our classes. Create
    this file as shown in [Listing 23-3](#lis23-3).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写一个 *composer.json* 文件来自动加载我们的类。按照 [列表 23-3](#lis23-3) 中的示例创建该文件。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 23-3: The composer.json file for autoloading'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23-3：用于自动加载的 composer.json 文件
- en: Once you have this file, generate the autoloader scripts by entering composer
    dump-autoload at the command line.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了这个文件，通过在命令行输入 composer dump-autoload 来生成自动加载脚本。
- en: Now let’s write an index script to attempt to create a Food and a Dessert object.
    Create *public/index.php* to match [Listing 23-4](#lis23-4).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个索引脚本，尝试创建一个 Food 和一个 Dessert 对象。创建*public/index.php*，使其与[列表 23-4](#lis23-4)匹配。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 23-4: Attempting to create an invalid Dessert object in index.php'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23-4：在 index.php 中尝试创建无效的 Dessert 对象
- en: 'We read and execute the autoloader and provide use statements for the two classes
    we need. Then we create and print a Food object and a Dessert object, passing
    an invalid argument of -1 for the latter’s calories property. Here’s the result
    of running this index script at the command line:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取并执行了自动加载器，并为所需的两个类提供了使用语句。然后我们创建并打印了一个 Food 对象和一个 Dessert 对象，并为后者的卡路里属性传递了无效参数
    -1。以下是运行此索引脚本时在命令行中得到的结果：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first line of output shows that the Food object was successfully created
    and printed out, but then we get a fatal error due to the exception thrown by
    the negative calorie value. The exception is said to be *uncaught*, since we didn’t
    write any code telling PHP what to do if an exception is thrown. As a result,
    the application has simply stopped running and has printed the error message we
    provided, followed by a *stack trace*, a report that steps through the code to
    show the cause of the exception.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行显示，Food 对象已成功创建并打印出来，但由于负卡路里值抛出的异常，我们遇到了致命错误。这个异常被称为*未捕获*，因为我们没有编写任何代码告诉
    PHP 如果抛出异常该怎么办。结果，应用程序停止运行并打印出了我们提供的错误消息，随后是*堆栈跟踪*，它报告了代码的执行步骤，显示异常的原因。
- en: 'The stack trace tells us the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪告诉我们以下内容：
- en: '#0 shows that the exception was thrown when setCalories() was passed -1 as
    an argument at line 12 of the *src/Dessert.php* file.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '#0 显示，当 setCalories() 在*src/Dessert.php* 文件的第12行传递 -1 作为参数时，抛出了异常。'
- en: '#1 shows that setCalories() was called when the Dessert class’s constructor
    method was invoked with the arguments (''strawberry chee...'', -1) (the food-name
    string has been shortened).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '#1 显示，当调用 Dessert 类的构造方法并传递参数 (''strawberry chee...'', -1) 时，setCalories()
    被调用了（食物名称字符串已被简化）。'
- en: '#2 reports that the exception-throwing code is line 23 in *src/Dessert.php*.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '#2 报告指出抛出异常的代码位于*src/Dessert.php*文件的第23行。'
- en: Notice that the output ends with the stack trace, meaning the index script wasn’t
    able to get to the point of printing out the Dessert object. The uncaught exception
    halted the flow of the program, so the final line of the index script didn’t execute.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出以堆栈跟踪结束，这意味着索引脚本无法打印出 Dessert 对象。未捕获的异常中止了程序的执行，因此索引脚本的最后一行没有执行。
- en: Catching an Exception
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 捕获异常
- en: To avoid a fatal error and safely manage exceptions, we need to *catch* the
    exceptions by writing a try...catch statement in our index script. The try portion
    indicates what we want to do under normal circumstances, and the catch portion
    indicates what to do when an exception is thrown.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免致命错误并安全地管理异常，我们需要通过在索引脚本中编写 try...catch 语句来*捕获*异常。try 部分指示在正常情况下我们想要做的事情，而
    catch 部分指示在抛出异常时该做什么。
- en: By catching exceptions, we prevent application users from seeing fatal errors
    and the resulting stack traces. Besides being embarrassing and not user-friendly,
    printing out a stack trace “leaks” information about the structure of the web
    application code (in the preceding example, for instance, we leaked the folder
    name *src* and the class filename *Dessert.php*). While stack traces aren’t serious
    security vulnerability issues, any information leaked like this might be helpful
    to an attacker and so should be prevented where possible. Catching exceptions
    lets us decide what to do with the exception data, as well as what the user will
    see when a problem arises.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过捕获异常，我们可以防止应用程序用户看到致命错误和随之而来的堆栈跟踪。除了尴尬且不友好，打印堆栈跟踪会“泄漏”关于 Web 应用程序代码结构的信息（例如，在前面的例子中，我们泄漏了文件夹名*src*和类文件名*Dessert.php*）。虽然堆栈跟踪并不是严重的安全漏洞问题，但任何这样的信息泄漏都可能对攻击者有帮助，因此应该尽可能避免。捕获异常使我们可以决定如何处理异常数据，以及当出现问题时用户将看到什么。
- en: NOTE
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In [Chapter 24](chapter24.xhtml), we’ll explore logging, which allows useful
    debugging data such as stack traces to be stored for developers and site administrators
    to access, while not publishing such information to any public website visitor
    or software client.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*在[第24章](chapter24.xhtml)中，我们将探讨日志记录，它允许存储有用的调试数据，如堆栈跟踪，供开发人员和网站管理员访问，同时不向任何公共网站访问者或软件客户端发布这些信息。*'
- en: To catch the exception raised when a negative calorie value is given, update
    the *public/index.php* script to match [Listing 23-5](#lis23-5).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获当输入负的卡路里值时引发的异常，请更新*public/index.php*脚本以匹配[示例23-5](#lis23-5)。
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 23-5: Adding a try...catch statement to index.php'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 示例23-5：向index.php添加`try...catch`语句
- en: The old code creating and printing Food and Dessert objects is now inside a
    try block ❶. If any exception occurs during this sequence, PHP checks the class
    of the exception against the class(es) specified in the catch block that follows
    ❷. If the class matches, the catch block is executed. In this case, the catch
    statement is for objects of the \Exception class, as specified in the parentheses
    after the catch keyword. The variable $e, also in the parentheses, becomes a reference
    to the Exception object that has been caught.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以前创建并打印Food和Dessert对象的代码现在放在一个`try`块中❶。如果在此过程中发生任何异常，PHP会检查异常的类是否与接下来的`catch`块中指定的类匹配❷。如果类匹配，就会执行`catch`块。在本例中，`catch`语句是针对`\Exception`类的对象，如`catch`关键字后面的小括号所指定的。小括号中的变量`$e`将成为捕获到的Exception对象的引用。
- en: In the catch block, we print out the message '(caught!) - an exception occurred!'
    followed by a line break. Then we print the message inside the Exception object
    via its public getMessage() method ❸. This is the 'attempting to set calories
    to a negative value' message we defined earlier.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`catch`块中，我们打印出消息'(caught!) - 发生了异常!'，并跟随一个换行符。然后，我们通过Exception对象的`public getMessage()`方法打印Exception对象中的消息❸。这就是我们之前定义的“尝试将卡路里设置为负值”的消息。
- en: 'Now that we’ve added code catching the exception, try running the index script
    again at the command line. You should see the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了捕获异常的代码，请尝试再次在命令行运行index脚本。你应该会看到如下输出：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, the Food object has been successfully created and printed. Next, we see
    the message printed from inside our catch statement, followed by the message from
    the Exception object itself. In this example, having caught the exception, we’re
    still printing out a message for the user, but we’ve controlled the information
    that’s displayed. No stack trace is leaking information now that we’re handling
    the exception with a catch statement.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Food对象已成功创建并打印。接下来，我们看到从`catch`语句内部打印的消息，后跟来自Exception对象本身的消息。在这个示例中，捕获异常后，我们仍然为用户打印出一条消息，但我们已经控制了显示的信息。由于我们正在使用`catch`语句处理异常，现在没有泄漏任何堆栈跟踪信息。
- en: Ending with a finally Statement
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 以`finally`语句结束
- en: A finally statement is a block of code that gets executed regardless of whether
    an exception has been thrown. It’s written after the try and catch statements
    and typically includes *housekeeping code*, code that gracefully ends any processes
    that have been started. For example, you might use a finally statement to ensure
    that any file streams or database connections are closed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`语句是一个代码块，不管是否抛出异常，都会被执行。它写在`try`和`catch`语句之后，通常包含*清理代码*，用于优雅地结束任何已启动的进程。例如，你可以使用`finally`语句来确保任何文件流或数据库连接都会被关闭。'
- en: Let’s add a finally statement to our index script to gracefully close the application
    every time it runs, even if an exception has been thrown. Modify *public/index.php*
    to match [Listing 23-6](#lis23-6).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在index脚本中添加一个`finally`语句，以便每次运行时都优雅地关闭应用程序，即使抛出了异常。修改*public/index.php*以匹配[示例23-6](#lis23-6)。
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 23-6: Adding a finally statement to index.php'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例23-6：向index.php添加`finally`语句
- en: 'We declare a finally block that prints a simple message after either the try
    or catch block concludes. Here’s the result of running this updated index script:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个`finally`块，在`try`或`catch`块结束后打印一条简单的消息。下面是运行更新后的index脚本的结果：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The message from the finally block prints at the end of the output, after displaying
    the message from the exception.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块中的消息会在输出的最后打印出来，显示异常消息之后。'
- en: To make sure the finally statement executes even when the catch statement doesn’t,
    let’s update our script so that the Dessert object is given a valid number of
    calories, meaning no exception will be thrown. Modify the instantiation of the
    Dessert object in *public/index.php* as shown in [Listing 23-7](#lis23-7).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保即使 catch 语句没有执行，finally 语句仍然会执行，我们将更新脚本，确保 Dessert 对象的卡路里数量是有效的，也就是说不会抛出异常。按照
    [列表 23-7](#lis23-7) 中的方式修改 *public/index.php* 中的 Dessert 对象实例化代码。
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 23-7: Creating a valid Dessert object in index.php'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23-7：在 index.php 中创建有效的 Dessert 对象
- en: 'When you run the index script now, you should see the Food and Dessert object
    messages and then the finally message:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行 index 脚本时，你应该能看到 Food 和 Dessert 对象的消息，以及最终的消息：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output confirms that a Dessert object was successfully created without
    throwing an exception, and that the finally block was still executed regardless.  ###
    Using Multiple Exception Classes'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出确认 Dessert 对象已成功创建且没有抛出异常，同时 regardless 的 finally 语句块仍然会执行。### 使用多个异常类
- en: In addition to PHP’s root Exception class, several other classes of exception
    are available as part of the Standard PHP Library (SPL), such as the InvalidArgumentException
    class. These other exception classes are all connected hierarchically to Exception
    as its subclasses, subclasses of its subclasses, and so on. You can also create
    your own custom exception classes that are subclasses of one of these built-in
    exception classes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 PHP 的根 Exception 类外，标准 PHP 库（SPL）还提供了其他几种异常类，例如 InvalidArgumentException
    类。这些异常类都与 Exception 类通过继承层次结构连接在一起，作为其子类、子类的子类，依此类推。你也可以创建自定义异常类，这些类是某个内置异常类的子类。
- en: At first glance, it may seem unnecessary to have subclasses of Exception, since
    we could create basic Exception objects with custom messages for each situation
    throwing an exception. However, by writing code that throws objects of different
    Exception subclasses, you can include several catch statements, one for each Exception
    subclass, allowing you to respond differently to each type of exception.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，可能觉得没有必要使用 Exception 的子类，因为我们可以为每种情况创建具有自定义消息的基本 Exception 对象来抛出异常。然而，通过编写抛出不同
    Exception 子类对象的代码，你可以包含多个 catch 语句，每个语句处理一个 Exception 子类，从而能够针对每种类型的异常做出不同的响应。
- en: For example, you could write multiple validation checks into a setter method
    and throw a certain class of exception depending on which validation check fails.
    Then you could write a separate catch statement for each of the exception classes,
    so each type of exception generates a customized response. You would then typically
    end with a catch statement for generic Exception objects, allowing you to catch
    any exceptions you didn’t already account for. We’ll look at how this works in
    the following sections.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将多个验证检查写入一个 setter 方法，并根据哪个验证检查失败抛出特定的异常类。然后，你可以为每个异常类编写一个单独的 catch 语句，这样每种类型的异常都会生成定制的响应。通常，你最后会以一个
    catch 语句来捕获通用的 Exception 对象，这样你就能捕获任何你没有提前考虑到的异常。我们将在接下来的章节中查看这种方法是如何工作的。
- en: Other Built-in Exception Classes
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他内置异常类
- en: 'Let’s use another built-in PHP exception class in conjunction with the root
    Exception class. We’ll update our Dessert class’s setCalories() method to throw
    one of two exception class objects as part of the validation of the received $calories
    argument. Our validation tests are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用另一个内置的 PHP 异常类，并结合根 Exception 类来使用。我们将更新 Dessert 类的 setCalories() 方法，使其抛出两种异常类对象之一，以验证接收到的
    $calories 参数。我们的验证测试如下：
- en: If $calories is less than 0, throw an \InvalidArgumentException object because
    desserts can’t have negative calories.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 $calories 小于 0，抛出一个 \InvalidArgumentException 对象，因为甜点不能有负卡路里。
- en: If $calories is greater than 5000, throw a general \Exception object because
    that’s *way too many* calories for one dessert.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 $calories 大于 5000，抛出一个通用的 \Exception 对象，因为那是 *太多了*，一个甜点不可能有这么多卡路里。
- en: Update the setCalories() method in *src/Dessert.php* to match [Listing 23-8](#lis23-8).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 *src/Dessert.php* 中的 setCalories() 方法，使其符合 [列表 23-8](#lis23-8)。
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 23-8: Updating the setCalories() method to throw different classes
    of exception'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23-8：更新 setCalories() 方法以抛出不同的异常类
- en: 'First, we change the class of exception thrown when the argument received is
    negative to \InvalidArgumentException. Once again, note the forward slash before
    the class name, indicating that this class is declared in the root PHP namespace.
    Then we add a second validation test: when the number of calories is greater than
    5000, an object of the general \Exception class will be thrown. If execution of
    the code gets past these two if statements without throwing any exceptions, we
    store the provided value in the object’s calories property as before.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将当接收到负数作为参数时抛出的异常类更改为\InvalidArgumentException。再次注意，在类名之前有一个斜杠，表示这个类声明在根PHP命名空间下。然后我们添加第二个验证测试：当卡路里数大于5000时，将抛出一个通用的\Exception类对象。如果代码执行通过了这两个if语句而没有抛出任何异常，我们将像之前一样把提供的值存储在对象的calories属性中。
- en: Next, we need to update the index script. We’ll write multiple catch statements
    to handle each class of exception object appropriately. Then we’ll try different
    values for the Dessert object’s calories property to test the validation logic.
    Edit *public/index.php* to match [Listing 23-9](#lis23-9).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新索引脚本。我们将编写多个catch语句，分别适当地处理每个异常对象类。然后，我们将为Dessert对象的calories属性尝试不同的值，以测试验证逻辑。编辑*public/index.php*，以匹配[示例23-9](#lis23-9)。
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 23-9: Multiple catch statements in the public/index.php script'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 示例23-9：public/index.php脚本中的多个catch语句
- en: We start with three assignment statements for different values of the $calories
    variable. To thoroughly test the script, comment out all but one of these assignment
    statements, choosing a different one each time. In the try block, we create a
    new Dessert object, providing the $calories variable as an argument. Then we create
    two catch statements, one for the InvalidArgumentException class ❶ and the other
    for the general Exception class ❷. Each prints a different message, along with
    the message attached to the exception object itself, retrieved with $e->getMessage().
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从为$calories变量赋不同值的三个赋值语句开始。为了彻底测试脚本，将除一个赋值语句外的所有语句注释掉，每次选择一个不同的赋值语句。在try块中，我们创建一个新的Dessert对象，并将$calories变量作为参数传入。然后，我们创建两个catch语句，一个用于InvalidArgumentException类
    ❶，另一个用于通用Exception类 ❷。每个catch语句都会打印不同的消息，并附带从异常对象中获取的消息，使用$e->getMessage()。
- en: '[Table 23-1](#tab23-1) shows the outputs for the three values of $calories,
    demonstrating that our exception-based logic is working as expected.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[表23-1](#tab23-1)展示了$calories的三个值的输出，证明我们的基于异常的逻辑如预期般工作。'
- en: 'Table 23-1: Outputs for Calorie Values'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表23-1：卡路里值的输出
- en: '| Value of $calories | Program output |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| $calories的值 | 程序输出 |'
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| -1 | (caught!) - an Invalid Argument Exception occurred! attempting to set
    calories to a negative value (finally) -- Application finished -- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| -1 | （已捕获！）- 发生了一个无效参数异常！尝试将卡路里设置为负值（最终）-- 应用程序完成 -- |'
- en: '| 6000 | (caught!) - a general Exception occurred! too many calories for one
    dessert! (finally) -- Application finished -- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 6000 | （已捕获！）- 发生了一个通用异常！一个甜点的卡路里太多了！(最终) -- 应用程序完成 -- |'
- en: '| 500 | I am a Dessert containing 500 calories! (finally) -- Application finished
    -- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 500 | 我是一个含有500卡路里的甜点！（最终）-- 应用程序完成 -- |'
- en: Notice that the values of -1 and 6000 each trigger their own class of exception,
    while 500 allows the Dessert object to be successfully created and printed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，-1和6000的值分别触发了它们各自的异常类，而500允许成功创建并打印Dessert对象。
- en: Custom Exception Classes
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义异常类
- en: PHP gives you the flexibility to write your own custom exception classes, provided
    they’re subclasses of Exception or one of the other built-in PHP exception classes.
    Also, many third-party libraries come with their own custom exception classes
    designed specifically for the methods in that library. Whether you’re writing
    your own or using someone else’s, custom exception classes give you even more
    freedom to structure your code to respond differently to a variety of anticipated
    problems.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: PHP为你提供了编写自定义异常类的灵活性，只要它们是Exception或其他内置PHP异常类的子类。此外，许多第三方库带有自己专门为该库中的方法设计的自定义异常类。无论你是在编写自己的异常类还是使用他人的，自定义异常类都能让你有更多的自由来组织代码，以便针对各种预期问题做出不同的响应。
- en: 'Let’s add a custom exception class to our Dessert project: Mattsmithdev\NegativeCaloriesException.
    We’ll update the project to throw an exception object of this class instead of
    the InvalidArgumentException class. [Figure 23-2](#fig23-2) shows the two classes
    of exception that our Dessert objects can throw. Notice that the NegativeCaloriesException
    class falls within the Mattsmithdev namespace, while the Exception class is outside,
    since it’s in the root PHP namespace.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 Dessert 项目添加一个自定义异常类：Mattsmithdev\NegativeCaloriesException。我们将更新项目，以抛出该类的异常对象，而不是
    InvalidArgumentException 类。 [图 23-2](#fig23-2) 显示了我们的 Dessert 对象可以抛出的两类异常。请注意，NegativeCaloriesException
    类位于 Mattsmithdev 命名空间内，而 Exception 类在外部，因为它位于根 PHP 命名空间中。
- en: '![](../images/figure23-2.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure23-2.jpg)'
- en: 'Figure 23-2: The two classes of exception that a Dessert object can throw'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23-2：Dessert 对象可以抛出的两类异常
- en: First, create a new class in *src/NegativeCaloriesException.php* containing
    the code in [Listing 23-10](#lis23-10).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 *src/NegativeCaloriesException.php* 中创建一个新类，包含 [列表 23-10](#lis23-10) 中的代码。
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 23-10: The custom NegativeCaloriesException class'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23-10：自定义的 NegativeCaloriesException 类
- en: We declare NegativeCaloriesException as a subclass of the root \Exception class.
    It contains no methods. Since it doesn’t have its own constructor method, it will
    inherit the constructor from its Exception superclass, allowing it to take in
    a message for display.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 NegativeCaloriesException 声明为根 \Exception 类的子类。它不包含任何方法。由于它没有自己的构造方法，因此将继承其
    Exception 超类的构造方法，从而允许它接收用于显示的消息。
- en: Let’s now update our Dessert class’s setCalories() method to throw a NegativeCaloriesException
    object when the provided calorie value is negative. As in the previous example,
    we’ll throw a general Exception object when the provided value is greater than
    5000. Update the setCalories() method in *src/Dessert.php* to match [Listing 23-11](#lis23-11).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新 Dessert 类的 setCalories() 方法，当提供的卡路里值为负时抛出 NegativeCaloriesException
    对象。与之前的示例一样，当提供的值大于 5000 时，我们将抛出一个通用的 Exception 对象。更新 *src/Dessert.php* 中的 setCalories()
    方法以匹配 [列表 23-11](#lis23-11)。
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 23-11: Throwing a custom exception in the setCalories() method'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23-11：在 setCalories() 方法中抛出自定义异常
- en: We change the class of exception thrown when the argument received is negative
    to an object of the NegativeCaloriesException class. Since this new class is in
    the same namespace as our Dessert class, we don’t write a backslash before the
    class identifier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到的参数为负数时，我们将抛出的异常类更改为 NegativeCaloriesException 类的对象。由于这个新类与我们的 Dessert 类在同一个命名空间中，因此我们不在类标识符前加反斜杠。
- en: Next, we need to update the catch statements in our index script to handle the
    new custom exception class. Modify *public/index.php* as shown in [Listing 23-12](#lis23-12).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新 index 脚本中的 catch 语句，以处理新的自定义异常类。按照 [列表 23-12](#lis23-12) 中所示修改 *public/index.php*。
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 23-12: Catching custom exception objects in the index.php script'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23-12：在 index.php 脚本中捕获自定义异常对象
- en: 'We add a use statement so we can reference the NegativeCaloriesException class
    without the Mattsmithdev namespace prefix. Then we create a catch statement for
    exceptions of this class, printing an appropriate message. Here’s the output you
    should get if you try to create a new Dessert object with -1 calories, confirming
    that a NegativeCaloriesException is thrown:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个 use 语句，以便可以在不带 Mattsmithdev 命名空间前缀的情况下引用 NegativeCaloriesException 类。然后我们为该类的异常创建一个
    catch 语句，打印适当的消息。如果你尝试创建一个卡路里为 -1 的新 Dessert 对象，确认抛出 NegativeCaloriesException，以下是你应该得到的输出：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Testing for a negative value is a simple example, but it serves to illustrate
    how straightforward it is to create custom subclasses of Exception, allowing you
    to write different logic to address different anticipated problems at runtime.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 测试负值是一个简单的示例，但它说明了创建 Exception 的自定义子类是多么简单，这使你能够编写不同的逻辑来处理运行时预期的不同问题。
- en: Call-Stack Bubbling
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用栈冒泡
- en: If an exception occurs in a block of code and isn’t caught by that code block,
    it will *bubble up* the call stack to the code that invoked the code block. If
    not caught there, the exception will continue to bubble up through successively
    higher levels of code until either it’s caught and handled or the top of the call
    stack is reached. If the exception isn’t caught in the top-level block of code,
    a fatal error will result, as we saw in this chapter’s first example. For this
    reason, it’s a good idea to include some code at the top level of an application
    to catch any exceptions that may have bubbled all the way to the top of the call
    stack.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个异常发生在某个代码块中并且没有被该代码块捕获，它将 *冒泡到* 调用栈中调用该代码块的代码。如果在那里没有捕获，它将继续向上冒泡，经过逐渐更高层次的代码，直到它被捕获并处理，或者到达调用栈的顶部。如果异常在顶层代码块中没有被捕获，则会导致致命错误，正如我们在本章的第一个示例中看到的那样。基于这个原因，建议在应用程序的顶层代码中加入一些代码，以捕获任何可能已经冒泡到调用栈顶部的异常。
- en: As you’ve seen, the flow of control for a typical object-oriented PHP web application
    begins with the index script, which creates an object of the Application class
    and invokes its run() method. This in turn triggers the creation of other objects
    and the invocation of other methods. Some of this activity might throw exceptions.
    You can try to catch all those exceptions within the Application class, but any
    uncaught exceptions will ultimately bubble up to the index script and should be
    caught there to avoid a fatal error.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，典型的面向对象 PHP Web 应用程序的控制流程是从索引脚本开始的，该脚本创建一个 Application 类的对象并调用其 run()
    方法。这又触发了其他对象的创建和其他方法的调用。这些活动中可能会抛出异常。你可以尝试在 Application 类中捕获所有这些异常，但任何未捕获的异常最终都会冒泡到索引脚本，并应在那里捕获，以避免致命错误。
- en: To demonstrate how this works, we’ll update our Dessert project, taking the
    code that used to be in the index script and encapsulating it in an Application
    class. This class will be responsible for catching any NegativeCaloriesException
    objects thrown during the creation of Dessert objects, but we’ll allow other miscellaneous
    exceptions to bubble up to the top of the call stack. Then we’ll catch those in
    the top-level index script.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一过程，我们将更新我们的 Dessert 项目，将原本位于索引脚本中的代码封装进 Application 类中。这个类将负责捕获在创建 Dessert
    对象时抛出的任何 NegativeCaloriesException 对象，但我们将允许其他杂项异常冒泡到调用栈的顶部。然后，我们将在顶层索引脚本中捕获这些异常。
- en: First, let’s update our index script to create an Application object and invoke
    its run() method. We’ll wrap that code in a try...catch statement to handle any
    uncaught exceptions that bubble up, and we’ll include a finally statement to gracefully
    close the application. We’ll also clearly indicate that the messages being printed
    by the catch and finally blocks are coming from this index script by prefixing
    them with (index.php). Modify *public/index.php* to match [Listing 23-13](#lis23-13).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新我们的索引脚本，以创建一个 Application 对象并调用它的 run() 方法。我们将把这段代码包装在 try...catch 语句中，以处理任何未被捕获的异常，并在其中添加一个
    finally 语句来优雅地关闭应用程序。我们还将通过在 catch 和 finally 块打印的消息前添加 (index.php) 前缀，明确表示这些消息是来自这个索引脚本。修改
    *public/index.php* 以匹配 [列表 23-13](#lis23-13)。
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 23-13: The simplified index.php script creating an Application object'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23-13：创建 Application 对象的简化 index.php 脚本
- en: Inside the try block, we create an Application object, storing a reference to
    the new object in the $app variable, and invoke its run() method. If any uncaught
    Exception objects bubble up from the try block statements, we use a catch block
    to handle them and print a message. Since every exception object is an instance
    of the Exception class (either directly or as a subclass), this catch statement
    acts as a catchall for any possible exception object that was thrown during program
    execution but wasn’t caught elsewhere in the code. We also add a finally block
    that will print a final message regardless of whether any exceptions were thrown.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 try 块中，我们创建一个 Application 对象，将该对象的引用存储在 $app 变量中，并调用其 run() 方法。如果有任何未捕获的 Exception
    对象从 try 块语句中冒泡出来，我们将使用 catch 块来处理它们并打印一条消息。由于每个异常对象都是 Exception 类的一个实例（无论是直接的还是作为子类），因此这个
    catch 语句作为一个捕获所有异常的通用处理器，用于处理在程序执行过程中抛出的但未在代码中其他地方捕获的异常。我们还添加了一个 finally 块，它会打印最终消息，无论是否抛出异常。
- en: Now let’s write the Application class. Create a new file named *src/Application.php*
    to match [Listing 23-14](#lis23-14).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写 Application 类。创建一个名为 *src/Application.php* 的新文件，以匹配 [列表 23-14](#lis23-14)。
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 23-14: The Application class'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 23-14：Application 类
- en: We declare the Application class with a run() method containing many of the
    statements from the older index script. As before, we include three assignment
    statements for the $calories variable that you can selectively comment out to
    test the project. Then we create and print a new Dessert object in a try block
    and use a catch block to handle NegativeCaloriesException objects. [Table 23-2](#tab23-2)
    shows the results of running the application with the different possible values
    of $calories.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个包含 `run()` 方法的 Application 类，该方法包含了来自旧版 index 脚本的许多语句。和之前一样，我们为 `$calories`
    变量包含了三个赋值语句，你可以选择性地注释掉这些语句来测试项目。然后，我们在一个 try 块中创建并打印一个新的 Dessert 对象，并使用 catch
    块来处理 NegativeCaloriesException 对象。[表 23-2](#tab23-2) 显示了在使用不同 `$calories` 值时运行应用程序的结果。
- en: 'Table 23-2: Catching Exceptions with Call-Stack Bubbling'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 表 23-2：使用调用栈冒泡捕获异常
- en: '| Value of $calories | Program output |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| $calories 的值 | 程序输出 |'
- en: '| --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 500 | I am a Dessert containing 500 calories! (index.php) finally -- Application
    finished -- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 500 | 我是一个包含 500 卡路里的甜点！ (index.php) 最终 -- 应用程序结束 -- |'
- en: '| -1 | (Application->run) - Negative Calories Value Exception caught! (index.php)
    finally -- Application finished -- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| -1 | (Application->run) - 捕获到负卡路里值异常！ (index.php) 最终 -- 应用程序结束 -- |'
- en: '| 6000 | (index.php) Exception caught! (index.php) finally -- Application finished
    -- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 6000 | (index.php) 捕获到异常！ (index.php) 最终 -- 应用程序结束 -- |'
- en: When a valid value of 500 is used, the object properties are printed out. When
    the value is -1, the NegativeCaloriesException is caught inside the run() method
    of the Application class. When the too-high value of 6000 is used, the run() method
    of the Application class fails to catch the general Exception that’s thrown, since
    the method is watching only for NegativeCaloriesException objects. As a result,
    the exception bubbles up to the index script, where it hits the general catch
    block. In all cases, the output ends with the message from the finally block in
    the index script.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用有效值 500 时，对象的属性会被打印出来。当值为 -1 时，NegativeCaloriesException 会在 Application 类的
    `run()` 方法内被捕获。当使用过高的值 6000 时，Application 类的 `run()` 方法未能捕获抛出的通用异常，因为该方法只会捕获 NegativeCaloriesException
    对象。因此，异常会冒泡到 index 脚本，在那里会命中通用的 catch 块。在所有情况下，输出都会以 index 脚本中 finally 块的消息结束。
- en: Adding a general try...catch statement to an index script ensures that any bubbled-up
    uncaught exceptions will be addressed, meaning the application will avoid runtime
    errors relating to exceptions. Meanwhile, the code for handling more-specific
    exceptions, such as our custom NegativeCaloriesException, is located at a lower
    level of the application code, which keeps the index script simple and well organized.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 向 index 脚本添加通用的 try...catch 语句可以确保任何冒泡上来的未捕获异常都会被处理，这意味着应用程序将避免与异常相关的运行时错误。同时，处理更具体异常的代码，如我们自定义的
    NegativeCaloriesException，位于应用程序代码的更低级别，这样可以保持 index 脚本简洁且结构良好。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced how to work with exceptions. You learned how to create
    exceptions when anticipated problematic situations occur by writing throw statements,
    and how to manage exceptions with try...catch...finally structures. All exceptions
    are instances of PHP’s top-level \Exception class, but we discussed how to refine
    the program logic by using provided exception subclasses such as InvalidArgumentException
    or by declaring custom exception subclasses.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何处理异常。你学习了如何在预期的有问题情况发生时通过编写 throw 语句来创建异常，并通过 try...catch...finally 结构来管理异常。所有异常都是
    PHP 顶级 \Exception 类的实例，但我们讨论了如何通过使用提供的异常子类（如 InvalidArgumentException）或声明自定义异常子类来优化程序逻辑。
- en: We also explored a general application architecture that exploits the bubbling
    up of uncaught exceptions. Specific anticipated exceptions can be caught within
    class methods, while any remaining exceptions can be caught in the index script
    at the top level of the application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了一种通用的应用架构，该架构利用未捕获异常的冒泡。当预期的特定异常发生时，可以在类方法中捕获，而任何剩余的异常则可以在应用程序顶层的 index
    脚本中捕获。
- en: Exercises
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '1.   Create a new project and implement a simple Product class with private
    name and price properties, public accessor methods for each property, and a constructor
    that takes in new values for each property and sets them using the setter methods.
    Add validation as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   创建一个新项目，并实现一个简单的 Product 类，该类具有私有的 name 和 price 属性，针对每个属性的公共访问方法，以及一个构造函数，该构造函数接收每个属性的新值并使用
    setter 方法设置它们。添加以下验证：
- en: a.   If a negative value for price is received, an InvalidArgumentException
    is thrown.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: a.   如果收到负值的价格，将抛出InvalidArgumentException。
- en: b.   If a price greater than 1000000 is received, a general Exception is thrown.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: b.   如果收到的价格大于1000000，将抛出一个通用Exception。
- en: c.   If an empty string is provided for the name property, an InvalidArgumentException
    is thrown.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: c.   如果为name属性提供一个空字符串，将抛出InvalidArgumentException。
- en: Create a *composer.json* file and an index script to attempt to create a Product
    object with valid and invalid names and prices. Then wrap your index code with
    try...catch statements, so you can handle the various exceptions your code throws.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个*composer.json*文件和一个索引脚本，尝试使用有效和无效的名称和价格创建一个Product对象。然后用try...catch语句包裹你的索引代码，这样你就可以处理代码抛出的各种异常。
- en: '2.   Make a copy of your Exercise 1 solution and introduce an Application class
    similar to the one from [Listing 23-14](#lis23-14). Refactor your code as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   复制你的第1题解答，并引入一个类似于[清单23-14](#lis23-14)中的Application类。按以下方式重构你的代码：
- en: a.   Create the Product object in the run() method of your Application class.
    Catch InvalidArgumentException objects and print an appropriate message as part
    of the run() method as well.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: a.   在你的Application类的run()方法中创建Product对象。捕获InvalidArgumentException对象，并在run()方法中打印相应的消息。
- en: b.   In the index script, create an Application object and invoke its run()
    method. Catch any bubbled-up general Exception objects and print an appropriate
    message.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: b.   在索引脚本中，创建一个Application对象并调用其run()方法。捕获任何向上传播的通用Exception对象并打印相应的消息。
- en: 3.   Make a copy of your solution for Exercise 2 and introduce a custom exception
    named EmptyStringException that’s thrown by the setName() method. Add an appropriate
    catch block to catch and process this exception in the run() method of the Application
    class.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   复制你的第2题解答，并引入一个名为EmptyStringException的自定义异常，该异常由setName()方法抛出。在Application类的run()方法中添加一个适当的catch块，以捕获并处理此异常。
