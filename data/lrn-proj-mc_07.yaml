- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**DANCE PARTIES AND FLOWER PARADES WITH WHILE LOOPS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用`while`循环的舞会派对和花车游行**'
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common01.jpg)'
- en: '*Loops* make it easy to repeat code again and again. Instead of copying and
    pasting the same code, you can use a loop to repeat the code as many times as
    you want. You’ll use loops in this chapter to make your programs repeat without
    having to rerun them. We’ll focus on one type of Python loop known as the `while`
    loop.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环*使得重复执行代码变得更加容易。你无需复制粘贴相同的代码，而是可以使用循环按需重复代码。在本章中，你将使用循环来使程序重复执行，而无需重新运行它们。我们将重点讨论一种名为`while`循环的Python循环。'
- en: '**A SIMPLE WHILE LOOP**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**一个简单的`while`循环**'
- en: You use `while` loops to repeat blocks of code. Similar to `if` statements,
    a `while` loop will execute the code inside it as long as a condition is `True`.
    That is, a condition must be met in order for the body of the statement to run.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`while`循环来重复代码块。类似于`if`语句，`while`循环只要条件为`True`，就会执行其中的代码。也就是说，必须满足某个条件，语句的主体才会执行。
- en: The difference between a `while` loop and an `if` statement is that the code
    in the `if` statement executes only once at the most, whereas the code in the
    `while` loop can repeat many times. Programmers call the repeating of code *iteration*.
    When a loop repeats, you say it *iterates*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环和`if`语句之间的区别在于，`if`语句中的代码最多只会执行一次，而`while`循环中的代码可以重复执行多次。程序员称代码的重复执行为*迭代*。当一个循环重复时，我们说它*迭代*。'
- en: 'For example, this code uses a `while` loop to print the numbers 1 to 5:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这段代码使用`while`循环打印数字1到5：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `count` variable records the number of times that the loop has repeated.
    It starts with the value of 1\. The condition in the `while` loop checks whether
    the count is less than or equal to 5.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`变量记录循环已执行的次数。它从1开始。`while`循环中的条件检查`count`是否小于或等于5。'
- en: '**NOTE**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In [Chapter 3](ch03.html#ch03) you learned that* `+=` *is a shorthand operator.
    You could use the standard addition operator* `count = count + 1` *to do the same
    thing.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*在[第3章](ch03.html#ch03)中，你学到了`+=`是一个简写运算符。你也可以使用标准的加法运算符* `count = count +
    1` *来做同样的事情。*'
- en: The first time the loop runs, the value of `count` is `1`, which is less than
    5\. The condition of the loop is `True`, and the body of the loop runs. Next,
    the program prints the value of `count` to the Python shell, and then it adds
    1 to the value of `count`. The `while` loop now starts again and checks the condition
    again, going through each step until the `count` variable is greater than 5.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 循环第一次运行时，`count`的值为`1`，小于5。循环的条件为`True`，因此循环体执行。接下来，程序将`count`的值打印到Python shell中，然后将1加到`count`的值上。`while`循环现在重新开始，重新检查条件，逐步执行直到`count`变量大于5。
- en: Outside the loop is one final line, which prints `"Loop finished"`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 循环外有最后一行，它会打印`"循环结束"`。
- en: 'Save this program and run it; you should see the following output:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这个程序并运行，你应该看到以下输出：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Try experimenting a bit with the code. Change the conditions so you list more
    than 5 numbers or change the amount by which the `count` variable increases. Here’s
    a refresher on how the code works. The `while` statement follows these steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对代码做一些实验。修改条件，使其列出超过5个数字，或者更改`count`变量增加的数量。以下是代码如何工作的回顾。`while`语句遵循以下步骤：
- en: Check whether the condition is `True`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查条件是否为`True`。
- en: 'If the condition is `True`:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果条件为`True`：
- en: a. Execute the body of code.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 执行代码体。
- en: b. Repeat step 1.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 重复步骤1。
- en: 'If the condition is `False`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果条件为`False`：
- en: a. Ignore the body of code.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 忽略代码体。
- en: Continue to the line after the `while` loop block.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续到`while`循环块之后的行。
- en: Let’s try using a `while` loop in Minecraft to teleport to lots of new places!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在Minecraft中使用`while`循环传送到许多新地点！
- en: '**MISSION #33: A RANDOM TELEPORTATION TOUR**'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #33：随机传送之旅**'
- en: 'In [Mission #3](ch02.html#ch02lev2sec08) ([page 40](ch02.html#page_40)), you
    teleported the player to different positions in the game. Let’s rewrite that program
    using a `while` loop so you can repeat the teleportation again and again.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '在[任务 #3](ch02.html#ch02lev2sec08)（[第40页](ch02.html#page_40)）中，你将玩家传送到了游戏中的不同位置。让我们使用`while`循环重写那个程序，这样你就可以一遍又一遍地重复传送。'
- en: By looping some code that will teleport the player to a random location, you
    can make the program more powerful *and* a lot easier to read. Cool, huh?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过循环一些会将玩家传送到随机位置的代码，你可以使程序更强大且*更易于阅读*。酷吧？
- en: The following code will teleport the player to a random location once by picking
    random values in the game world for the variables `x`, `y`, and `z`. Then it will
    set the player’s position using those variables.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码通过为`x`、`y`和`z`变量在游戏世界中选取随机值，将玩家传送到一个随机位置。然后，它将使用这些变量设置玩家的位置。
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Right now, however, the code will only teleport the player once. Although that’s
    pretty cool, you can make it totally awesome. Let’s write a loop so the code repeats
    five times, making this quite a whirlwind tour.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在代码只会传送玩家一次。虽然这已经挺酷了，但你可以让它变得更棒。让我们写一个循环，让代码重复五次，这样就变成了一个快速的世界之旅。
- en: 'To change the code to use a loop, follow these four steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要将代码改成使用循环，按照以下四个步骤操作：
- en: Create a `count` variable to control the loop ➊.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`count`变量来控制循环 ➊。
- en: Add a `while` loop with a condition based on `count` ➋.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个基于`count`的条件的`while`循环 ➋。
- en: Indent the body of the `while` statement ➌.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缩进`while`语句的代码体 ➌。
- en: Increment the value of `count` with each loop ➍.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次循环时增大`count`的值 ➍。
- en: The purpose of the `count` variable and the `count` increment is to keep track
    of the number of times the loop has repeated. I’ll talk more about them in the
    next section. For now, all you need to know is that `count` lets us control how
    many times this code repeats.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`变量和`count`增量的目的是跟踪循环重复的次数。接下来我会详细讲解它们。现在你需要知道的是，`count`让我们控制代码重复的次数。'
- en: '[Listing 7-1](ch07.html#ch7ex1) shows the code with the changes added.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例7-1](ch07.html#ch7ex1)显示了添加更改后的代码。'
- en: '*randomTeleport.py*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*randomTeleport.py*'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 7-1: Code to randomly teleport the player around the game world*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例7-1：让玩家在游戏世界中随机传送的代码*'
- en: Copy [Listing 7-1](ch07.html#ch7ex1) into a new file, save it as *randomTeleport.py*
    in a new folder called *whileLoops*, and run the code. You should see the player
    zip around the Minecraft world. But the code runs far too quickly! The entire
    journey is over in less than a second. Let’s fix that together.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将[示例7-1](ch07.html#ch7ex1)复制到一个新文件中，保存为*randomTeleport.py*，并放入名为*whileLoops*的文件夹内，然后运行代码。你应该能看到玩家在Minecraft世界中快速移动。但代码运行得太快了！整个过程不到一秒钟就结束了。让我们一起来解决这个问题。
- en: 'You’ll use the `time` module to slow down the code. Follow these steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`time`模块来减慢代码的执行速度。按照以下步骤操作：
- en: On the first line of the program, add the statement `import time`. This imports
    Python’s `time` module, which contains a set of handy functions related to timing
    and more.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序的第一行添加语句`import time`。这将导入Python的`time`模块，里面包含一组与时间相关的有用函数等。
- en: Add the line `time.sleep(10)` at the end of the body of your `while` loop to
    add a delay of 10 seconds to your program. Make sure you indent this new final
    line of your program so it’s within the `while` loop!
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环的代码体末尾添加`time.sleep(10)`这一行，给程序增加10秒的延迟。确保你缩进这行新代码，使其处于`while`循环内部！
- en: Save the program and run it. Now the player should teleport to a new random
    location every 10 seconds. [Figure 7-1](ch07.html#ch7fig1) shows my program running.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 保存程序并运行。现在，玩家应该每10秒钟传送到一个新的随机位置。[图7-1](ch07.html#ch7fig1)显示了我运行程序的情况。
- en: '![image](graphics/f07-01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-01.jpg)'
- en: '*Figure 7-1: Every 10 seconds, the program teleports me to a new location.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：每10秒钟，程序将我传送到一个新位置。*'
- en: '**BONUS OBJECTIVE: SLEEP TIGHT**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加目标：好好休息**'
- en: At the moment, the program will wait for 10 seconds at the end of every loop.
    What happens if you move the `time.sleep(10)` statement to the start of the loop?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，程序会在每次循环结束时等待10秒钟。如果你把`time.sleep(10)`语句移到循环开始处会发生什么呢？
- en: '**CONTROLLING LOOPS WITH A COUNT VARIABLE**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用计数变量控制循环**'
- en: 'Count variables are a common way of storing the number of times a program has
    repeated. You’ve seen these variables in action a few times now. Let’s look at
    another example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 计数变量是存储程序重复次数的常见方式。你已经在之前的几个例子中看到过这些变量的使用。我们再来看一个例子：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `while` loop’s condition tests that the value of the `count` variable is
    less than 5\. In the body of the loop, I’ve changed the value of the `count` variable
    to record the number of times the count has repeated. Adding to the value of a
    `count` variable is called *incrementing*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环的条件测试`count`变量的值是否小于5。在循环体内，我改变了`count`变量的值，以记录循环重复的次数。增加`count`变量的值叫做*增量*。'
- en: The last line of this code increases the value of the `count` variable by 1\.
    Each time the code repeats, it will check the new value of the `count` variable
    to see whether it is less than 5\. When it is equal to or greater than 5, the
    loop will stop.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的最后一行将 `count` 变量的值增加 1。每次代码重复时，它会检查 `count` 变量的新值，看它是否小于 5。当它等于或大于 5 时，循环将停止。
- en: 'If you forget to increment the `count` variable, you’ll end up with an *infinite
    loop*, which will repeat the loop forever, as shown in the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记增加 `count` 变量的值，你会陷入一个*无限循环*，这个循环将永远重复下去，正如下面的例子所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The value of `count` is always 0 because it’s never incremented. So, the condition
    of the loop will always be `True`, and the loop will repeat *forever*. If you
    don’t believe me, try running the code!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`count` 的值始终为 0，因为它从未被增加。因此，循环的条件始终为 `True`，循环将会*永远*重复。如果你不相信我，可以试着运行这段代码！'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To break the execution of this infinite program, press CTRL-C. To correct the
    code, just add the line `count += 1` to the loop’s body. Now you won’t get trapped
    in an infinite loop. Phew!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要中断这个无限程序的执行，按下 CTRL-C。要修正代码，只需在循环体内添加一行 `count += 1`。现在你就不会被困在无限循环中了。呼！
- en: 'Counts don’t always have to be incremented by 1\. In some situations you may
    want to increment the count by a different value. In the following example, the
    count is incremented by 2 every time; the result is that the code prints all the
    even numbers between 0 and 100:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 计数并不总是必须每次增加 1。在某些情况下，你可能希望计数以不同的值增加。在下面的例子中，计数每次增加 2；结果是，代码打印出 0 到 100 之间的所有偶数：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also count backward using a negative number to *decrement* the value
    of the count. The following code counts *down* from 100 to 1:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用负数来倒数，*减少* 计数的值。以下代码会从 100 倒数到 1：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The only difference between this example and the previous examples is the condition.
    Here I’ve used a greater than comparator (`>`). As long as the count is greater
    than 0, the loop continues; when the count reaches 0, the loop stops.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与之前的例子唯一的区别是条件。在这里我使用了大于比较符号（`>`）。只要 count 大于 0，循环就会继续；当 count 等于 0 时，循环停止。
- en: '**NOTE**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The variable used to control a loop isn’t always called* `count`. *You could
    call it* `repeats` *or anything else you want. If you look at other people’s code,
    you will see a huge range of different names.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*用来控制循环的变量不一定总是叫做* `count`。*你可以将它命名为* `repeats` *或任何你想要的名称。如果你查看其他人的代码，你会看到各种各样的不同命名。*'
- en: '**MISSION #34: THE WATERY CURSE**'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #34: 水之诅咒**'
- en: Let’s try something a bit nasty and write a curse for the player that lasts
    for just a short time. Curses in video games might *debuff* the character in some
    way, such as slowing them down or making them weaker, often for just a little
    while.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些有点恶作剧的操作，给玩家写一个持续时间非常短的诅咒。在视频游戏中，诅咒可能会以某种方式*削弱*角色，比如让他们变慢或者变弱，通常持续时间较短。
- en: We’ll create a curse program that places a flowing water block at the player’s
    position once a second for 30 seconds. This will make it difficult for the player
    to move without being pushed around by flowing water.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个诅咒程序，每秒在玩家的位置放置一个流动水块，持续 30 秒。这将使玩家在不被水流推开的情况下很难移动。
- en: 'The following code places a flowing water block at the player’s position:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码会在玩家的位置放置一个流动水块：
- en: '*waterCurse.py*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*waterCurse.py*'
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code will place a water block at the player’s current position only once.
    It is your task to make it repeat. The final code should repeat 30 times, and
    each iteration of the loop should last 1 second.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只会在玩家当前位置放置一个水块。你的任务是让它重复。最终的代码应该重复 30 次，每次循环持续 1 秒。
- en: Save this code as *waterCurse.py* in the *whileLoops* folder and run it once
    to make sure it works. You should see a single water block appear at the player’s
    position before the program stops.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码保存为 *waterCurse.py* 文件，并放在 *whileLoops* 文件夹中，然后运行一次以确保它能正常工作。你应该会看到在程序停止之前，玩家的位置出现一个水块。
- en: 'Let’s talk through what to add next to make this curse last. Use what you learned
    about `while` loops and `count` variables to do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下接下来需要添加什么，以让这个诅咒持续下去。使用你学到的 `while` 循环和 `count` 变量来完成以下任务：
- en: Add a `count` variable to the program.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序中添加一个 `count` 变量。
- en: Add a loop to the program to repeat the last two lines of code. The loop should
    repeat 30 times.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序中添加一个循环，重复执行最后两行代码。循环应该重复 30 次。
- en: Increment the `count` variable at the end of the loop.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环结束时增加 `count` 变量。
- en: Import the `time` module (on the first line of your program) and then add a
    1 second sleep on the last line of the `while` loop.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`time`模块（在程序的第一行），然后在`while`循环的最后一行添加1秒的休眠。
- en: 'Save the program and test it. As you walk around the game world, the program
    should create one block of water every second for 30 seconds. If you get stuck,
    go back to the steps in [Mission #33](ch07.html#ch07lev2sec01) ([page 125](ch07.html#page_125))
    for help.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '保存程序并进行测试。当你在游戏世界中走动时，程序应该每秒创建一个水块，持续30秒。如果遇到困难，可以参考[任务 #33](ch07.html#ch07lev2sec01)（[第125页](ch07.html#page_125)）中的步骤获取帮助。'
- en: '[Figure 7-2](ch07.html#ch7fig2) shows the curse in action.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-2](ch07.html#ch7fig2)显示了这个诅咒的实际效果。'
- en: '![image](graphics/f07-02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-02.jpg)'
- en: '*Figure 7-2: Oh no! I’m being followed by a small flood.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：哦不！我被一小股洪水追着跑。*'
- en: '**BONUS OBJECTIVE: A FASTER FLOOD**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外目标：更快的洪水**'
- en: How would you make the loop repeat twice as fast (every half a second) while
    still lasting for 30 seconds?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如何让循环以原来的两倍速度（每半秒一次）重复，同时仍然持续30秒？
- en: '**INFINITE WHILE LOOPS**'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**无限循环**'
- en: In most cases, it is very important that the Boolean condition in your `while`
    loop eventually become `False`; otherwise, the loop will iterate forever, and
    your computer might crash.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`while`循环中的布尔条件最终必须变为`False`；否则，循环将永远执行下去，可能会导致计算机崩溃。
- en: But there are times when you may want to program an infinite loop. For example,
    video games often use an infinite loop to check for user input and manage player
    movement. Of course, these video games include a Quit button so you can pause
    or stop the infinite loops when you need to take a break!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时你可能想编写一个无限循环。例如，视频游戏通常使用无限循环来检查用户输入并管理玩家的移动。当然，这些视频游戏会包含一个退出按钮，这样你就可以在需要休息时暂停或停止无限循环！
- en: 'A simple way to create an infinite loop is to use a `True` condition when you
    define a `while` loop, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建无限循环的一个简单方法是，当你定义`while`循环时使用`True`条件，如下所示：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code will repeat forever, printing the string `"Hello"` over and over again.
    Whether or not you meant to create an infinite loop, pressing CTRL-C in the Python
    shell is a common way to stop it. In IDLE you can select **Shell** ▸ **Restart
    Shell** to stop the loop as well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将会永远重复，反复打印字符串`"Hello"`。无论你是否打算创建一个无限循环，按CTRL-C可以在Python shell中常见地停止它。在IDLE中，你也可以选择**Shell**
    ▸ **Restart Shell**来停止循环。
- en: 'Note that any code that is placed *after* an infinite `while` loop will never
    run. In the following example, the last line of code is unreachable due to the
    infinite `while` loop that comes before it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何位于无限`while`循环*之后*的代码都永远不会执行。在以下示例中，由于前面的无限`while`循环，最后一行代码无法执行：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Although infinite loops can sometimes be tricky, you can also create them to
    do lots of cool things. Let’s try this next!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管无限循环有时可能会有点棘手，但你也可以利用它来做很多有趣的事情。接下来我们就来尝试一下！
- en: '**MISSION #35: FLOWER TRAIL**'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #35：花朵轨迹**'
- en: 'The program you’ll write in this mission is like the one in [Mission #34](ch07.html#ch07lev2sec02),
    but instead of placing water blocks, you’ll create a trail of flowers behind the
    player. Flowers are much nicer than floods!'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '你在这个任务中编写的程序类似于[任务 #34](ch07.html#ch07lev2sec02)中的程序，但不是放置水块，而是让玩家身后留下花朵轨迹。花朵比洪水要漂亮多了！'
- en: Open the file *waterCurse.py* in the *whileLoops* folder and then save it as
    *flowerTrail.py*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*waterCurse.py*文件（位于*whileLoops*文件夹中），然后将其保存为*flowerTrail.py*。
- en: 'To make an infinite trail of flowers appear as the player walks around the
    game, make the following changes to the program:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让玩家在游戏中走动时，花朵能不断出现并形成一条无限轨迹，请对程序进行如下修改：
- en: Change the condition of the `while` loop to `True`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`while`循环的条件改为`True`。
- en: Delete the `count` variable and the increment.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`count`变量和增量。
- en: Change the block type argument in the `setBlock()` function from `8` to `38`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`setBlock()`函数中的块类型参数从`8`改为`38`。
- en: Reduce the value of the argument in the `sleep()` function to `0.2` to make
    five flowers appear every second.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`sleep()`函数中的参数值改为`0.2`，让每秒出现五朵花。
- en: Save the program and run it. [Figure 7-3](ch07.html#ch7fig3) shows what you
    should see.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存程序并运行。[图7-3](ch07.html#ch7fig3)显示了你应该看到的效果。
- en: '![image](graphics/f07-03.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-03.jpg)'
- en: '*Figure 7-3: Look at all the beautiful flowers!*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：看，所有美丽的花朵！*'
- en: '**BONUS OBJECTIVE: A TRAIL OF DESTRUCTION**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外目标：一条毁灭的轨迹**'
- en: The *flowerTrail.py* program is very flexible. Try changing the block type that
    is placed by the program. A fun block type to try is explosive TNT (`setBlock(x,
    y, z, 46, 1)`). Notice the extra argument `1` after `46`, which is the TNT block
    type. The `1` sets the state of the TNT to make it detonate just by hitting it,
    without needing flint and steel. Just click the left mouse button a few times
    when pointing at the TNT to make it explode!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*flowerTrail.py*程序非常灵活。试着改变程序放置的方块类型。一个有趣的方块类型是爆炸性TNT（`setBlock(x, y, z, 46,
    1)`）。注意在`46`之后的额外参数`1`，它是TNT方块类型。`1`将TNT的状态设置为只要碰到它就会引爆，而不需要打火石和火柴。当你指向TNT时，连续点击鼠标左键几次，就能让它爆炸！'
- en: '**FANCY CONDITIONS**'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**复杂条件**'
- en: Because `while` loops expect a Boolean value for their condition, you can use
    any of the comparators and Boolean operators that you’ve learned about so far.
    For instance, you’ve already seen that the greater than and less than operators
    work just like they did in earlier chapters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`while`循环期望其条件是一个布尔值，你可以使用到目前为止学到的所有比较符和布尔运算符。例如，你已经看到大于和小于运算符就像在之前的章节中一样使用。
- en: But you can control `while` loops with comparators and Boolean operators in
    other ways as well. Let’s take a look!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也可以通过其他方式使用比较符和布尔运算符来控制`while`循环。让我们来看看！
- en: We’ll start by writing a more interactive condition. The following code creates
    the `continueAnswer` variable before the loop starts and checks that the value
    is equal to `"Y"`. Note that we can’t use the word `continue` as a variable name
    because it is a reserved word in Python.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从编写一个更互动的条件开始。以下代码在循环开始之前创建了`continueAnswer`变量，并检查其值是否等于`"Y"`。请注意，我们不能使用`continue`作为变量名，因为它是Python中的保留字。
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the last line of the `while` loop, the program asks for input from the user.
    If the user presses anything besides `"Y"` in response, the loop will exit. The
    user can repeatedly press Y and Y and Y, and each time the value of the `coins`
    variable will increase by 1.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环的最后一行，程序要求用户输入。如果用户输入除`"Y"`之外的任何内容，循环将结束。用户可以重复按下Y、Y、Y，每次`coins`变量的值都会增加1。
- en: Notice that the variable being checked, `continueAnswer`, is created before
    the loop starts. If it wasn’t, the program would display an error. That’s why
    the variable we use to test the condition must exist before we try to use it,
    and it must be `True` when the program reaches the `while` loop the first time;
    otherwise, the condition won’t be met, and the `while` loop’s body statement will
    never execute.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正在检查的变量`continueAnswer`是在循环开始之前创建的。如果没有创建，程序会显示错误。因此，我们用来测试条件的变量必须在使用之前就存在，并且在程序第一次进入`while`循环时，变量的值必须为`True`；否则，条件将不成立，`while`循环的主体语句将永远不会执行。
- en: '**MISSION #36: DIVING CONTEST**'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #36: 潜水比赛**'
- en: Let’s have some fun with `while` loops and the equal to (`==`) comparator. In
    this mission, you’ll create a mini-game in which the player dives underwater for
    as long as they can. The program will record how many seconds they stay underwater
    and display their score at the end of the program. To congratulate the player,
    the program will shower them with flowers if they stay underwater longer than
    6 seconds.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`while`循环和相等运算符（`==`）来玩得开心。在这个任务中，你将创建一个小游戏，让玩家尽可能长时间地潜水。程序会记录他们在水下停留的时间，并在程序结束时显示他们的得分。如果玩家在水下停留超过6秒，程序将为他们洒下鲜花，祝贺他们。
- en: 'Here is some code to get you started:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些代码，帮助你入门：
- en: '*divingContest.py*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*divingContest.py*'
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Save the program as *divingContest.py* in your *whileLoops* folder. The `score`
    variable keeps track of how many seconds the player is underwater.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序保存为*divingContest.py*，并放在你的*whileLoops*文件夹中。`score`变量用于记录玩家在水下停留的时间（秒数）。
- en: 'Run the code to see what happens. At the moment, the program isn’t complete:
    it only checks whether the player is underwater once and then finishes.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码看看会发生什么。此时程序还未完成：它只会检查玩家是否在水下一次，然后结束。
- en: Before you fix this, let’s look at what the rest of the code does. The `blockAbove`
    variable stores the type of the block located at the player’s head ➊. For example,
    if the player’s head is underwater, this variable will store a value of 8 (which
    means the block is water). Later in the code, you’ll set `blockAbove` to store
    the value of the block above the player’s head again ➌ so when you create your
    `while` loop, it will update `blockAbove` to the current block above the player’s
    head. At ➍, the program adds 1 point to the total for every second the player
    is underwater, and at ➎, it uses an `if` statement to create a shower of flowers
    above the player if the score is greater than 6.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在你修复此问题之前，让我们看看代码的其余部分。`blockAbove` 变量存储位于玩家头顶的方块类型 ➊。例如，如果玩家的头在水下，这个变量将存储一个值
    8（表示该方块是水）。稍后在代码中，你将重新设置 `blockAbove` 存储玩家头顶上方方块的值 ➌，这样当你创建 `while` 循环时，它会将 `blockAbove`
    更新为玩家头顶当前的方块类型。在 ➍，程序会为玩家每在水下待一秒钟，给总分加 1 分；而在 ➎，它会使用 `if` 语句，如果得分大于 6，就在玩家头顶上方生成花朵雨。
- en: 'It’s up to you to add a loop to the program that uses the `blockAbove` variable
    as a condition at ➋. Make the `while` loop check whether `blockAbove` is equal
    to water (block type 8) or equal to flowing water (block type 9). You can use
    the following condition in the while loop to check this: `while blockAbove ==
    8 or blockAbove == 9`. This checks whether the player is currently underwater
    and will continue to check whether the player is underwater every time the loop
    repeats.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在程序中添加一个循环，使用 `blockAbove` 变量作为条件，位置在 ➋。使 `while` 循环检查 `blockAbove` 是否等于水（方块类型
    8）或等于流动水（方块类型 9）。你可以在 while 循环中使用以下条件来检查：`while blockAbove == 8 or blockAbove
    == 9`。这会检查玩家当前是否在水下，并在每次循环重复时继续检查玩家是否在水下。
- en: To test your program, find some water that’s at least three blocks deep and
    dive into it. The program will run only if you’re already underwater. When you
    run the program, it should start displaying how many seconds you’ve been underwater.
    After a while, swim to the surface. The program should display your score and
    shower you with flowers if you were underwater for 6 seconds or more. [Figure
    7-4](ch07.html#ch7fig4) shows the player underwater and the score being displayed.
    [Figure 7-5](ch07.html#ch7fig5) shows the flowers that appear when you win.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的程序，找到至少三格深的水并跳进去。程序只会在你已经在水下时运行。当你运行程序时，它应该开始显示你在水下的秒数。过一会儿，游到水面。程序应该显示你的得分，如果你在水下呆了
    6 秒或更长时间，还会洒上花朵。[图 7-4](ch07.html#ch7fig4) 显示了玩家在水下且得分已显示。[图 7-5](ch07.html#ch7fig5)
    显示了获胜时出现的花朵。
- en: '![image](graphics/f07-04.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-04.jpg)'
- en: '*Figure 7-4: I’m holding my breath underwater, and the number of seconds I’ve
    been underwater is displayed.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：我正在水下屏住呼吸，显示的是我在水下待的秒数。*'
- en: '![image](graphics/f07-05.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-05.jpg)'
- en: '*Figure 7-5: I won my very own flowery celebration!*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：我赢得了属于自己的花朵庆祝！*'
- en: '**BONUS OBJECTIVE: A WINNER IS YOU**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励目标：你是赢家**'
- en: Try adding extra prizes by writing more code in the `if` statement at the end
    of the program. If the player gets a high score, you could give them a gold block.
    Try adding several levels of difficulty with different prizes for each one.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过在程序结尾的 `if` 语句中编写更多代码来添加额外的奖励。如果玩家得分很高，你可以给他们一个金块。试着为每个难度级别添加不同的奖励。
- en: '**BOOLEAN OPERATORS AND WHILE LOOPS**'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**布尔运算符与 while 循环**'
- en: 'You can use Boolean operators like *and*, *or*, and *not* with a `while` loop
    when you want the loop to use more than one condition. For example, the following
    loop will iterate while the user has not input the correct password and has made
    three attempts or fewer:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望循环使用多个条件时，可以在 `while` 循环中使用布尔运算符，如*and*、*or*和*not*。例如，以下循环将在用户未输入正确密码且尝试次数不超过三次时进行迭代：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `while` loop condition ➊ does two tasks: it checks whether the password
    is different from the user’s input (`password != passwordInput`) and checks whether
    the user has tried to enter the password three times or less (`attempts < 3`).
    The `and` operator allows the `while` loop to check both conditions at the same
    time. If the condition is `False`, the loop increments the `attempts` variable
    ➋ and asks the user to reenter the password ➌. The loop will finish if the user
    enters the correct password or the `attempts` variable is greater than 3\. After
    the loop finishes, the program will output `Password accepted` only if the user
    entered the correct password ➍.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环条件 ➊ 执行了两项任务：它检查密码是否与用户输入的不同（`password != passwordInput`），并检查用户是否尝试输入密码不超过三次（`attempts
    < 3`）。`and` 操作符使 `while` 循环能够同时检查这两个条件。如果条件为 `False`，循环会增加 `attempts` 变量 ➋ 并要求用户重新输入密码
    ➌。如果用户输入了正确的密码或 `attempts` 变量大于 3，循环将结束。循环结束后，程序将输出 `Password accepted`，前提是用户输入了正确的密码
    ➍。'
- en: '**CHECKING A RANGE OF VALUES IN WHILE LOOPS**'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**检查 while 循环中值的范围**'
- en: You can also check for values in a certain range using a `while` loop. For example,
    the following code checks whether the value the user has entered is between 0
    and 10\. If it is not, the loop will exit.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `while` 循环检查某个范围内的值。例如，以下代码检查用户输入的值是否在 0 和 10 之间。如果不是，循环将退出。
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the `position` variable is greater than 10, the loop won’t repeat ➊. The
    same will happen if the value is less than 0\. This is useful in Minecraft when
    you’re checking whether the player’s position is in a certain area in the game,
    as you’ll see in the next mission.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `position` 变量大于 10，循环将不会重复 ➊。如果值小于 0 也会如此。这在 Minecraft 中非常有用，当你检查玩家是否处于游戏中的某个特定区域时，正如你在下一个任务中将会看到的。
- en: '**MISSION #37: MAKE A DANCE FLOOR**'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #37：制作一个舞池**'
- en: It’s time to dance! But before you can bust out some sweet moves, you’ll need
    a dance floor. The program in this mission will generate a dance floor that flashes
    different colors every half second as long as the player stays on the floor.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该跳舞时间到了！但在你能展现舞步之前，你需要一个舞池。本任务中的程序会生成一个舞池，并且只要玩家站在舞池上，舞池就会每半秒改变一次颜色。
- en: The following is the start of the code. It creates a dance floor at the player’s
    current position and uses an `if` statement to change colors. But the code is
    not complete.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的开头。它在玩家当前的位置创建一个舞池，并使用 `if` 语句改变颜色。但代码尚未完成。
- en: '*danceFloor.py*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*danceFloor.py*'
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Open IDLE, create a new file, and save the program as *danceFloor.py* in the
    *whileLoops* folder. The code builds the dance floor based on the player’s current
    position ➊ and stores the dance floor’s location and size in the `floorX`, `floorY`,
    `floorZ`, `width`, and `length` variables. Inside the `while` loop, the code uses
    an `if` statement to alternate the blocks that the dance floor is made of ➌, making
    the dance floor look like it’s flashing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 IDLE，创建一个新文件，并将程序保存为 *danceFloor.py* 在 *whileLoops* 文件夹中。代码根据玩家的当前位置➊构建舞池，并将舞池的位置和大小存储在
    `floorX`、`floorY`、`floorZ`、`width` 和 `length` 变量中。在 `while` 循环内部，代码使用 `if` 语句交替改变构成舞池的方块
    ➌，使得舞池看起来像是在闪烁。
- en: To get the program to work properly, you need to change the `while` loop’s condition
    to check whether the player’s z-coordinate is on the dance floor ➋. In other words,
    check whether `pos.z` is greater than or equal to `floorZ` and less than or equal
    to `floorZ` plus `length`. For guidance, look at how I checked whether `pos.x`
    is on the dance floor by using (`floorX <= pos.x <= floorX + width`). [Figure
    7-6](ch07.html#ch7fig6) shows the dance floor in action!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让程序正常工作，你需要修改 `while` 循环的条件，检查玩家的 z 坐标是否在舞池上➋。换句话说，检查 `pos.z` 是否大于或等于 `floorZ`
    并且小于或等于 `floorZ` 加 `length`。为了指导你，看看我是如何通过使用（`floorX <= pos.x <= floorX + width`）来检查
    `pos.x` 是否在舞池上的。[图 7-6](ch07.html#ch7fig6) 展示了舞池的实际效果！
- en: '![image](graphics/f07-06.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-06.jpg)'
- en: '*Figure 7-6: I’m showing off my moves on the dance floor.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：我在舞池上展示我的舞步。*'
- en: When you’ve completed the program, save it and run it. A dance floor should
    appear below the player and change every half second. Dance around a bit—have
    some fun! When you’re done, leave the dance floor and make sure it stops flashing.
    It won’t switch on again unless you run the program again to create a new dance
    floor.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 完成程序后，保存并运行它。玩家下方应该会出现一个舞池，并且每半秒钟改变一次。跳一会儿舞——玩得开心！完成后，离开舞池，确保它停止闪烁。除非重新运行程序来创建新的舞池，否则它不会再次开启。
- en: '**BONUS OBJECTIVE: PARTY’S OVER**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加目标：派对结束**'
- en: When the player is finished dancing on the dance floor, make the floor disappear.
    To do this, change the dance floor to air when the loop finishes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家在舞池中跳舞完成后，让舞池消失。为此，当循环结束时，将舞池更改为空气。
- en: '**NESTED IF STATEMENTS AND WHILE LOOPS**'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**嵌套 IF 语句与 WHILE 循环**'
- en: 'You can write more powerful programs by using `if` statements and nested `if`
    statements inside `while` loops. You may have noticed a nested `if` statement
    in the code in [Mission #37](ch07.html#ch07lev2sec08) ([page 135](ch07.html#page_135)).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以通过在 `while` 循环中使用 `if` 语句和嵌套的 `if` 语句来编写更强大的程序。你可能已经注意到，在 [任务 #37](ch07.html#ch07lev2sec08)
    ([第 135 页](ch07.html#page_135)) 的代码中使用了一个嵌套的 `if` 语句。'
- en: In the following example, the nested `if` statement checks the last word that
    was printed and decides whether to print the words `"mine"` and `"craft"`. The
    loop repeats 50 times.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，嵌套的 `if` 语句检查最后打印的单词，并决定是否打印单词 `"mine"` 和 `"craft"`。循环重复 50 次。
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `word` variable stores the first word that will be printed. The `if` statement
    in the loop checks whether the current word is `"mine"` and, if it is, changes
    the word to `"craft"` and prints it on the next iteration of the loop. If the
    word isn’t `"mine"`, it will be changed to `"mine"`. This is an infinite loop,
    so be sure to use CTRL-C to escape!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`word` 变量存储将要打印的第一个单词。循环中的 `if` 语句检查当前单词是否为 `"mine"`，如果是，它将把单词更改为 `"craft"`，并在下一个循环迭代中打印该单词。如果单词不是
    `"mine"`，它将被更改为 `"mine"`。这是一个无限循环，所以请确保使用 CTRL-C 来退出！'
- en: You can also nest `elif` statements and other `while` loops inside `while` loops.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 `while` 循环中嵌套 `elif` 语句和其他 `while` 循环。
- en: 'The following program asks the user if they want to print all the numbers between
    one and a million:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序会询问用户是否希望打印出从 1 到 100 万之间的所有数字：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `if` statement checks whether the user’s input is `yes` ➊. If it is, the
    program runs the loop that is nested in the `if` statement ➋. If the input is
    anything else, the program won’t run the loop and will finish.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句检查用户的输入是否为 `yes` ➊。如果是，程序将运行嵌套在 `if` 语句中的循环 ➋。如果输入的是其他内容，程序将不会运行该循环，并将结束。'
- en: '**MISSION #38: THE MIDAS TOUCH**'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #38：米达斯的触摸**'
- en: Midas is a king of legend. Everything he touched turned to gold. Your mission
    is to write a program that changes every block below the player to gold—except
    for air and water, of course, or you’d be in real trouble! Recall that the gold
    block has a value of 41, still water is 9, and air is 0.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 米达斯是一个传奇中的国王。他所触及的所有东西都会变成黄金。你的任务是编写一个程序，将玩家下面的每一块地板都变成黄金——当然，空气和水除外，否则你会陷入麻烦！请记住，黄金块的值是
    41，静水的值是 9，空气的值是 0。
- en: '*midas.py*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*midas.py*'
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Open IDLE and create a new file. Save the file as *midas.py* in the *whileLoops*
    folder. You need to add a bit more to the program so it can do what you need it
    to do. First, you’ll add an infinite `while` loop ➊. Remember that an infinite
    `while` loop has a condition that is always `True`. You also need to add an `if`
    statement that checks whether the block below the player is not equal to air and
    not equal to still water ➋. The value of the block below the player is stored
    in the `blockBelow` variable, and the values for air and water are stored in the
    `air` and `water` variables.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 IDLE 并创建一个新文件。将文件保存为 *midas.py*，并放入 *whileLoops* 文件夹中。你需要在程序中添加更多内容，以便它能完成你需要的操作。首先，你将添加一个无限的
    `while` 循环 ➊。记住，无限 `while` 循环的条件总是 `True`。你还需要添加一个 `if` 语句，用来检查玩家下面的方块既不等于空气也不等于静水
    ➋。玩家下面的方块的值存储在 `blockBelow` 变量中，空气和水的值分别存储在 `air` 和 `water` 变量中。
- en: When you’ve completed the program, save it and run it. The player should leave
    a trail of gold behind them. When you jump in water or fly in the air, the blocks
    below you should not change. [Figure 7-7](ch07.html#ch7fig7) shows the program
    in action.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成程序后，保存并运行它。玩家应在身后留下黄金的足迹。当你跳入水中或飞上空中时，你下面的方块不应该发生变化。[图 7-7](ch07.html#ch7fig7)
    显示了程序运行的效果。
- en: '![image](graphics/f07-07.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-07.jpg)'
- en: '*Figure 7-7: Every block I walk on turns to gold.*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：我走过的每一块地板都变成了黄金。*'
- en: To exit the infinite loop, go to **Shell** ▸ **Restart Shell** in your IDLE
    shell or click in the shell and press CTRL-C.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出无限循环，进入 **Shell** ▸ **Restart Shell**，在 IDLE shell 中或点击 shell 并按 CTRL-C。
- en: '**BONUS OBJECTIVE: I’M A PLOWMAN**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加目标：我是一个犁耕者**'
- en: You can change *midas.py* to serve a variety of purposes. How would you change
    it so it automatically changes dirt blocks to hoed farmland? How about changing
    dirt blocks to grass blocks?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改*midas.py*以实现各种功能。你会如何修改它，使其自动将泥土方块转换为耕地？那如果将泥土方块转换为草方块呢？
- en: '**ENDING A WHILE LOOP WITH BREAK**'
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用BREAK结束WHILE循环**'
- en: With `while` loops, you have complete control over how and when the loop ends.
    So far you’ve only used conditions to end loops, but you can also use a `break`
    statement. The `break` statement lets your code immediately exit a `while` loop.
    Let’s look at this concept!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`while`循环时，你可以完全控制循环的开始和结束。到目前为止，你只使用条件来结束循环，但你也可以使用`break`语句。`break`语句让你的代码立即退出`while`循环。我们来看看这个概念！
- en: 'One way to use `break` statements is to put them in an `if` statement nested
    in the loop. Doing so immediately stops the loop when the `if` statement’s condition
    is `True`. The following code continually asks for user input until they type
    `"exit"`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`break`语句的一种方法是将其放入嵌套在循环中的`if`语句中。这样，当`if`语句的条件为`True`时，循环会立即停止。以下代码会不断请求用户输入，直到他们输入`"exit"`：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is an infinite loop because it uses `while True` ➊. Each time the loop
    repeats, it asks for the user to enter a command ➋. The program checks whether
    the input is `"exit"` ➌ using an `if` statement. If the input meets the condition,
    the `break` statement stops the loop from repeating ➍, and the program continues
    on the line immediately after the body of the loop, printing `"Loop exited"` to
    the Python shell ➎.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个无限循环，因为它使用了`while True` ➊。每次循环重复时，它都会请求用户输入命令 ➋。程序通过`if`语句检查输入是否为`"exit"`
    ➌。如果输入符合条件，`break`语句会停止循环的重复 ➍，程序会继续执行循环体之后的代码，并在Python Shell中打印`"Loop exited"`
    ➎。
- en: '**MISSION #39: CREATE A PERSISTENT CHAT WITH A LOOP**'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #39：创建一个带循环的持久聊天**'
- en: 'In [Mission #13](ch04.html#ch04lev2sec05) ([page 72](ch04.html#page_72)), you
    created a program that posts the user’s message to chat using strings, input,
    and output. Although this program was useful, it was quite limited because you
    had to rerun the program every time you wanted to post a new message.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '在[任务 #13](ch04.html#ch04lev2sec05)（[第72页](ch04.html#page_72)）中，你创建了一个使用字符串、输入和输出将用户消息发布到聊天的程序。尽管这个程序很有用，但因为每次发布新消息时都需要重新运行程序，所以它的功能非常有限。'
- en: In this mission, you’ll improve your chat program using a `while` loop so users
    can post as many messages as they want without restarting the program.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，你将通过使用`while`循环改进你的聊天程序，让用户可以在不重新启动程序的情况下发送任意数量的消息。
- en: Open the *userChat.py* file in the *strings* folder and then save it as *chatLoop.py*
    in the *whileLoops* folder.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*userChat.py*文件（位于*strings*文件夹中），然后将其另存为*chatLoop.py*，保存在*whileLoops*文件夹中。
- en: 'To post a new message every time you want to without rerunning the program,
    add the following to your code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不重新运行程序的情况下每次发布新消息，向你的代码添加以下内容：
- en: Add an infinite `while` loop to the program.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个无限的`while`循环添加到程序中。
- en: Add an `if` statement to the loop to check whether the user’s input is `"exit"`.
    If the input is `"exit"`, the loop should break.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向循环中添加一个`if`语句，检查用户的输入是否为`"exit"`。如果输入是`"exit"`，循环应当中断。
- en: Make sure the `userName` variable is defined before the start of the loop.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在循环开始之前定义好`userName`变量。
- en: When you’ve added the changes, save your program and run it. A prompt in the
    Python shell will ask you to type in a username. Do this and press ENTER. The
    program will then ask you to enter a message. Type a message and then press ENTER.
    The program will keep asking you to enter a message until you type `exit`. [Figure
    7-8](ch07.html#ch7fig8) shows my chat program running.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加完更改后，保存你的程序并运行它。Python Shell会提示你输入用户名。输入后按ENTER键。然后程序会要求你输入一条消息。输入一条消息后按ENTER键。程序会继续要求你输入消息，直到你输入`exit`为止。[图7-8](ch07.html#ch7fig8)展示了我的聊天程序运行情况。
- en: '![image](graphics/f07-08.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-08.jpg)'
- en: '*Figure 7-8: I’m chatting with myself.*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-8：我在和自己聊天。*'
- en: '**BONUS OBJECTIVE: BLOCK CHAT**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励目标：方块聊天**'
- en: Expand the chat feature so users can create blocks. For example, if the user
    enters `"wool"`, the program creates a wool block. You can do this by adding `elif`
    statements to your `if` statement to check user input.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展聊天功能，让用户能够创建方块。例如，如果用户输入`"wool"`，程序将创建一个羊毛方块。你可以通过向`if`语句中添加`elif`语句来检查用户输入。
- en: '**WHILE-ELSE STATEMENTS**'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**WHILE-ELSE语句**'
- en: Like an `if` statement, `while` loops can have secondary conditions triggered
    by `else` statements.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 像`if`语句一样，`while`循环也可以有由`else`语句触发的次要条件。
- en: 'The `else` statement executes when the condition of a `while` statement is
    `False`. Unlike the body of a `while` statement, the `else` statement will execute
    only once, as shown here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`语句在`while`语句的条件为`False`时执行。与`while`语句的主体不同，`else`语句只会执行一次，如下所示：'
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This loop repeats as long as the `message` entered is not equal to `"exit"`.
    If the `message` is `"exit"`, the loop will stop repeating, and the body of the
    `else` statement will print `"User has left the chat."`
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环会在输入的`message`不等于`"exit"`时一直重复。如果`message`是`"exit"`，循环将停止重复，`else`语句的内容将打印`"User
    has left the chat."`
- en: If you use a `break` statement in the `while` statement, the `else` isn’t executed.
    The following code is similar to the preceding example but includes a nested `if`
    statement and a `break` statement. When the user types `abort` instead of `exit`,
    the chat loop will exit without printing the `"User has left the chat."` message
    to the chat.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`while`语句中使用了`break`语句，`else`语句将不会执行。以下代码与前面的示例类似，但包含一个嵌套的`if`语句和一个`break`语句。当用户输入`abort`而不是`exit`时，聊天循环将退出，而不会打印`"User
    has left the chat."`的消息。
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `if` statement checks whether the message entered is `"abort"`. If this
    is `True`, the `break` statement runs and the loop will exit. Because the `break`
    statement was used, the body of the `else` statement will not run, and `"User
    has left the chat."` will not be printed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句检查输入的消息是否为`"abort"`。如果为`True`，则执行`break`语句，循环将退出。因为使用了`break`语句，所以`else`语句的内容不会执行，`"User
    has left the chat."`也不会被打印。'
- en: '**MISSION #40: HOT AND COLD**'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #40：热与冷**'
- en: In this mission, we’ll create a Hot and Cold game in Minecraft. If you’ve never
    played, the idea is that your friend hides an object and you have to find it.
    Your friend gives you hints based on how far away from the object you are. If
    you’re close, your friend says “Hot,” and if you’re far away, they’ll say “Cold.”
    When you’re right next to the object, they’ll say “You’re on fire!” and if you’re
    very far away, they’ll say “Freezing!”
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将在《Minecraft》中创建一个“热与冷”游戏。如果你从未玩过，游戏的规则是你的朋友隐藏一个物体，而你需要找到它。你的朋友会根据你离物体的远近给你提示。如果你很近，他们会说“热”，如果很远，他们会说“冷”。当你站在物体旁边时，他们会说“你着火了！”，如果你很远，他们会说“冰冻！”
- en: The object of the game is to find and stand on the diamond block that has been
    placed randomly in the game world. In this version of the game, you’ll play by
    yourself, and the Python program will tell you how far away from the hidden block
    you are. The game ends when you stand on the diamond block.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的目标是找到并站在随机放置在游戏世界中的钻石方块上。在这个版本的游戏中，你将单独玩，Python 程序会告诉你距离隐藏方块的远近。当你站在钻石方块上时，游戏结束。
- en: '[Listing 7-2](ch07.html#ch7ex2) places a block in a random location.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-2](ch07.html#ch7ex2) 将一个方块放置在随机位置。'
- en: '*blockHunter.py*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*blockHunter.py*'
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 7-2: The start of the Hot and Cold program*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-2：热与冷程序的开始部分*'
- en: Before randomly placing a block, the program makes sure that the block won’t
    be placed underground. To do so, it uses the `getHeight()` function ➊, which finds
    the block that is the highest y-coordinate (that is, on the surface) for any position
    in the game. Then it places a diamond block at a random position ➋.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在随机放置方块之前，程序确保方块不会被放置在地下。为此，它使用`getHeight()`函数 ➊，该函数找到游戏中任何位置的最高 y 坐标的方块（即地面上的方块）。然后，它在随机位置
    ➋ 放置一个钻石方块。
- en: The code at ➌ calculates the distance to the diamond block. It uses the `sqrt()`
    function, which is in the `math` module—this is why `import math` is needed at
    the beginning of the program. The `sqrt()` function calculates the square root
    of a number.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ 处的代码计算到钻石方块的距离。它使用`sqrt()`函数，该函数位于`math`模块中——这就是为什么程序开始时需要`import math`的原因。`sqrt()`函数计算一个数的平方根。
- en: '**NOTE**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*[Listing 7-2](ch07.html#ch7ex2) uses a formula called the* Pythagorean theorem.
    *The formula uses two sides of a triangle to calculate the length of the third.
    In this case, I use the distance from the player to the hidden block on the x-axis
    and the z-axis to calculate the distance to the hidden block in a straight line.*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*[列表 7-2](ch07.html#ch7ex2) 使用了一个叫做*毕达哥拉斯定理*的公式。*该公式使用三角形的两边来计算第三边的长度。在这种情况下，我使用玩家到隐藏方块在
    x 轴和 z 轴的距离来计算到隐藏方块的直线距离。*'
- en: The message that the program displays depends on how far away you are from the
    block, which you can find out using an `if` statement and the `distance` variable
    ➍. The program displays `"Freezing"` if you’re very far away and `"On fire!"`
    if you’re very close.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 程序显示的信息取决于你距离方块的远近，你可以通过`if`语句和`distance`变量  ➍ 来确定。当你远离方块时，程序会显示 `"Freezing"`，而当你非常接近时，程序会显示
    `"On fire!"`。
- en: Copy [Listing 7-2](ch07.html#ch7ex2) into a new file in IDLE and save the program
    as *blockHunter.py* in the *whileLoops* folder.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单7-2](ch07.html#ch7ex2)复制到IDLE中新文件中，并将程序保存为*blockHunter.py*，存放在*whileLoops*文件夹内。
- en: At the moment the program works, but it doesn’t end when you find the block.
    To finish the code, you need to add a `break` statement when the player’s distance
    from the block is 0 ➎.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 目前程序是可以运行的，但当你找到方块时并不会结束。要完成代码，你需要在玩家与方块的距离为0时添加一个`break`语句➎。
- en: When you’ve completed the program, save it and run it. A random block will be
    generated, and you’ll need to find it. The program should stop when you find the
    block and stand on it. [Figure 7-9](ch07.html#ch7fig9) shows that I’ve just found
    the block.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 完成程序后，保存并运行它。程序会生成一个随机方块，你需要找到它。当你找到并站在方块上时，程序应该停止。[图7-9](ch07.html#ch7fig9)显示了我刚刚找到了方块。
- en: '![image](graphics/f07-09.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f07-09.jpg)'
- en: '*Figure 7-9: I’ve found the block, and now I just need to stand on it.*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-9：我已经找到了方块，现在只需要站在上面。*'
- en: '**BONUS OBJECTIVE: TIME FOR TIME**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外目标：时间就是时间**'
- en: The *blockHunter.py* program gives you as long as you need to find the block.
    Can you think of a way to display how long it takes the player to find the block
    or even limit the amount of time they have to play the game?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*blockHunter.py*程序会给你足够的时间来找到方块。你能想到一种方法来显示玩家找到方块所花的时间，或者甚至限制他们玩游戏的时间吗？'
- en: '**WHAT YOU LEARNED**'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: Well done! You’ve learned a lot about `while` loops. You can create `while`
    loops and infinite `while` loops, and you can use loops with conditions and Boolean
    operators. Using loops, you can now write programs that repeat code, which will
    save you lots of time so you can focus on mastering Minecraft. In [Chapter 8](ch08.html#ch08),
    you’ll learn another way to make reusable code using functions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！你已经学到了很多关于`while`循环的知识。你可以创建`while`循环和无限`while`循环，并且能够使用带条件和布尔运算符的循环。通过使用循环，你现在可以编写重复代码的程序，这样可以节省大量时间，让你可以专注于掌握Minecraft。在[第8章](ch08.html#ch08)中，你将学习另一种使用函数使代码可重用的方法。
