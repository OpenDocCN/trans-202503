- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: BRAINFUCK
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: BRAINFUCK
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: '*Brainfuck*, or *BF* as we’ll call it, is more or less the grandfather of all
    esolangs. It’s one of the earliest and probably the most extended, modified, discussed,
    and parodied esolang in existence. In this chapter, we’ll see what all the fuss
    is about it—there’s more to it than just the name!'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*Brainfuck*，或者我们称之为*BF*，或多或少是所有另类编程语言的祖先。它是最早的，并且可能是最广泛的、修改过的、讨论过的、恶搞过的另类编程语言之一。在这一章中，我们将看看它为何如此引起关注——它的内容远不止名字那么简单！'
- en: '**WTF Is BF?**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**WTF是BF？**'
- en: BF is the brainchild of Urban Müller, who loosed it upon an unsuspecting world
    in 1993\. His goal was to create a tiny language leading to a tiny compiler for
    the Amiga computer. His compiler was 296 bytes long. Later in the chapter, we’ll
    encounter a BF compiler that’s only 166 bytes long.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: BF是Urban Müller的脑力结晶，他在1993年将其带入了这个未曾察觉的世界。他的目标是创建一个小巧的语言，并为Amiga计算机开发一个小巧的编译器。他的编译器长296字节。稍后在本章中，我们将遇到一个仅166字节长的BF编译器。
- en: How can BF compilers be so tiny? Because BF itself is tiny (see [Table 10-1](ch10.xhtml#ch010tab1),
    which describes all *eight* commands). As a certain pig might say, “Th-th-that’s
    all, folks!”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么BF编译器可以如此小巧？因为BF本身就很小（见[表10-1](ch10.xhtml#ch010tab1)，其中描述了所有*八个*命令）。就像某只猪可能会说的那样，“就这样，伙计们！”
- en: '**Table 10-1:** BF in All Its Glory'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**表10-1：** BF的全貌'
- en: '| **Command** | **Action** |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **操作** |'
- en: '| --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `>` | Increment memory pointer |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 递增内存指针 |'
- en: '| `<` | Decrement memory pointer |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 递减内存指针 |'
- en: '| `.` | Print memory as a character |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 将内存内容作为字符打印 |'
- en: '| `,` | Input a character to memory |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `,` | 将字符输入到内存 |'
- en: '| `+` | Increment memory |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 递增内存 |'
- en: '| `-` | Decrement memory |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 内存递减 |'
- en: '| `[` | Begin loop if memory not 0 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `[` | 如果内存不为0，则开始循环 |'
- en: '| `]` | Continue loop if memory not 0 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `]` | 如果内存不为0，则继续循环 |'
- en: The machine BF expects is quite similar to a Turing machine. The BF machine
    is a vector of cells, each of which holds a single value. Originally, there were
    30,000 cells, each capable of holding a single byte [0, 255]. The interpreters
    we’ll use in this chapter have 32-bit cells. BF is analogous to what’s called
    a *Harvard architecture*, a hardware architecture in which the program space and
    memory are distinct. There’s no self-modifying code here, though I wouldn’t be
    surprised if someone has created a von Neumann version of BF just to explore what
    self-modifying BF code might be able to accomplish. Recall that a von Neumann
    architecture combines program space and memory. Modern PCs are von Neumann machines.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: BF期望的机器与图灵机非常相似。BF机器是一个由单元格组成的向量，每个单元格存储一个值。最初有30,000个单元格，每个单元格能存储一个字节[0，255]。我们在本章使用的解释器有32位单元格。BF类似于被称为*哈佛架构*的硬件架构，在这种架构中，程序空间和内存是分开的。这里没有自我修改的代码，尽管我不会感到惊讶，如果有人为了探索自我修改的BF代码可能能够完成的任务，创建了一个冯·诺依曼版本的BF。回想一下，冯·诺依曼架构将程序空间和内存结合在一起。现代PC是冯·诺依曼机器。
- en: A Turing machine has a tape head that moves along a tape to read and write symbols.
    BF does the same, but in this case we’ll call the “tape head” a memory or cell
    pointer. The `>` and `<` instructions move the memory pointer from cell to cell
    and the remaining BF instructions operate on the current memory cell. When a BF
    program starts, it assumes each memory cell has a value of 0 and the pointer is
    looking at cell 0.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵机有一个磁带头，沿着磁带读取和写入符号。BF也做了同样的事情，但在这里我们将“磁带头”称为内存或单元格指针。`>`和`<`指令将内存指针从一个单元格移动到另一个单元格，而其余的BF指令则操作当前的内存单元。当BF程序开始时，它假设每个内存单元的值为0，且指针指向第0个单元格。
- en: We now know what two of BF’s eight instructions do. The comma (`,`) and period
    (`.`) are input and output, respectively. The `+` increments the cell and `-`
    decrements it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了BF的八个指令中的两个做了什么。逗号（`,`）和句点（`.`）分别是输入和输出。`+`指令递增单元格，`-`指令递减单元格。
- en: 'What makes BF interesting as a language are the `[` and `]` loop instructions.
    Loops begin with `[` and end with `]`, but both are commands. When BF executes
    the `[` instruction, it looks at the current cell and asks: “Is the value 0?”
    If the answer is “yes,” BF skips ahead to the `]` instruction and continues with
    the instruction after it. If the answer is “no,” BF moves to the next instruction
    to begin the loop.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使得BF作为一种语言有趣的地方在于其`[`和`]`循环指令。循环以`[`开始，`[`和`]`都是命令。当BF执行`[`指令时，它会查看当前单元格并询问：“值是0吗？”如果答案是“是”，BF会跳过到`]`指令并继续执行其后的指令。如果答案是“不是”，BF会执行下一条指令并开始循环。
- en: When BF encounters a `]` instruction, it doesn’t automatically jump to the corresponding
    `[`. Instead, it examines the *current* memory cell and jumps back if that cell
    *isn’t* 0\. Otherwise, the loop ends and BF continues with the next instruction.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当 BF 遇到 `]` 指令时，它不会自动跳转到对应的 `[ `。相反，它会检查 *当前* 的内存单元格，如果该单元格 *不是* 0，它就跳回去。否则，循环结束，BF
    继续执行下一个指令。
- en: 'Think about this for a bit. The `[` command is a gatekeeper that decides whether
    a loop begins, but it doesn’t check anything after that. The decision about continuing
    a loop falls to the matching `]` instruction. Also, the cell that initiated the
    loop need not be the cell that decides whether the loop continues. BF is very
    flexible when it comes to looping, as we might expect from such a provocatively
    named language—it’s messing with our brains. BF loops are neither top-tested nor
    bottom-tested, but rather are a mix of both. There is a top test to decide whether
    the loop even begins, but from then on, the loop is bottom-tested. In C, we can
    accomplish something similar by nesting loops:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 思考一下这个问题。`[` 指令是一个门控，它决定循环是否开始，但它之后不会再检查任何事情。决定是否继续循环的责任落在匹配的 `]` 指令上。而且，启动循环的单元格不一定是决定循环是否继续的单元格。BF
    在循环方面非常灵活，正如我们从这种具有挑衅性的名称中可以预见的那样——它在挑战我们的思维。BF 循环既不是顶部测试也不是底部测试，而是两者的混合。存在一个顶部测试来决定循环是否开始，但从那时起，循环是底部测试的。在
    C 中，我们可以通过嵌套循环来实现类似的效果：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To begin the loop, `cond1` must be true. However, after `cond1` begins the loop,
    it isn’t examined again; the loop runs until `cond2` is no longer true. To get
    the desired effect in C, `cond1` must be made false (`cond1 = 0`), so the entire
    structure exits when `cond2` becomes false.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始循环，`cond1` 必须为真。然而，在 `cond1` 开始循环后，它不会再被检查；循环会一直执行，直到 `cond2` 不再为真。为了在 C
    中实现所需的效果，`cond1` 必须被设为假（`cond1 = 0`），这样整个结构在 `cond2` 变为假时会退出。
- en: BF code isn’t particularly easy to write, but it is complete enough to implement
    interesting, nontrivial programs. BF is more than ABC. We need an interpreter
    to see that’s the case; we’ll leave compiler design for another day.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: BF 代码写起来并不特别容易，但它足够完整，可以实现有趣的、非平凡的程序。BF 不仅仅是简单的 ABC。我们需要一个解释器来验证这一点；编译器设计我们可以留到另一天讨论。
- en: '**The Two Implementations**'
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**两个实现**'
- en: BF implementations abound. Let’s investigate two in this section. The first
    is a slightly updated version of Urban Müller’s original 1993 C code for the Amiga
    computer. The second we’ll build from scratch in SNOBOL because an unusual, minimalist
    esoteric language deserves an equally unusual implementation. If you skipped [Chapter
    5](ch05.xhtml#ch05) on SNOBOL, now’s a good time to go back and read it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: BF 实现层出不穷。让我们在本节中探讨两个实现。第一个是 Urban Müller 于 1993 年为 Amiga 计算机编写的原始 C 代码的稍微更新版本。第二个我们将在
    SNOBOL 中从零开始构建，因为这种不寻常的、极简的晦涩语言值得一个同样不寻常的实现。如果你跳过了[第五章](ch05.xhtml#ch05)中的 SNOBOL
    内容，现在是时候回去阅读了。
- en: '***The Original***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原版***'
- en: The original Amiga LHA archive with the first version of BF is in the file *brainf-2.lha*.
    Müller’s implementation is in plain C. To work with the code on a modern Linux
    system, I took the liberty of updating it to compile without warnings, changed
    the cell size from 8 bits (`unsigned char`) to 32 bits (`int`), and increased
    the program space to 70,000 cells. Using 32-bit cells matches the SNOBOL implementation
    we’ll develop in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 Amiga LHA 压缩包包含了第一版 BF 的代码，文件名为 *brainf-2.lha*。Müller 的实现是用纯 C 编写的。为了在现代
    Linux 系统上使用该代码，我自行更新了它，使其能够无警告地编译，将单元格大小从 8 位（`unsigned char`）改为 32 位（`int`），并将程序空间增加到
    70,000 个单元格。使用 32 位单元格与我们将在下一节中开发的 SNOBOL 实现相匹配。
- en: '[Listing 10-1](ch10.xhtml#ch010list1) shows the interpreter in its entirety.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-1](ch10.xhtml#ch010list1) 显示了完整的解释器代码。'
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-1: Urban Müller’s original BF interpreter (updated)*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：Urban Müller 的原始 BF 解释器（更新版）*'
- en: This implementation is quite compact and handles loops via recursion (notice
    the recursive call to `interpret` ➊). Our SNOBOL implementation will process loops
    without recursion. Also, notice that `#` is a supported command. It prints basic
    debugging information if the interpreter is called with a second command line
    argument. The `#` command was dropped from later versions of BF. My modifications
    introduce `MAXMEM` and `MAXPROG` and the addition of `int` before `main` to avoid
    a `gcc` warning.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现非常紧凑，并通过递归处理循环（注意 `interpret` 的递归调用 ➊）。我们的 SNOBOL 实现将通过非递归方式处理循环。另外，注意到
    `#` 是一个受支持的命令。如果解释器被调用并传递第二个命令行参数，`#` 命令会打印基本的调试信息。后来版本的 BF 中已经去掉了 `#` 命令。我的修改引入了
    `MAXMEM` 和 `MAXPROG`，并在 `main` 前添加了 `int`，以避免 `gcc` 警告。
- en: The interpreter processes the input BF program loaded into `f`. The `interpret`
    function loops over the characters in `f`, or the characters of the nested loop
    enclosed in brackets via the recursive call. If the character is a BF command,
    the command is performed; otherwise, it is ignored.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器处理加载到 `f` 中的输入 BF 程序。`interpret` 函数循环遍历 `f` 中的字符，或者通过递归调用遍历括号中的嵌套循环字符。如果字符是
    BF 命令，则执行该命令；否则，忽略它。
- en: 'Building the interpreter is straightforward:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 构建解释器是直接的：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So is testing it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试它的过程如下：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All the BF examples in the book’s GitHub repository work with this interpreter.
    However, not every BF example you’ll find on the web does. Take a look at the
    *README* file in the *examples* directory, as it contains attribution and license
    information. Credit is given to code authors where authorship is known. I’ll leave
    working through the operation of *hello.b* as an exercise, as there are explanatory
    comments in the file. As you might expect, it involves generating and printing
    the required sequence of ASCII values.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本书 GitHub 仓库中的所有 BF 示例都可以与这个解释器一起使用。然而，并非所有你在网上找到的 BF 示例都能兼容。查看 *README* 文件，它位于
    *examples* 目录中，因为它包含了归属和许可证信息。如果已知作者身份，代码作者会得到相应的署名。我将让你自行完成 *hello.b* 文件的操作过程，因为文件中已经有了解释性注释。如你所料，它涉及到生成并打印所需的
    ASCII 值序列。
- en: '***SNOBOL Meets BF***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SNOBOL 与 BF 的结合***'
- en: 'The seductive elegance of BF requires, indeed, almost demands that we make
    our own interpreter. We’ll use SNOBOL because SNOBOL provides all the facilities
    we need. Besides, it’s fun. The full interpreter is in *bf.sno*. Let’s begin with
    the parser:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: BF 的诱人优雅确实几乎要求我们自己编写解释器。我们将使用 SNOBOL，因为 SNOBOL 提供了我们所需的所有功能。此外，它很有趣。完整的解释器在
    *bf.sno* 中。我们从解析器开始：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-2: Parsing the input file*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-2: 解析输入文件*'
- en: '[Listing 10-2](ch10.xhtml#ch010list2) presents global memory definitions and
    the `parse` function to read the input file and keep only actual program commands.
    Code is stored in the array `prog` with memory in `mem`, a second array. BF expects
    memory to be initialized to 0, which SNOBOL does for us via the second argument
    to `array` ➊. We’ll discuss the `jump` table momentarily.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 10-2](ch10.xhtml#ch010list2) 展示了全局内存定义和 `parse` 函数，用来读取输入文件并仅保留有效的程序命令。代码存储在数组
    `prog` 中，内存存储在第二个数组 `mem` 中。BF 期望内存被初始化为 0，SNOBOL 通过 `array` 的第二个参数 ➊ 为我们完成了这一操作。稍后我们将讨论
    `jump` 表。'
- en: The `parse` function accepts the `name` of the input text file, defines a pattern
    to match valid program characters (`pat`), and opens the file for input, reading
    one character at a time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse` 函数接受输入文本文件的 `name`，定义一个模式来匹配有效的程序字符（`pat`），并打开文件进行输入，每次读取一个字符。'
- en: The loop (`parse_l0`) reads a character into `c` and applies the pattern. If
    the pattern succeeds, then `c` contains one of the allowed command characters;
    therefore, `prog` is set and its index is incremented. Notice the SNOBOL idiom
    of embedding the `ne` predicate to test for maximum program length. If the predicate
    fails, the increment to `n` does not happen and execution falls through to `endfile`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 循环（`parse_l0`）将字符读入 `c` 并应用模式。如果模式匹配成功，那么 `c` 包含一个允许的命令字符；因此，`prog` 被设置，并且其索引递增。注意
    SNOBOL 的惯用法，将 `ne` 谓词嵌入来测试程序的最大长度。如果谓词失败，则 `n` 的递增不会发生，执行将跳转到 `endfile`。
- en: When `parse` finishes processing the input file, `prog` contains the valid commands
    and only the valid commands. The number of commands read is returned by assigning
    `n` to `parse`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `parse` 完成输入文件的处理时，`prog` 中包含了有效命令，且仅包含有效命令。读取的命令数量通过将 `n` 赋值给 `parse` 来返回。
- en: A BF program is executed sequentially until the interpreter encounters a loop.
    The original BF interpreter used recursion to handle loops; however, we’ll take
    a more literal approach. Every time we see an opening bracket (`[`), we’ll scan
    the program text forward to find the corresponding closing bracket (`]`). Similarly,
    for a closing bracket, we’ll scan backward to find the matching opening bracket.
    We could do this while interpreting the code, but that’s hideously inefficient—imagine
    a loop running tens of thousands of times.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: BF 程序按顺序执行，直到解释器遇到一个循环。原始的 BF 解释器使用递归来处理循环；然而，我们将采取更直接的方法。每当看到一个左括号 (`[`)，我们会向前扫描程序文本，找到对应的右括号
    (`]`)。类似地，对于右括号，我们将向后扫描，找到匹配的左括号。我们本可以在解释代码时进行此操作，但这效率低下——想象一下，一个循环运行了数万次。
- en: A moment’s thought makes it clear that a single pass through the code before
    starting the interpreter is sufficient to locate each opening bracket and its
    corresponding closing bracket. This is where the `jump` table comes into play.
    Recall that a SNOBOL table is like a Python dictionary; it’s an associative array.
    The index into the table is the index of an opening bracket in `prog`. Closing
    brackets also go in `jump`, as their index values are unique. With `jump` built
    ahead of time, a single reference to `jump` during program execution returns the
    proper index into `prog` for both the opening and closing brackets.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 片刻思考就能清楚，开始解释器之前对代码进行一次遍历就足以定位每个左括号及其对应的右括号。这就是 `jump` 表发挥作用的地方。回想一下，SNOBOL
    的表就像 Python 字典；它是一个关联数组。表中的索引是 `prog` 中左括号的索引。右括号也存储在 `jump` 中，因为它们的索引值是唯一的。通过提前构建
    `jump`，在程序执行期间对 `jump` 的一次引用就能为左右括号提供正确的索引。
- en: '[Listing 10-3](ch10.xhtml#ch010list3) shows `buildtable` and its helper function,
    `closing`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 10-3](ch10.xhtml#ch010list3) 显示了 `buildtable` 及其辅助函数 `closing`。'
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 10-3: Building the jump table*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-3：构建跳转表*'
- en: Here, `buildtable` scans the program text looking for an opening bracket. When
    it finds one, it calls `closing` to return the index of the corresponding closing
    bracket. Next, `buildtable` sets the `jump` table to the opening and closing locations
    for rapid lookup during program execution.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`buildtable` 扫描程序文本，寻找左括号。当找到一个左括号时，它调用 `closing` 来返回对应右括号的索引。接着，`buildtable`
    设置 `jump` 表，将左右括号的位置存入表中，以便程序执行期间快速查找。
- en: The `closing` function locates the matching closing bracket by scanning forward
    and incrementing `n` each time a new opening bracket is found. When a closing
    bracket is found, `n` is decremented. When `n` is zero, the closing bracket matching
    the initial opening bracket has been found, so its index is returned.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`closing` 函数通过向前扫描并在每次找到新的左括号时递增 `n`，来定位匹配的右括号。当找到右括号时，`n` 会递减。当 `n` 为零时，表示找到了与最初的左括号匹配的右括号，于是返回该右括号的索引。'
- en: 'BF accepts single-character input that it stores in memory as an ASCII value.
    SNOBOL has a `char` function to return the character associated with a given ASCII
    value; however, it lacks what many languages call `ord`, a function to return
    the ASCII value of a given character. No matter; we’ll make our own:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: BF 接受单字符输入，并将其作为 ASCII 值存储在内存中。SNOBOL 有一个 `char` 函数，可以返回与给定 ASCII 值关联的字符；然而，它缺少许多语言所称的
    `ord` 函数，后者用于返回给定字符的 ASCII 值。没关系，我们自己实现一个：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: SNOBOL includes a special variable, `&alphabet`, which is the full range of
    ASCII characters, [0, 255]. The `ord` function uses pattern matching to locate
    all the characters of this special variable up to the given character, `c`. The
    pattern stores this substring in `v` and the length of the substring is the ASCII
    code for the character.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL 包含一个特殊变量 `&alphabet`，它包含所有的 ASCII 字符范围 [0, 255]。`ord` 函数使用模式匹配来定位此特殊变量中所有字符，直到给定字符
    `c`。该模式将子字符串存储在 `v` 中，并且子字符串的长度就是该字符的 ASCII 代码。
- en: We’re now ready to run the BF program in `prog`. Let’s walk through the main
    portion of the interpreter. We’ll add some debugging abilities to help us later.
    BF is hard, so we’ll take all the help we can get.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好运行 `prog` 中的 BF 程序了。让我们一起走一遍解释器的主要部分。我们将添加一些调试功能，以便后续使用。BF 很难，所以我们会尽可能多地利用帮助。
- en: The main portion of the interpreter is in [Listing 10-4](ch10.xhtml#ch010list4).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器的主要部分在 [Listing 10-4](ch10.xhtml#ch010list4) 中。
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 10-4: The main BF interpreter loop*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-4：主要的 BF 解释器循环*'
- en: '[Listing 10-4](ch10.xhtml#ch010list4) consists of some preliminaries followed
    by a `loop` that moves through the program in `prog`. The preliminaries call `parse`
    to process the input file and `buildtable` to configure the `jump` table. BF expects
    single-character input and output with the console, which SNOBOL supports using
    the given `input` and `output` incantations.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-4](ch10.xhtml#ch010list4)包含一些准备工作，随后是一个`loop`，它在`prog`中移动程序。准备工作调用`parse`来处理输入文件，调用`buildtable`来配置`jump`表。BF期望与控制台进行单字符输入和输出，SNOBOL通过给定的`input`和`output`咒语来支持这一点。'
- en: The current program counter is `pc` and the memory pointer is `mp`. We’ll use
    `gmp` to track the highest memory cell accessed by the program. Doing this simplifies
    dumping relevant memory when the program ends.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的程序计数器是`pc`，内存指针是`mp`。我们将使用`gmp`来跟踪程序访问的最高内存单元。这样做简化了在程序结束时转储相关内存。
- en: The `loop` executes the current instruction depending on its character. Recall
    that `ident` is the SNOBOL predicate to compare two strings. Executing an instruction
    is a jump to the relevant line. Most instructions are a single statement. For
    example, `>` moves the cell pointer to the right (`mp=mp+1`). When incrementing
    the cell pointer, there’s an extra check to see if `gmp` should be updated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop`根据当前指令的字符执行。回想一下，`ident`是SNOBOL谓词，用于比较两个字符串。执行指令时会跳转到相关行。大多数指令都是单一语句。例如，`>`将单元指针向右移动（`mp=mp+1`）。在增加单元指针时，还会额外检查是否需要更新`gmp`。'
- en: SNOBOL has one quirk requiring a bit of extra code. Take a look at `gchar`,
    which reads a single character of input. The `cin` variable reads the character
    and places its ASCII value in `ch`. The problem occurs when the user presses ENTER.
    On Unix systems, this should return the ASCII value 10; however, the SNOBOL interpreter
    returns the ASCII value 13\. So a quick check converts ASCII 13 to ASCII 10 before
    assigning the character to the current memory location (`gchar0`) ➊. Notice that
    each instruction ends with a jump to `cont` to continue processing the next instruction.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SNOBOL有一个怪癖，需要一些额外的代码。看看`gchar`，它读取单个字符的输入。`cin`变量读取字符，并将其ASCII值放入`ch`中。问题出现在用户按下ENTER时。在Unix系统上，这应该返回ASCII值10；然而，SNOBOL解释器返回的是ASCII值13。所以在赋值当前内存位置（`gchar0`）之前，会快速检查并将ASCII
    13转换为ASCII 10 ➊。注意，每个指令都以跳转到`cont`来继续处理下一条指令。
- en: Additionally, observe how opening and closing brackets are handled as `begin`
    and `again`, respectively ➋. Even though there is a single statement for each,
    a bit of explanation is in order. For example, the code for an opening bracket
    is
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，观察如何处理开括号和闭括号，分别作为`begin`和`again` ➋。尽管每个都有单个语句，但还是需要做一些解释。例如，开括号的代码是
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The BF standard says to begin a loop if the currently active memory cell is
    not 0; otherwise, skip the loop. Here, the SNOBOL predicate `eq` will succeed
    if the current memory cell is 0\. In that case, the assignment happens and `pc`
    is set to `jump[pc]`, which is the *end* of the loop that we’re currently considering.
    In contrast, if the memory cell is not 0, `eq` fails and the assignment does not
    happen. Therefore, the interpreter enters the loop as it should. The test in `again`
    is much the same, only the logic is reversed, so we jump to the beginning of the
    loop if the memory cell is not 0.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: BF标准规定，如果当前活动的内存单元不为0，则开始一个循环；否则跳过循环。在这里，SNOBOL谓词`eq`将在当前内存单元为0时成功。这样，赋值会发生，`pc`被设置为`jump[pc]`，即我们当前考虑的循环的*结束*。相反，如果内存单元不为0，`eq`失败，赋值不会发生。因此，解释器会按预期进入循环。`again`中的测试与此类似，只是逻辑相反，因此如果内存单元不为0，我们跳转到循环的开始。
- en: 'Take another look at the statement to decrement the current cell:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看递减当前单元的语句：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the decrement succeeds, flow continues with the next instruction, `s(cont)`.
    However, if `mp` is negative or too large, the statement fails and the interpreter
    jumps to `bad1`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果递减成功，流程继续执行下一条指令`s(cont)`。然而，如果`mp`为负数或过大，语句会失败，解释器会跳转到`bad1`：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This prints an error message and exits. A similar error happens if an opening
    bracket has no matching closing bracket.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印错误信息并退出。如果开括号没有匹配的闭括号，也会发生类似的错误。
- en: If the second command line argument is `dump`, the interpreter will dump the
    final value of all memory locations accessed by the program before exiting. The
    code for this is in [Listing 10-5](ch10.xhtml#ch010list5).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个命令行参数是`dump`，解释器将在退出前转储程序访问的所有内存位置的最终值。相关代码见[列表 10-5](ch10.xhtml#ch010list5)。
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 10-5: Dumping memory*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-5：转储内存*'
- en: Memory values are dumped, one per line. If the value is in the range 31 < *v*
    < 127, the corresponding character is displayed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 内存值被逐行转储。如果值在 31 < *v* < 127 的范围内，则显示相应的字符。
- en: The BF interpreter is now complete. Let’s test it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: BF 解释器现在完成了。让我们测试一下。
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The memory dump shows that cells 0 through 6 were used at some point in the
    program, and that the program ended with the memory pointer looking at cell 6\.
    Knowing which memory cell is active is critical to successful BF programming.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 内存转储显示程序中某个时刻使用了 0 到 6 号单元，并且程序结束时内存指针指向了 6 号单元。知道哪个内存单元是活动的，对成功的 BF 编程至关重要。
- en: Our implementation appears to work. Now, let’s do stuff with it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现看起来可以工作了。现在，让我们用它做些事情。
- en: '**BF in Action**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**BF 实践**'
- en: Let’s explore BF with worked examples. I encourage you to consider the other
    examples included on the GitHub site. However, the more complex ones like *mandelbrot.b*
    and *hanoi.b* are the output of programs that generate BF code. They were not
    written by hand.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实际例子来探索 BF。我鼓励你考虑 GitHub 网站上包含的其他示例。然而，像 *mandelbrot.b* 和 *hanoi.b* 这样的复杂例子是由生成
    BF 代码的程序输出的，它们不是手工编写的。
- en: We’ll start with some basic examples and then develop more advanced examples
    that require a bit of thought. For example, we’ll end with a program to multiply
    two numbers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一些基本的例子开始，然后发展出需要一点思考的更高级的例子。例如，我们将以一个程序来结束，它用于乘以两个数字。
- en: '***Baby Steps***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***婴儿步骤***'
- en: 'Consider the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下代码：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It increments cell 0 five times, then starts a loop: `[-]`. Incrementing five
    times is obvious, so let’s work through the loop to see what it does. The first
    command is `[`. It checks to see whether the current cell is 0\. In this case,
    the cell is 5 and not 0, so `[` succeeds and the loop begins.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它将单元 0 增加 5 次，然后开始一个循环：`[-]`。增加五次是显而易见的，所以让我们通过循环看它做了什么。第一个命令是 `[ `。它检查当前单元是否为
    0。在这种情况下，单元值是 5，而不是 0，因此 `[` 成功，循环开始。
- en: The next instruction, `-`, decrements the value in the current memory cell (cell
    0), so the value is now 4\. The closing bracket, `]`, asks if cell 0 is 0, which
    it isn’t, so it jumps to the beginning of the loop. Note that the beginning of
    the loop isn’t `[`, but the first instruction after it (`-`). Cell 0 is decremented
    again and `]` runs again. When the value of cell 0 is 0, `]` will fail and the
    program will end. Therefore, the snippet of code above zeroes a cell. You’ll see
    `[-]` in many BF programs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个指令 `-`，减少当前内存单元（单元 0）中的值，因此值现在是 4。闭括号 `]` 会检查单元 0 是否为 0，显然不是，所以它跳回循环的开始。注意，循环的开始不是
    `[ `，而是它后面的第一个指令（`-`）。单元 0 再次递减，` ]` 再次执行。当单元 0 的值为 0 时，` ]` 会失败，程序将结束。因此，上面的代码片段将单元清零。你会在许多
    BF 程序中看到 `[-]`。
- en: 'Now that we have a basic loop under our belt, let’s contemplate the following
    bit of code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了一个基本的循环，让我们思考以下这段代码：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What do you think it might be doing? The code itself is in *cat.b*. Let’s run
    it and see what it produces. To run it, use this command line:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为它可能在做什么？代码本身在 *cat.b* 中。让我们运行它，看看它会输出什么。要运行它，请使用以下命令行：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Do you see the text of *bf.sno*? The filename is a clue, of course, but this
    simple program acts like the Unix `cat` command to display the contents of a file.
    Let’s add comments to the code to explain what is happening.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到 *bf.sno* 的文本了吗？文件名当然是个线索，但这个简单的程序就像 Unix 中的 `cat` 命令一样，用来显示文件的内容。让我们给代码加上注释，以解释发生了什么。
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Reading a character, printing, and looping until there are no more characters
    to read is a good idea in this case, but what’s with `+` and `-`? These extra
    commands handle the case where a 0 character has been read. They are present to
    deal with how different systems process end-of-file (EOF). For example, this version
    of the program works nicely with our SNOBOL interpreter
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 读取字符、打印并循环，直到没有更多字符可读，这是一个不错的主意，但 `+` 和 `-` 是怎么回事呢？这些额外的命令处理了读取到 0 字符的情况。它们的存在是为了应对不同系统处理文件结束符（EOF）的方式。例如，这个版本的程序与我们的
    SNOBOL 解释器配合得很好。
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: but hangs at EOF when using the C interpreter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但在使用 C 解释器时，在 EOF 处会挂起。
- en: 'Let’s look at another loop example. Honestly, all our examples will be loop
    examples, as that’s all BF has to offer that isn’t quickly boring. This example
    is in *countdown0.b*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个循环的例子。老实说，所有我们的例子都会是循环例子，因为这是 BF 所能提供的唯一不容易让人感到无聊的内容。这个例子在 *countdown0.b*
    中：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It’s only slightly more interesting than our first example. Beyond counting
    down, we also print the value of cell 0\. However, BF’s print (`.`) expects an
    ASCII character, so this example won’t print anything visible, only a set of control
    characters. We can see this by using the Unix `xxd` command to dump binary files:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它比我们的第一个示例稍微有趣一些。除了倒计时，我们还打印了单元格 0 的值。然而，BF 的打印（`.`）期望的是一个 ASCII 字符，所以这个示例不会打印任何可见的内容，只有一组控制字符。我们可以使用
    Unix 的 `xxd` 命令来查看二进制文件：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `xxd` command dumps binary data as hexadecimal values. Looking at the output
    you’ll see the countdown (09, 08, 07, . . . , 00). To get a countdown we must
    convert the current value of cell 0 to a digit. The offset between a digit value
    and the ASCII code for the digit is 48, so we must add 48 before printing and
    subtract 48 afterward.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`xxd` 命令将二进制数据转储为十六进制值。查看输出，你会看到倒计时（09, 08, 07, ... , 00）。为了得到倒计时，我们必须将单元格
    0 的当前值转换为数字。数字值和该数字的 ASCII 码之间的偏移量是 48，所以我们在打印之前必须加上 48，打印后再减去 48。'
- en: '[Listing 10-6](ch10.xhtml#ch010list6) shows us *countdown1.b*. We’ve included
    comments to explain the code.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-6](ch10.xhtml#ch010list6) 向我们展示了 *countdown1.b*。我们已包含注释来解释代码。'
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 10-6: Countdown with ASCII output*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-6：带有 ASCII 输出的倒计时*'
- en: Running [Listing 10-6](ch10.xhtml#ch010list6) produces a countdown as output
    (9, 8, 7, . . . , 0). To output newline repeatedly, it’s easiest to store it somewhere,
    so we set cell 0 to 10\. Next, `>` moves the cell pointer to look at cell 1\.
    As you write BF code, pay very close attention to where the cell pointer is looking.
    Cell 1 is set to 10 as well, but in this case, it is the value to count down.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 [清单 10-6](ch10.xhtml#ch010list6) 会产生倒计时输出（9, 8, 7, ... , 0）。为了重复输出换行，最简单的方法是将它存储在某个地方，所以我们将单元格
    0 设置为 10。接下来，`>` 将单元格指针移到单元格 1。编写 BF 代码时，必须非常注意单元格指针所指向的位置。单元格 1 也设置为 10，但在这种情况下，它是倒计时的值。
- en: The loop begins by incrementing the value in cell 0 with 48 `+` commands. This
    is boring but quick to implement. The current loop count is now a valid ASCII
    digit, so we print it and subtract 48 to get back to the actual count. The bottom
    of the loop looks at cell 0, which is always 10, and prints it to get the newline
    character. The code then looks again at cell 1, where our count lives, and loops
    until 0.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 循环通过使用 48 个 `+` 命令来递增单元格 0 的值。这很无聊，但实现起来很快。当前的循环计数现在是一个有效的 ASCII 数字，因此我们打印它，并减去
    48 以恢复到实际的计数。循环的底部查看单元格 0，它始终为 10，并打印它来获取换行符。然后代码再次查看单元格 1，我们的计数存储在这里，并循环直到 0。
- en: '***Bunches O’Bits***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***大量的比特***'
- en: '*Bit twiddling*, meaning fiddling around with the bits of a byte, is the goal
    of this section. Here we’ll implement two examples. The first calculates the ones’
    complement of a byte. The second calculates the even parity bit. Don’t be concerned
    if these terms are new to you; I’ll clarify as we go.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*比特操作*，即操作字节中的比特，是本节的目标。我们将在这里实现两个示例。第一个计算字节的反码。第二个计算偶校验位。如果这些术语对你来说是新的，不用担心；我们会在过程中解释。'
- en: '**A Complimentary Complement**'
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**补充的补码**'
- en: Internally, computers represent integers as a set number of bits, that is, as
    a base-2 number. One method for encoding negative numbers is to use the *ones’
    complement*, where each bit is the opposite of what it would be for a positive
    value. For example, if a number is 00001101[2] = 11, then 11110010[2] = *–*11
    where each 1 is now a 0 and vice versa. In this encoding, the leading bit will
    be one when the number should be interpreted as a negative value. Our goal is
    to write a BF program to calculate the ones’ complement of an input byte. The
    byte will be entered as a string of eight characters (each 0 or 1).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，计算机将整数表示为固定数量的位，即以二进制表示。编码负数的一种方法是使用 *反码*，即每一位的值与正数值的相反。例如，如果一个数字是 00001101[2]
    = 11，那么 11110010[2] = *–*11，其中每个 1 变成 0，反之亦然。在这种编码中，当数字应该被解释为负值时，最高位为 1。我们的目标是编写一个
    BF 程序来计算输入字节的反码。字节将作为一串八个字符（每个字符是 0 或 1）输入。
- en: Let’s think about this task for a bit (or eight). We know we’ll likely want
    a loop to read eight bits. After reading a bit, we need to subtract 48 to map
    the ASCII value read to its actual value (0 or 1). Once we have the actual value,
    we then output a 0 if the value is 1 or a 1 if the value is 0\. In typical languages,
    a simple `if` statement would do the trick. Of course, we’re not working with
    an ordinary language, but rather in the strange world of BF.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下这个任务（或者说八个）。我们知道，可能需要一个循环来读取八个比特。读取完一个比特后，我们需要减去48，以将读取的ASCII值映射到实际值（0或1）。一旦得到实际值，如果值是1，我们输出0；如果值是0，我们输出1。在常见编程语言中，一个简单的`if`语句就能解决问题。当然，我们并不是在使用普通的语言，而是在BF的奇特世界中。
- en: A loop to read a byte’s worth of bits could be written as
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用来读取一个字节比特的循环可以写成如下形式：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this code, we first set cell 0 to 8 and then start a loop. The loop decrements
    cell 0, moves to cell 1, and inputs something. It then moves the memory pointer
    back to cell 0 and loops if the count isn’t 0\. This reads eight characters and
    then exits. Adding a period after the comma echoes the input. Of course, we need
    a 0 or 1 in memory, not the ASCII code for 0 or 5, so somewhere we’ll have to
    subtract 48\. We’ll use a sequence of 48 `-` instructions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先将单元格0设置为8，然后开始一个循环。该循环递减单元格0，移到单元格1并输入内容。然后它将内存指针移回单元格0，并在计数不为0时继续循环。这个循环读取八个字符后退出。在逗号后加一个句号可以回显输入内容。当然，我们需要在内存中存储0或1，而不是ASCII码0或5，因此我们需要在某个地方减去48。我们将使用一系列48个`-`指令。
- en: All right, we have the input bit, but how do we decide whether we should output
    a 0 or a 1? If the bit is 1, we could enter a loop that is otherwise skipped if
    the bit is 0\. How can we use that? Well, we might be able to set another memory
    location to 1, read the input bit, and if it is 1, decrement the preset memory
    location. If we do that, we’ll be in business. However, before we go too far,
    it’s a good idea to make a map of how we are using BF memory. So far, we have
    the setup
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经得到了输入比特，但如何决定是否输出0或1呢？如果比特是1，我们可以进入一个循环，如果比特是0，则跳过该循环。我们如何利用这一点呢？其实，我们可以设置另一个内存位置为1，读取输入的比特，如果是1，就递减该预设的内存位置。如果这样做，我们就可以成功了。不过，在继续之前，最好先绘制一下我们如何使用BF内存的地图。到目前为止，我们的设置如下
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: where our loop counter is in cell 0, the bit entered by the user is in cell
    1, cell 2 holds a 1, and the memory pointer is looking at cell 1.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们的循环计数器在单元格0中，用户输入的位在单元格1中，单元格2存储着1，内存指针指向单元格1。
- en: 'If the user’s bit is 1, we want to enter a loop to decrement cell 2\. If the
    bit is 0, the loop will be skipped and cell 2 will remain 1\. Then, we print cell
    2 and we have it: a 1 is changed into a 0, and a 0 is changed into a 1\. We then
    move the memory pointer back to cell 0 to decrement the bit counter and repeat
    until we’re done.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户的位是1，我们希望进入一个循环来递减单元格2。如果位是0，则跳过循环，单元格2保持为1。然后，我们打印单元格2，得到的结果是：1变为0，0变为1。接着，我们将内存指针移回单元格0，递减位计数器，并重复直到完成。
- en: '[Listing 10-7](ch10.xhtml#ch010list7) shows *ones.b*, which implements our
    algorithm. Let’s walk through the code to see that it does what I claim.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10-7](ch10.xhtml#ch010list7)展示了*ones.b*，它实现了我们的算法。让我们一起分析这段代码，看看它是否按照我所说的那样执行。'
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 10-7: Ones’ complement*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-7：反码*'
- en: First, the outermost loop uses cell 0 to count down from 8\. Inside this loop,
    after decrementing the count, the memory pointer is moved to cell 2, which is
    then incremented. We know that cell 2 was initially 0, so it must be 1 now. We
    then move back to cell 1 to get the user’s input, which we’ll assume is a 0 or
    1\. This much is `->>+<,` if the comments are removed. Look at the commands until
    you are sure you follow what’s going on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最外层的循环使用单元格0从8开始递减。在这个循环内部，递减计数后，内存指针移到单元格2，然后对其进行递增。我们知道，单元格2最初是0，所以现在它应该是1。接着，我们返回到单元格1以获取用户的输入，我们假设输入是0或1。去掉注释后，这部分是`->>+<,`。看看这些指令，直到你完全明白它在做什么。
- en: 'The next block of code is an uninspired sequence of 48 `-` commands to change
    the user’s input into either a 0 or 1\. Recall that we’re looking at cell 1\.
    At this point, we have memory as we want it: cell 1 is 0 or 1 and cell 2 is 1\.
    The next set of commands are key to the entire program: `[->-<]>`. The small loop
    (`[->-<]`) executes if the user’s bit is 1 because we are looking at cell 1 and
    it isn’t 0; therefore, `[` enters the loop. Cell 1 is immediately decremented
    to make it 0 because we only want the code in the loop to execute once. Next,
    `>` looks at cell 2 and `-` decrements it to change it from 1 to 0\. Lastly, `<`
    looks again at cell 1, which is now 0, so the loop exits, and the final `>` executes
    to look at cell 2\. If the user’s bit is a 0, then `[` fails, skipping the entire
    loop and moving directly to the final `>` to also look at cell 2\. At this point,
    cell 2 is the focus, and it contains a 1 if the input bit was a 0 or a 0 if the
    input bit was a 1\. The next block of 48 `+` commands increments the value in
    cell 2 to get the corresponding ASCII code and `.` prints it.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码是一个无创意的 48 个 `-` 命令序列，将用户的输入转化为 0 或 1。回想一下，我们关注的是第 1 号单元。此时，内存状态是我们想要的：第
    1 号单元为 0 或 1，第 2 号单元为 1。接下来的命令是程序的关键：`[->-<]>`。小循环 (`[->-<]`) 在用户的位为 1 时执行，因为我们查看的是第
    1 号单元，它不是 0；因此，`[` 进入循环。第 1 号单元立即递减为 0，因为我们只希望循环中的代码执行一次。接着，`>` 查看第 2 号单元，`-`
    将其递减，从 1 改为 0。最后，`<` 再次查看第 1 号单元，此时它是 0，循环退出，最后的 `>` 执行，查看第 2 号单元。如果用户的位是 0，那么
    `[` 失败，跳过整个循环，直接执行最后的 `>`，同样查看第 2 号单元。此时，第 2 号单元为焦点，如果输入位是 0，它包含 1，如果输入位是 1，它包含
    0。接下来的 48 个 `+` 命令递增第 2 号单元的值，得到相应的 ASCII 码，并通过 `.` 打印出来。
- en: What does `[-]` do? As we saw above, `[-]` is the BF idiom to zero a memory
    location. This is necessary to make sure cell 2 is 0 when the outer loop comes
    around for the next input bit. Right now, cell 2 is either 48 or 49\. The final
    two `<<` instructions move focus back to cell 0, the loop counter. The outer `]`
    then loops if cell 0 isn’t 0\. When it is, the final line, `++++++++++.`, outputs
    ASCII 10, a newline, and the program exits.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`[-]` 是做什么的？正如我们上面所看到的，`[-]` 是 BF 中清空内存位置的惯用法。这是必要的，以确保在外部循环处理下一个输入位时，第 2 号单元为
    0。现在，第 2 号单元是 48 或 49。最后两个 `<<` 指令将焦点移回到第 0 号单元，也就是循环计数器。如果第 0 号单元不是 0，则外部的 `]`
    会使循环继续。当它是 0 时，最后一行 `++++++++++.` 会输出 ASCII 10，即换行符，程序退出。'
- en: 'Whew! Let’s see [Listing 10-7](ch10.xhtml#ch010list7) in action. Run *ones.b*
    like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！让我们看看 [Listing 10-7](ch10.xhtml#ch010list7) 是如何运作的。像这样运行 *ones.b*：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `echo` command is a convenient way to send input to a program without typing
    it directly. Notice that the input is 11 as we saw it earlier, 00001101[2]. The
    output is 11110010[2], which is –11 in ones’ complement, as we wanted. The memory
    dump tells us we end the program looking at cell 0, which contains 10 for the
    final newline. The other two cells used by the program are both 0.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo` 命令是一种方便的方式，可以将输入发送给程序，而无需直接输入。注意，我们看到的输入是 11，如之前所见，00001101[2]。输出是 11110010[2]，这就是我们想要的
    –11 的反码表示。内存转储告诉我们，程序结束时会查看第 0 号单元，其中包含 10，表示最终的换行符。程序使用的另外两个单元都是 0。'
- en: One note before moving on. [Listing 10-7](ch10.xhtml#ch010list7) excludes a
    comment block at the top of *ones.b*. The BF interpreter ignores non-command characters;
    however, the comments must not include any command characters. That gets a bit
    annoying at times. The comments at the top of *ones.b* are enclosed in brackets
    (`[` and `]`). This means the entire comment block (at least the characters that
    are valid BF commands) is a loop. But this doesn’t matter. The comment block is
    the first loop in the program, and we know cell 0 is always 0, so the loop will
    never execute and we are free to enter whatever text we want in the comments.
    This was not my idea, but it is another illustration of the creativity present
    in the esolang community.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，有一点需要注意。[Listing 10-7](ch10.xhtml#ch010list7) 中排除了 *ones.b* 顶部的注释块。BF
    解释器会忽略非命令字符；然而，注释中不能包含任何命令字符。这样有时会有点麻烦。*ones.b* 顶部的注释被括号（`[` 和 `]`）包围。这意味着整个注释块（至少是有效的
    BF 命令字符）是一个循环。但这并不重要。注释块是程序中的第一个循环，而我们知道第 0 号单元总是 0，因此这个循环永远不会执行，我们可以在注释中自由输入任何文本。这不是我的想法，但它再次展示了
    esolang 社区的创造力。
- en: '**Achieving Parity**'
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**实现奇偶校验**'
- en: Serial communication protocols sometimes use a *parity bit*, an extra bit transmitted
    with the data that makes it easier to detect transmission errors. For example,
    if the data fits in seven bits, as standard ASCII characters do, then an eighth
    bit can be added to make the number of one bits (bits with a value of 1) in the
    8-bit byte even. This is known as even parity. If the received byte does not have
    an even number of one bits, the receiver immediately knows there is an error and
    can request the byte again. A single parity bit can capture a single-bit error,
    which is sufficient in most cases.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 串行通信协议有时会使用 *校验位*，这是一个额外的位，随数据一起传输，可以更容易地检测传输错误。例如，如果数据适合七个比特（如标准的 ASCII 字符），则可以添加第八个比特，以使
    8 位字节中的 1 的个数（值为 1 的比特）为偶数。这就是所谓的偶校验。如果接收到的字节中 1 的个数不是偶数，接收方立刻知道有错误，并可以请求重新发送该字节。一个校验位可以检测到单比特错误，这在大多数情况下是足够的。
- en: 'Our mission is to write a BF program to accept seven input bits and output
    the proper even parity bit. We’ll input bits as a sequence of seven ASCII characters
    as before and then output either ASCII 0 or ASCII 1 to make the number of one
    bits even. The following are some examples of bytes with parity bits:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是编写一个 BF 程序，接受七个输入位并输出正确的偶校验位。我们将像之前一样输入七个 ASCII 字符的位序列，然后输出 ASCII 0 或
    ASCII 1，使得 1 的个数为偶数。以下是一些带有校验位的字节示例：
- en: '| 0000000 | → | 0000000**0** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 0000000 | → | 0000000**0** |'
- en: '| 0000010 | → | 0000010**1** |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 0000010 | → | 0000010**1** |'
- en: '| 0011001 | → | 0011001**1** |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 0011001 | → | 0011001**1** |'
- en: '| 1111111 | → | 1111111**1** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 1111111 | → | 1111111**1** |'
- en: The bold output bit ensures that every byte has an even number of 1s.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出位**确保每个字节都有偶数个 1。'
- en: How should we go about getting BF to do this for us? There are likely multiple
    approaches, but the approach we’ll use here is first to tally the number of 1s
    present in the seven inputs. Then we’ll decide which bit to output based on this
    tally. As with *ones.b* above, we need an outer loop to read the ASCII bits and
    subtract 48\. To tally the one bits, we’ll increment a memory cell each time the
    bit is a 1.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何让 BF 为我们做这件事呢？可能有多种方法，但我们在这里使用的方法是首先统计七个输入中的 1 的个数。然后，根据这个计数决定输出哪个比特。与上面的
    *ones.b* 一样，我们需要一个外循环来读取 ASCII 比特并减去 48。为了统计 1 的个数，每当遇到 1 时，我们就递增一个内存单元。
- en: '[Listing 10-8](ch10.xhtml#ch010list8) presents a loop to read seven bits and
    tally the number of one bits.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-8](ch10.xhtml#ch010list8) 展示了一个循环，用于读取七个比特并统计 1 的个数。'
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 10-8: Adding the input bits*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-8：添加输入位*'
- en: As always, tracking memory use is essential. In this case, cell 0 holds the
    bits read counter, cell 1 is the input bit, and cell 2 the tally of one bits.
    The first part of the loop is `>,.`, which moves to cell 1, reads the input bit,
    and echoes it. Next comes a block of 48 `-` commands to turn the ASCII character
    code into a 0 or 1.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，跟踪内存使用是至关重要的。在这种情况下，单元格 0 存储读取的比特计数器，单元格 1 存储输入比特，单元格 2 存储 1 的个数。循环的第一部分是
    `>,.`，它移动到单元格 1，读取输入比特并回显。接下来是一段由 48 个 `-` 命令组成的块，将 ASCII 字符代码转换为 0 或 1。
- en: If the bit is a 1, `[` begins the inner loop. The loop body, `->+<`, decrements
    cell 1, looks at cell 2 and increments it, and looks again at cell 1\. Because
    cell 1 is now 0, `]` fails and the loop ends. If the input bit is 0, `[` skips
    ahead to `<-`. In both cases, the memory pointer is looking at cell 1, so `<`
    looks at cell 0, which `-` then decrements. The final `]` fires to repeat the
    loop six more times. When the loop ends, cell 2 contains a tally of the number
    of one bits read and the memory pointer is looking at cell 0\. It’s important
    to note that cell 0 and cell 1 are both 0 when the outer loop exits.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入位是 1，`[` 开始内循环。循环体 `->+<` 会递减单元格 1，查看单元格 2 并递增它，然后再次查看单元格 1。由于单元格 1 此时为
    0，`]` 失败，循环结束。如果输入位是 0，`[` 会跳过到 `<-`。在这两种情况下，内存指针都指向单元格 1，因此 `<` 会指向单元格 0，然后 `-`
    会递减它。最终的 `]` 会触发，循环重复执行六次。当循环结束时，单元格 2 存储了读取的 1 的个数，内存指针指向单元格 0。需要注意的是，当外循环退出时，单元格
    0 和单元格 1 都是 0。
- en: Cell 2 contains the number of one bits in the input. If this number is odd,
    the output bit should be 1\. Otherwise, it should be 0\. How do we tell if cell
    2 is even or odd? Here’s where things get a bit tricky. Our solution is in [Listing
    10-9](ch10.xhtml#ch010list9), but we must walk through it to understand it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格 2 包含输入中 1 的个数。如果这个数字是奇数，输出位应为 1。否则，输出位应为 0。我们如何判断单元格 2 是奇数还是偶数呢？这里有点复杂。我们的解决方案在
    [清单 10-9](ch10.xhtml#ch010list9) 中，但我们必须逐步理解它。
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 10-9: Using the ones tally to decide the parity bit*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-9：使用 1 的计数决定校验位*'
- en: In essence, when the outer loop of [Listing 10-9](ch10.xhtml#ch010list9) ends,
    the memory pointer will be looking at cell 0 if the output bit should be 1 or
    cell 2 if the output bit should be 0\. Additionally, cell 3 will be 1 if we end
    at cell 0 and cell 5 will be its default value of 0.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，当[清单 10-9](ch10.xhtml#ch010list9)的外层循环结束时，内存指针会指向单元格0（如果输出位应该是1）或者单元格2（如果输出位应该是0）。此外，如果我们在单元格0结束，单元格3将为1，而单元格5将保持默认值0。
- en: The code before the main loop of [Listing 10-9](ch10.xhtml#ch010list9) is simple
    enough. Move the memory pointer twice to look at cell 2, which has the one bits
    tally. If this tally is 0, the loop is skipped by `[` and we move to the final
    bit of code with the memory pointer looking at cell 2\. We’ll get to the final
    bit of code soon.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-9](ch10.xhtml#ch010list9)的主循环前的代码非常简单。将内存指针移动两次，查看单元格2，它存储的是1的计数。如果这个计数为0，循环将被`[`跳过，我们将进入代码的最后部分，内存指针指向单元格2。我们很快就会看到代码的最后部分。'
- en: If the tally in cell 2 isn’t 0, we enter the main loop of [Listing 10-9](ch10.xhtml#ch010list9).
    The body of this loop has two inner loops, one after the other. The body of the
    first inner loop is `->+>`. It subtracts 1 from cell 2, looks at and increments
    cell 3, and then looks at cell 4, which is always 0\. Because cell 4 is 0, `]`
    exits the loop, meaning the loop never actually loops. Notice that when the loop
    exits, the memory pointer is looking at cell 4 and cell 3 is 1.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元格2中的计数不为0，我们将进入[清单 10-9](ch10.xhtml#ch010list9)的主循环。这个循环体包含两个内层循环，一个接一个。第一个内层循环的主体是`->+>`。它从单元格2中减去1，查看并增加单元格3的值，然后查看单元格4，它的值总是0。由于单元格4为0，`]`将退出循环，这意味着循环实际上并没有执行。请注意，当循环退出时，内存指针指向单元格4，而单元格3的值为1。
- en: If we assume that cell 2 was initially 1 ➊, cell 2 is now 0, cell 3 is 1, and
    we are looking at cell 4, which is also 0\. The `<<` between the inner loops moves
    back to cell 2, which, as it is 0, skips the second inner loop and hits the final
    `<<` to move back from cell 2 to cell 0\. Because cell 0 is 0, the outer loop
    exits, meaning we are looking at cell 0 and cell 3 is still 1.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们最初将单元格2设置为1 ➊，现在单元格2为0，单元格3为1，而我们正在查看单元格4，它的值也是0。内层循环之间的`<<`操作将指针移回单元格2，由于它的值是0，跳过第二个内层循环，并执行最后的`<<`将指针从单元格2移回单元格0。由于单元格0为0，外层循环退出，这意味着我们正在查看单元格0，而单元格3仍然是1。
- en: This situation happens every time cell 2 contains an odd value. What if cell
    2 contains 2? After the first inner loop of [Listing 10-9](ch10.xhtml#ch010list9),
    cell 2 contains 1, cell 3 contains 1, and we are looking at cell 2\. Therefore,
    the second inner loop fires to decrement cell 2 and cell 3, making them both 0\.
    The loop then moves to cell 4, which is always 0, exits, and moves back to cell
    2, which is now also 0\. The outer loop then exits, and we are looking at cell
    2 this time, not cell 0\. Whenever cell 2 is initially even, both inner loops
    will repeatedly fire to make cell 2 0\. Cell 3 is also decremented by the second
    inner loop to make sure it only ever contains a 1.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每当单元格2包含奇数值时，就会发生这种情况。如果单元格2包含2呢？在[清单 10-9](ch10.xhtml#ch010list9)的第一个内层循环后，单元格2的值为1，单元格3的值为1，而我们正在查看单元格2。因此，第二个内层循环被触发，减少单元格2和单元格3的值，使它们都变为0。然后，循环移动到单元格4，它的值总是0，退出后返回到单元格2，此时单元格2也变为0。外层循环随之退出，我们这次查看的是单元格2，而不是单元格0。每当单元格2最初为偶数时，两个内层循环将反复执行，将单元格2置为0。第二个内层循环还会递减单元格3的值，以确保它始终为1。
- en: We’re almost done. The code in [Listing 10-9](ch10.xhtml#ch010list9) ends, leaving
    BF in one of two states. If the tally in cell 2 was even, we’re looking at cell
    2\. If the tally is odd, we’re looking at cell 0 and cell 3 is 1\. To output the
    proper bit, we need the code in [Listing 10-10](ch10.xhtml#ch010list10).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快完成了。[清单 10-9](ch10.xhtml#ch010list9)中的代码执行完毕，BF将处于两种状态之一。如果单元格2中的计数是偶数，我们正在查看单元格2；如果计数是奇数，我们正在查看单元格0，且单元格3为1。为了输出正确的位，我们需要[清单
    10-10](ch10.xhtml#ch010list10)中的代码。
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 10-10: Printing the proper parity bit*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-10：打印正确的奇偶校验位*'
- en: We use `>>>` to move to either cell 3 or cell 5\. Cell 3 would be 1 if we ended
    at cell 0 and that’s the value we want to output. If we ended at cell 2, we move
    to cell 5, which is initialized to be 0 and is also the value we want. All that
    remains is to add 48 to convert the value to the ASCII character code for either
    1 or 0, print it, and then move to either cell 4 or cell 6, both of which are
    initially 0, to output the final newline character.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`>>>`将指针移动到单元格3或单元格5。如果我们在单元格0结束，单元格3将为1，而这是我们想要输出的值。如果我们在单元格2结束，则移动到单元格5，它的初始值为0，这也是我们想要的值。剩下的就是加上48，将该值转换为ASCII字符代码（表示1或0），打印出来，然后将指针移动到单元格4或单元格6，它们最初的值都是0，输出最终的换行符。
- en: 'Let’s try *parity.b* with the example inputs above:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用上面的示例输入来运行 *parity.b*：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output is as expected, meaning that *parity.b* works. You’ll get the same
    results if you use the SNOBOL interpreter as well.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如预期所示，这意味着 *parity.b* 起作用。如果使用 SNOBOL 解释器，你也会得到相同的结果。
- en: 'Now, let’s work on our final BF example: multiplication.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理最后一个 BF 示例：乘法。
- en: '***Multiplicative Multiplicity***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***乘法的倍增性***'
- en: Multiplication is repeated addition. Let’s use that fact to write a BF program
    to accept two single-digit numbers and compute their product. We’ll write two
    versions. The first version implements multiplication but leaves the product in
    memory. This is unsatisfying, so the second version uses freely available code
    from *[https://esolangs.org/](https://esolangs.org/)* to output the product as
    ASCII characters. The full source code for both examples is in *mult.b* and *mult2.b*,
    respectively.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法是重复加法。让我们利用这一点编写一个 BF 程序，接受两个单一数字并计算它们的乘积。我们将编写两个版本。第一个版本实现了乘法，但将乘积保存在内存中。这让人不太满意，因此第二个版本使用来自
    *[https://esolangs.org/](https://esolangs.org/)* 的公开代码，将乘积作为 ASCII 字符输出。两个示例的完整源代码分别在
    *mult.b* 和 *mult2.b* 中。
- en: We require two inputs, which we’ll store in cells 0 and 1\. We’ll use cells
    2 and 3 while multiplying and place the final product in cell 3\. Reading the
    input characters is straightforward; see [Listing 10-11](ch10.xhtml#ch010list11).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个输入，它们将存储在单元格 0 和 1 中。我们将在乘法过程中使用单元格 2 和 3，并将最终结果存储在单元格 3 中。读取输入字符是直接的；请参见
    [清单 10-11](ch10.xhtml#ch010list11)。
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 10-11: Reading and printing the inputs*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-11：读取和打印输入*'
- en: The first character is read and converted to its numeric value. Then cell 1
    is used to output `*` before reading the second digit.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符被读取并转换为其数字值。然后单元格 1 用来输出 `*`，再读取第二个数字。
- en: To multiply, we must increment a memory location as many times as the value
    in cell 1 dictates (that is, increment it cell 1 times), and repeat until cell
    0 is 0\. For example, if cell 0 is 5 and cell 1 is 4, the algorithm is to calculate
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行乘法，我们必须根据单元格 1 中的值递增一个内存位置（也就是说，递增它单元格 1 次），并重复直到单元格 0 为 0。例如，如果单元格 0 为
    5，单元格 1 为 4，那么算法将计算
- en: 5 × 4 = 4 + 4 + 4 + 4 + 4 = 20
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 5 × 4 = 4 + 4 + 4 + 4 + 4 = 20
- en: which we might write in a language like Python as
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会用类似 Python 这样的语言来写：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s duplicate this code in BF. However, we have a minor issue. We need two
    loops, an outer loop running until cell 0 is 0, and an inner loop to increment
    cell 3 by cell 1 times. Recall that BF loops are destructive. For example, if
    we write `++++[.-]`, we’ll print the current value of cell 0 four times, from
    4 down to 1\. When the loop exits, cell 0 is 0, meaning its original value has
    been lost. Thus, we must preserve the value of cell 1 to use it again on the next
    pass.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 BF 中复制这段代码。不过，我们有一个小问题。我们需要两个循环，一个外部循环在单元格 0 为 0 时停止，一个内部循环将单元格 3 递增单元格
    1 次。回想一下，BF 循环是破坏性的。例如，如果我们写 `++++[.-]`，我们将打印单元格 0 的当前值四次，从 4 到 1。当循环退出时，单元格 0
    变为 0，意味着它的原始值已经丢失。因此，我们必须保留单元格 1 的值，以便在下一次循环时使用。
- en: '[Listing 10-12](ch10.xhtml#ch010list12) shows us the multiplication algorithm.
    Let’s see how it preserves the inner loop counter.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-12](ch10.xhtml#ch010list12) 展示了乘法算法。让我们看看它如何保持内循环计数器。'
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 10-12: Multiplying the two digits*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-12：乘法运算*'
- en: The first `<` moves us back to cell 0 as the code in [Listing 10-11](ch10.xhtml#ch010list11)
    ends with the memory pointer looking at cell 1\. Cell 0 isn’t 0, generally, so
    the outer loop begins, and cell 0 is immediately decremented. Next, `>` moves
    to cell 1, and the first inner loop begins if cell 1 isn’t 0\. Cell 1 is also
    immediately decremented.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `<` 将我们移动回单元格 0，因为 [清单 10-11](ch10.xhtml#ch010list11) 中的代码结束时内存指针指向单元格 1。单元格
    0 通常不为 0，因此外部循环开始，单元格 0 立即递减。接下来，`>` 移动到单元格 1，如果单元格 1 不为 0，则第一个内循环开始。单元格 1 也立即递减。
- en: 'The body of the first inner loop is `>+>+<<`. The `>+` instructions move to
    cell 2 and increment it. The following `>+` does the same to cell 3\. Lastly,
    `<<` moves back to cell 1 so `]` can decide whether to continue the loop or not.
    When the loop exits, memory looks like this, assuming the user entered `5` and
    `4`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个内循环的代码是 `>+>+<<`。`>+` 指令将指针移动到单元格 2 并递增它。接下来的 `>+` 对单元格 3 执行相同操作。最后，`<<`
    移动回单元格 1，以便 `]` 可以决定是否继续循环。当循环退出时，内存状态如下，假设用户输入的是 `5` 和 `4`：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Recall that cell 3 holds our product. It’s currently 4 because the first inner
    loop ran four times. We now must restore cell 1\. That’s why the loop incremented
    both cell 2 and cell 3\. We use cell 3 for the product and we can use cell 2 to
    restore the inner loop counter. That’s what `>[-<+>]` does; it decrements cell
    2 while incrementing cell 1\. The final `<<` ensures that the outer loop’s `]`
    instruction is looking at cell 0.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，单元格 3 存储了我们的乘积。现在它是 4，因为第一个内部循环运行了四次。现在我们必须恢复单元格 1。这就是为什么循环同时递增单元格 2 和单元格
    3。我们使用单元格 3 存储乘积，而可以用单元格 2 恢复内部循环计数器。这就是 `>[-<+>]` 的作用；它在递减单元格 2 的同时递增单元格 1。最终的
    `<<` 确保外部循环的 `]` 指令查看的是单元格 0。
- en: Each pass through the outer loop adds cell 1 to cell 3, using cell 2 to restore
    cell 1 for the next pass. When cell 0 is finally 0, cell 3 holds the product.
    Note that we entered single digits, but this multiplication routine is generic
    and will work for any two values. Also, the trick of double incrementing memory
    to have a place to restore from is another BF idiom. We saw similar code in [Chapter
    8](ch08.xhtml#ch08) when we implemented multiplication in FRACTRAN.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每次外部循环都会将单元格 1 加到单元格 3，使用单元格 2 恢复单元格 1 以便进行下一次循环。当单元格 0 最终变为 0 时，单元格 3 存储了乘积。请注意，我们输入的是单个数字，但这个乘法例程是通用的，适用于任何两个值。此外，双重递增内存以便有一个地方恢复的技巧是另一个BF惯用法。我们在[第8章](ch08.xhtml#ch08)实现FRACTRAN乘法时见过类似的代码。
- en: 'Let’s take *mult.b* out for a test drive. We’ll use our interpreter’s ability
    to dump memory to see if it is working. For example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下*mult.b*。我们将利用解释器的内存转储功能来检查它是否正常工作。例如：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In both cases, we see that cell 3 contains the correct product.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们看到单元格 3 包含正确的乘积。
- en: To print the product as a number, we add the code in [Listing 10-13](ch10.xhtml#ch010list13)
    to the end of the multiplication routine in [Listing 10-12](ch10.xhtml#ch010list12)
    (see *mult2.b*).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将乘积作为数字打印，我们将[Listing 10-13](ch10.xhtml#ch010list13)中的代码添加到[Listing 10-12](ch10.xhtml#ch010list12)中乘法例程的末尾（见
    *mult2.b*）。
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 10-13: The print routine*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-13: 打印例程*'
- en: As mentioned, this routine comes from *[https://esolangs.org/](https://esolangs.org/)*.
    What is particularly nice about this routine is that it works with any memory
    location, so we move from cell 0 to cell 3 prior to running it. The provided comments
    give some indication of what the routine is doing. Notice that the second line
    of [Listing 10-13](ch10.xhtml#ch010list13) uses the “clear a cell” idiom three
    times to initialize memory. We won’t walk through [Listing 10-13](ch10.xhtml#ch010list13)
    in any detail, as it is quite challenging. Motivated readers will find the code,
    with some additional details, at *[https://esolangs.org/wiki/Brainfuck_algorithms](https://esolangs.org/wiki/Brainfuck_algorithms)*
    under the heading beginning with “Print value of cell x as number.”
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个例程来自 *[https://esolangs.org/](https://esolangs.org/)*。这个例程特别好的一点是，它可以与任何内存位置一起工作，因此在运行之前，我们从单元格
    0 移动到单元格 3。提供的注释给出了一些例程的操作指示。请注意，[Listing 10-13](ch10.xhtml#ch010list13)的第二行使用了“三次清除一个单元格”的惯用法来初始化内存。我们不会详细讲解[Listing
    10-13](ch10.xhtml#ch010list13)，因为它相当具有挑战性。有兴趣的读者可以在 *[https://esolangs.org/wiki/Brainfuck_algorithms](https://esolangs.org/wiki/Brainfuck_algorithms)*
    上找到包含一些附加细节的代码，标题为“Print value of cell x as number.”。
- en: Let’s review some examples to see that the routine works as advertised.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些示例，看看例程是否按预期工作。
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The examples of this section, *ones.b*, *parity.b*, *mult.b*, and *mult2.b*,
    serve as our introduction to BF. There’s much more we might say, but we covered
    the essentials. Let’s turn now to outside resources to see additional examples,
    learn more about BF programming, and gain insight on how BF has influenced esolangs
    as a whole, to say nothing of genuine academic research involving BF.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例，*ones.b*、*parity.b*、*mult.b* 和 *mult2.b*，作为我们了解BF的引入。还有很多内容我们可以讲，但我们已经覆盖了基本要点。接下来，让我们看看外部资源，查看更多示例，深入了解BF编程，并了解BF如何影响整个esolangs，甚至包括涉及BF的真正学术研究。
- en: '**The BF Multiverse**'
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**BF 多重宇宙**'
- en: 'If Piet generated a universe, then to be fair, we must say that BF has created
    a multiverse. Let’s briefly investigate some of those universes in this section:
    examples, tutorials, implementations, inspirations, and academic BF. Enjoy!'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Piet创造了一个宇宙，那么公平地说，我们必须承认BF创造了一个多重宇宙。让我们简要地探讨一下本节中的一些宇宙：示例、教程、实现、灵感和学术BF。请享受！
- en: '***Examples***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例***'
- en: The best way to learn a language is to use it. We did that in the previous section.
    The next best way to learn a language is to see how others have used it. Let’s
    take a cursory look at the BF examples included with this book. I did not write
    these examples. See the *README* file for attribution information.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一门语言最好的方法就是使用它。我们在上一节中做到了这一点。学习语言的第二好方法是看看别人是如何使用它的。让我们粗略地看看本书中包含的 BF 示例。我并没有编写这些例子。请参阅
    *README* 文件以获取归属信息。
- en: The most impressive set of BF programs written by hand and not generated by
    another system producing BF code as output I’ve found are by Daniel B. Cristofani.
    You’ll find them at *[http://brainfuck.org/](http://brainfuck.org/)*, which alone
    tells you Cristofani’s a serious BF coder—he registered the domain name. I suspect
    you’ll learn much from the examples and even more from the tutorial information
    on his site.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我找到的最令人印象深刻的手写 BF 程序集，并不是由另一个系统生成 BF 代码作为输出的，是由 Daniel B. Cristofani 编写的。你可以在
    *[http://brainfuck.org/](http://brainfuck.org/)* 上找到它们，仅此一项就能告诉你 Cristofani 是一个严肃的
    BF 编程者——他注册了这个域名。我怀疑你会从这些例子中学到很多东西，甚至更多的是从他网站上的教程信息中学到。
- en: 'The book repository contains the following, all of which run with both the
    C and SNOBOL interpreters:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的代码库包含以下内容，所有内容都可以在 C 和 SNOBOL 解释器下运行：
- en: '***squares.b***  Print *n*² for [0,100].'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '***squares.b***  打印 *n*²，范围是 [0,100]。'
- en: '***fib.b***  Generate an endless stream of Fibonacci numbers. We encountered
    the Fibonacci sequence in [Chapter 1](ch01.xhtml#ch01) and will again in [Chapter
    13](ch13.xhtml#ch13). This version does not use a single cell to hold the number,
    but rather handles arbitrary-sized numbers. This is a good example of how compact
    BF code can be while still doing something interesting.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '***fib.b***  生成无尽的斐波那契数列。我们在[第1章](ch01.xhtml#ch01)中遇到了斐波那契数列，并将在[第13章](ch13.xhtml#ch13)中再次遇到。这个版本不使用单一的单元来存储数字，而是处理任意大小的数字。这是一个很好的例子，展示了
    BF 代码可以多么紧凑，同时仍然能够完成有趣的任务。'
- en: '***factorial2.b***  Another gem. This one calculates an endless stream of factorials.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '***factorial2.b***  另一个宝石。这个计算无尽的阶乘流。'
- en: '***sierpinski.b***  The Sierpiński triangle is a common fractal, one that a
    straightforward algorithm can generate. This version produces ASCII output. We’ll
    work with the Sierpiński triangle again in [Chapter 13](ch13.xhtml#ch13). Consider
    this example a preview.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '***sierpinski.b***  Sierpiński 三角形是一个常见的分形，简单的算法就能生成这个分形。这个版本生成 ASCII 输出。我们将在[第13章](ch13.xhtml#ch13)中再次处理
    Sierpiński 三角形。请将此例子视为预览。'
- en: '***random.b***  Implements Wolfram’s Rule 30, a 1D cellular automaton. This
    automaton, especially the center bit, passes many tests for randomness and formed
    the basis for Mathematica’s first pseudorandom generator. To experiment more with
    Rule 30 and other 1D automatons, see [Chapter 7](ch07.xhtml#ch07) of my book *Random
    Numbers and Computers* (Springer, 2018).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '***random.b*** 实现了沃尔夫拉姆的规则30，这是一个一维元胞自动机。这个自动机，尤其是中心位，经过了许多随机性测试，并成为 Mathematica
    第一个伪随机生成器的基础。要进一步实验规则30和其他一维自动机，请参见我的书 *《随机数与计算机》*（Springer，2018）中的[第7章](ch07.xhtml#ch07)。'
- en: '***golden.b***  Calculates the decimal expansion of ![Image](Images/f0292-01.jpg).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '***golden.b***  计算 ![Image](Images/f0292-01.jpg) 的十进制展开式。'
- en: '***e.b***  Calculates the decimal expansion of *e*, the base of the natural
    logarithm. The natural log can be defined via an integral, In ![Image](Images/f0293-1.jpg)
    with *e* the limit such that the log is ![Image](Images/f0293-2.jpg).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.b***  计算 *e*（自然对数的底数）的十进制展开式。自然对数可以通过积分定义，如 ![Image](Images/f0293-1.jpg)，其中
    *e* 是使得对数为 ![Image](Images/f0293-2.jpg) 的极限。'
- en: '***tictactoe.b***  Tic-tac-toe in BF. You against the computer. Good luck.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '***tictactoe.b***  用 BF 实现的井字游戏。你和计算机对战。祝你好运。'
- en: 'The remaining examples, beyond *cat.b* and *hello.b*, which we saw earlier,
    include the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的例子，除了之前看到的 *cat.b* 和 *hello.b*，包括以下内容：
- en: '***prime.b***  Calculate prime numbers less than the given number. This commented
    example was written by hand, but I have not succeeded in identifying the author.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '***prime.b***  计算小于给定数值的素数。这个带注释的例子是手写的，但我尚未成功找出作者。'
- en: '***hanoi.b***  An animated Tower of Hanoi. This example is the output of Claire
    Wolf’s BF compiler suite (see below). It’s fun to watch, but run it with the C
    interpreter or you’ll be waiting a very long time indeed.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '***hanoi.b***  动画版汉诺塔。这个例子是 Claire Wolf 的 BF 编译器套件的输出（见下文）。看起来很有趣，但请用 C 解释器运行它，否则你将等待非常长的时间。'
- en: '***mandelbrot.b***  Creates an ASCII version of the Mandelbrot set. The *README*
    file gives the URL of the code. It appears to be the output of Wolf’s BF compiler
    as well. If you use the SNOBOL interpreter, you’ll eventually finish, but it runs
    about 100 times slower than the C interpreter.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '***mandelbrot.b***  创建曼德布罗集合的ASCII版本。*README*文件提供了代码的URL。它似乎也是Wolf的BF编译器输出的结果。如果你使用SNOBOL解释器，最终会完成，但它的运行速度大约比C语言解释器慢100倍。'
- en: '***Tutorials***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***教程***'
- en: The tutorials here offer plenty of good BF programming insights, idioms, and
    explanations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教程提供了许多有价值的BF编程见解、惯用语和解释。
- en: '**Daniel B Cristofani’s BF pages**  Mentioned earlier but worth mentioning
    again because of the helpful programming advice. You’ll even find advice on how
    to write a “compliant” interpreter. Our SNOBOL interpreter is not compliant, but
    we’re happy with it. (*[http://brainfuck.org/](http://brainfuck.org/)*)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**Daniel B Cristofani的BF页面**  前面提到过，但因为提供了有用的编程建议，值得再次提及。你甚至可以找到关于如何编写“合规”解释器的建议。我们的SNOBOL解释器不合规，但我们对此很满意。
    (*[http://brainfuck.org/](http://brainfuck.org/)*)'
- en: '**Frans Faase’s BF pages**  You’ll find many good reference/tutorial pages
    here. Some are Faase’s, whereas others are links to still more information about
    BF. The World Wide Web is a web, after all. (*[https://www.iwriteiam.nl/Ha_BF.html](https://www.iwriteiam.nl/Ha_BF.html)*)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**Frans Faase的BF页面**  你将在这里找到许多好的参考/教程页面。有些是Faase的作品，而其他一些则是链接到更多关于BF的信息。毕竟，万维网就是一个网络。
    (*[https://www.iwriteiam.nl/Ha_BF.html](https://www.iwriteiam.nl/Ha_BF.html)*)'
- en: '**Katie Ball’s BF tutorial**  Ball’s tutorial is another good reference. (*[https://gist.github.com/roachhd/dce54bec8ba55fb17d3a/](https://gist.github.com/roachhd/dce54bec8ba55fb17d3a/)*)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**Katie Ball的BF教程**  Ball的教程是另一个很好的参考。 (*[https://gist.github.com/roachhd/dce54bec8ba55fb17d3a/](https://gist.github.com/roachhd/dce54bec8ba55fb17d3a/)*)'
- en: '***Implementations***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现***'
- en: The implementations of BF are legion, which is somehow fitting. Only a tiny
    selection is referenced here, and I’m completely ignoring all the hardware implementations.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: BF的实现形式多种多样，某种程度上这也很合适。这里只提到了一小部分，完全忽略了所有的硬件实现。
- en: '**Compilers**'
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**编译器**'
- en: 'The phrase *BF compiler* has multiple meanings. For example, a BF compiler
    might be a program that takes a higher-level language and produces BF code. In
    that case, BF is the machine code for the compiler. Alternatively, a BF compiler
    might be just that: a program that takes BF as input and produces executable code
    from it. I offer an example of each kind here.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*BF编译器*这个短语有多重含义。例如，BF编译器可能是一个将高级语言转换为BF代码的程序。在这种情况下，BF是编译器的机器代码。或者，BF编译器可能仅仅是一个将BF作为输入并生成可执行代码的程序。我这里提供了每种类型的示例。'
- en: '**Brian Raiter’s native BF compiler**  As promised above, here’s Brian Raiter’s
    166-byte BF compiler. It’s written in assembly language (install `nasm` on Linux)
    and produces standalone executables. Not every example in the repository works
    with this compiler, but many do, and the results are significantly faster than
    even the C interpreter. Try *e.b*, *golden.b*, and *tictactoe.b*. There are many
    comments in the source code, *bf.asm*. Hopefully, your x86 assembly is much stronger
    than mine. (*[http://www.muppetlabs.com/~breadbox/software/tiny/bf.asm.txt](http://www.muppetlabs.com/~breadbox/software/tiny/bf.asm.txt)*)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**Brian Raiter的本地BF编译器**  如前所述，这里是Brian Raiter的166字节BF编译器。它是用汇编语言编写的（在Linux上安装`nasm`），并生成独立的可执行文件。并非库中的每个示例都能与此编译器一起工作，但很多可以，而且运行速度比C语言解释器要快得多。试试
    *e.b*，*golden.b* 和 *tictactoe.b*。源代码*bf.asm*中有许多注释。希望你的x86汇编水平比我强。 (*[http://www.muppetlabs.com/~breadbox/software/tiny/bf.asm.txt](http://www.muppetlabs.com/~breadbox/software/tiny/bf.asm.txt)*)'
- en: '**Claire Wolf’s compiler to BF**  This compiler takes a higher-level macro
    language and produces executable BF code. It produced two of our examples: *hanoi.b*
    and *mandelbrot.b*. (*[http://bygone.clairexen.net/bfcpu/bfcomp.html](http://bygone.clairexen.net/bfcpu/bfcomp.html)*)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**Claire Wolf的BF编译器**  这个编译器将一个高级宏语言转换为可执行的BF代码。它生成了我们的两个示例：*hanoi.b* 和 *mandelbrot.b*。
    (*[http://bygone.clairexen.net/bfcpu/bfcomp.html](http://bygone.clairexen.net/bfcpu/bfcomp.html)*)'
- en: '**Interpreters**'
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**解释器**'
- en: We saw how easy it is to write a BF interpreter, even in SNOBOL. The two links
    here point to large lists of BF interpreters in all kinds of languages.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到编写一个BF解释器是多么容易，即使是在SNOBOL中。这里的两个链接指向了各种语言的BF解释器的大型列表。
- en: '**[esolangs.org](http://esolangs.org)’s BF implementations**  This page has
    a long list of BF and BF-related goods and services, er, implementations. (*[https://esolangs.org/wiki/Brainfuck_implementations](https://esolangs.org/wiki/Brainfuck_implementations)*)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**[esolangs.org](http://esolangs.org)的BF实现** 该页面列出了大量与 BF 相关的商品和服务，呃，实施方案。
    (*[https://esolangs.org/wiki/Brainfuck_implementations](https://esolangs.org/wiki/Brainfuck_implementations)*)'
- en: '**Rosetta Code’s BF implementations**  BF interpreters in a plethora of languages.
    Neither Jefe nor I are responsible for time or bits lost due to incomplete or
    erroneous code. (*[http://rosettacode.org/wiki/Execute_Brain****](http://rosettacode.org/wiki/Execute_Brain****)*)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rosetta Code的BF实现**  BF 解释器涵盖了众多语言。无论是 Jefe 还是我，都不对由于不完整或错误代码造成的时间或比特丢失负责。
    (*[http://rosettacode.org/wiki/Execute_Brain****](http://rosettacode.org/wiki/Execute_Brain****)*)'
- en: '***Inspirations***'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***灵感来源***'
- en: Perhaps the greatest tribute to BF is that it has inspired many other esolangs.
    Some are serious, genuine extensions to core BF. Others are less serious or even
    outright jokes. If you browse the (long) language list at *[https://esolangs.org/wiki/Language_list](https://esolangs.org/wiki/Language_list)*,
    you’ll recognize many BF-related languages from nothing more than the colorful,
    if not sometimes offensive, names.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 也许对 BF 的最大致敬就是它启发了许多其他的 esolang（另类编程语言）。有些是对核心 BF 的严肃、真正扩展，其他一些则较为不严肃，甚至是纯粹的笑话。如果你浏览
    *[https://esolangs.org/wiki/Language_list](https://esolangs.org/wiki/Language_list)*
    上的（长）语言列表，你会从一些丰富多彩、甚至有时令人反感的名称中认出许多与 BF 相关的语言。
- en: '***Academic BF***'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***学术BF***'
- en: BF isn’t all just fun and games. The language is elementary, yet Turing complete.
    This makes it attractive to researchers looking for a target or other language
    to use in their systems. The references here are to academic papers that use BF,
    either actively or as an example. What’s particularly interesting is that not
    all of the references are from traditional computer science journals. BF is useful
    even in relation to more traditional human pursuits, like poetry. This list is
    by no means exhaustive, merely illustrative, and favors more recent references
    to BF.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: BF 并不只是单纯的娱乐。该语言虽然简单，但却是图灵完备的。这使它对研究人员具有吸引力，他们可能需要寻找一种目标或其他可以在其系统中使用的语言。这里的参考文献是使用
    BF 的学术论文，无论是积极使用还是作为示例。特别有趣的是，并非所有参考文献都来自传统的计算机科学期刊。BF 甚至在与更传统的人文学科（如诗歌）相关的领域中也有所应用。这个列表绝非详尽无遗，仅供参考，且更侧重于近期的
    BF 相关文献。
- en: '*BF++: A Language for General-purpose Program Synthesis*, Vadim Liventsev,
    Aki Härmä, and Milan Petković (2021).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*BF++：一种通用程序合成语言*，瓦季姆·利文采夫、阿基·哈尔玛和米兰·佩特科维奇（2021年）。'
- en: '*Neural Program Synthesis with Priority Queue Training*, Daniel A. Abolafia,
    Mohammad Norouzi, Jonathan Shen, Rui Zhao, and Quoc V Le (2018).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*优先队列训练的神经程序合成*，丹尼尔·A·阿博拉菲亚、穆罕默德·诺鲁齐、乔纳森·申、瑞·赵和阮国伟（2018年）。'
- en: '*Resisting Clarity/Highlighting Form: Comparing Vanguard Approaches in Poetry
    and Programming*, Irina Lyubchenko (2020).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*抵抗清晰/突出形式：诗歌和编程中的先锋方法比较*，伊琳娜·柳布琴科（2020年）。'
- en: '*Fully Human, Fully Machine: Rhetorics of Digital Disembodiment in Programming*,
    Brandee Easter (2020).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*完全人类，完全机器：编程中的数字化脱身修辞*，布兰迪·伊斯特（2020年）。'
- en: '*50,000,000,000 Instructions per Second: Design and Implementation of a 256-Core
    BrainFuck Computer*, Sang-Woo Jun (2016).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*50,000,000,000 每秒指令：256核BrainFuck计算机的设计与实现*，尚-吴·俊（2016年）。'
- en: '*A Box, Darkly: Obfuscation, Weird Languages, and Code Aesthetics*, Michael
    Mateas and Nick Montfort (2005).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*黑暗的盒子：模糊化、怪异语言与代码美学*，迈克尔·马提亚斯和尼克·蒙福特（2005年）。'
- en: The first two references use BF with reinforcement learning, thereby combining
    esolangs and deep machine learning. Advanced neural networks generate BF programs
    to solve problems.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 前两篇文献将 BF 与强化学习结合，进而将另类编程语言与深度机器学习相结合。先进的神经网络生成 BF 程序来解决问题。
- en: '**Discussion**'
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: BF is Turing complete. It is imperative, has the requisite control structures
    (brackets), and, ignoring the self-imposed 30,000-cell memory limit, uses arbitrary
    memory. Additionally, and impressively, Daniel Cristofani implemented a universal
    Turing machine in BF, thereby directly demonstrating Turing completeness. The
    machine is in *utm.b* in the BF examples directory. Comments in the file explain,
    in detail, what the program is and what it means.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: BF 是图灵完备的。它是命令式的，具有必要的控制结构（括号），并且在忽略自设的30,000单元内存限制的情况下，使用了任意内存。此外，令人印象深刻的是，丹尼尔·克里斯托法尼在
    BF 中实现了一个通用图灵机，从而直接展示了图灵完备性。该机器位于 BF 示例目录中的 *utm.b* 文件中。文件中的注释详细解释了程序的功能和意义。
- en: There’s a certain enticing nature to BF due to its simplicity. Yes, it’s challenging
    to work with, which might have been intentional, like a gauntlet thrown down to
    see who might pick it up. But I don’t view BF that way. Life is built from the
    combinatorial mixing of a multitude of smaller components. Might it be possible
    to view something like BF as the DNA of programming? We already know from [Chapter
    3](ch03.xhtml#ch03) that a Turing machine captures the essence of what an algorithm
    is. BF is more advanced than a Turing machine, but just barely, so it can serve
    the same purpose as an encapsulation of the idea of an “algorithm.”
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: BF由于其简单性，具有某种诱人的特性。是的，使用它很有挑战性，这可能是故意设计的，就像一条扔下的挑战，看看谁会去捡。但我并不这么看待BF。生活是由众多小组件的组合而构成的。也许我们可以把像BF这样的语言视为编程的DNA？我们已经从[第3章](ch03.xhtml#ch03)了解到，图灵机捕捉到了算法的本质。BF比图灵机更为先进，但也仅仅是略胜一筹，因此它可以作为“算法”概念的封装，承担同样的作用。
- en: In his famous *Epigrams on Programming*, Alan Perlis wrote
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在他著名的*编程格言*中，艾伦·珀利斯写道
- en: 19\. A language that doesn’t affect the way you think about programming, is
    not worth knowing.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 19. 一种语言如果不影响你对编程的思考方式，那么它不值得学习。
- en: This is true for every language in this book, but I hope it is especially so
    for the esolangs, with BF chief among them. Struggling to write code in BF, especially
    when decades of experience make the necessary code almost instantly present itself
    in more familiar languages, does affect the way you think about programming. I
    found myself trying, with varying levels of success, to think in a new way to
    understand how to fit what BF offers to what I would instinctively do in a language
    like Python or C. Perhaps that’s the most enduring effect of learning BF. It requires
    you to think in new ways instead of relying on what is already familiar. BF is
    a way out of the Python (or C or Java or . . .) echo chamber, as it were.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的每种语言，这都是真理，但我希望这对于电子语言，尤其是BF，尤为如此。在BF中编写代码的过程非常艰难，特别是当几十年的经验让你能几乎瞬间在更熟悉的语言中写出所需的代码时，它的确会影响你对编程的思考方式。我发现自己在尽力（有时成功，有时失败）尝试用一种新的方式思考，理解如何将BF提供的方式与我在Python或C语言中本能的做法相结合。也许这就是学习BF最持久的影响。它要求你以新的方式思考，而不是依赖于已经熟悉的方式。BF是摆脱Python（或者C、Java等）回音室的一个途径。
- en: 'Perlis offers more wisdom directly applicable to BF:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 珀利斯提供了更多直接适用于BF的智慧：
- en: 23\. To understand a program you must become both the machine and the program.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 23. 要理解一个程序，你必须同时成为机器和程序。
- en: For modern, high-level languages, we need not think about the machine too much.
    Indeed, modern languages go to great lengths to abstract themselves from the machine.
    With BF, as with a Turing machine, we must consider both the machine and the program
    if we hope to be successful.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现代的高级语言，我们不必过多考虑机器的底层实现。事实上，现代语言尽力将自己从机器的细节中抽象出来。而对于BF，就像图灵机一样，我们必须同时考虑机器和程序，才能希望成功。
- en: 'As we’re quoting Perlis, I’d be remiss not to include this epigram:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们引用了珀利斯，我就不能不包括这条格言：
- en: 54\. Beware of the Turing tar-pit in which everything is possible but nothing
    of interest is easy.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 54. 当一切皆有可能，但没有任何有趣的事情容易做到时，要小心图灵陷阱。
- en: 'Turing tar-pits might be a bit like beauty—in the eye of the beholder. The
    following that has grown around BF and, by extension, esolangs in general, argues
    against Perlis in this case, at least to me. Perlis’s first epigram is “One man’s
    constant is another man’s variable.” I’m tempted to rephrase it: “One man’s Turing
    tar-pit is another man’s inspiration.”'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵陷阱可能有点像美—存在于观者的眼中。围绕BF以及更广泛的电子语言（esolangs）形成的追随者群体，在这个问题上与珀利斯的看法相悖，至少对我来说是这样。珀利斯的第一条格言是：“一个人的常量是另一个人的变量。”我忍不住想改述为：“一个人的图灵陷阱是另一个人的灵感。”
- en: '**Summary**'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'This chapter introduced us to the strangely attractive, if frustratingly difficult,
    multiverse of BF. We explored what BF is and then implemented it twice: once in
    C using the original implementation and again in SNOBOL. After this, we wrote
    a few example programs to get a feel for thinking in BF. With a basic grasp of
    the language in hand, we then turned our gaze upward to examine some of the brighter
    lights in the BF multiverse. As with every language, we closed the chapter with
    a brief discussion.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了BF的奇异魅力，尽管它令人沮丧且困难重重的多重宇宙。我们探讨了BF是什么，然后实现了它两次：一次使用C语言和原始实现，再次使用SNOBOL。之后，我们写了几个示例程序，以便熟悉BF的思维方式。掌握了语言的基本知识后，我们把目光转向了BF多重宇宙中的一些更亮眼的存在。和每种语言一样，我们在本章的最后进行了简短的讨论。
- en: 'In [Chapter 9](ch09.xhtml#ch09) we painted pretty pictures with Piet, a 2D
    language. Let’s close our survey of existing esolangs by returning to the world
    of 2D programming, but this time using text instead of pixels. Next stop: Befunge.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](ch09.xhtml#ch09)中，我们用Piet这门二维语言绘制了漂亮的图画。让我们通过回到二维编程的世界来结束对现有另类编程语言的调查，不过这次我们将使用文本而非像素。下一站：Befunge。
