- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Computational Geometry for Safety Resource Distribution
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算几何在安全资源分配中的应用
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'In enterprise security work, you’ll often be asked to assist with a wide variety
    of infrastructure planning and deployment tasks that have more to do with providing
    safety than the traditional CIA (confidentiality, integrity, availability) triad
    we commonly think of as guiding information security. But fear not—with the mathematical
    tools you’re collecting, you’ll be able to adapt to the changing challenges and
    thrive under them. In this chapter we’ll focus on one of the most commonly applied
    tools from computational geometry, and one of my personal favorite algorithms:
    Voronoi tessellation.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业安全工作中，你将经常被要求协助进行各种基础设施规划和部署任务，这些任务更多地涉及提供安全性，而非我们通常认为引导信息安全的传统CIA（三要素：保密性、完整性、可用性）三元组。但不用担心——凭借你正在收集的数学工具，你将能够适应不断变化的挑战，并在其中蓬勃发展。本章我们将重点介绍计算几何中最常用的工具之一，也是我个人最喜欢的算法之一：Voronoi镶嵌。
- en: We’re going to help the city of Portland, Oregon, plan the location of a new
    fire station using the locations of the current stations to inform our risk assessment.
    I picked this project because it shows how applied security concepts can scale;
    the same type of analysis can be applied to police stations, hospitals, burger
    joints, or any other public resource distributed throughout a city, state, country,
    or geographic region, making this one of the most flexible analysis tools in your
    arsenal.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将帮助俄勒冈州波特兰市规划新消防站的位置，利用现有消防站的位置来进行风险评估。我选择这个项目是因为它展示了如何将应用安全概念扩展到其他领域；同样类型的分析可以应用于警察局、医院、汉堡店或任何其他分布在城市、州、国家或地理区域的公共资源，使其成为你工具箱中最灵活的分析工具之一。
- en: 'This is the high-level plan: first we’ll create a polygon that represents the
    city, and then we’ll place points within the polygon representing the locations
    of the current fire stations. We’ll split up the city into smaller polygons that
    represent the areas closest to a given fire station. Finally, we’ll compare the
    areas of the smaller polygons to determine which fire station is responsible for
    covering the most area, and make our recommendation for the new fire station accordingly
    to improve response time in that area. Along the way, we’ll examine Voronoi tessellations
    and discuss some of the limitations of our implementation. By the end of this
    chapter, you should have a solid understanding of how to use computational geometry
    for resource distribution plans. You should also feel comfortable retrieving and
    manipulating geospatial information using the OpenStreetMaps API, which will allow
    you to scale your resource planning to whatever geographic size you need.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是高层次的计划：首先，我们将创建一个表示城市的多边形，然后在多边形内放置一些点，表示当前消防站的位置。接着，我们将城市划分成更小的多边形，代表每个消防站所负责的区域。最后，我们将比较这些小多边形的面积，确定哪个消防站负责覆盖的面积最大，并根据需要推荐新消防站的设置，以提高该区域的响应时间。在过程中，我们将研究Voronoi镶嵌，并讨论我们实现的一些限制。到本章结束时，你应该能够扎实地理解如何使用计算几何进行资源分配计划。你还应该能够熟练地使用OpenStreetMaps
    API来获取和处理地理空间信息，这将使你能够将资源规划扩展到任何所需的地理范围。
- en: Using Voronoi Tessellation for Resource Distribution
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Voronoi镶嵌进行资源分配
- en: You already saw tessellation in action when we placed the security assets around
    the park in [Chapter 7](c07.xhtml). In that case we divided the plane into triangles
    based on the vertices of the polygon, then placed a point in some of these regions
    representing the guard. We would expect the guard to respond to any incident that
    was within their zone. A *Voronoi tessellation* works in reverse, where we have
    a set of points (called *seeds* or *generators*) distributed throughout a plane,
    and we want to split up the area into regions that contain a single point. Take
    a look at [Figure 9-1](#figure9-1), which shows an example of a Voronoi tessellation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第7章](c07.xhtml)中已经看到过镶嵌的应用，当时我们将安全资产部署在公园周围。在那个例子中，我们基于多边形的顶点将平面划分成三角形，然后在这些区域中放置一个点，表示守卫。我们预期守卫会对任何发生在他们区域内的事件做出响应。*Voronoi镶嵌*则是反向工作的，我们有一组点（称为*种子*或*生成器*），这些点分布在平面上，我们希望将区域划分为包含单一点的区域。请看[图9-1](#figure9-1)，它展示了一个Voronoi镶嵌的示例。
- en: '![](image_fi/502567c09/f09001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c09/f09001.png)'
- en: 'Figure 9-1: Randomly generated Voronoi tessellation'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1：随机生成的Voronoi镶嵌
- en: The gray circles represent 10 randomly selected (*x*, *y*) coordinates that
    serve as the generators for our Voronoi tessellation. Each line segment represents
    the place in the plane that is equidistant from two or more generators. Points
    along the lines are the same distance from more than one generator point, so we
    mark them as the border between generators. After marking all the borders between
    generators, we end up with a polygonal mosaic. Each polygon represents a subregion
    of the plane. In each polygon region there’s exactly one generator point, so we
    can classify any arbitrary point in the plane that doesn’t fall on a border line
    segment based on which generator point is closest.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 灰色圆圈代表了10个随机选取的（*x*，*y*）坐标，这些坐标作为我们Voronoi镶嵌的生成器。每条线段代表平面上距离两个或多个生成器等距的位置。线上的点与多个生成器点的距离相同，因此我们将它们标记为生成器之间的边界。标记完所有生成器之间的边界后，我们就得到了一个多边形的马赛克。每个多边形代表平面上的一个子区域。在每个多边形区域中都有一个生成器点，因此我们可以根据哪个生成器点离平面上任意一个不在边界线段上的点最近来对其进行分类。
- en: In the park example from [Chapter 7](c07.xhtml), this would be like spreading
    the guards through the park and then dividing up the park into areas of responsibility
    based on their positions. Approaching the problem this way is useful in a lot
    of cases, especially when examining the distribution of resources that are already
    in place or can’t be moved easily.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](c07.xhtml)中的公园示例中，这就像是将警卫分布到公园中，然后根据他们的位置将公园划分为各自的责任区域。以这种方式处理问题在很多情况下都非常有用，特别是在检查已经到位或无法轻易移动的资源分布时。
- en: Formally speaking, a Voronoi tessellation divides a plane into regions of space
    where all the points in one region are closer to the generator for that region
    than any other generator. Points that are equidistant from two or more generators
    define the boundary between the regions. To perform the Voronoi tessellation for
    the fire station project, we need to define a *metric space X*, which is simply
    a set (in this case, of generator points in a plane defined by a 2D polygon) and
    a metric function that operates on the set (here, a function *d* to calculate
    distance between points). Our metric space—that is, the plane we’ll be tessellating—is
    bounded by the shape of the city limits. The generator points will be the locations
    of the current stations that divide the city up into areas of responsibility.
    Both the boundary data and the generating points need to be in the same coordinate
    system. Rather than having to manually project the coordinates, like we did in
    the previous project, we’ll take advantage of a purpose-built library called geovoronoi,
    which handles the back-and-forth projections under the hood.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，Voronoi镶嵌将平面划分为空间区域，其中每个区域的所有点都比任何其他生成器更接近该区域的生成器。与两个或多个生成器等距的点定义了区域之间的边界。为了对消防站项目执行Voronoi镶嵌，我们需要定义一个*度量空间X*，这只是一个集合（在此情况下，是一个由2D多边形定义的平面上的生成器点集合）和一个作用于该集合的度量函数（这里是一个计算点间距离的*d*函数）。我们的度量空间——也就是我们将进行镶嵌的平面——受到城市边界形状的限制。生成器点将是当前站点的位置，负责划分城市的责任区域。边界数据和生成点都需要处于同一坐标系统中。我们不再像之前的项目那样手动投影坐标，而是利用一个专门构建的库叫做geovoronoi，它在后台处理坐标的前后投影。
- en: 'The Proof of Concept: Analyzing Fire Station Coverage'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念验证：分析消防站覆盖范围
- en: The proof of concept for this project is pretty straightforward. Our goal is
    to produce an application that shows the current division of fire service coverage
    for the city of Portland, using a Voronoi tessellation to define the service areas
    programmatically. We want our program to find the largest service area and produce
    this as the recommended area to split up. To achieve this, we need to define three
    pieces of information. First, we need shape data representing the area we plan
    to analyze, in this case Portland. I’ve included a copy of this data in the file
    *portland_geodata.json* in the book’s supplemental materials. You can also get
    the data from web services like OpenStreetMap API, which is how I retrieved it
    initially. The second thing we need is the location of our generator points, which,
    for this project, are the addresses of the various fire stations around Portland.
    I’ve included the 10 addresses I used for this analysis in the file *station_addresses_portland.csv
    in the supplemental materials. Third, we need to define the function we’ll use
    to measure distance between points when performing the Voronoi tessellation.*
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的概念验证相当简单。我们的目标是开发一个应用程序，通过Voronoi镶嵌来程序化地定义波特兰市的消防服务区域分布。我们希望程序能找到面积最大的服务区，并将其作为推荐的拆分区域。为此，我们需要定义三项信息。首先，我们需要表示我们计划分析的区域的形状数据，在本例中是波特兰。我已经将这部分数据包含在书籍附录材料中的*portland_geodata.json*文件里。你也可以通过像OpenStreetMap
    API这样的网络服务获取数据，这也是我最初获取数据的方式。其次，我们需要定义生成点的位置，在这个项目中，生成点是波特兰各消防站的地址。我已经将我在此次分析中使用的10个地址包含在书籍附录材料中的*station_addresses_portland.csv*文件里。第三，我们需要定义在执行Voronoi镶嵌时用于测量点之间距离的函数。*
- en: '*Once we’ve defined these three pieces of information, we’re ready to perform
    the Voronoi analysis. Then it’s just a matter of finding the generated region
    with the largest area; for this, we’ll again rely on Shapely. We’re going to start
    by discussing the distance function. Loading the area shape and generator points
    are interesting data retrieval tasks, but the distance function defines how the
    borders between regions will be calculated, so it’s where the bulk of the math
    magic happens.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦我们定义了这三项信息，就可以进行Voronoi分析了。接下来，我们只需找到生成的区域中面积最大的那个；为了实现这一点，我们将再次依赖Shapely。我们将从讨论距离函数开始。加载区域形状和生成点是有趣的数据检索任务，但距离函数定义了区域之间边界的计算方式，因此这是大部分数学“魔法”发生的地方。*'
- en: Defining the Distance Function
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义距离函数
- en: 'The metric space contains the distance function *d*(*p*, *q*), which is used
    to determine the distance between points in the plane. This is how the algorithm
    decides which points belong to which regions. There are several choices for the
    distance function: Manhattan distance, Chebychev distance, sum of absolute difference,
    sum of squared difference, and more. Each has advantages and disadvantages, so
    we’ll stick with the most basic and intuitive option, Euclidean distance or, colloquially,
    “as the crow flies.”'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 度量空间包含距离函数 *d*(*p*, *q*)，该函数用于确定平面中两点之间的距离。算法通过这个方式来决定哪些点属于哪个区域。距离函数有几种选择：曼哈顿距离、切比雪夫距离、绝对差的和、平方差的和等等。每种都有其优缺点，因此我们将选择最基本、最直观的选项——欧几里得距离，或口语上称为“鸟飞直线”。
- en: 'The Euclidean distance between points *p* and *q* is the length of the line
    segment connecting them (pq). If we treat the latitude and longitude as Cartesian
    coordinates, we can approach the problem as a 2D Euclidean geometry question,
    which we can solve using the Pythagorean theorem:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 两点 *p* 和 *q* 之间的欧几里得距离是连接它们的线段（pq）的长度。如果我们将纬度和经度视为笛卡尔坐标系中的坐标，就可以将这个问题视为一个二维欧几里得几何问题，我们可以使用勾股定理来解决：
- en: '![](image_fi/502567c09/m09001.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c09/m09001.png)'
- en: Here *n* is the number of dimensions the problem is mapped to, or more generally
    the length of the vector that defines a point. So, if you were working in 10 dimensions,
    each point would be defined by a vector of length 10\. In our case, we have two
    dimensions, so *n* = 2\. We simply need to square the difference between the end
    point and the beginning point, sum the squared difference across both dimensions,
    and then find the square root of the result.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *n* 是问题映射到的维度数，或者更一般地说，是定义一个点的向量的长度。所以，如果你在处理10维问题，每个点将由一个长度为10的向量来定义。在我们的例子中，我们有两个维度，因此
    *n* = 2。我们只需要对终点和起点之间的差值进行平方，将两个维度的平方差求和，然后对结果取平方根。
- en: 'There is a drawback to Euclidean distance in this scenario: in reality, you
    can rarely move straight through a geographic area without worrying about obstructions
    like trees and buildings. Furthermore, vehicles like fire engines are confined
    to streets and subject to traffic and other conditions that dictate the path they
    take to their destination. I encourage you to expand on my simplification to make
    the results more accurate and useful in your own implementation. For now, we’ve
    defined everything we need to start diving into the question. It’s time to start
    collecting the data required to define our geometric plane, starting with the
    shape of the city limits.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，欧几里得距离有一个缺点：实际上，你很少能直接穿越一个地理区域而不考虑像树木和建筑物这样的障碍物。此外，像消防车这样的车辆受到街道的限制，并且受交通和其他条件的影响，这些因素决定了它们到达目的地的路径。我鼓励你在我的简化基础上进行扩展，以便在你自己的实现中使结果更加准确和有用。现在，我们已经定义了开始深入探讨问题所需的一切。是时候开始收集定义几何平面所需的数据，从城市边界的形状开始。
- en: Determining the City Shape
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定城市形状
- en: To get the polygon that represents the bounds of the plane, I like to use a
    web tool from the OpenStreetMap team called Nominatim ([https://nominatim.org](https://nominatim.org)).
    Its simple and free interface allows you to get several important pieces of information,
    like the place ID, the localized spellings of the name, and more. You can view
    the information on the website directly or request a JSON response to parse in
    your own programs, as we do here. [Listing 9-1](#listing9-1) shows how to request
    the information.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取表示平面边界的多边形，我喜欢使用 OpenStreetMap 团队提供的一个名为 Nominatim 的网页工具（[https://nominatim.org](https://nominatim.org)）。其简单且免费的界面允许你获取几项重要信息，如地点
    ID、名称的本地化拼写等。你可以直接在网站上查看这些信息，或者请求 JSON 响应以便在你自己的程序中解析，正如我们在这里所做的那样。[清单 9-1](#listing9-1)
    展示了如何请求这些信息。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 9-1: Retrieving the JSON data for Portland, Oregon, via Nominatim'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-1：通过 Nominatim 获取俄勒冈州波特兰市的 JSON 数据
- en: When we call the Nominatim API, the `q` parameter holds the query string we’re
    searching; here, we set it to a string containing the city name and state abbreviation,
    `"Portland OR"`. The `polygon_geojson` parameter tells the API to return the geoJSON
    representation of the polygon indicating the boundaries of the city. This is the
    part we’re most interested in at the moment, since it gets the shape data we need
    to define the city limits. The `format` parameter tells the API how we want the
    response data encoded. Whenever JSON is an option, it’s a good choice for Python,
    as it handles the parsed data like a dictionary. We have to encode the parameter
    dictionary into a string that can be appended to the URL, using the `urllib.parse.urlencode`
    function. We then submit the query string as part of a GET request and parse the
    data using the function `json.loads` on the text value of the response. The value
    should come back as a list with one or more entries representing the places that
    match our query. In this case, there should be only one result, representing the
    city of Portland. [Figure 9-2](#figure9-2) shows the polygon.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 Nominatim API 时，`q` 参数包含我们要搜索的查询字符串；在这里，我们将其设置为包含城市名称和州缩写的字符串，`"Portland
    OR"`。`polygon_geojson` 参数告诉 API 返回表示城市边界的多边形的 geoJSON 形式。这是我们目前最感兴趣的部分，因为它获取了我们定义城市边界所需的形状数据。`format`
    参数告诉 API 我们希望以何种格式返回响应数据。每当 JSON 可选时，它是 Python 的一个不错选择，因为它将解析后的数据处理得像字典一样。我们需要将参数字典编码成可以附加到
    URL 的字符串，使用 `urllib.parse.urlencode` 函数。然后，我们将查询字符串作为 GET 请求的一部分提交，并使用 `json.loads`
    函数解析响应的文本值。返回的值应该是一个列表，包含一个或多个代表与查询匹配的地方的条目。在这种情况下，应该只有一个结果，代表波特兰市。[图 9-2](#figure9-2)
    展示了该多边形。
- en: '![](image_fi/502567c09/f09002.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c09/f09002.png)'
- en: 'Figure 9-2: The city of Portland as a polygon'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：波特兰市的多边形
- en: The gray area represents the municipal boundaries of the city. This is the section
    that must be protected by the city’s fire service. We need to convert the coordinates
    into a shape, but first let’s format the data as geoJSON, as shown in [Listing
    9-2](#listing9-2).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 灰色区域表示该市的市政边界。这是需要由城市消防服务保护的部分。我们需要将坐标转换为形状，但首先让我们将数据格式化为 geoJSON，如[清单 9-2](#listing9-2)所示。
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-2: Converting the coordinates to a geoJSON feature collection'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-2：将坐标转换为 geoJSON 特征集合
- en: The data structure here is the top-level definition of a geoJSON object, which
    has the type property `FeatureCollection` to indicate that there can be a list
    of features nested under the appropriately named `features` key. Each feature
    is a nested JSON object with the type `Feature`. Each feature needs a set of coordinates
    that define its geometry; here we use `resp_data["geojson"]`, the geoJSON that
    was returned from the API in [Listing 9-1](#listing9-1). We can also add further
    properties to store custom information that can be used for organization or to
    inform our analysis. The `properties` key is followed by a nested dictionary of
    property and value definitions, where the dictionary’s key represents the property
    name and the value represents the property value. Keys are restricted to string
    literals, but the values can be any legal JSON object, so you can get pretty creative
    with the property information you attach to the features.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的数据结构是geoJSON对象的顶级定义，该对象的type属性为`FeatureCollection`，表示可以在适当命名的`features`键下嵌套特征列表。每个特征是一个嵌套的JSON对象，类型为`Feature`。每个特征需要一组坐标来定义其几何形状；在这里我们使用`resp_data["geojson"]`，即在[清单
    9-1](#listing9-1)中从API返回的geoJSON。我们还可以添加更多属性来存储自定义信息，这些信息可以用于组织或为我们的分析提供支持。`properties`键后面跟着一个嵌套的字典，定义了属性名称和值，其中字典的键表示属性名称，值表示属性值。键仅限于字符串字面量，但值可以是任何合法的JSON对象，因此你可以在附加到特征的属性信息上进行非常有创意的操作。
- en: The next step, shown in [Listing 9-3](#listing9-3), is to convert the resulting
    geoJSON information into `shape` objects stored together in a `GeometryCollection`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，如[清单 9-3](#listing9-3)所示，是将结果geoJSON信息转换为存储在`GeometryCollection`中的`shape`对象。
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 9-3: Converting the city geometry into a collection of Shapely shapes'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-3：将城市几何转换为Shapely形状集合
- en: First we create a `GeometryCollection` by passing in a list of geometric objects
    making up the collection. We use a list comprehension to loop over each feature
    in the `city_gj` variable created in [Listing 9-2](#listing9-2). For each feature,
    we pass the geometry parameter to the `shape` constructor. The result is a `shape`
    object representing the coordinates of the geoJSON feature. Some cities are represented
    by more than one polygon, so this function will loop over all of the polygons
    that make up the city and convert each one into a `shape` object. The `city_shape`
    is now a `GeometryCollection` containing a single `MultiPolygon` object. We can
    access the `MultiPolygon` with another list comprehension. Since there’s only
    one item, we can extract it from the list using index `0`. If you had more `MultiPolygon`
    objects to process, you’d want to loop over each individually. The `MultiPolygon`
    data in the `city_shape` variable now represents the plane we’ll be tessellating
    using the metric space we’ve defined. Now it’s time to get the locations for the
    stations to create our list of generators.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过传入组成集合的几何对象列表来创建一个`GeometryCollection`。我们使用列表推导遍历在[清单 9-2](#listing9-2)中创建的`city_gj`变量中的每个要素。对于每个要素，我们将几何参数传递给`shape`构造函数。结果是一个`shape`对象，表示geoJSON要素的坐标。有些城市由多个多边形表示，因此此函数将遍历构成城市的所有多边形，并将每个多边形转换为一个`shape`对象。`city_shape`现在是一个包含单个`MultiPolygon`对象的`GeometryCollection`。我们可以使用另一个列表推导访问`MultiPolygon`。由于只有一个项目，我们可以通过索引`0`从列表中提取它。如果你有更多`MultiPolygon`对象需要处理，应该遍历每个对象。`city_shape`变量中的`MultiPolygon`数据现在表示我们将使用我们定义的度量空间进行镶嵌的平面。现在是时候获取车站的位置来创建我们的发电机列表了。
- en: Gathering the Locations of Existing Fire Stations
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集现有消防站的位置
- en: As I mentioned previously, we’ll be using the geographic location of the existing
    fire stations as the regional generators in our analysis. The file *station_addresses_portland.csv*,
    provided in the book’s supplemental materials, contains the names and addresses
    of 10 fire stations within the city limits. The pandas library offers a convenient
    function for loading data from a CSV file into a `DataFrame`, shown in [Listing
    9-4](#listing9-4).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用现有消防站的地理位置作为我们分析中的区域发电机。书籍附赠材料中提供的文件*station_addresses_portland.csv*包含了市区内10个消防站的名称和地址。pandas库提供了一个方便的函数，可以将CSV文件中的数据加载到`DataFrame`中，如[清单
    9-4](#listing9-4)所示。
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-4: Loading the data into a `DataFrame` the quick-and-dirty way'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-4：将数据快速而简便地加载到`DataFrame`中
- en: Although there are libraries specifically for handling CSV data, I prefer to
    leverage pandas’s built-in `read_csv` function, as it is flexible and comes packaged
    in a library I already use often. When I was preparing the data for this project,
    I compiled the station address list manually, using Google Maps. I didn’t bother
    to include a header, which is why we pass in a list of columns using the `names`
    parameter. In an actual consultation, I’d expect the client to provide the addresses
    for you, so you’ll likely need to adjust the file parsing to match the data format
    you’re provided. Next we create a convenient `addr` column to hold the whole street
    address as a string by applying a function called `row_to_str`, which simply returns
    the concatenation of the `street`, `city`, `state`, and `zip` columns separated
    by a space character. We pass `axis=1` to tell pandas we want to apply the function
    to the whole row, instead of all the values in a column. We’ll use the `addr`
    column to make it easier to search the geolocation API.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有专门用于处理 CSV 数据的库，但我更倾向于利用 pandas 的内置 `read_csv` 函数，因为它灵活且已经包含在我常用的库中。当我为这个项目准备数据时，我手动使用
    Google Maps 汇总了车站地址列表。我没有添加标题行，这就是为什么我们通过 `names` 参数传入一个列名列表。在实际的咨询工作中，我会期待客户提供地址，因此你可能需要调整文件解析方式，以匹配提供的数据格式。接下来，我们创建一个方便的
    `addr` 列，将完整的街道地址作为字符串存储，通过应用一个名为 `row_to_str` 的函数，该函数简单地返回 `street`、`city`、`state`
    和 `zip` 列的值，使用空格分隔。我们传递 `axis=1` 告诉 pandas 我们想要将函数应用于整行，而不是列中的所有值。我们将使用 `addr`
    列来简化地理位置 API 的搜索。
- en: Once we’ve gathered the addresses into a `DataFrame`, we can again leverage
    the OpenStreetMaps API (via the geocoder library) to turn these into geodesic
    points. In [Listing 9-5](#listing9-5) we define the `locate` function to turn
    a single address into location info.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将地址收集到 `DataFrame` 中，我们可以再次利用 OpenStreetMaps API（通过 geocoder 库）将这些地址转换为地理坐标点。在[清单
    9-5](#listing9-5)中，我们定义了 `locate` 函数，将单个地址转换为位置数据。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 9-5: Converting an address to a geodesic point'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-5：将地址转换为地理坐标点
- en: The main work of calling the API is abstracted away for us by the `geocoder.osm`
    function ❶. Passing in a query string (in this case, the address) returns an object
    containing the API’s response. The library supplies a convenient `json` parameter
    on the response object. If the JSON response is `None` ❷, we return `None` to
    indicate that the API couldn’t locate anything for the input query. If a JSON
    object is returned, we grab a subset of the data containing the important information
    from the response, such as the latitude and longitude, and return it as a dictionary
    ❸. We also record the `osm_id`, so we can use it to shortcut future lookups or
    choose between multiple results for a query.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 API 的主要工作被 `geocoder.osm` 函数 ❶ 抽象化处理。传入查询字符串（在本例中为地址）会返回一个包含 API 响应的对象。库在响应对象上提供了一个方便的
    `json` 参数。如果 JSON 响应为 `None` ❷，我们返回 `None` 以表示 API 未能找到任何与输入查询相关的内容。如果返回了 JSON
    对象，我们提取包含重要信息的子集，例如纬度和经度，并将其作为字典 ❸ 返回。我们还会记录 `osm_id`，以便在未来进行快捷查找或在多个结果中选择。
- en: To collect the points for all the stations, we’ll call the `locate` function
    in a loop over the addresses and store the results as a list. Since we previously
    created a `DataFrame` from the station data (the `stations_df` variable from [Listing
    9-4](#listing9-4)), we can leverage pandas’s `apply` function to handle the messy
    work behind the scenes. We’ll then convert the location information into its own
    `GeoDataFrame` object. [Listing 9-6](#listing9-6) shows how to handle the conversion.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了收集所有车站的坐标点，我们将在一个循环中调用 `locate` 函数，对每个地址进行处理，并将结果存储为一个列表。由于我们之前已经从车站数据创建了一个
    `DataFrame`（[清单 9-4](#listing9-4) 中的 `stations_df` 变量），我们可以利用 pandas 的 `apply`
    函数来处理幕后繁琐的工作。然后，我们将位置数据转换为独立的 `GeoDataFrame` 对象。[清单 9-6](#listing9-6) 展示了如何进行转换。
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 9-6: Creating a `DataFrame` from the station locations'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-6：从车站位置创建 `DataFrame`
- en: After we call `apply`, the `locations` variable contains a list of dictionary
    objects, one for each station, to hold the geodesic coordinates we need for our
    analysis. We filter out any instances where the location is `None` and then use
    this data to create a location `DataFrame` named `loc_df`. Finally, we can convert
    this regular pandas `DataFrame` into a more suitable `GeoDataFrame` object from
    the GeoPandas library. [Figure 9-3](#figure9-3) shows the results plotted on the
    map.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用`apply`之后，`locations`变量包含了一个字典对象的列表，每个字典代表一个火车站，存储了我们分析所需的地理坐标。我们筛选掉位置为`None`的实例，然后使用这些数据创建一个名为`loc_df`的地点`DataFrame`。最后，我们可以将这个常规的pandas
    `DataFrame`转换成一个更合适的GeoPandas库中的`GeoDataFrame`对象。[图 9-3](#figure9-3)展示了结果在地图上的显示。
- en: '![](image_fi/502567c09/f09003.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c09/f09003.png)'
- en: 'Figure 9-3: The fire station locations as points'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：作为点的消防站位置
- en: The dark circles inside the previously defined polygon show the station locations.
    If you count the locations on the map, only 8 of the 10 stations are present.
    The `locate` function failed to locate coordinates for two of the addresses. If
    this project were meant for production, we’d probably want to have multiple sources
    from which to retrieve the coordinates to increase the likelihood of success.
    You could also look them up manually or ask a client to provide the missing information.
    For now, we’ll just drop these two from the analysis and move on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的多边形内的黑色圆圈显示了站点位置。如果你数一下地图上的位置，只有10个站中的8个是显示出来的。`locate`函数未能找到两个地址的坐标。如果这个项目是用于生产环境，我们可能需要从多个来源获取坐标，以提高成功的概率。你也可以手动查找这些坐标，或者请客户提供缺失的信息。现在，我们将从分析中删除这两个地址，继续进行下去。
- en: Now that we’ve collected all the necessary data, we’re ready to perform the
    actual tessellation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经收集了所有必要的数据，可以开始执行实际的镶嵌操作了。
- en: Performing the Voronoi Analysis
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行Voronoi分析
- en: As usual, there are several options for performing a Voronoi tessellation in
    Python, but the easiest by far when working with geographic information is a library
    named geovoronoi, which handles the coordinate projection and boundary work for
    us. It takes a list of coordinates and calculates the Voronoi regions using SciPy
    behind the scenes. At the edges of a typical Voronoi diagram, the region boundaries
    continue out to infinity, which isn’t always the desired behavior, so the geovoronoi
    library allows us to take the shape of the surrounding area (in this case, the
    shape of a city as a polygon) to cut the Voronoi regions so that they fit into
    the provided shape, making the regions at the edges finite. The library also uses
    Shapely for managing the shape manipulation operations, making it a perfect fit
    for this project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，Python中有多种执行Voronoi镶嵌的选项，但在处理地理信息时，最简单的选择是名为geovoronoi的库，它为我们处理坐标投影和边界工作。它接收一组坐标，并使用SciPy后台计算Voronoi区域。在典型的Voronoi图的边缘，区域边界会延伸到无穷大，这通常不是我们想要的行为，因此geovoronoi库允许我们使用周围区域的形状（在这个例子中，是城市的多边形形状）来裁剪Voronoi区域，使其适应提供的形状，从而使边缘区域变得有限。该库还使用Shapely来管理形状操作，使其非常适合这个项目。
- en: '[Listing 9-7](#listing9-7) shows how to use the library along with the previously
    collected data to create the tessellation.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-7](#listing9-7)展示了如何使用该库与之前收集的数据一起创建镶嵌。'
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 9-7: Converting an address to a geodesic point'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-7：将地址转换为地理坐标点
- en: The first step is to convert the points representing the fire stations into
    a NumPy array using a list comprehension to iterate over the `geometry` column
    of the previously created `geo_df` `DataFrame` object. We can then call the `voronoi_regions_from_coords`
    function from the geovoronoi library with the array of points (`points`) as the
    first argument and the boundary polygon (`city_shape`) as the second.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用列表推导将表示消防站的点转换为NumPy数组，遍历之前创建的`geo_df` `DataFrame`对象的`geometry`列。然后，我们可以调用geovoronoi库中的`voronoi_regions_from_coords`函数，将点数组（`points`）作为第一个参数，将边界多边形（`city_shape`）作为第二个参数。
- en: The result of the function is a tuple containing three useful pieces of information.
    The `poly_shapes` variable holds a list of Shapely `Polygon` objects representing
    the shape of the Voronoi regions created during the tessellation algorithm. The
    `pts` variable holds a set of `Point` objects representing the coordinates of
    the generators. These are for convenience if you haven’t already created them
    using GeoPandas or some other method. The `poly_to_pt` variable holds a nested
    list for each region in `poly_shapes` that contains a list of indices into `pts`.
    The indices indicate the generators that belong to this Voronoi region. Usually,
    this is only a single point for our problem, because multiple fire stations shouldn’t
    share the same location, but there may be cases where this isn’t true and multiple
    generator points have the exact same location. In these situations, all of the
    points will be indexed in `poly_to_pt`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的结果是一个包含三项有用信息的元组。`poly_shapes`变量包含一组Shapely `Polygon`对象，表示在Voronoi网格生成过程中创建的多边形区域的形状。`pts`变量包含一组`Point`对象，表示生成器的坐标。如果你还没有使用GeoPandas或其他方法创建它们，这些信息会很方便。`poly_to_pt`变量包含一个嵌套列表，其中每个`poly_shapes`中的区域都有一个列表，表示该区域内生成器的索引。索引指示哪些生成器属于此Voronoi区域。通常情况下，这个区域只有一个点，因为多个消防站不应共享相同的位置，但也可能存在多个生成器点具有相同位置的情况。在这种情况下，所有这些点都会在`poly_to_pt`中被索引。
- en: '[Figure 9-4](#figure9-4) shows the regions that were created along with the
    generators for each region.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-4](#figure9-4)显示了创建的区域以及每个区域的生成器。'
- en: '![](image_fi/502567c09/f09004.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c09/f09004.png)'
- en: 'Figure 9-4: A Voronoi tessellation showing each station’s area of responsibility'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-4：一个Voronoi网格，显示了每个站点的责任区域
- en: The eight regions are divided by the black outlines. The area inside each polygon
    can be viewed as the naive area of responsibility (AOR) for the fire station that
    generated the region. It is naive because it doesn’t take into account obstructions
    (like the water) that might make a different station the better choice to respond.
    Still, the information is a good starting point for you to build on. We can already
    see how the distribution of the stations near the center of the city leaves the
    edge stations with the largest AORs. Visually, the top-left AOR appears to be
    the largest, but we can easily verify this using the `area` parameter, as shown
    in [Listing 9-8](#listing9-8).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 八个区域由黑色轮廓划分。每个多边形内部的区域可以视为生成该区域的消防站的简单责任区域（AOR）。之所以称之为简单，是因为它没有考虑到可能影响响应站点选择的障碍物（例如水体）。尽管如此，这些信息仍然是构建模型的一个良好起点。我们可以看到，位于城市中心附近的消防站分布，使得边缘站点拥有最大的AOR。从视觉上看，左上角的AOR似乎最大，但我们可以使用`area`参数轻松验证这一点，如[Listing
    9-8](#listing9-8)所示。
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 9-8: Finding the largest AOR'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-8：找到最大的AOR
- en: We begin by looping over each shape in the `poly_shapes` variable, iterating
    over the length of the list ❶. Looping this way allows us to keep track of the
    index as the function progresses. There may be cases (albeit unlikely) where more
    than one region has the same area. In such a case, we convert the `winner` variable
    into a list and keep track of the ties ❷. In the more likely scenario, the two
    areas aren’t equal, so we check if the current area is greater than the current
    winning area ❸. If so, we update the `winning` amount and the `winner` index.
    Once all regions have been checked, the `winner` variable will contain one or
    more region indices, which we can use to look up the shape (or shapes) in `poly_shapes`.
    We can also use it to look up the station (or stations) in `poly_to_pt`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先遍历`poly_shapes`变量中的每个形状，按照列表长度进行迭代 ❶。这样迭代可以让我们在函数执行过程中跟踪索引。在一些罕见的情况下，可能会有多个区域具有相同的面积。遇到这种情况时，我们将`winner`变量转换为列表，并跟踪所有平局情况
    ❷。在更常见的情况下，两个区域的面积不相等，因此我们检查当前区域的面积是否大于当前获胜区域的面积 ❸。如果是这样，我们更新`winning`值和`winner`索引。一旦所有区域都被检查过，`winner`变量将包含一个或多个区域索引，我们可以利用这些索引在`poly_shapes`中查找形状（或多个形状）。我们也可以用它来查找`poly_to_pt`中的站点（或多个站点）。
- en: '[Figure 9-5](#figure9-5) shows the region plotted to the map along with the
    station location responsible for it.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-5](#figure9-5)显示了将区域绘制到地图上的结果，以及负责该区域的站点位置。'
- en: '![](image_fi/502567c09/f09005.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502567c09/f09005.png)'
- en: 'Figure 9-5: The largest region and its generator location'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-5：最大区域及其生成器位置
- en: Once again, the darker gray area represents the region of interest and the dark
    gray circle shows the location of the responding fire station. Therefore, you
    could reasonably argue that placing another station somewhere within that region
    would improve response time and resource availability in that area.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，深灰色区域代表了关注区域，而深灰色圆圈显示了响应的消防站位置。因此，你可以合理地认为，在该区域内的某个位置增设一个消防站，将改善该地区的响应时间和资源可用性。
- en: 'You can run the proof-of-concept code by navigating to the chapter’s supplemental
    materials directory and running the *Emergency_service_poc.py* script like so:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过导航到本章的附加材料目录并运行*Emergency_service_poc.py*脚本来运行概念验证代码，方式如下：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once the code finishes loading the data and performing the Voronoi analysis,
    it will open a browser tab to *http://127.0.0.1*, which displays the solution
    using Plotly and the MapBox API.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码完成加载数据并进行Voronoi分析，它将打开一个浏览器标签页，访问*http://127.0.0.1*，该页面通过Plotly和MapBox
    API展示解决方案。
- en: Limitations of the Algorithm
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法的局限性
- en: In this chapter we’ve focused solely on the geographic portion of the problem,
    which is an excellent starting point. The narrow scope does present some limitations,
    though. I’ve already mentioned the limitations of the distance function, but there
    are other factors to consider if you’re asked to make a recommendation like this
    in the real world.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仅专注于问题的地理部分，这是一个很好的起点。然而，这种狭窄的范围确实存在一些局限性。我之前已经提到过距离函数的局限性，但如果你在现实中被要求做出类似的建议，还需要考虑其他因素。
- en: For one, not all fire stations are equipped the same. Some have more trucks,
    some have different types of specialty equipment (like a plane for surveying large
    wooded areas, or a boat for doing harbor patrols), and so on. The diversity of
    equipment means that different stations may be better equipped to handle different
    problems. Putting a specially equipped station in a region where it isn’t needed
    would be a terrible waste of resources. Another problem with the distribution
    of resources is that some stations are more equipped to deal with larger regions.
    For example, a station with a large area but 10 fire trucks at its disposal may
    be able to patrol its region more effectively than a station with a medium-sized
    region but only two trucks. You can improve upon this analysis by adding more
    information about the resources and specializations for the stations. You would
    want to ask your contacts in the city about the equipment plan for the new station
    and then factor that in when creating the Voronoi regions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个问题是，并非所有消防站的装备都相同。有些消防站配备更多的消防车，有些配备不同类型的专业设备（比如用于勘察大面积森林的飞机，或者用于进行港口巡逻的船只）等等。设备的多样性意味着不同的消防站可能更适合处理不同的问题。如果将一座专门装备的消防站设置在不需要这些设备的地区，那将是资源的极大浪费。资源分配的另一个问题是，有些消防站更适合应对较大的区域。例如，一座有着广阔区域且拥有10辆消防车的消防站，可能比一座区域较小但仅有两辆车的消防站更有效地进行巡逻。你可以通过添加更多关于消防站资源和专业化的信息来改进这一分析。在创建Voronoi区域时，你需要向市内相关人员咨询新消防站的装备计划，并将其考虑进分析中。
- en: The final consideration is that fire stations don’t see these boundaries. A
    fire in one region may bring responders from nearby regions as well. The fire
    department does a lot to try to distribute the load for any given area across
    two or more stations so that large fires can be controlled more quickly. The larger
    the fire, the more resources it will take to battle, and therefore it may be necessary
    to direct resources from one region to assist in another. Strictly dividing the
    region into AORs may lead you to suggest a station location that perfectly distributes
    the AORs but nevertheless doesn’t allow the new station to assist the existing
    stations in a meaningful way.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的考虑因素是，消防站并不会看见这些边界。一个地区的火灾可能也会带来来自附近地区的响应人员。消防部门尽力将任何给定区域的负载分配到两个或更多的消防站，以便更快速地控制大型火灾。火灾越大，所需的资源就越多，因此可能需要将一个地区的资源调配到另一个地区来提供帮助。严格划分区域为AORs（责任区域）可能会导致你建议一个完美分配AOR的消防站位置，但仍然无法让新站点在有意义的方式上帮助现有站点。
- en: To avoid this limitation, I suggest performing multiple analyses. For each station
    in the data, you can check how each other station affects its region by removing
    them one at a time from the list and recalculating the regions. This is similar
    to asking, “How would the responsibilities for station A change if station B weren’t
    able to respond?” By overlaying the resulting regions, you’ll see which stations
    take on the most shared responsibility because that region will have the largest
    overall change in area after all the other stations have been removed. A station
    with a lot of shared responsibility may suffer from equipment fatigue or physical
    exhaustion, so you may suggest that another station located somewhere closer to
    the overworked station could distribute the load better. Again, the station with
    the most shared responsibilities may have the proper equipment and personnel to
    handle the extra work.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个局限性，我建议进行多次分析。对于数据中的每个站点，你可以通过一次移除一个站点并重新计算区域，检查其他站点如何影响其所在区域。这类似于在问，“如果站点B无法响应，站点A的职责将如何变化？”通过叠加结果区域，你将看到哪些站点承担了更多的共享责任，因为该区域在移除所有其他站点后，其面积变化最大。一个承担了大量共享责任的站点可能会遭受设备疲劳或身体疲惫，因此你可以建议将位于过度负担站点附近的其他站点调动，以更好地分配负载。同样，承担最多共享责任的站点可能拥有合适的设备和人员来处理额外的工作。
- en: All of this is meant to show you that, although Voronoi diagrams are extremely
    useful, they’re not always the final answer. As with all analyses, the more accuracy
    and detail you add to your model, the more applicable the results will be to the
    real world. When performing any type of resource analysis, it’s just as important
    to understand how those resources interact with their region as with each other.
    Doing so will allow you to make intelligent choices for your model and overcome
    some of the limitations of this basic framework.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些内容旨在向你展示，尽管Voronoi图非常有用，但它们并不总是最终的答案。与所有分析一样，你对模型添加的准确性和细节越多，结果在现实世界中的适用性就越强。在进行任何类型的资源分析时，了解这些资源如何与其所在区域以及彼此之间相互作用同样重要。这样做将使你能够为模型做出明智的选择，并克服这一基本框架的一些局限性。
- en: Summary
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve covered one of the most famous computational geometry
    algorithms, the Voronoi tessellation. We’ve seen how it can be applied to real-world
    problems related to the distribution of resources and how it can be scaled to
    fit the problem. We’ve also discussed some of the limitations to this implementation
    and ways you can improve upon it yourself. My hope is that you’ll take this framework
    and expand upon it to suit your own projects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了最著名的计算几何算法之一——Voronoi镶嵌。我们看到它如何应用于与资源分布相关的现实问题，并且如何根据问题的需求进行扩展。我们还讨论了该实现的一些局限性，以及你可以自行改进的方式。我希望你能将这个框架加以拓展，以适应你自己的项目。
- en: There’s a lot of excellent research material available on the different applications
    of these tessellations, from security to neurology and everywhere in between.
    I recommend you read the research paper “Rationalizing Police Patrol Beats Using
    Voronoi Tessellations”^([2](b01.xhtml#c09-endnote-002)) for another example of
    applying this analysis to improve emergency services. As a security analyst, you’ll
    find plenty of opportunities to show off your resource distribution knowledge.
    In the final part of the book, we’ll revisit tessellations to plan the distribution
    of security resources for the art gallery problem.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量优秀的研究材料，涉及这些镶嵌的不同应用，从安全到神经学，涵盖了所有领域。我建议你阅读研究论文《使用Voronoi镶嵌合理化警察巡逻区域》^([2](b01.xhtml#c09-endnote-002))，这是另一个将此分析应用于改善紧急服务的例子。作为安全分析员，你会发现许多机会来展示你的资源分布知识。在本书的最后部分，我们将重新审视镶嵌，以规划艺术画廊问题的安全资源分布。
- en: In the next chapter, we’ll conclude our look into the world of computational
    geometry for security with one of my favorite projects of all time, facial recognition
    systems. Although the size and geometry are drastically different from anything
    we’ve dealt with so far, the basic ideas are the same. We’ll continue to use Shapely
    to handle the geometry, but now we’ll add some machine learning to the mix, giving
    us the tools needed to build the highly sophisticated analysis required to recognize
    facial features programmatically.*
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将通过我最喜欢的项目之一——人脸识别系统，来总结我们对计算几何在安全领域应用的探索。尽管其规模和几何结构与我们迄今为止处理的任何内容截然不同，但基本思想是相同的。我们将继续使用Shapely来处理几何部分，但现在我们将加入一些机器学习的元素，这将为我们提供所需的工具，以便构建实现面部特征程序化识别所需的高度复杂分析。*
