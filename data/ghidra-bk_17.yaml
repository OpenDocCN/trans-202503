- en: '## **14'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **14'
- en: Basic Ghidra Scripting**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础 Ghidra 脚本编写**'
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: No application can meet every need of every user. It is just not possible to
    anticipate every potential use case that may arise. Ghidra’s open source model
    facilitates feature requests and innovative contributions by developers. However,
    sometimes you need to immediately address a problem at hand and can’t wait for
    someone else to implement new functionality. To support unanticipated use cases
    and programmatic control of Ghidra’s actions, Ghidra includes integrated scripting
    features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何应用程序能够满足每个用户的所有需求。这是因为无法预见所有可能出现的使用情况。Ghidra 的开源模型鼓励开发者提出功能请求并进行创新贡献。然而，有时你需要立即解决眼前的问题，而不能等待其他人实现新功能。为了支持无法预见的使用案例和对
    Ghidra 操作的程序化控制，Ghidra 包含了集成脚本功能。
- en: Uses for scripts are infinite and can range from simple one-liners to full-blown
    programs that automate common tasks or perform complex analysis. In this chapter,
    we focus on the basic scripting that is provided through the CodeBrowser interface.
    We introduce the internal scripting environment, discuss script development using
    Java and Python, and then move on to other integrated scripting options in [Chapter
    15](ch15.xhtml#ch15).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的用途是无穷无尽的，既可以是简单的单行代码，也可以是完整的程序，自动化常见任务或执行复杂分析。本章我们将重点介绍通过 CodeBrowser 界面提供的基本脚本编写。我们将介绍内部脚本环境，讨论如何使用
    Java 和 Python 开发脚本，接着进入 [第15章](ch15.xhtml#ch15)中讨论的其他集成脚本选项。
- en: '### **Script Manager**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### **脚本管理器**'
- en: The Ghidra Script Manager is available through the CodeBrowser menu. Choosing
    Window ▸ Script Manager opens the window shown in [Figure 14-1](ch14.xhtml#fig14_1).
    The window can also be opened using the Script Manager icon in the CodeBrowser
    toolbar (a green circle with an arrow inside, also shown in the top left of the
    Script Manager window).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 脚本管理器可以通过 CodeBrowser 菜单访问。选择“窗口 ▸ 脚本管理器”会打开如 [图14-1](ch14.xhtml#fig14_1)
    所示的窗口。也可以通过 CodeBrowser 工具栏中的脚本管理器图标（一个绿色圆圈，内有箭头，也出现在脚本管理器窗口的左上角）来打开该窗口。
- en: '![image](Images/fig14-1.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig14-1.jpg)'
- en: '*Figure 14-1: Script Manager window*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-1：脚本管理器窗口*'
- en: '***Script Manager Window***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***脚本管理器窗口***'
- en: In a new Ghidra installation, the Script Manager loads with over 240 scripts
    organized in a category tree, as seen on the left side of [Figure 14-1](ch14.xhtml#fig14_1).
    Some of the folders contain subfolders to provide even more detailed classification
    of the scripts. You can expand and collapse the folders to see the organization
    of the scripts. Selecting an individual folder or subfolder limits the display
    to the scripts within the selected folder. To populate this window, Ghidra locates
    and indexes all scripts in subdirectories named *ghidra_scripts* within the Ghidra
    distribution folder. Ghidra also looks for a *ghidra_scripts* directory within
    your home directory and indexes any scripts it finds there.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在全新安装的 Ghidra 中，脚本管理器加载时会包含超过 240 个脚本，这些脚本按类别树进行组织，如 [图14-1](ch14.xhtml#fig14_1)
    左侧所示。部分文件夹内包含子文件夹，以便对脚本进行更详细的分类。你可以展开或折叠这些文件夹，查看脚本的组织结构。选择一个文件夹或子文件夹将只显示该文件夹中的脚本。为了填充这个窗口，Ghidra
    会在 Ghidra 安装目录中的 *ghidra_scripts* 子目录内查找并索引所有脚本。Ghidra 还会查找用户主目录下的 *ghidra_scripts*
    目录，并索引其中的脚本。
- en: 'The default set of scripts covers a wide range of functionality. Some of the
    scripts are intended to demonstrate fundamental scripting concepts. The columns
    in the script list table provide additional detail about the purpose of each script.
    As with most Ghidra tables, you can control which columns are displayed as well
    as the sort order for individual columns. By default, all available fields for
    the table are displayed except Created and Path. The six information columns provide
    the following insight into a script:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的脚本集覆盖了广泛的功能。一些脚本旨在演示基本的脚本概念。脚本列表表格中的列提供了关于每个脚本用途的更多细节。与大多数 Ghidra 表格一样，你可以控制显示哪些列以及各列的排序方式。默认情况下，所有可用的字段都会显示，除了“创建时间”和“路径”之外。六个信息列为脚本提供了以下详细信息：
- en: '**Status** Indicates the status of the script. The field is generally blank
    but can contain a red icon to indicate an error in the script. If you have associated
    a toolbar icon with the script, the icon will appear in this column.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态** 显示脚本的状态。该字段通常为空，但可以显示一个红色图标，表示脚本中有错误。如果你已将工具栏图标与脚本关联，该图标将显示在这一列。'
- en: '**Name** Contains the filename of the script, including its extension.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称** 包含脚本的文件名及其扩展名。'
- en: '**Description** A description pulled from the metadata comment within the script.
    This field can be quite lengthy, but you can read the entire contents by hovering
    over the field. This field is discussed in more depth in “[Script Development](ch14.xhtml#ch14lev234)”
    on [page 289](ch14.xhtml#page_289).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**描述** 从脚本中的元数据注释提取的描述。该字段可能非常长，但您可以通过悬停在字段上阅读完整内容。该字段在“[脚本开发](ch14.xhtml#ch14lev234)”一节中有更详细的讨论，详见[第289页](ch14.xhtml#page_289)。'
- en: '**Key** Indicates if there is a key binding assigned for running the script.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**键** 指示是否为运行该脚本分配了键绑定。'
- en: '**Category** Specifies the path at which the script will be listed in the Script
    Manager’s topic hierarchy. This is a logical hierarchy, *not* a filesystem directory
    hierarchy.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**类别** 指定脚本将在脚本管理器的主题层次结构中列出的路径。这是一个逻辑层次结构，*不是*文件系统目录层次结构。'
- en: '**Modified** The date the script was last saved. For the default scripts the
    date is the installation date of the Ghidra instance.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**已修改** 脚本最后保存的日期。对于默认脚本，日期为Ghidra实例的安装日期。'
- en: The filter field on the left side of the window searches through the script
    categories. The filter on the right searches the script names and descriptions.
    Finally, at the bottom, an additional window is initially empty. This window displays
    metadata about a selected script in an easy-to-process format that includes the
    field extracted from the metadata within the script. The format and meaning of
    the metadata fields are discussed in “[Writing Java Scripts (Not JavaScript!)](ch14.xhtml#ch14lev235)”
    on [page 289](ch14.xhtml#page_289).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口左侧的过滤器字段用于在脚本类别中进行搜索。右侧的过滤器用于搜索脚本的名称和描述。最后，在底部，还有一个最初为空的额外窗口。该窗口以易于处理的格式显示所选脚本的元数据，包括从脚本中的元数据提取的字段。元数据字段的格式和含义在“[编写Java脚本（不是JavaScript！）](ch14.xhtml#ch14lev235)”一节中讨论，详见[第289页](ch14.xhtml#page_289)。
- en: While the Script Manager provides a significant amount of information, the main
    power of this window comes from the toolbar it provides. An overview of the toolbar
    is provided in [Figure 14-2](ch14.xhtml#fig14_2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然脚本管理器提供了大量的信息，但此窗口的主要功能来自于其提供的工具栏。工具栏的概述请参见[图 14-2](ch14.xhtml#fig14_2)。
- en: '***Script Manager Toolbar***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***脚本管理器工具栏***'
- en: The Script Manager has no menus to help you manage your scripts. Instead, all
    script management actions are associated with tools on the Script Manager toolbar
    ([Figure 14-2](ch14.xhtml#fig14_2)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本管理器没有菜单来帮助您管理脚本。相反，所有的脚本管理操作都与脚本管理器工具栏上的工具相关联（见[图 14-2](ch14.xhtml#fig14_2)）。
- en: While most of the menu options are pretty clear from the descriptions in [Figure
    14-2](ch14.xhtml#fig14_2), the Edit options merit additional discussion. Editing
    with Eclipse is covered in [Chapter 15](ch15.xhtml#ch15), as it facilitates more
    advanced scripting capabilities. The Edit Script option opens a primitive text
    editor window with its own toolbar, shown in [Figure 14-3](ch14.xhtml#fig14_3).
    The associated actions provide the basic functionality for editing files. With
    an editor in hand, we can get down to the business of writing actual scripts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大部分菜单选项从[图 14-2](ch14.xhtml#fig14_2)中的描述来看都比较清晰，但编辑选项值得额外讨论。Eclipse中的编辑功能在[第15章](ch15.xhtml#ch15)中有所介绍，因为它支持更高级的脚本功能。编辑脚本选项会打开一个原始的文本编辑器窗口，并带有自己的工具栏，如[图
    14-3](ch14.xhtml#fig14_3)所示。相关的操作提供了编辑文件的基本功能。有了编辑器，我们可以开始编写实际的脚本。
- en: '![image](Images/fig14-2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig14-2.jpg)'
- en: '*Figure 14-2: Script Manager toolbar*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2: 脚本管理器工具栏*'
- en: '![image](Images/fig14-3.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig14-3.jpg)'
- en: '*Figure 14-3: Edit Script toolbar*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3: 编辑脚本工具栏*'
- en: '### **Script Development**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '### **脚本开发**'
- en: There are several methods for developing scripts within Ghidra. In this chapter,
    we focus on scripting using Java and Python, as these are languages used by the
    existing scripts in the Script Manager window. Most of the 240+ system scripts
    are written in Java, so we begin with editing and developing scripts in Java.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ghidra中开发脚本有几种方法。本章重点介绍使用Java和Python编写脚本，因为这些语言是脚本管理器窗口中现有脚本所使用的语言。超过240个系统脚本大多是用Java编写的，因此我们将从编辑和开发Java脚本开始。
- en: '***Writing Java Scripts (Not JavaScript!)***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写Java脚本（不是JavaScript！）***'
- en: In Ghidra, a script written in Java is actually a complete class specification
    designed to be seamlessly compiled, dynamically loaded into your running Ghidra
    instance, invoked, and finally unloaded. The class must extend the class `Ghidra.app.script.GhidraScript`,
    implement a `run()` method, and be annotated with comments that provide Javadoc-format
    metadata about the script. We’ll show the structure of a script file, describe
    the metadata requirements, look at some of the system scripts, and then move on
    to editing existing scripts and building our own scripts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ghidra 中，使用 Java 编写的脚本实际上是一个完整的类规范，旨在无缝编译、动态加载到运行中的 Ghidra 实例中、调用并最终卸载。该类必须扩展类`Ghidra.app.script.GhidraScript`，实现`run()`方法，并使用注释提供有关脚本的
    Javadoc 格式元数据。我们将展示脚本文件的结构，描述元数据要求，查看一些系统脚本，然后继续编辑现有脚本并构建我们自己的脚本。
- en: '[Figure 14-4](ch14.xhtml#fig14_4) shows the script editor opened when the Create
    New Script option (refer to [Figure 14-2](ch14.xhtml#fig14_2)) is selected to
    create a new Java script. We have named the new script *CH14_NewScript*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-4](ch14.xhtml#fig14_4)显示了选择“创建新脚本”选项（参见[图 14-2](ch14.xhtml#fig14_2)）时打开的脚本编辑器，用于创建新的
    Java 脚本。我们将新脚本命名为*CH14_NewScript*。'
- en: '![image](Images/fig14-4.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig14-4.jpg)'
- en: '*Figure 14-4: A new, empty script*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：一个新的空脚本*'
- en: 'At the top of the file are the metadata comments and tags used to produce the
    expected Javadoc information. This information is also used to populate the fields
    in the Script Manager window (refer to [Figure 14-1](ch14.xhtml#fig14_1)). Any
    comments starting with `//` before the class, field, or method declarations will
    become part of the Javadoc Description for the script. Additional comments can
    be embedded within the script and will not be included in the description. In
    addition, the following tags within the metadata comments are supported:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 文件顶部是用于生成预期 Javadoc 信息的元数据注释和标签。这些信息也用于填充脚本管理器窗口中的字段（参见[图 14-1](ch14.xhtml#fig14_1)）。任何在类、字段或方法声明之前以`//`开头的注释将成为脚本的
    Javadoc 描述的一部分。额外的注释可以嵌入脚本中，并且不会包含在描述中。此外，以下元数据注释中的标签是支持的：
- en: '@author Provides information about the author of the script. The information
    is provided at the discretion of the author and can include any pertinent details
    (for example, name, contact information, date of creation, and so on).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '@author 提供有关脚本作者的信息。该信息由作者自行决定，可以包括任何相关细节（例如，姓名、联系信息、创建日期等）。'
- en: '@category Determines where the script appears within the category tree. This
    is the only mandatory tag and must be present in all Ghidra scripts. The period
    (dot) character acts as a path separator for category names (for example, `@category
    Ghidrabook.CH14`).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '@category 确定脚本在类别树中的位置。这是唯一的强制标签，必须在所有 Ghidra 脚本中存在。句点（点）字符充当类别名称的路径分隔符（例如，`@category
    Ghidrabook.CH14`）。'
- en: '@keybinding Documents a shortcut for accessing the script from the CodeBrowser
    window (for example, `@keybinding K`).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '@keybinding 记录用于从 CodeBrowser 窗口访问脚本的快捷键（例如，`@keybinding K`）。'
- en: '@menupath Defines a period-delimited menu path for the script as well as provides
    a means to run the script from a CodeBrowser menu (for example, `@menupath File.Run.ThisScript`).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '@menupath 定义脚本的菜单路径，并提供一种从 CodeBrowser 菜单运行脚本的方式（例如，`@menupath File.Run.ThisScript`）。'
- en: '@toolbar Associates an icon with the script. This icon is displayed as a toolbar
    button in the CodeBrowser window and may be used to run the script. If Ghidra
    cannot find the image in the script directory or the Ghidra installation, a default
    image will be used (for example, `@toolbar myImage.png`).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '@toolbar 为脚本关联一个图标。此图标显示为 CodeBrowser 窗口中的工具栏按钮，可用于运行脚本。如果 Ghidra 在脚本目录或 Ghidra
    安装中找不到图像，将使用默认图像（例如，`@toolbar myImage.png`）。'
- en: When confronted with a new API (such as the Ghidra API), it may take some time
    before you’re comfortable writing scripts without constantly consulting available
    API documentation. Java in particular is very sensitive to classpath issues and
    the proper inclusion of required support packages. A time- and sanity-saving option
    is to edit an existing program rather than creating a new program. We adopt this
    approach in presenting a simple example of a script.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到一个新的 API（如 Ghidra API）时，可能需要一些时间才能在不不断查阅 API 文档的情况下编写脚本。尤其是 Java 对类路径问题和正确包含所需支持包非常敏感。一个节省时间和精力的选择是编辑现有程序，而不是创建一个新程序。我们在展示脚本的简单示例时采用了这种方法。
- en: '***Edit Script Example: Regex Search***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编辑脚本示例：正则表达式搜索***'
- en: Assume that you are tasked with developing a script to accept a regular expression
    as input from the user and output matching strings to the console. Further, this
    script needs to appear in the Script Manager for a particular project. While Ghidra
    offers many ways to accomplish this task, you have been asked to produce a script.
    To find a script with similar functionality to use as a base, you look through
    the categories in the Script Manager and check the contents of the Strings and
    Search categories, and then filter for the term *strings* and find other options.
    Using filters produces a more comprehensive list of string-related scripts for
    your consideration. For this example, you will edit the first script in the list
    that shares some functionality with what you want your script to do—*CountAndSaveStrings.java*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的任务是开发一个脚本，接受用户输入的正则表达式并将匹配的字符串输出到控制台。此外，脚本需要在特定项目的脚本管理器中显示。虽然 Ghidra 提供了多种方法来完成这个任务，但你被要求编写一个脚本。为了找到一个具有相似功能的脚本作为基础，你查看了脚本管理器中的类别，检查了“字符串”和“搜索”类别的内容，然后筛选出包含
    *strings* 的选项。使用筛选器可以提供一个更全面的与字符串相关的脚本列表供你参考。在这个示例中，你将编辑列表中第一个与要实现功能相似的脚本——*CountAndSaveStrings.java*。
- en: Open the script in the editor to confirm that it’s a good starting point for
    our new functionality by right-clicking the desired script and selecting **Edit**
    with basic editor; then save this script with the new name, *FindStringsByRegex.java*,
    using the **Save As** option. Ghidra does not allow you to edit the system scripts
    provided as part of your Ghidra installation within the Script Manager window
    (although you can in Eclipse and other editors). You could also edit the file
    prior to using Save As since Ghidra prevents you from accidentally writing any
    modified content to the existing *CountAndSaveStrings.java* script.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中打开脚本，通过右键点击所需脚本并选择 **编辑**（使用基本编辑器）来确认它是否是我们新功能的良好起点；然后使用 **另存为** 选项保存该脚本并将其命名为
    *FindStringsByRegex.java*。Ghidra 不允许你在脚本管理器窗口中编辑作为 Ghidra 安装一部分提供的系统脚本（尽管你可以在
    Eclipse 和其他编辑器中编辑）。你也可以在使用“另存为”之前编辑该文件，因为 Ghidra 会防止你不小心将任何修改后的内容写入现有的 *CountAndSaveStrings.java*
    脚本。
- en: 'The original *CountAndSaveStrings.java* contains the following metadata:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 *CountAndSaveStrings.java* 包含以下元数据：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can leave, modify, or delete the licensing agreement ➊ for the script without
    impacting the execution of the script or the associated Javadoc. We’ll modify
    the description of the script ➋ so that the information displayed in Javadoc and
    the Script Manager accurately describes the script. The script author has included
    only one of the five available tags ➌, so we’ll add placeholders for the unpopulated
    tags and revise the description, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在不影响脚本执行或关联 Javadoc 的情况下，留下、修改或删除脚本的许可协议➊。我们将修改脚本的描述➋，以便 Javadoc 和脚本管理器中显示的信息能够准确描述该脚本。脚本作者只包含了五个可用标签中的一个➌，因此我们将为未填充的标签添加占位符，并修改描述，如下所示：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The category tag `Ghidrabook.CH14` will be added to the Script Manager’s tree
    display, as shown in [Figure 14-5](ch14.xhtml#fig14_5).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类别标签 `Ghidrabook.CH14` 将添加到脚本管理器的树状显示中，如[图 14-5](ch14.xhtml#fig14_5)所示。
- en: 'The next portion of the original script contains Java `import` statements.
    Of the long list of imports Ghidra includes when you create a new script, as shown
    in [Figure 14-4](ch14.xhtml#fig14_4), only the following imports are necessary
    for string searching, so we’ll keep the same list as the original *CountAndSaveStrings.java*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 原始脚本的下一部分包含 Java `import` 语句。在创建新脚本时，Ghidra 会包含一个长列表的导入，如[图 14-4](ch14.xhtml#fig14_4)所示，只有以下导入对字符串搜索是必要的，因此我们将保留与原始
    *CountAndSaveStrings.java* 相同的导入列表：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the new script and then select it in the Script Manager to see the content
    shown in [Figure 14-5](ch14.xhtml#fig14_5). Our new category is included in the
    script tree, and the script’s metadata is displayed in the information window
    and script table. The table contains only one script, *Ghidrabook.CH14*, as it
    is the only script in the selected category.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 保存新脚本后，然后在脚本管理器中选择它，以查看[图 14-5](ch14.xhtml#fig14_5)中显示的内容。我们的新类别已包含在脚本树中，脚本的元数据显示在信息窗口和脚本表格中。该表格只包含一个脚本，*Ghidrabook.CH14*，因为它是所选类别中唯一的脚本。
- en: '![image](Images/fig14-5.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig14-5.jpg)'
- en: '*Figure 14-5: New script information displayed in the Script Manager window*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：脚本管理器窗口中显示的新脚本信息*'
- en: 'As this book is not intended to be a Java tutorial, we summarize the changes
    we made to the script rather than explaining Java syntax and functionality. The
    following list describes the behavior of *CountAndSaveStrings.java*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书并非旨在作为Java教程，我们将总结我们对脚本所做的更改，而不是解释Java的语法和功能。以下列表描述了*CountAndSaveStrings.java*的行为：
- en: Get the program listing content to search.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取程序列表内容以进行搜索。
- en: Get the file to save results to.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取文件以保存结果。
- en: Open the file.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件。
- en: 'Iterate through the program listing: count the number of qualifying strings
    and write each qualifying string to the file.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历程序列表：统计符合条件的字符串数量，并将每个符合条件的字符串写入文件。
- en: Close the file.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭文件。
- en: Write the number of qualifying strings to the console.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将符合条件的字符串的数量写入控制台。
- en: 'The functionality we desire in our modified script is described next:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需的修改脚本的功能如下：
- en: Get the program listing content to search.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取程序列表内容以进行搜索。
- en: Ask the user for a regular expression (regex) to search for.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向用户询问要搜索的正则表达式（regex）。
- en: 'Iterate through the program listing: count the number of qualifying strings
    and write each qualifying string to the console.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历程序列表：统计符合条件的字符串数量，并将每个符合条件的字符串写入控制台。
- en: Write the number of qualifying strings to the console.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将符合条件的字符串的数量写入控制台。
- en: 'Our new script will be significantly shorter than the original script, as there
    is no need to interact with the filesystem and perform associated error checking.
    Our implementation follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新脚本将比原始脚本短得多，因为不再需要与文件系统交互以及执行相关的错误检查。我们的实现如下：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All Java scripts that you write for Ghidra must extend (inherit from) an existing
    class named `Ghidra.app.script.GhidraScript` ➊. After saving the final version
    of the script, select it from within the Script Manager and execute it. When the
    script executes, we see the prompt shown in [Figure 14-6](ch14.xhtml#fig14_6).
    This figure includes the regular expression that we will be searching for to test
    our script.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有你为Ghidra编写的Java脚本必须继承（扩展）一个名为`Ghidra.app.script.GhidraScript`的现有类➊。保存脚本的最终版本后，从脚本管理器中选择并执行它。当脚本执行时，我们可以看到在[图14-6](ch14.xhtml#fig14_6)中显示的提示。此图包含我们将要搜索的正则表达式，以测试我们的脚本。
- en: '![image](Images/fig14-6.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig14-6.jpg)'
- en: '*Figure 14-6: New script prompt to enter a regex*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：输入正则表达式的新脚本提示*'
- en: 'The CodeBrowser console displays the following content when our new script
    has completed execution:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的新脚本执行完成后，CodeBrowser控制台将显示以下内容：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This simple example demonstrates the low barrier to entry of Ghidra’s extensive
    Java scripting capabilities. Existing scripts can be easily modified and new scripts
    can be built from the ground up using the Script Manager. We present some more
    complex Java scripting capabilities in [Chapters 15](ch15.xhtml#ch15) and [16](ch16.xhtml#ch16),
    but Java is just one of the scripting options provided by Ghidra. Ghidra also
    allows you to author scripts in Python.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例展示了Ghidra广泛的Java脚本功能的低门槛。现有脚本可以很容易地修改，新的脚本可以通过脚本管理器从零开始构建。在[第15章](ch15.xhtml#ch15)和[第16章](ch16.xhtml#ch16)中，我们展示了一些更复杂的Java脚本功能，但Java只是Ghidra提供的脚本选项之一。Ghidra还允许你使用Python编写脚本。
- en: '#### ***Python Scripts***'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***Python脚本***'
- en: Of the 240+ scripts in the Script Manager, only a handful are written in Python.
    You can easily locate the Python scripts by filtering for the *.py* extension
    in the Script Manager. The majority of the Python scripts can be found in the
    Examples.Python category in the tree and includes a disclaimer similar to the
    one shown in [Figure 14-7](ch14.xhtml#fig14_7).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本管理器中的240多个脚本中，只有少数是用Python编写的。你可以通过在脚本管理器中过滤*.py*扩展名来轻松找到Python脚本。大多数Python脚本可以在树形结构中的Examples.Python类别下找到，并且包含类似于[图14-7](ch14.xhtml#fig14_7)中所示的免责声明。
- en: '![image](Images/fig14-7.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig14-7.jpg)'
- en: '*Figure 14-7: Sample Python script with disclaimer*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：带免责声明的示例Python脚本*'
- en: 'Of the examples in this directory, the following three provide a good starting
    point if you prefer to use Python:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在此目录中的示例中，以下三个示例是如果你更喜欢使用Python，提供了一个很好的起点：
- en: '***ghidra_basic.py*** This script includes examples of basic Python scripting
    as related to Ghidra.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '***ghidra_basic.py*** 这个脚本包含与Ghidra相关的基本Python脚本示例。'
- en: '***python_basics.py*** This is a very basic introduction to many of the Python
    commands that you might want to use.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '***python_basics.py*** 这是对你可能想使用的许多Python命令的一个非常基础的介绍。'
- en: '***jython_basic.py*** This extends the basic Python commands to demonstrate
    content that is specific to Jython.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '***jython_basic.py*** 该脚本扩展了基础 Python 命令，展示了特定于 Jython 的内容。'
- en: The Ghidra features demonstrated in these examples barely scratch the surface
    of the available Ghidra APIs. You’ll likely still need to spend some time reading
    through Ghidra’s library of Java examples before you’ll be ready to access Ghidra’s
    full Java API from your Python scripts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中展示的 Ghidra 功能仅仅触及了 Ghidra API 的表面。你可能仍然需要花些时间阅读 Ghidra 的 Java 示例库，才能准备好通过你的
    Python 脚本访问 Ghidra 的完整 Java API。
- en: In addition to running Python scripts, Ghidra provides the Python Interpreter
    to allow you to use Python/Jython to directly access the Java objects associated
    with Ghidra, as shown in [Figure 14-8](ch14.xhtml#fig14_8).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了运行 Python 脚本外，Ghidra 还提供了 Python 解释器，使你能够使用 Python/Jython 直接访问与 Ghidra 相关的
    Java 对象，如 [图 14-8](ch14.xhtml#fig14_8) 所示。
- en: '**GHIDRA’S PYTHON FUTURE**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**GHIDRA 的 Python 未来**'
- en: Python is popular for creating scripts because of its simplicity and numerous
    available libraries. While the majority of the scripts in the Ghidra release are
    written in Java, the open source RE community likely will use Python as a primary
    scripting language within Ghidra. Ghidra is reliant on Jython for Python support
    (which provides the advantage of allowing direct access to Ghidra’s Java objects).
    Jython is compatible with Python 2 (specifically 2.7.1) but not Python 3\. Although
    Python 2 went end-of-life in January 2020, Python 2 scripts will continue to function
    within Ghidra, and any new Ghidra Python 2 scripts should be written in a way
    that makes them as portable as possible to Python 3.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Python 因其简洁性和众多可用库而广受欢迎，成为创建脚本的首选语言。尽管 Ghidra 发布版中的大多数脚本是用 Java 编写的，但开源的逆向工程社区很可能会在
    Ghidra 中使用 Python 作为主要脚本语言。Ghidra 依赖 Jython 来支持 Python（这使得可以直接访问 Ghidra 的 Java
    对象）。Jython 与 Python 2（特别是 2.7.1）兼容，但不支持 Python 3。尽管 Python 2 在 2020 年 1 月停止了生命周期，但
    Python 2 脚本在 Ghidra 中仍然能够正常运行，任何新的 Ghidra Python 2 脚本应尽可能地以便于迁移到 Python 3 的方式编写。
- en: '![image](Images/fig14-8.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig14-8.jpg)'
- en: '*Figure 14-8: Python Interpreter* print *example*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：Python 解释器* 打印 *示例*'
- en: The Python Interpreter is accessible through the CodeBrowser by selecting Windows
    ▸ Python. For more information about using the interpreter, see Ghidra Help. To
    get API information when using Python and the Python Interpreter, choose Help
    ▸ Ghidra API Help at the top left of the Interpreter window shown in [Figure 14-8](ch14.xhtml#fig14_8),
    which opens the Javadoc content on the `GhidraScript` class. Alternatively, Python
    has a built-in function, `help( )`, that has been modified in Ghidra to provide
    direct access to Ghidra’s Javadoc. To use the function, type `help(`object`)`
    in the interpreter, as shown in [Figure 14-9](ch14.xhtml#fig14_9). For example,
    `help(currentProgram)` displays the Ghidra Javadoc content describing the Ghidra
    API class `ProgramDB`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 CodeBrowser 可以访问 Python 解释器，选择 Windows ▸ Python。有关如何使用解释器的更多信息，请参见 Ghidra
    帮助。在使用 Python 和 Python 解释器时，要获取 API 信息，请选择解释器窗口左上角的帮助 ▸ Ghidra API 帮助，如 [图 14-8](ch14.xhtml#fig14_8)
    所示，这将打开 `GhidraScript` 类的 Javadoc 内容。或者，Python 有一个内置函数 `help( )`，在 Ghidra 中已经被修改，可以直接访问
    Ghidra 的 Javadoc。要使用该功能，在解释器中键入 `help(`object`)`，如 [图 14-9](ch14.xhtml#fig14_9)
    所示。例如，`help(currentProgram)` 显示 Ghidra Javadoc 内容，描述了 Ghidra API 类 `ProgramDB`。
- en: '![image](Images/fig14-9.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig14-9.jpg)'
- en: '*Figure 14-9: Python Interpreter Help example*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：Python 解释器帮助示例*'
- en: '***Support for Other Languages***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***对其他语言的支持***'
- en: Finally, Ghidra can support scripts from languages other than Java and Python,
    which lets you bring existing scripts from your reverse engineering toolkit into
    your Ghidra workflow. This functionality is discussed further in Ghidra Help.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Ghidra 支持来自 Java 和 Python 以外的其他语言的脚本，这使你能够将现有的脚本从你的逆向工程工具包中带入 Ghidra 的工作流程中。这个功能在
    Ghidra 帮助中有更详细的讨论。
- en: '**Introduction to the Ghidra API**'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Ghidra API 介绍**'
- en: At this point, you have all the information required to edit and run Ghidra
    scripts. Now it’s time to use the Ghidra API to extend your scripting capabilities
    and interact more directly with Ghidra artifacts. Ghidra exposes its API in two
    rather different styles.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你已经掌握了编辑和运行 Ghidra 脚本所需的所有信息。现在是时候使用 Ghidra API 来扩展你的脚本功能，并更直接地与 Ghidra 文物进行交互了。Ghidra
    提供了两种截然不同的 API 风格。
- en: The *Program* API defines an object hierarchy, many levels deep, rooted at the
    top by the `Program` class. This API may change from one version of Ghidra to
    another. The *Flat* API flattens out the Program API by exposing all levels of
    that API from a single class, `FlatProgramAPI`. The Flat API is often the most
    convenient way to access many Ghidra constructs. Additionally, it is less likely
    to change from one version of Ghidra to the next.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*Program* API定义了一个对象层次结构，深度多层，最上层由`Program`类根本。这一API可能会随着Ghidra的版本不同而有所变化。*Flat*
    API通过暴露该API的所有层级，统一从一个类`FlatProgramAPI`中访问，从而将Program API进行扁平化。Flat API通常是访问许多Ghidra构造的最便捷方式。此外，它比Program
    API更不容易随着Ghidra版本的更新而发生变化。'
- en: For the remainder of the chapter, we highlight some of the more useful Flat
    API functionality. When necessary, we also provide detail about specific classes
    from the Program API. We use Java as the language for this discussion, as it is
    the native language of Ghidra.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将重点介绍一些更有用的Flat API功能。在必要时，我们还会提供有关Program API中特定类的详细信息。我们使用Java作为本讨论的语言，因为它是Ghidra的原生语言。
- en: The Ghidra API contains many packages, classes, and associated functions to
    interface with your Ghidra projects and associated files, all detailed in Javadoc-style
    documentation supplied with Ghidra that can be accessed by clicking the red plus
    in the Script Manager window. This documentation, in conjunction with the sample
    scripts supplied with Ghidra, is your primary reference about the APIs and how
    to use them. The most common way to figure out how to do something is to browse
    the Ghidra classes looking for one that, based on its name, appears to do what
    you need. As you gain more experience with Ghidra, your increased understanding
    of the naming conventions and file organization will help you identify appropriate
    classes more quickly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra API包含许多包、类及其相关函数，用于与Ghidra项目和相关文件交互，所有这些内容都在随Ghidra提供的Javadoc风格文档中详细说明，可以通过点击脚本管理器窗口中的红色加号访问。该文档与随Ghidra提供的示例脚本一起，是你了解API及其使用方法的主要参考资料。最常见的做法是浏览Ghidra类，查找那些从名称上看似乎能完成你需要的任务的类。随着你对Ghidra的理解不断加深，你对命名约定和文件组织结构的理解将帮助你更快地识别出合适的类。
- en: Ghidra adheres to the Java Swing *model-delegate* architecture in which data
    values and characteristics are stored in model objects and displayed by user interface
    delegate objects such as tree, list, and table views. Delegates handle events,
    such as mouse clicks, to update and refresh data and views. In the overwhelming
    majority of cases, your scripts will focus on the data encapsulated in the model
    classes used to represent various program and reverse engineering constructs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra遵循Java Swing的*模型-委托*架构，其中数据值和特性存储在模型对象中，并由用户界面委托对象（如树视图、列表视图和表格视图）显示。委托对象处理事件，例如鼠标点击，来更新和刷新数据和视图。在绝大多数情况下，你的脚本将集中在表示各种程序和逆向工程构造的模型类所封装的数据上。
- en: The remainder of this section focuses on commonly used model classes, their
    relationships to each other, and useful APIs for interacting with them. We make
    no attempt to cover the entire Ghidra API, and many more functions and classes
    are available. The authoritative documentation for the entire Ghidra API is the
    Javadoc that ships with Ghidra, and ultimately the Java source code from which
    Ghidra is built.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分集中介绍常用的模型类、它们之间的关系，以及与之交互的有用API。我们并不打算涵盖整个Ghidra API，实际上还有许多其他的函数和类可以使用。整个Ghidra
    API的权威文档是随Ghidra提供的Javadoc，最终的参考资料是构建Ghidra的Java源代码。
- en: '***The Address Interface***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***地址接口***'
- en: The `Address` interface describes a model for an address within an address space.
    All addresses are represented by an offset up to 64 bits in size. Segmented addresses
    may be further qualified by a segment value. In many cases, an address’s offset
    is equivalent to a virtual address within a program listing. The `getOffset` method
    retrieves the `long` offset value from an `Address` instance. Many Ghidra API
    functions require `Address` objects as arguments or return an `Address` object
    as a result.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address`接口描述了地址空间内地址的模型。所有地址通过一个最多为64位的偏移量表示。分段地址可能会通过段值进一步限定。在许多情况下，一个地址的偏移量相当于程序列表中的虚拟地址。`getOffset`方法从`Address`实例中检索`long`类型的偏移量值。许多Ghidra
    API函数要求以`Address`对象作为参数，或者返回`Address`对象作为结果。'
- en: '***The Symbol Interface***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***符号接口***'
- en: 'The `Symbol` interface defines properties common to all symbols. At a minimum,
    a symbol is composed of a name and an address. These attributes may be retrieved
    with the following member functions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol`接口定义了所有符号的共同属性。至少，一个符号由名称和地址组成。这些属性可以通过以下成员函数获取：'
- en: Address getAddress()
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Address getAddress()
- en: Returns the address of the `Symbol`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`Symbol`的地址。
- en: String getName()
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: String getName()
- en: Returns the name of the `Symbol`
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`Symbol`的名称。
- en: '#### ***The Reference Interface***'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***引用接口***'
- en: 'A `Reference` models a cross-reference relationship (as described in [Chapter
    9](ch09.xhtml#ch09)) between a source address and a destination address and is
    characterized by a reference type. Useful functions associated with a `Reference`
    include these:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reference`表示源地址和目标地址之间的交叉引用关系（如[第9章](ch09.xhtml#ch09)所述），并且具有一个引用类型。与`Reference`相关的有用函数包括：'
- en: public Address getFromAddress()
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: public Address getFromAddress()
- en: Returns the source address for this reference
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 返回此引用的源地址。
- en: public Address getToAddress()
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: public Address getToAddress()
- en: Returns the destination address for this reference
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 返回此引用的目标地址。
- en: public RefType getReferenceType()
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: public RefType getReferenceType()
- en: Returns a `RefType` object that describes the nature of the link between the
    source and destination addresses
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个`RefType`对象，描述源地址和目标地址之间的链接性质。
- en: '***The GhidraScript Class***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GhidraScript类***'
- en: Although this class doesn’t model a specific attribute in a binary, every script
    that you write must be a subclass of `GhidraScript`, which, in turn, is a subclass
    of `FlatProgramAPI`. As a result, your scripts have instantaneous access to the
    entire Flat API and your only obligation is to provide an implementation of
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个类并没有表示二进制文件中的某个特定属性，但你编写的每个脚本必须是`GhidraScript`类的子类，而`GhidraScript`又是`FlatProgramAPI`类的子类。因此，你的脚本可以即时访问整个Flat
    API，而你唯一的义务是提供实现。
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: which, hopefully, makes your script do something interesting. The remainder
    of the `GhidraScript` class gives you access to the most common resources for
    interacting with the Ghidra user and the program that is being analyzed. Some
    of the more useful functions and data members of this class (including some inherited
    from `FlatProgramAPI`) are summarized in the following sections.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这样， hopefully，你的脚本就能做一些有趣的事情。`GhidraScript`类的剩余部分为你提供了与Ghidra用户以及正在分析的程序交互的最常见资源的访问权限。该类的一些更有用的函数和数据成员（包括一些从`FlatProgramAPI`继承的）将在以下章节中总结。
- en: '**Useful Data Members**'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**有用的数据成员**'
- en: 'The `GhidraScript` class provides convenient access to a number of objects
    commonly referenced in scripts, including the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`GhidraScript`类为你提供了方便访问在脚本中常用的多个对象，包括以下内容：'
- en: protected Program currentProgram;
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的Program currentProgram;
- en: This is the current open program. The `Program` class is discussed later. This
    data member is likely your gateway to retrieving more interesting information,
    such as instruction and symbol lists.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前打开的程序。`Program`类将在后面讨论。这个数据成员可能是你获取更有趣信息（例如指令和符号列表）的通道。
- en: protected Address currentAddress;
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的Address currentAddress;
- en: This is the address of the current cursor location. The `Address` class is discussed
    later.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前光标位置的地址。`Address`类将在后面讨论。
- en: protected ProgramLocation currentLocation;
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的ProgramLocation currentLocation;
- en: A `ProgramLocation` object that describes the current cursor location, including
    its address, cursor row, column, and other information.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`ProgramLocation`对象，描述当前光标位置，包括其地址、光标所在的行、列以及其他信息。
- en: protected ProgramSelection currentSelection;
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的ProgramSelection currentSelection;
- en: A `ProgramSelection` object representing a range of addresses selected in the
    Ghidra GUI.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`ProgramSelection`对象，表示在Ghidra图形界面中选择的一系列地址。
- en: protected TaskMonitor monitor;
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的TaskMonitor monitor;
- en: The `TaskMonitor` class updates the status of long-running tasks and checks
    to determine whether a long-running task has been cancelled by the user (`monitor.isCancelled()`).
    Any long-running loops that you write should incorporate a call to `monitor.isCancelled`
    as an additional termination condition to recognize that the user has attempted
    to cancel your script.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskMonitor`类更新长时间运行任务的状态，并检查是否有长时间运行的任务被用户取消（`monitor.isCancelled()`）。你编写的任何长时间运行的循环都应该包含调用`monitor.isCancelled`，作为附加的终止条件，以识别用户是否尝试取消你的脚本。'
- en: '**User Interface Functions**'
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**用户界面函数**'
- en: 'The GhidraScript class provides convenience functions for basic user interface
    operations, ranging from simple message output to more interactive dialog elements.
    Some of the more common user interface functions are described here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: GhidraScript类提供了便捷的函数，用于执行基本的用户界面操作，从简单的消息输出到更具互动性的对话框元素。一些常见的用户界面函数在此描述：
- en: public void println(String message)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: public void println(String message)
- en: Prints `message` followed by a linefeed to Ghidra’s console window. This function
    is useful for printing status messages or results of your scripts in a nonintrusive
    manner.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将`message`打印到Ghidra的控制台窗口，后跟换行符。此函数对于以非侵入的方式打印状态消息或脚本结果非常有用。
- en: public void printf(String message, Object... args)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: public void printf(String message, Object... args)
- en: Uses `message` as a Java format string and prints the resulting string of formatted
    `args` to Ghidra’s console window.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`message`作为Java格式化字符串，并将格式化后的`args`打印到Ghidra的控制台窗口。
- en: public void popup(final String message)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: public void popup(final String message)
- en: Displays `message` in a pop-up dialog that requires the user to click OK before
    script execution can continue. This is a more intrusive way to display status
    messages to a user.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出对话框中显示`message`，要求用户点击确定才能继续脚本执行。这是一种更具侵入性的方式来向用户显示状态消息。
- en: public String askString(String title, String message)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: public String askString(String title, String message)
- en: One of many available `ask` functions. `askString` displays a text input dialog,
    using `message` as a prompt, and returns the text entered by the user.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 许多可用的`ask`函数之一。`askString`显示一个文本输入对话框，使用`message`作为提示，并返回用户输入的文本。
- en: public boolean askYesNo(String title, String question)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean askYesNo(String title, String question)
- en: Uses a dialog to ask the user a yes-or-no `question`. Returns `true` for yes,
    and `false` for no.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对话框询问用户一个是或否的`问题`。如果选择“是”，返回`true`；选择“否”，返回`false`。
- en: public Address askAddress(String title, String message)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: public Address askAddress(String title, String message)
- en: Displays a dialog, using `message` as a prompt, that parses the user’s input
    into an `Address` object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个对话框，使用`message`作为提示，解析用户输入为`Address`对象。
- en: public int askInt(String title, String message)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: public int askInt(String title, String message)
- en: Displays a dialog, using `message` as a prompt, that parses the user’s input
    into an `int`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个对话框，使用`message`作为提示，解析用户输入为`int`类型。
- en: public File askFile(final String title, final String approveButtonText)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: public File askFile(final String title, final String approveButtonText)
- en: Displays a system file chooser dialog and returns a Java `File` object representing
    the file selected by the user.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个系统文件选择对话框，并返回一个Java `File`对象，表示用户选择的文件。
- en: public File askDirectory(final String title, final String approveButtonText)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: public File askDirectory(final String title, final String approveButtonText)
- en: Displays a system file chooser dialog and returns a Java `File` object representing
    the directory selected by the user.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个系统文件选择对话框，并返回一个Java `File`对象，表示用户选择的目录。
- en: public boolean goTo(Address address)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean goTo(Address address)
- en: Repositions all connected Ghidra disassembly windows to `address`. Overloaded
    versions of this function take a `Symbol` or a `Function` argument and navigate
    the displays accordingly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有连接的Ghidra反汇编窗口重新定位到`address`。此函数的重载版本接受`Symbol`或`Function`参数，并根据这些参数调整显示。
- en: '**Address-Related Functions**'
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**地址相关函数**'
- en: 'For a processor, an address is typically just a number that happens to refer
    to a memory location. Ghidra models addresses using the `Address` class. `GhidraScript`
    provides a wrapper function that offers easy conversion from numbers to Ghidra
    `Address` objects:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理器而言，地址通常只是一个数字，恰好指向一个内存位置。Ghidra通过`Address`类来表示地址。`GhidraScript`提供了一个包装函数，可以方便地将数字转换为Ghidra的`Address`对象：
- en: public Address toAddr(long offset)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: public Address toAddr(long offset)
- en: Convenience function to create an `Address` object in the default address space
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Address`对象的便捷函数，位于默认地址空间中
- en: '**Reading Program Memory**'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**读取程序内存**'
- en: 'The `Memory` class represents contiguous ranges of byte values, such as the
    contents of an executable file loaded into Ghidra. Within a `Memory` object, every
    byte value is associated with an address, though addresses may be tagged as uninitialized
    and have no value to retrieve. Ghidra throws a `MemoryAccessException` if you
    attempt to access a location within a memory object with an invalid address. Consult
    the documentation for the `Memory` class for a full description of available API
    functions. The following convenience functions expose some of the `Memory` class
    via the Flat API:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Memory` 类表示字节值的连续范围，例如加载到 Ghidra 中的可执行文件的内容。在 `Memory` 对象中，每个字节值都与一个地址关联，尽管地址可能被标记为未初始化，并且没有可获取的值。如果尝试访问
    `Memory` 对象中无效地址的内存位置，Ghidra 会抛出 `MemoryAccessException`。有关 `Memory` 类的完整 API
    函数说明，请查阅文档。以下便捷函数通过 Flat API 暴露了 `Memory` 类的一部分功能：'
- en: public byte getByte(Address addr)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: public byte getByte(Address addr)
- en: Returns the single byte value retrieved from `addr`. Data type `byte` is a signed
    type in Java, so this value will be in the range –128..127.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从 `addr` 获取的单个字节值。数据类型 `byte` 在 Java 中是有符号类型，因此该值的范围为 -128..127。
- en: public byte[] getBytes(Address addr, int length)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: public byte[] getBytes(Address addr, int length)
- en: Returns `length` bytes from memory, beginning at `addr`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从 `addr` 开始的 `length` 字节数据。
- en: public int getInt(Address addr)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: public int getInt(Address addr)
- en: Returns the 4-byte value, beginning at `addr`, as a Java `int`. This function
    is endianness-aware and respects the binary’s underlying architecture when reconstituting
    the `int` value.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从 `addr` 开始的 4 字节值，作为 Java 的 `int` 类型。此函数会考虑字节序，并在重建 `int` 值时遵循二进制的底层架构。
- en: public long getLong(Address addr)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: public long getLong(Address addr)
- en: Returns the 8-byte value, beginning at `addr`, as a Java `long`. This function
    is endianness-aware and respects the binary’s underlying architecture when reconstituting
    the `long` value.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从 `addr` 开始的 8 字节值，作为 Java 的 `long` 类型。此函数会考虑字节序，并在重建 `long` 值时遵循二进制的底层架构。
- en: '**Program Search Functions**'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**程序搜索功能**'
- en: 'Ghidra’s search capabilities reside within different Program API classes according
    to the type of item being searched for. The `Memory` class contains raw byte search
    functionality. Code units (such as `Data` and `Instruction`), comment text, and
    associated iterators are obtained from the `Listing` class. Symbols/labels and
    associated iterators are accessed via the `SymbolTable` class. The following convenience
    functions expose some of the available search functionality via the Flat API:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 的搜索功能根据被搜索项的类型，分布在不同的 Program API 类中。`Memory` 类包含原始字节搜索功能。代码单元（如 `Data`
    和 `Instruction`）、注释文本及相关迭代器从 `Listing` 类中获取。符号/标签及相关迭代器通过 `SymbolTable` 类访问。以下便捷函数通过
    Flat API 暴露了部分可用的搜索功能：
- en: public Data getFirstData()
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: public Data getFirstData()
- en: Returns the first data item in the program.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 返回程序中的第一个数据项。
- en: public Data getDataAfter(Data data)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: public Data getDataAfter(Data data)
- en: Returns the next data item after `data`, or `null` if no such data exists.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `data` 后的下一个数据项，如果没有此数据项，则返回 `null`。
- en: public Data getDataAt(Address address)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: public Data getDataAt(Address address)
- en: Returns the data item at `address`, or `null` if no such data exists.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `address` 处的数据项，如果没有此数据项，则返回 `null`。
- en: public Instruction getFirstInstruction()
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: public Instruction getFirstInstruction()
- en: Returns the first instruction in the program.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 返回程序中的第一条指令。
- en: public Instruction getInstructionAfter(Instruction instruction)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: public Instruction getInstructionAfter(Instruction instruction)
- en: Returns the next instruction item after `instruction`, or `null` if no such
    instruction exists.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `instruction` 后的下一个指令项，如果没有此指令项，则返回 `null`。
- en: public Instruction getInstructionAt(Address address)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: public Instruction getInstructionAt(Address address)
- en: Returns the instruction at `address`, or `null` if no such instruction exists.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `address` 处的指令，如果不存在此指令，则返回 `null`。
- en: public Address find(String text)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: public Address find(String text)
- en: 'Searches for a `text` string within the Listing window. Listing components
    are searched in the following order:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Listing 窗口中搜索 `text` 字符串。Listing 组件按以下顺序进行搜索：
- en: Plate comments
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Plate 注释
- en: Pre comments
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pre 注释
- en: Labels
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标签
- en: Code unit mnemonics and operands
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码单元助记符和操作数
- en: EOL comments
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: EOL 注释
- en: Repeatable comments
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可重复注释
- en: Post comments
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Post 注释
- en: A successful search returns the address containing the match. Note that as a
    result of the search order, the returned address may *not* represent the first
    occurrence of text in the disassembly listing when considered in strictly increasing
    address order.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的搜索返回包含匹配项的地址。请注意，由于搜索顺序的原因，返回的地址可能*不*代表在严格递增的地址顺序下反汇编清单中第一次出现的文本。
- en: public Address find(Address start, byte[] values);
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: public Address find(Address start, byte[] values);
- en: Searches memory, beginning at `addr`, for a specified sequence of byte `values`.
    When `addr` is `null`, the search begins at the lowest valid address in the binary.
    A successful search returns the address of the first byte in the matching sequence.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addr`处开始搜索内存，查找指定的字节`values`序列。当`addr`为`null`时，搜索从二进制文件中的最低有效地址开始。成功的搜索将返回匹配序列中第一个字节的地址。
- en: public Address findBytes(Address start, String byteString)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: public Address findBytes(Address start, String byteString)
- en: Searches memory, beginning at `addr`, for a specified `byteString` that may
    contain regular expressions. When `addr` is `null`, the search begins at the lowest
    valid address in the binary. A successful search returns the address of the first
    byte in the matching sequence.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addr`处开始搜索内存，查找可能包含正则表达式的指定`byteString`。当`addr`为`null`时，搜索从二进制文件中的最低有效地址开始。成功的搜索将返回匹配序列中第一个字节的地址。
- en: '**Manipulating Label and Symbols**'
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**操作标签和符号**'
- en: 'The need to manipulate named locations arises fairly often in scripts. The
    following functions are available for working with named locations in a Ghidra
    database:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，经常需要操作命名的位置。以下是可用于在Ghidra数据库中处理命名位置的函数：
- en: public Symbol getSymbolAt(Address address)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: public Symbol getSymbolAt(Address address)
- en: Returns the `Symbol` associated with the given address, or `null` if the location
    has no `Symbol`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 返回与给定地址关联的`Symbol`，如果该位置没有`Symbol`，则返回`null`。
- en: public Symbol createLabel(Address address, String name, boolean makePrimary)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: public Symbol createLabel(Address address, String name, boolean makePrimary)
- en: Assigns the given `name` to the given `address`. Ghidra allows multiple names
    to be assigned to a single address. If `makePrimary` is `true`, the new name will
    become the primary name associated with `address`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定的`name`分配给给定的`address`。Ghidra允许多个名称分配给单一地址。如果`makePrimary`为`true`，则新名称将成为与`address`关联的主名称。
- en: public List<Symbol> getSymbols(String name, Namespace namespace)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: public List<Symbol> getSymbols(String name, Namespace namespace)
- en: Returns a list of all symbols named `name` in `namespace`. When namespace is
    `null`, the global namespace is searched. If the result is empty, the named symbol
    does not exist. If the result contains only one element, the name is unique.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`namespace`中所有名为`name`的符号列表。如果`namespace`为`null`，则搜索全局命名空间。如果结果为空，则表示该符号不存在。如果结果仅包含一个元素，则表示该名称是唯一的。
- en: '**Working with Functions**'
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**与函数的操作**'
- en: 'Many scripts are designed to analyze functions within a program. The following
    functions can be used to access information about program functions:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 许多脚本旨在分析程序中的函数。以下函数可用于访问有关程序函数的信息：
- en: public final Function getFirstFunction()
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: public final Function getFirstFunction()
- en: Returns the first `Function` object in the program
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 返回程序中的第一个`Function`对象
- en: public Function getGlobalFunctions(String name)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: public Function getGlobalFunctions(String name)
- en: Returns the first `Function` object for the named function, or `null` if no
    such function exists
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 返回命名函数的第一个`Function`对象，如果没有这样的函数则返回`null`
- en: public Function getFunctionAt(Address entryPoint)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: public Function getFunctionAt(Address entryPoint)
- en: Returns the `Function` object for the function at `entryPoint`, or `null` if
    no such function exists
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`entryPoint`处的`Function`对象，如果没有这样的函数则返回`null`
- en: public Function getFunctionAfter(Function function)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: public Function getFunctionAfter(Function function)
- en: Returns the `Function` object for the successor to `function`, or `null` if
    no such function exists
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`function`的后继`Function`对象，如果没有这样的函数则返回`null`
- en: public Function getFunctionAfter(Address address)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: public Function getFunctionAfter(Address address)
- en: Returns the `Function` object for the function that starts after address, or
    `null` if no such function exists
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 返回在地址后开始的`Function`对象，如果没有这样的函数则返回`null`
- en: '**Working with Cross-References**'
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**与交叉引用的操作**'
- en: 'Cross-references were covered in [Chapter 9](ch09.xhtml#ch09). In the Ghidra
    Program API, the top-level `Program` object contains a `ReferenceManager`, which,
    unsurprisingly, manages the references within the program. As with many other
    program constructs, the Flat API offers convenience functions for accessing cross-references,
    some of which are detailed here:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉引用在[第9章](ch09.xhtml#ch09)中有详细介绍。在Ghidra程序API中，顶层的`Program`对象包含一个`ReferenceManager`，显而易见，它管理程序中的引用。与许多其他程序构造一样，Flat
    API 提供了方便的函数来访问交叉引用，其中一些在此处进行了详细说明：
- en: public Reference[] getReferencesFrom(Address address)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: public Reference[] getReferencesFrom(Address address)
- en: Returns an array of all `Reference` objects originating from `address`
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 返回所有来自`address`的`Reference`对象的数组。
- en: public Reference[] getReferencesTo(Address address)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: public Reference[] getReferencesTo(Address address)
- en: Returns an array of all `Reference` objects terminating at `address`
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 返回所有指向`address`的`Reference`对象的数组。
- en: '**Program Manipulation Functions**'
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**程序操作函数**'
- en: 'When automating your analysis tasks, you may find yourself wanting to add new
    information into a program. The Flat API provides a variety of functions for modifying
    the contents of a program, including the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化分析任务时，您可能会希望将新信息添加到程序中。Flat API 提供了多种修改程序内容的功能，包括以下内容：
- en: public final void clearListing(Address address)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: public final void clearListing(Address address)
- en: Removes any instruction or data defined at `address`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 移除`address`处定义的任何指令或数据。
- en: public void removeFunctionAt(Address address)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: public void removeFunctionAt(Address address)
- en: Removes the function at `address`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 移除位于`address`的函数。
- en: public boolean disassemble(Address address)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean disassemble(Address address)
- en: Performs a recursive descent disassembly beginning at `address`. Returns `true`
    if the operation is successful.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从`address`开始执行递归下降反汇编。如果操作成功，返回`true`。
- en: public Data createByte(Address address)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: public Data createByte(Address address)
- en: Converts the item at the specified address into a data byte. Also, `createWord`,
    `createDword`, `createQword`, and other data creation functions are available.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将指定地址处的项目转换为数据字节。此外，还可以使用`createWord`、`createDword`、`createQword`和其他数据创建函数。
- en: public boolean setEOLComment(Address address, String comment)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean setEOLComment(Address address, String comment)
- en: Adds an EOL comment at the given `address`. Additional comment-related functions
    include `setPlateComment`, `setPreComment`, and `setPostComment`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的`address`处添加一个EOL注释。其他与注释相关的函数包括`setPlateComment`、`setPreComment`和`setPostComment`。
- en: public Function createFunction(Address entryPoint, String name)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: public Function createFunction(Address entryPoint, String name)
- en: Creates a function with the given `name` at `entryPoint`. Ghidra attempts to
    automatically identify the end of the function by locating the function’s return
    instruction.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在`entryPoint`处创建一个具有给定`name`的函数。Ghidra会尝试通过定位函数的返回指令来自动识别函数的结束。
- en: public Data createAsciiString(Address address)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: public Data createAsciiString(Address address)
- en: Creates a null-terminated ASCII string at `address`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在`address`处创建一个以空字符结尾的ASCII字符串。
- en: public Data createAsciiString(Address address, int length)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: public Data createAsciiString(Address address, int length)
- en: Creates an ASCII string of the specified `length` at `address`. If `length`
    is zero or less, Ghidra attempts to automatically locate the string’s null terminator.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在`address`处创建指定`length`长度的ASCII字符串。如果`length`为零或更小，Ghidra会尝试自动定位字符串的空字符终止符。
- en: public Data createUnicodeString(Address address)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: public Data createUnicodeString(Address address)
- en: Creates a null-terminated Unicode string at `address`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`address`处创建一个以空字符结尾的Unicode字符串。
- en: '***The Program Class***'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***程序类***'
- en: 'The `Program` class represents the root of the Program API hierarchy and outermost
    layer of the data model of a binary file. You will commonly use a `Program` object
    (often `currentProgram`) to access the binary model. Commonly used `Program` class
    member functions include the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program`类代表程序API层次结构的根节点，以及二进制文件数据模型的最外层。您通常会使用`Program`对象（通常是`currentProgram`）来访问二进制模型。常用的`Program`类成员函数包括以下内容：'
- en: public Listing getListing()
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: public Listing getListing()
- en: Retrieves the `Listing` object for the current program.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 获取当前程序的`Listing`对象。
- en: public FunctionManager getFunctionManager()
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: public FunctionManager getFunctionManager()
- en: Retrieves the program’s `FunctionManager`, which provides access to all of the
    functions that have been identified within the binary. This class provides the
    functionality to map an `Address` back to its containing `Function` (`Function`
    `getFunctionContaining (``Address` `addr)`). In addition, it provides a `FunctionIterator`,
    which is useful when you want to process every function in the program.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 检索程序的 `FunctionManager`，该管理器提供对已在二进制文件中识别的所有函数的访问。此类提供了将 `Address` 映射回其包含的 `Function`（`Function`
    `getFunctionContaining(Address addr)`）的功能。此外，它还提供了一个 `FunctionIterator`，当你想要处理程序中的每个函数时非常有用。
- en: public SymbolTable getSymbolTable()
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: public SymbolTable getSymbolTable()
- en: Retrieves the program’s `SymbolTable` object. Using a `SymbolTable`, you can
    work with individual symbols or iterate over every symbol in the program.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 检索程序的 `SymbolTable` 对象。使用 `SymbolTable`，可以处理单个符号或遍历程序中的所有符号。
- en: public Memory getMemory()
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: public Memory getMemory()
- en: Retrieves the `Memory` object associated with this program, which allows you
    to work with raw program byte content.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 检索与此程序关联的 `Memory` 对象，该对象允许你操作原始程序字节内容。
- en: public ReferenceManager getReferenceManager()
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: public ReferenceManager getReferenceManager()
- en: Retrieves the program’s `ReferenceManager` object. A `ReferenceManager` may
    be used to add and remove references as well as retrieve iterators for many types
    of references.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 检索程序的 `ReferenceManager` 对象。`ReferenceManager` 可用于添加和删除引用以及检索多种类型引用的迭代器。
- en: public Address getMinAddress()
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: public Address getMinAddress()
- en: Returns the lowest valid address within the program. This is most often the
    binary’s base memory address.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 返回程序中最低有效地址。这通常是二进制文件的基础内存地址。
- en: public Address getMaxAddress()
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: public Address getMaxAddress()
- en: Returns the highest valid address within the program.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 返回程序中最高有效地址。
- en: public LanguageID getLanguageID()
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: public LanguageID getLanguageID()
- en: Returns the object representation of the binary’s language specification. The
    language specification itself may then be retrieved using the `getIdAsString()`
    function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 返回二进制文件语言规范的对象表示。可以使用 `getIdAsString()` 函数检索语言规范本身。
- en: '***The Function Interface***'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***函数接口***'
- en: 'The `Function` interface defines the required Program API behaviors of function
    objects. Member functions provide access to various attributes commonly associated
    with functions and include the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function` 接口定义了函数对象所需的程序 API 行为。成员函数提供对与函数常相关的各种属性的访问，包括以下内容：'
- en: public String getPrototypeString(boolean formalSignature,
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: public String getPrototypeString(boolean formalSignature,
- en: boolean includeCallingConvention)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: boolean includeCallingConvention)
- en: Returns the `Function` object’s prototype as a string. The two arguments influence
    the format of the returned prototype string.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `Function` 对象的原型字符串。两个参数影响返回的原型字符串的格式。
- en: public AddressSetView getBody()
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: public AddressSetView getBody()
- en: Returns the address set that contains the function’s body of code. An *address
    set* is composed of one or more address ranges, and allows for situations in which
    a function’s code is distributed among several noncontiguous ranges of memory.
    Obtain an `AddressIterator` to visit all addresses in the set or an `AddressRangeIterator`
    to iterate over each range. Note that you must use a `Listing` object to retrieve
    the actual instructions contained in the function’s body (see `getInstructions`).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 返回包含函数代码体的地址集合。*地址集合*由一个或多个地址范围组成，允许函数的代码分布在多个非连续的内存范围中。获取 `AddressIterator`
    以访问集合中的所有地址，或者获取 `AddressRangeIterator` 以遍历每个范围。请注意，必须使用 `Listing` 对象来检索函数体内的实际指令（参见
    `getInstructions`）。
- en: public StackFrame getStackFrame()
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: public StackFrame getStackFrame()
- en: Returns the stack frame associated with the function. The result may be used
    to retrieve detailed information about the layout of the function’s local variables
    and stack-based arguments.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 返回与函数相关联的堆栈帧。结果可用于获取关于函数局部变量和基于堆栈的参数布局的详细信息。
- en: '***The Instruction Interface***'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指令接口***'
- en: 'The `Instruction` interface defines the required Program API behaviors of instruction
    objects. Member functions provide access to various attributes commonly associated
    with instructions and include the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Instruction` 接口定义了指令对象所需的程序 API 行为。成员函数提供对与指令常相关的各种属性的访问，包括以下内容：'
- en: public String getMnemonicString()
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: public String getMnemonicString()
- en: Returns the instruction’s mnemonic.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指令的助记符。
- en: public String getComment(int commentType)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: public String getComment(int commentType)
- en: Returns the `commentType` comment associated with the instruction or `null`
    if no comment of the given type is associated with the instruction. A `commentType`
    may be one of `EOL_COMMENT`, `PRE_COMMENT`, `POST_COMMENT`, or `REPEATABLE_COMMENT`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 返回与指令相关联的`commentType`注释，如果没有与该指令关联的指定类型的注释，则返回`null`。`commentType`可能是`EOL_COMMENT`、`PRE_COMMENT`、`POST_COMMENT`或`REPEATABLE_COMMENT`之一。
- en: public int getNumOperands()
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: public int getNumOperands()
- en: Returns the number of operands associated with this instruction.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 返回与此指令关联的操作数数量。
- en: public int getOperandType(int opIndex)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: public int getOperandType(int opIndex)
- en: Returns a bitmask of operand type flags defined in class `OperandType`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 返回在`OperandType`类中定义的操作数类型标志的位掩码。
- en: public String toString()
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString()
- en: Returns the string representation of the instruction.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指令的字符串表示。
- en: '**Ghidra Scripting Examples**'
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Ghidra 脚本示例**'
- en: For the remainder of the chapter, we present some fairly common situations in
    which a script can be used to answer a question about a program. For brevity,
    only the body of each script’s `run` function is shown.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将介绍一些脚本可以用来回答程序相关问题的常见情况。为简洁起见，本文仅展示每个脚本`run`函数的主体部分。
- en: '***Example 1: Enumerating Functions***'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例 1：枚举函数***'
- en: Many scripts operate on individual functions. Examples include generating the
    call tree rooted at a specific function, generating the control flow graph of
    a function, and analyzing the stack frames of every function in a program. [Listing
    14-1](ch14.xhtml#exa14_1) iterates through every function in a program and prints
    basic information about each function, including the start and end addresses of
    the function, the size of the function’s arguments, and the size of the function’s
    local variables. All output is sent to the console window.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 很多脚本操作于单个函数。例如，生成以特定函数为根的调用树，生成函数的控制流图，以及分析程序中每个函数的堆栈帧。[清单 14-1](ch14.xhtml#exa14_1)遍历程序中的每个函数，并打印每个函数的基本信息，包括函数的起始和结束地址、函数参数的大小以及函数局部变量的大小。所有输出都发送到控制台窗口。
- en: '[PRE6]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 14-1: Function enumeration script*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-1：函数枚举脚本*'
- en: The script uses Ghidra’s Flat API to iterate over all functions from the first
    ➊ and advancing through each in succession ➎. A reference to each function’s stack
    frame is obtained ➋, and the size of the local variables ➌ and the stack-based
    arguments ➍ retrieved. A summary for each function is printed before continuing
    the iteration.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本使用Ghidra的Flat API遍历从第一个函数 ➊开始的所有函数，并依次向前推进 ➎。获取每个函数堆栈帧的引用 ➋，并检索局部变量的大小 ➌以及基于堆栈的参数的大小
    ➍。在继续迭代之前，会打印每个函数的摘要。
- en: '***Example 2: Enumerating Instructions***'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例 2：枚举指令***'
- en: 'Within a given function, you may want to enumerate every instruction. [Listing
    14-2](ch14.xhtml#exa14_2) counts the number of instructions contained in the function
    identified by the current cursor position:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的函数内，您可能想要枚举每一条指令。[清单 14-2](ch14.xhtml#exa14_2)计算当前光标位置所标识的函数中包含的指令数量：
- en: '[PRE7]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 14-2: Instruction enumeration script*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-2：指令枚举脚本*'
- en: The function begins by obtaining a reference to the function containing the
    cursor ➊. If a function is found, the next step is to use the program’s `Listing`
    object to obtain an `InstructionIterator` over the function ➋. The iteration loop
    counts the number of instructions retrieved, and the total is reported to the
    user with a pop-up message dialog ➌.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先获取包含光标的函数的引用 ➊。如果找到该函数，下一步是使用程序的`Listing`对象获取该函数的`InstructionIterator`
    ➋。迭代循环计算检索到的指令数量，并通过弹出消息对话框 ➌将总数报告给用户。
- en: '***Example 3: Enumerating Cross-References***'
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例 3：枚举交叉引用***'
- en: Iterating through cross-references can be confusing because of the number of
    functions available for accessing cross-reference data and the fact that code
    cross-references are bidirectional. To get the data you want, you need to access
    the proper type of cross-reference for your situation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代交叉引用可能会令人困惑，因为可以访问交叉引用数据的函数数量以及代码交叉引用是双向的。要获取所需的数据，您需要访问适合您情况的正确类型的交叉引用。
- en: In our first cross-reference example, shown in [Listing 14-3](ch14.xhtml#exa14_3),
    we retrieve the list of all function calls made within a function by iterating
    through each instruction in the function to determine if the instruction calls
    another function. One method of doing this might be to parse the results of the
    `getMnemonicString` function to look for `call` instructions. This would not be
    a very portable or efficient solution because the instruction used to call a function
    varies among processor types, and additional parsing would be required to determine
    exactly which function was being called. Cross-references avoid each of these
    difficulties because they are processor-independent and directly inform us about
    the target of the cross-reference.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一个交叉引用示例中，如[清单 14-3](ch14.xhtml#exa14_3)所示，我们通过遍历函数中的每条指令，检查该指令是否调用了其他函数，从而获取函数中所有调用的列表。实现这一点的一种方法是解析`getMnemonicString`函数的结果，查找`call`指令。这并不是一个很便携或者高效的解决方案，因为调用函数的指令在不同的处理器类型之间有所不同，而且还需要额外的解析来确定到底调用了哪个函数。交叉引用避免了这些困难，因为它们与处理器无关，并且直接告诉我们交叉引用的目标。
- en: '[PRE8]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 14-3: Enumerating function calls*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-3：枚举函数调用*'
- en: '**DANGEROUS FUNCTIONS**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**危险函数**'
- en: 'The C functions `strcpy` and `sprintf` are considered dangerous to use because
    they allow unbounded copying into destination buffers. While each may be safely
    used by programmers who check the size of source and destination buffers, such
    checks are all too often forgotten by programmers unaware of the dangers of these
    functions. The `strcpy` function, for example, is declared as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中的`strcpy`和`sprintf`函数被认为是危险的，因为它们允许将数据无限制地复制到目标缓冲区。尽管程序员可以通过检查源缓冲区和目标缓冲区的大小来安全地使用这些函数，但这些检查常常被那些不了解这些函数危险性的程序员忽略。例如，`strcpy`函数的声明如下：
- en: '[PRE9]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `strcpy` function copies all characters up to and including the first null
    termination character encountered in the source buffer to the given destination
    buffer (`dest`). The fundamental problem is that there is no way to determine,
    at runtime, the size of any array, and `strcpy` can’t determine whether the capacity
    of the destination buffer is sufficient to hold all of the data to be copied from
    source. Such unchecked copy operations are a major cause of buffer overflow vulnerabilities.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`strcpy`函数将源缓冲区中所有字符（包括遇到的第一个空字符终止符）复制到指定的目标缓冲区(`dest`)。根本问题在于，无法在运行时确定任何数组的大小，而`strcpy`无法判断目标缓冲区是否足够大，以容纳从源缓冲区复制的所有数据。这种未经检查的复制操作是缓冲区溢出漏洞的主要原因。'
- en: We begin by obtaining a reference to the function containing the cursor ➊. Next,
    we iterate through each instruction in the function ➋, and for each instruction,
    we iterate through each cross-reference from the instruction ➌. We are interested
    only in cross-references that call other functions, so we must test the return
    value of `getReferenceType` ➍ to determine whether `isCall` is `true`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取包含光标位置的函数的引用 ➊。接下来，我们遍历该函数中的每条指令 ➋，对于每条指令，我们会遍历每个来自该指令的交叉引用 ➌。我们只对调用其他函数的交叉引用感兴趣，因此我们必须测试`getReferenceType`的返回值
    ➍，以确定`isCall`是否为`true`。
- en: '***Example 4: Finding Function Calls***'
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例 4：查找函数调用***'
- en: Cross-references are also useful for identifying every instruction that references
    a particular location. In [Listing 14-4](ch14.xhtml#exa14_4), we iterate across
    all of the cross-references *to* a particular symbol (as opposed to *from* in
    the previous example).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉引用也对于识别每个引用特定位置的指令非常有用。在[清单 14-4](ch14.xhtml#exa14_4)中，我们遍历所有指向特定符号的交叉引用（与之前示例中的*from*不同，这次是*to*）。
- en: '[PRE10]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 14-4: Enumerating a function’s callers*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-4：枚举函数的调用者*'
- en: In this example, we have written the helper function `getFunctions` ➏ to collect
    `Function` objects associated with our functions of interest. For each function
    of interest, we call a second helper function, `list_calls` ➊, to process all
    cross-references ➋ to the function. If the cross-reference type is determined
    to be a call-type cross-reference ➌, the calling function is retrieved ➍ and its
    name is displayed to the user ➎. Among other things, this approach could be used
    to create a low-budget security analyzer by highlighting all calls to functions
    such as `strcpy` and `sprintf`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们编写了辅助函数`getFunctions` ➏，用于收集与我们关注的函数相关的`Function`对象。对于每个感兴趣的函数，我们调用第二个辅助函数`list_calls`
    ➊来处理所有对该函数的交叉引用 ➋。如果交叉引用类型被确定为调用类型的交叉引用 ➌，则会检索调用函数 ➍并将其名称显示给用户 ➎。除此之外，这种方法还可以用来创建一个低成本的安全分析工具，突出显示对`strcpy`和`sprintf`等函数的所有调用。
- en: '***Example 5: Emulating Assembly Language Behavior***'
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例 5：模拟汇编语言行为***'
- en: There are a number of reasons you might need to write a script that emulates
    the behavior of a program you are analyzing. For example, the program you are
    studying may be self-modifying, as many malware programs are, or the program may
    contain some encoded data that gets decoded when needed at runtime. Without running
    the program and pulling the modified data out of the running process’s memory,
    how can you understand the behavior of the program?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种原因可能需要编写脚本来模拟你正在分析的程序的行为。例如，您正在研究的程序可能是自我修改的，就像许多恶意软件程序一样，或者程序可能包含一些在运行时需要解码的数据。在不运行程序并从正在运行的进程内存中提取修改后的数据的情况下，你如何理解程序的行为呢？
- en: If the decoding process is not terribly complex, you may be able to quickly
    write a script that performs the same actions that are performed by the program
    when it runs. Using a script to decode data in this way eliminates the need to
    run the program when you don’t know what the program does or you don’t have access
    to a platform on which you can run the program. For example, without a MIPS execution
    environment, you cannot execute a MIPS binary and observe any data decoding it
    might perform. You could, however, write a Ghidra script to mimic the behavior
    of the binary and make the required changes within your Ghidra project, all with
    no need for a MIPS execution environment.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解码过程不太复杂，你可能能够快速编写一个脚本，执行与程序运行时相同的操作。通过使用脚本以这种方式解码数据，可以在你不清楚程序执行内容或无法访问运行程序的平台时，避免运行程序。例如，没有MIPS执行环境时，你无法执行MIPS二进制文件并观察它可能执行的任何数据解码。然而，你可以编写一个Ghidra脚本来模拟二进制文件的行为，并在你的Ghidra项目中进行所需的更改，完全不需要MIPS执行环境。
- en: The following x86 code was extracted from a DEFCON Capture the Flag binary:^([1](footnotes.xhtml#ch14fn1))
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以下x86代码是从一个DEFCON Capture the Flag二进制文件中提取的：^([1](footnotes.xhtml#ch14fn1))
- en: '[PRE11]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code decodes a private key that has been embedded within the program binary.
    Using the script in [Listing 14-5](ch14.xhtml#exa14_5), we can extract the private
    key without running the program.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码解码了一个嵌入在程序二进制文件中的私钥。使用[列表14-5](ch14.xhtml#exa14_5)中的脚本，我们可以在不运行程序的情况下提取私钥。
- en: '[PRE12]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 14-5: Emulating assembly language with a Ghidra script*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-5：使用Ghidra脚本模拟汇编语言*'
- en: '[Listing 14-5](ch14.xhtml#exa14_5) is a fairly literal translation of the preceding
    assembly language sequence generated according to the following mechanical rules:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表14-5](ch14.xhtml#exa14_5)是根据以下机械规则生成的前述汇编语言序列的相当字面翻译：'
- en: For each stack variable and register used in the assembly code, declare an appropriately
    typed script variable.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于汇编代码中使用的每个栈变量和寄存器，声明一个适当类型的脚本变量。
- en: For each assembly language statement, write a statement that mimics its behavior.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个汇编语言语句，编写一个模仿其行为的语句。
- en: Emulate reading and writing stack variables by reading and writing the corresponding
    variable declared in your script.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过读取和写入脚本中声明的相应变量来模拟栈变量的读写。
- en: Emulate reading from a nonstack location using the `getByte`, `getWord`, `getDword`,
    or `getQword` function, depending on the amount of data being read (1, 2, 4, or
    8 bytes).
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getByte`、`getWord`、`getDword`或`getQword`函数模拟从非栈位置读取数据，具体取决于读取的数据量（1、2、4或8字节）。
- en: Emulate writing to a nonstack location using the `setByte`, `setWord`, `setDword`,
    or `setQword` function, depending on the amount of data being written.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`setByte`、`setWord`、`setDword`或`setQword`函数来模拟写入非栈位置，具体取决于写入的数据量。
- en: If the code contains a loop for which the termination condition is not immediately
    obvious, begin with an infinite loop such as `while(true){...}` and then insert
    a `break` statement when you encounter statements that cause the loop to terminate.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码包含一个终止条件不明显的循环，首先可以使用一个无限循环，比如 `while(true){...}`，然后在遇到导致循环终止的语句时插入一个 `break`
    语句。
- en: When the assembly code calls functions, things get complicated. To properly
    simulate the behavior of the assembly code, you must mimic the behavior of the
    function that has been called, including providing a return value that makes sense
    within the context of the code being simulated.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当汇编代码调用函数时，事情会变得更加复杂。为了正确模拟汇编代码的行为，你必须模仿已调用函数的行为，包括提供一个在模拟的代码上下文中有意义的返回值。
- en: As the complexity of the assembly code increases, it becomes more challenging
    to write a script that emulates all aspects of an assembly language sequence,
    but you don’t have to fully understand how the code you are emulating works. Translate
    one or two instructions at a time. If each instruction has been correctly translated,
    the script as a whole should properly mimic the complete functionality of the
    original assembly code. After the script has been completed, you can use the script
    to better understand the underlying assembly. You will see this approach, and
    more generic emulation functionality, used again in [Chapter 21](ch21.xhtml#ch21)
    when we discuss the analysis of obfuscated binaries.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 随着汇编代码复杂性的增加，编写一个能仿真汇编语言序列所有方面的脚本变得更加具有挑战性，但你不必完全理解你正在仿真的代码是如何工作的。一次翻译一到两条指令。如果每条指令都正确翻译，那么整个脚本就应该能够正确地模拟原始汇编代码的完整功能。完成脚本后，你可以使用该脚本更好地理解底层的汇编代码。你将会在
    [第21章](ch21.xhtml#ch21) 中看到这种方法，以及更多通用的仿真功能，届时我们将讨论如何分析混淆的二进制文件。
- en: 'For example, once we translate the sample algorithm and spend some time considering
    how it works, we can shorten the emulation script as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一旦我们翻译了示例算法，并花些时间考虑它是如何工作的，我们可以将仿真脚本简化如下：
- en: '[PRE13]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once the script executes, you can see the decoded private key starting at address
    `0x804B880`. If you don’t want to modify the Ghidra database when emulating code,
    replace the `setByte` function call with a call to `printf`, which will output
    the results to the CodeBrowser console, or write the data to a disk file for binary
    data. Don’t forget that in addition to Ghidra’s Java API, you have access to all
    of the standard Java API classes as well as any other Java packages that you’ve
    chosen to install on your system.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本执行，你可以看到解码后的私钥从地址`0x804B880`开始。如果你不想在仿真代码时修改 Ghidra 数据库，可以将 `setByte` 函数调用替换为
    `printf` 函数调用，这样就会把结果输出到 CodeBrowser 控制台，或者将数据写入磁盘文件以存储二进制数据。别忘了，除了 Ghidra 的 Java
    API 外，你还可以访问所有标准的 Java API 类以及你选择安装到系统上的其他 Java 包。
- en: '**Summary**'
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Scripting provides a powerful means for automating repetitive tasks and extending
    Ghidra’s capabilities. This chapter has introduced Ghidra’s functionality for
    editing and building new scripts using both Java and Python. The integrated ability
    to build, compile, and run Java-based scripts within the CodeBrowser environment
    lets you extend Ghidra’s capabilities without requiring an in-depth understanding
    of the underlying intricacies of the Ghidra development environment. [Chapters
    15](ch15.xhtml#ch15) and [16](ch16.xhtml#ch16) introduce Eclipse integration and
    the ability to run Ghidra in headless mode.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本编写提供了一种强大的手段，用于自动化重复任务并扩展 Ghidra 的功能。本章介绍了如何使用 Java 和 Python 编辑和构建新的脚本，Ghidra
    的集成功能可以在 CodeBrowser 环境内构建、编译和运行基于 Java 的脚本，让你在无需深入理解 Ghidra 开发环境的复杂性情况下，扩展 Ghidra
    的功能。[第15章](ch15.xhtml#ch15) 和 [第16章](ch16.xhtml#ch16)介绍了 Eclipse 集成以及在无头模式下运行
    Ghidra 的能力。
