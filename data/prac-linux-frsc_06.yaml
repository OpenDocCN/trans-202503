- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6'
- en: RECONSTRUCTING SYSTEM BOOT AND INITIALIZATION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 重建系统启动和初始化**
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common01.jpg)'
- en: This chapter covers the forensic analysis of the Linux system boot and initialization
    process. We’ll examine the early boot stages where the BIOS or UEFI firmware pass
    control to the bootloader, the loading and executing of the kernel, and systemd
    initialization of a running system. Also included here is analysis of power management
    activities like sleep and hibernation, and the final shutdown process of the system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍 Linux 系统启动和初始化过程的取证分析。我们将检查启动的早期阶段，其中 BIOS 或 UEFI 固件将控制权交给引导加载程序，内核的加载和执行，以及
    systemd 初始化运行系统。此外，还包括电源管理活动的分析，如睡眠和休眠，以及系统最终的关机过程。
- en: '**Analysis of Bootloaders**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**引导加载程序分析**'
- en: Traditional PCs used a BIOS (basic input/output system) chip to run code from
    the first sector of a disk to boot the computer. This first sector is called the
    *master boot record (MBR)*, and it initiates the process of loading the operating
    system kernel and other components into memory for execution. Modern PCs use the
    *unified extensible firmware interface (UEFI)* to run EFI binary program files
    from a FAT filesystem in the EFI system partition. These UEFI-specific programs
    are run directly by the firmware and manage the process of loading and executing
    the operating system. This section describes forensic artifacts from these early
    boot stages of a Linux system that may be interesting for an investigator.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 传统 PC 使用 BIOS（基本输入输出系统）芯片运行来自磁盘第一个扇区的代码以启动计算机。这个第一个扇区称为 *主引导记录 (MBR)*，它启动了将操作系统内核和其他组件加载到内存中的过程。现代
    PC 使用 *统一可扩展固件接口 (UEFI)* 来从 EFI 系统分区中的 FAT 文件系统运行 EFI 二进制程序文件。这些 UEFI 特定的程序由固件直接运行，管理操作系统的加载和执行过程。本节描述了这些
    Linux 系统早期启动阶段的取证 artifacts，这些可能对调查人员有价值。
- en: PC-based Linux systems booting with BIOS or UEFI use software called a *bootloader*
    to start up. The bootloader is responsible for loading the Linux kernel and other
    components into memory, choosing the right kernel parameters, and executing the
    kernel. Non-PC systems may have a completely different boot process. For example,
    the Raspberry Pi doesn’t use BIOS or UEFI, but has its own bootloading mechanism,^([1](footnotes.xhtml#ch06foot_01))
    which is also described here.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 PC 的 Linux 系统使用 BIOS 或 UEFI 启动，采用一种名为 *引导加载程序* 的软件来启动。引导加载程序负责将 Linux 内核和其他组件加载到内存中，选择正确的内核参数并执行内核。非
    PC 系统可能有完全不同的启动过程。例如，树莓派不使用 BIOS 或 UEFI，而是有自己独特的引导机制，^([1](footnotes.xhtml#ch06foot_01))
    本章也将简要描述。
- en: Modern Linux PCs overwhelmingly use the *GRand Unified Bootloader (GRUB)* system
    for booting. GRUB replaced the older, more basic loader called LILO (LInux LOader).
    This section focuses primarily on MBR and UEFI booting with GRUB. I’ll cover Raspberry
    Pi booting and briefly describe other bootloaders later in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 Linux 计算机大多数使用 *GRand Unified Bootloader (GRUB)* 系统进行启动。GRUB 替代了更古老、基础的引导加载程序
    LILO（LInux LOader）。本节主要聚焦于通过 GRUB 的 MBR 和 UEFI 启动。我将在本章后面简要介绍树莓派启动及其他引导加载程序。
- en: 'From a forensics perspective, we might identify or extract a number of artifacts
    when analyzing the bootloader process, such as:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从取证角度来看，在分析引导加载程序过程时，我们可能会识别或提取一些 artifacts，例如：
- en: The installed bootloader
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装的引导加载程序
- en: Evidence of booting more than one operating system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动多个操作系统的证据
- en: Evidence of multiple Linux kernels previously installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 曾经安装的多个 Linux 内核的证据
- en: Timestamps of boot files
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动文件的时间戳
- en: UUIDs of partitions and filesystems
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区和文件系统的 UUID
- en: Parameters passed to the kernel on boot
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动时传递给内核的参数
- en: The root filesystem location
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件系统位置
- en: The hibernation image location
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 休眠映像位置
- en: Bootloader password hashes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导加载程序密码哈希值
- en: EFI system partition contents
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EFI 系统分区内容
- en: Unusual bootloader binaries (for possible malware analysis)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常的引导加载程序二进制文件（用于可能的恶意软件分析）
- en: '[Chapter 3](ch03.xhtml) covered the analysis of partition tables, and even
    though the bootloader and partition tables are closely related, I’ve chosen to
    cover them separately. A comprehensive analysis of bootloader executable code
    is beyond the scope of this book. Analyzing maliciously modified bootloaders involves
    malware reverse engineering, binary code decompilation and disassembly, and execution
    debugging or tracing of code blocks. This topic alone could easily fill an entire
    book, so here I include only the extraction of bootloader components and data
    to be analyzed. The analysis of BIOS settings and EFI variables are operating
    system independent and are mentioned only briefly.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.xhtml)涵盖了分区表的分析，尽管引导加载程序和分区表紧密相关，我选择将它们分开讲解。对引导加载程序可执行代码的全面分析超出了本书的范围。分析恶意修改的引导加载程序涉及恶意软件逆向工程、二进制代码反编译与反汇编，以及代码块的执行调试或追踪。仅此一主题就足以填满一本书，因此这里仅包括提取引导加载程序组件和数据以供分析。BIOS设置和EFI变量的分析是与操作系统无关的，这里只是简要提及。'
- en: '***BIOS/MBR GRUB Booting***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***BIOS/MBR GRUB引导***'
- en: Booting with an MBR is considered legacy, but it’s still used (often for small
    virtual machines). Modern UEFI mainboards support MBR boots using the *compatibility
    support module (CSM)*.^([2](footnotes.xhtml#ch06foot_02)) Checking the PC’s BIOS/firmware
    settings will indicate whether CSM booting is enabled.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MBR启动被视为遗留方式，但仍然在使用（通常用于小型虚拟机）。现代UEFI主板支持使用*兼容性支持模块（CSM）*进行MBR启动。^([2](footnotes.xhtml#ch06foot_02))
    检查PC的BIOS/固件设置可以确认是否启用了CSM引导。
- en: '[Figure 6-1](ch06.xhtml#ch06fig01) shows the diagram for Linux GRUB using the
    MBR.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-1](ch06.xhtml#ch06fig01)显示了使用MBR的Linux GRUB的示意图。'
- en: '![Image](Images/ch06fig01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/ch06fig01.jpg)'
- en: '*Figure 6-1: GRUB MBR boot data flow*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：GRUB MBR启动数据流*'
- en: The BIOS reads the first sector of a drive and executes the code if the last
    two bytes of sector zero are 0x55 and 0xAA.^([3](footnotes.xhtml#ch06foot_03))
    This signature indicates that it is an MBR. The 64 bytes just before the signature
    are reserved for a DOS partition table consisting of four entries of 16 bytes
    each. The first 446 bytes of an MBR contain executable binary code (written in
    assembly language) that is loaded into memory by the BIOS and executed. When you
    install or update the GRUB MBR, the *boot.img* file is written to sector zero
    (after being modified to the requirements of the system) and is used as the initial
    bootloader code.^([4](footnotes.xhtml#ch06foot_04))
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS读取磁盘的第一个扇区并执行代码，如果扇区零的最后两个字节是0x55和0xAA。^([3](footnotes.xhtml#ch06foot_03))
    这个签名表示它是一个MBR。签名前的64个字节保留给一个DOS分区表，该表由四个每个16字节的条目组成。MBR的前446个字节包含可执行的二进制代码（用汇编语言编写），该代码由BIOS加载到内存并执行。当你安装或更新GRUB的MBR时，*boot.img*文件会被写入扇区零（在根据系统要求修改后），并作为初始引导加载程序代码使用。^([4](footnotes.xhtml#ch06foot_04))
- en: 'GRUB’s MBR contains several searchable strings shown here together with their
    hexadecimal representation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB的MBR包含几个可以搜索的字符串，下面显示了它们的十六进制表示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `grub-install` program runs `grub-bios-setup` to write the MBR. The 512-byte
    boot sector (*boot.img*) can be extracted using `dd` or with a hex editor that
    supports exporting the sector.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`grub-install`程序运行`grub-bios-setup`来写入MBR。可以使用`dd`或支持导出扇区的十六进制编辑器提取512字节的引导扇区（*boot.img*）。'
- en: 'The code in sector zero is responsible for loading the next stage of the bootloader
    code and executing it. This subsequent code is also read directly from sectors
    on the disk; however, it is much larger (tens of kilobytes), giving it the functionality
    to understand partitions and filesystems, and read files. GRUB version 2 calls
    this stage the *core.img*, and it’s assembled from **.img* files and modules in
    the *grub/* directory. This image is created with `grub-mkimage` and written directly
    to the drive sectors when GRUB is installed or updated. The first sector of *core.img*
    is stored in the MBR at byte offset 92 (0x5c) and is 8 bytes long (stored in little-endian
    form on Intel). In DOS-partitioned drives, the *core.img* code is typically located
    in the area between the MBR (from sector 1) and the start of the first partition
    (usually sector 63 or 2048). If this “MBR gap” is not available, the *core.img*
    can be stored elsewhere on the drive and read using a specified list of sectors.
    The first sector of *core.img* contains several searchable strings shown in the
    following example together with their hexadecimal representation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 扇区零中的代码负责加载引导加载器代码的下一阶段并执行它。此后续代码也直接从磁盘上的扇区读取；然而，它的大小要大得多（数十千字节），因此它具有理解分区和文件系统并读取文件的功能。GRUB
    2版本将此阶段称为*core.img*，它由**.img**文件和*grub/*目录中的模块组成。此映像通过`grub-mkimage`创建，并在安装或更新GRUB时直接写入驱动器扇区。*core.img*的第一个扇区存储在MBR的字节偏移92（0x5c）处，长度为8个字节（在Intel上以小端形式存储）。在DOS分区驱动器中，*core.img*代码通常位于MBR（从扇区1开始）和第一个分区的起始位置（通常为扇区63或2048）之间的区域。如果此“MBR间隙”不可用，*core.img*可以存储在驱动器的其他位置，并通过指定的扇区列表读取。*core.img*的第一个扇区包含几个可搜索的字符串，下面是它们的示例及其十六进制表示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `grub-install` program runs `grub-mkimage` to create and write the *core
    .img* to the drive. The size of the *core.img* and the list of sectors used (“block
    list” in the documentation) are specified in the initial sector of *core.img*
    (called *diskboot.img*). The *core.img* sectors can be extracted using `dd` or
    with a hex editor that supports exporting by sector.^([5](footnotes.xhtml#ch06foot_05))
    The *core.img* code finds and reads the *grub.conf* file, loads additional GRUB
    modules, provides the menu system, and performs other GRUB tasks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`grub-install`程序运行`grub-mkimage`来创建并写入*core .img*到驱动器中。*core.img*的大小和使用的扇区列表（文档中的“块列表”）在*core.img*的初始扇区中指定（称为*diskboot.img*）。可以使用`dd`或支持按扇区导出的十六进制编辑器提取*core.img*扇区。*core.img*代码查找并读取*grub.conf*文件，加载额外的GRUB模块，提供菜单系统，并执行其他GRUB任务。'
- en: '***UEFI GRUB Booting***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***UEFI GRUB引导***'
- en: The BIOS/MBR boot process was introduced in the early 1980s with the original
    IBM PC. Around 20 years later, Intel developed a new more advanced firmware and
    boot system for PCs. This evolved into the UEFI standard that defines a modern
    interface between hardware and operating system. It includes a more scalable partitioning
    scheme called *GPT*, a file-based boot partition (instead of a sector-based mechanism)
    called the *EFI System Partition (ESP)*, and many other modern features.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS/MBR引导过程是在1980年代初期随着原始IBM PC的推出而引入的。大约20年后，英特尔为PC开发了一个更新、更先进的固件和引导系统。这一系统演变为UEFI标准，定义了硬件与操作系统之间的现代接口。它包括一种更具扩展性的分区方案，称为*GPT*，一种基于文件的引导分区（而非基于扇区的机制），称为*EFI系统分区（ESP）*，以及许多其他现代功能。
- en: To prevent accidental partition data loss on GPT-partitioned drives, a *protective
    MBR* is installed on sector zero that defines a single maximal DOS partition with
    a type 0xEE, indicating the drive is using GPT partitions. (The GPT partitioning
    scheme is discussed in [Chapter 3](ch03.xhtml).)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止在GPT分区驱动器上意外丢失分区数据，在扇区零上安装了*保护性MBR*，该MBR定义了一个最大DOS分区，类型为0xEE，指示该驱动器正在使用GPT分区。（GPT分区方案在[第3章](ch03.xhtml)中讨论。）
- en: The firmware’s increased sophistication helped reduce the complexity of the
    bootloading process. Unlike MBR, EFI booting does not require writing code blocks
    directly to raw sectors on a drive. Executable code can be placed in regular files
    and simply copied to expected locations on a normal FAT filesystem (the ESP).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 固件的日益复杂化有助于简化引导加载过程。与MBR不同，EFI引导不需要直接将代码块写入驱动器的原始扇区。可执行代码可以放在常规文件中，并简单地复制到正常FAT文件系统（ESP）中的预期位置。
- en: A Linux distribution can specify a path in the ESP for a file, such as *EFI/Linux/grubx64.efi*.
    If this file is not found (or the EFI variable is not set), the default file is
    located at *EFI/BOOT/BOOT64.EFI*. This file combines the functionality of both
    the *boot.img* and *core.img* files described in the preceding subsection. [Figure
    6-2](ch06.xhtml#ch06fig02) is a diagram of Linux GRUB using UEFI.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 发行版可以在 ESP 中指定文件的路径，例如 *EFI/Linux/grubx64.efi*。如果找不到此文件（或没有设置 EFI 变量），则默认文件位于
    *EFI/BOOT/BOOT64.EFI*。该文件结合了前面小节中描述的 *boot.img* 和 *core.img* 文件的功能。[图 6-2](ch06.xhtml#ch06fig02)
    是使用 UEFI 的 Linux GRUB 图示。
- en: '![Image](Images/ch06fig02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/ch06fig02.jpg)'
- en: '*Figure 6-2: Grub UEFI boot data flow*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：Grub UEFI 启动数据流*'
- en: A mainboard with UEFI support contains more interesting forensic evidence than
    traditional BIOS/MBR mainboards. The firmware contains persistent EFI variables,
    including information about current and previously installed operating systems,
    boot order, secure boot information, asset and inventory tags, and more (it’s
    generic and can be used to store any variables). Extracting and analyzing EFI
    variables from a mainboard’s NVRAM variables is beyond the scope of this book.
    GRUB detects whether a system is booting with UEFI or MBR and can install on both
    as appropriate.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 UEFI 的主板包含比传统 BIOS/MBR 主板更有趣的取证证据。固件中包含持久的 EFI 变量，包含当前和以前安装的操作系统信息、启动顺序、安全启动信息、资产和库存标签等（这些是通用的，可以用来存储任何变量）。从主板的
    NVRAM 变量中提取和分析 EFI 变量超出了本书的范围。GRUB 可以检测系统是使用 UEFI 还是 MBR 启动，并可以根据需要在两者上安装。
- en: 'From a forensics perspective, it’s important to identify and analyze suspicious
    binaries found in the ESP partition. ESP has been used for both exploitation and
    as a forensic technique for extracting memory. WikiLeaks has published leaked
    documents related to EFI and UEFI from Vault 7: CIA Hacking Tools Revealed (*[https://wikileaks.org/ciav7p1/cms/page_26968080.html](https://wikileaks.org/ciav7p1/cms/page_26968080.html)*).
    Academic research work has been done to describe the use of UEFI binaries for
    dumping memory images (*[https://www.diva-portal.org/smash/get/diva2:830892/FULLTEXT01.pdf](https://www.diva-portal.org/smash/get/diva2:830892/FULLTEXT01.pdf)*).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从取证角度来看，识别并分析在 ESP 分区中发现的可疑二进制文件是很重要的。ESP 曾被用于漏洞利用，也作为提取内存的取证技术。维基解密发布了与 EFI
    和 UEFI 相关的泄露文件，来自 Vault 7：CIA 黑客工具公开 (*[https://wikileaks.org/ciav7p1/cms/page_26968080.html](https://wikileaks.org/ciav7p1/cms/page_26968080.html)*)。学术研究也描述了使用
    UEFI 二进制文件转储内存镜像的情况 (*[https://www.diva-portal.org/smash/get/diva2:830892/FULLTEXT01.pdf](https://www.diva-portal.org/smash/get/diva2:830892/FULLTEXT01.pdf)*).
- en: '***GRUB Configuration***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***GRUB 配置***'
- en: The GRUB differences between MBR and UEFI are primarily found in the installation
    process (writing sectors for MBR versus copying files and setting EFI variables
    for UEFI). However, the configuration between the two is very similar.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB 在 MBR 和 UEFI 之间的主要差异体现在安装过程上（MBR 写入扇区，UEFI 复制文件并设置 EFI 变量）。然而，它们的配置非常相似。
- en: 'The configuration revolves around the *grub.conf* file, which is stored in
    different places depending on the distribution. Here are several typical locations
    where the *grub.conf* might be found:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 配置主要围绕 *grub.conf* 文件展开，具体存储位置取决于发行版。以下是几个典型的 *grub.conf* 可能存在的位置：
- en: '*/boot/grub/grub.cfg*'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/boot/grub/grub.cfg*'
- en: '*/boot/grub2/grub.cfg*'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/boot/grub2/grub.cfg*'
- en: '*EFI/fedora/grub.cfg* (on the UEFI FAT filesystem)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*EFI/fedora/grub.cfg*（在 UEFI FAT 文件系统上）'
- en: Sometimes a Linux system will have a separate small filesystem mounted on */boot/*
    where the GRUB configuration files are saved.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，Linux 系统会将一个单独的小文件系统挂载到 */boot/*，用于保存 GRUB 配置文件。
- en: The *grub.cfg* file is not usually modified by hand, but rather generated from
    the `grub-mkconfig` script (`update-grub` on some systems). These scripts read
    configuration variables from the */etc/default/grub* file and include helper scripts
    from the */etc/grub.d/* directory. The files */etc/grub.d/40_custom* and */boot/grub/custom.cfg*
    (if they exist) are intended for additional customization.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*grub.cfg* 文件通常不会手动修改，而是通过 `grub-mkconfig` 脚本（在某些系统上是 `update-grub`）生成。这些脚本从
    */etc/default/grub* 文件读取配置变量，并包含来自 */etc/grub.d/* 目录的辅助脚本。文件 */etc/grub.d/40_custom*
    和 */boot/grub/custom.cfg*（如果存在）用于额外的自定义设置。'
- en: 'The files mentioned here may contain changes and customization made by a system
    administrator and should be analyzed during a forensic examination. The following
    is a sample */etc/default/grub* file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的文件可能包含系统管理员所做的更改和自定义设置，在取证检查过程中应进行分析。以下是一个示例 */etc/default/grub* 文件：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The */usr/bin/grub-mkconfig* shell script^([6](footnotes.xhtml#ch06foot_06))
    contains all the variables that can be defined (look for the `GRUB_*` lines inside
    the script). The `GRUB_CMDLINE_*` variables are interesting because they contain
    information passed to the kernel. The other variables are processed by the helper
    scripts. On some systems, like Fedora and SUSE, */etc/sysconfig/grub* may be symbolically
    linked (symlinked) to */etc/default/grub*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*/usr/bin/grub-mkconfig* shell 脚本^([6](footnotes.xhtml#ch06foot_06)) 包含了所有可以定义的变量（在脚本内部查找
    `GRUB_*` 行）。`GRUB_CMDLINE_*` 变量很有意思，因为它们包含传递给内核的信息。其他变量由辅助脚本处理。在一些系统中，如 Fedora
    和 SUSE，*/etc/sysconfig/grub* 可能会通过符号链接（symlink）指向 */etc/default/grub*。'
- en: 'The resulting *grub.cfg* file consists of multiple sections generated from
    each of the helper scripts. GRUB has a built-in scripting language used to parse
    more complex *grub.cfg* files and provide an elaborate menu and submenu interface
    for a user to choose boot options. Here is an example of the menu options found
    in a sample *grub.cfg* file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 *grub.cfg* 文件由多个部分组成，这些部分是从每个辅助脚本生成的。GRUB 有一种内置的脚本语言，用于解析更复杂的 *grub.cfg*
    文件，并为用户提供详细的菜单和子菜单界面，以选择启动选项。以下是一个示例，展示了在示例 *grub.cfg* 文件中找到的菜单选项：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: During a forensic examination, the `menuentry` and `submenu` lines will potentially
    reveal other operating systems, past versions of other operating systems, and
    other setup/diagnostic options. For each of the menu options, the parameters passed
    to the kernel are defined, including current and past root UUIDs and the location
    of hibernation images (`resume=`). These are of interest in a Linux forensic examination
    because they provide a reconstruction of OS installation activity on the drive.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在法医检查过程中，`menuentry` 和 `submenu` 行可能会揭示其他操作系统、过去版本的其他操作系统以及其他设置/诊断选项。对于每个菜单选项，传递给内核的参数都已定义，包括当前和过去的根
    UUID 以及休眠镜像的位置（`resume=`）。这些在 Linux 法医检查中很有意义，因为它们提供了驱动器上操作系统安装活动的重建。
- en: Historically, Linux users would dual-boot their machines into different operating
    systems, but it is becoming more common to use virtual machines inside one host
    operating system. As a result, not all installed operating systems will be detected
    by the GRUB configuration scripts and visible in the *grub.cfg* file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，Linux 用户会在不同的操作系统之间双重启动，但现在在一个主机操作系统内部使用虚拟机变得越来越普遍。因此，并非所有已安装的操作系统都会被 GRUB
    配置脚本检测到，也不会在 *grub.cfg* 文件中显示。
- en: In addition to loading the kernel and initramfs binary images (described in
    the next section), GRUB can also load CPU firmware updates (from the same directory),
    which are typically *ucode.img* for Intel and *amd-ucode.img* for AMD.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加载内核和 initramfs 二进制镜像（将在下一节中描述），GRUB 还可以加载 CPU 固件更新（来自同一目录），通常对于 Intel 为 *ucode.img*，对于
    AMD 为 *amd-ucode.img*。
- en: 'In some cases, a GRUB password may be found. If this password is only to control
    access during boot, it won’t affect our ability to image or analyze the system
    in a forensic context. The following example (as generated by SUSE scripts) shows
    a password-protected *grub.cfg* entry:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能会找到 GRUB 密码。如果该密码仅用于在启动时控制访问，它不会影响我们在法医环境中获取镜像或分析系统的能力。以下示例（由 SUSE
    脚本生成）展示了一个受密码保护的 *grub.cfg* 条目：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another feature of GRUB is the ability to request a password to unlock a LUKS-encrypted
    root filesystem during the bootloading process (see the section on LUKS encryption
    in [Chapter 3](ch03.xhtml)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB 的另一个功能是在启动加载过程中请求密码，以解锁 LUKS 加密的根文件系统（见 [第 3 章](ch03.xhtml) 中的 LUKS 加密部分）。
- en: You can find the grub scripting language used in *grub.cfg*, file formats, design
    details, and much more in the online manual (*[https://www.gnu.org/software/grub/manual/grub/](https://www.gnu.org/software/grub/manual/grub/)*).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在在线手册中找到 *grub.cfg* 中使用的 GRUB 脚本语言、文件格式、设计细节以及更多内容（* [https://www.gnu.org/software/grub/manual/grub/](https://www.gnu.org/software/grub/manual/grub/)
    *）。
- en: '***Other Bootloaders***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他引导加载程序***'
- en: SYSLINUX is a bootloader designed to boot from a DOS/Windows filesystem making
    it easier for new Linux users to install Linux or test a live system. It is also
    sometimes used for booting Linux rescue images. A SYSLINUX image can be identified
    by the existence of the *LDLINUX.SYS* file in the root directory. In addition,
    a *syslinux.cfg* configuration file may be located in the root (/) directory or
    the */boot/* or */syslinux/* subdirectories. This file determines how SYSLINUX
    behaves and may include (using the `INCLUDE` configuration parameter) other configuration
    files. These files contain information like menu options, the location of the
    kernel image and initial ramdisk, the kernel command line, and other defined variables.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: SYSLINUX 是一个设计用来从 DOS/Windows 文件系统引导的引导加载程序，它使新手 Linux 用户能够更容易地安装 Linux 或测试实时系统。它有时也用于引导
    Linux 救援镜像。可以通过根目录中存在 *LDLINUX.SYS* 文件来识别 SYSLINUX 镜像。此外，*syslinux.cfg* 配置文件可能位于根目录（/）或
    */boot/* 或 */syslinux/* 子目录中。该文件决定了 SYSLINUX 的行为，并可能包含（使用 `INCLUDE` 配置参数）其他配置文件。这些文件包含信息，例如菜单选项、内核镜像和初始
    ramdisk 的位置、内核命令行及其他定义的变量。
- en: SYSLINUX files are located on a FAT filesystem that can be analyzed with regular
    filesystem forensic tools. Within the same software project, the ISOLINUX, EXTLINUX,
    and PXELINUX variants are also available for booting from optical discs, Linux
    filesystems, and network booting with PXE (using DHCP and TFTP). See the project’s
    website (*[https://www.syslinux.org/](https://www.syslinux.org/)*) for more information.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: SYSLINUX 文件位于 FAT 文件系统上，可以使用常规的文件系统取证工具进行分析。在同一软件项目中，还有 ISOLINUX、EXTLINUX 和
    PXELINUX 变体，分别用于从光盘、Linux 文件系统和网络引导（使用 DHCP 和 TFTP）进行启动。有关更多信息，请访问该项目的官方网站 (*[https://www.syslinux.org/](https://www.syslinux.org/)*).
- en: The systemd developers created an alternative UEFI bootloader and manager called
    systemd-boot (formerly known as Gummiboot), which was designed to provide a simple
    menu system, basic configuration files, and other features. One characteristic
    of systemd-boot is the expectation that the kernel and initial ramdisk images
    reside in the EFI system partition. The mainboard’s NVRAM stores a number of systemd-boot-related
    EFI variables. The UEFI firmware executes `systemd-bootx64.efi`, an EFI binary
    that looks for the default configuration file *loader/loader.conf*. Further configuration
    for booting multiple operating systems is found in *loader/entries/** (typically
    one directory per operating system boot option). From a digital forensics perspective,
    the entire bootloading process and files are all contained within a single FAT
    filesystem that can be analyzed using common FAT filesystem forensic tools to
    identify timestamps and evidence of deleted files. For more information, see the
    systemd-boot(7) man page and the Boot Loader Specification document (*[https://systemd.io/BOOT_LOADER_SPECIFICATION/](https://systemd.io/BOOT_LOADER_SPECIFICATION/)*).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 开发者创建了一个替代的 UEFI 引导加载程序和管理器，名为 systemd-boot（前身为 Gummiboot），旨在提供一个简单的菜单系统、基本的配置文件和其他功能。systemd-boot
    的一个特点是期望内核和初始 ramdisk 镜像位于 EFI 系统分区中。主板的 NVRAM 存储了一些与 systemd-boot 相关的 EFI 变量。UEFI
    固件执行 `systemd-bootx64.efi`，这是一个 EFI 二进制文件，它查找默认配置文件 *loader/loader.conf*。有关多操作系统启动的进一步配置可以在
    *loader/entries/** 中找到（通常每个操作系统启动选项对应一个目录）。从数字取证的角度来看，整个引导过程和文件都包含在一个 FAT 文件系统中，可以使用常见的
    FAT 文件系统取证工具来分析文件的时间戳和已删除文件的证据。有关更多信息，请参阅 systemd-boot(7) 手册和引导加载程序规范文档 (*[https://systemd.io/BOOT_LOADER_SPECIFICATION/](https://systemd.io/BOOT_LOADER_SPECIFICATION/)*).
- en: Diskless systems may use the Preboot eXecution Environment (PXE) to boot the
    operating system over the network. Here the mainboard firmware makes DHCP requests
    to the local network segment and then fetches the bootloader, kernel, and initramfs.
    The root filesystem is then mounted via NFS or other network file-sharing protocol.
    A netbooting machine might still have a local drive for caching or swap, which
    can be analyzed. If no physical drive is installed, all forensic evidence (operating
    system filesystem tree, home directories, and so on) will reside on the PXE server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 无盘系统可以使用预启动执行环境（PXE）通过网络引导操作系统。在这里，主板固件向本地网络段发送 DHCP 请求，然后获取引导加载程序、内核和 initramfs。根文件系统随后通过
    NFS 或其他网络文件共享协议进行挂载。网络启动的计算机可能仍然有本地驱动器用于缓存或交换，这些都可以进行分析。如果没有安装物理驱动器，所有取证证据（操作系统文件系统树、用户主目录等）将存储在
    PXE 服务器上。
- en: The Raspberry Pi does not use MBR, UEFI, or even GRUB for booting, relying instead
    on its own multistage boot process.^([7](footnotes.xhtml#ch06foot_07)) The first
    stage of the bootloader is code in the ROM, which loads the second stage *bootcode.bin*
    file (this file is stored in the EEPROM of Raspberry Pi 4 models). The third stage
    (*start*.elf* ) is a binary firmware image that finds and starts the kernel. Potentially
    interesting artifacts are the user configurable settings in several files in the
    */boot/* directory. The *cmdline.txt* file specifies parameters that are passed
    to the kernel. The *settings.conf* file specifies the parameters for the bootloaders
    to configure the Raspberry Pi during startup. A *wpa_supplicant.conf* file that
    contains a Wi-Fi network and password may also exist. If an *ssh* or *ssh.txt*
    file existed during the first boot, a systemd unit (*/lib/systemd/system/sshswitch.service*)
    would enable SSH and remove the file. These are documented at the official Raspberry
    Pi website (*[https://www.raspberrypi.org/documentation/](https://www.raspberrypi.org/documentation/)*).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派不使用 MBR、UEFI 或甚至 GRUB 进行启动，而是依赖于自己的一种多阶段启动过程。^([7](footnotes.xhtml#ch06foot_07))
    启动加载程序的第一阶段是 ROM 中的代码，它加载第二阶段的 *bootcode.bin* 文件（该文件存储在树莓派 4 型号的 EEPROM 中）。第三阶段（*start*.elf）是一个二进制固件镜像，它查找并启动内核。潜在有趣的文物是
    *boot/* 目录下几个文件中的用户可配置设置。*cmdline.txt* 文件指定传递给内核的参数。*settings.conf* 文件指定用于在启动时配置树莓派的引导加载程序的参数。可能还存在一个包含
    Wi-Fi 网络和密码的 *wpa_supplicant.conf* 文件。如果在第一次启动时存在 *ssh* 或 *ssh.txt* 文件，systemd
    单元（*/lib/systemd/system/sshswitch.service*）将启用 SSH 并删除该文件。有关这些信息，请参阅树莓派官方网站 (*[https://www.raspberrypi.org/documentation/](https://www.raspberrypi.org/documentation/)*）。
- en: It is also worth mentioning Linux containers and how they boot. Because containers
    are started from within a running Linux host system and share the same kernel
    as the host, they don’t need a bootloader. A Linux system can be booted in a container
    with a separate filesystem tree using commands provided by the container manager
    (LXC, systemd-nspawn, and so on). Forensic analysis here may involve the examination
    of both the hosting system and the container’s file tree.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，值得一提的是 Linux 容器及其启动方式。由于容器是在运行中的 Linux 主机系统内启动的，并与主机共享相同的内核，因此它们不需要引导加载程序。可以使用容器管理器（如
    LXC、systemd-nspawn 等）提供的命令，在容器中启动具有独立文件系统树的 Linux 系统。在此进行法医分析时，可能需要检查宿主系统和容器的文件树。
- en: '**Analysis of Kernel Initialization**'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**内核初始化分析**'
- en: The Linux kernel is modular and configurable. Kernel modules can be built into
    the kernel at compile time, dynamically loaded at boot or during operation, or
    manually loaded by the user. The configuration of the core kernel and modules
    can be done during boot, when loading a module (`modprobe`) or manually by the
    user. In this section, I describe how to identify which modules were loaded and
    how the kernel is configured.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核是模块化和可配置的。内核模块可以在编译时构建到内核中，也可以在启动或操作期间动态加载，或由用户手动加载。内核和模块的配置可以在启动时进行，加载模块时（`modprobe`），或由用户手动配置。本节中，我将描述如何识别已加载的模块以及内核的配置方式。
- en: The modules loaded and the configured state of the kernel change dynamically
    during operation and are visible only while the machine is running. Postmortem
    forensic analysis must be done through induction or inference because we can’t
    observe the running kernel (unless we have a memory image). This section focuses
    on the modules and configuration defined at boot time and attempts to find traces
    of other changes during operation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的加载和内核的配置状态在操作过程中动态变化，并且只有在机器运行时才可见。事后法医分析必须通过推导或推测来进行，因为我们无法观察到正在运行的内核（除非我们有内存镜像）。本节重点讨论启动时定义的模块和配置，并尝试查找操作过程中发生的其他变化的痕迹。
- en: 'In a forensic context, knowing the kernel’s configuration and loaded modules
    helps us reconstruct the state of the machine under analysis, which helps us answer
    various questions and identify the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在法医分析中，了解内核的配置和已加载的模块帮助我们重建正在分析的机器的状态，这有助于回答各种问题并识别以下内容：
- en: Non-default kernel modules loaded
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载的非默认内核模块
- en: Default kernel modules prevented from being loaded
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止加载的默认内核模块
- en: Kernel configuration explicitly defined or changed
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确或更改的内核配置
- en: Explicit changes manually made by a system administrator
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统管理员明确手动做出的更改
- en: Changes introduced by malicious actors
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意行为者引入的变化
- en: We are especially interested in the modules and configuration that deviate from
    the defaults of the distribution or installed software packages. If we can identify
    non-default, explicit, or deliberate activity, we can try to determine why and
    how these changes happened.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别关注那些偏离发行版或已安装软件包默认设置的模块和配置。如果我们能够识别出非默认、显式或故意的活动，我们可以尝试找出这些变化发生的原因和方式。
- en: '***Kernel Command Line and Runtime Parameters***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内核命令行和运行时参数***'
- en: The kernel is just a program, albeit a unique and special one. Like most programs,
    it can be started with parameters to provide some initial configuration. These
    parameters, sometimes called the *kernel command line*, are provided by the bootloader
    and passed to the kernel at boot time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 内核只是一个程序，尽管它是一个独特且特殊的程序。像大多数程序一样，它可以通过参数启动，以提供一些初始配置。这些参数有时被称为*内核命令行*，由引导加载程序提供，并在启动时传递给内核。
- en: 'The kernel command line parameters configure several parts of the system during
    boot, including the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 内核命令行参数在启动时配置系统的多个部分，包括以下内容：
- en: Core kernel parameters
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心内核参数
- en: Parameters for modules built in to the kernel
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核内置模块的参数
- en: Init system parameters (`systemd pid 1`)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化系统参数（`systemd pid 1`）
- en: The kernel understands multiple parameters that allow it to configure itself
    when executed. Built-in kernel modules can be configured using a dot (`.`) separating
    the module name and the module parameter; for example, `libata.allow_tpm=1`. Parameters
    specified for loadable modules may be handled by the startup scripts and units
    of the init process. Parameters that the kernel is unable to understand are passed
    on to the init system, either as command parameters or as environment variables.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 内核理解多个参数，这些参数允许它在执行时进行自我配置。内置的内核模块可以通过点号（`.`）分隔模块名称和模块参数来配置；例如，`libata.allow_tpm=1`。为可加载模块指定的参数可能由初始化进程的启动脚本和单元处理。内核无法理解的参数会传递给初始化系统，无论是作为命令参数还是环境变量。
- en: On a running system, the command line is found in */proc/cmdline*; however,
    for a postmortem investigation, we must find evidence in persistent storage. Because
    the bootloader passes the command line to the kernel, the parameters are likely
    stored in the bootloader configuration (which we covered in the previous section).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行中的系统上，命令行位于*/proc/cmdline*；然而，对于死后调查，我们必须在持久存储中寻找证据。由于引导加载程序将命令行传递给内核，因此这些参数可能存储在引导加载程序配置中（我们在前面一节中已讨论）。
- en: 'For the GRUB bootloader, the kernel command parameters are typically found
    in the */boot/grub/grub.cfg* file (some distros use a *grub2* directory). Look
    for a line (possibly indented) that starts with `linux` followed by the path to
    a kernel image. The parameters are listed after the kernel image filename, such
    as the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 GRUB 引导加载程序，内核命令参数通常可以在*/boot/grub/grub.cfg*文件中找到（某些发行版使用*grub2*目录）。查找以`linux`开头的行（可能有缩进），后面跟着内核镜像的路径。参数列在内核镜像文件名之后，如下所示：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the root filesystem is defined (`root=UUID=...`), the hibernate
    partition is defined (`resume=UUID=...`), a parameter for the built-in `libata`
    module is configured (`libata.allow_tpm=1`), a core kernel parameter is configured
    (`intel_iommu=on`), and network configuration is passed on to systemd init (`net.ifnames=0`).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，定义了根文件系统（`root=UUID=...`），定义了休眠分区（`resume=UUID=...`），配置了内置的`libata`模块参数（`libata.allow_tpm=1`），配置了核心内核参数（`intel_iommu=on`），并将网络配置传递给
    systemd 初始化（`net.ifnames=0`）。
- en: As mentioned earlier, the *grub.cfg* file is typically generated with scripts.
    These scripts read the */etc/default/grub* file for additional kernel parameters
    defined in `GRUB_CMDLINE_*` variables. For systemd-boot, the kernel parameters
    are defined in the *loader/entries/** files. On Raspberry Pi systems, the user-configurable
    kernel command line is stored in */boot/cmdline.txt* (the boot process may add
    additional parameters before starting the kernel). The kernel-command-line(7)
    man page describes additional parameters that are interpreted by the systemd initialization
    process.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，*grub.cfg*文件通常是通过脚本生成的。这些脚本读取*/etc/default/grub*文件，以获取在`GRUB_CMDLINE_*`变量中定义的附加内核参数。对于
    systemd-boot，内核参数定义在*loader/entries/**文件中。在 Raspberry Pi 系统上，用户可配置的内核命令行存储在*/boot/cmdline.txt*中（启动过程可能会在启动内核之前添加附加参数）。内核命令行(7)手册页面描述了由
    systemd 初始化过程解释的附加参数。
- en: 'Potentially interesting forensic artifacts on the kernel command line are:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 内核命令行上可能有趣的法医证据包括：
- en: The name and location of the kernel image
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核镜像的名称和位置
- en: The location (and possible UUID) of the root filesystem (`root=`)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件系统的位置（及可能的 UUID）（`root=`）
- en: The location of a potential hibernation memory dump (`resume=`)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 潜在的休眠内存转储的位置（`resume=`）
- en: The configuration of modules to be loaded (`module.parameter=`)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要加载的模块的配置（`module.parameter=`）
- en: Possible alternative init^([8](footnotes.xhtml#ch06foot_08)) program (`init=`)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的替代 init^([8](footnotes.xhtml#ch06foot_08)) 程序（`init=`）
- en: Other kernel configuration indicating the use of certain hardware
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他指示使用某些硬件的内核配置
- en: Possible indicators of manipulation or abuse
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的篡改或滥用迹象
- en: Understanding the kernel command line gives the investigator a more complete
    understanding of the Linux system under examination. See the bootparam(7) man
    page and the Linux kernel documentation (*[https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html](https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html)*)
    for a list of commands and further information.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 理解内核命令行能让调查人员更全面地理解正在检查的 Linux 系统。有关命令列表和更多信息，请参见 bootparam(7) 手册页和 Linux 内核文档
    (*[https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html](https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html)*)。
- en: '***Kernel Modules***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内核模块***'
- en: Modules add kernel functionality to manage filesystems, network protocols, hardware
    devices, and other kernel subsystems. Modules can be statically built in to the
    kernel at compile time or dynamically added to a running kernel.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 模块为内核提供功能，以管理文件系统、网络协议、硬件设备和其他内核子系统。模块可以在编译时静态构建到内核中，也可以动态添加到正在运行的内核中。
- en: 'To list the modules statically compiled into the kernel, we can view the */lib/modules/*/modules.builtin*
    file for the installed kernel:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出静态编译到内核中的模块，我们可以查看安装的内核中的*/lib/modules/*/modules.builtin*文件：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because these modules are static on the filesystem, they are easy to identify
    and examine in a postmortem forensic analysis. There may also be multiple kernels
    installed that can be compared to one another as well as with the original files
    in the distribution’s release.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些模块在文件系统中是静态的，所以它们在事后取证分析中很容易识别和检查。可能还会安装多个内核，可以将它们相互比较，并与发行版的原始文件进行比较。
- en: Modules inserted and removed dynamically can be identified from the boot configuration
    and available logs. To determine the modules loaded at boot time, we can examine
    configuration files in several places.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 动态插入和移除的模块可以通过启动配置和可用日志来识别。要确定启动时加载的模块，可以检查多个地方的配置文件。
- en: 'The systemd initialization process provides the `systemd-modules-load` `.service`
    to load kernel modules during boot. A local user (or system administrator) can
    explicitly load modules at boot by placing configuration files in */etc/modules-load.d/*.conf*.
    Software packages that provide their own configuration to load modules explicitly
    can be found in */usr/lib/modules -load.d/*.conf*. Here is an example of a configuration
    file to load modules for the CUPS printing system:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 初始化过程提供了 `systemd-modules-load` `.service` 来在启动时加载内核模块。用户（或系统管理员）可以通过将配置文件放入
    */etc/modules-load.d/*.conf* 来显式加载模块。提供自己配置来显式加载模块的软件包可以在 */usr/lib/modules-load.d/*.conf*
    中找到。以下是一个加载 CUPS 打印系统模块的配置文件示例：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See the systemd-modules-load(8) and modules-load.d(5) man pages for more information.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参见 systemd-modules-load(8) 和 modules-load.d(5) 手册页。
- en: There are other places to look for evidence of kernel module loading/ unloading
    activity. Some distributions (Debian-based, for example) may have an */etc/modules*
    file containing a list of additional modules to be loaded at boot time. The shell
    history files (for both root and non-root users possibly using `sudo`) can be
    searched for evidence of commands, such as `modprobe`, `insmod`, or `rmmod` to
    identify modules inserted or removed by a user. The kernel command line may be
    used to load modules during the early boot process (by systemd). These command
    line options are `modules_load=<modulename>` or `rd.modules_load=<modulename>`;
    the latter refers to the initial RAM disk (rd).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他地方可以查找内核模块加载/卸载活动的证据。一些发行版（例如基于 Debian 的发行版）可能会有一个*/etc/modules*文件，里面包含了启动时需要加载的额外模块列表。可以通过搜索
    shell 历史文件（包括 root 用户和可能使用 `sudo` 的非 root 用户）来查找包含命令的证据，例如`modprobe`、`insmod`或`rmmod`，以识别用户插入或移除的模块。内核命令行可以在早期启动过程中（由
    systemd 进行）用来加载模块。这些命令行选项是`modules_load=<modulename>`或`rd.modules_load=<modulename>`；后者指的是初始
    RAM 磁盘（rd）。
- en: 'Inserting and removing modules in the kernel may or may not generate log entries.
    The amount of logging is up to the module’s developer. For example, the `i2c_dev`
    driver prints nothing when removed from the kernel, and prints only minimal information
    when inserted. Here’s the log entry in dmesg:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核中插入和移除模块可能会或可能不会生成日志条目。日志记录的多少取决于模块的开发者。例如，`i2c_dev`驱动程序在从内核中移除时不打印任何内容，插入时仅打印最少的信息。以下是dmesg中的日志条目：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If kernel module log information is generated (via the kernel ring buffer),
    it will typically be passed to dmesg, syslog, or the systemd journal. See [Chapter
    5](ch05.xhtml) for more information about examining kernel messages.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成内核模块日志信息（通过内核环形缓冲区），它通常会传递到dmesg、syslog或systemd日志中。有关检查内核消息的更多信息，请参见[第5章](ch05.xhtml)。
- en: During a forensic examination, these module configuration files and directories
    should be reviewed for unusual or unexplained kernel modules. In particular, modules
    that deviate from the distribution and software package defaults should be examined.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在取证检查过程中，应检查这些模块配置文件和目录，查看是否有不寻常或无法解释的内核模块。特别是，应检查那些偏离发行版和软件包默认设置的模块。
- en: '***Kernel Parameters***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内核参数***'
- en: The initial kernel configuration is set during system startup, with dynamic
    reconfiguration occurring later based on the needs of the system over time. Some
    examples of dynamically changing configuration might include adding, removing,
    or modifying hardware; changing network settings; mounting filesystems; and so
    on. Even the hostname is a kernel configuration setting that is set during system
    boot. Forensic analysis here involves reconstructing the kernel’s configuration
    at boot time and determining changes that happened over time during system operation.
    In particular, we’re interested in configuration that deviates from normal defaults,
    possibly introduced by the user or a malicious actor.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 初始内核配置在系统启动时设置，随后根据系统需求动态重新配置。动态更改配置的一些示例可能包括添加、移除或修改硬件；更改网络设置；挂载文件系统等。甚至主机名也是在系统启动时设置的内核配置项。此处的取证分析涉及重建系统启动时的内核配置，并确定系统运行过程中发生的变化。特别是，我们关注偏离正常默认值的配置，可能是用户或恶意行为者所引入的。
- en: 'Kernel parameters can also be specified manually at runtime. On a running system,
    the system administrator can read and write kernel parameters with the `sysctl`
    command or by redirecting text to/from the appropriate pseudo-files in the */proc/sys/*
    directory. In a postmortem forensic investigation, we can search for evidence
    of the `sysctl` command in the shell history files or in logs indicating that
    `sysctl` was used with privilege escalation. The following example shows a non-privileged
    user (Sam) setting a kernel parameter with the sysctl `-w` flag:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在运行时手动指定内核参数。在运行中的系统上，系统管理员可以使用`sysctl`命令读取和写入内核参数，或者通过将文本重定向到/从*/proc/sys/*目录中的适当伪文件进行操作。在事后取证调查中，我们可以在shell历史文件中或日志中搜索`sysctl`命令的痕迹，查看是否有`sysctl`命令与权限提升一起使用的证据。以下示例显示了一个非特权用户（Sam）使用sysctl
    `-w`标志设置内核参数：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This user enabled IPv6 packet forwarding. If an organization focused only on
    managing IPv4 security, this action could be a malicious attempt to bypass network
    controls or reduce the chances of detection.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该用户启用了IPv6数据包转发。如果一个组织只专注于管理IPv4安全性，那么这一行为可能是绕过网络控制或减少检测机会的恶意尝试。
- en: 'Kernel parameters can also be set at boot time by adding them to configuration
    files. These follow the typical Linux convention of a configuration file in */etc/*
    and directories for additional configuration files and are located in the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 内核参数还可以通过将其添加到配置文件中，在启动时进行设置。这些配置文件遵循典型的Linux惯例，配置文件位于*/etc/*目录下，附加配置文件则位于以下目录：
- en: '*/etc/sysctl.conf*'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/etc/sysctl.conf*'
- en: '*/etc/sysctl.d/*.conf*'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/etc/sysctl.d/*.conf*'
- en: '*/usr/lib/sysctl.d/*.conf*'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/usr/lib/sysctl.d/*.conf*'
- en: A system administrator will typically make changes to *sysctl.conf* or create
    files in the */etc/sysctl.d/* directory. Installed packages requiring kernel configuration
    may also place configuration files in the */usr/lib/sysctl.d/* directory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员通常会修改*sysctl.conf*或在*/etc/sysctl.d/*目录中创建文件。需要内核配置的已安装软件包也可能将配置文件放在*/usr/lib/sysctl.d/*目录中。
- en: During a forensic investigation, files and directories providing sysctl configuration
    should be reviewed for unusual or unexplained kernel settings. Custom modifications
    and deviations from the distribution defaults can be found by comparing them to
    the original files. The creation and last modified timestamp on the files is a
    potential indicator of when the changes took place. Manual kernel setting changes
    may provide additional insight into an investigation (for example, changes could
    indicate the manual installation of a particular hardware device at some point
    in the past).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在取证调查期间，应审核提供 sysctl 配置的文件和目录，以寻找不寻常或未解释的内核设置。通过将它们与原始文件进行比较，可以找到自定义修改和与发行版默认设置的偏差。文件的创建时间和最后修改时间可能是变更发生时间的潜在指标。手动内核设置更改可能为调查提供额外洞察（例如，变更可能指示在过去某个时点手动安装特定硬件设备）。
- en: See the sysctl(8), sysctl.conf(5), and sysctl.d(5) man pages for more information
    about sysctl.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 sysctl 的信息，请参阅 sysctl(8)、sysctl.conf(5) 和 sysctl.d(5) 手册页面。
- en: '***Analyzing initrd and initramfs***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析 initrd 和 initramfs***'
- en: The kernel binary executable is typically called vmlinuz^([9](footnotes.xhtml#ch06foot_09))
    and is usually found in the */boot/* directory. It may also be a symlink to a
    filename with version information (for example, *vmlinuz-5.4.0-21-generic*). You
    will typically find a companion file called *initrd* or *initramfs* (sometimes
    with the **.img* extension). These files may also be symlinks to filenames with
    version information (for example, *initrd.img-5.4.0-21-generic* or *initramfs-5.4-x86_64.img*).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 内核二进制可执行文件通常称为 vmlinuz^([9](footnotes.xhtml#ch06foot_09))，通常位于 */boot/* 目录中。它也可能是指向带有版本信息的文件名的符号链接（例如
    *vmlinuz-5.4.0-21-generic*）。通常还会找到一个称为 *initrd* 或 *initramfs* 的伴侣文件（有时带有 **.img*
    扩展名）。这些文件也可能是指向带有版本信息的文件名的符号链接（例如 *initrd.img-5.4.0-21-generic* 或 *initramfs-5.4-x86_64.img*）。
- en: 'The *initrd* and *initramfs* files solve a chicken-or-egg problem when the
    kernel boots. The kernel needs various files, utilities, and modules to mount
    the root filesystem, but those items are located on the root filesystem that can’t
    be mounted yet. To solve this problem, the bootloader loads a temporary minimal
    root filesystem containing all the required files into memory and provides it
    to the kernel as a RAM disk. This is called the *initial RAM disk*, and it comes
    in two forms: initrd and initramfs (see the initrd(4) man page for more information).
    The initial RAM disk file is created with scripts, usually run by bootloader tools
    (mkinitramfs, mkinitcpio, or dracut) during installation or when the kernel is
    changed or upgraded.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*initrd* 和 *initramfs* 文件解决了内核引导时的鸡和蛋问题。内核需要各种文件、实用工具和模块来挂载根文件系统，但这些项目位于尚未能够挂载的根文件系统上。为了解决这个问题，引导加载程序将临时的最小根文件系统加载到内存中，并将其作为
    RAM 磁盘提供给内核。这称为*初始 RAM 磁盘*，有两种形式：initrd 和 initramfs（有关更多信息，请参阅 initrd(4) 手册页面）。初始化
    RAM 磁盘文件是通过安装或更改/升级内核时由引导加载程序工具（如 mkinitramfs、mkinitcpio 或 dracut）运行脚本创建的。'
- en: The kernel runs the init program found inside the initramfs (parameters can
    be passed on the kernel command line), and the initial setup begins. Some distros
    use busybox^([10](footnotes.xhtml#ch06foot_010)) as the init program within the
    initramfs. Others, often dracut-based,^([11](footnotes.xhtml#ch06foot_011)) use
    systemd init. When finished, there is a switch to the main root filesystem and
    execution is passed to the main init system to begin the full system startup.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 内核运行内部初始化程序，该程序位于 initramfs 中（参数可以传递给内核命令行），并且初始设置开始。一些发行版使用 busybox^([10](footnotes.xhtml#ch06foot_010))
    作为 initramfs 中的初始化程序。其他一些，通常基于 dracut^([11](footnotes.xhtml#ch06foot_011))，使用
    systemd 初始化。完成后，切换到主根文件系统并将执行权传递给主初始化系统以开始完整系统启动。
- en: 'From a forensics perspective, the contents of the initial RAM disks may contain
    interesting information about the system and the boot process, such as the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从取证的角度来看，初始 RAM 磁盘的内容可能包含有关系统和引导过程的有趣信息，例如以下内容：
- en: Possible file timestamps (though some systems set files to the Unix epoch, January
    1, 1970)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的文件时间戳（尽管一些系统将文件设置为 Unix 纪元，即 1970 年 1 月 1 日）
- en: List of executables and kernel modules
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行文件和内核模块列表
- en: Configuration files (like */etc/fstab*)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件（如 */etc/fstab*）
- en: Scripts (startup, custom, and so on)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本（启动、自定义等）
- en: Information about RAID configuration
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAID 配置的信息
- en: Information about encrypted filesystems
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密文件系统的信息
- en: Kiosk and IoT device custom startup
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kiosk 和 IoT 设备的自定义启动
- en: For cases involving encrypted filesystems, the initial RAM disk may be the only
    unencrypted data available to analyze. There could also be information about the
    decryption process and location of keys.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及加密文件系统的情况下，初始RAM磁盘可能是唯一可以分析的未加密数据。可能还会包含解密过程和密钥位置的信息。
- en: If commercial forensic tools cannot access the contents of initial RAM disk
    files, an investigator can copy the file to a similar Linux distribution and use
    Linux commands to perform the analysis.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果商业取证工具无法访问初始RAM磁盘文件的内容，调查员可以将文件复制到类似的Linux发行版中，使用Linux命令进行分析。
- en: 'For example, listing the contents of an Arch Linux *initramfs* file using `lsinitcpio`,
    looks like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用`lsinitcpio`列出Arch Linux *initramfs*文件的内容如下所示：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `lsinitcpio` command also provides a useful analysis summary with the `-a`
    flag.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsinitcpio`命令还可以通过`-a`标志提供有用的分析摘要。'
- en: 'Listing the contents of a Debian *initrd* file using `lsinitramfs` looks like
    the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`lsinitramfs`列出Debian *initrd*文件内容的输出如下所示：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Fedora and SUSE have a similar tool called `lsinitrd` to list the contents of
    the initial RAM disk files.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora和SUSE有一个类似的工具叫做`lsinitrd`，用来列出初始RAM磁盘文件的内容。
- en: 'After listing the contents of the files, it may be useful to extract files
    for further analysis. One easy way to do this is to extract everything into a
    separate directory using the `unmkinitramfs` or `lsinitcpio` tools, depending
    on the Linux distribution. Here is an example of extracting an *initrd* file on
    a Debian system:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列出文件内容后，可能需要提取文件以进行进一步分析。一个简单的方法是使用`unmkinitramfs`或`lsinitcpio`工具将所有内容提取到一个单独的目录中，具体取决于Linux发行版。以下是在Debian系统上提取*initrd*文件的示例：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On an Arch system, the same `lsinitcpio` command can be used, but with the
    `-x` flag:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arch系统上，可以使用相同的`lsinitcpio`命令，但需要加上`-x`标志：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In these examples, `unmkinitramfs` and `lsinitcpio` will extract the contents
    into the current directory and thus expect to have write permission. For a postmortem
    examination, the file being analyzed can be copied to a separate analysis system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，`unmkinitramfs`和`lsinitcpio`会将内容提取到当前目录，因此需要具有写权限。对于死后检查，被分析的文件可以复制到一个单独的分析系统中。
- en: 'It should be possible to analyze these files with regular commercial forensic
    tools without a Linux system. The files are typically compressed CPIO archives
    using gzip or zstd. The file can be decompressed first and then handled as a normal
    CPIO archive (a standard Unix format, similar to tar). These two examples list
    an *initramfs*’s contents by piping from a compression program (`gunzip` or `zstcat`)
    into the `cpio` program:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，应该可以使用常规的商业取证工具分析这些文件，而不需要Linux系统。文件通常是使用gzip或zstd压缩的CPIO归档文件。文件可以先解压，然后像正常的CPIO归档（标准Unix格式，类似于tar）一样处理。这两个示例通过将压缩程序（`gunzip`或`zstcat`）的输出传递给`cpio`程序，列出*initramfs*的内容：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Removing the `t` flag from the `cpio` flags will extract the contents into the
    current directory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 移除`cpio`标志中的`t`标志会将内容提取到当前目录中。
- en: 'The bootloader can also load CPU microcode updates in a similar way to *initrd*
    files. These may also be packaged as CPIO files (but not compressed), and the
    contents can be listed with the `cpio` command. Two examples with Intel and AMD
    processors are shown here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 启动加载程序也可以以类似于*initrd*文件的方式加载CPU微代码更新。这些也可能以CPIO文件的形式打包（但不压缩），并且可以使用`cpio`命令列出内容。以下是显示Intel和AMD处理器的两个示例：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The timestamps in these files may vary. They can be from the original packaging
    process or from the local install process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件中的时间戳可能不同。它们可以来自原始打包过程，也可以来自本地安装过程。
- en: Some *initramfs* files (Red Hat, for example) contain a single archive for firmware
    and initramfs (appended to each other). To extract the second one, use the `skipcpio`
    tool from the dracut software package.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一些*initramfs*文件（例如Red Hat）包含一个固件和initramfs的单一归档文件（彼此附加）。要提取第二个文件，可以使用`skipcpio`工具，该工具来自dracut软件包。
- en: The Raspberry Pi operates differently and doesn’t need an initial RAM disk.
    Because the hardware is standard, Raspberry Pi developers can create a specific
    kernel with all the necessary drivers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi的操作方式不同，不需要初始RAM磁盘。由于硬件是标准化的，Raspberry Pi开发人员可以创建一个包含所有必要驱动程序的特定内核。
- en: '**Analysis of Systemd**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Systemd分析**'
- en: From a digital forensics perspective, we want to understand what the system
    was doing during startup, how it appears in a fully booted target state, and what
    activity has taken place over time. In particular, we are reconstructing configuration
    and activity that deviates from the default distro behavior. This includes configuration
    explicitly created by a system administrator, installed software packages, or
    possibly a malicious process or attacker.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从数字取证的角度来看，我们希望了解系统在启动过程中做了什么，完全启动后的目标状态是什么样的，以及随着时间的推移发生了什么活动。特别是，我们要重建偏离默认发行版行为的配置和活动。这包括由系统管理员明确创建的配置、安装的软件包或可能的恶意进程或攻击者。
- en: The most common Linux initialization system is systemd. Since its original announcement
    in 2010, systemd has been adopted by every major Linux distribution, replacing
    the traditional Unix sysvinit and other distro-specific alternatives like Upstart
    from Ubuntu. Systemd is fundamentally different from traditional Unix and Linux
    init systems, and its introduction was not without controversy.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的 Linux 初始化系统是 systemd。自 2010 年首次宣布以来，systemd 已被所有主要的 Linux 发行版采用，取代了传统的
    Unix sysvinit 以及其他发行版特有的替代方案，如 Ubuntu 的 Upstart。Systemd 从根本上与传统的 Unix 和 Linux
    初始化系统不同，其引入并非没有争议。
- en: This section focuses on the systemd system initialization process. When performing
    a postmortem forensic analysis, we want to reconstruct essentially the same information
    provided by systemd commands on a running system (like `systemctl`, for example),
    which we can do by examining the systemd files and directories on the filesystem.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍 systemd 的系统初始化过程。在进行事后取证分析时，我们希望重建由系统运行时的 systemd 命令（例如 `systemctl`）提供的基本相同的信息，这可以通过检查文件系统上的
    systemd 文件和目录来完成。
- en: Systemd is very well documented. The systemd.index(7) man page has a list of
    all the systemd man pages (more than 350). For forensic investigators unfamiliar
    with Linux, these man pages are the best and most authoritative source of information
    on systemd.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Systemd 的文档非常完备。systemd.index(7) 手册页列出了所有 systemd 手册页（超过 350 个）。对于不熟悉 Linux
    的取证调查员来说，这些手册页是关于 systemd 最好且最权威的信息来源。
- en: '**NOTE**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Warning: systemd makes extensive use of symlinks. If you mount a suspect Linux
    filesystem on your examination Linux machine, the symlinks may point to your own
    installation and not the suspect drive. Make sure you are analyzing the right
    files on the suspect filesystem during a forensic examination.*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告：systemd 广泛使用符号链接。如果你在调查 Linux 机器上挂载了一个可疑的 Linux 文件系统，这些符号链接可能指向你自己的安装，而不是可疑驱动器。请确保在取证检查时，分析的是可疑文件系统中的正确文件。*'
- en: '***Systemd Unit Files***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Systemd 单元文件***'
- en: Systemd uses configuration files to initialize the system and manage services.
    This is a fundamental change from traditional Unix and Linux init systems that
    used shell scripts to achieve similar goals.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Systemd 使用配置文件来初始化系统并管理服务。这是与传统的 Unix 和 Linux 初始化系统的根本变化，后者使用 shell 脚本来实现类似的目标。
- en: Systemd uses the concept of *units* to control how a system is started or services
    are run. Units have associated text files called *unit configuration files*. Unit
    file content is organized into sections, with each section containing directives
    or options that are set by the system administrator, package maintainer, or distro
    vendor. Unit files are not only used for system startup, but also for operational
    maintenance (start, stop, restart, reload, and so on) and system shutdown. More
    information can be found in the systemd(1) and bootup(7) man pages.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Systemd 使用 *单元* 的概念来控制系统的启动或服务的运行。单元有相关的文本文件，称为 *单元配置文件*。单元文件内容组织成多个部分，每部分包含由系统管理员、软件包维护者或发行版供应商设置的指令或选项。单元文件不仅用于系统启动，还用于操作维护（启动、停止、重启、重载等）和系统关机。更多信息可以在
    systemd(1) 和 bootup(7) 手册页中找到。
- en: 'The following list shows systemd’s 11 different unit types, listed with the
    objects they control and the man page describing the unit file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了 systemd 的 11 种不同单元类型，列出了它们控制的对象以及描述单元文件的手册页：
- en: '**Service** For programs or daemons; systemd.service(5)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务** 程序或守护进程；systemd.service(5)'
- en: '**Socket** For IPC and sockets; systemd.socket(5)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**套接字** 用于 IPC 和套接字；systemd.socket(5)'
- en: '**Target** Groups of units; systemd.target(5)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标** 单元组；systemd.target(5)'
- en: '**Device** For kernel devices; systemd.device(5)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备** 用于内核设备；systemd.device(5)'
- en: '**Mount** Filesystem mount points; systemd.mount(5)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**挂载** 文件系统挂载点；systemd.mount(5)'
- en: '**Automount** Filesystem on-demand mounting; systemd.automount(5)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动挂载** 文件系统按需挂载；systemd.automount(5)'
- en: '**Timer** Time-based unit activation; systemd.timer(5)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**定时器** 基于时间的单元激活；systemd.timer(5)'
- en: '**Swap** Swap partitions or files; systemd.swap(5)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**交换** 交换分区或文件；systemd.swap(5)'
- en: '**Path** Unit activation based on file changes; systemd.path(5)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径** 基于文件更改的单元激活；systemd.path(5)'
- en: '**Slice** Units grouped for resource management; systemd.slice(5)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**切片** 用于资源管理的单元分组；systemd.slice(5)'
- en: '**Scope** Units grouped by process parent; systemd.scope(5)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**作用域** 由进程父项分组的单元；systemd.scope(5)'
- en: Unit files are normal text files with a filename describing the unit and extension
    matching the type (*httpd.service* or *syslog.socket*, for example). A unit may
    also have an associated **.d* directory containing **.conf* files that provide
    additional configuration.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 单元文件是普通的文本文件，文件名描述单元类型，扩展名与类型匹配（例如 *httpd.service* 或 *syslog.socket*）。单元文件还可能包含一个关联的
    **.d** 目录，该目录包含 **.conf** 文件，用于提供额外的配置。
- en: Unit files can have `[Unit]` and `[Install]` sections with options that describe
    the unit’s basic behavior and provide generic unit settings (see the systemd.unit(5)
    man page). All unit files except *target* and *device* have a self-titled section
    name with additional options that are specific to that unit type. For example,
    *service* has a `[Service]` section, *socket* has `[Socket]`, and so on. The *service*,
    *socket*, *swap*, and *mount* units have additional options that specify paths,
    users, groups, permissions, and other options relevant to the execution environment
    (see the systemd.exec(5) man page). The *service*, *socket*, *swap*, *mount*,
    and *scope* units have additional kill options that describe how processes belonging
    to a unit are terminated (see the systemd.kill(5) man page). The *slice*, *scope*,
    *service*, *socket*, *mount*, and *swap* units have additional resource control
    options that specify CPU and memory usage, IP network access control,^([12](footnotes.xhtml#ch06foot_012))
    and other limits (see the systemd.resource-control(5) man page). All available
    systemd options, variables, and directives (more than 5,000!) are listed together
    on the systemd.directives(7) man page. When examining unit files, this index should
    provide you with the documentation needed to understand the individual options.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 单元文件可以包含 `[Unit]` 和 `[Install]` 部分，这些部分包含描述单元基本行为并提供通用单元设置的选项（参见 systemd.unit(5)
    手册页）。除 *target* 和 *device* 外，所有单元文件都有一个自命名的部分，包含特定于该单元类型的附加选项。例如，*service* 有一个
    `[Service]` 部分，*socket* 有一个 `[Socket]`，以此类推。*service*、*socket*、*swap* 和 *mount*
    单元有附加选项，指定路径、用户、组、权限以及与执行环境相关的其他选项（参见 systemd.exec(5) 手册页）。*service*、*socket*、*swap*、*mount*
    和 *scope* 单元具有附加的终止选项，描述如何终止属于单元的进程（参见 systemd.kill(5) 手册页）。*slice*、*scope*、*service*、*socket*、*mount*
    和 *swap* 单元具有附加的资源控制选项，指定 CPU 和内存使用、IP 网络访问控制、^([12](footnotes.xhtml#ch06foot_012))
    和其他限制（参见 systemd.resource-control(5) 手册页）。所有可用的 systemd 选项、变量和指令（超过 5,000 个！）都列在
    systemd.directives(7) 手册页中。在检查单元文件时，此索引应为您提供理解各个选项所需的文档。
- en: 'The following example is a typical service unit file. It was installed from
    the xorg-xdm package provided by the distro and provides a graphical login screen:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是一个典型的服务单元文件。它是通过发行版提供的 xorg-xdm 包安装的，并提供图形化登录界面：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `[Unit]` section provides a description and dependency information. The
    `[Service]` section defines the command to run and other options described in
    the systemd.service(5) man page. The `[Install]` section provides information
    needed to enable or disable the unit.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Unit]` 部分提供描述和依赖信息。`[Service]` 部分定义要运行的命令及其他选项，这些选项在 systemd.service(5) 手册页中有描述。`[Install]`
    部分提供启用或禁用单元所需的信息。'
- en: Systemd can operate as a *system* instance (during init and system operation)
    or as a *user* instance (during a user login session). Users can create and manage
    their own systemd unit files. System administrators with privileged access can
    manage the systemd system unit files. When forensically examining a Linux system,
    you need to know where to look for unit files. These are created and saved in
    several common locations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 可以作为 *系统* 实例（在初始化和系统操作期间）或 *用户* 实例（在用户登录会话期间）运行。用户可以创建和管理自己的 systemd
    单元文件。具有特权访问权限的系统管理员可以管理 systemd 系统单元文件。在进行 Linux 系统取证检查时，您需要知道在哪里查找单元文件。这些文件会在多个常见位置创建并保存。
- en: Unit files installed by a distro’s packaging system are located in the */usr/lib/systemd/system/*
    directory (some distros may use */lib/systemd/system/*). Unit files installed
    by a system administrator or those created during system configuration are typically
    installed in */etc/systemd/system/*. Files created by the system administrator
    in the */etc/systemd/system/* directory take precedence over those in the */usr/lib/systemd/system/*
    directory. Unit files that are not part of any installed package are interesting
    because they were explicitly added by an administrator or potentially malicious
    privileged process.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由发行版打包系统安装的单元文件位于*/usr/lib/systemd/system/*目录下（某些发行版可能使用*/lib/systemd/system/*）。由系统管理员安装的单元文件或在系统配置过程中创建的文件通常安装在*/etc/systemd/system/*目录下。系统管理员在*/etc/systemd/system/*目录中创建的文件优先于*/usr/lib/systemd/system/*目录中的文件。那些不是任何已安装包的一部分的单元文件很有意思，因为它们是由管理员显式添加的，或者是潜在恶意的特权进程添加的。
- en: User unit files can be created by the distro’s packaging system, a system administrator,
    or the users themselves. The distro’s user unit files are found in the */usr/lib/systemd/user/*
    directory, and the system administrator’s user unit files are found in the */etc/systemd/user/*
    directory. Users may place their own unit files in *~/.config/systemd/user/* of
    their home directory. User unit files are used during a user’s login session.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 用户单元文件可以由发行版的打包系统、系统管理员或用户本人创建。发行版的用户单元文件位于*/usr/lib/systemd/user/*目录下，系统管理员的用户单元文件位于*/etc/systemd/user/*目录下。用户可以将自己的单元文件放置在其主目录的*~/.config/systemd/user/*中。用户单元文件在用户的登录会话期间使用。
- en: From a forensics perspective, a user’s own unit files are interesting, as they
    could have been created from a running program, explicitly by hand, or from malicious
    activity targeting the user. See the systemd.unit(5) man page for a full list
    of where systemd searches for unit files.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从取证的角度来看，用户自己的单元文件很有趣，因为它们可能是由正在运行的程序创建的，或是手动显式创建的，或者是针对用户的恶意活动所创建的。查看systemd.unit(5)的man页面，了解systemd搜索单元文件的完整位置列表。
- en: If a unit file is empty (zero bytes) or symlinked to */dev/null*, it is considered
    to be *masked*, which means it cannot be started or enabled. On a running system,
    unit directories can be found in the */run/systemd/* pseudo-directory; however,
    they exist only in the running system’s memory, so they won’t be available during
    a postmortem forensic examination.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元文件为空（零字节）或符号链接到*/dev/null*，则被认为是*屏蔽*的，这意味着它不能被启动或启用。在运行的系统中，单元目录可以在*/run/systemd/*伪目录中找到；然而，它们仅存在于运行系统的内存中，因此在事后取证检查时将无法访问。
- en: '***Systemd Initialization Process***'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Systemd 初始化过程***'
- en: 'When the kernel has started and mounted the root filesystem, it looks for the
    init program (typically symlinked to */lib/systemd/systemd*) to initialize the
    system’s userspace. When systemd starts, it reads the */etc/systemd/system.conf*
    file to configure itself. This file provides various options to change how systemd
    behaves. Here is part of a *system.conf* file:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核启动并挂载根文件系统后，它会寻找初始化程序（通常符号链接到*/lib/systemd/systemd*）来初始化系统的用户空间。当systemd启动时，它会读取*/etc/systemd/system.conf*文件来进行自我配置。此文件提供了多种选项来改变systemd的行为。以下是*system.conf*文件的一部分：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The default file lists all the compile time default entries, but they’re commented
    out (using the `#`). A system administrator may deviate from these defaults by
    modifying or adding entries. This file configures logging, crashing, various limits,
    accounting, and other settings. See the systemd-system.conf(5) man page for more
    information.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 默认文件列出了所有编译时的默认条目，但这些条目是被注释掉的（使用`#`）。系统管理员可以通过修改或添加条目来偏离这些默认设置。此文件配置日志记录、崩溃、各种限制、记账及其他设置。更多信息请参见systemd-system.conf(5)的man页面。
- en: 'When other systemd daemons start (or reload), they also read various */etc/systemd/*.conf*
    configuration files. Some examples of these files are listed here by their man
    page:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他systemd守护进程启动（或重新加载）时，它们也会读取各种*/etc/systemd/*.conf*配置文件。以下是这些文件的一些示例，它们可以通过其man页面查看：
- en: systemd-user.conf(5)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: systemd-user.conf(5)
- en: logind.conf(5)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: logind.conf(5)
- en: journald.conf(5)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: journald.conf(5)
- en: journal-remote.conf(5)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: journal-remote.conf(5)
- en: journal-upload.conf(5)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: journal-upload.conf(5)
- en: systemd-sleep.conf(5)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: systemd-sleep.conf(5)
- en: timesyncd.conf(5)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: timesyncd.conf(5)
- en: homed.conf(5)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: homed.conf(5)
- en: coredump.conf(5)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: coredump.conf(5)
- en: resolved.conf(5)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: resolved.conf(5)
- en: The systemd.syntax(7) man page calls these *daemon config files*, which shouldn’t
    be confused with unit files. Typically, these config files (including *system.conf*
    ) will also have a list of default options, which are commented out (with `#`).
    In a forensic examination, look for `*.conf` entries that have been uncommented
    or added. These indicate explicit changes made by the system owner.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: systemd.syntax(7) 手册页将这些称为 *守护进程配置文件*，不应与单元文件混淆。通常，这些配置文件（包括 *system.conf*）还会列出默认选项，这些选项会被注释掉（以
    `#` 开头）。在取证检查中，查看 `*.conf` 条目，若这些条目没有注释或被添加了内容，表示系统所有者已做出明确更改。
- en: Traditional Unix and Linux systems have *run levels*, where a system can be
    brought up into different states of operation (single user, multiuser, and so
    on). Systemd has a similar concept called *targets*. A target is reached when
    a defined group of units have successfully become active. The primary purpose
    of targets is to manage dependencies.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 Unix 和 Linux 系统有 *运行级别*，系统可以启动到不同的操作状态（单用户、多用户等）。Systemd 有类似的概念，称为 *目标*。当定义的一组单元成功激活时，就达到了一个目标。目标的主要目的是管理依赖关系。
- en: 'When systemd boots, it starts all the units needed to achieve the default target
    state. The default target is the *default.target* unit file, which is usually
    a symlink to another target such as *graphical.target* or *multi-user.target*.
    Some common target states that Linux systems have include:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当 systemd 启动时，它会启动所有需要的单元，以实现默认目标状态。默认目标是 *default.target* 单元文件，通常是指向其他目标的符号链接，例如
    *graphical.target* 或 *multi-user.target*。Linux 系统中的一些常见目标状态包括：
- en: '***rescue.target*** Single-user mode, for sysadmins, no users, minimal services'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '***rescue.target*** 单用户模式，供系统管理员使用，没有用户，最小化服务'
- en: '***sysinit.target*** **and** ***basic.target*** Set up swap, local mount points,
    sockets, timers, and so on'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '***sysinit.target*** **和** ***basic.target*** 设置交换分区、本地挂载点、套接字、定时器等'
- en: '***multi-user.target*** A fully booted system without the graphical interface
    (typical for servers)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '***multi-user.target*** 完全启动的系统，没有图形界面（典型的服务器配置）'
- en: '***graphical.target*** A fully booted graphical system'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '***graphical.target*** 完全启动的图形化系统'
- en: '***default.target*** The default, usually a symbolic link to multiuser or graphical
    targets'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '***default.target*** 默认目标，通常是指向 multiuser 或 graphical 目标的符号链接'
- en: '***shutdown.target*** Cleanly brings the system down'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '***shutdown.target*** 清理地关闭系统'
- en: The systemd standard targets are described in the systemd.special(7) and bootup(7)
    man pages. The traditional Unix-style boot is described in the boot(7) man page.
    The default target can be overridden by explicitly providing another target name
    on the kernel command line (`systemd.unit=`).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 标准目标在 systemd.special(7) 和 bootup(7) 手册页中有描述。传统的 Unix 风格引导在 boot(7)
    手册页中有说明。默认目标可以通过在内核命令行中显式提供另一个目标名称来覆盖（`systemd.unit=`）。
- en: 'Unit files contain information about dependency relationships to other unit
    files or targets. These are defined in the `[Unit]` and `[Install]` sections.
    During startup, the `[Unit]` section defines the dependencies and how a unit behaves
    if those dependencies have failed. The following list shows some common dependency
    options:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 单元文件包含关于与其他单元文件或目标之间依赖关系的信息。这些信息在`[Unit]`和`[Install]`部分中定义。在启动过程中，`[Unit]`部分定义了依赖关系以及如果这些依赖项失败时，单元如何表现。以下列表显示了一些常见的依赖选项：
- en: '| Wants= | Other units wanted by this unit (continue if they failed) |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| Wants= | 该单元需要的其他单元（即使它们失败也继续） |'
- en: '| Requires= | Other units required by this unit (fail if they failed) |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| Requires= | 该单元所需的其他单元（如果它们失败则失败） |'
- en: '| Requisite= | Fail if other units are not already active |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| Requisite= | 如果其他单元尚未激活，则失败 |'
- en: '| Before= | This unit must be activated before these others |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| Before= | 该单元必须在这些单元之前激活 |'
- en: '| After= | This unit must be activated after these others |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| After= | 该单元必须在这些单元之后激活 |'
- en: An alternative to the `Wants=` and `Requires=` options is to place unit files
    or symlinks to unit files in the **.wants/* or **.requires/* directories.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wants=` 和 `Requires=` 选项的替代方法是将单元文件或指向单元文件的符号链接放置在 **.wants/* 或 **.requires/*
    目录中。'
- en: Starting with the *default.target* unit file, it is possible to work backward
    and build a list of all started unit files based on the `Requires=` and `Wants=`
    configuration entries or **.wants/* and **.requires/* directories. This approach
    requires an exhaustive manual examination, which may be necessary in some investigations.
    If you want to assess only what services have been created or enabled by the system
    administrator under normal circumstances, analyze the */etc/systemd/system/* directory
    for the existence of unit files (or symlinks to unit files).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *default.target* 单元文件开始，可以向后追溯并根据 `Requires=` 和 `Wants=` 配置项或 **.wants/* 和
    **.requires/* 目录构建所有已启动单元文件的列表。这种方法需要进行详尽的手动检查，在某些调查中可能是必要的。如果你只想评估在正常情况下由系统管理员创建或启用的服务，可以分析
    */etc/systemd/system/* 目录中是否存在单元文件（或指向单元文件的符号链接）。
- en: Options in the `[Install]` section of a unit file are used to enable or disable
    a unit with the `systemctl` command. This section is not used by systemd during
    startup. The `[Install]` dependencies can be defined with `WantedBy=` or `RequiredBy=`
    options.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 单元文件的 `[Install]` 部分中的选项用于通过 `systemctl` 命令启用或禁用单元。systemd 在启动时不使用这一部分。`[Install]`
    依赖项可以通过 `WantedBy=` 或 `RequiredBy=` 选项来定义。
- en: '***Systemd Services and Daemons***'
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Systemd 服务和守护进程***'
- en: A *daemon* (pronounced either dee-men or day-mon) originates from Unix and describes
    a process running in the background. Systemd starts daemons using a **.service*
    unit file that includes a `[Service]` section to configure how the daemon is started.
    Daemons can also be started on demand using various forms of activation (described
    in the next section). The words *service* and *daemon* are often used interchangeably,
    but in the context of systemd, there are differences. A systemd service is more
    abstract, can start one or more daemons, and has different service types.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*守护进程*（发音为 dee-men 或 day-mon）源自 Unix，描述了一个在后台运行的进程。Systemd 使用 **.service* 单元文件来启动守护进程，该文件包含
    `[Service]` 部分，用于配置守护进程的启动方式。守护进程还可以通过各种激活方式按需启动（在下一节中介绍）。*服务* 和 *守护进程* 这两个词经常互换使用，但在
    systemd 的上下文中，它们有一些区别。systemd 服务更加抽象，可以启动一个或多个守护进程，并且具有不同的服务类型。'
- en: '**NOTE**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Starting and stopping a service is not the same as enabling and disabling
    a service. If a service is* enabled*, it will automatically start at boot time.
    If* disabled*, it will not start at boot time. Services can be started and stopped
    by a system administrator during system operation, independent of the enabled/disabled
    state. A* masked *service can’t be started or enabled.*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*启动和停止服务与启用和禁用服务不同。如果服务是*启用*的，它将在启动时自动启动。如果*禁用*，它将在启动时不会启动。服务可以在系统运行时由系统管理员启动和停止，而不受启用/禁用状态的影响。*被屏蔽*的服务不能启动或启用。*'
- en: Daemons under systemd are slightly different from traditional Unix daemons because
    their terminal output (`stdout` and `stderr`) is captured by the systemd journal.
    See *[https://www.freedesktop.org/software/systemd/man/daemon.html](https://www.freedesktop.org/software/systemd/man/daemon.html)*
    for a detailed comparison between systemd and traditional daemons.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 下的守护进程与传统 Unix 守护进程有所不同，因为它们的终端输出（`stdout` 和 `stderr`）会被 systemd 日志捕获。有关
    systemd 和传统守护进程的详细比较，请参见 *[https://www.freedesktop.org/software/systemd/man/daemon.html](https://www.freedesktop.org/software/systemd/man/daemon.html)*。
- en: 'This example unit file (`sshd.service`) manages the secure shell daemon:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例单元文件（`sshd.service`）管理安全外壳守护进程：
- en: '[PRE18]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This file describes how to start, stop, and reload the daemon, and also when
    it should be started.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件描述了如何启动、停止和重新加载守护进程，并指明何时启动它。
- en: On a live system, units can be active or inactive (that is, started or stopped),
    and their status can be checked with the `systemctl status` command. On a forensic
    image, we can determine only whether a unit is enabled or disabled at startup
    (obviously, nothing is active on a dead system). When a system administrator explicitly
    enables a service, a symlink is created in */etc/systemd/ system/* or in a **.target.wants/*
    directory. Examining all the symlinks in these directories will indicate which
    services are started for each target.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时系统中，单元可以是活动的或非活动的（即，已启动或已停止），其状态可以通过 `systemctl status` 命令进行检查。在取证镜像中，我们只能确定单元是否在启动时启用或禁用（显然，死机系统上没有任何活动）。当系统管理员显式启用服务时，会在
    */etc/systemd/system/* 或 **.target.wants/* 目录下创建一个符号链接。检查这些目录中的所有符号链接将显示为每个目标启动的服务。
- en: 'In the example *sshd.service* unit file in the preceding code block, we can
    determine that the secure shell daemon is enabled by observing the symlink created
    in the multi-user target’s **.wants/* directory:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码块中的示例 *sshd.service* 单元文件中，我们可以通过观察在多用户目标的 **.wants/* 目录中创建的符号链接，来确定安全外壳守护进程是否已启用：
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can also see from the timestamps when the symlink was created, indicating
    when the service was last enabled. The timestamps on the original file */usr/lib/systemd/system/sshd.service*
    indicate when the service file was last installed or upgraded.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从时间戳中看到符号链接何时创建，指示服务最后一次启用的时间。原始文件 */usr/lib/systemd/system/sshd.service*
    上的时间戳表明该服务文件最后一次被安装或升级的时间。
- en: 'The starting and stopping of services is logged. The following example shows
    the secure shell daemon being stopped and started (restarted):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的启动和停止都会被记录。以下示例显示了安全外壳守护进程被停止并重新启动（重启）的过程：
- en: '[PRE20]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The systemd journal does not log information about enabling or disabling services
    aside from a simple `systemd[1]: Reloading` message. An examination of the file
    timestamps on the symlink will determine when services were enabled. If services
    were enabled with `systemctl`, the timestamps should correlate with the systemd
    reloading log entry.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'systemd 日志不会记录启用或禁用服务的信息，除了一个简单的 `systemd[1]: Reloading` 消息。通过检查符号链接的文件时间戳，可以确定服务启用的时间。如果服务是通过
    `systemctl` 启用的，那么时间戳应该与 systemd 重新加载日志条目相对应。'
- en: '***Activation and On-Demand Services***'
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***激活与按需服务***'
- en: The concept behind on-demand services is simply that a background process or
    daemon is not started until the moment it is needed. Services and daemons can
    be triggered in various ways, including by D-Bus, socket, path, and device activation.
    Service activation can be used in a system context or be specific to individual
    users. Activation is typically logged and can be examined in a forensic investigation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 按需服务的概念非常简单，即背景进程或守护进程在真正需要时才会启动。服务和守护进程可以通过多种方式触发，包括 D-Bus、套接字、路径和设备激活。服务激活可以在系统上下文中使用，也可以针对单个用户。激活通常会被记录，并且可以在取证调查中进行检查。
- en: '**Socket Activation**'
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**套接字激活**'
- en: 'Socket activation is the starting of services based on incoming FIFO, IPC,
    or network connection attempts. Traditional Unix-style activation used a daemon
    called inetd (or the xinetd alternative) to listen on multiple incoming TCP and
    UDP ports and start the appropriate daemon when a network connection was attempted.
    Today, systemd’s **.socket* unit files provide the same functionality. In the
    following example, PipeWire^([13](footnotes.xhtml#ch06foot_013)) is configured
    to be socket activated if a user needs it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字激活是基于传入的 FIFO、IPC 或网络连接尝试来启动服务。传统的 Unix 风格激活使用名为 inetd（或 xinetd 替代品）的守护进程来监听多个传入的
    TCP 和 UDP 端口，并在尝试建立网络连接时启动相应的守护进程。今天，systemd 的 **.socket** 单元文件提供了相同的功能。在以下示例中，PipeWire^([13](footnotes.xhtml#ch06foot_013))
    配置为在用户需要时通过套接字激活：
- en: '[PRE21]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here the user’s runtime directory (`%t`) is selected as the location of the
    `pipewire-0` listening pipe. If it is accessed, a service with the same name is
    activated:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里选择了用户的运行时目录（`%t`）作为 `pipewire-0` 监听管道的位置。如果访问该管道，则会激活一个具有相同名称的服务：
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ExecStart` option then runs the `pipewire` program. Notice how two unit
    files are used, one for the socket activation and one for the actual service.
    See the systemd.socket(5) man page for more information, and see [Chapter 8](ch08.xhtml)
    for network service examples.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecStart` 选项随后会运行 `pipewire` 程序。注意，这里使用了两个单元文件，一个用于套接字激活，一个用于实际的服务。有关更多信息，请参阅
    systemd.socket(5) 手册页，并查看 [第 8 章](ch08.xhtml) 中的网络服务示例。'
- en: '**D-Bus Activation**'
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**D-Bus 激活**'
- en: 'The D-Bus^([14](footnotes.xhtml#ch06foot_014)) is both a library and daemon
    (`dbus-daemon`) that facilitates communication between processes. The D-Bus daemon
    can run as a system-wide instance or as part of a user login session. Several
    common directories are associated with D-Bus configuration that can be examined
    on a suspect drive image:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: D-Bus^([14](footnotes.xhtml#ch06foot_014)) 是一个库和守护进程（`dbus-daemon`），用于促进进程之间的通信。D-Bus
    守护进程可以作为系统范围的实例运行，或者作为用户登录会话的一部分运行。几个常见的目录与 D-Bus 配置相关联，可以在嫌疑磁盘镜像上检查：
- en: '***/usr/share/dbus-1/*** Package default configuration'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '***/usr/share/dbus-1/*** 包默认配置'
- en: '***/etc/dbus-1/*** Sysadmin-specified configuration'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '***/etc/dbus-1/*** 系统管理员指定的配置'
- en: '***~******/.local/share/dbus-1/*** User-specified configuration'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '***~******/.local/share/dbus-1/*** 用户指定的配置'
- en: These directories (if they exist) may contain system and session configuration
    files, XML definition files, and service files specifying activation details.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目录（如果存在）可能包含系统和会话配置文件、XML 定义文件以及指定激活细节的服务文件。
- en: The `dbus-daemon` manages D-Bus activity, activates services on request, and
    logs activity to the systemd journal. Once a D-Bus service is requested, the service
    is activated either directly or via systemd. See the dbus-daemon(1) man page for
    more information.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbus-daemon` 管理 D-Bus 活动，根据请求激活服务，并将活动记录到 systemd 日志中。一旦请求了 D-Bus 服务，服务会直接或通过
    systemd 被激活。更多信息请参见 dbus-daemon(1) 手册页。'
- en: 'The logging of D-Bus activation shows several items that are interesting in
    reconstructing past events. In this example, a D-Bus request is made to activate
    the PolicyKit service:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: D-Bus 激活的日志显示了几个在重建过去事件时有用的项目。在这个例子中，发出了一个 D-Bus 请求以激活 PolicyKit 服务：
- en: '[PRE23]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the D-Bus daemon (shown with its PID) ➊ generates the log and asks systemd
    ➋ to start the policykit service ➌. The originator of the activation request is
    also logged ➍ (`systemd-logind` in this case).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，D-Bus 守护进程（显示其 PID） ➊ 生成日志并请求 systemd ➋ 启动 policykit 服务 ➌。激活请求的发起者也会被记录
    ➍（此例中为 `systemd-logind`）。
- en: 'Services that are D-Bus aware may also shut down after a period of inactivity.
    In this example, the GeoClue service is started by D-Bus activation, and the service
    terminates itself after 60 seconds of inactivity:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 D-Bus 的服务也可能在一段时间不活动后自行关闭。在此示例中，GeoClue 服务由 D-Bus 激活，且服务在 60 秒不活动后自动终止：
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Path-Based Activation**'
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**基于路径的激活**'
- en: 'Path-based activation uses a kernel feature called inotify that allows the
    monitoring of files and directories. The **.path* unit files define which files
    to monitor (see the systemd.path(5) man page). A **.service* file with the same
    name is activated when the path unit file’s conditions are met. In this example,
    a *canary.txt* file is monitored to detect possible ransomware. The canary file,
    path unit, and service unit are shown here:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 基于路径的激活使用了内核特性 inotify，允许监控文件和目录。**.path** 单元文件定义了哪些文件需要监控（请参见 systemd.path(5)
    手册页）。当路径单元文件的条件满足时，与其同名的 **.service** 文件会被激活。在此例中，一个 *canary.txt* 文件被监控以检测可能的勒索病毒。这里显示了
    canary 文件、路径单元和服务单元：
- en: '[PRE25]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Two unit files, *canary.path* and *canary.service*, are located in the user’s
    *~/.config/systemd/user/* directory and define the path-activated service. If
    the file is modified, the service is started and the command executed, which is
    shown in the journal:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 两个单元文件，*canary.path* 和 *canary.service*，位于用户的 *~/.config/systemd/user/* 目录中，定义了路径激活的服务。如果文件被修改，服务将启动并执行命令，日志中会显示这一过程：
- en: '[PRE26]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, the logs show the canary service starting, executing (the logger command
    output), and finishing (`Succeeded`). A user must be logged in for their own unit
    files to be active.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的日志显示了 canary 服务的启动、执行（记录器命令输出）和完成（`Succeeded`）。用户必须登录才能使自己的单元文件处于活动状态。
- en: '**Device Activation**'
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设备激活**'
- en: 'Device activation uses the udev dynamic device management system (the `systemd-udevd`
    daemon). The appearance of new devices observed by the kernel can be configured
    to activate service unit files. The **.device* unit files described in the systemd.device(5)
    man page are created dynamically on a running kernel and aren’t available during
    a postmortem forensic examination. However, we can still examine systemd device
    activation configured in the udev rule files and the journal. For example, a rule
    file (*60-gpsd.rules*) defines a systemd service to run when a particular GPS
    device (pl2303) is plugged in:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 设备激活使用了 udev 动态设备管理系统（`systemd-udevd` 守护进程）。内核观察到的新设备可以被配置为激活服务单元文件。系统d.device(5)
    手册页中描述的 **.device** 单元文件是在运行的内核上动态创建的，无法在事后进行法医检查时获得。然而，我们仍然可以检查在 udev 规则文件和日志中配置的
    systemd 设备激活。例如，一个规则文件 (*60-gpsd.rules*) 定义了当特定 GPS 设备（pl2303）插入时运行的 systemd 服务：
- en: '[PRE27]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this example, the udev rule is tagged with systemd ➊ and the `SYSTEMD_WANTS`
    ➋ environment variable specifies the `gpsdctl@.service` template with `%k` representing
    the kernel name of the device (it will become `ttyUSB0`). The service template
    file ➌ describes how and what program to run. The journal shows the insertion
    of the device and subsequent activation:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，udev 规则被标记为 systemd ➊，`SYSTEMD_WANTS` ➋ 环境变量指定了 `gpsdctl@.service` 模板，其中
    `%k` 代表设备的内核名称（它将变为 `ttyUSB0`）。服务模板文件 ➌ 描述了如何运行程序。日志显示了设备的插入和随后的激活：
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The kernel detects the device as `ttyUSB0`, and the systemd unit is activated
    and runs the `gpsdctl` commands with the device name. The systemd.device(5), udev(7),
    and systemd-udevd(8) man pages have more information.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 内核将设备检测为 `ttyUSB0`，系统d 单元被激活并使用设备名称运行 `gpsdctl` 命令。systemd.device(5)、udev(7)
    和 systemd-udevd(8) 手册页提供了更多信息。
- en: In a forensic examination, these activation logs may be useful to help reconstruct
    past device activity. In addition, investigators should analyze the logs immediately
    before and after activation to see whether anything related or suspicious can
    be found.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在取证检查中，这些激活日志可能有助于帮助重建过去的设备活动。此外，调查人员应分析激活前后立即的日志，看看是否能发现与之相关或可疑的内容。
- en: '***Scheduled Commands and Timers***'
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计划命令和定时器***'
- en: 'Every modern operating system allows scheduling of programs to run in the future,
    either once or on a repeating basis. On Linux systems, scheduling is done with
    traditional Unix-style `at` and `cron` jobs, or with systemd timers. From a forensics
    perspective, we want to answer several questions:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 每个现代操作系统都允许将程序安排在未来运行，可以是一次性执行，也可以是重复执行。在 Linux 系统中，任务调度通过传统的 Unix 风格的 `at`
    和 `cron` 任务，或通过 systemd 定时器来完成。从取证的角度来看，我们需要回答几个问题：
- en: What jobs are currently scheduled?
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前计划执行的任务有哪些？
- en: When are they scheduled to execute?
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们计划何时执行？
- en: When was the job created?
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该任务何时被创建？
- en: Who created the job?
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是谁创建了该任务？
- en: What is scheduled to be executed?
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划执行的是什么任务？
- en: What other jobs have been run in the past?
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过去运行过哪些任务？
- en: Log entries and files found in the */var/spool/* directory often reveal more
    information to help answer these questions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 */var/spool/* 目录中找到的日志条目和文件通常会揭示更多信息，帮助回答这些问题。
- en: '**at**'
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**at**'
- en: 'The `at` program is used to create jobs that are run once at a specific time
    by the `atd` daemon. One example of malicious activity using `at` jobs is to execute
    a logic bomb at some point in the future. A scheduled `at` job is identified by
    a file located in the */var/spool/at/* or */var/spool/cron/atjobs/* directory;
    for example:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`at` 程序用于创建由 `atd` 守护进程在特定时间执行一次的任务。一个使用 `at` 任务的恶意活动示例是将在未来某个时刻执行逻辑炸弹。计划的
    `at` 任务由位于 */var/spool/at/* 或 */var/spool/cron/atjobs/* 目录中的文件标识；例如：'
- en: '[PRE29]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, the filename encodes information about the job. The first character is
    the queue state (`a` is pending and `=` is executing), the next five characters
    are the job number (in hexadecimal), and the last eight characters are the number
    of minutes since the epoch, January 1, 1970 (also in hexadecimal).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，文件名编码了有关任务的信息。第一个字符表示队列状态（`a` 表示待处理，`=` 表示正在执行），接下来的五个字符是任务编号（十六进制），最后八个字符是自
    1970 年 1 月 1 日以来的分钟数（也以十六进制表示）。
- en: Converting the last eight characters into decimal and multiplying by 60 will
    reveal the timestamp (in seconds) of pending execution.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 将最后八个字符转换为十进制并乘以 60，将揭示待处理执行的时间戳（以秒为单位）。
- en: 'The job file is a script created by the `at` command that contains information
    about how to run the program, where to email the output, environment variables,
    and the contents of the user’s script. Here is an example of an `at` job shell
    script header:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 任务文件是由 `at` 命令创建的脚本，包含如何运行程序、将输出发送到哪里、环境变量和用户脚本的内容。以下是一个 `at` 任务 shell 脚本头部的示例：
- en: '[PRE30]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The header information is embedded in the shell script using comments. The
    owner of the `at` job can be determined from the filesystem ownership or the uid
    comments in the shell job’s header. The job’s filesystem creation timestamp indicates
    when the user submitted the job. A hidden file *.SEQ* contains the number of the
    last job run on the system. A spool directory (*/var/spool/at/spool/* or */var/spool/cron/atspool/*)
    saves the output of running jobs into email messages that are sent to the owner
    on completion. Investigators can check email logs and mailboxes for `at` job output
    email (for example, `Subject: Output from your job 27`). The timestamps of these
    emails will indicate when the job completed. Once an `at` job is completed, the
    spool files are deleted. The execution and completion of the `at` job may appear
    in the journal:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '头部信息通过注释嵌入在 shell 脚本中。`at` 任务的所有者可以通过文件系统的所有权或 shell 脚本头部的 uid 注释来确定。任务的文件系统创建时间戳表示用户提交任务的时间。一个隐藏文件
    *.SEQ* 包含系统上最后一个任务的编号。一个待处理目录（*/var/spool/at/spool/* 或 */var/spool/cron/atspool/*）将运行任务的输出保存到电子邮件中，并在任务完成后发送给任务所有者。调查人员可以检查电子邮件日志和邮箱中的
    `at` 任务输出电子邮件（例如，`Subject: Output from your job 27`）。这些电子邮件的时间戳将指示任务何时完成。一旦 `at`
    任务完成，待处理文件将被删除。`at` 任务的执行和完成可能会出现在日志中：'
- en: '[PRE31]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The submission of an at job is not logged, but it might be found in the user’s
    shell history. Shell histories can be searched for the existence of the at command
    being run.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: at 作业的提交不会被记录，但可以在用户的 shell 历史记录中找到。可以搜索 shell 历史记录，查看是否运行了 at 命令。
- en: '**cron**'
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**cron**'
- en: The cron system is traditionally configured in the */etc/crontab* file. The
    file format consists of one line per scheduled job. Each line begins with fields
    specifying the minute, hour, day of month, month of year, and day of week. If
    a field contains an asterisk (*), the command is run every time (every hour, every
    day, and so on). The last two fields specify the user under which to run the job
    as well as the command to be executed. The following is a sample *crontab* file
    with some helpful comments.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: cron 系统通常在 */etc/crontab* 文件中进行配置。文件格式由每个计划任务的一行组成。每行以指定分钟、小时、日期、月份和星期几的字段开始。如果某个字段包含星号（*），则命令会在每次（每小时、每天等）运行时执行。最后两个字段指定运行任务的用户以及要执行的命令。以下是一个包含一些有用注释的
    *crontab* 文件示例。
- en: '[PRE32]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, every day at one minute before midnight, a backup script starts
    running as root.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，每天午夜前一分钟，备份脚本作为 root 用户开始运行。
- en: 'Most Linux distros have a crontab and also run hourly, daily, weekly, and monthly
    scripts that are stored in various directories:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Linux 发行版都有一个 crontab，并且运行每小时、每天、每周和每月的脚本，这些脚本存储在不同的目录中：
- en: '[PRE33]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Installed packages can place files in these directories for periodic tasks.
    Individual users may also have *crontab* files in the */var/spool/cron/* directory.
    The format is almost the same as */etc/crontab*, but without the username field
    because the filename indicates the name of the user.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 已安装的包可以将文件放置在这些目录中以执行周期性任务。单独的用户也可能在 */var/spool/cron/* 目录中拥有 *crontab* 文件。格式几乎与
    */etc/crontab* 相同，但没有用户名字段，因为文件名已经指示了用户的名称。
- en: A forensic investigator can examine the *crontab* files and directories for
    signs of malicious scheduled activity (exfiltrating data, deleting files, and
    so on).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 法医调查员可以检查 *crontab* 文件和目录，查找恶意计划活动的迹象（如外泄数据、删除文件等）。
- en: '**Systemd Timers**'
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Systemd 定时器**'
- en: 'Systemd timers are starting to replace cron on modern Linux systems. Timers
    are systemd unit files that specify when and how corresponding unit files (with
    the same name but different extensions) are activated. This is also a form of
    activation as discussed in the previous section, but it is timer based. Timers
    have a **.timer* extension and are normal systemd units with an additional `[Timer]`
    section, as illustrated in this example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Systemd 定时器开始在现代 Linux 系统中取代 cron。定时器是 systemd 单元文件，指定何时以及如何激活相应的单元文件（具有相同的名称但不同的扩展名）。这也是上一节讨论的激活形式，但它是基于定时器的。定时器的扩展名为**.timer**，并且是普通的
    systemd 单元，具有一个额外的 `[Timer]` 部分，如下例所示：
- en: '[PRE34]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The *logrotate.timer* unit specifies that the *logrotate.service* unit be activated
    every day. The *logrotate.service* unit file contains the information about how
    to run the `logrotate` program. Timer execution information is logged in the journal
    with the `Description=` string, as shown here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*logrotate.timer* 单元指定每天激活 *logrotate.service* 单元。*logrotate.service* 单元文件包含有关如何运行
    `logrotate` 程序的信息。定时器执行信息以 `Description=` 字符串的形式记录在日志中，如下所示：'
- en: '[PRE35]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Timers are typically found in the same locations as other systemd unit files
    installed by software packages or by system administrators. Users can also create
    timers in their own home directories (*./config/systemd/user/*.timer*), but the
    timers will not remain active after logout.^([15](footnotes.xhtml#ch06foot_015))
    See the systemd.timer(5) man page for more information. Systemd provides a flexible
    notation for specifying time periods used in the `OnCalendar=` directive. The
    systemd.time(7) man page has more details.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器通常位于与软件包或系统管理员安装的其他 systemd 单元文件相同的位置。用户也可以在自己的主目录中创建定时器（*./config/systemd/user/*.timer*），但在注销后，定时器将不会保持激活状态。^([15](footnotes.xhtml#ch06foot_015))有关更多信息，请参见
    systemd.timer(5) 手册页。Systemd 提供了灵活的符号表示法，用于指定在 `OnCalendar=` 指令中使用的时间段。有关更多细节，请参见
    systemd.time(7) 手册页。
- en: '**Power and Physical Environment Analysis**'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**电力和物理环境分析**'
- en: The Linux kernel interacts directly with hardware that is part of the physical
    environment. Changes to this physical environment may leave digital traces in
    the logs that are interesting to forensic investigators. These digital traces
    may provide useful information about electrical power or temperature or indicate
    the physical proximity of people near the computer.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核直接与物理环境中的硬件进行交互。物理环境的变化可能会在日志中留下数字痕迹，这些痕迹对于取证调查人员来说可能很有意义。这些数字痕迹可能提供有关电力或温度的有用信息，或者表明接近计算机的人的物理位置。
- en: '***Power and Physical Environment Analysis***'
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***电力和物理环境分析***'
- en: Most server installations have backup power with uninterruptible power supply
    (UPS) devices. These devices contain batteries able to provide power continuity
    during an outage. They usually have a serial or USB cable connected to a server
    responsible for taking action (clean shutdown, notification, and so on) when power
    fails. In a Linux environment, a daemon listens for alerts from the UPS. Common
    UPS software packages include PowerPanel/Cyber-Power with the `pwrstatd` daemon,
    Network UPS Tools (NUT) with the `upsd` daemon, and the `apcupsd` daemon.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数服务器安装配备了备份电源，通常使用不间断电源（UPS）设备。这些设备包含电池，能够在停电时提供电力连续性。它们通常通过串行或 USB 电缆连接到服务器，当电源故障时，服务器会负责采取行动（如清理关闭、通知等）。在
    Linux 环境中，守护进程会监听来自 UPS 的警报。常见的 UPS 软件包包括 PowerPanel/Cyber-Power 及其 `pwrstatd`
    守护进程、Network UPS Tools（NUT）及其 `upsd` 守护进程，以及 `apcupsd` 守护进程。
- en: 'This example shows a server losing and then regaining power:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子显示了一台服务器失去电源然后重新恢复电源：
- en: '[PRE36]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These logs may be useful in enterprise computing environments where accidental
    failure or intentional sabotage are being investigated.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志在企业计算环境中可能很有用，尤其是当调查意外故障或故意破坏时。
- en: 'Log messages related to laptop power may come from several sources (or not
    at all), depending on the Linux distro and the configuration. An ACPI daemon (`acpid`)
    could be running and logging to syslog, systemd or the window environment may
    be reacting to ACPI messages and taking actions, and there may be other daemons
    configured to react to ACPI changes. Linux may not fully support the implemented
    ACPI interface of some hardware, and certain error messages may appear. For example,
    in this log, the laptop noticed a change when the power cable was unplugged, but
    didn’t recognize what it was:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 与笔记本电源相关的日志消息可能来自多个来源（或者根本没有），这取决于 Linux 发行版和配置。一个 ACPI 守护进程（`acpid`）可能正在运行并记录到
    syslog，systemd 或窗口环境可能会对 ACPI 消息作出反应并采取相应的行动，也可能有其他守护进程被配置为响应 ACPI 更改。Linux 可能没有完全支持某些硬件实现的
    ACPI 接口，可能会出现某些错误消息。例如，在这个日志中，笔记本检测到电源线拔掉时发生了变化，但没有识别出是什么：
- en: '[PRE37]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This usually happens with a buggy or unsupported ACPI BIOS.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常发生在存在 bug 或不受支持的 ACPI BIOS 时。
- en: Temperature issues may result from being in a high temperature environment,
    blocked ventilation, fan failure, explicit overclocking by the owner, or other
    factors. Depending on how the system was installed and configured, the logs may
    have traces of temperature readings.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 温度问题可能源于处于高温环境、通风受阻、风扇故障、用户的超频操作或其他因素。根据系统的安装和配置方式，日志中可能会留下温度读数的痕迹。
- en: The ACPI interface may provide some temperature information, the `lm_sensors`
    software package provides temperature information, and other temperature programs
    may be plug-ins for a graphical environment. Enterprise systems may run monitoring
    software like Icinga/Nagios that checks and reports temperature. Daemons like
    `thermald` also log temperature information. Daemons like `hddtemp` read Self-Monitoring
    Analysis and Reporting Technology (SMART) data on drives to monitor the temperature
    (and log thresholds).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ACPI 接口可能提供一些温度信息，`lm_sensors` 软件包提供温度信息，其他温度程序可能是图形环境的插件。企业系统可能运行像 Icinga/Nagios
    这样的监控软件来检查和报告温度。像 `thermald` 这样的守护进程也会记录温度信息。像 `hddtemp` 这样的守护进程读取硬盘上的自我监控分析与报告技术（SMART）数据来监控温度（并记录阈值）。
- en: 'In some cases, the kernel detects temperature changes. This example shows the
    system reacting to high load on a CPU and changing its speed:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，内核会检测到温度变化。这个例子显示了系统在 CPU 高负载时作出的反应，并改变其速度：
- en: '[PRE38]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Reactions to hitting temperature thresholds depend on the software configured
    and may include reporting to a sysadmin, logging, slowing down a device, shutting
    down a device, or even shutting down the entire system. Depending on the context
    of an investigation, temperature indicators may be of forensic interest. Examples
    of this include correlating potential high CPU activity from an unexpected process
    or changes in the physical environment in which the machine is located.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 达到温度阈值后的反应取决于已配置的软件，可能包括向系统管理员报告、日志记录、减慢设备速度、关闭设备或甚至关闭整个系统。根据调查的上下文，温度指示器可能具有法医兴趣。例如，可能通过关联来自意外进程的高
    CPU 活动或机器所在物理环境的变化来进行调查。
- en: '***Sleep, Shutdown, and Reboot Evidence***'
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***睡眠、关机和重启证据***'
- en: Depending on the investigation, knowing when a computer was online, offline,
    suspended, or rebooted can be important for building a forensic timeline. For
    example, knowing when a computer was suspended may conflict with someone’s claim
    that a machine was online and working, or the unplanned reboot of a server could
    be the result of malicious activity. The state of a machine can be deduced from
    a timeline analysis and also determined from log analysis.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 根据调查，了解计算机何时在线、离线、挂起或重启，对于构建法医时间线可能很重要。例如，知道计算机何时挂起可能与某人声称机器在线并且在工作的说法相冲突，或者服务器的非计划重启可能是恶意活动的结果。计算机的状态可以通过时间线分析推断出来，也可以通过日志分析确定。
- en: 'The ACPI specification defines multiple sleep states (“S” states) for a computer
    and the Linux kernel implements variations of these sleep states (*[https://www.kernel.org/doc/html/latest/admin-guide/pm/sleep-states.html](https://www.kernel.org/doc/html/latest/admin-guide/pm/sleep-states.html)*).
    Each state listed here provides an increasing level of power savings through various
    methods:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ACPI 规范定义了计算机的多个睡眠状态（“S” 状态），Linux 内核实现了这些睡眠状态的变体（*[https://www.kernel.org/doc/html/latest/admin-guide/pm/sleep-states.html](https://www.kernel.org/doc/html/latest/admin-guide/pm/sleep-states.html)*）。此处列出的每个状态通过各种方法提供逐渐增加的节能效果：
- en: '**Suspend-to-Idle (S0 Idle)** Freeze userspace, devices in low power, CPU idle'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**挂起到空闲（S0 空闲）** 冻结用户空间，设备处于低功耗，CPU 空闲'
- en: '**Standby (S1)** In addition to S0 Idle, non-boot CPUs offline, low-level system
    functions suspended'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**待机（S1）** 除了 S0 空闲，非启动 CPU 离线，低级系统功能挂起'
- en: '**Suspend-to-Ram (S3)** RAM has power; other hardware is off or in low power
    mode'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**挂起到内存（S3）** 内存有电；其他硬件关闭或处于低功耗模式'
- en: '**Hibernation (S4 or S5)** RAM is suspended to disk and system is powered off'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**休眠（S4 或 S5）** 内存挂起到磁盘，系统关闭电源'
- en: The ACPI specification also defines S0 as normal operation and S5 as powered
    off. Under Linux, these states are changed by explicit user requests, idle timeouts,
    or low-battery threshold conditions.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ACPI 规范还将 S0 定义为正常操作，将 S5 定义为关闭电源。在 Linux 下，这些状态通过显式的用户请求、空闲超时或低电池阈值条件来改变。
- en: 'Many of these sleep changes can be seen in the logs when systemd manages the
    suspension process:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当 systemd 管理挂起过程时，许多这些睡眠状态变化可以在日志中看到：
- en: '[PRE39]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In some cases, individual daemons aware of the changes may also log messages
    about going to sleep or waking up.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，意识到变化的单个守护进程也可能记录关于进入睡眠或唤醒的消息。
- en: 'The hibernation process suspends everything to disk and shuts the system down
    (analysis of this hibernation area is described in [Chapter 3](ch03.xhtml)), which
    can be observed in the logs:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 休眠过程将所有内容挂起到磁盘并关闭系统（对这个休眠区域的分析将在[第 3 章](ch03.xhtml)中描述），这一过程可以在日志中观察到：
- en: '[PRE40]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This example shows how systemd begins the hibernate process and then hands it
    over to the kernel to finish writing memory to disk. On resume, the kernel reads
    memory back from disk and hands it back over to systemd to complete the wakeup.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例展示了 systemd 如何开始休眠过程，然后将其交给内核完成将内存写入磁盘的任务。在恢复时，内核从磁盘读取内存并将其交还给 systemd 以完成唤醒。
- en: Systemd manages both the initialization and shutdown of a Linux system and logs
    the activity to the journal. Downtime from a halt or power-off depends on the
    system administrator. The shutdown and bootup times can be deduced from a filesystem
    timeline analysis, but the information should also be available in various logs.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Systemd 管理 Linux 系统的初始化和关闭，并将活动记录到日志中。由于停止或关机导致的停机时间取决于系统管理员，关机和启动时间可以通过文件系统时间线分析得出，但这些信息也应在各种日志中可用。
- en: 'Rebooting a Linux system causes a clean shutdown and immediately restarts the
    system. A reboot is initiated by systemd and shown in the logs:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 重启Linux系统会进行干净的关机，并立即重新启动系统。重启是由systemd启动的，并会在日志中显示：
- en: '[PRE41]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The downtime from a reboot is limited to the time needed to shut down fully
    and then fully restart.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 重启后的停机时间仅限于完全关机和完全重启所需的时间。
- en: 'Halting a Linux system performs a clean shutdown and then halts the kernel,
    but without rebooting or powering off. The initiation of a halt process can be
    observed in the logs:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 停止Linux系统会执行干净的关机操作，然后停止内核，但不会重启或关闭电源。停止过程的启动可以在日志中看到：
- en: '[PRE42]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The final kernel logs are shown on the console (but not in the journal, as systemd
    logging is already stopped).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的内核日志会显示在控制台上（但不会出现在日志中，因为systemd日志记录已经停止）。
- en: 'The power-off of a Linux system begins the same way as a reboot or halt, but
    the hardware is instructed to power off after the Linux shutdown is complete.
    A power-off can be observed in the logs:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Linux系统的关机过程与重启或停止相同，但在Linux关机完成后，硬件会被指示关闭电源。关机过程可以在日志中看到：
- en: '[PRE43]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Rebooting, halting, and powering off a system have similar shutdown processes.
    The only difference is what happens after kernel execution stops.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 重启、停止和关闭系统的过程类似。唯一的区别是内核执行停止后发生的事情。
- en: 'The journal keeps a list of boot periods, which you can view by copying the
    journal file(s) to an analysis machine and running journalctl with the --list-boots
    flag:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 日志会记录启动周期，你可以通过将日志文件复制到分析机器并使用`journalctl`命令加上--list-boots标志来查看：
- en: '[PRE44]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This command produces a list of each boot period from start to end. Other logs,
    such as *lastlog* and *wtmp*, will also log reboots and shutdowns. Daemons may
    log shutdown information showing that they are terminating themselves due to a
    pending shutdown.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会生成一个启动周期的列表，从开始到结束。其他日志，如*lastlog*和*wtmp*，也会记录重启和关机。守护进程可能会记录关机信息，表明它们由于即将进行关机而终止。
- en: '***Human Proximity Indicators***'
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***人类接近指标***'
- en: Determining whether a person was within physical proximity of a computer is
    often useful in investigations. Although Linux has flexible remote access capabilities,
    with secure shell and remote desktop, investigators can still determine when some
    activity was likely done by a person sitting at (or near) the computer or performing
    some interaction with the local hardware. I call these *human proximity indicators*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 确定某人是否在计算机附近通常对调查很有帮助。尽管Linux具有灵活的远程访问功能，如安全外壳和远程桌面，调查人员仍然可以通过某些活动的发生时间推测某人是否曾坐在（或靠近）计算机旁边，或者与本地硬件进行某种交互。我称这些为*人类接近指标*。
- en: '**Laptop Lids**'
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**笔记本电脑盖**'
- en: One human proximity indicator is interaction with a laptop lid. If a lid was
    opened or closed, someone likely made physical contact with the machine to do
    it. Knowing the difference between a lid opening and a lid closing is also interesting,
    as it may indicate an intention to start working or stop working at a certain
    point in time.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人类接近指标是与笔记本电脑盖的交互。如果盖子被打开或关闭，说明有人可能实际接触了机器进行操作。知道盖子打开与关闭的区别也很有趣，因为这可能表示某人在某个时刻有意开始工作或停止工作。
- en: 'Laptop lid activity is logged in the systemd journal. The following example
    shows a laptop lid being closed and then opened:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本盖的活动会记录在systemd日志中。以下示例显示了笔记本盖被关闭然后再打开的过程：
- en: '[PRE45]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Typically, closing a laptop lid will trigger a screen-locking program, and when
    the lid is opened, authentication is required. Successful authentication and continued
    user activity (as observed from the timeline and other indicators) suggests that
    the machine’s owner was nearby at that time.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，关闭笔记本电脑盖会触发屏幕锁定程序，打开盖子时需要进行身份验证。成功的身份验证和后续的用户活动（从时间线和其他指示符观察到）表明机器的主人当时就在附近。
- en: '**Power Cables**'
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**电源线**'
- en: The power cable on a laptop can also be interesting from an investigative perspective.
    If a laptop power cable was physically unplugged or plugged in, it may leave traces
    in the logs. Unless there was a power outage, this indicates that someone was
    in physical proximity of the laptop. Many laptop systems use the `upowerd` daemon
    for power management. This daemon keeps several logs of power-related events,
    including a history of battery charging/discharging states, times, and power consumption.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本电脑的电源电缆从调查角度来看也可能很有趣。如果笔记本电脑的电源电缆被物理拔出或插入，可能会在日志中留下痕迹。除非发生了电力中断，否则这表明某人曾靠近笔记本电脑。许多笔记本电脑系统使用`upowerd`守护进程来进行电源管理。这个守护进程会记录与电源相关的多个事件日志，包括电池充放电状态的历史、时间和功耗。
- en: 'The */var/lib/upower/* directory contains the power historical data reported
    via ACPI^([16](footnotes.xhtml#ch06foot_016)) from battery-operated peripherals
    and laptop batteries. A battery has four history files (* is a string identifying
    the battery):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*/var/lib/upower/* 目录包含通过 ACPI^([16](footnotes.xhtml#ch06foot_016)) 从电池供电的外设和笔记本电池报告的电源历史数据。电池有四个历史文件（*
    是一个标识电池的字符串）：'
- en: '***history-charge-*.dat*** Log of percentage charged'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '***history-charge-*.dat*** 记录充电百分比'
- en: '***history-rate-*.dat*** Log of energy consumption rate (in watts)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '***history-rate-*.dat*** 记录能耗率（以瓦特为单位）'
- en: '***history-time-empty-*.dat*** When unplugged, log of time (in seconds) until
    empty'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '***history-time-empty-*.dat*** 拔出时，记录电池放空所需的时间（以秒为单位）'
- en: '***history-time-full-*.dat*** When charging, log of time (in seconds) until
    full'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '***history-time-full-*.dat*** 充电时，记录充满电所需的时间（以秒为单位）'
- en: 'There are three charging states found in the logs that may be interesting in
    a forensic investigation:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 日志中找到的三种充电状态可能对法医调查有意义：
- en: '**Charging** Battery is being charged; cable is plugged in'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**充电中** 电池正在充电；电缆已插入'
- en: '**Discharging** Battery is discharging; cable is unplugged'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**放电中** 电池正在放电；电缆已拔出'
- en: '**Fully charged** Battery is charged to its maximum; cable attached'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**已充满电** 电池已充满；电缆已连接'
- en: For a list of all the supported charging states, see the project documentation
    (*[https://upower.freedesktop.org/docs/](https://upower.freedesktop.org/docs/)*).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所有支持的充电状态的列表，请参见项目文档 (*[https://upower.freedesktop.org/docs/](https://upower.freedesktop.org/docs/)*).
- en: 'The charging and discharging of the battery correlates to the plugged and unplugged
    state of the power cable. Changes to this state are logged with a timestamp and
    shown in this example:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 电池的充电和放电与电源电缆的插入和拔出状态相关。该状态的变化会被时间戳记录，并在此示例中显示：
- en: '[PRE46]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, the charging history contains timestamps (Unix epoch), power consumption,
    and the charging state. In a forensic examination, the transitions between `charging`,
    `discharging`, and `fully-charged` may indicate when a power cable was physically
    plugged in or unplugged (or a power outage occurred). These state transitions
    may be observed in one or more of the four *upower* history files.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的充电历史包含时间戳（Unix纪元）、功耗和充电状态。在法医检查中，`充电`、`放电`和`已充满电`之间的状态过渡可能表明电源电缆何时被物理插入或拔出（或发生了电力中断）。这些状态过渡可能出现在一个或多个四个*upower*历史文件中。
- en: '**Ethernet Cables**'
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**以太网电缆**'
- en: 'An Ethernet cable link status can also be interesting from an investigative
    perspective. In server environments, if an Ethernet cable is physically plugged
    in or unplugged from a machine, the kernel will notice and log the information:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网电缆的连接状态从调查角度来看也可能很有趣。在服务器环境中，如果以太网电缆被物理插入或拔出，内核会注意到并记录该信息：
- en: '[PRE47]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This activity may include unused Ethernet ports suddenly becoming active or
    configured interfaces suddenly going down. These actions can indicate human proximity
    (people plugging in and unplugging cables), but they can also indicate other infrastructure
    situations, such as a switch going down, an administrator disabling a port, a
    severed cable, or the machine itself deactivating a port (with the `ip link set`
    command, for example). Possible malicious reasons for unexpected Ethernet port
    activity may include disruption, creating a side channel for data exfiltration,
    bypassing perimeter security, or performing some other unauthorized network activity.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动可能包括未使用的以太网端口突然变为活动状态或配置的接口突然关闭。这些操作可能表明人类靠近（例如插拔电缆），但也可能表明其他基础设施问题，例如交换机故障、管理员禁用端口、电缆断开或机器本身停用端口（例如使用`ip
    link set`命令）。意外的以太网端口活动的潜在恶意原因可能包括干扰、创建数据外泄的旁路通道、绕过外围安全或进行其他未经授权的网络活动。
- en: '**Plugged-In Peripheral Devices and Removable Media**'
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**插入的外围设备和可移动介质**'
- en: 'Another indicator of a person’s physical proximity is the record of USB devices
    being plugged in or removed from a machine. [Chapter 11](ch11.xhtml) discusses
    the detection of attached USB devices, but the following example shows a physically
    attached (and later removed) USB thumb drive:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个显示人员物理接近度的指标是 USB 设备的插入或移除记录。[第11章](ch11.xhtml)讨论了如何检测附加的 USB 设备，但以下示例展示了一个物理连接（并随后移除）的
    USB 闪存驱动器：
- en: '[PRE48]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It is also possible to determine the physical plug used to attach the USB device
    by examining the bus and port numbers (for example, to determine whether the activity
    happened in front of or behind a PC).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过检查总线和端口号来确定用于连接 USB 设备的物理插口（例如，用于确定活动发生在 PC 前面还是后面）。
- en: Other indicators of human proximity include the insertion or removal of physical
    removable media (CD-ROM, tape, SD card, and so on). Depending on the media and
    drive, this action may leave traces in the logs indicating that a person was present
    to perform the action.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 其他接近度指示包括物理可移动介质（CD-ROM、磁带、SD 卡等）的插入或移除。根据介质和驱动器，这一操作可能会在日志中留下痕迹，表明某人在现场执行了该操作。
- en: '**Console Logins and Other Indicators**'
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**控制台登录和其他指示**'
- en: Logging in to a machine from the physical console (local keyboard, screen, and
    so on) is the most obvious example of human proximity. If a login session is bound
    to a systemd “seat” (which is not the case with remote access like SSH), it indicates
    a local physical login. The `last` log output (described in [Chapter 10](ch10.xhtml))
    provides a history of local and remote logins.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 从物理控制台（本地键盘、屏幕等）登录机器是最明显的接近度指示。如果登录会话绑定到一个 systemd “座席”（这与像 SSH 这样的远程访问不同），则表示是本地物理登录。`last`日志输出（在[第10章](ch10.xhtml)中有描述）提供了本地和远程登录的历史记录。
- en: 'A login to a local physical console will use a `tty`, whereas a remote SSH
    session will use a pseudoterminal (`pts`). The following example is from the `last`
    output showing logins from user Sam:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 本地物理控制台的登录将使用`tty`，而远程 SSH 会话将使用伪终端（`pts`）。以下示例来自`last`输出，显示了用户 Sam 的登录记录：
- en: '[PRE49]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here `tty7` represents the local physical device where a login was made (`:0`
    is the X11 server), and `pts/3` shows a remote login (from the given IP address).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`tty7`表示登录发生的本地物理设备（`:0`是 X11 服务器），而`pts/3`则表示远程登录（来自给定的 IP 地址）。
- en: When a physical keyboard/video/mouse (KVM) device is attached to a PC and accessed
    remotely, physical proximity can’t be determined (unless the KVM device retains
    its own logs).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当物理键盘/视频/鼠标（KVM）设备连接到 PC 并通过远程方式访问时，无法确定物理接近度（除非 KVM 设备保留了自己的日志）。
- en: 'Other indicators of human proximity are physical key presses on a locally attached
    keyboard.^([17](footnotes.xhtml#ch06foot_017)) These are not typically logged,
    but certain keys (power, brightness, function keys, and so on) may be associated
    with an action performed by the operating system. Logs may exist depending on
    the key or the daemon configured to take action. Some of these keyboard actions
    may also trigger scripts or programs that leave traces in the logs when run, such
    as shown here:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 其他接近度指示是本地连接键盘上的物理按键按下。^([17](footnotes.xhtml#ch06foot_017))这些通常不会被记录，但某些按键（如电源、亮度、功能键等）可能与操作系统执行的操作相关联。日志可能会根据按键或配置为执行操作的守护进程而存在。某些键盘操作还可能触发脚本或程序，这些脚本或程序在运行时会在日志中留下痕迹，如以下所示：
- en: '[PRE50]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this example, the power button was pressed on a computer, triggering a suspend
    action. The physical button press is logged, indicating that someone was in proximity
    of the computer.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，按下了计算机的电源按钮，触发了挂起操作。物理按钮按压被记录下来，表明有人靠近计算机。
- en: The use of fingerprint readers for biometric authentication can also help determine
    human proximity. If a person scanned in a fingerprint on a local fingerprint reader,
    it’s an indicator that they were in physical contact with the system at a particular
    point in time. The advantage here is the combined determination of proximity together
    with biometric identification of the person. More information about Linux fingerprint
    authentication is explained in [Chapter 10](ch10.xhtml).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指纹识别器进行生物特征认证还可以帮助确定人的接近程度。如果某人在本地指纹识别器上扫描了指纹，这表明他们在特定时间点与系统有过物理接触。这里的优势是结合了接近度的判断和人员的生物特征识别。有关
    Linux 指纹认证的更多信息，请参见[第10章](ch10.xhtml)。
- en: The absence of human proximity indicators does not mean nobody was near the
    computer. Also, just knowing that a person was in physical proximity of a computer
    and performing some action does not identify that person. This must be deduced
    from corroborating timestamps from other logs or the filesystem (or even logs
    from remote servers). If a laptop lid was opened and passwords were subsequently
    entered to log in or unlock a physical system, those actions point to anyone with
    knowledge of the password, not necessarily the user observed in the logs (in other
    words, the password may have been stolen or known by someone else).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少人类接近性指示器并不意味着没有人在计算机旁边。此外，仅仅知道一个人处于计算机的物理接近位置并且执行了一些操作，并不能确定这个人。必须通过其他日志或文件系统中的时间戳来推断，甚至是远程服务器的日志。如果打开了笔记本电脑的盖子，并且随后输入了密码以登录或解锁物理系统，这些操作指向任何知道密码的人，而不一定是日志中观察到的用户（换句话说，密码可能已经被盗或被其他人知道）。
- en: '**Summary**'
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you have learned how a Linux system boots, runs, and shuts
    down. You have seen examples of systemd unit files and more examples of logs that
    we can use to reconstruct past events. You have also been introduced to the concept
    of human proximity indicators and Linux power management. This chapter provides
    the background knowledge an investigator needs to analyze the system layer activity
    of a Linux machine.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了 Linux 系统的启动、运行和关闭过程。你看到了 systemd 单元文件的示例，以及我们可以用来重建过去事件的更多日志示例。你还了解了人类接近性指示器和
    Linux 电源管理的概念。本章提供了分析 Linux 机器系统层活动所需的背景知识。
