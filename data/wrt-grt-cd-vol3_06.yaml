- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4'
- en: AN INTRODUCTION TO UML AND USE CASES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**UML 和用例简介**'
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: The *Unified Modeling Language (UML)* is a graphic-based developmental language
    used to describe requirements and standards for software design. The latest versions
    of the Institute of Electrical and Electronics Engineers (IEEE) SDD standard are
    built around UML concepts, so we’ll start by covering the background and features
    of UML before moving on to how the language implements use cases to help us represent
    software system designs clearly and consistently.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*统一建模语言（UML）* 是一种基于图形的开发语言，用于描述软件设计的需求和标准。最新版本的电气和电子工程师学会（IEEE）软件设计文档（SDD）标准围绕
    UML 概念构建，因此我们将首先介绍 UML 的背景和特点，然后再讨论如何使用该语言实现用例，帮助我们清晰、一致地表示软件系统设计。'
- en: '**4.1 The UML Standard**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.1 UML 标准**'
- en: 'UML started out in the mid-1990s as a collection of three independent modeling
    languages: the Booch method (Grady Booch), the object modeling technique (Jim
    Rumbaugh), and the object-oriented software engineering system (Ivar Jacobson).
    After this initial amalgamation, the Object Management Group (OMG) developed the
    first UML standard, with input from a multitude of researchers, in 1997\. UML
    remains under OMG’s management today. Because UML was essentially designed by
    unification, it contains many different ways to specify the same thing, resulting
    in a lot of systemwide redundancy and inconsistency.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: UML 最早起源于 1990 年代中期，作为三种独立建模语言的集合：Booch 方法（Grady Booch）、面向对象建模技术（Jim Rumbaugh）和面向对象软件工程系统（Ivar
    Jacobson）。经过这次初步合并后，面向对象管理组织（OMG）于 1997 年制定了第一个 UML 标准，得到了众多研究人员的输入。今天，UML 仍然由
    OMG 管理。由于 UML 本质上是通过统一设计的，它包含了许多不同的方式来指定相同的内容，这导致了许多系统范围的冗余和不一致性。
- en: 'So why use UML? Well, despite its shortcomings, it’s a rather complete modeling
    language for object-oriented design. It’s also become the de facto IEEE documentation
    standard to use. So even if you don’t intend to use UML for your own projects,
    you’ll need to be able to read it when dealing with documentation from other projects.
    Because UML has become popular, there’s a good chance your project’s stakeholders
    are already familiar with it. It’s sort of like the C programming language (or
    BASIC, if you don’t know C): it’s ugly as far as language design goes, but everybody
    knows it.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要使用 UML 呢？尽管它存在一些缺点，但它仍然是一个相当完整的面向对象设计建模语言。它也已成为事实上的 IEEE 文档标准。所以即使你不打算在自己的项目中使用
    UML，处理其他项目的文档时，你也需要能够阅读它。因为 UML 已经变得非常流行，所以很有可能你的项目相关方已经熟悉它。它有点像 C 编程语言（或者，如果你不懂
    C，可以类比 BASIC）：语言设计上它并不美观，但每个人都知道它。
- en: UML is a very complex language that requires considerable study to master, an
    educational process that is beyond the scope of this book. Fortunately, dozens
    of good books are available on the subject, some almost 1,000 pages long (for
    example, *The UML Bible* by Tom Pender; see “[For More Information](ch04.xhtml#lev-4.5)”
    on [page 88](ch04.xhtml#page_88)). This chapter and those that follow are not
    intended to make you an expert on UML, but rather to quickly cover the UML features
    and concepts that the rest of the book uses. That way, you can refer back to these
    chapters when you’re trying to make sense of UML diagrams later in the book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: UML 是一种非常复杂的语言，需要相当多的学习才能掌握，这一教育过程超出了本书的范围。幸运的是，关于这个主题有许多优秀的书籍可供参考，有些书籍几乎有 1000
    页长（例如，*The UML Bible*，作者 Tom Pender；请参见 “[更多信息](ch04.xhtml#lev-4.5)” 和 [第88页](ch04.xhtml#page_88)）。本章及随后的章节并不是为了让你成为
    UML 专家，而是快速介绍本书中使用的 UML 特性和概念。这样，当你在本书后续章节中遇到 UML 图表时，可以回头参考这些章节来帮助理解。
- en: With that brief introduction behind us, next we’ll discuss how UML enables us
    to visualize a system’s design in a standardized way.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的介绍结束后，接下来我们将讨论 UML 如何帮助我们以标准化的方式可视化系统设计。
- en: '**4.2 The UML Use Case Model**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.2 UML 用例模型**'
- en: UML specifies use cases to describe a system’s functionality. A *use case* roughly
    corresponds to a requirement. Designers create a *use case diagram* to specify
    what a system does from an external observer’s point of view, meaning they specify
    only *what* a system does, not *how* it does it. They’ll then create a use case
    narrative to fill in the details of the diagram.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: UML 通过用例来描述系统的功能。*用例* 大致对应于一个需求。设计师创建 *用例图* 来指定从外部观察者的角度来看系统做什么，这意味着他们仅指定系统做什么，而不是它是如何做到的。然后，他们会创建一个用例叙述，填充图表的细节。
- en: '***4.2.1 Use Case Diagram Elements***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.1 用例图元素***'
- en: 'Use case diagrams typically contain three elements: an actor, a communication
    link (or association), and the actual use case:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 用例图通常包含三个元素：参与者、通信链接（或关联）以及实际的用例：
- en: '*Actors*, typically drawn as stick figures, represent users or external devices
    and systems that use the system under design.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参与者*通常以火柴人图形表示，代表使用设计中的系统的用户或外部设备和系统。'
- en: '*Communication links* are drawn as a line between an actor and a use case,
    and indicate some form of communication between the two.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通信链接*绘制为参与者和用例之间的一条线，表示两者之间的某种形式的通信。'
- en: '*Use cases* are drawn as ovals with an appropriate description and represent
    the activities the actors perform on the system.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用例*绘制为椭圆形，具有适当的描述，表示参与者在系统上执行的活动。'
- en: '[Figure 4-1](ch04.xhtml#ch4fig1) shows an example of a use case diagram.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-1](ch04.xhtml#ch4fig1)展示了一个用例图的示例。'
- en: '![image](Images/fig4-1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig4-1.jpg)'
- en: '*Figure 4-1: A sample use case diagram*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：一个示例用例图*'
- en: 'Every use case should have a high-level name that concisely and uniquely describes
    the operation. For example, a nuclear reactor operator might want to select a
    power input from a nuclear power (NP) channel: “select %Pwr” is a general description,
    whereas “press the percent power button on the NP device” is probably too specific.
    How the user selects percent power is more of a design issue, not a system analysis
    issue (analysis is what we’re doing at this stage).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用例应具有一个高层次的名称，简洁且唯一地描述操作。例如，核反应堆操作员可能希望从核电（NP）通道中选择一个功率输入：“选择 %Pwr”是一个通用描述，而“按下NP设备上的百分比功率按钮”可能过于具体。用户如何选择百分比功率更多的是设计问题，而不是系统分析问题（分析是我们在此阶段进行的工作）。
- en: The use case name should be unique, because you’ll likely use it to associate
    the diagram with a use case narrative elsewhere in your UML documentation. One
    way to achieve uniqueness is by attaching a *tag* (see “[Tag Formats](ch09.xhtml#lev-9.2.2)”
    on [page 172](ch09.xhtml#page_172)). However, the whole point of a use case diagram
    is to make the action obvious to the readers and stakeholders (that is, the external
    observers), and tags can obfuscate the meaning. One possible solution is to include
    a descriptive name (or phrase) *and* a tag inside the use case oval, as shown
    in [Figure 4-2](ch04.xhtml#ch4fig2).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 用例名称应唯一，因为您可能会用它将图表与UML文档中的其他用例叙述关联起来。实现唯一性的一种方法是附加一个*标签*（请参阅[标签格式](ch09.xhtml#lev-9.2.2)）在[第172页](ch09.xhtml#page_172)）。然而，用例图的主要目的是使操作对读者和利益相关者（即外部观察者）显而易见，而标签可能会使意义不清晰。一种可能的解决方案是在用例椭圆中同时包含描述性名称（或短语）*和*标签，如[图
    4-2](ch04.xhtml#ch4fig2)所示。
- en: '![image](Images/fig4-2.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig4-2.jpg)'
- en: '*Figure 4-2: A use case tag combined with a user-friendly name*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：一个结合了用户友好名称的用例标签*'
- en: The tag uniquely identifies the use case narrative, and the user-friendly name
    makes the diagram easy to read and understand.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 标签唯一地标识用例叙述，且用户友好的名称使得图表易于阅读和理解。
- en: A use case diagram can contain multiple actors as well as multiple use cases,
    as shown in [Figure 4-3](ch04.xhtml#ch4fig3), which provides use cases for generating
    Individual Megawatt Hour (MWH) and other reports.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 用例图可以包含多个参与者以及多个用例，如[图 4-3](ch04.xhtml#ch4fig3)所示，其中提供了生成个别兆瓦时（MWH）和其他报告的用例。
- en: '![image](Images/fig4-3.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig4-3.jpg)'
- en: '*Figure 4-3: Multiple actors and use cases in a use case diagram*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：用例图中的多个参与者和用例*'
- en: Stick figures are useful for making it instantly obvious that you’re specifying
    an actor, but they have some drawbacks. First, a stick figure is rather large
    and can consume considerable screen (or page) space. Also, in a large and cluttered
    UML diagram, it can become difficult to associate names and other information
    with a stick figure actor. For this reason, UML designers often use a stereotype
    to represent an actor. A *stereotype* is a special UML name (such as “actor”)
    surrounded by guillemets (« and ») and enclosed along with the element’s name
    inside a rectangle, as shown in [Figure 4-4](ch04.xhtml#ch4fig4). (You can use
    a pair of angle brackets—less-than and greater-than symbols—if you don’t have
    access to guillemets in your editing system.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 火柴人形象对于快速表明你正在指定一个演员非常有用，但它也有一些缺点。首先，火柴人形象比较大，可能占用相当大的屏幕（或页面）空间。另外，在一个大且杂乱的UML图中，将名称和其他信息与火柴人演员关联起来可能会变得困难。因此，UML设计师通常使用构造型来表示演员。*构造型*是一个特殊的UML名称（如“演员”），它被引号（«和»）包围，并与元素名称一起封闭在矩形内，如[图4-4](ch04.xhtml#ch4fig4)所示。（如果你的编辑系统中没有引号，可以使用一对尖括号——小于号和大于号。）
- en: '![image](Images/fig4-4.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig4-4.jpg)'
- en: '*Figure 4-4: An actor stereotype*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-4：一个演员的构造型*'
- en: Stereotypes can apply to any UML element, not just an actor. The stereotype
    consumes less space and creates less clutter, though its disadvantage is that
    the type of element isn’t as instantly clear as it would be using the actual icon.^([1](ch19_footnote.xhtml#ch04fn1))
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 构造型可以应用于任何UML元素，而不仅仅是演员。构造型占用较少空间，减少了杂乱，但其缺点是，元素的类型不像使用实际图标时那么直观清晰。^([1](ch19_footnote.xhtml#ch04fn1))
- en: '***4.2.2 Use Case Packages***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.2 用例包***'
- en: You can assign use case names to different *packages* by separating the package
    name from the use case name using a pair of colons. For example, if the aforementioned
    reactor operator needs to select percent power from two different nuclear power
    systems (NP and NPP), we could use `NP` and `NPP` packages to separate these operations
    (see [Figure 4-5](ch04.xhtml#ch4fig5)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用一对冒号将用例名称与不同的*包*名称分开，来为不同的包分配用例名称。例如，如果上述的反应堆操作员需要从两个不同的核电系统（NP和NPP）中选择百分比功率，我们可以使用`NP`和`NPP`包来分隔这些操作（参见[图4-5](ch04.xhtml#ch4fig5)）。
- en: '![image](Images/fig4-5.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig4-5.jpg)'
- en: '*Figure 4-5: Package names in a use case*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-5：用例中的包名称*'
- en: '***4.2.3 Use Case Inclusion***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.3 用例包含***'
- en: Sometimes, use cases will replicate information. For example, the use case in
    [Figure 4-5](ch04.xhtml#ch4fig5) might correspond to a reactor operator selecting
    which nuclear power channel to use (the NP or NPP instrument) for a given operation.
    If the operator must verify that the channel is online before making the selection,
    presumably either of the use cases for `NP::Select%Pwr` and `NPP::Select%Pwr`
    would contain the steps needed to confirm this. When writing the narrative for
    these two use cases, you’ll probably discover that you’re duplicating considerable
    information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，用例会重复信息。例如，[图4-5](ch04.xhtml#ch4fig5)中的用例可能对应于反应堆操作员为某个操作选择使用的核电通道（NP或NPP仪表）。如果操作员必须在做出选择之前验证通道是否在线，那么`NP::Select%Pwr`和`NPP::Select%Pwr`中的任一用例可能都包含确认这一点所需的步骤。当编写这两个用例的叙述时，你可能会发现你在重复大量信息。
- en: To avoid this replication, UML defines *use case inclusion*, which allows one
    use case to completely include the functionality of another.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种重复，UML定义了*用例包含*，它允许一个用例完全包含另一个用例的功能。
- en: You specify use case inclusion by drawing two use cases with oval icons, and
    placing a dashed open arrow from the including use case to the included use case.
    Also attach the label «include» to the dashed arrow, as shown in [Figure 4-6](ch04.xhtml#ch4fig6).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过绘制两个椭圆形图标的用例，并在包括用例和被包含用例之间放置一个虚线箭头来指定用例包含。同时，将标签«include»附加到虚线箭头上，如[图4-6](ch04.xhtml#ch4fig6)所示。
- en: '![image](Images/fig4-6.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig4-6.jpg)'
- en: '*Figure 4-6: Use case inclusion*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-6：用例包含*'
- en: We could redraw [Figure 4-5](ch04.xhtml#ch4fig5) using inclusion as shown in
    [Figure 4-7](ch04.xhtml#ch4fig7).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用包含的方式重新绘制[图4-5](ch04.xhtml#ch4fig5)，如[图4-7](ch04.xhtml#ch4fig7)所示。
- en: '![image](Images/fig4-7.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig4-7.jpg)'
- en: '*Figure 4-7: Use case inclusion example*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-7：用例包含示例*'
- en: An inclusion is the use case diagram equivalent of a function call. Inclusion
    allows you to reuse a use case from other use cases, thereby reducing redundancy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 包含是用例图中函数调用的等效物。包含允许你从其他用例中重用一个用例，从而减少冗余。
- en: '***4.2.4 Use Case Generalization***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.4 用例泛化***'
- en: Sometimes, two or more use cases share an underlying base design and build upon
    it to produce different use cases. Revisiting the example from [Figure 4-3](ch04.xhtml#ch4fig3),
    the Sr. Reactor Operator actor might produce additional reactor reports (that
    is, “All reports”) beyond those that the Reactor Operator actor produces (“Individual
    MWH report”). However, both use cases are still an example of the more general
    “Generate reports” use case and, therefore, they share some common (*inherited*)
    operations. This relationship is known as *use case generalization*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，两个或更多用例共享一个基础设计，并在其基础上构建出不同的用例。回顾[图 4-3](ch04.xhtml#ch4fig3)中的例子，资深反应堆操作员演员可能会生成额外的反应堆报告（即“所有报告”），而这些报告是反应堆操作员演员生成的报告（“单个
    MWH 报告”）之外的。然而，这两个用例仍然是更一般的“生成报告”用例的例子，因此它们共享一些共同的（*继承的*）操作。这种关系被称为*用例泛化*。
- en: We can illustrate use case generalization in a use case diagram by drawing a
    hollow arrow from a specific use case to the more general use case, as shown in
    [Figure 4-8](ch04.xhtml#ch4fig8).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在用例图中画一条从具体用例指向更一般的用例的空心箭头来表示用例泛化，如[图 4-8](ch04.xhtml#ch4fig8)所示。
- en: '![image](Images/fig4-8.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig4-8.jpg)'
- en: '*Figure 4-8: Generalization of use cases*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8：用例的泛化*'
- en: This figure tells us that the “Individual MWH report” and “All reports” use
    cases share some common activities inherited from the “Generate reports” use case.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该图告诉我们，“单个 MWH 报告”和“所有报告”用例共享一些从“生成报告”用例继承的共同活动。
- en: We can generalize actors in the same fashion by drawing an open arrow from multiple
    (specific) actors to a generalized actor, as shown in [Figure 4-9](ch04.xhtml#ch4fig9).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过画一条从多个（具体的）演员指向一个概括的演员的开放箭头来对演员进行泛化，如[图 4-9](ch04.xhtml#ch4fig9)所示。
- en: '![image](Images/fig4-9.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig4-9.jpg)'
- en: '*Figure 4-9: Generalization of actors*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-9：演员的泛化*'
- en: Generalization (particularly, use case generalization) is equivalent to inheritance
    in object-oriented systems. The hollow arrow points at the base use case, and
    the tail of the arrow (that is, the end without the arrowhead) connects to the
    inheriting, or derived, use case. In [Figure 4-9](ch04.xhtml#ch4fig9), “Generate
    reports” is the base use case, and “Individual MWH report” and “All reports” are
    the derived use cases.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 泛化（特别是用例泛化）等同于面向对象系统中的继承。空心箭头指向基础用例，箭头的尾部（即没有箭头的那一端）连接到继承的或派生的用例。在[图 4-9](ch04.xhtml#ch4fig9)中，“生成报告”是基础用例，而“单个
    MWH 报告”和“所有报告”是派生用例。
- en: A derived use case inherits all the features and activities of the base use
    case. That is, all the items and functionality in the base use case are present
    in the derived use case, along with certain items unique to the derived use case.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 派生用例继承了基础用例的所有特性和活动。也就是说，基础用例中的所有项和功能都存在于派生用例中，同时还包括一些仅属于派生用例的项。
- en: In [Figure 4-9](ch04.xhtml#ch4fig9), the Reactor Operator actor can select only
    an “Individual MWH report.” Therefore, any report generated by the Reactor Operator
    actor always follows the steps associated with that individual report. The Sr.
    Reactor Operator actor, on the other hand, can generate any report derived from
    the “All reports” or “Individual MWH report” use case.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 4-9](ch04.xhtml#ch4fig9)中，反应堆操作员演员只能选择“单个 MWH 报告”。因此，反应堆操作员演员生成的任何报告总是遵循与该单个报告相关的步骤。另一方面，资深反应堆操作员演员可以生成任何从“所有报告”或“单个
    MWH 报告”用例派生的报告。
- en: Although generalization might seem very similar to inclusion, there are subtle
    differences. With inclusion a use case is completely included, but with inheritance
    the base use case is augmented by the features in the derived use case.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管泛化看起来与包含非常相似，但它们之间有细微的区别。在包含的情况下，一个用例是完全被包含的，而在继承中，基础用例是通过派生用例中的特性进行扩展的。
- en: '***4.2.5 Use Case Extension***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.5 用例扩展***'
- en: The UML *use case extension* allows you to specify the optional (*conditional*)
    inclusion of some use case. You draw an extension similar to an inclusion except
    you use the word «extend» rather than «include» and the arrow is a dashed line
    with a solid arrowhead. Another difference is that the arrowhead points at the
    extended use case, and the tail points at the extending use case, as shown in
    [Figure 4-10](ch04.xhtml#ch4fig10).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: UML的*用例扩展*允许你指定某些用例的可选（*条件性*）包含。你绘制一个类似包含的扩展，只不过使用“extend”代替“include”，并且箭头是虚线带实心箭头的。另一个不同点是，箭头指向扩展的用例，箭头尾指向扩展用例，如[图4-10](ch04.xhtml#ch4fig10)所示。
- en: '![image](Images/fig4-10.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig4-10.jpg)'
- en: '*Figure 4-10: Use case extension*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-10：用例扩展*'
- en: 'Use case extensions are useful when you want to select one of several different
    use cases based on some internal system/software state. A classic example would
    be error or exception handling conditions. Suppose you have a small command line
    processor that recognizes certain commands beginning with a verb (such as `read_digital`).
    The command syntax might take the form:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 用例扩展在你希望根据某些内部系统/软件状态选择多个不同用例中的一个时非常有用。一个经典的例子是错误或异常处理条件。假设你有一个小型命令行处理器，它识别以动词开头的某些命令（例如`read_digital`）。命令语法可能如下所示：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'where `port#` is a numeric string indicating the port to read from. Two things
    could go wrong when the software processes this command: `port#` could have a
    syntax error (that is, it doesn’t represent a valid numeric value) or the `port#`
    value could be out of range. Thus, there are three possible outcomes from processing
    this command: the command is correct and reads the specified port; a syntax error
    occurs and the system presents an appropriate message to the user; or a range
    error occurs and the system displays an appropriate error message. Use case extensions
    easily handle these situations, as shown in [Figure 4-11](ch04.xhtml#ch4fig11).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`port#`是一个表示要读取端口的数字字符串。当软件处理此命令时，可能会发生两种错误：`port#`可能存在语法错误（即它不是有效的数字值），或者`port#`的值超出了范围。因此，处理此命令时可能有三种结果：命令正确并读取指定的端口；发生语法错误，系统向用户展示适当的消息；或者发生范围错误，系统显示适当的错误消息。用例扩展可以轻松处理这些情况，如[图4-11](ch04.xhtml#ch4fig11)所示。
- en: '![image](Images/fig4-11.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig4-11.jpg)'
- en: '*Figure 4-11: Use case extension example*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-11：用例扩展示例*'
- en: Note that the normal case (no error) is not an extension use case. The `read_port`
    command use case handles the nonerror case directly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正常情况（无错误）不是扩展用例。`read_port`命令用例直接处理无错误的情况。
- en: '***4.2.6 Use Case Narratives***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.6 用例叙述***'
- en: By themselves, the use case diagrams you’ve seen thus far don’t explain any
    details. An actual use case (as opposed to a use case *diagram*) is text, not
    graphics. The diagrams provide an “executive overview” of the use case and make
    it easy for external observers to differentiate activities, but the *use case
    narrative* is where you truly describe a use case. Although there is no defined
    set of items that appear in a use case narrative, it typically contains the information
    listed in [Table 4-1](ch04.xhtml#ch4tab1).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，你看到的用例图并没有解释任何细节。一个实际的用例（与用例*图*不同）是文本，而不是图形。用例图提供了用例的“高层概览”，并使外部观察者容易区分活动，但*用例叙述*才是你真正描述用例的地方。尽管用例叙述中没有固定的一组项，但通常包含[表4-1](ch04.xhtml#ch4tab1)中列出的信息。
- en: '**Table 4-1:** Use Case Narrative Items'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-1：用例叙述项**'
- en: '| **Use case narrative item** | **Description** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **用例叙述项** | **描述** |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Associated requirements | A requirements tag or other indication of the requirement(s)
    associated with the use case. This provides traceability to the SyRS and SRS documentation.
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 相关需求 | 与用例相关的需求标签或其他需求指示。这提供了与SyRS和SRS文档的可追溯性。 |'
- en: '| Actors | A list of the actors that interact with the use case. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 角色 | 与用例交互的角色列表。 |'
- en: '| Goal/purpose/brief description | A description of the goal (and its context
    within the system) to clarify the purpose of the use case. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 目标/目的/简要描述 | 目标的描述（及其在系统中的背景），以明确用例的目的。 |'
- en: '| Assumptions and preconditions | A description of what must be true prior
    to the execution of the use case. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 假设和前提条件 | 执行用例之前必须为真条件的描述。 |'
- en: '| Triggers | External events that start the execution of the use case. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 触发器 | 启动用例执行的外部事件。 |'
- en: '|  Interaction/Flow of Events  | The step-by-step description of how an external
    actor interacts with the system during the execution of the use case. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 交互/事件流程 | 描述外部演员在执行用例期间如何与系统逐步交互。 |'
- en: '| Optional interactions/Alternative Flow of Events | Alternative interactions
    from those the interaction steps describe. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 可选交互/替代事件流程 | 与交互步骤描述的交互不同的替代交互。 |'
- en: '| Termination | Conditions that result in the termination of a use case. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 终止 | 导致用例终止的条件。 |'
- en: '| End conditions | Conditions describing what happens when the use case successfully
    terminates or when it fails. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 结束条件 | 描述用例成功终止或失败时发生的情况。 |'
- en: '| Post conditions | Conditions that apply upon completion of the execution
    of a use case (success or failure). |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 后置条件 | 用例执行完成后适用的条件（无论成功或失败）。 |'
- en: Additional items (search online for descriptions) might include:^([2](ch19_footnote.xhtml#ch04fn2))
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 额外项（在线搜索描述）可能包括：^([2](ch19_footnote.xhtml#ch04fn2))
- en: Minimal guarantees
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小保证
- en: Successful guarantees
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功的保证
- en: Dialog (effectively another name for interactions)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对话（实际上是交互的另一种名称）
- en: Secondary actors
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 次要演员
- en: Extensions (another name for optional/conditional interactions)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展（可选/条件性交互的另一个名称）
- en: Exceptions (that is, error-handling conditions)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常（即，错误处理条件）
- en: Related use cases (that is, other relevant use cases)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关用例（即，其他相关的用例）
- en: Stakeholders (people with an interest in the use case)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利益相关者（对用例感兴趣的人）
- en: Priority (among use cases for implementation)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先级（在用例实现中的优先顺序）
- en: '**4.2.6.1 Use Case Narrative Formality**'
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**4.2.6.1 用例叙述的正式性**'
- en: Use case narratives can range in formality from casual to fully dressed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 用例叙述可以从随意到正式不等。
- en: A casual use case narrative is a natural language (for example, English) description
    of the use case without much structure. Casual narratives are ideal for small
    projects, and often vary from use case to use case.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 随意的用例叙述是用自然语言（例如，英语）描述的用例，结构上较为简单。随意叙述适用于小型项目，并且通常因用例而异。
- en: 'A fully dressed use case narrative is a formal description of the use case,
    typically created via a form with all the narrative items defined for your project.
    A fully dressed use case narrative will likely consist of three forms:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 完全正式的用例叙述是对用例的正式描述，通常通过填写包含所有项目定义的表单来创建。完全正式的用例叙述通常包括三种形式：
- en: A list of the use case items, exclusive of the Dialog/Flow of Events/Interaction
    and Alternative Flow of Events/Optional Interactions items
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例项的列表，排除对话/事件流程/交互和替代事件流程/可选交互项
- en: The main Flow of Events
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要事件流程
- en: The Alternative Flow of Events (extensions)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代事件流程（扩展）
- en: '[Tables 4-2](ch04.xhtml#ch4tab2), [4-3](ch04.xhtml#ch4tab3), and [4-4](ch04.xhtml#ch4tab4)
    show an example of a fully dressed use case narrative.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-2](ch04.xhtml#ch4tab2)，[4-3](ch04.xhtml#ch4tab3)，和[4-4](ch04.xhtml#ch4tab4)显示了完全正式的用例叙述示例。'
- en: '**Table 4-2:** Select Nuclear Power Source, RCTR_USE_022'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-2：** 选择核电源，RCTR_USE_022'
- en: '| **Requirement(s)** | **RCTR_SyRS_022, RCTR_SRS_022_000** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **需求** | **RCTR_SyRS_022, RCTR_SRS_022_000** |'
- en: '| --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Actors | Reactor Operator, Sr. Reactor Operator |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 演员 | 反应堆操作员，高级反应堆操作员 |'
- en: '| Goal | To select the power measurement channel used during automatic operation
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 目标 | 选择在自动操作期间使用的电力测量通道 |'
- en: '| Assumptions and preconditions | Operator has logged in to the reactor console
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 假设和前提条件 | 操作员已登录反应堆控制台 |'
- en: '| Trigger | Operator presses appropriate button, selecting automatic mode power
    source |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 触发器 | 操作员按下相应按钮，选择自动模式电源 |'
- en: '| Termination | Operator-specified power source is selected |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 终止 | 操作员指定的电源被选择 |'
- en: '| End conditions | System uses the selected power source for current actual
    power during automatic operation, if successful; system reverts to original auto-mode
    power source if unsuccessful |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 结束条件 | 如果成功，系统在自动操作时使用选定的电源；如果失败，系统将恢复到原来的自动模式电源 |'
- en: '| Post condition | System has an operational automatic-mode power source available
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 后置条件 | 系统有一个可用的操作自动模式电源 |'
- en: '**Table 4-3:** Flow of Events, RCTR_USE_022'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-3：** 事件流程，RCTR_USE_022'
- en: '| **Step** | **Action** |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **操作** |'
- en: '| 1 | Operator presses NP selection button |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 操作员按下NP选择按钮 |'
- en: '| 2 | System verifies that the NP is online |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 系统验证NP是否在线 |'
- en: '| 3 | System switches auto-mode power selection to the NP channel |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 系统切换自动模式电源选择到核电源通道 |'
- en: '**Table 4-4:** Alternative Flow of Events (Extensions), RCTR_USE_022'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-4：** 事件的替代流程（扩展），RCTR_USE_022'
- en: '| **Step** | **Action** |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **动作** |'
- en: '| 2.1 | The NP channel is not online |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 2.1 | NP 通道不在线 |'
- en: '| 2.2 | The system doesn’t switch to using the NP power channel and continues
    to use the previously selected power channel for automatic mode |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 2.2 | 系统未切换到使用 NP 电源通道，并继续使用先前选择的电源通道进行自动模式 |'
- en: '**4.2.6.2 Alternative Flow of Events**'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**4.2.6.2 事件的替代流程**'
- en: Whenever a step in the Flow of Events table contains a conditional or optional
    item (an *extension* in UML terminology), you’ll have some corresponding entries
    in the Alternative Flow of Events table that describe the behavior when the conditional
    item is `false`. Note that you don’t use a separate Alternative Flow of Events
    table for each condition; you simply use substeps (in this example, 2.1 and 2.2
    in [Table 4-4](ch04.xhtml#ch4tab4)) associated with the step number(s) from the
    Flow of Events table (step 2 in [Table 4-3](ch04.xhtml#ch4tab3)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每当事件流程表中的步骤包含条件或可选项（在 UML 术语中称为*扩展*）时，你将在替代事件流程表中看到相应的条目，描述当条件项为 `false` 时的行为。请注意，你不会为每个条件使用单独的替代事件流程表；你只需使用与事件流程表中的步骤编号（例如[表
    4-3](ch04.xhtml#ch4tab3)的步骤 2）关联的子步骤（在本示例中为[表 4-4](ch04.xhtml#ch4tab4)中的 2.1 和
    2.2）。
- en: This is just one possible example of a fully dressed use case narrative. Many
    other forms are possible. For example, you could create a fourth table to list
    all the possible end conditions, as shown in [Table 4-5](ch04.xhtml#ch4tab5).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个完整的用例叙述的可能示例。还有许多其他形式。例如，你可以创建第四个表来列出所有可能的结束条件，如[表 4-5](ch04.xhtml#ch4tab5)所示。
- en: '**Table 4-5:** End Conditions, RCTR_USE_022'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-5：** 结束条件，RCTR_USE_022'
- en: '| **Condition** | **Result** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **条件** | **结果** |'
- en: '| Success | The NP channel is selected as the automatic-mode power channel
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 成功 | NP 通道被选为自动模式电源通道 |'
- en: '| Failure | The previously selected channel continues to control automatic
    mode |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 失败 | 先前选择的通道继续控制自动模式 |'
- en: Adding an end conditions table is especially compelling if there are more than
    two end conditions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两个以上的结束条件，添加结束条件表尤其有说服力。
- en: As another example, consider the `read_port` use case in [Figure 4-11](ch04.xhtml#ch4fig11).
    The narrative for it could be similar to [Tables 4-6](ch04.xhtml#ch4tab6), [4-7](ch04.xhtml#ch4tab7),
    and [4-8](ch04.xhtml#ch4tab8).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例是考虑[图 4-11](ch04.xhtml#ch4fig11)中的 `read_port` 用例。它的叙述可能类似于[表 4-6](ch04.xhtml#ch4tab6)、[4-7](ch04.xhtml#ch4tab7)和[4-8](ch04.xhtml#ch4tab8)。
- en: '**Table 4-6:** `read_port` Command'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-6：** `read_port` 命令'
- en: '| **Requirement(s)** | **DAQ_SyRS_102, DAQ_SRS_102_000** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **需求** | **DAQ_SyRS_102, DAQ_SRS_102_000** |'
- en: '| Actors | PC host computer system |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 角色 | PC 主机计算机系统 |'
- en: '| Goal | To read a digital data port on the data acquisition system |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 目标 | 读取数据采集系统上的数字数据端口 |'
- en: '| Assumptions and preconditions | Digital data acquisition ports have been
    initialized as input ports |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 假设和前提条件 | 数字数据采集端口已初始化为输入端口 |'
- en: '| Trigger | Receipt of the `read_port` command |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 触发条件 | 接收到 `read_port` 命令 |'
- en: '| Termination | Data port is read and the value returned to requesting system
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 终止条件 | 数据端口被读取，返回值给请求系统 |'
- en: '| End conditions | System returns port value or appropriate error message if
    the command was malformed |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 结束条件 | 如果命令格式不正确，系统返回端口值或适当的错误信息 |'
- en: '| Post condition | The system is ready to accept another command |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 后置条件 | 系统准备好接受另一个命令 |'
- en: '**Table 4-7:** Flow of Events, `read_port` Command'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-7：** 事件流程，`read_port` 命令'
- en: '| **Step** | **Action** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **动作** |'
- en: '| 1 | The host PC sends a command line beginning with `read_port` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 主机 PC 发送以 `read_port` 开头的命令行 |'
- en: '| 2 | System verifies that there is a second parameter |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 系统验证是否存在第二个参数 |'
- en: '| 3 | System verifies that the second parameter is a valid numeric string |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 系统验证第二个参数是否为有效的数字字符串 |'
- en: '| 4 | System verifies that the second parameter is a numeric value in the range
    0–15 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 系统验证第二个参数是否为 0–15 范围内的数字值 |'
- en: '| 5 | System reads the digital data from the specified port |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 系统从指定的端口读取数字数据 |'
- en: '| 6 | System returns the port value to the host PC |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 系统将端口值返回给主机 PC |'
- en: '**Table 4-8:** Alternative Flow of Events (Extensions), `read_port` Command'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-8：** 事件的替代流程（扩展），`read_port` 命令'
- en: '| **Step** | **Action** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **动作** |'
- en: '| 2.1 | Second parameter doesn’t exist |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 2.1 | 第二个参数不存在 |'
- en: '| 2.2 | System returns a “syntax error” message to the host PC |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 2.2 | 系统向主机 PC 返回“语法错误”消息 |'
- en: '| 3.1 | Second parameter isn’t a valid numeric string |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 3.1 | 第二个参数不是有效的数字字符串 |'
- en: '| 3.2 | System returns a “syntax error” message to the host PC |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 3.2 | 系统向主机PC返回“语法错误”消息 |'
- en: '| 4.1 | Second parameter is outside the range 0–15 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 4.1 | 第二个参数超出了0–15的范围 |'
- en: '| 4.2 | The system returns a “range error” message to the host PC |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 4.2 | 系统向主机PC返回“范围错误”消息 |'
- en: '[Table 4-8](ch04.xhtml#ch4tab8) actually contains several independent flows
    of events. The major number to the left of the decimal point specifies the associated
    step in the Flow of Events table; the minor number to the right of the decimal
    point is the particular step within the Alternative Flow of Events. The flow occurs
    only within the steps associated with a single Flow of Events number. That is,
    the flow from 2.1 to 2.2 ends with 2.2; it doesn’t continue into 3.1 (in this
    example).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-8](ch04.xhtml#ch4tab8)实际上包含了几个独立的事件流程。小数点左边的主要数字指定了与事件流程表中的步骤相关联的步骤；小数点右边的次要数字是替代事件流程中的特定步骤。流程仅在与单个事件流程编号关联的步骤内发生。也就是说，2.1到2.2的流程在2.2结束；它不会继续到3.1（在这个例子中）。'
- en: Generally, once a system selects an alternative flow (such as the “range error”
    flow, steps 4.1 and 4.2 in this example), the use case ends with the completion
    of that alternative flow (that is, at step 4.2). Control doesn’t return to the
    main Flow of Events. Execution to the end of the main Flow of Events list happens
    only if no alternative flows occur.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一旦系统选择了一个替代流程（例如，本例中的“范围错误”流程，步骤4.1和4.2），用例就在完成该替代流程时结束（即在步骤4.2）。控制不会返回到主事件流程。只有在没有替代流程发生时，才会执行到主事件流程列表的末尾。
- en: The “correct” way to use the Flow of Events and Alternative Flow of Events is
    to write a straight-line sequence representing the path through the use case that
    produces the intended result. If multiple viable paths exist, you would typically
    create multiple use cases, one for each correct path. The alternative flows handle
    any deviations (usually error paths) from the correct path. Of course, one risk
    of this approach is that you might wind up with an excessive number of use case
    diagrams.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件流程和替代事件流程的“正确”方式是编写一个直线序列，表示通过用例的路径，该路径产生预期的结果。如果存在多个可行路径，通常会为每个正确路径创建多个用例。替代流程处理任何偏离正确路径的情况（通常是错误路径）。当然，这种方法的一个风险是，您可能最终会得到过多的用例图。
- en: For a Flow of Events, diagrams are more expensive to create and maintain than
    a textual description; even with the proper UML diagramming tools, creating figures
    generally takes more time and effort than just writing textual descriptions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于事件流程，图表的创建和维护比文本描述更为昂贵；即使使用适当的UML绘图工具，创建图形通常也比仅仅编写文本描述更耗时和精力。
- en: '**4.2.6.3 Conditional Flow of Events**'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**4.2.6.3 条件事件流程**'
- en: For use cases that have multiple correct paths, you could encode those paths
    in the main Flow of Events using branches and conditionals, and leave the alternative
    paths for exceptional conditions. Consider a command for a data acquisition system
    that supports two different syntaxes:^([3](ch19_footnote.xhtml#ch04fn3))
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有多个正确路径的用例，您可以使用分支和条件将这些路径编码到主事件流程中，并将替代路径留给异常情况。考虑一个数据采集系统的命令，该命令支持两种不同的语法：^([3](ch19_footnote.xhtml#ch04fn3))
- en: '[PRE1]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first variant returns the number of PPDIO boards in the system, and the
    second variant sets the number of PPDIO boards. The technically correct solution
    to document these two commands is to create two separate use cases, each with
    its own Flow of Events. However, if the data acquisition system has dozens of
    different commands, creating individual use cases could clutter your documentation.
    One solution is to combine these use cases into a single use case by incorporating
    conditional operations (that is, `if..else..endif`) into a single Flow of Events,
    as in the following example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变体返回系统中的PPDIO板数量，第二个变体设置PPDIO板的数量。技术上正确的做法是为这两个命令创建两个独立的用例，每个用例都有自己的事件流程。然而，如果数据采集系统有数十个不同的命令，创建独立的用例可能会使文档显得杂乱无章。一个解决方案是通过将条件操作（即`if..else..endif`）合并到单个事件流程中，将这些用例合并为一个用例，具体如下面的示例所示。
- en: '**Flow of Events**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件流程**'
- en: Verify command begins with `ppdio`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证命令以`ppdio`开头。
- en: Verify second word on command line is `boards`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证命令行上的第二个单词是`boards`。
- en: 'If no additional parameters appear on command line:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果命令行上没有出现额外的参数：
- en: Return number of PPDIO boards in system as response.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回系统中PPDIO板的数量作为响应。
- en: Verify there is a single numeric parameter on the line.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证该行上是否只有一个数值参数。
- en: Verify that the numeric parameter is in the range `0..6`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证数值参数是否在`0..6`的范围内。
- en: Set the number of PPDIO boards to the value specified by the numeric parameter.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将PPDIO板的数量设置为数值参数中指定的值。
- en: '**Alternative Flows**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代流**'
- en: 1.1 If command doesn’t begin with `ppdio`, return `not PPDIO` response.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1 如果命令没有以`ppdio`开头，返回`not PPDIO`响应。
- en: 2.1 If command doesn’t begin with `ppdio boards`, return `not PPDIO BOARDS`
    response.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1 如果命令没有以`ppdio boards`开头，返回`not PPDIO BOARDS`响应。
- en: 5.1 Return `syntax error` as the response.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 5.1 返回`syntax error`作为响应。
- en: 6.1 Return `range error` as the response.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 6.1 返回`range error`作为响应。
- en: Having conditionals and multiple exit points from a Flow of Events isn’t “clean”
    UML; however, it can reduce the overall size of the documentation (saving time
    and expenses), so this is a common kludge in use cases.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件流中使用条件语句和多个退出点并不是“干净”的 UML；然而，它可以减少文档的整体大小（节省时间和费用），因此这是用例中常见的解决办法。
- en: You could even add `while`, `for`, `switch`, and other high-level-language–style
    operations to your Flow of Events. But keep in mind that use cases (and their
    descriptions) should be very general. Once you start embedding programming language
    concepts into your use cases, you invariably start introducing implementation
    details, which don’t belong in use cases; save those for later UML diagram types
    (such as activity diagrams).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以在事件流中加入`while`、`for`、`switch`等高级语言风格的操作。但请记住，用例（及其描述）应当非常通用。一旦你开始将编程语言的概念嵌入到用例中，你不可避免地会开始引入实现细节，而这些不属于用例的范畴；这些细节应留到后续的
    UML 图（如活动图）中。
- en: These examples might seem to suggest that alternative flows are solely for error
    handling, but you can use them for other purposes as well; any time a conditional
    branch is out of a main flow, you can use extensions to handle that. However,
    one problem with using alternative flows for generic conditionals is that concepts
    that are inherently related wind up separated from one another in your use case
    descriptions, which can make following the logic in those descriptions more difficult.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例可能让人觉得替代流仅仅用于错误处理，但你也可以用它们来处理其他情况；任何时候条件分支脱离主流，你都可以使用扩展来处理。然而，使用替代流来处理通用条件的一个问题是，原本相关的概念最终会在你的用例描述中被分开，这会使得理解这些描述中的逻辑变得更加困难。
- en: '**4.2.6.4 Generalization vs. Extension**'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**4.2.6.4 泛化与扩展**'
- en: Generalization is often a better tool than extension. For example, suppose you
    have a generic `port_command` use case and you want to attach `read_port` and
    `write_port` to it. In theory, you could create an extension to handle this, as
    shown in [Figure 4-12](ch04.xhtml#ch4fig12).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 泛化通常比扩展更有效。例如，假设你有一个通用的`port_command`用例，并且你想将`read_port`和`write_port`附加到它上面。理论上，你可以创建一个扩展来处理这个问题，如[图
    4-12](ch04.xhtml#ch4fig12)所示。
- en: '![image](Images/fig4-12.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig4-12.jpg)'
- en: '*Figure 4-12: Poor example of use case extension*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-12：用例扩展的糟糕示例*'
- en: In practice, this particular situation is probably better handled with generalization,
    because `read_port` and `write_port` are special cases of a `port_command` (rather
    than being alternative branches from `port_command`). [Figure 4-13](ch04.xhtml#ch4fig13)
    shows the generalization approach.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种情况可能更适合使用泛化处理，因为`read_port`和`write_port`是`port_command`的特例（而不是从`port_command`派生的替代分支）。[图
    4-13](ch04.xhtml#ch4fig13)展示了泛化方法。
- en: '![image](Images/fig4-13.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig4-13.jpg)'
- en: '*Figure 4-13: Using generalization rather than extension*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-13：使用泛化而不是扩展*'
- en: With generalization, the derived use case follows all the steps in the base
    use case. When you use extensions, control transfers from the main Flow of Events
    to the Alternative Flow of Events, and any remaining steps in the main flow don’t
    happen.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛化时，派生的用例遵循基本用例中的所有步骤。当使用扩展时，控制从主事件流转移到替代事件流，主事件流中剩余的步骤将不再执行。
- en: '***4.2.7 Use Case Scenarios***'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***4.2.7 用例场景***'
- en: 'A *scenario* is a single path through a use case. For example, the `read_port`
    use case has four scenarios: the success scenario when the command reads a port
    and returns the port data; two syntax error scenarios (2.1/2.2 and 3.1/3.2 in
    the Alternative Flow of Events); and one range error scenario (4.1/4.2 in the
    Alternative Flow of Events). You generate a full scenario by choosing the steps
    from the Flow of Events and Alternative Flow of Events that complete a specific
    path. The `read_port` command has the following scenarios:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*场景*是用例中的单一路径。例如，`read_port` 用例有四个场景：当命令读取端口并返回端口数据时的成功场景；两个语法错误场景（Alternative
    Flow of Events 中的 2.1/2.2 和 3.1/3.2）；以及一个范围错误场景（Alternative Flow of Events 中的
    4.1/4.2）。通过选择完成特定路径的事件流程和备用事件流程中的步骤，你可以生成一个完整的场景。`read_port` 命令有以下场景：'
- en: '**Success scenario**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**成功场景**'
- en: The host sends a command beginning with `read_port`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主机发送以 `read_port` 开头的命令。
- en: The system verifies that there is a second parameter.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统验证是否存在第二个参数。
- en: The system verifies that the second parameter is a numeric string.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统验证第二个参数是否为数字字符串。
- en: The system verifies that the second parameter is a value in the range `0..15`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统验证第二个参数是否在 `0..15` 范围内。
- en: The system reads the data from the specified port.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统从指定的端口读取数据。
- en: The system returns the port value to the host PC.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统将端口值返回给主机 PC。
- en: '**Syntax error #1 scenario**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法错误 #1 场景**'
- en: The host sends a command beginning with `read_port`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主机发送以 `read_port` 开头的命令。
- en: The system determines there is no second parameter.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统确定没有第二个参数。
- en: The system sends a syntax error to the host PC.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统向主机 PC 发送语法错误。
- en: '**Syntax error #2 scenario**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法错误 #2 场景**'
- en: The host sends a command beginning with `read_port`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主机发送以 `read_port` 开头的命令。
- en: The system verifies that there is a second parameter.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统验证是否存在第二个参数。
- en: The system determines that the second parameter is not a legal numeric string.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统确定第二个参数不是合法的数字字符串。
- en: The system sends a syntax error to the host PC.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统向主机 PC 发送语法错误。
- en: '**Range error scenario**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围错误场景**'
- en: The host sends a command beginning with `read_port`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主机发送以 `read_port` 开头的命令。
- en: The system verifies that there is a second parameter.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统验证是否存在第二个参数。
- en: The system verifies that the second parameter is a numeric string.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统验证第二个参数是否为数字字符串。
- en: The system determines that the numeric string is a value outside the range `0..15`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统确定数字字符串的值超出了 `0..15` 范围。
- en: The system sends a range error to the host PC.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统向主机 PC 发送范围错误。
- en: You can use scenarios to create test cases and test procedures for your system.
    You’ll have one or more test cases for each scenario.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用场景来为系统创建测试用例和测试流程。每个场景都会有一个或多个测试用例。
- en: You can combine use case scenarios by incorporating `if` statements in your
    Flow of Events. However, because this introduces low-level details into your use
    case narratives, you should avoid combining scenarios unless the number of use
    case narratives grows out of control.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在事件流程中加入 `if` 语句来结合用例场景。然而，由于这会将低级细节引入你的用例叙述中，除非用例叙述数量失控，否则应避免结合场景。
- en: '**4.3 The UML System Boundary Diagrams**'
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.3 UML 系统边界图**'
- en: When you’re drawing a simple use case diagram, it should be obvious which components
    are internal to the system and which are external. Specifically, actors are external
    entities, and the use cases are internal. If you’re using stereotyped rectangles
    instead of stick figures for the actors, though, it might not be immediately clear
    which components are external to the system. Also, if you reference multiple systems
    in a use case diagram, determining which use cases are part of which system can
    be challenging. UML system boundary diagrams solve these problems.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当你绘制简单的用例图时，应该能明显区分哪些组件是系统内部的，哪些是外部的。具体来说，参与者是外部实体，用例是内部的。不过，如果你使用带有刻板矩形而不是火柴人图形来表示参与者，可能不容易立刻明确哪些组件是系统外部的。此外，如果你在用例图中引用了多个系统，确定哪些用例属于哪个系统可能会很有挑战性。UML
    系统边界图解决了这些问题。
- en: A *UML system boundary diagram* is simply a shaded rectangle surrounding the
    use cases that are internal to a particular system, as shown in [Figure 4-14](ch04.xhtml#ch4fig14).
    The system title generally appears near the top of the rectangle.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*UML 系统边界图* 只是一个阴影矩形，围绕着特定系统内部的用例，如[图 4-14](ch04.xhtml#ch4fig14)所示。系统标题通常出现在矩形的顶部附近。'
- en: '![image](Images/fig4-14.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig4-14.jpg)'
- en: '*Figure 4-14: A system boundary diagram*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-14：系统边界图*'
- en: '**4.4 Beyond Use Cases**'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.4 超越用例**'
- en: This chapter introduced UML uses cases, a very important feature of the Unified
    Modeling Language. However, there are many other components of UML beyond use
    cases. The next chapter presents UML activity diagrams, which provide a way to
    model actions within a software design.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了UML用例，这是统一建模语言中一个非常重要的特性。然而，UML除了用例之外，还有许多其他组件。下一章将介绍UML活动图，它提供了一种在软件设计中建模动作的方法。
- en: '**4.5 For More Information**'
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**4.5 获取更多信息**'
- en: 'Bremer, Michael. *The User Manual Manual: How to Research, Write, Test, Edit,
    and Produce a Software Manual*. Grass Valley, CA: UnTechnical Press, 1999\. A
    sample chapter is available at *[http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf](http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf)*.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Bremer, Michael. *用户手册手册：如何研究、编写、测试、编辑和制作软件手册*。加利福尼亚州格拉斯谷：UnTechnical Press，1999年。可以通过*[http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf](http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf)*下载样本章节。
- en: 'Larman, Craig. *Applying UML and Patterns: An Introduction to Object-Oriented
    Analysis and Design and Iterative Development*. 3rd ed. Upper Saddle River, NJ:
    Prentice Hall, 2004.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Larman, Craig. *应用UML与模式：面向对象分析与设计及迭代开发导论*。第3版。新泽西州上萨德尔河：普伦蒂斯霍尔，2004年。
- en: 'Miles, Russ, and Kim Hamilton. *Learning UML 2.0: A Pragmatic Introduction
    to UML*. Sebastopol, CA: O’Reilly Media, 2003.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Miles, Russ, 和 Kim Hamilton. *学习UML 2.0：UML的实用入门*。加利福尼亚州塞巴斯托波尔：O’Reilly Media，2003年。
- en: 'Pender, Tom. *UML Bible*. Indianapolis: Wiley, 2003.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Pender, Tom. *UML圣经*。印第安纳波利斯：Wiley，2003年。
- en: 'Pilone, Dan, and Neil Pitman. *UML 2.0 in a Nutshell: A Desktop Quick Reference*.
    2nd ed. Sebastopol, CA: O’Reilly Media, 2005.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Pilone, Dan, 和 Neil Pitman. *UML 2.0概要：桌面快速参考*。第2版。加利福尼亚州塞巴斯托波尔：O’Reilly Media，2005年。
- en: 'Roff, Jason T. *UML: A Beginner’s Guide*. Berkeley, CA: McGraw-Hill Education,
    2003.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Roff, Jason T. *UML：初学者指南*。加利福尼亚州伯克利：麦格劳-希尔教育，2003年。
- en: Tutorials Point. “UML Tutorial.” [*https://www.tutorialspoint.com/uml/*](https://www.tutorialspoint.com/uml/).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Tutorials Point. “UML教程。”[*https://www.tutorialspoint.com/uml/*](https://www.tutorialspoint.com/uml/)。
