- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Interrupts
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 中断
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: The two main methods for handling I/O are *polling*, which repeatedly asks the
    device whether it has any data ready, and *interrupts*, which are when the device
    interrupts normal workflow to tell you it’s ready. This chapter describes the
    difference between polling and interrupts as well as explains how interrupts work
    so you can use them to write a string to the serial port more efficiently (yes,
    “Hello World” again).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 I/O 的两种主要方法是 *轮询*，即反复询问设备是否有数据准备好，和 *中断*，即设备打断正常工作流程来告诉你它已经准备好了。本章描述了轮询和中断之间的区别，并解释了中断是如何工作的，以便你能够利用它们更高效地向串口写入字符串（是的，还是“Hello
    World”）。
- en: Polling vs. Interrupts
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮询与中断
- en: 'Let’s consider how polling and interrupts would work in the case of the telephone.
    With polling, the ringer is turned off, and you must check the phone every 10
    seconds to see whether a call is coming in. You must sit by the phone and not
    get bored easily. This method is what we used in our previous serial program in
    Chapter 9, which basically went like the following dialogue:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下轮询和中断在电话中的应用场景。使用轮询时，铃声被关闭，你必须每 10 秒检查一次电话是否有来电。你必须坐在电话旁，不容易感到无聊。这种方法正是我们在第
    9 章的串行程序中使用过的，基本上是这样的对话：
- en: “Are you busy?” “Yes.”
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “你忙吗？” “忙。”
- en: “Are you busy?” “Yes.”
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “你忙吗？” “忙。”
- en: “Are you busy?” “Yes.”
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “你忙吗？” “忙。”
- en: “Are you busy?” “No.” “Here’s the next character.”
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “你忙吗？” “不忙。” “这是下一个字符。”
- en: The computer is stuck in a polling loop, waiting for the UART status register
    to indicate that the UART is ready for the next character. At this point, the
    computer has nothing else to do and doesn’t get bored. The main advantages of
    polling are that it’s easy to understand and implement.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机被卡在一个轮询循环中，等待 UART 状态寄存器指示 UART 准备好接受下一个字符。此时，计算机没有其他任务要做，也不会感到无聊。轮询的主要优点是它容易理解和实现。
- en: Let’s go back to the telephone again, but this time we’ll use the interrupt
    method. You don’t sit by the phone continually checking whether a call is coming
    in. Instead, you go about your normal business until the phone rings (an interrupt
    occurs). Then you drop everything, race to the phone, and pick up it—only to discover
    that it’s another telemarketing call for something you wouldn’t buy in a million
    years.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再回到电话的例子，但这次我们使用中断方法。你不会一直坐在电话旁检查是否有电话进来。相反，你继续进行正常的事务，直到电话响起（中断发生）。然后你抛下手头的一切，飞奔到电话旁接起电话——结果发现又是一个销售电话，卖的是你一辈子都不会买的东西。
- en: 'The key sequence of events in the interrupt scenario is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在中断场景中的关键事件顺序如下：
- en: We go about our normal work.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续进行正常工作。
- en: We get an interrupt (the phone rings).
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们收到一个中断（电话响了）。
- en: We pick up the phone (service the interrupt), shout “No, I don’t want to buy
    a combination shaving brush and fountain pen,” and hang up.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接起电话（服务中断），大声说“不是，我不想买一把组合剃须刷和钢笔”，然后挂断电话。
- en: We resume our normal work where we left off.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续从上次中断的地方恢复正常工作。
- en: Interrupts for Serial I/O
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 串行 I/O 的中断
- en: We can send characters to the UART only when the transmit data register (TDR)
    is empty. [Figure 10-1](#figure10-1) shows a block diagram of a portion of the
    UART to illustrate how the TDR works.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有在发送数据寄存器（TDR）为空时才能向 UART 发送字符。[图 10-1](#figure10-1) 显示了 UART 部分的框图，说明了 TDR
    的工作原理。
- en: '![f10001](image_fi/501621c10/f10001.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![f10001](image_fi/501621c10/f10001.png)'
- en: 'Figure 10-1: UART transmission hardware'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1：UART 传输硬件
- en: When we want to send a character, we dump it in the TDR, which holds 8 bits.
    The character is then dumped into the *transmit shift register (TSR)*, which holds
    10 bits. The 2 extra bits are the start bit at the beginning of the character
    and the stop bit at the end of the character. The TSR then sends the data out
    the *transmit serial line (TX)* one bit at a time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想发送一个字符时，我们将其放入 TDR，TDR 存储 8 位。然后字符被放入 *传输移位寄存器（TSR）*，TSR 存储 10 位。额外的 2 位是字符开始时的起始位和字符结束时的停止位。然后，TSR
    会将数据按位发送到 *传输串行线（TX）*。
- en: When the data is moved from the TDR to the TSR, the TDR becomes empty and is
    ready to receive another character.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据从 TDR 移动到 TSR 时，TDR 变为空，准备接收另一个字符。
- en: 'The polling loop we’ve been using looks like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的轮询循环如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In English, this says, “Are you empty yet? Are you empty yet? Are you empty
    yet?” And it’s just as annoying in C code as it is in English. Again, polling’s
    main advantage is its simplicity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 用英文来说就是：“你空了吗？你空了吗？你空了吗？”在C代码中，它也一样令人烦躁。再次说明，轮询的主要优点是简单。
- en: The other way to transmit characters is to tell the system we want an interrupt
    when the UART is ready to receive another character. An interrupt function is
    called automatically when something occurs. In our case, we want an interrupt
    when the TDR is empty.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 传输字符的另一种方式是告诉系统，当UART准备接收下一个字符时我们希望触发中断。发生某些事件时，中断函数会自动被调用。在我们的例子中，我们希望在TDR为空时触发中断。
- en: With interrupts, we tell the processor, “I’m going to go off and do useful work.
    When the TDR is empty, I want you to interrupt the normal flow and call an *interrupt
    routine* function, so I can give you the next character.”
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中断时，我们告诉处理器，“我要去做有用的工作。当TDR为空时，我希望你中断正常流程并调用*中断例程*函数，这样我可以给你下一个字符。”
- en: Interrupt Routines
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中断例程
- en: 'When an interrupt occurs, the CPU calls an interrupt routine function, located
    at a fixed address determined by the CPU’s design. Early CPUs had *one* address
    for all interrupts, so the code had to go through a number of checks to see what
    had interrupted:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当中断发生时，CPU会调用一个位于固定地址的中断例程函数，该地址由CPU的设计决定。早期的CPU为所有中断定义了*一个*地址，因此代码必须进行多次检查来确认是哪一个中断发生了：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Nowadays, even a simple chip can have many different devices. Checking all of
    them to see which one interrupted is a time-consuming process. As a result, chips
    (including our ARM chip), now use *vectored interrupts*, which means each peripheral
    gets its own interrupt address. Interrupts from UART1 will call an interrupt routine
    at one address, while interrupts from UART2 will go to another (specifically `USART2_IRQHandler`),
    and so on for other peripheral devices.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，即便是简单的芯片也可能有许多不同的设备。检查它们所有的中断来源是一个耗时的过程。因此，芯片（包括我们的ARM芯片）现在使用*向量中断*，这意味着每个外设都有自己的中断地址。来自UART1的中断会调用一个地址的中断例程，而来自UART2的中断会跳转到另一个地址（特别是`USART2_IRQHandler`），其他外设也是如此。
- en: 'The interrupt vector is defined in the *startup/startup_stm32f030x8.S* file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 中断向量在*startup/startup_stm32f030x8.S*文件中定义：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Later, the code defines the `USART2_IRQHandler` symbol:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 后续代码定义了`USART2_IRQHandler`符号：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The second directive (`.thumb_set`) defines the procedure `USART2_IRQHandler`
    to be the same as `Default_Handler`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个指令（`.thumb_set`）定义了将`USART2_IRQHandler`与`Default_Handler`相同的过程。
- en: The first `.weak` directive defines it as a *weak symbol*. If it were a regular
    symbol and we tried to define our own `USART2_IRQHandler`, the linker would abort
    with a `Duplicate symbol` error message. However, because the symbol is weak,
    the linker will throw away the weak definition and use the one that we provide.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`.weak`指令将其定义为*弱符号*。如果它是一个常规符号，并且我们尝试定义我们自己的`USART2_IRQHandler`，链接器将因`重复符号`错误消息而中止。然而，由于该符号是弱符号，链接器会丢弃弱定义并使用我们提供的符号。
- en: 'The *startup/startup_stm32f030x8.S* file defines `Default_Handler` later:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*startup/startup_stm32f030x8.S*文件稍后定义了`Default_Handler`：'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The default response to an interrupt is to loop forever, making the machine
    almost totally useless (I say “almost totally useless” because the machine will
    still respond to the debugger and a reset).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对中断的默认响应是无限循环，使得机器几乎完全无用（我说“几乎完全无用”，因为机器仍然会响应调试器和复位）。
- en: We’ll write our own `USART2_IRQHandler` to respond when the TDR is empty and
    thereby replace the default handler with something more useful.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写我们自己的`USART2_IRQHandler`来响应TDR为空时，从而用更有用的内容替代默认处理程序。
- en: Writing a String with Interrupts
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用中断写字符串
- en: 'Now let’s change our serial I/O program from Chapter 9 so that it uses interrupts
    instead of polling to write a string. All that’s communicated between the upper
    layer (the main program) and the lower layer (interrupt routine) is a single global
    variable:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将第9章中的串行I/O程序改为使用中断而不是轮询来写字符串。在上层（主程序）和下层（中断例程）之间传递的唯一信息是一个全局变量：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `const` qualifier tells C that the character data is constant and we’ll
    never attempt to change it. The `volatile` qualifier tells C that this variable
    may be changed at any time by something outside the flow of a normal C program,
    such as an interrupt function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`限定符告诉C语言该字符数据是常量，我们永远不会尝试更改它。`volatile`限定符告诉C语言这个变量可能会随时被正常C程序流之外的东西改变，比如一个中断函数。'
- en: To clarify, because C’s syntax is a little complex at this point, the `const`
    appears before the `char` declaration and means that the character data is constant.
    It does not appear after the pointer operator (`*`), so the pointer is not constant.
    The `volatile` modifier appears after the pointer operator, indicating the pointer
    may be changed. The lack of the `const` modifier after the pointer operator means
    that the program can change this value.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，因为在这一点上 C 语言的语法有点复杂，`const` 出现在 `char` 声明之前，表示字符数据是常量。它不会在指针运算符 (`*`) 之后出现，因此指针不是常量。`volatile`
    修饰符出现在指针运算符之后，表示指针可能会被更改。指针运算符之后缺少 `const` 修饰符意味着程序可以更改该值。
- en: 'We need to be careful with any variables used by both layers. Fortunately,
    for this example, that’s just one variable, `usart2String`. The following lists
    show the workflow for that variable:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要小心处理两个层次共享的任何变量。幸运的是，在此示例中，只有一个变量 `usart2String`。以下列表显示了该变量的工作流程：
- en: '**Upper Layer (Main Program)**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**上层 (主程序)**'
- en: Wait for `usart2String` to become `NULL`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 `usart2String` 变为 `NULL`。
- en: Point it to the string we want to send to the output.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其指向我们要发送到输出的字符串。
- en: Send the first character.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送第一个字符。
- en: Increment the pointer.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加指针。
- en: Enable the UART interrupt.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 UART 中断。
- en: '**Lower Layer (Interrupt)**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**底层 (中断)**'
- en: If we’ve reached the end of the string, set `usart2String` to `NULL`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已到达字符串末尾，则将 `usart2String` 设置为 `NULL`。
- en: Acknowledge that the UART received the interrupt.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认 UART 接收到中断。
- en: Send the character pointed to by the string.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送指向的字符。
- en: Increment the pointer.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加指针。
- en: Both the upper and lower layers increment the pointer. We need to be very careful
    when it comes to enabling the interrupt to make sure both layers don’t try to
    use the pointer at the same time. The upper layer won’t do anything until `usart2String
    == NULL`, and the lower layer sets `usart2String` to `NULL` only when it has run
    out of data and disables the UART2 interrupt. The upper layer protects itself
    by not enabling interrupts until after it performs the increment. Thus, the interrupt
    routine cannot monkey with the code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上层和下层都会增加指针。在启用中断时，我们需要非常小心，以确保两个层次不同时尝试使用指针。只有当 `usart2String == NULL` 时，上层才不会执行任何操作，而下层仅在数据耗尽并且禁用了
    UART2 中断时才将 `usart2String` 设置为 `NULL`。上层通过在执行增量之后再启用中断来保护自己。因此，中断程序无法改变代码。
- en: This analysis is extremely important. When it’s not done or not done properly,
    the program will fail, and the failures will occur at random times with random
    results. These results pose an extremely difficult, debug-resistant problem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分析非常重要。如果未进行或未正确进行，则程序将失败，并且故障将在随机时间产生随机结果。这些结果构成了一个非常棘手、难以调试的问题。
- en: I actually spent about three years finding one of these bugs. The problem occurred
    only for one customer and only about once every two months. We were completely
    unable to reproduce it in the lab. Fortunately, the customer was very mellow and
    willing to work with us on the solution. Later in this chapter, we’ll explore
    what happens when this analysis is not done and consider some techniques for diagnosing
    interrupt-related bugs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我花了大约三年的时间找到其中一个漏洞。这个问题只发生在一个客户身上，每两个月才会发生一次。我们完全无法在实验室复现这个问题。幸运的是，客户非常冷静，并愿意与我们合作找到解决方案。本章后面，我们将探讨在没有进行此分析或未正确进行此分析时会发生什么，并考虑一些诊断与中断相关的
    bug 的技术。
- en: '[Listing 10-1](#listing10-1) contains the interrupt-driven serial I/O program.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码清单 10-1](#listing10-1) 包含基于中断驱动的串行 I/O 程序。'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 10-1: 10.serial.int/main.c*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 10-1: 10.serial.int/main.c*'
- en: Program Details
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序详细信息
- en: '[Listing 10-1](#listing10-1) looks a lot like the serial I/O program from Chapter
    9, because setting up the I/O system is the same, with a lot of extra little details.
    But in this case, we added something new:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码清单 10-1](#listing10-1) 看起来很像第 9 章的串行 I/O 程序，因为设置 I/O 系统是相同的，只是增加了许多额外的细节。但在这种情况下，我们添加了新的东西：'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `NVIC_EnableIRQ` function initializes the *nested vectored interrupt controller
    (NVIC)*, which is a bit of hardware that decides what the processor does when
    it receives an interrupt and enables the USART2 interrupt. When the processor
    is reset, it turns off all interrupts, so we need to tell it that we want USART2
    to interrupt it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`NVIC_EnableIRQ` 函数初始化了*嵌套向量中断控制器 (NVIC)*，这是一个硬件部件，决定处理器在接收中断时的操作，并启用了 USART2
    中断。处理器复位时会关闭所有中断，因此我们需要告诉它我们希望 USART2 中断它。'
- en: 'Now let’s look at the `myPuts` function, which sends a string (instead of a
    single character, like `myPutchar` from Chapter 9) to the serial device:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`myPuts`函数，它将一个字符串（而不是像第9章中的`myPutchar`那样的单个字符）发送到串行设备：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first thing we do is wait for the previous string to finish 1. We know that
    if `usart2String` is not `NULL`, the interrupt routine is active and we should
    wait until the previous string is transmitted. When it becomes `NULL`, the interrupt
    routine is inactive and we can start our transmission.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是等待前一个字符串传输完成1。我们知道，如果`usart2String`不为`NULL`，中断例程正在活动，我们应该等待直到前一个字符串传输完毕。当它变为`NULL`时，中断例程不再活动，我们就可以开始传输。
- en: When we do get our turn, we tell the interrupt function what string we are transmitting
    2, and then we transmit the first character 3. As a final step, we enable the
    transmit data buffer empty interrupt 4.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当轮到我们时，我们会告诉中断函数我们正在传输哪个字符串2，然后传输第一个字符3。最后一步，我们启用传输数据缓冲区空中断4。
- en: 'Several symbols control what interrupts are enabled. The `USART_CR1_TXNEIE`
    bit tells the UART to interrupt when the transmit data buffer is empty. Here are
    some other symbols to note:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个符号控制着哪些中断被使能。`USART_CR1_TXNEIE`位告诉UART在传输数据缓冲区为空时产生中断。这里还有一些其他需要注意的符号：
- en: '`USART_CR1_IDLEIE` IDLE interrupt enable'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_CR1_IDLEIE` 空闲中断使能'
- en: '`USART_CR1_RXNEIE` Receive interrupt enable'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_CR1_RXNEIE` 接收中断使能'
- en: '`USART_CR1_TCIE` Transmission complete interrupt enable (interrupt when the
    character has gone out, not when we first load a character into the transmission
    register)'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_CR1_TCIE` 传输完成中断使能（在字符传输完毕时触发中断，而不是当我们第一次将字符加载到传输寄存器时）'
- en: '`USART_CR1_PEIE` Parity error interrupt enable'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_CR1_PEIE` 奇偶校验错误中断使能'
- en: Once we send the first character, the TDR is filled. When it is transferred
    to the TSR, the TDR will be empty and we’ll get an interrupt. From here on, the
    interrupt routine does the work.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们发送第一个字符，TDR会被填充。当它被传输到TSR时，TDR将变为空，我们会得到一个中断。从此之后，中断例程将完成工作。
- en: 'The actual interrupt routine is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的中断例程如下：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function declaration uses a magic name that identifies it as the interrupt
    routine 1.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明使用了一个魔法名称，标识它为中断例程1。
- en: 'If the function gets called, we know we have an interrupt from USART2, but
    we don’t know what type of interrupt it is because the USART has multiple types
    of interrupts:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数被调用，我们知道我们收到了来自USART2的中断，但我们不知道是哪种类型的中断，因为USART有多种中断类型：
- en: '`USART_ISR_TXE` TDRempty'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_ISR_TXE` TDR为空'
- en: '`USART_ISR_CTSIF` CTS interrupt'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_ISR_CTSIF` CTS中断'
- en: '`USART_ISR_TC` Transmission complete'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_ISR_TC` 传输完成'
- en: '`USART_ISR_RXNE` Receive data register not empty (data ready to be read)'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_ISR_RXNE` 接收数据寄存器不为空（数据已准备好读取）'
- en: '`USART_ISR_ORE` Overrun error detected'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_ISR_ORE` 溢出错误检测到'
- en: '`USART_ISR_IDLE` Idle line detected'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_ISR_IDLE` 空闲线路检测到'
- en: '`USART_ISR_FE` Framing error'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_ISR_FE` 帧错误'
- en: '`USART_ISR_PE` Parity error'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_ISR_PE` 奇偶校验错误'
- en: '`USART_ISR_NE` Noise flag'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_ISR_NE` 噪声标志'
- en: '`USART_ISR_CMF` Character match'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_ISR_CMF` 字符匹配'
- en: '`USART_ISR_TXE` Receiver timeout'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USART_ISR_TXE` 接收超时'
- en: All of these interrupts will result in a call to `USART2_IRQHandler`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些中断将导致调用`USART2_IRQHandler`。
- en: First, we need to check whether we have a transmit buffer empty interrupt 2.
    Our interrupt function should never be called with `usart2String` set to `NULL`,
    but “should” and “reality” are vastly different, so we put in a little bit of
    paranoia to make sure we don’t crash if something goes wrong 3. The variable `usart2String`
    should never be `NULL` at this point, but if it is, we don’t want to cause trouble.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查是否有传输缓冲区空中断2。我们的中断函数不应该在`usart2String`为`NULL`时被调用，但“应该”与“现实”有很大差距，所以我们加入了一些谨慎，以确保在出现问题时不会崩溃3。此时变量`usart2String`不应该为`NULL`，但如果它是`NULL`，我们也不想引发问题。
- en: Without that check, we might try to deference a `NULL` pointer 4. Dereferencing
    a `NULL` pointer is illegal, and the STM32 is nice enough to have hardware to
    check for this condition. When it occurs, the STM32 generates a *memory fault
    interrupt*. In other words, the interrupt handler is being interrupted, and control
    transfers to the memory fault interrupt handler. However, we haven’t written one,
    so the default handler is executed. As mentioned previously, the default handler
    locks up the system until you reset it. To protect ourselves against an improper
    `usart2String`, when we see it, we do the safest thing, which is to turn off the
    interrupt and do nothing else 3.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有那个检查，我们可能会尝试解引用一个`NULL`指针4。解引用`NULL`指针是非法的，而STM32足够智能，具备硬件来检查这种情况。当这种情况发生时，STM32会生成一个*内存故障中断*。换句话说，中断处理程序正在被中断，控制权转移到内存故障中断处理程序。然而，我们还没有编写处理程序，因此执行的是默认的中断处理程序。如前所述，默认处理程序会锁死系统，直到你重置它。为了保护自己免受不当的`usart2String`影响，当我们看到它时，我们采取最安全的做法，即关闭中断并什么都不做3。
- en: Next, we check to see whether we’ve run out of string. If we have, we `NULL`
    out the string to signal to the top level that we’re done and to turn off interrupts.
    Otherwise, we know we have data for the UART and that the TDR is empty, so we
    dump a character into it 5. Once we’ve sent the character, we need to point to
    the next one for the next time we get interrupted, and then return to the main
    program 6.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否已经发送完字符串。如果已经发送完，我们将字符串设为`NULL`，以便向上层信号表示我们完成了任务并关闭中断。否则，我们知道UART还有数据，而TDR为空，因此我们将一个字符写入其中5。发送完字符后，我们需要指向下一个字符，为下次中断做好准备，然后返回主程序6。
- en: At this point, the TDR is full, and the UART is sending characters. The interrupt
    route has nothing more to do, so it will return and normal execution will resume.
    When the character is sent and the TDR is empty, we’ll get another interrupt,
    which will continue until we run out of string and turn off the interrupt.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，TDR已满，UART正在发送字符。中断路径没有更多的任务，因此它将返回，正常执行将恢复。当字符发送完毕并且TDR为空时，我们会收到另一个中断，直到字符串发送完毕并关闭中断。
- en: The hardware engineers at STMicroelectronics have helpfully explained this process
    with a diagram (see [Figure 10-2](#figure10-2)).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: STMicroelectronics的硬件工程师通过一张图帮助解释了这个过程（见[图10-2](#figure10-2)）。
- en: '![f10002](image_fi/501621c10/f10002.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![f10002](image_fi/501621c10/f10002.png)'
- en: 'Figure 10-2: USART interrupt mapping'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2：USART中断映射
- en: This diagram shows that if the TCIE (transmit character interrupt enable) bit
    is on 1 and a character has been transmitted (TC) 2, the output of the AND gate
    is true 3. This result is combined with the output of three other interrupts,
    and if any one is true (OR gate), the result 4 is true. Then that result is combined
    with the output of another OR gate 5 for all the other signals, and the result
    of the last OR gate is the USART interrupt signal. Note that the diagram is meant
    to simplify this process. If you want to know what the alphabet soup of inputs
    mean, read the 800-page reference manual for this processor.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图显示了如果TCIE（传输字符中断使能）位为1，并且一个字符已经被传输（TC）2，AND门的输出为真3。这个结果与另外三个中断的输出结合，如果有任何一个为真（OR门），结果4为真。然后，结果与另一个OR门的输出5结合，处理所有其他信号，最后的OR门输出即为USART中断信号。请注意，这张图旨在简化此过程。如果你想了解输入信号的具体含义，可以阅读这款处理器的800页参考手册。
- en: Interrupt Hell
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中断地狱
- en: Interrupts are extremely powerful tools when it comes to controlling hardware
    as well as dealing with events in real time. However, using interrupts can cause
    a number of unique and difficult problems to occur.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 中断在控制硬件以及处理实时事件时是非常强大的工具。然而，使用中断可能会导致一些独特且难以解决的问题。
- en: 'First, they can interrupt normal program flow at any time. For example, consider
    the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它们可以随时中断正常的程序流程。例如，考虑以下代码：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What’s the value of `i` after this statement is executed? The answer is obviously
    5, unless an interrupt routine just executed and modified it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此语句后，`i`的值是多少？答案显然是5，除非中断程序刚刚执行并修改了它：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Second, interrupt routines execute asynchronously, which means they execute
    whenever they feel like it, so any bugs caused by poorly written interrupt routines
    can be difficult to reproduce. I’ve seen cases where a bug occurred only randomly
    after about two weeks of testing because the interrupt had to occur exactly when
    one of two instructions was executing—that’s two out of the tens of thousands
    in the code. It took a lot of testing to stumble upon this problem.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，中断例程是异步执行的，这意味着它们会在任何需要的时候执行，因此，由于编写不当的中断例程引起的错误可能很难复现。我曾经见过一种情况，错误只有在经过两周的测试后偶尔发生，因为中断必须在两条指令之一执行时恰好发生——这只是成千上万条指令中的两条。需要大量的测试才能偶然发现这个问题。
- en: Because of the inherent difficulties with interrupt routines, it pays to give
    them a lot of respect. The most important design rule when dealing with interrupt
    routines is to keep them small and simple, because the less the routine does,
    the less there is that can go wrong. It’s better to leave the “thinking” to the
    higher-level code where debuggers work nicely and where reproducibility is not
    a problem.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于中断例程固有的困难，值得对它们给予高度重视。处理中断例程时最重要的设计原则是保持其简短和简单，因为例程做的越少，出错的可能性也就越小。最好将“思考”留给高层代码，在那里调试工具可以很好地工作，并且可复现性不是问题。
- en: Interrupt routines also need to execute quickly, because while an interrupt
    routine is executing, other interrupts are held off until the routine is finished.
    If you take a long time in an interrupt routine that’s reading a character from
    UART1, another device, such as UART2, might lose data because its interrupt couldn’t
    get serviced in time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 中断例程也需要快速执行，因为在中断例程执行时，其他中断会被暂时挂起，直到该例程执行完成。如果你在一个读取UART1字符的中断例程中花费了很长时间，另一个设备（如UART2）可能会丢失数据，因为它的中断没有及时得到处理。
- en: Using a Buffer to Increase Speed
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓冲区提高速度
- en: 'The system we just used has some limits. It can transmit only one message at
    a time. Suppose we wanted to output multiple short messages. Each one would have
    to wait until the previous one finished. Here’s an example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用的系统有一些限制。它一次只能传输一条消息。假设我们想要输出多条短消息。每条消息必须等待前一条完成。这里是一个示例：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: One solution to this problem is to create a *buffer* to hold the character data
    until the interrupt routine can service it. Doing that adds complexity to the
    application, but it increases the speed at which your top-level program can send
    data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是创建一个*缓冲区*，将字符数据保存，直到中断例程能够处理它。这样做增加了应用程序的复杂性，但它提高了你的顶层程序发送数据的速度。
- en: Using serial I/O means considering the general trend of speed versus simplicity.
    The polling version was very simple and slow. The single string interrupt version
    was faster but more complex. The buffer system we are using now is much faster
    and much more complex. This trend is true for most programs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用串行I/O意味着要考虑速度与简单性的一般趋势。轮询版本非常简单且慢。单一字符串中断版本较快，但更复杂。我们现在使用的缓冲区系统则更快且更加复杂。这个趋势对大多数程序来说都是成立的。
- en: 'For this problem, let’s go back to the buffer. We’ll use a *circular buffer*
    that has the following basic structure:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们回到缓冲区的概念。我们将使用一个*循环缓冲区*，它具有以下基本结构：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It’s called a circular buffer because the indices wrap. In other words, after
    a character is put in the last element of data, the `putIndex` will wrap from
    7 (`BUFFER_SIZE-1`) to 0.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为循环缓冲区，因为索引会回绕。换句话说，当一个字符被放入数据的最后一个元素时，`putIndex`会从7（`BUFFER_SIZE-1`）回绕到0。
- en: Graphically, this looks like [Figure 10-3](#figure10-3).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从图形上看，这像是[图10-3](#figure10-3)。
- en: '![f10003](image_fi/501621c10/f10003.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![f10003](image_fi/501621c10/f10003.png)'
- en: 'Figure 10-3: A circular buffer in action'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-3：循环缓冲区的工作原理
- en: Our implementation is going to contain a deliberate nasty mistake, so we can
    look at techniques and procedures for finding such mistakes in a small, controlled
    program. I’ll show the symptoms of the bug, the diagnostic techniques used to
    locate it, and the fix as we go through the program.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现将包含一个故意的错误，这样我们可以在一个小的、可控的程序中查看查找此类错误的技术和方法。我们将在程序中展示错误的症状、用于定位错误的诊断技术以及修复方法。
- en: The first time I encountered a problem like this was about 30 years ago. It
    wasn’t in a 200-line demonstration program; it was in the BSD Unix kernel in a
    serial module with tens of thousands of lines. It occurred about once every three
    to seven days randomly and took three engineers two months to find it. To make
    matters worse, it was processor-dependent and didn’t occur on the VAX processor
    that ran the original BSD.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次遇到这种问题是在大约 30 年前。它并不是出现在一个 200 行的演示程序中，而是在一个有着数万行代码的 BSD Unix 内核中的串行模块。它大约每三到七天随机发生一次，三个工程师花了两个月才找到了它。更糟糕的是，它依赖于处理器，并且在运行原始
    BSD 的 VAX 处理器上不会发生。
- en: The top-level program (the sender) puts data in the buffer. The lower-level
    interrupt routine (the receiver) removes data from the buffer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层程序（发送方）将数据放入缓冲区。低级中断例程（接收方）从缓冲区中移除数据。
- en: 'In pseudocode, the sender’s job is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 用伪代码表示，发送方的工作如下：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And the receiver’s job is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接收方的工作如下：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Sending Function
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送函数
- en: 'To use a circular buffer, we have to go back to sending one character at a
    time with another version of `myPutchar`. Let’s look at the code doing the sending:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用循环缓冲区，我们必须回到一次发送一个字符，使用另一个版本的 `myPutchar`。让我们看看执行发送的代码：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the beginning, we wait until there is room for at least one character in
    the buffer 1. Then we dump the character in the buffer 2. The `putIndex` advances
    by one and wraps back to 0 if necessary 3.The number of characters in the buffer
    has increased, so we increment the `nCharacters` count in the buffer structure
    4. Finally, we enable the interrupt 5. If we are transmitting, the interrupt may
    already be enabled. Enabling it again won’t cause problems.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们等待缓冲区中至少有一个字符的位置。然后我们将字符倒入缓冲区。`putIndex` 前进一个位置，并在必要时回绕到 0。缓冲区中的字符数量增加，因此我们在缓冲区结构中增加
    `nCharacters` 的计数。最后，我们启用中断。如果我们正在传输，可能中断已经启用，再次启用也不会造成问题。
- en: Interrupt Routine
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中断例程
- en: The interrupt routine reads the data from the buffer and transmits it to the
    UART. If a character is in the buffer, the routine removes it and sends it to
    the UART. If nothing is in the buffer, the routine turns off the interrupt.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 中断例程从缓冲区读取数据并将其传输到 UART。如果缓冲区中有字符，例程将其移除并发送到 UART。如果缓冲区中没有数据，例程会关闭中断。
- en: 'Here’s the code for this procedure:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个过程的代码：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we check to see whether the device has run out of data. If it has, we
    shut down the interrupt until we get more data from the upper level 1. Then we
    send the character 2, move the `getIndex` up one, and wrap if needed 3. Next,
    we let the upper layer know we have one less character 4. Finally, we shut down
    the interrupt if this was the last character 5.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查设备是否已没有数据。如果没有，我们关闭中断，直到从上层获取更多数据。然后我们发送字符，`getIndex` 上移一位，并在需要时回绕。接下来，我们让上层知道我们少了一个字符。最后，如果这是最后一个字符，我们关闭中断。
- en: Full Program
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整程序
- en: '[Listing 10-2](#listing10-2) shows the complete program.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-2](#listing10-2) 显示了完整的程序。'
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 10-2: 10.serial.buffer.bad/src/main.c*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-2：10.serial.buffer.bad/src/main.c*'
- en: The Problem
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: 'When we run the program, we expect to see the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，我们期望看到以下内容：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Instead, we get this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是这样的：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There is no pattern to when this issue will occur, other than that the more
    data we send to the buffer, the more likely we are to have a problem.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此问题的发生没有固定的模式，除了我们发送到缓冲区的数据越多，发生问题的可能性就越大。
- en: With this tiny program, replicating that problem in the field is going to be
    difficult because it requires very precise timing. It’s more likely that after
    implementing and testing this code, we would incorporate the module in another
    program that would make the timing more likely. Timing bugs are notoriously difficult
    to cause on demand, but there is one in this code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个小程序，在现场复制该问题会很困难，因为它需要非常精确的时序。更有可能的是，在实现并测试了这段代码后，我们会将模块纳入另一个程序，这样时序问题的发生概率会更大。时序错误通常很难按需触发，但这段代码中确实存在一个问题。
- en: 'We know that the busier the system is, the more likely it is that the problem
    will happen. Plus, we have another clue—we haven’t been able to catch it in the
    act, but afterward we looked at the debugger and discovered the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，系统越忙，问题发生的可能性就越大。此外，我们还有另一个线索——我们一直没能在发生时抓住它，但事后我们查看了调试器，发现了以下内容：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In a correctly working program, both of these conditions can never be true.
    There are two ways of attacking this problem. The first is to instrument the code
    and try to find out what is going on. The second is to perform very detailed analysis
    of any data shared between the upper and lower layers and the code that manipulates
    this data. Let’s do both.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个正常工作的程序中，这两个条件永远不可能同时成立。解决这个问题有两种方法。第一种是对代码进行插桩，尝试找出发生了什么。第二种方法是对上下层之间共享的数据和操作这些数据的代码进行非常详细的分析。我们两者都做一下。
- en: Instrumenting the Code
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对代码进行插桩
- en: '*Instrumenting* the code means putting in temporary debugging statements that
    will help find a problem. With most code, this means writing `printf` statements
    to output intermediate data that we can check as the program progresses. Sometimes
    data is printed to a logfile that can be analyzed after the problem occurs. Neither
    of these options is viable for our embedded program. We can’t use `printf` because
    the output would go to the serial console, and that’s the code with the bug. We
    can’t write a logfile because we don’t have a filesystem to write logging information
    to.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对代码进行*插桩*意味着插入临时的调试语句，这将有助于发现问题。对于大多数代码来说，这意味着写`printf`语句输出中间数据，供我们在程序执行过程中进行检查。有时，数据会被打印到日志文件中，供问题发生后分析。对于我们的嵌入式程序，这两种方式都不可行。我们不能使用`printf`，因为输出会发送到串口控制台，而控制台本身就包含了错误的代码。我们也不能写日志文件，因为我们没有文件系统来写入日志信息。
- en: We need to use a log buffer that will store the last 100 events. When we encounter
    a problem, we can go back and look at the events to see what led up to the problem.
    The log records the relevant data (`getIndex`, `putIndex`, `nCharacters`) and
    the line number of the call to the event-logging code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用一个日志缓冲区来存储最后100个事件。当我们遇到问题时，可以回溯查看这些事件，以了解问题的发生经过。日志记录相关数据（`getIndex`、`putIndex`、`nCharacters`）和事件记录代码的行号。
- en: When the problem occurs and we get a chance to stop the program in the debugger,
    we can look through the log. If we are lucky, we should be able to find a few
    log entries where at line *X* the buffer information was consistent and at line
    *Y* it was screwed up, which reveals that the problem occurred between lines *X*
    and *Y*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当问题发生并且我们有机会在调试器中暂停程序时，我们可以查看日志。如果幸运的话，我们应该能够找到一些日志条目，其中在*X*行时`buffer`信息是一致的，而在*Y*行时`buffer`出现了问题，这揭示了问题发生在*X*行和*Y*行之间。
- en: '[Listing 10-3](#listing10-3) shows the code to record an event. Add this code
    after the other definitions and variable declarations.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10-3](#listing10-3)展示了记录事件的代码。将此代码添加到其他定义和变量声明之后。'
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 10-3: The event recorder'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10-3：事件记录器
- en: This event recorder contains the same type of bug we’re trying to find, but
    for now, we’ll assume that it works well enough for us to locate the problem.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事件记录器包含了我们正在尝试找出的同样类型的错误，但目前我们假设它足够有效，可以帮助我们定位问题。
- en: 'Now we need to put in a few calls to the `debugEvent` function to see whether
    we can spot the error. Since `nCharacters` is driving us nuts, we put a call to
    `debugEvent` before and after each operation we perform on `nCharacters`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要插入一些`debugEvent`函数调用，看看能否发现错误。由于`nCharacters`让我们抓狂，我们在每次操作`nCharacters`之前和之后都插入了`debugEvent`调用：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We also put a consistency check at the beginning of `myPutchar` to make sure
    the `buffer` is sane. Specifically, if we see the condition where the `buffer`
    is inconsistent (`nCharacters == 0` and `getIndex != putIndex`), we invoke the
    `Error_Handler` function to stop the program:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`myPutchar`函数的开头增加了一致性检查，以确保`buffer`是正常的。具体来说，如果我们发现`buffer`不一致的情况（`nCharacters
    == 0`且`getIndex != putIndex`），我们调用`Error_Handler`函数停止程序：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s start the program under the debugger with a breakpoint at `Error_Handler`
    and see if we can catch the error. Eventually, we hit the breakpoint and, using
    the debugger, examine the `debugEvents`. Looking back through the traces using
    the debugger, we find the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在调试器中启动程序，并在`Error_Handler`处设置断点，看看能否捕捉到错误。最终，我们触发了断点，并通过调试器检查了`debugEvents`。回顾调试器中的追踪信息，我们发现了以下内容：
- en: 'Line 119: `nCharacters == 3`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第119行：`nCharacters == 3`
- en: 'Line 89: `nCharacters == 3`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第89行：`nCharacters == 3`
- en: 'Line 91: `nCharacters == 2`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第91行：`nCharacters == 2`
- en: 'Line 121: `nCharacters == 4`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第121行：`nCharacters == 4`
- en: Why did `nCharacters` jump by 2 between the last two events?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`nCharacters`在最后两次事件之间跳了2？
- en: 'Here are the relevant lines:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的代码如下：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'and:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以及：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Something is wrong with line 90 or 120, which also tells us something important.
    After line 119 and before line 121, an interrupt occurred. We’ve now pinpointed
    the error to a couple lines of code and an interrupt. Let’s shift gears and use
    code analysis to reach the same conclusion. We’re exploring both methods because
    sometimes one method works and the other doesn’t.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第90行或第120行出了问题，这也告诉我们一些重要的信息。在第119行和第121行之间发生了中断。我们现在已将错误定位到几行代码和一个中断。让我们转变思路，使用代码分析得出相同的结论。我们同时探索这两种方法，因为有时候一种方法有效，另一种却无效。
- en: Analyzing the Code
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分析代码
- en: 'The other way to figure out the problem is to analyze what is going on and
    try to identify potential problem spots. The analysis starts by identifying the
    shared data between the upper and lower layers—in other words, the buffer:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个找出问题的方法是分析正在发生的事情，并尝试识别潜在的问题点。分析从识别上下层之间共享的数据开始——换句话说，就是缓冲区：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Neither `putIndex` nor `getIndex` should cause a problem, since they’re used
    by only one layer each (the upper and lower layer, respectively). The `data` array
    is shared by both layers, but it’s written by the upper layer and read by the
    lower level, so each layer has a distinct job when it comes to that array. In
    addition, `putIndex` controls the portion of the array the upper layer uses, and
    `getIndex` controls the portion the lower layer uses. They point to different
    elements of the array, and nothing going into or out of `data` could affect the
    indices or character counter. The `data` array is not the problem.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`putIndex`和`getIndex`不应该导致问题，因为它们只被上下两层各自使用。`data`数组是由两层共享的，但由上层写入，下层读取，因此每层在处理该数组时有不同的职责。此外，`putIndex`控制上层使用的数组部分，而`getIndex`控制下层使用的数组部分。它们指向数组的不同元素，进入或离开`data`的内容不会影响索引或字符计数器。`data`数组不是问题所在。'
- en: 'All that’s left is `nCharacters`, which the upper layer increments and the
    lower level decrements, so there are two potential problem lines. One is in the
    interrupt routine:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只有`nCharacters`，上层递增，下层递减，因此有两个潜在的问题行。一个出现在中断例程中：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And the other is in `myPutchar`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题出现在`myPutchar`中：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These are the same two lines our instrumented code indicated might be a problem.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们的仪器化代码指出可能存在问题的同两行。
- en: Closely Examining the Code
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 细致检查代码
- en: 'Let’s see exactly what happens when the following line is executed:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看执行以下代码行时究竟发生了什么：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is the assembly code (comments added) for this line:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这一行的汇编代码（已添加注释）：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This code loads the value of `nCharacters` into register `r3`, increments it,
    and sticks it back in `nCharacters`. Interrupts can happen at any time, like right
    after the value is loaded into `r3` 1, which causes the following to happen (assuming
    `nCharacters` is 3):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将`nCharacters`的值加载到寄存器`r3`，递增它，并将其存回`nCharacters`。中断可以随时发生，比如就在值被加载到`r3`中之后，这导致以下情况发生（假设`nCharacters`为3）：
- en: At line 406, register `r3` gets the value of `nCharacters` (`r3 == 3`).
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第406行，寄存器`r3`获得了`nCharacters`的值（`r3 == 3`）。
- en: Just before the instruction at line 407, an interrupt occurs.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第407行指令之前发生了一个中断。
- en: The interrupt routine reads `nCharacters` (it’s 3).
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中断例程读取`nCharacters`（它是3）。
- en: It decrements it, so the value of `nCharacters` is now 2.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将其递减，所以`nCharacters`的值现在是2。
- en: The interrupt routine completes and returns control to line 407.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中断例程完成并将控制权返回到第407行。
- en: The instruction at line 407 adds 1 to register `r3` and sticks the result in
    `r2` (`r3` contains 3, `r2` contains 4).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第407行的指令将1加到寄存器`r3`并将结果存入`r2`（`r3`的值是3，`r2`的值是4）。
- en: Line 409 stores the value of `r2` into `nCharacters`, which should be 3, but
    it’s now 4.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第409行将`r2`的值存入`nCharacters`，它应该是3，但现在是4。
- en: At line 407, the program assumes that `r3` has the correct value of `nCharacters`,
    but it doesn’t.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第407行，程序假设`r3`具有正确的`nCharacters`值，但它没有。
- en: The register `r3` doesn’t have the correct value of `nCharacters` because an
    interrupt occurred at just the right time and the variable was modified. We failed
    to protect the consistency of shared data. The upper layer was modifying `nCharacters`
    while the lower layer was modifying it *at the same time*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器`r3`没有正确的`nCharacters`值，因为在恰当的时刻发生了中断，变量被修改了。我们未能保护共享数据的一致性。上层在修改`nCharacters`时，下层也在同时修改它*。
- en: If the interrupt occurs between some other instructions, the problem does not
    occur. This problem is random and happens infrequently, making it one of the more
    difficult problems to solve.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果中断发生在其他指令之间，这个问题不会发生。这个问题是随机的，发生得很少，因此是较难解决的问题之一。
- en: Fixing the Problem
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '解决问题  '
- en: 'The solution is to prevent the interrupt routine from modifying `nCharacters`
    while we are modifying it. To do that, we turn off interrupts before the increment
    and turn them on afterward:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '解决方案是防止中断例程在我们修改`nCharacters`时进行修改。为此，我们在增加之前关闭中断，之后再开启它们：  '
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Keep the amount of time interrupts are turned off short. If interrupts are turned
    off for a long period of time, you might miss an interrupt and drop data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '保持中断关闭的时间尽可能短。如果中断关闭时间过长，可能会错过一个中断并丢失数据。  '
- en: 'In the interrupt routine, we decrement `nCharacters`, so don’t we need to protect
    that with a `__disable_irq` and an `__enable_irq`? We don’t, because when an interrupt
    occurs, the system automatically performs the following steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '在中断例程中，我们减少了`nCharacters`，那么我们不需要用`__disable_irq`和`__enable_irq`来保护它吗？我们不需要，因为当发生中断时，系统会自动执行以下步骤：  '
- en: It disables interrupts for this level interrupt and lower. Higher-level interrupts
    can interrupt our interrupt routine, but lower ones cannot.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '它禁用该级别及以下的中断。更高级别的中断可以打断我们的中断例程，但较低级别的中断不能。  '
- en: It saves the state of the machine, including all general-purpose registers and
    status registers.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '它保存了机器的状态，包括所有通用寄存器和状态寄存器。  '
- en: It calls the interrupt function.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '它调用中断函数。  '
- en: 'When the interrupt routine returns, the system then performs these steps:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '当中断例程返回时，系统会执行以下步骤：  '
- en: It restores the state of the machine.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '它恢复机器的状态。  '
- en: It turns the interrupts back on.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '它重新开启中断。  '
- en: It returns control to the upper-level code.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '它将控制权返回给上层代码。  '
- en: A lot of bookkeeping needs to be done at the start and end of an interrupt routine.
    Fortunately, the designers of the ARM processor family decided to do it all in
    hardware. Other processors may not be so nice.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '在中断例程的开始和结束，需要做很多记录工作。幸运的是，ARM处理器系列的设计者决定在硬件中完成这一切。其他处理器可能没有这么友好。  '
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '概述  '
- en: Interrupts allow you to respond to input and output requests in real time. They
    also allow you to screw up your program in strange and random ways. Be sure to
    keep interrupt routines and code that accesses shared data as simple and clear
    as possible. Spending extra time making sure that interrupt-related code is written
    properly will save you a tremendous amount of debugging time later.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '中断使你能够实时响应输入和输出请求。它们也允许你以奇怪和随机的方式弄乱你的程序。务必保持中断例程和访问共享数据的代码尽可能简单和清晰。花额外的时间确保中断相关代码编写正确，后续会节省大量调试时间。  '
- en: Programming Problems
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '编程问题  '
- en: Create an interrupt routine that reads characters from the serial port.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个中断例程，从串行端口读取字符。  '
- en: Add an interrupt routine to service a button push and change the message when
    it occurs.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '添加一个中断例程来处理按钮按下事件，并在发生时更改消息。  '
- en: Browse the HAL library and find out how `__disable_irq` is implemented.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '浏览HAL库，找出`__disable_irq`是如何实现的。  '
