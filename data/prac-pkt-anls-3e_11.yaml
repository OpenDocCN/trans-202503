- en: '**11**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: '**FIGHTING A SLOW NETWORK**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**对抗慢速网络**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: As a network administrator, much of your time will be spent fixing computers
    and services that are running slower than they should be. But just because someone
    says that the network is running slowly doesn’t mean that the network is to blame.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网络管理员，您大部分时间都会花在修复运行速度慢的计算机和服务上。但仅仅因为有人说网络运行缓慢，并不意味着网络就是问题的根源。
- en: Before you begin to tackle a slow network, you first need to determine whether
    the network is in fact running slowly. You’ll learn how to do that in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始解决慢速网络问题之前，您首先需要确定网络是否确实运行缓慢。您将在本章中学习如何做到这一点。
- en: We’ll begin by discussing the error-recovery and flow-control features of TCP.
    Then we’ll explore how to detect the source of slowness on a network. Finally,
    we’ll look at ways of baselining networks and the devices and services that run
    on them. Once you have completed this chapter, you should be much better equipped
    to identify, diagnose, and troubleshoot slow networks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论TCP的错误恢复和流控制功能。接着我们将探讨如何检测网络上的慢速来源。最后，我们将研究如何基准测试网络以及运行在其上的设备和服务。完成本章后，您将更好地准备识别、诊断和排除慢速网络问题。
- en: '**NOTE**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Multiple techniques can be used to troubleshoot slow networks. I’ve chosen
    to focus primarily on TCP because most of the time, it is all you’ll have to work
    with. TCP allows you to perform passive retrospective analysis rather than generate
    additional traffic (unlike ICMP).*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*有多种技术可以用于排查慢速网络问题。我选择主要聚焦于TCP，因为大多数时候，它是您可以使用的唯一工具。TCP允许您进行被动回顾性分析，而无需生成额外的流量（与ICMP不同）。*'
- en: '**TCP Error-Recovery Features**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**TCP 错误恢复特性**'
- en: TCP’s error-recovery features are our best tools for locating, diagnosing, and
    eventually repairing high latency on a network. In terms of computer networking,
    *latency* is a measure of delay between a packet’s transmission and its receipt.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: TCP的错误恢复特性是我们定位、诊断并最终修复网络高延迟的最佳工具。在计算机网络中，*延迟*是指数据包传输和接收之间的延迟时间。
- en: Latency can be measured as one-way (from a single source to a destination) or
    as round-trip (from a source to a destination and back to the original source).
    When communication between devices is fast, and the amount of time it takes a
    packet to get from one point to another is low, the communication is said to have
    *low latency*. Conversely, when packets take a significant amount of time to travel
    between a source and destination, the communication is said to have *high latency*.
    High latency is the number one enemy of all network administrators who value their
    sanity (and their jobs).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟可以以单程（从单一来源到目的地）或往返（从来源到目的地再返回到原始来源）来衡量。当设备之间的通信速度快，数据包从一个点传输到另一个点的时间较短时，通信被认为是*低延迟*的。相反，当数据包在源和目的地之间传输所需时间较长时，通信被认为是*高延迟*的。高延迟是所有网络管理员的头号敌人，尤其是那些珍惜自己理智（和工作）的管理员。
- en: In [Chapter 8](ch08.xhtml#ch08), we discussed how TCP uses sequence and acknowledgment
    numbers to ensure the reliable delivery of packets. In this chapter, we’ll look
    at sequence and acknowledgment numbers again to see how TCP responds when high
    latency causes these numbers to be received out of sequence (or not received at
    all).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.xhtml#ch08)中，我们讨论了TCP如何使用序列号和确认号来确保数据包的可靠传输。在本章中，我们将再次查看序列号和确认号，了解当高延迟导致这些数字按顺序接收（或根本没有接收）时，TCP是如何响应的。
- en: '***TCP Retransmissions***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***TCP 重传***'
- en: '*tcp_retransmissions.pcapng*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcp_retransmissions.pcapng*'
- en: The ability of a host to retransmit packets is one of TCP’s most fundamental
    error-recovery features. It is designed to combat packet loss.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 主机重新传输数据包的能力是TCP最基本的错误恢复特性之一。它旨在应对数据包丢失问题。
- en: There are many possible causes of packet loss, including malfunctioning applications,
    routers under a heavy traffic load, or temporary service outages. Things move
    fast at the packet level, and often the packet loss is temporary, so it’s crucial
    for TCP to be able to detect and recover from packet loss.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包丢失的原因有很多种，包括应用程序故障、路由器负载过重或临时服务中断。在数据包层面，事情发生得非常快，而且数据包丢失通常是暂时的，因此TCP能够检测并恢复数据包丢失至关重要。
- en: The primary mechanism for determining whether the retransmission of a packet
    is necessary is the *retransmission timer*. This timer is responsible for maintaining
    a value called the *retransmission timeout (RTO)*. Whenever a packet is transmitted
    using TCP, the retransmission timer starts. This timer stops when an ACK for that
    packet is received. The time between the packet transmission and receipt of the
    ACK packet is called the *round-trip time (RTT)*. Several of these times are averaged,
    and that average is used to determine the final RTO value.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 确定是否需要重传数据包的主要机制是 *重传计时器*。该计时器负责维护一个名为 *重传超时（RTO）* 的值。每当使用 TCP 发送数据包时，重传计时器会启动。当该数据包的
    ACK 被接收到时，计时器停止。数据包传输和接收 ACK 数据包之间的时间称为 *往返时间（RTT）*。这些时间的平均值会被用来确定最终的 RTO 值。
- en: Until an RTO value is determined, the transmitting operating system relies on
    its default configured RTT setting, which is issued for the initial communication
    between hosts. This is then adjusted based on the RTT of received packets to determine
    the RTO value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定 RTO 值之前，发送操作系统依赖其默认配置的 RTT 设置，该设置用于主机间的初始通信。然后，这个值会根据接收数据包的 RTT 进行调整，以确定最终的
    RTO 值。
- en: Once the RTO value has been determined, the retransmission timer is used on
    every transmitted packet to determine whether packet loss has occurred. [Figure
    11-1](ch11.xhtml#ch11fig1) illustrates the TCP retransmission process.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 RTO 值确定，重传计时器就会在每个传输的数据包上使用，以确定是否发生了数据包丢失。[图 11-1](ch11.xhtml#ch11fig1)展示了
    TCP 重传过程。
- en: '![image](../images/f233-01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f233-01.jpg)'
- en: '*Figure 11-1: Conceptual view of the TCP retransmission process*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：TCP 重传过程的概念视图*'
- en: When a packet is sent, but the recipient has not sent back a TCP ACK packet,
    the transmitting host assumes that the original packet was lost and retransmits
    the original packet. When the retransmission is sent, the RTO value is doubled;
    if no ACK packet is received before that value is reached, another retransmission
    will occur. If this retransmission also does not receive an ACK response, the
    RTO value is doubled again. This process will continue, with the RTO value being
    doubled for each retransmission, until an ACK packet is received or until the
    sender reaches the maximum number of retransmission attempts it is configured
    to send. More details about this process are described in RFC6298.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数据包发送出去，但接收方没有返回 TCP ACK 数据包时，发送主机会假设原始数据包丢失，并重新发送该数据包。当重传被发送时，RTO 值会加倍；如果在达到该值之前没有收到
    ACK 数据包，就会发生另一轮重传。如果这次重传仍然没有收到 ACK 响应，RTO 值会再次加倍。这个过程会继续进行，每次重传时 RTO 值都会加倍，直到收到
    ACK 数据包或发送方达到它配置的最大重传次数为止。关于这个过程的更多细节可以参考 RFC6298。
- en: The maximum number of retransmission attempts depends on the value configured
    in the transmitting operating system. By default, Windows hosts make a maximum
    of five retransmission attempts. Most Linux hosts default to a maximum of 15 attempts.
    This option is configurable in either operating system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的重传尝试次数取决于发送操作系统中配置的值。默认情况下，Windows 主机会进行最多五次重传尝试。大多数 Linux 主机默认最大重传尝试次数为
    15 次。这个选项在两个操作系统中都可以进行配置。
- en: For an example of TCP retransmission, open the file *tcp_retransmissions.pcapng*,
    which contains six packets. The first packet is shown in [Figure 11-2](ch11.xhtml#ch11fig2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 TCP 重传的一个示例，打开文件 *tcp_retransmissions.pcapng*，该文件包含六个数据包。第一个数据包如[图 11-2](ch11.xhtml#ch11fig2)所示。
- en: '![image](../images/f234-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f234-01.jpg)'
- en: '*Figure 11-2: A simple TCP packet containing data*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2：包含数据的简单 TCP 数据包*'
- en: This packet is a TCP PSH/ACK packet ➋ containing 648 bytes of data ➌ that are
    sent from 10.3.30.1 to 10.3.71.7 ➊. This is a typical data packet.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据包是一个 TCP PSH/ACK 数据包 ➋，包含 648 字节的数据 ➌，从 10.3.30.1 发送到 10.3.71.7 ➊。这是一个典型的数据包。
- en: Under normal circumstances, you would expect to see a TCP ACK packet in response
    fairly soon after the first packet is sent. In this case, however, the next packet
    is a retransmission. You can tell this by looking at the packet in the Packet
    List pane. The Info column will clearly say `[TCP Retransmission]`, and the packet
    will appear with red text on a black background. [Figure 11-3](ch11.xhtml#ch11fig3)
    shows examples of retransmissions listed in the Packet List pane.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，你可以期望在发送第一个数据包后不久看到一个TCP ACK数据包作为响应。然而，在这种情况下，下一个数据包是重传。你可以通过查看数据包列表窗格中的数据包来判断这一点。信息列会清楚地显示`[TCP
    Retransmission]`，并且数据包会以红色文本显示在黑色背景上。[图11-3](ch11.xhtml#ch11fig3)显示了数据包列表窗格中列出的重传示例。
- en: '![image](../images/f234-02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f234-02.jpg)'
- en: '*Figure 11-3: Retransmissions in the Packet List pane*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-3：数据包列表窗格中的重传*'
- en: You can also determine whether a packet is a retransmission by examining it
    in the Packet Details pane, as shown in [Figure 11-4](ch11.xhtml#ch11fig4).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在数据包详细信息窗格中检查数据包，来判断它是否为重传，如[图11-4](ch11.xhtml#ch11fig4)所示。
- en: In the Packet Details pane, notice that the retransmission packet has some additional
    information included under the SEQ/ACK analysis heading ➊. This useful information
    is provided by Wireshark and is not contained in the packet itself. The SEQ/ACK
    analysis tells us that this is indeed a retransmission ➋, that the RTO value is
    0.206 seconds ➌, and that the RTO is based on the delta time from packet 1 ➍.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据包详细信息窗格中，可以看到重传的数据包在SEQ/ACK分析标题下有一些附加信息 ➊。此有用信息由Wireshark提供，而不包含在数据包本身中。SEQ/ACK分析告诉我们，这确实是一个重传
    ➋，RTO值为0.206秒 ➌，并且RTO是基于数据包1的时间差 ➍。
- en: '![image](../images/f235-01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f235-01.jpg)'
- en: '*Figure 11-4: An individual retransmission packet*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-4：单个重传数据包*'
- en: Note that this packet is the same as the original packet (other than the IP
    identification and Checksum fields). To verify this, compare the Packet Bytes
    pane of this retransmitted packet with the original one.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此数据包与原始数据包相同（除了IP标识符和校验和字段）。为验证这一点，比较此重传数据包与原始数据包的“数据包字节”窗格。
- en: Examination of the remaining packets should yield similar results, with the
    only differences between the packets found in the IP identification and Checksum
    fields and in the RTO value. To visualize the time lapse between each packet,
    look at the Time column in the Packet List pane, as shown in [Figure 11-5](ch11.xhtml#ch11fig5).
    Here, you see exponential growth in time as the RTO value is doubled after each
    retransmission.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 检查其余的数据包应得出类似的结果，数据包之间的唯一差异存在于IP标识符、校验和字段和RTO值中。要查看每个数据包之间的时间间隔，请查看数据包列表窗格中的时间列，如[图11-5](ch11.xhtml#ch11fig5)所示。在这里，你可以看到随着每次重传，RTO值的指数增长。
- en: The TCP retransmission feature is used by the transmitting device to detect
    and recover from packet loss. Next, we’ll examine *TCP duplicate acknowledgments*,
    a feature that the data recipient uses to detect and recover from packet loss.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: TCP重传功能被发送设备用于检测和恢复丢包。接下来，我们将探讨*TCP重复确认*功能，这是数据接收方用来检测和恢复丢包的一项特性。
- en: '![image](../images/f235-02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f235-02.jpg)'
- en: '*Figure 11-5: The Time column shows the increase in RTO value.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-5：时间列显示RTO值的增加。*'
- en: '***TCP Duplicate Acknowledgments and Fast Retransmissions***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***TCP重复确认与快速重传***'
- en: '*tcp_dupack.pcapng*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcp_dupack.pcapng*'
- en: A duplicate ACK is a TCP packet sent from a recipient when that recipient receives
    packets that are out of order. TCP uses the sequence and acknowledgment number
    fields within its header to reliably ensure that data is received and reassembled
    in the same order in which it was sent.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重复ACK是接收方在接收到乱序的数据包时发送的TCP数据包。TCP使用其头部中的序列号和确认号字段，可靠地确保数据按照发送的顺序接收并重新组装。
- en: '**NOTE**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The proper term for a TCP packet is actually* TCP segment*, but most people
    refer to it as a packet.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*TCP数据包的正确术语实际上是* TCP段*，但大多数人称其为数据包。*'
- en: When a new TCP connection is established, one of the most important pieces of
    information exchanged during the handshake process is an initial sequence number
    (ISN). Once the ISN is set for each side of the connection, each subsequently
    transmitted packet increments the sequence number by the size of its data payload.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当建立一个新的TCP连接时，握手过程中交换的最重要的信息之一是初始序列号（ISN）。一旦为连接的每一端设置了ISN，每个随后传输的包都会根据其数据负载的大小递增序列号。
- en: 'Consider a host that has an ISN of 5000 and sends a 500-byte packet to a recipient.
    Once this packet has been received, the recipient host will respond with a TCP
    ACK packet with an acknowledgment number of 5500, based on the following formula:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个ISN为5000的主机，它向接收方发送一个500字节的数据包。一旦这个数据包被接收，接收方主机将以确认号5500响应一个TCP确认包，基于以下公式：
- en: '*Sequence Number In* + *Bytes of Data Received* = *Acknowledgment Number Out*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列号输入* + *接收的数据字节* = *确认号输出*'
- en: As a result of this calculation, the acknowledgment number returned to the transmitting
    host is the next sequence number that the recipient expects to receive. An example
    of this can be seen in [Figure 11-6](ch11.xhtml#ch11fig6).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个计算，返回给发送主机的确认号是接收方预计接收的下一个序列号。这个例子可以在[图11-6](ch11.xhtml#ch11fig6)中看到。
- en: '![image](../images/f236-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f236-01.jpg)'
- en: '*Figure 11-6: TCP sequence and acknowledgment numbers*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-6：TCP序列号和确认号*'
- en: The detection of packet loss by the data recipient is made possible through
    the sequence numbers. As the recipient tracks the sequence numbers it is receiving,
    it can determine when it receives sequence numbers that are out of order.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 数据接收方通过序列号检测数据包丢失的能力。随着接收方跟踪接收到的序列号，它可以判断何时收到的序列号是乱序的。
- en: When the recipient receives an unexpected sequence number, it assumes that a
    packet has been lost in transit. To reassemble data properly, the recipient must
    have the missing packet, so it resends the ACK packet that contains the lost packet’s
    expected sequence number in order to elicit a retransmission of that packet from
    the transmitting host.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收方收到一个意外的序列号时，它会认为数据包在传输过程中丢失了。为了正确地重新组装数据，接收方必须拥有丢失的数据包，因此它会重新发送包含丢失数据包预期序列号的确认包，以便从发送主机请求重新传输该数据包。
- en: When the transmitting host receives three duplicate ACKs from the recipient,
    it assumes that the packet was indeed lost in transit and immediately sends a
    *fast retransmission*. Once a fast retransmission is triggered, all other packets
    being transmitted are queued until the fast retransmission packet is sent. This
    process is depicted in [Figure 11-7](ch11.xhtml#ch11fig7).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送主机收到接收方的三个重复确认包时，它会认为数据包确实在传输过程中丢失，并立即发送一个*快速重传*。一旦触发快速重传，所有其他正在传输的数据包都会被排队，直到快速重传的数据包发送完毕。这个过程在[图11-7](ch11.xhtml#ch11fig7)中有所展示。
- en: '![image](../images/f237-01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f237-01.jpg)'
- en: '*Figure 11-7: Duplicate ACKs from the recipient result in a fast retransmission.*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-7：接收方的重复确认包导致快速重传。*'
- en: You’ll find an example of duplicate ACKs and fast retransmissions in the file
    *tcp_dupack.pcapng*. The first packet in this capture is shown in [Figure 11-8](ch11.xhtml#ch11fig8).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件*tcp_dupack.pcapng*中，你可以找到重复确认包和快速重传的示例。此捕获中的第一个数据包显示在[图11-8](ch11.xhtml#ch11fig8)中。
- en: '![image](../images/f237-02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f237-02.jpg)'
- en: '*Figure 11-8: The ACK showing the next expected sequence number*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-8：显示下一个预期序列号的确认包*'
- en: This packet, a TCP ACK sent from the data recipient (172.31.136.85) to the transmitter
    (195.81.202.68) ➊, has an acknowledgment of the data sent in the previous packet
    that is not included in this capture file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据包，一个从数据接收方（172.31.136.85）到发送方（195.81.202.68）发送的TCP确认包 ➊，包含对前一个数据包中发送的数据的确认，这些数据不包含在此捕获文件中。
- en: '**NOTE**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*By default, Wireshark uses relative sequence numbers to make the analysis
    of these numbers easier, but the examples and screenshots in the next few sections
    do not use this feature. To turn off this feature, select* ***Edit ▶ Preferences****.
    In the Preferences window, select* ***Protocols*** *and then the* ***TCP*** *section.
    Then uncheck the box next to* ***Relative sequence numbers***.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*默认情况下，Wireshark使用相对序列号使得这些数字的分析更加容易，但接下来的几个部分中的示例和截图并未使用此功能。要关闭此功能，请选择* ***编辑
    ▶ 首选项***。在首选项窗口中，选择* ***协议***，然后选择* ***TCP*** *部分。然后取消选中* ***相对序列号*** *旁边的复选框。*'
- en: The acknowledgment number in this packet is 1310973186 ➋. This should match
    the sequence number in the next packet received, as shown in [Figure 11-9](ch11.xhtml#ch11fig9).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据包中的确认号是1310973186 ➋。它应该与接收到的下一个数据包中的序列号相匹配，如[图11-9](ch11.xhtml#ch11fig9)所示。
- en: '![image](../images/f238-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f238-01.jpg)'
- en: '*Figure 11-9: The sequence number of this packet is not what was expected.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-9：这个数据包的序列号不是预期的序列号。*'
- en: Unfortunately for us and our recipient, the sequence number of the next packet
    is 1310984130 ➊, which is not what we expect. This out-of-order packet indicates
    that the expected packet was somehow lost in transit. The recipient host notices
    that this packet is out of sequence and sends a duplicate ACK in the third packet
    of this capture, as shown in [Figure 11-10](ch11.xhtml#ch11fig10).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于我们和接收方来说，下一个数据包的序列号是 1310984130 ➊，这不是我们预期的。这一错乱的数据包表明预期的数据包在传输过程中丢失了。接收主机注意到该数据包顺序错乱，并在本次捕获的第三个数据包中发送了一个重复
    ACK，如[图 11-10](ch11.xhtml#ch11fig10)所示。
- en: 'You can determine that this is a duplicate ACK packet by examining either of
    the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下任意一种方式来确定这是一个重复 ACK 数据包：
- en: •     The Info column in the Packet Details pane. The packet should appear as
    red text on a black background.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: •     数据包详情窗格中的“信息”列。该数据包应该以红色文本显示在黑色背景上。
- en: •     The Packet Details pane under the SEQ/ACK analysis heading ([Figure 11-10](ch11.xhtml#ch11fig10)).
    If you expand this heading, you’ll find that the packet is listed as a duplicate
    ACK of packet 1 ➊.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: •     SEQ/ACK 分析标题下的数据包详情窗格（[图 11-10](ch11.xhtml#ch11fig10)）。如果展开该标题，你会发现该数据包被列为数据包
    1 ➊ 的重复 ACK。
- en: '![image](../images/f239-01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f239-01.jpg)'
- en: '*Figure 11-10: The first duplicate ACK packet*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-10：第一个重复 ACK 数据包*'
- en: The next several packets continue this process, as shown in [Figure 11-11](ch11.xhtml#ch11fig11).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个数据包继续这个过程，如[图 11-11](ch11.xhtml#ch11fig11)所示。
- en: '![image](../images/f239-02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f239-02.jpg)'
- en: '*Figure 11-11: Additional duplicate ACKs are generated due to out-of-order
    packets.*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-11：由于数据包顺序错乱，产生了额外的重复 ACK。*'
- en: The fourth packet in the capture file is another chunk of data sent from the
    transmitting host with the wrong sequence number ➊. As a result, the recipient
    host sends its second duplicate ACK ➋. One more packet with the wrong sequence
    number is received by the recipient ➌. That prompts the transmission of the third
    and final duplicate ACK ➍.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获文件中的第四个数据包是另一个从发送主机发送的带有错误序列号 ➊的数据块。因此，接收主机发送了第二个重复 ACK ➋。接收主机又接收到一个带有错误序列号的数据包
    ➌，这导致它发送了第三个也是最后一个重复 ACK ➍。
- en: As soon as the transmitting host receives the third duplicate ACK from the recipient,
    it is forced to halt all packet transmission and resend the lost packet. [Figure
    11-12](ch11.xhtml#ch11fig12) shows the fast retransmission of the lost packet.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发送方主机接收到收件方的第三个重复 ACK，它必须停止所有数据包传输并重新发送丢失的数据包。[图 11-12](ch11.xhtml#ch11fig12)展示了丢失数据包的快速重传。
- en: The retransmission packet can once again be found through the Info column in
    the Packet List pane. As with previous examples, the packet is clearly labeled
    with red text on a black background. The SEQ/ACK analysis section of this packet
    ([Figure 11-12](ch11.xhtml#ch11fig12)) tells us that this is suspected to be a
    fast retransmission ➊. (Again, the information that labels this packet as a fast
    retransmission is not a value set in the packet itself but rather a feature of
    Wireshark.) The final packet in the capture is an ACK packet acknowledging receipt
    of the fast retransmission.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过数据包列表窗格中的信息列，你可以再次找到重传的数据包。与之前的示例一样，该数据包明确标注为红色文本显示在黑色背景上。该数据包的 SEQ/ACK 分析部分（[图
    11-12](ch11.xhtml#ch11fig12)）告诉我们这是一个疑似的快速重传 ➊。（再次说明，标记此数据包为快速重传的信息并非数据包本身设置的值，而是
    Wireshark 的一项特性。）捕获中的最后一个数据包是一个 ACK 数据包，确认已收到快速重传的数据包。
- en: '![image](../images/f240-01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f240-01.jpg)'
- en: '*Figure 11-12: Three duplicate ACKs cause this fast retransmission of the lost
    packet.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-12：三个重复 ACK 导致了该丢失数据包的快速重传。*'
- en: '**NOTE**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*One feature to consider that may affect the flow of data in TCP communications
    in which packet loss is present is the Selective Acknowledgment feature. In the
    packet capture we just examined, Selective ACK was negotiated as an enabled feature
    during the initial three-way handshake process. As a result, whenever a packet
    is lost and a duplicate ACK received, only the lost packet has to be retransmitted,
    even though other packets were received successfully after the lost packet. Had
    Selective ACK not been enabled, every packet occurring after the lost packet would
    have had to be retransmitted as well. Selective ACK makes data loss recovery much
    more efficient. Because most modern TCP/IP stack implementations support Selective
    ACK, you will find that this feature is usually implemented.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*在TCP通信中，当出现丢包时，可能影响数据流动的一个特点是选择性确认（Selective Acknowledgment）功能。在我们刚刚检查的包捕获中，选择性确认在初始的三次握手过程中被协商为启用的功能。因此，每当发生丢包并收到重复确认时，只有丢失的数据包需要重新传输，即使在丢失的数据包之后，其他数据包已经成功接收。如果没有启用选择性确认，丢失数据包之后的每个数据包都需要重新传输。选择性确认使得数据丢失恢复更加高效。由于大多数现代TCP/IP协议栈实现都支持选择性确认，因此你会发现这一功能通常是已实现的。*'
- en: '**TCP Flow Control**'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**TCP流量控制**'
- en: Retransmissions and duplicate ACKs are reactive TCP functions designed to recover
    from packet loss. TCP would be a poor protocol indeed if it didn’t include some
    form of proactive method for preventing packet loss.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 重新传输和重复确认是TCP的反应式功能，旨在从丢包中恢复。如果TCP没有包含某种形式的主动方法来防止丢包，它将是一个非常糟糕的协议。
- en: TCP implements a *sliding-window mechanism* to detect when packet loss may occur
    and adjust the rate of data transmission to prevent it. The sliding-window mechanism
    leverages the data recipient’s *receive window* to control the flow of data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: TCP实现了一个*滑动窗口机制*，用于检测何时可能发生丢包，并调整数据传输速率以防止丢包。滑动窗口机制利用数据接收方的*接收窗口*来控制数据流。
- en: The receive window is a value specified by the data recipient and stored in
    the TCP header (in bytes) that tells the transmitting device how much data the
    recipient is willing to store in its *TCP buffer space*. This buffer space is
    where data is stored temporarily until it can be passed up the stack to the application-layer
    protocol waiting to process it. As a result, the transmitting host can send only
    the amount of data specified in the Window size value field at one time. For the
    transmitter to send more data, the recipient must send an acknowledgment that
    the previous data was received. It also must clear TCP buffer space by processing
    the data that is occupying that position. [Figure 11-13](ch11.xhtml#ch11fig13)
    illustrates how the receive window works.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接收窗口是由数据接收方指定并存储在TCP头部（以字节为单位）的一个值，告知发送设备接收方愿意在其*TCP缓冲区空间*中存储多少数据。这个缓冲区空间是数据暂时存储的地方，直到它可以被传递到栈上等待处理的应用层协议。因此，发送方一次只能发送接收方在窗口大小字段中指定的数量的数据。为了让发送方发送更多数据，接收方必须发送确认，表示先前的数据已经接收。同时，它还必须通过处理占用该位置的数据来清理TCP缓冲区空间。[图11-13](ch11.xhtml#ch11fig13)说明了接收窗口的工作原理。
- en: '![image](../images/f241-01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f241-01.jpg)'
- en: '*Figure 11-13: The receive window keeps the data recipient from getting overwhelmed.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-13：接收窗口防止数据接收方被淹没。*'
- en: In [Figure 11-13](ch11.xhtml#ch11fig13), the client is sending data to a server
    that has communicated a receive window size of 5,000 bytes. The client sends 2,500
    bytes, reducing the server’s buffer space to 2,500 bytes, and then sends another
    2,000 bytes, further reducing the buffer to 500 bytes. The server sends an acknowledgment
    of this data, and after it processes the data in its buffer, it again has an empty
    buffer available. This process repeats, with the client sending 3,000 bytes and
    another 1,000 bytes, reducing the server’s buffer to 1,000 bytes. The client once
    more acknowledges this data and processes the contents of its buffer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图11-13](ch11.xhtml#ch11fig13)中，客户端正在向服务器发送数据，服务器已传达接收窗口大小为5,000字节。客户端发送了2,500字节，减少了服务器的缓冲区空间至2,500字节，然后又发送了2,000字节，进一步将缓冲区减少至500字节。服务器对此数据发送了确认，并在处理完缓冲区中的数据后，缓冲区变为空。这个过程会重复，客户端发送3,000字节和另外1,000字节，减少服务器缓冲区至1,000字节。客户端再次确认这些数据并处理缓冲区中的内容。
- en: '***Adjusting the Window Size***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调整窗口大小***'
- en: This process of adjusting the window size is fairly clear-cut, but it isn’t
    always perfect. Whenever data is received by the TCP stack, an acknowledgment
    is generated and sent in reply, but the data placed in the recipient’s buffer
    is not always processed immediately.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 调整窗口大小的过程相当直接，但并不总是完美的。每当TCP栈接收到数据时，都会生成并发送一个确认响应，但并不是所有放入接收方缓冲区的数据都会立即被处理。
- en: When a busy server is processing packets from multiple clients, it could quite
    possibly be slow in clearing its buffer and thus be unable to make room for new
    data. Without a means of flow control, a full buffer could lead to lost packets
    and data corruption. Fortunately, when a server becomes too busy to process data
    at the rate its receive window is advertising, it can adjust the size of the window.
    It does this by decreasing the window size value in the TCP header of the ACK
    packet it is sending back to the hosts that are sending it data. [Figure 11-14](ch11.xhtml#ch11fig14)
    shows an example of this.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当一台繁忙的服务器正在处理来自多个客户端的数据包时，它很可能在清空其缓冲区时变得缓慢，从而无法为新数据腾出空间。如果没有流量控制机制，缓冲区满了可能会导致数据包丢失和数据损坏。幸运的是，当服务器变得过于繁忙，无法按照其接收窗口所广告的速率处理数据时，它可以调整窗口大小。它通过减少在返回给发送数据的主机的ACK数据包中的TCP头部窗口大小值来做到这一点。[图11-14](ch11.xhtml#ch11fig14)展示了这一过程的示例。
- en: '![image](../images/f242-01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f242-01.jpg)'
- en: '*Figure 11-14: The window size can be adjusted when the server becomes busy.*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-14：当服务器变得繁忙时，窗口大小可以调整。*'
- en: In [Figure 11-14](ch11.xhtml#ch11fig14), the server starts with an advertised
    window size of 5,000 bytes. The client sends 2,000 bytes, followed by another
    2,000 bytes, leaving only 1,000 bytes of buffer space available. The server realizes
    that its buffer is filling up quickly and knows that if data transfer keeps up
    at this rate, packets will soon be lost. To avoid such a mishap, the server sends
    an acknowledgment to the client with an updated window size of 1,000 bytes. The
    client responds by sending less data, and now the rate at which the server can
    process its buffer contents allows data to flow in a constant manner.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图11-14](ch11.xhtml#ch11fig14)中，服务器开始时的广告窗口大小为5000字节。客户端发送了2000字节，然后又发送了2000字节，剩下的缓冲区空间只有1000字节。服务器意识到其缓冲区正在快速填满，并知道如果数据传输以此速度继续进行，数据包很快就会丢失。为了避免这种意外，服务器向客户端发送了一个更新后的窗口大小为1000字节的确认数据包。客户端通过发送较少的数据进行响应，现在服务器处理缓冲区内容的速率使得数据能够以稳定的方式流入。
- en: The resizing process works both ways. When the server can process data at a
    faster rate, it can send an ACK packet with a larger window size.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口大小调整的过程是双向的。当服务器可以以更快的速率处理数据时，它可以发送一个带有更大窗口大小的ACK数据包。
- en: '***Halting Data Flow with a Zero Window Notification***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过零窗口通知停止数据流***'
- en: Due to a lack of memory, a lack of processing capability, or another problem,
    a server may no longer process data sent from a client. Such a stoppage could
    result in dropped packets and a halting of the communication process, but the
    receive window can minimize negative effects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内存不足、处理能力不足或其他问题，服务器可能不再处理来自客户端的数据。这种停止可能导致数据包丢失并中断通信过程，但接收窗口可以最小化负面影响。
- en: When this situation arises, a server can send a packet that contains a window
    size of zero. When the client receives this packet, it will halt any data transmission
    but will sometimes keep the connection to the server open with the transmission
    of *keep-alive packets*. Keep-alive packets can be sent by the client at regular
    intervals to check the status of the server’s receive window. Once the server
    can begin processing data again, it will respond with a nonzero window size, and
    communication will resume. [Figure 11-15](ch11.xhtml#ch11fig15) illustrates an
    example of zero window notification.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，服务器可以发送一个包含零窗口大小的数据包。当客户端接收到此数据包时，它会停止所有数据传输，但有时会保持与服务器的连接，通过传输*保持连接数据包*。客户端可以定期发送保持连接数据包，以检查服务器接收窗口的状态。一旦服务器可以再次开始处理数据，它将以非零窗口大小响应，通信将恢复。[图11-15](ch11.xhtml#ch11fig15)展示了零窗口通知的示例。
- en: '![image](../images/f243-01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f243-01.jpg)'
- en: '*Figure 11-15: Data transfer stops when the window size is set to 0 bytes.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-15：当窗口大小设置为0字节时，数据传输停止。*'
- en: In [Figure 11-15](ch11.xhtml#ch11fig15), the server begins receiving data with
    a 5,000-byte window size. After receiving a total of 4,000 bytes of data from
    the client, the server begins experiencing a very heavy processor load, and it
    can no longer process any data from the client. The server then sends a packet
    with the Window size value field set to 0\. The client halts transmission of data
    and sends a keep-alive packet. After receiving the keep-alive packet, the server
    responds with a packet notifying the client that it can now receive data and that
    its window size is 1,000 bytes. The client resumes sending data but at a slower
    rate than before.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图11-15](ch11.xhtml#ch11fig15)中，服务器开始以5,000字节的窗口大小接收数据。在从客户端接收到总计4,000字节的数据后，服务器开始经历非常高的处理器负载，无法再处理来自客户端的任何数据。然后，服务器发送一个数据包，将窗口大小值字段设置为0。客户端停止发送数据，并发送一个保持连接的数据包。在接收到保持连接的数据包后，服务器回应一个数据包，通知客户端它现在可以接收数据，并且其窗口大小为1,000字节。客户端恢复发送数据，但速度比之前慢。
- en: '***The TCP Sliding Window in Practice***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实际中的TCP滑动窗口***'
- en: '*tcp_zerowindow recovery.pcapng tcp_zerowindow dead.pcapng*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcp_zerowindow recovery.pcapng tcp_zerowindow dead.pcapng*'
- en: Having covered the theory behind the TCP sliding window, we will now examine
    it in the capture file *tcp_zerowindowrecovery.pcapng*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在讲解完TCP滑动窗口的理论后，我们将开始检查捕获文件*tcp_zerowindowrecovery.pcapng*中的实际情况。
- en: In this file, we begin with several TCP ACK packets traveling from 192.168.0.20
    to 192.168.0.30\. The main value of interest to us is the Window size value field,
    which can be seen in both the Info column of the Packet List pane and in the TCP
    header in the Packet Details pane. You can see immediately that this field’s value
    decreases over the course of the first three packets, as shown in [Figure 11-16](ch11.xhtml#ch11fig16).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们首先看到几个从192.168.0.20发送到192.168.0.30的TCP ACK数据包。我们最关心的值是窗口大小值字段，可以在数据包列表窗格的“信息”列和数据包详细信息窗格中的TCP头部看到。你可以立即看到，这个字段的值在前三个数据包中逐渐减小，如[图11-16](ch11.xhtml#ch11fig16)所示。
- en: '![image](../images/f243-02.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f243-02.jpg)'
- en: '*Figure 11-16: The window size of these packets is decreasing.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-16：这些数据包的窗口大小正在减小。*'
- en: The window size value goes from 8,760 bytes in the first packet to 5,840 bytes
    in the second packet and then 2,920 bytes in the third packet ➋. This lowering
    of the window size value is a classic indicator of increased latency from the
    host. Notice in the Time column that this happens very quickly ➊. When the window
    size is lowered this fast, it’s common for the window size to drop to zero, which
    is exactly what happens in the fourth packet, as shown in [Figure 11-17](ch11.xhtml#ch11fig17).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口大小值从第一个数据包中的8,760字节下降到第二个数据包的5,840字节，再到第三个数据包的2,920字节 ➋。窗口大小值的下降是主机延迟增加的经典指示器。请注意，在“时间”列中，这一过程发生得非常迅速
    ➊。当窗口大小如此快速下降时，窗口大小通常会降到零，这正是第四个数据包中的情况，如[图11-17](ch11.xhtml#ch11fig17)所示。
- en: '![image](../images/f244-01.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f244-01.jpg)'
- en: '*Figure 11-17: This zero window packet says that the host cannot accept any
    more data.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-17：这个零窗口数据包表示主机无法再接收任何数据。*'
- en: The fourth packet is also being sent from 192.168.0.20 to 192.168.0.30, but
    its purpose is to tell 192.168.0.30 that it can no longer receive any data. The
    0 value is seen in the TCP header ➊. Wireshark also tells us that this is a zero
    window packet in the Info column of the Packet List pane and under the SEQ/ACK
    analysis section of the TCP header ➋.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个数据包也从192.168.0.20发送到192.168.0.30，但它的目的是告诉192.168.0.30，它已经无法再接收任何数据。TCP头部中看到的0值
    ➊。Wireshark还告诉我们，这是一个零窗口数据包，显示在数据包列表窗格的“信息”列和TCP头部的SEQ/ACK分析部分 ➋。
- en: Once this zero window packet is sent, the device at 192.168.0.30 will not send
    any more data until it receives a window update from 192.168.0.20 notifying it
    that the window size has increased. Luckily for us, the issue causing the zero
    window condition in this capture file was only temporary. So, a window update
    is sent in the next packet, shown in [Figure 11-18](ch11.xhtml#ch11fig18).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个零窗口数据包被发送，位于192.168.0.30的设备将不会再发送任何数据，直到它收到来自192.168.0.20的窗口更新，通知它窗口大小已经增大。幸运的是，这个捕获文件中的零窗口问题只是暂时的。因此，在下一个数据包中发送了一个窗口更新，如[图11-18](ch11.xhtml#ch11fig18)所示。
- en: In this case, the window size is increased to a very healthy 64,240 bytes ➊.
    Wireshark once again lets us know that this is a window update under the SEQ/ACK
    analysis heading.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，窗口大小增加到了一个非常健康的64,240字节 ➊。Wireshark再次告知我们，这是一个在SEQ/ACK分析标题下的窗口更新。
- en: Once the update packet is received, the host at 192.168.0.30 can begin sending
    data again, as it does in packets 6 and 7\. This entire period of halted data
    transmission takes place very quickly. Had it lasted only slightly longer, it
    could have caused a potential hiccup on the network, resulting in a slower or
    failed data transfer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更新包被接收，位于192.168.0.30的主机可以重新开始发送数据，就像在数据包6和7中所做的那样。整个数据传输暂停的过程发生得非常迅速。如果这一过程稍微长一点，它可能会导致网络出现潜在的卡顿，导致数据传输变慢或失败。
- en: '![image](../images/f245-01.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f245-01.jpg)'
- en: '*Figure 11-18: A TCP window update packet lets the other host know it can begin
    transmitting again.*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-18：TCP窗口更新数据包让另一台主机知道它可以重新开始传输。*'
- en: For one last look at the sliding window, examine *tcp_zerowindowdead.pcapng*.
    The first packet in this capture is normal HTTP traffic being sent from 195.81.202.68
    to 172.31.136.85\. The packet is immediately followed with a zero window packet
    sent back from 172.31.136.85, as shown in [Figure 11-19](ch11.xhtml#ch11fig19).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看滑动窗口，检查 *tcp_zerowindowdead.pcapng*。此捕获中的第一个数据包是从195.81.202.68发送到172.31.136.85的正常HTTP流量。该数据包后面紧跟着一个从172.31.136.85发送回来的零窗口数据包，如[图
    11-19](ch11.xhtml#ch11fig19)所示。
- en: '![image](../images/f245-02.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f245-02.jpg)'
- en: '*Figure 11-19: A zero window packet halts data transfer.*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-19：零窗口数据包暂停数据传输。*'
- en: This looks very similar to the zero window packet shown in [Figure 11-17](ch11.xhtml#ch11fig17),
    but the result is much different. Rather than seeing a window update from the
    172.31.136.85 host and the resumption of communication, we see a keep-alive packet,
    as shown in [Figure 11-20](ch11.xhtml#ch11fig20).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与[图 11-17](ch11.xhtml#ch11fig17)中显示的零窗口数据包非常相似，但结果却大不相同。我们没有看到来自172.31.136.85主机的窗口更新以及通信的恢复，而是看到一个保持连接的数据包，如[图
    11-20](ch11.xhtml#ch11fig20)所示。
- en: '![image](../images/f246-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f246-01.jpg)'
- en: '*Figure 11-20: This keep-alive packet ensures the zero window host is still
    alive.*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-20：该保持连接数据包确保零窗口主机仍然存活。*'
- en: This packet is marked as a keep-alive by Wireshark under the SEQ/ACK analysis
    section of the TCP header in the Packet Details pane ➊. The Time column tells
    us that this packet was sent 3.4 seconds after the last received packet. This
    process continues several more times, with one host sending a zero window packet
    and the other sending a keep-alive packet, as shown in [Figure 11-21](ch11.xhtml#ch11fig21).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据包在Wireshark中被标记为保持连接数据包，位于数据包详细信息面板的TCP头部SEQ/ACK分析部分 ➊。时间列显示该数据包是在收到上一个数据包后3.4秒发送的。这个过程还会继续几次，一台主机发送零窗口数据包，另一台主机发送保持连接数据包，如[图
    11-21](ch11.xhtml#ch11fig21)所示。
- en: '![image](../images/f246-02.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f246-02.jpg)'
- en: '*Figure 11-21: The host and client continue to send zero window and keep-alive
    packets, respectively.*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-21：主机和客户端继续分别发送零窗口和保持连接数据包。*'
- en: These keep-alive packets occur at intervals of 3.4, 6.8, and 13.5 seconds ➊.
    This process can go on for quite a long time, depending on the operating systems
    of the communicating devices. As you can see by adding up the values in the Time
    column, the connection is halted for nearly 25 seconds. Imagine attempting to
    authenticate with a domain controller or download a file from the internet while
    experiencing a 25-second delay—unacceptable!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些保持连接的数据包间隔为3.4秒、6.8秒和13.5秒 ➊。这个过程可以持续很长时间，具体取决于通信设备的操作系统。通过累加时间列中的值，可以看到连接被暂停了将近25秒。想象一下，在进行域控制器身份验证或从互联网下载文件时，经历25秒的延迟——这是无法接受的！
- en: '**Learning from TCP Error-Control and Flow-Control Packets**'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从TCP错误控制和流量控制数据包中学习**'
- en: Let’s put retransmission, duplicate ACKs, and the sliding-window mechanism into
    some context. Here are a few notes to keep in mind when troubleshooting latency
    issues.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将重传、重复ACK和滑动窗口机制放入一些背景中。在排查延迟问题时，记住以下几点。
- en: '**Retransmission Packets**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**重传数据包**'
- en: Retransmissions occur because the client has detected that the server is not
    receiving the data it’s sending. Therefore, depending on which side of the communication
    you are analyzing, you may never see retransmissions. If you are capturing data
    from the server, and it is truly not receiving the packets being sent and retransmitted
    from the client, you may be in the dark because you won’t see the retransmission
    packets. If you suspect that you are the victim of packet loss on the server side,
    consider attempting to capture traffic from the client (if possible) so that you
    can see whether retransmission packets are present.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重传发生是因为客户端检测到服务器没有接收到它发送的数据。因此，根据你分析的通信方，可能永远看不到重传。如果你从服务器端捕获数据，并且服务器确实没有接收到客户端发送并重传的数据包，你可能一无所知，因为你看不到重传的数据包。如果你怀疑自己在服务器端遭遇了数据包丢失，考虑尝试从客户端捕获流量（如果可能的话），这样你就可以看到是否存在重传数据包。
- en: '**Duplicate ACK Packets**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**重复ACK数据包**'
- en: I tend to think of a duplicate ACK as the pseudo-opposite of a retransmission,
    because it is sent when the server detects that a packet from the client it is
    communicating with was lost in transit. In most cases, you can see duplicate ACKs
    when capturing traffic on both sides of the communication. Remember that duplicate
    ACKs are triggered when packets are received out of sequence. For example, if
    the server received just the first and third of three packets sent, it would send
    a duplicate ACK to elicit a fast retransmission of the second packet from the
    client. Since you have received the first and third packets, it’s likely that
    whatever condition caused the second packet to be dropped was only temporary,
    so the duplicate ACK will likely be sent and received successfully. Of course,
    this scenario isn’t always the case, so when you suspect packet loss on the server
    side and don’t see any duplicate ACKs, consider capturing packets from the client
    side of the communication.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于将重复ACK视为重传的伪相反，因为它是在服务器检测到与之通信的客户端丢失数据包时发送的。在大多数情况下，你可以在捕获两端的流量时看到重复ACK。记住，重复ACK是在数据包按顺序接收时触发的。例如，如果服务器只接收到三包数据中的第一包和第三包，它会发送一个重复ACK，以促使客户端快速重传第二个数据包。由于已经接收到第一包和第三包，因此导致第二包丢失的条件很可能是暂时性的，因此重复ACK很可能会成功发送和接收。当然，这种情况并不总是如此，所以当你怀疑服务器端丢包并且没有看到任何重复ACK时，考虑从客户端侧捕获数据包。
- en: '**Zero Window and Keep-Alive Packets**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**零窗口和保持活动数据包**'
- en: The sliding window relates directly to the server’s inability to receive and
    process data. Any decrease in the window size or a zero window state is a direct
    result of some issue with the server, so if you see either occurring on the wire,
    you should focus your investigation there. You will typically see window update
    packets on both sides of network communications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动窗口直接与服务器无法接收和处理数据有关。窗口大小的任何减少或零窗口状态都是服务器存在问题的直接结果，因此，如果你在网络上传输中看到这些情况，你应该将调查重点放在那里。你通常会在网络通信的两端看到窗口更新数据包。
- en: '**Locating the Source of High Latency**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定位高延迟的来源**'
- en: In some cases, packet loss may not be the cause of latency. You may find that
    even though communications between two hosts are slow, that slowness doesn’t show
    the common symptoms of TCP retransmissions or duplicate ACKs. Thus, you need another
    technique to locate the source of the high latency.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，数据包丢失可能不是延迟的原因。你可能会发现，即使两个主机之间的通信很慢，这种慢速并没有显示出TCP重传或重复ACK的常见症状。因此，你需要使用其他技术来定位高延迟的来源。
- en: One of the most effective ways to find the source of high latency is to examine
    the initial connection handshake and the first couple of packets that follow it.
    For example, consider a simple connection between a client and a web server as
    the client attempts to browse a site hosted on the web server. We are concerned
    with the first six packets of this communication sequence, consisting of the TCP
    handshake, the initial HTTP `GET`   request, the acknowledgment of that `GET`
    request, and the first data packet sent from the server to the client.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 查找高延迟来源的一个有效方法是检查初始连接握手以及随后的前几个数据包。例如，考虑一个简单的客户端和Web服务器之间的连接，客户端尝试浏览托管在Web服务器上的网站。我们关心的是这次通信序列中的前六个数据包，包括TCP握手、初始HTTP
    `GET`请求、该`GET`请求的确认以及服务器发送到客户端的第一个数据包。
- en: '**NOTE**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To follow along with this section, ensure that you have the proper time display
    format set in Wireshark by selecting* ***View*** ▶ ***Time Display Format*** ▶
    ***Seconds Since Previous Displayed Packet***.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*要跟随本节内容，请确保在Wireshark中设置了正确的时间显示格式，选择***视图*** ▶ ***时间显示格式*** ▶ ***自上次显示的数据包以来的秒数***。*'
- en: '***Normal Communications***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***正常通信***'
- en: '*latency1.pcapng*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*latency1.pcapng*'
- en: We’ll discuss network baselines in detail a little later in the chapter. For
    now, just know that you need a baseline of normal communications to compare with
    the conditions of high latency. For these examples, we will use the file *latency1.pcapng*.
    We have already covered the details of the TCP handshake and HTTP communication,
    so we won’t review those topics again. In fact, we won’t look at the Packet Details
    pane at all. All we are really concerned about is the Time column, as shown in
    [Figure 11-22](ch11.xhtml#ch11fig22).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将在本章中详细讨论网络基线。现在，只需要知道你需要一个正常通信的基线，以便与高延迟的情况进行比较。对于这些示例，我们将使用文件*latency1.pcapng*。我们已经涵盖了TCP握手和HTTP通信的细节，因此不再重复这些主题。事实上，我们根本不需要查看数据包详情面板。我们真正关心的是“时间”这一列，如[图11-22](ch11.xhtml#ch11fig22)所示。
- en: '![image](../images/f248-01.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f248-01.jpg)'
- en: '*Figure 11-22: This traffic happens very quickly and can be considered normal.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-22：这种流量发生得非常快，可以视为正常。*'
- en: This communication sequence is quite quick, with the entire process taking less
    than 0.1 seconds.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这段通信序列非常快速，整个过程耗时不到0.1秒。
- en: The next few capture files we’ll examine will consist of this same traffic pattern
    but with differences in the timing of the packets.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将检查的几个捕获文件将包含相同的流量模式，只是数据包的时间有所不同。
- en: '***Slow Communications: Wire Latency***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***慢速通信：线缆延迟***'
- en: '*latency2.pcapng*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*latency2.pcapng*'
- en: Now let’s turn to the capture file *latency2.pcapng*. Notice that all of the
    packets are the same except for the time values in two of them, as shown in [Figure
    11-23](ch11.xhtml#ch11fig23).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看捕获文件*latency2.pcapng*。请注意，所有数据包内容相同，唯一的不同是其中两个数据包的时间值，正如[图11-23](ch11.xhtml#ch11fig23)所示。
- en: '![image](../images/f249-01.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f249-01.jpg)'
- en: '*Figure 11-23: Packets 2 and 5 show high latency.*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-23：数据包2和5显示了较高的延迟。*'
- en: As we begin stepping through these six packets, we encounter our first sign
    of latency immediately. The initial SYN packet is sent by the client (172.16.16.128)
    to begin the TCP handshake, and a delay of 0.87 seconds is seen before the return
    SYN/ACK is received from the server (74.125.95.104). This is our first indicator
    that we are experiencing wire latency, which is caused by a device between the
    client and server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始逐一分析这六个数据包时，立刻就遇到了第一个延迟的迹象。初始的SYN数据包由客户端（172.16.16.128）发送，用于启动TCP握手，而在接收到来自服务器（74.125.95.104）返回的SYN/ACK之前，出现了0.87秒的延迟。这是我们首次发现存在线缆延迟的迹象，延迟是由于客户端和服务器之间的某个设备造成的。
- en: We can make the determination that this is wire latency because of the nature
    of the types of packets being transmitted. When the server receives a SYN packet,
    a very minimal amount of processing is required to send a reply, because the workload
    doesn’t involve any processing above the transport layer. Even when a server is
    experiencing a very heavy traffic load, it will typically respond quickly to a
    SYN packet with a SYN/ACK. This eliminates the server as the potential cause of
    the high latency.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以判断这是线缆延迟，因为传输的数据包类型的特性。当服务器接收到SYN数据包时，回复所需的处理非常少，因为工作负载不涉及超出传输层的任何处理。即使服务器在承受非常重的流量负载时，通常也会迅速回应SYN数据包并发送SYN/ACK。这排除了服务器作为高延迟的潜在原因。
- en: The client is also eliminated because, at this point, it is not doing any processing
    beyond simply receiving the SYN/ACK packet. Elimination of both the client and
    server points us to potential sources of slow communication within the first two
    packets of this capture.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端也被排除了，因为此时它仅仅是在接收SYN/ACK数据包，并未进行任何进一步处理。排除客户端和服务器后，我们可以将慢速通信的潜在来源指向此捕获的前两个数据包。
- en: Continuing, we see that the transmission of the ACK packet that completes the
    three-way handshake occurs quickly, as does the HTTP `GET` request sent by the
    client. All of the processing that generates these two packets occurs locally
    on the client following receipt of the SYN/ACK, so these two packets are expected
    to be transmitted quickly, as long as the client is not under a heavy processing
    load.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 继续观察，我们看到完成三次握手的ACK数据包传输非常快，客户端发送的HTTP `GET`请求也是如此。所有生成这两个数据包的处理都发生在客户端本地，在收到SYN/ACK之后，因此只要客户端没有面临重负载，这两个数据包应该会很快传输。
- en: At packet 5, we see another packet with an incredibly high time value. It appears
    that after our initial HTTP `GET` request was sent, the ACK packet returned from
    the server took 1.15 seconds to be received. Upon receipt of the HTTP `GET` request,
    the server sent a TCP ACK before it began sending data, which once again requires
    very little processing by the server. This is another sign of wire latency.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据包5处，我们看到另一个数据包具有非常高的时间值。看起来，在我们发送初始的HTTP `GET`请求后，服务器返回的ACK数据包花费了1.15秒才被接收。在收到HTTP
    `GET`请求后，服务器发送了一个TCP ACK，随后才开始发送数据，这又一次表明服务器几乎没有处理负担。这是网络延迟的另一个迹象。
- en: Whenever you experience wire latency, you will almost always see it exhibited
    in both the SYN/ACK during the initial handshake and in other ACK packets throughout
    the communication. Although this information doesn’t tell you the exact source
    of the high latency on this network, it does tell you that neither client nor
    server is the source, so you know that the latency is due to some device in between.
    At this point, you could begin examining the various firewalls, routers, and proxies
    to locate the culprit.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你遇到网络延迟时，你几乎总是会在初始握手中的SYN/ACK以及通信过程中其他ACK数据包中看到它。尽管这些信息不能告诉你网络中高延迟的确切来源，但它能告诉你，既不是客户端也不是服务器是延迟的源头，因此你知道延迟是由中间的某个设备引起的。此时，你可以开始检查各种防火墙、路由器和代理，以定位罪魁祸首。
- en: '***Slow Communications: Client Latency***'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***慢速通信：客户端延迟***'
- en: '*latency3.pcapng*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*latency3.pcapng*'
- en: The next latency scenario we’ll examine is contained in *latency3.pcapng*, as
    shown in [Figure 11-24](ch11.xhtml#ch11fig24).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的延迟场景我们将在*latency3.pcapng*中查看，如[图11-24](ch11.xhtml#ch11fig24)所示。
- en: '![image](../images/f250-01.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f250-01.jpg)'
- en: '*Figure 11-24: The slow packet in this capture is the initial HTTP `GET`.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-24：此抓包中的慢速数据包是初始的HTTP `GET`。*'
- en: This capture begins normally, with the TCP handshake occurring very quickly
    and without any signs of latency. Everything appears to be fine until packet 4,
    which is an HTTP `GET` request after the handshake has completed. This packet
    shows a 1.34-second delay from the previously received packet.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个抓包正常开始，TCP握手非常快速地完成，没有任何延迟的迹象。直到数据包4，它是握手完成后的HTTP `GET`请求。这个数据包显示出从前一个接收到的数据包的1.34秒延迟。
- en: To determine the source of this delay, we need to examine what is occurring
    between packets 3 and 4\. Packet 3 is the final ACK in the TCP handshake sent
    from the client to the server, and packet 4 is the `GET` request sent from the
    client to the server. The common thread here is that these are both packets sent
    by the client and are independent of the server. The `GET` request should occur
    quickly after the ACK is sent, since all of these actions are centered on the
    client.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定这个延迟的来源，我们需要检查数据包3和数据包4之间发生了什么。数据包3是客户端发送到服务器的TCP握手中的最后一个ACK，而数据包4是客户端发送到服务器的`GET`请求。这里的共同点是，这两个数据包都是客户端发送的，并且与服务器无关。`GET`请求应该在ACK发送后迅速发生，因为所有这些动作都集中在客户端。
- en: Unfortunately for the end user, the transition from ACK to `GET` doesn’t happen
    quickly. The creation and transmission of the `GET` packet requires processing
    up to the application layer, and the delay in this processing indicates that the
    client was unable to perform the action in a timely manner. Thus, the client is
    ultimately responsible for the high latency in the communication.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对最终用户来说，不幸的是，从ACK到`GET`的过渡并不会很快发生。`GET`数据包的创建和传输需要处理到应用层，而这一处理的延迟表明客户端未能及时执行该操作。因此，客户端最终对通信中的高延迟负责。
- en: '***Slow Communications: Server Latency***'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***慢速通信：服务器延迟***'
- en: '*latency4.pcapng*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*latency4.pcapng*'
- en: The last latency scenario we’ll examine uses the file *latency4.pcapng*, as
    shown in [Figure 11-25](ch11.xhtml#ch11fig25). This is an example of server latency.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的最后一个延迟场景使用文件*latency4.pcapng*，如[图11-25](ch11.xhtml#ch11fig25)所示。这是一个服务器延迟的示例。
- en: '![image](../images/f250-02.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f250-02.jpg)'
- en: '*Figure 11-25: High latency isn’t exhibited until the last packet of this capture.*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-25：直到这次捕获的最后一个数据包才表现出高延迟。*'
- en: In this capture, the TCP handshake process between these two hosts completes
    flawlessly and quickly, so things begin well. The next couple of packets bring
    more good news, as the initial `GET` request and response ACK packets are delivered
    quickly as well. It is not until the last packet in this file that we see signs
    of high latency.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次捕获中，这两台主机之间的TCP握手过程完成得非常顺利且快速，因此一切开始得很好。接下来的几个数据包也带来了好消息，因为初始的`GET`请求和响应ACK数据包也很快被传送。直到该文件的最后一个数据包，我们才看到高延迟的迹象。
- en: This sixth packet is the first HTTP data packet sent from the server in response
    to the `GET` request sent by the client, and it has a slow arrival time of 0.98
    seconds after the server sends its TCP ACK for the `GET` request. The transition
    between packets 5 and 6 is very similar to the transition we saw in the previous
    scenario between the handshake ACK and `GET` request. However, in this case, the
    server is the focus of our concern.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第六个数据包是服务器响应客户端发送的`GET`请求的第一个HTTP数据包，在服务器发送完`GET`请求的TCP ACK后，延迟到达时间为0.98秒。数据包5和6之间的过渡非常类似于我们在之前场景中看到的握手ACK和`GET`请求之间的过渡。然而，在这种情况下，服务器是我们关注的重点。
- en: Packet 5 is the ACK that the server sends in response to the `GET` request from
    the client. As soon as that packet has been sent, the server should begin sending
    data almost immediately. The accessing, packaging, and transmitting of the data
    in this packet is done by the HTTP protocol, and because this is an application-layer
    protocol, a bit of processing is required by the server. The delay in receipt
    of this packet indicates that the server was unable to process this data in a
    reasonable amount of time, ultimately pointing to it as the source of latency
    in this capture file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包5是服务器在响应客户端的`GET`请求时发送的ACK数据包。一旦该数据包发送完，服务器应几乎立即开始发送数据。数据包中数据的访问、打包和传输是由HTTP协议完成的，鉴于这是一个应用层协议，服务器需要进行一些处理。此数据包的接收延迟表明服务器未能在合理的时间内处理该数据，最终将其指向为此捕获文件中的延迟源。
- en: '***Latency Locating Framework***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***延迟定位框架***'
- en: Using six packets, we’ve managed to locate the source of high network latency
    between the client and the server in several scenarios. The diagram in [Figure
    11-26](ch11.xhtml#ch11fig26) should help you troubleshoot your own latency issues.
    These principles can be applied to almost any TCP-based communication.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过六个数据包，我们已经能够在多个场景中定位客户端与服务器之间的高网络延迟源。图[11-26](ch11.xhtml#ch11fig26)应当能帮助你排查自己的延迟问题。这些原则可以应用于几乎所有基于TCP的通信。
- en: '![image](../images/f251-01.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f251-01.jpg)'
- en: '*Figure 11-26: This diagram can be used to troubleshoot your own latency issues.*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-26：此图可用于排查你的延迟问题。*'
- en: '**NOTE**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Notice that we have not talked a lot about UDP latency. Because UDP is designed
    to be quick but unreliable, it doesn’t have any built-in features to detect and
    recover from latency. Instead, it relies on the application-layer protocols (and
    ICMP) that it’s paired with to handle data delivery reliability.*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，我们没有详细讨论UDP延迟。由于UDP设计上是快速但不可靠的，它没有任何内置的特性来检测和恢复延迟。相反，它依赖于与之配对的应用层协议（和ICMP）来处理数据传输的可靠性。*'
- en: '**Network Baselining**'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络基准**'
- en: When all else fails, your *network baseline* can be one of the most crucial
    pieces of data you have when troubleshooting slowness on the network. For our
    purposes, a network baseline consists of a sample of traffic from various points
    on the network that includes a large chunk of what we would consider “normal”
    network traffic. The goal of having a network baseline is for it to serve as a
    basis of comparison when the network or devices on it are misbehaving.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他方法都失败时，你的*网络基准*可以是排查网络延迟问题时最重要的数据之一。就我们的目的而言，网络基准由来自网络各个点的流量样本组成，包含了我们认为的“大部分正常”网络流量。建立网络基准的目标是，它可以作为比较的基础，当网络或其上的设备出现异常时，进行分析。
- en: For example, consider a scenario in which several clients on the network complain
    of slowness when logging in to a local web application server. If you were to
    capture this traffic and compare it to a network baseline, you might find that
    the web server is responding normally but that the external DNS requests resulting
    from external content embedded in the web application are running twice as slowly
    as normal.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个场景，网络上的几个客户端在登录本地 Web 应用服务器时抱怨慢。如果您捕获了这段流量并将其与网络基线进行比较，您可能会发现 Web 服务器的响应是正常的，但由于
    Web 应用中嵌入的外部内容，外部 DNS 请求的响应速度只有正常的两倍。
- en: You might have noticed the slow external DNS server without the aid of a network
    baseline, but when you are dealing with subtle changes, that may not be the case.
    Ten DNS queries taking 0.1 seconds longer than normal to process are just as bad
    as one DNS query taking 1 full second longer than normal, but the former situation
    is much harder to detect without a network baseline.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经在没有网络基线的帮助下注意到慢速外部 DNS 服务器，但当您处理的是微小的变化时，情况可能并非如此。十个 DNS 查询处理时间比正常情况多 0.1
    秒，和一个 DNS 查询多 1 秒的情况一样糟糕，但前者在没有网络基线的情况下更难以发现。
- en: 'Because no two networks are alike, the components of a network baseline can
    vary drastically. The following sections provide examples of the components of
    a network baseline. You may find that all of these items apply to your network
    infrastructure or that very few of them do. Regardless, you should be able to
    place each component of your baseline inside one of three basic baseline categories:
    site, host, and application.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有两个网络是完全相同的，所以网络基线的组成部分可能会有很大差异。以下部分提供了网络基线组成部分的示例。您可能会发现这些项目中的所有内容都适用于您的网络基础设施，或者只有很少一部分适用。无论如何，您应该能够将基线的每个组成部分归类到三个基本基线类别之一：站点、主机和应用程序。
- en: '***Site Baseline***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***站点基线***'
- en: The purpose of the site baseline is to gain an overall snapshot of the traffic
    at each physical site on your network. Ideally, this would be every segment of
    the WAN.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 网站基线的目的是获取网络中每个物理站点的流量概况。理想情况下，这应包括广域网的每个段。
- en: 'Components of this baseline might include the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基线的组成部分可能包括以下内容：
- en: '**Protocols in Use**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**正在使用的协议**'
- en: To see traffic from all devices, use the Protocol Hierarchy Statistics window
    (**Statistics**   ▶ **Protocol Hierarchy**) while capturing traffic from all the
    devices on the network segment at the network edge (router/firewall). Later, you
    can compare against the hierarchy output to find out whether normally present
    protocols are missing or new protocols have introduced themselves on the network.
    You can also use this output to find above ordinary amounts of certain types of
    traffic based on protocol.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看来自所有设备的流量，请在捕获来自网络边缘（路由器/防火墙）上所有设备的流量时，使用协议层次统计窗口（**统计** ▶ **协议层次**）。之后，您可以将其与层次输出进行比较，找出是否缺少常见协议，或是否有新协议在网络中出现。您还可以使用此输出根据协议查找异常的某些类型的流量。
- en: '**Broadcast Traffic**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**广播流量**'
- en: This includes all broadcast traffic on the network segment. Sniffing at any
    point within the site should let you capture all of the broadcast traffic, allowing
    you to know who or what normally sends a lot of broadcast out on the network.
    Then you can quickly determine whether you have too much (or not enough) broadcasting
    going on.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括网络段上的所有广播流量。在站点内的任何位置嗅探都应该让您捕获到所有的广播流量，从而让您知道谁或什么通常在网络上发送大量的广播。然后，您可以快速判断是否存在过多（或不足）的广播。
- en: '**Authentication Sequences**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证序列**'
- en: These include traffic from authentication processes on random clients to all
    services, such as Active Directory, web applications, and organization-specific
    software. Authentication is one area in which services are commonly slow. The
    baseline allows you to determine whether authentication is to blame for slow communications.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包括从随机客户端到所有服务的身份验证过程流量，如活动目录、Web 应用程序和特定于组织的软件。身份验证是服务常常变慢的一个领域。基线可以帮助您判断身份验证是否是导致通信缓慢的原因。
- en: '**Data Transfer Rate**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据传输速率**'
- en: This usually consists of a measure of a large data transfer from the site to
    various other sites in the network. You can use the capture summary and graphing
    features of Wireshark (demonstrated in [Chapter 5](ch05.xhtml#ch05)) to determine
    the transfer rate and consistency of the connection. This is probably the most
    important site baseline you can have. Whenever any connection entering or leaving
    the network segment seems slow, you can perform the same data transfer as in your
    baseline and compare the results. This will tell you whether the connection is
    actually slow and will possibly even help you find the area in which the slowness
    begins.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常包括衡量从该站点到网络中其他站点的大量数据传输。你可以使用Wireshark的捕获摘要和图形功能（在[第5章](ch05.xhtml#ch05)中展示）来确定传输速率和连接的一致性。这可能是你拥有的最重要的站点基线。每当任何进入或离开网络段的连接看起来很慢时，你可以执行与你的基线相同的数据传输并进行比较。这样你可以判断连接是否真的很慢，甚至可能帮助你找到导致慢速的区域。
- en: '***Host Baseline***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***主机基线***'
- en: You probably don’t need to baseline every single host within your network. The
    host baseline should be performed on only high-traffic or mission-critical servers.
    Basically, if a slow server will result in angry phone calls from management,
    you should have a baseline of that host.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不需要为网络中的每个主机设置基线。主机基线应仅在高流量或关键任务服务器上执行。基本上，如果一个缓慢的服务器会导致管理层打来愤怒的电话，那么你应该为该主机设置基线。
- en: 'Components of the host baseline include the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 主机基线的组成部分包括以下内容：
- en: '**Protocols in Use**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用中的协议**'
- en: This baseline provides a good opportunity to use the Protocol Hierarchy Statistics
    window while capturing traffic from the host. Later, you can compare against this
    baseline to find out whether normally present protocols are missing or new protocols
    have introduced themselves on the host. You can also use this to find unusually
    large amounts of certain types of traffic based on protocol.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基线提供了一个很好的机会，可以在捕获主机流量时使用协议层次统计窗口。之后，你可以将其与基线进行比较，找出是否有正常存在的协议丢失，或新协议已出现在主机上。你还可以用它来根据协议发现异常大的某些类型的流量。
- en: '**Idle/Busy Traffic**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**空闲/繁忙流量**'
- en: This baseline simply consists of general captures of normal operating traffic
    during peak and off-peak times. Knowing the number of connections and amount of
    bandwidth used by those connections at different times of the day will allow you
    to determine whether slowness is a result of user load or another issue.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基线仅包括在高峰和非高峰时间段的正常操作流量的通用捕获。了解在一天中不同时间连接数和这些连接使用的带宽量，将帮助你判断缓慢是否由于用户负载或其他问题引起。
- en: '**Startup/Shutdown**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**启动/关闭**'
- en: To obtain this baseline, you’ll need to create a capture of the traffic generated
    during the startup and shutdown sequences of the host. If the computer refuses
    to boot, refuses to shut down, or is abnormally slow during either sequence, you
    can use this baseline to determine whether the cause is network related.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得这个基线，你需要创建一个捕获，记录主机启动和关闭序列期间生成的流量。如果计算机拒绝启动、拒绝关闭，或在任何一个序列中表现出异常的慢速，你可以利用这个基线来判断原因是否与网络相关。
- en: '**Authentication Sequences**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证序列**'
- en: Getting this baseline requires capturing traffic from authentication processes
    to all services on the host. Authentication is one area in which services are
    commonly slow. The baseline allows you to determine whether authentication is
    to blame for slow communications.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 获取这个基线需要捕获所有服务认证过程的流量。认证是服务常常变慢的一个领域。基线使你能够判断认证是否是造成通信缓慢的原因。
- en: '**Associations/Dependencies**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**关联/依赖关系**'
- en: This baseline consists of a longer-duration capture to determine what other
    hosts this host is dependent upon (and are dependent upon this host). You can
    use the Conversations window (**Statistics**   ▶ **Conversations**) to see these
    associations and dependencies. An example is a SQL Server host on which a web
    server depends. We are not always aware of the underlying dependencies between
    hosts, so the host baseline can be used to determine these. From there, you can
    determine whether a host is not functioning properly due to a malfunctioning or
    high-latency dependency.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基线由一个较长时间的捕获组成，用于确定该主机依赖于哪些其他主机（以及哪些主机依赖于它）。你可以使用会话窗口（**统计** ▶ **会话**）查看这些关联和依赖关系。例如，一个SQL服务器主机，网络中的一个Web服务器依赖于它。我们并不总是意识到主机之间潜在的依赖关系，因此可以通过主机基线来识别这些依赖关系。接下来，你可以判断是否由于某个故障或高延迟的依赖关系导致主机无法正常工作。
- en: '***Application Baseline***'
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用程序基准***'
- en: The final network baseline category is the application baseline. This baseline
    should be performed on all business-critical network-based applications.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的网络基准类别是应用程序基准。这个基准应该在所有业务关键的网络应用程序上执行。
- en: 'The following are the components of the application baseline:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是应用程序基准的组成部分：
- en: '**Protocols in Use**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用的协议**'
- en: Again, for this baseline, use the Protocol Hierarchy Statistics window in Wireshark,
    this time while capturing traffic from the host running the application. Later,
    you can compare against this list to find out whether protocols that the application
    depends on are functioning incorrectly or not at all.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，对于这个基准，使用Wireshark中的协议层次统计窗口，这次是在捕获来自运行应用程序的主机的流量时进行。之后，你可以与这个列表进行比较，以查看应用程序依赖的协议是否出现故障，或根本无法工作。
- en: '**Startup/Shutdown**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**启动/关闭**'
- en: This baseline includes a capture of the traffic generated during the startup
    and shutdown sequences of the application. If the application refuses to start
    or is abnormally slow during either sequence, you can use this baseline to determine
    the cause.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该基准包括在应用程序启动和关闭序列期间生成的流量捕获。如果应用程序在任何一个序列中拒绝启动或异常缓慢，可以使用该基准来确定问题原因。
- en: '**Associations/Dependencies**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**关联/依赖**'
- en: This baseline requires a longer-duration capture in which the Conversations
    window can be used to determine on which other hosts and applications this application
    depends. We are not always aware of the underlying dependencies between applications,
    so this baseline can be used to determine those. From there, you can determine
    whether an application is not functioning properly due to a malfunctioning or
    high-latency dependency.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基准需要进行较长时间的捕获，可以利用会话窗口来确定该应用程序依赖于哪些其他主机和应用程序。我们并不总是意识到应用程序之间的潜在依赖关系，因此可以使用这个基准来确定这些依赖关系。然后，你可以确定应用程序是否因某个故障或高延迟的依赖而无法正常运行。
- en: '**Data Transfer Rate**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据传输速率**'
- en: You can use the capture summary and graphing features of Wireshark to determine
    the transfer rate and consistency of the connections to the application server
    during its normal operation. Whenever the application is reported as being slow,
    you can use this baseline to determine whether the issues being experienced are
    a result of high utilization or high user load.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Wireshark的捕获总结和图形功能来确定应用程序服务器在正常操作期间的传输速率和连接一致性。每当应用程序报告为缓慢时，你可以使用这个基准来确定是否是由于高利用率或高用户负载导致的问题。
- en: '***Additional Notes on Baselines***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基准的额外说明***'
- en: 'Here are a few more points to keep in mind when creating your network baseline:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建网络基准时，还有一些其他要点需要记住：
- en: '•     When creating your baselines, capture each one at least three times:
    once during a low-traffic time (early morning), once during a high-traffic time
    (midafternoon), and once during a no-traffic time (late night).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: •     在创建基准时，每个基准至少要捕获三次：一次在低流量时段（清晨），一次在高流量时段（下午），一次在无流量时段（深夜）。
- en: •     When possible, avoid capturing directly from the hosts you are baselining.
    During periods of high traffic, doing so may put an increased load on the device,
    hurt its performance, and cause your baseline to be invalid due to dropped packets.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: •     在可能的情况下，避免直接从你正在基准化的主机上捕获数据。在高流量时段这样做可能会增加设备的负载，影响其性能，并导致丢包，使得基准无效。
- en: •     Your baseline will contain some very intimate information about your network,
    so be sure to secure it. Store it in a safe place where only the appropriate individuals
    have access. But at the same time, keep it readily accessible so you can use it
    when needed. Consider keeping it on a USB flash drive or on an encrypted partition.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: •     你的基准将包含一些关于你网络的非常敏感的信息，因此要确保对其进行保护。将其存储在一个安全的地方，只有合适的人才能访问。但同时，也要确保它随时可用，以便在需要时使用。可以考虑将其存储在USB闪存驱动器或加密分区中。
- en: •     Keep all *.pcap*   and *.pcapng* files associated with your baseline and
    create a cheat sheet of the more commonly referenced values, such as associations
    or average data transfer rates.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: •     保留所有与基准相关的*.pcap*和*.pcapng*文件，并创建一份常用值的备忘单，例如关联关系或平均数据传输速率。
- en: '**Final Thoughts**'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**最终思考**'
- en: This chapter has focused on troubleshooting slow networks. We’ve covered some
    of the more useful reliability detection and recovery features of TCP, demonstrated
    how to locate the source of high latency in network communications, and discussed
    the importance of a network baseline and some of its components. Using the techniques
    discussed here, along with some of Wireshark’s graphing and analysis features,
    you should be well equipped to troubleshoot when you get that call complaining
    that the network is slow.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论了慢网络故障排除。我们介绍了一些 TCP 中更有用的可靠性检测和恢复功能，演示了如何定位网络通信中的高延迟来源，并讨论了网络基线及其一些组成部分的重要性。运用本文中讨论的技术，以及
    Wireshark 的图形和分析功能，你应该能够做好充分准备，当接到抱怨网络慢的电话时进行故障排除。
