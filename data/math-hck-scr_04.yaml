- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: '**Finding Patterns in Sequences**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**在序列中寻找模式**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Humans are hardwired to look for patterns and predict what comes next. Patterns
    can be complicated in the real world, with lots of variables and outcomes in time
    (when will the moon be full again?) or space (is there a bear in that cave?).
    In this chapter, we’ll explore the patterns found in sequences of numbers. You’ll
    learn how to uncover the rules for how a sequence is formed and how to predict
    later numbers in the sequence.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 人类天生就能寻找模式并预测接下来会发生什么。现实世界中的模式可能很复杂，涉及到很多变量和结果，可能是时间上的（比如下次月圆是什么时候？）或空间上的（比如那个洞里有熊吗？）。在本章中，我们将探索数字序列中的模式。你将学会如何揭示序列形成的规则，以及如何预测序列中的后续数字。
- en: What Are Sequences?
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是序列？
- en: A *sequence* is just a list of numbers. The numbers are listed in a particular
    order—there’s a first number, a second number, a third number, and so on—so we
    can say that sequences are ordered, or *indexed*, by the positive integers. When
    we write about the mathematics of sequences, we often show the index numbers as
    subscripts. For example, we might write a sequence as *a*[1], *a*[2], *a*[3],
    . . . , where each *a* is a value in the sequence, known as a *term* or an *element*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *序列* 就是一系列数字。这些数字按照特定的顺序排列——有第一个数字、第二个数字、第三个数字，等等——所以我们可以说序列是由正整数 *索引* 或
    *排列* 的。当我们写关于序列的数学时，我们通常会将索引数字写作下标。例如，我们可能会将一个序列写作 *a*[1]，*a*[2]，*a*[3]，. . .
    ，其中每个 *a* 是序列中的一个值，称为 *项* 或 *元素*。
- en: 'Often, the numbers in a sequence tell a story about how they were generated.
    Maybe there’s a rule that describes a formula for taking an index number and manipulating
    it to produce the corresponding element of the sequence. For example, if we wanted
    to study the sequence of odd numbers (1, 3, 5, 7, . . .), we might describe the
    *n*th odd number as 2*n* – 1\. We could arrive at this formula by thinking about
    the even numbers as multiples of 2 and odd numbers as 1 less than even numbers.
    We can do a quick check to make sure this works: the first odd number is when
    index *n* = 1, and 2 ⋅ 1 – 1 = 1\. Next, when *n* = 2, we get 2*n* – 1 = 2 ⋅ 2
    – 1 = 3, and so on. We can make the pattern explicit by saying *a*[*n*] = 2*n*
    – 1, or, in words, *double the index and subtract one*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，序列中的数字讲述了它们是如何生成的。也许有一个规则描述了一个公式，用来获取索引数字并对其进行操作，以生成对应的序列元素。例如，如果我们想研究奇数的序列（1,
    3, 5, 7, . . .），我们可能会将第 *n* 个奇数描述为 2*n* – 1。我们可以通过将偶数看作是 2 的倍数，奇数则是比偶数少 1，来推导出这个公式。我们可以快速检查这个公式是否有效：当索引
    *n* = 1 时，第一个奇数是 2 ⋅ 1 – 1 = 1。接着，当 *n* = 2 时，我们得到 2*n* – 1 = 2 ⋅ 2 – 1 = 3，以此类推。我们可以通过以下方式明确模式：*a*[*n*]
    = 2*n* – 1，或者用语言来说就是：*将索引翻倍并减去 1*。
- en: Maybe each index *n* represents a mathematical object, like a geometric shape,
    and the corresponding number in the sequence can be found by examining or counting
    some feature of the object. For example, if we let each *n* represent a square
    of side length *n*, we might be interested in the sequence of the squares’ areas
    (1, 4, 9, 16, . . .). Or maybe we’d want the sequence of the squares’ perimeters
    instead (4, 8, 12, 16, . . .).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 也许每个索引 *n* 代表一个数学对象，比如几何形状，而对应的序列中的数字可以通过检查或计数该对象的一些特征来找到。例如，如果我们让每个 *n* 代表一个边长为
    *n* 的正方形，我们可能对正方形面积的序列感兴趣（1, 4, 9, 16, . . .）。或者也许我们更想要正方形周长的序列（4, 8, 12, 16,
    . . .）。
- en: Finding the Next Value in a Sequence
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在序列中寻找下一个值
- en: It may be possible to find a formula for a sequence like the ones just described
    that’s based on a geometric or logical pattern. That formula can then give us
    useful insight into what’s going on with the sequence. For example, we might notice
    that the numbers in the area sequence are all perfect squares and recognize that
    this has to do with a square’s area being a product of its length and width. Likewise,
    we might notice that the numbers in the perimeter sequence are all multiples of
    4 and find a reason for this in a square’s four equal sides. If we write the sequence
    of areas as *s*[1], *s*[2], *s*[3], . . . , and the sequence of perimeters as
    *p*[1], *p*[2], *p*[3], . . . , we might then find the formulas *s*[*n*] = *n*²
    and *p*[*n*] = 4*n*. These formulas are correct algebraically, but we arrived
    at them based on the geometric descriptions of the sequences.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有可能找到一个基于几何或逻辑模式的公式，来描述像刚才提到的那样的数列。然后，这个公式可以帮助我们深入理解数列的规律。例如，我们可能会注意到，面积数列中的所有数字都是完全平方数，并且意识到这与一个正方形的面积是其长和宽的乘积有关。同样，我们可能会注意到，周长数列中的数字都是4的倍数，并且能够找到一个理由，这与正方形四条相等的边长有关。如果我们将面积数列写成
    *s*[1]、*s*[2]、*s*[3]、. . . ，将周长数列写成 *p*[1]、*p*[2]、*p*[3]、. . . ，我们可能会发现公式 *s*[*n*]
    = *n*² 和 *p*[*n*] = 4*n*。这些公式在代数上是正确的，但我们是基于数列的几何描述得出的这些公式。
- en: Sometimes a sequence’s pattern is best described by providing a recipe to produce
    later terms in the sequence based on earlier terms. A *recurrence* does this by
    giving a formula for *a*[*n*] that’s based not on the index *n* but on the values
    of previous elements. For example, the perimeter sequence could be generated by
    noting that *p*[1] = 4 and that each perimeter is 4 more than the previous one.
    The element before the element with index *n* has index *n* – 1, so the formula
    could be *p*[*n*] = *p*[*n* – 1] + 4\. As long as we have the starting value (which
    is *p*[1]), we can generate the rest of the sequence.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，描述数列的模式最好是通过提供一个生成后续项的规则，基于前面的项。*递归*就是通过给出一个公式来描述 *a*[*n*]，这个公式不仅仅依赖于索引 *n*，而是基于前面元素的值。例如，周长数列可以通过注意到
    *p*[1] = 4，并且每个周长都比前一个多4来生成。位于索引 *n* 前的元素具有索引 *n* – 1，因此公式可以是 *p*[*n*] = *p*[*n*
    – 1] + 4。只要我们有了起始值（即 *p*[1]），我们就能生成剩下的数列。
- en: The sequence of square areas also follows its own, more subtle recurrence. Given
    the starting element *s*[1] = 1, any later element *s*[*n*] can be calculated
    as *s*[*n* – 1] + 2*n* – 1\. This gives us another way to describe the sequence.
    In general, to specify a sequence by a recurrence you must provide an initial
    value (such as *p*[1] = 4) and a rule of formation (such as *p*[*n*] = *p*[*n*
    – 1] + 4). Recurrences can sometimes depend on two or more preceding terms instead
    of just one, in which case two or more initial values must be given. A famous
    example is the Fibonacci sequence, which we’ll explore soon.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正方形的面积数列也遵循它自己更微妙的递归规律。给定初始元素 *s*[1] = 1，任何后续元素 *s*[*n*] 都可以通过公式 *s*[*n* – 1]
    + 2*n* – 1 计算得出。这为我们提供了另一种描述该数列的方式。一般来说，要通过递归来指定一个数列，你必须提供一个初始值（例如 *p*[1] = 4）和一个形成规则（例如
    *p*[*n*] = *p*[*n* – 1] + 4）。有时，递归可能依赖于两个或更多前导项，而不仅仅是一个，在这种情况下，必须提供两个或更多初始值。一个著名的例子是斐波那契数列，我们稍后会进行探讨。
- en: Making Sequences in Scratch
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Scratch 中创建数列
- en: In Scratch, we can represent sequences as lists. A Scratch list can hold numbers
    or strings and can be up to 200,000 items long, which is generous for exploring
    patterns. Unlike many other programming languages, which index list items starting
    from 0, Scratch indexes its lists starting from 1\. This quirk makes Scratch lists
    especially useful for representing sequences, which are also typically indexed
    starting from 1\. As mentioned in [Chapter 3](ch03.xhtml#ch03), when Scratch displays
    a list on the stage, it includes the index numbers down the left side, so you
    can easily see an item’s position in the sequence. If the list is too long to
    fit on the stage, you can scroll down to see the later entries.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scratch 中，我们可以将数列表示为列表。Scratch 列表可以包含数字或字符串，并且可以最多容纳 200,000 个项目，这对于探索模式来说是足够的。与许多其他编程语言（这些语言通常从
    0 开始索引列表项）不同，Scratch 从 1 开始索引其列表。这一特性使得 Scratch 列表特别适用于表示数列，因为数列通常也是从 1 开始索引的。如
    [第 3 章](ch03.xhtml#ch03) 中所提到的，当 Scratch 在舞台上显示一个列表时，它会在左侧显示索引数字，因此你可以轻松看到一个项在数列中的位置。如果列表太长，无法完全显示在舞台上，你可以滚动查看后面的条目。
- en: The Scratch blocks for working with lists are shown in [Figure 4-1](ch04.xhtml#ch4fig1).
    These blocks are available in the Variables section of the block palette.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用于处理列表的Scratch模块如[图 4-1](ch04.xhtml#ch4fig1)所示。这些模块可以在模块面板的变量部分找到。
- en: '![Image](../images/pg81_Image_85.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg81_Image_85.jpg)'
- en: '*Figure 4-1: Scratch’s list manipulation blocks*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：Scratch的列表操作模块*'
- en: Notice that, as well as adding items at the end of a list, we can insert items
    at any position in the list, which causes the indices of later items to shift
    (increase) by 1\. We can delete list items, which also shifts the later index
    numbers (reducing them by 1), and we can replace list items with other items,
    which leaves the later indices unchanged. We can look up an item’s index to see
    where in the list it occurs, and we can check if an item occurs in the list at
    all. We can also see how long the list is.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了在列表末尾添加项，我们还可以在列表的任何位置插入项，这会导致后续项的索引增加（加 1）。我们可以删除列表项，这也会使后续项的索引减小（减少 1），同时我们还可以用其他项替换列表项，这样后续项的索引则不会改变。我们可以查找某个项的索引，查看它在列表中的位置，也可以检查某个项是否出现在列表中。我们还可以查看列表的长度。
- en: 'Project 14: Fibonacci’s Rabbits'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 14：斐波那契的兔子
- en: In this project, we’ll explore the *Fibonacci numbers*, a famous sequence described
    by a *two-term recurrence*. This means each number in the sequence is calculated
    based on the previous two. The sequence was first mentioned in western Europe
    in the book *Liber Abaci*, written by an Italian mathematician named Fibonacci
    in 1202\. Fibonacci used the sequence to describe the growth of a population of
    rabbits.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将探索*斐波那契数列*，这是一个由*二项递推*描述的著名数列。这意味着数列中的每个数字都是基于前两个数字计算出来的。这个数列最早在1202年由意大利数学家斐波那契在《Liber
    Abaci》一书中提到。斐波那契使用这个数列来描述兔子种群的增长。
- en: 'After we’re given the first two numbers in the Fibonacci sequence, *f*[1] =
    1 and *f*[2] = 1, every other number is found using this rule of formation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定斐波那契数列的前两个数字，*f*[1] = 1 和 *f*[2] = 1之后，其他的数字都是通过这个生成规则来找到的：
- en: '![Image](../images/pg82_Image_86.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg82_Image_86.jpg)'
- en: In other words, we add the two previous numbers in the sequence to get the next
    one. The third number is 1 + 1 = 2, the fourth is 1 + 2 = 3, the fifth is 2 +
    3 = 5, and so on. For more, we can let Scratch do the work, as in [Figure 4-2](ch04.xhtml#ch4fig2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们将序列中的前两个数相加，得到下一个数字。第三个数字是 1 + 1 = 2，第四个是 1 + 2 = 3，第五个是 2 + 3 = 5，依此类推。更多内容我们可以让Scratch来处理，如[图
    4-2](ch04.xhtml#ch4fig2)所示。
- en: '![Image](../images/pg82_Image_87.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg82_Image_87.jpg)'
- en: '*Figure 4-2: Generating the Fibonacci sequence using a two-term recurrence*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：使用二项递推生成斐波那契数列*'
- en: Notice in this code that to generate numbers in a two-term recurrence, we need
    to keep track of only the previous two values to calculate the next one. We first
    set the variables named `oldold` and `old` to the starting values (`1` and `1`).
    Then, in a loop ❶, we assign the `new` variable their sum, replace `oldold` with
    `old`, and replace `old` with `new`. With these replacements, we’re ready to calculate
    the next value of `new` the next time through the loop.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这段代码中，为了生成二项递推的数字，我们只需要追踪前两个值来计算下一个值。我们首先将名为 `oldold` 和 `old` 的变量设置为初始值（`1`
    和 `1`）。然后，在一个循环 ❶ 中，我们将 `new` 变量赋值为它们的和，将 `oldold` 替换为 `old`，并将 `old` 替换为 `new`。通过这些替换，我们就准备好在下一次循环时计算
    `new` 的下一个值。
- en: 'Project 15: The Golden Ratio'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 15：黄金比例
- en: 'An interesting fact about the Fibonacci sequence is that the ratios of successive
    numbers approach a limiting value, meaning the value of *f*[*n*] divided by *f*[*n*
    – 1] gets closer and closer to a particular number (the *limit*) as the sequence
    goes on, without ever quite reaching it. This is known as a *convergent ratio*.
    For Fibonacci numbers, the limit is a famous mathematical constant called the
    *golden ratio*. Its exact value is:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列的一个有趣的事实是，连续两个数的比值趋近于一个极限值，这意味着随着数列的展开，*f*[*n*] 除以 *f*[*n* – 1] 会越来越接近某个特定数字（即*极限*），但永远不会完全到达它。这被称为*收敛比率*。对于斐波那契数列来说，这个极限是一个著名的数学常数，叫做*黄金比例*。它的准确值是：
- en: '![Image](../images/pg83_Image_88.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg83_Image_88.jpg)'
- en: To prove that the Fibonacci numbers have a convergent ratio, we can modify the
    code from the previous project, adding another list that keeps track of the ratios
    of each number with the previous number in the sequence. [Figure 4-3](ch04.xhtml#ch4fig3)
    shows how.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明斐波那契数列具有收敛比值，我们可以修改前一个项目中的代码，添加另一个列表来跟踪每个数字与序列中前一个数字的比值。[图4-3](ch04.xhtml#ch4fig3)展示了如何做。
- en: '![Image](../images/pg83_Image_89.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg83_Image_89.jpg)'
- en: '*Figure 4-3: Tracking the ratios of successive Fibonacci terms*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-3：追踪连续斐波那契项的比值*'
- en: The code is similar to [Figure 4-2](ch04.xhtml#ch4fig2), but with an extra list
    to keep track of the `Fibonacci ratio`. We update this list with the value of
    `old / oldold` before calculating the next term in the sequence ➋. We let the
    list go through 40 iterations ➊ because that’s where the value of the ratio stabilizes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与[图4-2](ch04.xhtml#ch4fig2)类似，只不过多了一个额外的列表来追踪`Fibonacci ratio`。我们在计算序列中的下一个项之前，用`old
    / oldold`的值更新这个列表 ➋。我们让列表经过40次迭代 ➊，因为这是比值稳定下来的地方。
- en: The Results
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 4-4](ch04.xhtml#ch4fig4) shows the initial results in the two lists
    after running the code shown in [Figure 4-3](ch04.xhtml#ch4fig3). You’ll have
    to scroll down to see the later values in the lists.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-4](ch04.xhtml#ch4fig4)显示了运行[图4-3](ch04.xhtml#ch4fig3)中代码后的两个列表中的初始结果。你需要向下滚动才能查看列表中的后续值。'
- en: '![Image](../images/pg84_Image_90.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg84_Image_90.jpg)'
- en: '*Figure 4-4: The first Fibonacci numbers and their ratios*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-4：前几个斐波那契数及其比值*'
- en: The `Fibonacci` list shows the Fibonacci sequence itself, while the `Fibonacci
    ratio` list shows the ratio between each term and the one that follows it. As
    you can see, the ratios bounce around above and below their limiting value. If
    you wanted to stop the program early, taking the average of two successive list
    elements in `Fibonacci ratio` would give a better approximation of the limiting
    value than either element alone.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fibonacci`列表显示了斐波那契数列本身，而`Fibonacci ratio`列表显示了每一项与其后续项之间的比值。正如你所看到的，比值在它们的极限值上下波动。如果你想提前停止程序，取`Fibonacci
    ratio`中两个连续列表元素的平均值，将比单独的元素提供更好的极限值近似。'
- en: Hacking the Code
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: We used a `repeat` loop to give the program what seemed like a reasonable number
    of terms to calculate, but it may be better to let it decide for itself how many
    terms it needs. For instance, we could have the program stop calculating Fibonacci
    numbers when the ratios have sufficiently converged to the limiting value. We
    could define this as the point when the ratio values are no longer changing, or
    when they change by less than a specified amount. [Figure 4-5](ch04.xhtml#ch4fig5)
    shows a modified Fibonacci program that uses this approach.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`repeat`循环来为程序提供看起来合理的计算项数，但最好是让程序自己决定需要多少项。例如，我们可以让程序在比值足够收敛到极限值时停止计算斐波那契数。我们可以将此定义为比值不再变化的时刻，或者当它们的变化小于指定的量时。[图4-5](ch04.xhtml#ch4fig5)展示了使用这种方法的修改版斐波那契程序。
- en: This program no longer stores the Fibonacci numbers in a list, since we’re interested
    only in how long it takes for the ratios to converge. We use a `repeat until`
    loop ➊ to monitor the ratios as more terms are calculated, stopping when the difference
    between the current and previous ratio is less than `0.0000001`. This accuracy
    level is configurable, but if we use too many digits (too small a number), we’ll
    run into the limitations of the IEEE 754 floating-point representation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序不再将斐波那契数存储在列表中，因为我们只关心比值收敛所需的时间。我们使用`repeat until`循环 ➊ 来监控比值随着更多项的计算而变化，直到当前比值与前一个比值的差异小于`0.0000001`为止。这个精度水平是可配置的，但如果我们使用过多的数字（过小的数字），我们将遇到IEEE
    754浮点表示法的限制。
- en: Notice that the `repeat until` condition uses an absolute value function (`abs`).
    This is necessary because the ratios seesaw around the limiting value, alternately
    too big and too small. This means the difference we calculate is alternately positive
    and negative, so `abs` converts the negative values to positive.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`repeat until`条件使用了绝对值函数（`abs`）。这是必要的，因为比值在极限值周围来回摆动，交替地过大或过小。这意味着我们计算的差异交替为正值和负值，因此`abs`将负值转换为正值。
- en: '![Image](../images/pg85_Image_91.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg85_Image_91.jpg)'
- en: '*Figure 4-5: Stopping the program when the ratio converges*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-5：当比值收敛时停止程序*'
- en: The program includes a variable called `count` to keep track of how many terms
    we need to get to the specified accuracy level. After the loop ends, the program
    stores the final ratio in the `ratio` variable ➋. On the stage, only the first
    few digits of the ratio are shown, but you can click the ratio in the coding area
    to see all the digits that were calculated, as shown in [Figure 4-6](ch04.xhtml#ch4fig6).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序包含一个名为 `count` 的变量，用来跟踪需要多少项才能达到指定的准确度水平。在循环结束后，程序将最终的比率存储在 `ratio` 变量中
    ➋。在舞台上，只显示比率的前几位数字，但你可以点击编码区域中的比率，查看计算出的所有数字，如[图 4-6](ch04.xhtml#ch4fig6)所示。
- en: '![Image](../images/pg85_Image_92.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg85_Image_92.jpg)'
- en: '*Figure 4-6: Calculating the Fibonacci ratio*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：计算斐波那契比率*'
- en: As an experiment, you might try setting the accuracy level to different values
    (`0.01`, `0.001`, . . .) to see how many terms it takes to reach that level of
    accuracy.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实验，你可以尝试将准确度设置为不同的值（`0.01`，`0.001`，……），看看需要多少项才能达到那个准确度水平。
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**4.1** Try changing the starting conditions for the Fibonacci recurrence by
    using different initial values for `old` and `oldold` in the original Fibonacci
    program ([Figure 4-2](ch04.xhtml#ch4fig2)). Setting `old` to `2` and `oldold`
    to `1` wouldn’t be very interesting, since that just gives the Fibonacci sequence
    shifted by one number. Setting `old` to `1` and `oldold` to `2`, however, gives
    a different sequence, called the *Lucas sequence*. See if you can find any relationships
    between Lucas numbers and Fibonacci numbers.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.1** 尝试通过在原始斐波那契程序中使用不同的初始值来更改斐波那契递归的起始条件（[图 4-2](ch04.xhtml#ch4fig2)）。将
    `old` 设置为 `2`，`oldold` 设置为 `1` 并不会很有趣，因为这只是将斐波那契数列向右平移了一位。然而，如果将 `old` 设置为 `1`，`oldold`
    设置为 `2`，则会得到一个不同的数列，称为 *卢卡斯数列*。看看你是否能找到卢卡斯数与斐波那契数之间的关系。'
- en: '**4.2** How could you make sense of Fibonacci numbers going backward? What
    should *f*[0] be to preserve the recurrence? How about *f*[–1] and *f*[–2]? Program
    a recurrence for negative integers.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.2** 你如何理解斐波那契数列的反向计算？为了保持递归关系，*f*[0] 应该是什么？*f*[–1] 和 *f*[–2] 又应该是什么？编写一个针对负整数的递归程序。'
- en: '**4.3** Play with the code in [Figure 4-2](ch04.xhtml#ch4fig2) to explore its
    limits. How far can the Fibonacci sequence go before the numbers it generates
    exceed flintmax? How far before the numbers exceed the absolute limit for Scratch’s
    floating-point representation and are reported as `Infinity`? The rate of growth
    is exponential, so it doesn’t take many steps before flintmax is exceeded!'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.3** 在[图 4-2](ch04.xhtml#ch4fig2)中的代码上进行修改，探索它的极限。斐波那契数列能走多远，才会超出 flintmax？在数字超过
    Scratch 浮点数表示的绝对限制并被报告为 `Infinity` 之前，能走多远？增长速度是指数级的，因此不需要很多步骤，flintmax 就会被超越！'
- en: Figurate Numbers
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 几何数
- en: '*Figurate numbers* come from sequences that count how many points it takes
    to build nested geometric figures. For example, in [Figure 4-7](ch04.xhtml#ch4fig7)
    we have squares that fit (“nest”) inside one another. The blue points are the
    points we want to count, in this case positioned on a grid. By drawing connections
    between the points, starting from the bottom-left corner, we can create increasingly
    larger squares that encompass more and more of the points.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*几何数* 来自那些计算构建嵌套几何图形所需点数的数列。例如，在[图 4-7](ch04.xhtml#ch4fig7)中，我们有一个内嵌的正方形序列。蓝色的点是我们要计数的点，这些点位于网格上。通过连接这些点，从左下角开始，我们可以绘制出越来越大的正方形，包含越来越多的点。'
- en: '![Image](../images/pg86_Image_93.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg86_Image_93.jpg)'
- en: '*Figure 4-7: Nested squares as figurate numbers*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-7：作为几何数的嵌套正方形*'
- en: The word *square* can be a noun or a verb. As a noun, it names a geometric object,
    a polygon with four equal sides and four equal angles. As a verb, it’s more often
    used for arithmetic, to describe the process of multiplying a number by itself.
    Of course, the arithmetic and geometry are related. The formula *A* = *s*², used
    to calculate the area of a (geometric) square by multiplying the length of a side
    *s* by itself, interprets the arithmetic in a geometrical way. Numbers are squares
    if they’re the result of multiplying a positive integer by itself (1² = 1, 2²
    = 4, 3² = 9, 16, 25, . . .).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*平方*一词可以是名词或动词。作为名词时，它指的是一种几何图形，一个具有四个相等边和四个相等角的多边形。作为动词时，它通常用于算术中，用来描述将一个数字乘以自身的过程。当然，算术和几何是相关的。公式*A*
    = *s*²，用于通过将边长*s*自乘来计算（几何）正方形的面积，从几何角度解释了算术。若某个数字是通过将一个正整数自乘得到的，那么这个数字就是平方数（1²
    = 1, 2² = 4, 3² = 9, 16, 25，...）。'
- en: '[Figure 4-7](ch04.xhtml#ch4fig7) shows how we can arrange square numbers of
    points to form ever-growing geometric squares. We have a square with 4 points
    (2 rows of 2) inside a square with 9 points (3 rows of 3) inside a square with
    16 points (4 rows of 4) inside a square with 25 points (5 rows of 5). You can
    think of the bottom-left point itself as a square with 1 point, too. Each larger
    square adds a new set of connected points around the edges of the previous square.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-7](ch04.xhtml#ch4fig7)展示了我们如何排列平方数个点，形成不断增长的几何正方形。我们有一个包含4个点（2行2列）的正方形，内嵌着一个包含9个点（3行3列）的正方形，再内嵌着一个包含16个点（4行4列）的正方形，最后是一个包含25个点（5行5列）的正方形。你也可以把最左下角的点当作包含1个点的正方形。每个较大的正方形都会在前一个正方形的边缘添加一组新的连接点。'
- en: In fact, any kind of polygon can be nested to make a sequence of figurate numbers
    like the sequence of squares, as we’ll explore next.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，任何类型的多边形都可以嵌套，从而生成类似平方数序列的几何数列，正如我们接下来要探讨的那样。
- en: 'Project 16: Square, Triangular, and Pentagonal Numbers?'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目16：平方数、三角形数和五边形数？
- en: The Scratch program in the next three figures draws nested *s*-sided polygons
    and counts the newly added points around the edges to generate a sequence. So
    far, we haven’t used many of Scratch’s graphics capabilities, but in this program
    we use the Pen extension to animate the drawing of various figures. (Click the
    **Add Extensions** icon in the bottom-left corner to add these Pen blocks.) Our
    program starts with the initial setup in [Figure 4-8](ch04.xhtml#ch4fig8).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个图中的Scratch程序绘制了嵌套的*s*边形，并计算新添加的点以生成一个序列。到目前为止，我们还没有使用很多Scratch的图形功能，但在这个程序中，我们使用了Pen扩展来为绘制各种图形添加动画。（点击左下角的**添加扩展**图标来添加这些Pen块。）我们的程序从[图
    4-8](ch04.xhtml#ch4fig8)中的初始设置开始。
- en: '![Image](../images/pg87_Image_94.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg87_Image_94.jpg)'
- en: '*Figure 4-8: The setup code for drawing nested polygons*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8：绘制嵌套多边形的设置代码*'
- en: This `initial setup` block erases previous drawings from the screen and asks
    the user for the number of sides (in the variable `number of sides`) and the number
    of polygons to nest (in the variable `reps`) ❶. The calculation of `side length`
    ➋, which is the distance on the stage between two adjacent points, makes sure
    the polygons will fit on the stage.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`initial setup`块清除屏幕上的前面绘图，并要求用户输入边数（保存在变量`number of sides`中）和嵌套的多边形数量（保存在变量`reps`中）❶。计算`side
    length` ➋，即舞台上两个相邻点之间的距离，确保多边形能够适应舞台。
- en: '[Figure 4-9](ch04.xhtml#ch4fig9) shows the main logic of the program.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-9](ch04.xhtml#ch4fig9)展示了程序的主要逻辑。'
- en: '![Image](../images/pg88_Image_95.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg88_Image_95.jpg)'
- en: '*Figure 4-9: Drawing the polygons*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-9：绘制多边形*'
- en: We draw the nested polygons in a loop that repeats `reps` times. We start drawing
    each polygon from the bottom-left corner, using the `go to` block to skip any
    dots that we’ve already drawn (since the polygons all share the same base). After
    drawing the first side with a custom `Draw n segment(s)` block, we rotate the
    pen ❶ depending on the number of sides of the polygon. The `counter` variable
    keeps track of the total number of points drawn. Once the current polygon is complete,
    we add `counter` to `end point list` ➋. This list keeps track of how many points
    we’ve drawn at the end of each completed polygon, building up our figurate number
    sequence. We use a custom `Highlight point` block to specify how the points are
    drawn. [Figure 4-10](ch04.xhtml#ch4fig10) shows these two custom blocks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个循环中绘制嵌套的多边形，该循环重复`reps`次。我们从左下角开始绘制每个多边形，使用`go to`块跳过已经绘制的点（因为所有多边形都有相同的底边）。在用自定义的`Draw
    n segment(s)`块绘制完第一条边后，我们根据多边形的边数旋转笔刷❶。`counter`变量跟踪已绘制的点的总数。一旦当前的多边形完成，我们将`counter`添加到`end
    point list` ➋。该列表跟踪每完成一个多边形时绘制的点数，构建我们的图形数列。我们使用自定义的`Highlight point`块来指定如何绘制这些点。[图
    4-10](ch04.xhtml#ch4fig10)显示了这两个自定义块。
- en: '![Image](../images/pg89_Image_96.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg89_Image_96.jpg)'
- en: '*Figure 4-10: Drawing points and lines*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-10：绘制点和线*'
- en: The `Draw n segment(s)` block takes `n` steps along the side of a polygon, first
    drawing a large dot (`pen size 5`) and then drawing a thin line (`pen size 1`)
    to connect with the next dot. The `wait` block calculates a pause between each
    step ❶, but if you get tired of watching the drawing happen, you can speed it
    up by lowering the value in the numerator.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Draw n segment(s)`块沿多边形的一条边执行`n`步，首先画一个大点（`笔刷大小 5`），然后画一条细线（`笔刷大小 1`）连接到下一个点。`wait`块计算每一步之间的暂停时间❶，但如果你厌倦了观看绘图过程，可以通过降低分子中的值来加快速度。'
- en: The custom `Highlight point` block simply changes the pen color to red and increases
    its size to mark the final dot in each polygon. Then, it changes the pen color
    back to blue and reduces the size again.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义的`Highlight point`块只是将笔刷颜色改为红色，并增加其大小，以标记每个多边形中的最后一个点。然后，它将笔刷颜色恢复为蓝色，并再次减小大小。
- en: The Results
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: Let’s use the drawing program to generate some sequences. For the number of
    sides *s* = 4 we get squares, both geometrically and arithmetically, as shown
    in [Figure 4-11](ch04.xhtml#ch4fig11). Geometrically, each added layer of dots
    around the existing ones forms a new, larger square. Arithmetically, the numbers
    accumulated in the `end point list` sequence are all perfect squares. We arrived
    at these numbers by counting points, starting from the lower-left corner and moving
    counterclockwise, expanding outward with each layer of nesting. As mentioned earlier,
    when we complete a square, the number of points counted so far is added to the
    list and the point is highlighted in red.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用绘图程序生成一些数列。当边数*s* = 4时，我们得到方形，无论是几何上还是算术上，如[图 4-11](ch04.xhtml#ch4fig11)所示。从几何角度看，每添加一层点到现有点周围就形成一个新的、更大的方形。从算术角度看，`end
    point list`序列中累积的数字都是完全平方数。我们通过从左下角开始计数点，逆时针移动，并随着每一层嵌套扩展，得到了这些数字。如前所述，当我们完成一个方形时，到目前为止计数的点数会被添加到列表中，并且该点会用红色高亮显示。
- en: '![Image](../images/pg90_Image_97.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg90_Image_97.jpg)'
- en: '*Figure 4-11: Square figurate numbers*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-11：方形数*'
- en: There’s no need to restrict ourselves to squares. *Triangular numbers* are the
    sequence generated by arranging points in nested equilateral triangles, as shown
    in [Figure 4-12](ch04.xhtml#ch4fig12).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必局限于方形。*三角形数*是通过将点按嵌套等边三角形排列生成的序列，如[图 4-12](ch04.xhtml#ch4fig12)所示。
- en: '![Image](../images/pg90_Image_98.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg90_Image_98.jpg)'
- en: '*Figure 4-12: Triangular figurate numbers*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-12：三角形数*'
- en: 'Notice that each triangular number is built by adding the next integer to the
    triangular number that came before: 1, 1 + 2 = 3, 1 + 2 + 3 = 6, 1 + 2 + 3 + 4
    = 10, and so on. In other words, the *n*th triangular number is the sum of all
    the integers from 1 to *n*.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个三角形数都是通过将下一个整数加到前一个三角形数中构建的：1, 1 + 2 = 3, 1 + 2 + 3 = 6, 1 + 2 + 3 + 4
    = 10，依此类推。换句话说，第*n*个三角形数是从1到*n*所有整数的和。
- en: How can we describe the pattern of the sequence of triangular numbers with a
    formula? Think about putting a copy of the *n*th triangle next to itself, rotated
    to make a parallelogram, as shown in [Figure 4-13](ch04.xhtml#ch4fig13).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何用公式描述三角形数列的模式呢？可以考虑将第*n*个三角形复制一份并旋转，使其形成平行四边形，如[图 4-13](ch04.xhtml#ch4fig13)所示。
- en: '![Image](../images/pg91_Image_99.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg91_Image_99.jpg)'
- en: '*Figure 4-13: We can make a formula for triangular numbers by thinking about
    two triangles arranged to make a parallelogram.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-13：我们可以通过思考两个三角形排列成平行四边形的方式来推导三角形数字的公式。*'
- en: The parallelogram has *n* + 1 dots across the bottom and *n* rows of dots, so
    there are *n*(*n* + 1) dots in all. Since the parallelogram was made with two
    copies of the triangle, each triangle has *n*(*n* + 1) / 2 dots in it. There’s
    the formula for the *n*th triangular number.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个平行四边形的底部有*n* + 1个点，且有*n*行点，因此一共有*n*(*n* + 1)个点。由于这个平行四边形是由两个三角形复制而成，每个三角形中包含*n*(*n*
    + 1) / 2个点。这就是*n*阶三角形数的公式。
- en: We can make another sequence of figurate numbers, which will be of use in [Chapter
    7](ch07.xhtml#ch07), by counting points in nested pentagons. [Figure 4-14](ch04.xhtml#ch4fig14)
    shows the sequence of *pentagonal numbers*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在嵌套的五边形中数点，来生成另一个图形数列，这将在[第7章](ch07.xhtml#ch07)中派上用场。[图4-14](ch04.xhtml#ch4fig14)展示了*五边形数字*的序列。
- en: '![Image](../images/pg91_Image_100.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg91_Image_100.jpg)'
- en: '*Figure 4-14: Pentagonal figurate numbers*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-14：五边形图形数字*'
- en: There are other interesting sequences hidden in the nested pentagons. For example,
    if you count the points and write down just the numbers of those along the green
    path in [Figure 4-14](ch04.xhtml#ch4fig14), you get 1, 2, 6, 13, 23, 36, . . .
    , as the sequence. Another path that gives a sequence we’ll need in [Chapter 7](ch07.xhtml#ch07)
    starts at 2 and goes up and to the right, along the purple path in [Figure 4-14](ch04.xhtml#ch4fig14).
    Counting around the nested pentagons gives the numbers 2, 7, 15, 26, 40, 57, .
    . . , as the sequence.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套的五边形中还有其他有趣的数字序列。例如，如果你数一下这些点，并记录下沿着[图4-14](ch04.xhtml#ch4fig14)中绿色路径的点的数字，你会得到1,
    2, 6, 13, 23, 36，……这样的序列。另一个在[第7章](ch07.xhtml#ch07)中会用到的路径从2开始，沿着[图4-14](ch04.xhtml#ch4fig14)中的紫色路径向上和向右走。围绕嵌套的五边形数点得到的序列是2,
    7, 15, 26, 40, 57，……。
- en: Hacking the Code
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: Even if you set the wait time in the `Draw n segment(s)` block ([Figure 4-10](ch04.xhtml#ch4fig10)
    ❶) to `0`, there’s still a delay in drawing the polygons and reporting the values
    of the sequence of figurate numbers. If you want the results right away, you can
    speed up the program by using Turbo Mode (see [Figure 4-15](ch04.xhtml#ch4fig15)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你将`绘制n段`积木中的等待时间（[图4-10](ch04.xhtml#ch4fig10) ❶）设置为`0`，在绘制多边形和报告图形数列的值时，仍然会有延迟。如果你想立即得到结果，可以通过使用Turbo模式来加速程序（参见[图4-15](ch04.xhtml#ch4fig15)）。
- en: '![Image](../images/pg92_Image_101.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg92_Image_101.jpg)'
- en: '*Figure 4-15: Turning on Turbo Mode*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-15：开启Turbo模式*'
- en: Turbo Mode is a feature that eliminates the short pause that Scratch usually
    inserts after running blocks that update the screen. To turn it on, select **Edit
    ▸ Turn on Turbo Mode** in the Scratch Editor or hold down SHIFT while clicking
    the green flag button. When Turbo Mode is activated, there’s an indication in
    the menu bar.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Turbo模式是一个功能，能够消除Scratch在运行更新屏幕的积木后通常会插入的短暂停顿。要开启Turbo模式，请在Scratch编辑器中选择**编辑
    ▸ 开启Turbo模式**，或在点击绿色旗帜按钮时按住SHIFT键。当Turbo模式激活时，菜单栏会有相应的指示。
- en: Predicting Values in a Sequence
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预测序列中的值
- en: Whenever you see the first few terms in a sequence, a natural question is “What
    comes next?” One possible answer is “Whatever you want!” If all you know is that
    there are some numbers listed one after the other, then any number can come next.
    But if you assume that the numbers mean something—that they’re generated by following
    some kind of rule—then figuring out what comes next requires discovering the rule
    and applying it to generate the later terms. There may be more than one rule that
    works, in which case you can pick the one that seems most natural or useful to
    you.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你看到一个序列的前几个项时，大家都会自然地问：“接下来是什么？”一个可能的回答是：“随便你想要什么！”如果你只知道有一些数字一个接一个地列出，那么任何数字都可以是接下来的项。但如果你假设这些数字有某种意义——也就是说，它们是通过某种规则生成的——那么要弄清楚接下来是什么，就需要发现这个规则，并将其应用到后面的项上。可能存在多个符合条件的规则，在这种情况下，你可以选择最自然或最有用的那个规则。
- en: For example, consider the sequence of square numbers in [Figure 4-11](ch04.xhtml#ch4fig11).
    We could predict the next number in the sequence by finding the rule that the
    *n*th element in the sequence is *n*². The element after 9² = 81 should, then,
    be 10² = 100\. Alternatively, we could notice that for each new (geometric) square,
    we’re building on the squares that came before by adding another shell of dots
    along the top and right sides. The *n*th shell adds the *n*th odd number (2*n*
    – 1) of points to the total (so the sequence could be described as 1, 1 + 3, 1
    + 3 + 5, 1 + 3 + 5 + 7, . . .). This is an example of an *addition rule*, and
    it highlights a different aspect of the pattern. Thinking this way, we would get
    from the ninth number in the sequence (81) to the tenth number by adding (2 ⋅
    10) – 1 = 19, giving us 81 + 19 = 100\. Either way, we make the same prediction,
    but we describe what’s going on differently.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑[图 4-11](ch04.xhtml#ch4fig11)中的平方数列。我们可以通过找到规则来预测数列中的下一个数字，即数列中的第*n*项是*n*²。9²
    = 81之后的元素应该是10² = 100。或者，我们可以注意到，对于每一个新的（几何）平方，我们都是在前面的平方基础上，沿着上边和右边添加了一层新的点。第*n*层会添加第*n*个奇数（2*n*
    - 1）个点到总数中（因此数列可以描述为 1, 1 + 3, 1 + 3 + 5, 1 + 3 + 5 + 7, ……）。这是一个*加法规则*的例子，它揭示了规律的另一个方面。从这个角度考虑，我们可以通过在第九个数（81）上加上（2
    ⋅ 10）– 1 = 19，得到 81 + 19 = 100。无论哪种方式，我们都会做出相同的预测，但我们对其描述方式不同。
- en: 'Project 17: Difference Tables Make All the Difference'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目 17：差分表带来的巨大变化
- en: One way to understand the pattern in a sequence built with some sort of addition
    rule is to undo the addition by doing a subtraction. A *difference table* for
    a sequence is another sequence built by subtracting each term of the original
    sequence from the next one. In this project, we’ll explore how to use Scratch
    to create difference tables.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 了解一个数列的规律，尤其是使用某种加法规则构建的数列，可以通过减法来逆转加法操作。一个数列的*差分表*是通过将原始数列的每个项与下一个项进行相减而得到的另一个数列。在这个项目中，我们将探讨如何使用
    Scratch 来创建差分表。
- en: If one difference table isn’t enough to reveal a sequence’s pattern, we can
    create a second difference table by finding the differences between adjacent numbers
    in the first difference table. These are known as the *second differences* of
    the original sequence. If necessary, we can then make a third difference table
    based on the second, and so on. Sometimes, interesting patterns emerge from this
    process.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个差分表无法揭示数列的规律，我们可以通过在第一个差分表中找到相邻数字的差值来创建第二个差分表。这些差值被称为原始数列的*第二差分*。如果有需要，我们可以基于第二差分表再创建第三差分表，以此类推。有时，通过这个过程会出现有趣的规律。
- en: '[Figure 4-16](ch04.xhtml#ch4fig16) shows some Scratch code to take in a sequence
    and generate its difference table.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-16](ch04.xhtml#ch4fig16)展示了部分 Scratch 代码，用于输入一个数列并生成其差分表。'
- en: '![Image](../images/pg93_Image_102.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg93_Image_102.jpg)'
- en: '*Figure 4-16: Building a difference table to analyze a sequence*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-16：构建差分表以分析一个数列*'
- en: First, the `initialize` block clears out the data from the last time the program
    was run. Then, the `repeat until` loop ➊ prompts us to enter a sequence, one number
    at a time, until we let Scratch know we’re done by entering an `x`. The sequence
    is stored in the `seq` list. We then build the first difference table in the `1st`
    list by calculating the differences between adjacent values in the sequence ➋.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`initialize` 块清空了上次运行程序时的数据。然后，`repeat until` 循环 ➊ 提示我们一次输入一个数，直到我们通过输入 `x`
    告诉 Scratch 我们已经完成了。数列被存储在 `seq` 列表中。接着，我们通过计算数列中相邻值之间的差值来构建第一个差分表，并将其存储在 `1st`
    列表中 ➋。
- en: The additional code in [Figure 4-17](ch04.xhtml#ch4fig17) finds the second and
    third differences, storing them in the `2nd` and `3rd` lists.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-17](ch04.xhtml#ch4fig17)中的附加代码计算了第二和第三差分，并将它们存储在 `2nd` 和 `3rd` 列表中。'
- en: '![Image](../images/pg94_Image_103.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg94_Image_103.jpg)'
- en: '*Figure 4-17: Calculating the second and third differences*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-17：计算第二和第三差分*'
- en: This code segment follows the same pattern we used to calculate the first difference
    table, except we use the `1st` and `2nd` lists as input instead of using `seq`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段遵循了我们计算第一个差分表时使用的相同模式，只不过我们这次使用 `1st` 和 `2nd` 列表作为输入，而不是使用 `seq`。
- en: The Results
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 结果
- en: '[Figure 4-18](ch04.xhtml#ch4fig18) shows the result of running the difference
    table program for the first several values from the sequence of squares: 1, 4,
    9, 16, 25, 36, 49, 64, and 81.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-18](ch04.xhtml#ch4fig18)展示了运行差分表程序后，来自平方数列的前几个值的结果：1，4，9，16，25，36，49，64
    和 81。'
- en: '![Image](../images/pg94_Image_104.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg94_Image_104.jpg)'
- en: '*Figure 4-18: Difference tables for the sequence of squares*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-18：平方数序列的差异表*'
- en: 'The first difference table confirms what we discussed earlier: the differences
    are successive odd numbers, meaning the *n*th number in the sequence is the sum
    of the first *n* odd numbers. The second differences are constant: they’re all
    equal to 2, since successive odd numbers are always 2 apart. The third differences
    are all 0.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次差异表确认了我们之前讨论的内容：差异是连续的奇数，意味着序列中的第 *n* 个数字是前 *n* 个奇数的总和。第二次差异是恒定的：它们都等于 2，因为连续的奇数之间总是相差
    2。第三差异都为 0。
- en: 'Third differences of 0 are a dead giveaway that the sequence’s underlying rule
    of formation can be given as a *quadratic polynomial*, an expression of the form
    *ax*² + *bx* + *c*. Writing the rule of formation then becomes a matter of determining
    the values of *a*, *b*, and *c*, known as *coefficients*. For the sequence of
    square numbers, it’s especially easy to write the quadratic polynomial: we can
    use *a* = 1, *b* = 0, and *c* = 0\. This gives us:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第三差异为 0 是一个明显的标志，表明序列的基础形成规则可以用 *二次多项式* 给出，形式为 *ax*² + *bx* + *c*。因此，写出形成规则就变成了确定
    *a*、*b* 和 *c* 的值，这些值被称为 *系数*。对于平方数序列，写出二次多项式尤其容易：我们可以使用 *a* = 1, *b* = 0, 和 *c*
    = 0。这样我们得到：
- en: '![Image](../images/pg95_Image_105.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg95_Image_105.jpg)'
- en: 'For the triangular numbers from [Figure 4-13](ch04.xhtml#ch4fig13), we can
    use *a* = 1/2, *b* = 1/2, and *c* = 0\. Then we get:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于来自[图 4-13](ch04.xhtml#ch4fig13)的三角形数，我们可以使用 *a* = 1/2, *b* = 1/2, 和 *c* =
    0。然后我们得到：
- en: '![Image](../images/pg95_Image_106.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg95_Image_106.jpg)'
- en: This is the same rule we arrived at before by treating two copies of the triangle
    as a parallelogram.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前通过将两个三角形复制并视为平行四边形得出的规则相同。
- en: Hacking the Code
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破解代码
- en: Here’s a Scratch trick to make programs with lists easier to use. Suppose you
    have a list of numbers from another program—for example, the pentagonal numbers
    you generated with the code from [Project 16](ch04.xhtml#ch04lev9) ([Figure 4-14](ch04.xhtml#ch4fig14))—and
    you want to bring them into your difference table program for analysis. Rather
    than copying over the numbers by hand, one by one, you can export the whole list
    from that project by right-clicking it and selecting **Export** (see [Figure 4-19](ch04.xhtml#ch4fig19)).
    This will save the list as a text file called *end point list.txt* (or whatever
    the name of the list is) in your default directory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个 Scratch 技巧，可以让程序中使用列表变得更容易。假设你有另一个程序中的数字列表——例如，使用[项目 16](ch04.xhtml#ch04lev9)中的代码生成的五边形数([图
    4-14](ch04.xhtml#ch4fig14))——并且你想将它们带入差异表程序进行分析。你可以通过右键点击该列表并选择 **导出** 来导出该列表，而不是逐一手动复制数字（见[图
    4-19](ch04.xhtml#ch4fig19)）。这样会将列表保存为名为 *end point list.txt*（或者任何列表的名称）的文本文件，保存在你的默认目录中。
- en: '![Image](../images/pg95_Image_107.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg95_Image_107.jpg)'
- en: '*Figure 4-19: Saving a list for later use*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-19：保存列表以备后用*'
- en: To use that list in the difference table program, ignore the prompt to enter
    a number and instead right-click the `seq` list on the stage. Click **Import**,
    as shown in [Figure 4-20](ch04.xhtml#ch4fig20), and select the file you just saved
    to upload it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要在差异表程序中使用该列表，请忽略输入数字的提示，右键点击舞台上的 `seq` 列表。点击 **导入**，如[图 4-20](ch04.xhtml#ch4fig20)所示，然后选择你刚刚保存的文件进行上传。
- en: '![Image](../images/pg96_Image_108.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg96_Image_108.jpg)'
- en: '*Figure 4-20: Recovering a list for further work*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-20：恢复列表以进行进一步工作*'
- en: The `seq` list will now be populated with the pentagonal numbers, so you need
    to enter only an `x` into the prompt to have the differences calculated. [Figure
    4-21](ch04.xhtml#ch4fig21) shows the results.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`seq` 列表现在将填充五边形数，因此你只需要在提示符中输入一个 `x`，就能计算差异。[图 4-21](ch04.xhtml#ch4fig21)展示了结果。'
- en: '![Image](../images/pg96_Image_109.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg96_Image_109.jpg)'
- en: '*Figure 4-21: Difference tables for the sequence of pentagonal numbers*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-21：五边形数序列的差异表*'
- en: What do you know? Again, the third differences are all 0, so the sequence of
    pentagonal numbers can be generated using a quadratic polynomial too!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道什么吗？再次地，第三差异都为 0，因此五边形数序列也可以通过二次多项式生成！
- en: '![Image](../images/pg26_Image_12.jpg) Programming Challenges'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pg26_Image_12.jpg) 编程挑战'
- en: '**4.4** Write a Scratch program that takes any sequence with third differences
    of 0 and recovers the coefficients *a*, *b*, and *c* for that sequence’s quadratic
    polynomial, *ax*² + *bx* + *c*. Use the program to find the coefficients for the
    pentagonal numbers. If all you want is the pentagonal number formula, it might
    help to draw the *n*th pentagon the way a young child draws a house, as a square
    with a triangular roof on top, and see it as the *n*th square with the (*n* –
    1)st triangle on top.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.4** 编写一个 Scratch 程序，它可以处理任何第三差分为 0 的序列，并恢复该序列的二次多项式系数 *a*、*b* 和 *c*，即 *ax*²
    + *bx* + *c*。使用该程序查找五边形数的系数。如果你只想要五边形数的公式，试着像小孩子画房子一样画第 *n* 个五边形，将它看作是第 *n* 个正方形上方加上第
    (*n* – 1) 个三角形。'
- en: '**4.5** If you exported the list of primes generated by the sieving program
    from [Project 7](ch02.xhtml#ch02lev10), import it into the difference table program
    and see what happens. The first few results are shown here. As you can see, there
    isn’t such a neat pattern of differences. Write some code to find the largest
    difference in the table of first differences.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.5** 如果你将 [项目 7](ch02.xhtml#ch02lev10) 中通过筛法生成的素数列表导出，并将其导入差分表程序中，看看会发生什么。这里显示了前几个结果。如你所见，差分并没有形成如此整齐的模式。编写一些代码来查找第一差分表中最大的差值。'
- en: '![Image](../images/pg97_Image_110.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg97_Image_110.jpg)'
- en: '**4.6** Generate a sequence with this rule: the *n*th term of the sequence
    is the number of occurrences of the digit 1 in the binary representation of *n*.
    This sequence starts 1, 1, 2, 1, 2, 2, 3, . . . , (from counting 1s in the binary
    sequence 1, 10, 11, 100, 101, 110, 111, . . .). Write a Scratch program to calculate
    a few hundred terms of this sequence and see if you can find either a formula
    or a recurrence relation to predict future terms.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.6** 根据这个规则生成一个序列：序列的第 *n* 项是 *n* 的二进制表示中数字 1 出现的次数。这个序列从 1 开始，1, 1, 2,
    1, 2, 2, 3, . . . ，（通过计算二进制序列 1, 10, 11, 100, 101, 110, 111, . . . 中的 1 的个数）。编写一个
    Scratch 程序来计算这个序列的几百项，并看看你能否找到一个公式或递推关系来预测未来的项。'
- en: '**4.7** What happens when you make a difference table of the Fibonacci sequence?'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.7** 当你对斐波那契数列制作差分表时，会发生什么？'
- en: '**4.8** What happens when you make a difference table of the sequence of powers
    of 2?'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.8** 当你对 2 的幂次序列制作差分表时，会发生什么？'
- en: '**4.9** Try creating a difference table of the sequence of cubes (1, 8, 27,
    64, 125, . . .). You can extend the code from [Figure 4-17](ch04.xhtml#ch4fig17)
    to get higher differences to explore difference tables for higher-degree polynomials.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.9** 尝试对立方数列（1, 8, 27, 64, 125, . . .）创建差分表。你可以扩展[图 4-17](ch04.xhtml#ch4fig17)中的代码，得到更高次差分，从而探索高次多项式的差分表。'
- en: Conclusion
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: Lists in Scratch are great for keeping track of sequences of numbers, and list
    arithmetic helps us make sense of the patterns that show up. Scratch graphics
    use geometry to animate sequences of figurate numbers, and difference tables make
    the patterns in these sequences easier to see. Scratch Cat has all the answers—your
    job is to ask the questions!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scratch 中，列表非常适合追踪数字序列，而列表运算帮助我们理解其中出现的模式。Scratch 图形使用几何学来动画化具象数列，而差分表使这些数列中的模式更加易于识别。Scratch
    Cat 拥有所有答案——你的任务是提出问题！
