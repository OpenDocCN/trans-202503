- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: WORKING WITH LISTS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 处理列表
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: People naturally make lists. Whether it’s a bucket list, shopping list, or list
    of top ten favorite books, an ordered sequence of items that share something in
    common sits easy on the brain. The history of functional programming is entwined
    with that of lists. The early functional language Lisp even has a name that is
    short for “list processor.” In Haskell, lists are just as important because the
    way we think about iteration in functional programming is often in terms of constructing
    a list and then using it to produce the result we want.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 人们天生就会列出清单。无论是愿望清单、购物清单，还是最喜欢的十本书清单，所有有共同点的项按顺序排列都容易被大脑处理。函数式编程的历史与列表紧密相连。早期的函数式语言Lisp甚至有一个名字，Lisp是“list
    processor”的缩写。在Haskell中，列表同样重要，因为我们在函数式编程中思考迭代的方式，通常是构建一个列表，然后使用它来产生我们想要的结果。
- en: In this chapter, we’ll learn about lists and the functions that work with them.
    We’ll start off with list basics, such as how to construct a list, how to select
    a particular element of a list, and how to concatenate lists. We’ll then see how
    to give a type to a list. Lists of numbers have a special role to play. There
    is special syntax for arithmetic sequences, and there are multiple Prelude functions
    for working with lists of numbers. After that, we’ll introduce the idea of type
    variables. We’ll take a short diversion to talk about type conversion before introducing
    list comprehension, a very useful way to form new lists from old. We’ll end the
    chapter with pattern matching, identifying the data constructors for the list
    type.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于列表及其相关函数的内容。我们将从列表基础开始，例如如何构造列表，如何选择列表中的特定元素，以及如何连接列表。然后我们将学习如何为列表指定类型。数字列表有特殊的作用。对于算术序列有特殊的语法，而且有多个Prelude函数用于操作数字列表。接下来，我们将介绍类型变量的概念。我们将稍微偏离话题讨论类型转换，然后介绍列表推导式，这是一种非常有用的从旧列表形成新列表的方式。最后，我们将通过模式匹配结束本章，了解列表类型的数据构造器。
- en: List Basics
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表基础
- en: 'A *list* in Haskell is an ordered sequence of data, all with the same type.
    Here is an example of a list:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中，*列表*是一个有序的数据序列，所有元素类型相同。以下是一个列表的示例：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The type `[String]` indicates that `physicists` is a list of `String`s.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`[String]`表示`physicists`是一个`String`类型的列表。
- en: Square brackets around the type indicate a list. A list with type `[String]`
    can have any number of items (including zero), but each item must have type `String`.
    In the second line, we define physicists by enclosing its elements in square brackets
    and separating the elements by commas. The empty list is denoted as [].
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 类型周围的方括号表示一个列表。一个类型为`[String]`的列表可以有任意数量的项（包括零），但每个项必须是`String`类型。在第二行，我们通过将物理学家元素用方括号括起来，并用逗号分隔元素来定义物理学家。空列表用[]表示。
- en: Using the type synonym
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型同义词
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'here is a list of real numbers:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实数列表：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Selecting an Element from a List
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从列表中选择一个元素
- en: The list element operator !! can be used to learn the value of an individual
    element of a list. We use the operator between the list and the place, or *index*,
    of the element we want. The first element of a list is considered to be element
    number 0.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表元素操作符`!!`可以用来获取列表中单个元素的值。我们在列表和元素的位置（或*索引*）之间使用该操作符。列表的第一个元素被视为第0个元素。
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first command loads the file *Lists.hs*, which contains the code in this
    chapter. This file, along with code files for other chapters, is available at
    [https://lpfp.io](https://lpfp.io). After the file is loaded, we can make reference
    to velocities, a name that would be unknown to GHCi before we loaded the file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令加载文件*Lists.hs*，该文件包含本章的代码。此文件以及其他章节的代码文件可以在[https://lpfp.io](https://lpfp.io)找到。加载文件后，我们可以引用`velocities`，这个名字在加载文件之前对GHCi是未知的。
- en: Concatenating Lists
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接列表
- en: Lists of the same type can be concatenated with the ++ operator shown in [Table
    1-2](ch01.xhtml#ch1tab2). For example, if we have another list that has type `[R]`,
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 相同类型的列表可以使用`++`操作符进行连接，如[表1-2](ch01.xhtml#ch1tab2)所示。例如，如果我们有另一个类型为`[R]`的列表，
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'we can concatenate `velocities` with this list:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`velocities`与这个列表连接起来：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the concatenation has the same type that each component list has,
    in this case `[R]`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，连接后的列表类型与每个组成列表的类型相同，在这个例子中是`[R]`。
- en: Attempting to concatenate lists with different underlying types produces an
    error. For example, `physicists ++ velocities` gives an error.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试连接不同底层类型的列表会产生错误。例如，`physicists ++ velocities`会报错。
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This sort of error is called a *type error*. While `physicists` has a well-defined
    type, namely `[String]`, and `velocities` has a well-defined type, namely `[R]`,
    the expression `physicists ++ velocities` cannot be given a well-defined type.
    A type error results when we attempt to apply a function (in this case, the function
    is the concatenation operator `++`) that expects input of one type to a value
    that actually has a different type. The concatenation operator expects its second
    argument to have type `[String]` because `physicists` has type `[String]`. However,
    we gave a second argument of `velocities`, which has type `[R]` and thus does
    not match `[String]`. In [Chapter 6](ch06.xhtml), we will discuss the type of
    the concatenation operator.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误被称为 *类型错误*。虽然 `physicists` 有明确的类型，即 `[String]`，而 `velocities` 有明确的类型，即 `[R]`，但是表达式
    `physicists ++ velocities` 无法得到一个明确的类型。类型错误发生在我们试图对一个期望某种类型输入的函数（在这种情况下是连接操作符
    `++`）应用一个实际上具有不同类型的值时。连接操作符期望它的第二个参数类型是 `[String]`，因为 `physicists` 的类型是 `[String]`。然而，我们给了一个第二个参数
    `velocities`，它的类型是 `[R]`，因此与 `[String]` 不匹配。在 [第六章](ch06.xhtml) 中，我们将讨论连接操作符的类型。
- en: Let’s try to understand the error message. The word “interactive” ➊ indicates
    that the error occurred at the GHCi prompt, rather than in a source code file.
    The numbers ➊ are the line number and column number where the error occurred.
    This is useful information for an error in a source code file, but it is not really
    needed for an error at the GHCi prompt. The text “Couldn’t match type” ➋ indicates
    a type error. The types that don’t match are `Double` and `[Char]` ➋. Since `R`
    is a type synonym for `Double` and `String` is a type synonym for `[Char]`, as
    we will see later in the chapter, the compiler tells us that `R` and `String`
    do not match.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着理解错误信息。单词“interactive” ➊ 表示错误发生在 GHCi 提示符下，而不是在源代码文件中。数字 ➊ 是错误发生的行号和列号。这对于源代码文件中的错误是有用的信息，但对于
    GHCi 提示符下的错误来说其实并不需要。“Couldn’t match type” ➋ 表示类型错误。类型不匹配的是 `Double` 和 `[Char]`
    ➋。由于 `R` 是 `Double` 的类型别名，而 `String` 是 `[Char]` 的类型别名，正如我们在本章稍后会看到的，编译器告诉我们 `R`
    和 `String` 不匹配。
- en: Next, the compiler tells us that a function expected an expression with type
    `[String]` (the “Expected type”) ➌ but was actually given an expression with type
    `[R]` (the “Actual type”) ➍. The error message then tells us that the location
    of this discrepancy is the second argument of the `++` operator ➎. It’s useful
    to be able to read type errors like this. There is no shame in making such an
    error. The compiler is helping us by checking that what we say makes sense. In
    physics, we can use Haskell’s type system to great advantage by assigning different
    types to different conceptual entities. We know, for example, that it makes no
    sense to add a number to a vector. By giving numbers and vectors different types,
    we engage Haskell’s type system to help us ensure that the code we write does
    not attempt to add a number to a vector.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编译器告诉我们一个函数期望一个类型为 `[String]` 的表达式（“预期类型”） ➌，但实际上给定了一个类型为 `[R]` 的表达式（“实际类型”）
    ➍。错误信息接着告诉我们，这个不匹配的地方是在 `++` 操作符的第二个参数 ➎。能够阅读像这样的类型错误是非常有用的。犯这样的错误并不丢脸。编译器通过检查我们的代码来帮助我们确保它的合理性。在物理学中，我们可以通过为不同的概念实体分配不同的类型，充分利用
    Haskell 的类型系统。例如，我们知道把一个数字加到一个向量上是没有意义的。通过给数字和向量不同的类型，我们利用 Haskell 的类型系统来确保我们编写的代码不会试图将数字加到向量上。
- en: Any number of lists of the same type can be concatenated with the `concat` function.
    If we define a list of strings,
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型相同的多个列表都可以通过 `concat` 函数进行连接。如果我们定义一个字符串列表，
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'then we can make the following concatenation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以进行如下的连接：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Arithmetic Sequences
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 算术序列
- en: 'An *arithmetic sequence* is a list formed with two dots (..), like so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*算术序列* 是一个由两个点（..）形成的列表，像这样：'
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The list ns contains the integers from 0 to 10\. I chose the name ns because
    it looks like the plural of the name n, which seems like a good name for an integer.
    It is a common style in Haskell programs to use names that end in s for lists,
    but it is by no means necessary.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 ns 包含从 0 到 10 的整数。我选择了名称 ns，因为它看起来像是 n 的复数形式，而 n 似乎是一个整数的好名字。在 Haskell 程序中，使用以
    s 结尾的名字来表示列表是一种常见的风格，但这并不是必须的。
- en: 'If we enter a list into GHCi, GHCi will evaluate each element and return the
    list of evaluated elements:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入一个列表到 GHCi，GHCi 将会评估每个元素并返回评估后的元素列表：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we give GHCi an arithmetic sequence, GHCi will expand the sequence for us:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们给 GHCi 输入一个算术序列，GHCi 会为我们展开这个序列：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A second form of arithmetic sequence allows us to increment from one term to
    the next with a value that is different from 1:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种算术数列形式允许我们通过一个不同于1的值从一个项递增到下一个项：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this second form, we specify the first, second, and last entries of the
    desired list. We can even do a decreasing list:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种形式中，我们指定所需列表的第一个、第二个和最后一个条目。我们甚至可以做一个递减的列表：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: List Types
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列表类型
- en: '*List types* are a second way to form a new type from an existing type (the
    first way being function types, as we saw in “Function Types” in [Chapter 3](ch03.xhtml)).
    Given any type `a` (`Int`, `Integer`, `Double`, and so on), there is a type `[a]`
    for lists with elements of type `a`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表类型* 是从现有类型形成新类型的第二种方式（第一种方式是函数类型，正如我们在[第3章](ch03.xhtml)中的“函数类型”部分所看到的）。给定任何类型
    `a`（如 `Int`、`Integer`、`Double` 等），都有一个类型 `[a]` 用于表示元素类型为 `a` 的列表。'
- en: You can, for example, make a list of functions. Recall the square function we
    defined in [Chapter 2](ch02.xhtml).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以制作一个函数列表。回想一下我们在[第2章](ch02.xhtml)中定义的平方函数。
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can define the following list, where cos and sin are functions defined in
    the Haskell Prelude:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义以下列表，其中 `cos` 和 `sin` 是在 Haskell Prelude 中定义的函数：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Why would we want a list of functions? One reason will show up in [Chapter 11](ch11.xhtml)
    when we meet a function that takes a list of functions and plots them all on the
    same set of axes. A second reason appears in [Chapter 14](ch14.xhtml) when the
    forces that act on an object are functions of time or velocity. Our function for
    solving Newton’s second law will take a list of these force functions to describe
    the forces that act on the object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要一个函数列表呢？其中一个原因会在[第11章](ch11.xhtml)中出现，当我们遇到一个接受函数列表并将它们绘制在同一坐标轴上的函数时。第二个原因出现在[第14章](ch14.xhtml)，当作用于物体的力是时间或速度的函数时。我们用于求解牛顿第二定律的函数将接受这些力函数的列表，以描述作用于物体的力。
- en: Functions for Lists of Numbers
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数字列表的函数
- en: Haskell has a few Prelude functions that work with lists of numbers. The first
    two are `sum` and `product`, shown in [Table 5-1](ch05.xhtml#ch5tab1). As you
    might expect from its name, `sum` returns the sum of the items in a list, returning
    `0` for the empty list. The function `product` returns the product of the items
    in a list, returning `1` for the empty list. The functions `maximum` and `minimum`
    return the largest and smallest items in a list, respectively, producing errors
    if you give them the empty list.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 提供了几个可以与数字列表一起使用的 Prelude 函数。前两个是 `sum` 和 `product`，如[表5-1](ch05.xhtml#ch5tab1)所示。正如你从名称中可能猜到的那样，`sum`
    返回列表中项的和，对于空列表返回 `0`。`product` 函数返回列表中项的积，对于空列表返回 `1`。`maximum` 和 `minimum` 函数分别返回列表中的最大值和最小值，如果给它们传递空列表，则会产生错误。
- en: '**Table 5-1:** Functions for Lists of Numbers'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-1：** 数字列表的函数'
- en: '| **Expression** |  | **Evaluates to** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **计算结果** |'
- en: '| --- | --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `sum [3,4,5]` | ⇝ | `12` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `sum [3,4,5]` | ⇝ | `12` |'
- en: '| `sum []` | ⇝ | `0` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `sum []` | ⇝ | `0` |'
- en: '| `product [3,4,5]` | ⇝ | `60` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `product [3,4,5]` | ⇝ | `60` |'
- en: '| `product []` | ⇝ | `1` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `product []` | ⇝ | `1` |'
- en: '| `maximum [4,5,-2,1]` | ⇝ | `5` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `maximum [4,5,-2,1]` | ⇝ | `5` |'
- en: '| `minimum [4,5,-2,1]` | ⇝ | `-2` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `minimum [4,5,-2,1]` | ⇝ | `-2` |'
- en: When Not to Use a List
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时不使用列表
- en: There will be times when you want to “bundle together” expressions of different
    types. For example, we may wish to form pairs composed of a person’s name (a `String`)
    and age (an `Int`). A list is not the right structure to use for this job. All
    elements of a list must have the same type. In [Chapter 9](ch09.xhtml), we’ll
    learn about *tuples*, which are a good way to bundle together items of different
    types.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要将不同类型的表达式“捆绑在一起”。例如，我们可能希望组成一对一对的项，其中包括一个人的姓名（`String`）和年龄（`Int`）。列表不是适合这种情况的结构。列表中的所有元素必须具有相同的类型。在[第9章](ch09.xhtml)中，我们将学习*元组*，它是将不同类型的项捆绑在一起的好方法。
- en: Type Variables
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型变量
- en: In the previous section, we saw how the list element operator `!!` returns a
    specified element of a list. The list element operator doesn’t care what type
    of elements the list contains. We would write `physicists !! 2` to get the number-two
    element of `physicists` in the same way that we would write `velocities !! 2`
    to get the number-two element of velocities, even though the former list has type
    `[String]` while the latter list has type `[R]`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到列表元素运算符 `!!` 返回指定的列表元素。列表元素运算符不关心列表中包含的元素类型。我们会写 `physicists !! 2`
    来获取 `physicists` 列表中的第二个元素，就像我们写 `velocities !! 2` 来获取 `velocities` 列表中的第二个元素一样，尽管前者的列表类型是
    `[String]`，而后者的列表类型是 `[R]`。
- en: There are other functions that also don’t care what element type a list has.
    [Table 5-2](ch05.xhtml#ch5tab2) shows several such functions from the Prelude.
    The types of these functions are expressed in terms of a *type variable* (`a`
    in this case). A type variable must start with a lowercase letter and can stand
    for any type.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些函数也不关心列表元素的类型。[表 5-2](ch05.xhtml#ch5tab2)展示了预定义函数中的几个这样的函数。这些函数的类型是通过*类型变量*（这里是`a`）表示的。类型变量必须以小写字母开头，并且可以代表任何类型。
- en: '**Table 5-2:** Some Prelude Functions for Working with Lists'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-2：** 用于处理列表的一些预定义函数'
- en: '| **Function** |  | **Type** | **Description** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **函数** |  | **类型** | **描述** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `head` | `::` | `[a] -> a` | Returns first item of list |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `head` | `::` | `[a] -> a` | 返回列表的第一个元素 |'
- en: '| `tail` | `::` | `[a] -> [a]` | Returns all but first item of list |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `tail` | `::` | `[a] -> [a]` | 返回列表中除了第一个元素的所有元素 |'
- en: '| `last` | `::` | `[a] -> a` | Returns last item of list |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `last` | `::` | `[a] -> a` | 返回列表的最后一个元素 |'
- en: '| `init` | `::` | `[a] -> [a]` | Returns all but last item of list |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `init` | `::` | `[a] -> [a]` | 返回列表中除了最后一个元素的所有元素 |'
- en: '| `reverse` | `::` | `[a] -> [a]` | Reverses order of list |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `reverse` | `::` | `[a] -> [a]` | 反转列表的顺序 |'
- en: '| `repeat` | `::` | `a` `-> [a]` | Infinite list of a single item |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `repeat` | `::` | `a` `-> [a]` | 无限重复单一项的列表 |'
- en: '| `cycle` | `::` | `[a] -> [a]` | Infinite list repeating given list |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `cycle` | `::` | `[a] -> [a]` | 无限循环给定列表 |'
- en: The function head returns the first element of a list. You can see some uses
    of head, as well as the other list functions, in [Table 5-3](ch05.xhtml#ch5tab3).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`函数返回列表中的第一个元素。你可以在[表 5-3](ch05.xhtml#ch5tab3)中看到一些`head`的使用示例，以及其他列表函数的使用示例。'
- en: '**Table 5-3:** Use of List Functions'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-3：** 列表函数的使用'
- en: '| **Expression** |  | **Evaluates to** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **计算结果** |'
- en: '| --- | --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `head ["Gal","Jo","Isaac","Mike"]` | ⇝ | `"Gal"` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `head ["Gal","Jo","Isaac","Mike"]` | ⇝ | `"Gal"` |'
- en: '| `head [1, 2, 4, 8, 16]` | ⇝ | `1` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `head [1, 2, 4, 8, 16]` | ⇝ | `1` |'
- en: '| `tail ["Gal","Jo","Isaac","Mike"]` | ⇝ | `["Jo","Isaac","Mike"]` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `tail ["Gal","Jo","Isaac","Mike"]` | ⇝ | `["Jo","Isaac","Mike"]` |'
- en: '| `tail [1, 2, 4, 8, 16]` | ⇝ | `[2,4,8,16]` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `tail [1, 2, 4, 8, 16]` | ⇝ | `[2,4,8,16]` |'
- en: '| `last ["Gal","Jo","Isaac","Mike"]` | ⇝ | `"Mike"` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `last ["Gal","Jo","Isaac","Mike"]` | ⇝ | `"Mike"` |'
- en: '| `last [1, 2, 4, 8, 16]` | ⇝ | `16` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `last [1, 2, 4, 8, 16]` | ⇝ | `16` |'
- en: '| `init ["Gal","Jo","Isaac","Mike"]` | ⇝ | `["Gal","Jo","Isaac"]` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `init ["Gal","Jo","Isaac","Mike"]` | ⇝ | `["Gal","Jo","Isaac"]` |'
- en: '| `init [1, 2, 4, 8, 16]` | ⇝ | `[1,2,4,8]` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `init [1, 2, 4, 8, 16]` | ⇝ | `[1,2,4,8]` |'
- en: '| `length ["Gal","Jo","Isaac","Mike"]` | ⇝ | `4` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `length ["Gal","Jo","Isaac","Mike"]` | ⇝ | `4` |'
- en: '| `length [1, 2, 4, 8, 16]` | ⇝ | `5` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `length [1, 2, 4, 8, 16]` | ⇝ | `5` |'
- en: The function head can accept a list of type `[Double]`, a list of type `[Char]`,
    or a list of type `[Int]`. Because `head` doesn’t care about the type of the payload,
    the best way of expressing the type of input `head` takes is by using a type variable
    `a` to say that `head` accepts an input of type `[a]`. The same type variable
    `a` appears also in the output; the return type of `head` is `a`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`函数可以接受类型为`[Double]`的列表、类型为`[Char]`的列表或类型为`[Int]`的列表。因为`head`不关心负载的类型，最好的方式是通过使用类型变量`a`来表达`head`接受`[a]`类型的输入。相同的类型变量`a`也出现在输出中；`head`的返回类型是`a`。'
- en: You can see a type variable if you ask GHCi for the type of the empty list.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查询GHCi空列表的类型，你会看到类型变量。
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let’s look at a few more of the functions from [Table 5-2](ch05.xhtml#ch5tab2).
    The tail function returns everything but the first element of a list. The function
    last returns the last element of a list. The function init returns everything
    except the last element. The book *Learn You a Haskell for Great Good!* has a
    cute picture of a caterpillar ([http://learnyouahaskell.com/starting-out#an-intro-to-lists](http://learnyouahaskell.com/starting-out#an-intro-to-lists))
    that visually explains these list functions. [Table 5-2](ch05.xhtml#ch5tab2) gives
    the types of these functions, and [Table 5-3](ch05.xhtml#ch5tab3) shows some examples
    of how to use them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一下[表 5-2](ch05.xhtml#ch5tab2)中的一些函数。`tail`函数返回列表中的所有元素，但不包括第一个元素。`last`函数返回列表中的最后一个元素。`init`函数返回列表中除了最后一个元素的所有元素。书籍《*Learn
    You a Haskell for Great Good!*》有一张可爱的毛毛虫图片（[http://learnyouahaskell.com/starting-out#an-intro-to-lists](http://learnyouahaskell.com/starting-out#an-intro-to-lists)），它形象地解释了这些列表函数。[表
    5-2](ch05.xhtml#ch5tab2)给出了这些函数的类型，[表 5-3](ch05.xhtml#ch5tab3)展示了如何使用它们的一些示例。
- en: Having introduced type variables, we are in a good position to take a short
    diversion into type conversion.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经介绍了类型变量，现在正是一个短暂探讨类型转换的好时机。
- en: Type Conversion
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'GHCi appears to allow a `Double` to be divided by an `Int`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: GHCi似乎允许`Double`与`Int`进行除法运算：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, that is not what is happening here. The number `0.4` can be a `Float`
    or a `Double`. The number `4` can be an `Int`, `Integer`, `Float`, or `Double`.
    The division operator demands that the types of the two numbers being divided
    are the same. In this case, both must be interpreted as `Float` or both as `Double`.
    Addition, subtraction, multiplication, and division require that the two expressions
    being combined have the same type. In terms of the type variables we introduced
    earlier, addition, subtraction, multiplication, and division all have type `a
    -> a -> a`, meaning that each of the two numbers being combined must have the
    same type `a`, and then the result of the operation will also have type `a`. (The
    full story of the types of arithmetic operations like addition is more complex.
    You can’t add two `String`s, but a function with type `a -> a -> a` must be able
    to accept two `String`s as input and produce a `String` as output. The missing
    piece involves the idea of type classes, which we’ll discuss in [Chapter 8](ch08.xhtml).)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是这里发生的情况。数字 `0.4` 可以是 `Float` 或 `Double`。数字 `4` 可以是 `Int`、`Integer`、`Float`
    或 `Double`。除法运算符要求被除的两个数字的类型相同。在这种情况下，两个数字必须都解释为 `Float` 或都解释为 `Double`。加法、减法、乘法和除法要求参与操作的两个表达式具有相同的类型。就我们之前介绍的类型变量而言，加法、减法、乘法和除法的类型都是
    `a -> a -> a`，意味着两个参与运算的数字必须具有相同的类型 `a`，然后运算的结果也将是类型 `a`。 （关于加法等算术运算类型的完整故事更为复杂。你不能将两个
    `String` 相加，但一个类型为 `a -> a -> a` 的函数必须能够接受两个 `String` 作为输入并产生一个 `String` 作为输出。缺少的部分涉及类型类的概念，我们将在
    [第8章](ch08.xhtml) 讨论。）
- en: The Haskell compiler will refuse to divide a `Double` by an `Int`. If we give
    explicit types to some numbers,
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 编译器会拒绝将 `Double` 除以 `Int`。如果我们给一些数字明确指定类型，
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'we can see the error the compiler produces:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到编译器生成的错误：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is another example of a type error. The first input to the division is
    a `Double`, so the “expected type” for the second argument of division is also
    `Double`. The “actual type” we supplied is `Int`, which doesn’t match. The compiler
    will similarly refuse to add a `Float` to a `Double`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个类型错误的示例。除法的第一个输入是 `Double`，因此除法的第二个参数的“期望类型”也是 `Double`。我们提供的“实际类型”是 `Int`，这不匹配。编译器同样会拒绝将
    `Float` 加到 `Double` 上。
- en: The fact that division can occur only between numbers with the same type can
    be irritating, especially if we expect the compiler to automatically convert one
    type into another. The solution is to use a type-conversion function to convert,
    say, an `Int` to a `Double`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除法操作只能发生在相同类型的数字之间，这可能会令人烦恼，尤其是当我们期望编译器自动将一种类型转换为另一种类型时。解决方案是使用一个类型转换函数，比如将一个
    `Int` 转换为 `Double`。
- en: 'There are two important type-conversion functions you may need to use from
    time to time. The first is `fromIntegral`, which converts an `Int` or `Integer`
    to some other kind of number. The compiler can usually figure out which type to
    convert to, but it demands your explicit permission through the use of this function.
    The second conversion function is `realToFrac`, which converts a `Float` to a
    `Double` or a `Double` to a `Float`. Again, you do not usually need to explicitly
    specify the type to convert to; you just need to give permission for the conversion
    to be done. Here is an example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个重要的类型转换函数，你可能需要不时使用。第一个是 `fromIntegral`，它将一个 `Int` 或 `Integer` 转换成其他类型的数字。编译器通常能够推断出应该转换成哪种类型，但它需要通过这个函数获得你的明确许可。第二个转换函数是
    `realToFrac`，它将一个 `Float` 转换为 `Double`，或者将一个 `Double` 转换为 `Float`。同样，你通常不需要明确指定要转换成的类型；你只需要允许进行转换。以下是一个示例：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The rationale behind the requirement for conversion is that, in Haskell, most
    errors are type errors. Type errors often indicate that we haven’t completely
    thought through the code we’ve written. It could be that dividing a `Double` by
    an `Int` is not what we intended and we are grateful to the type checker for producing
    an error rather than quietly converting the `Int` to a `Double`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 转换要求背后的理由是，在 Haskell 中，大多数错误是类型错误。类型错误通常意味着我们没有完全考虑过自己编写的代码。举例来说，将一个 `Double`
    除以一个 `Int` 可能不是我们所期望的，我们感谢类型检查器生成了错误，而不是悄悄地将 `Int` 转换成 `Double`。
- en: This concludes our diversion into type conversion. We can now return to our
    regularly scheduled program, namely lists.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对类型转换的简要讨论。现在我们可以回到我们正常的程序，具体来说是列表。
- en: The Length of Lists
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表的长度
- en: The Prelude provides a function length that returns the number of items in a
    list.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Prelude 提供了一个 `length` 函数，用于返回列表中项目的数量。
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the early days of Haskell, length was a simple function with a simple type.
    The type of length was `[a] -> Int`, meaning you could give length a list of anything,
    and it would give you back an integer. That was nice and simple. If we ask GHCi
    today for the type of length,
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell的早期，`length`是一个简单的函数，具有简单的类型。`length`的类型是`[a] -> Int`，意味着你可以给`length`传递一个任意类型的列表，它会返回一个整数。这很简单。如果我们今天在GHCi中查询`length`的类型，
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'we see a more complex type. This type involves the idea of a *type class*,
    which we’ll explore in [Chapter 8](ch08.xhtml). But for now, we can make our own
    length function with the simple type `[a] -> Int`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一个更复杂的类型。这个类型涉及到*类型类*的概念，我们将在[第8章](ch08.xhtml)中进行探讨。但目前，我们可以用简单的类型`[a] ->
    Int`定义自己的`length`函数：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we look at the type of `len` in GHCi,
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在GHCi中查看`len`的类型，
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: we see the simple type that we want.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了我们所需要的简单类型。
- en: There is no great advantage to defining our own length function because we are
    free to use `length` even though it has a complicated type, but understanding
    the types of the functions we use gives us real insight into what we are doing.
    We want to understand the types of the functions we write and use, and we want
    them to be as simple as they can be. There will, of course, be trade-offs between
    simplicity and power. The decision of the Haskell designers to give the `length`
    function a more complicated type means that it can be used in a wider variety
    of situations. In this case, the designers made a decision favoring power over
    simplicity. We will often favor simplicity over power.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 定义我们自己的`length`函数并没有太大好处，因为我们可以自由地使用`length`，即使它有一个复杂的类型，但是理解我们使用的函数的类型能让我们真正了解我们在做什么。我们希望理解我们编写和使用的函数的类型，并希望它们尽可能简单。当然，简洁性与功能之间会有权衡。Haskell设计者决定让`length`函数具有更复杂的类型，这意味着它可以在更广泛的场景中使用。在这种情况下，设计者做出了更偏向功能而非简洁性的决定。我们通常会偏向于简洁性而非功能性。
- en: A String Is a List of Characters
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串就是字符的列表
- en: 'Now that I have introduced lists, I can tell you that a string in Haskell is
    nothing but a list of characters. In other words, the type `String` is exactly
    the same as the type `[Char]`; in fact, `String` is defined in the Haskell Prelude
    to be a type synonym for `[Char]` in exactly the same way that we defined `R`
    to be a type synonym for `Double`. Haskell provides some special syntax for strings,
    namely the ability to enclose a sequence of characters in double quotes to form
    a `String`. This is obviously more pleasant than requiring an explicit list of
    characters, such as `[''W'',''h'',''y'',''?'']`. You can ask GHCi whether this
    is the same as "Why?":'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经介绍了列表，可以告诉你，在Haskell中，字符串不过是一个字符的列表。换句话说，`String`类型与`[Char]`类型完全相同；事实上，`String`在Haskell预定义模块中被定义为`[Char]`的类型同义词，正如我们将`R`定义为`Double`的类型同义词一样。Haskell为字符串提供了一些特殊的语法，特别是能将一串字符用双引号括起来，从而形成一个`String`。显然，这比要求显式列出字符列表（如`['W','h','y','?']`）要更加方便。你可以在GHCi中检查这是否与"Why?"相同：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: GHCi responds with True, indicating that it regards these two expressions as
    identical.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: GHCi返回True，表示它认为这两个表达式是相同的。
- en: The identity of the types `String` and `[Char]` also means that a string can
    be used in any function that expects a list of something. For example, we can
    use the function length on a string to tell us how many characters it has.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`和`[Char]`这两种类型的身份也意味着字符串可以在任何期望接收某种类型列表的函数中使用。例如，我们可以在一个字符串上使用`length`函数来告诉我们它包含多少个字符。'
- en: Readers who have some experience with programming may worry about the efficiency
    implications of representing strings as lists of characters. Rest assured that
    Haskell has some other options that are more efficient for programmers who need
    to process a lot of strings. However, for our purposes, we will not need to process
    a lot of strings, so the basic `String` type is just fine for us.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些编程经验的读者可能会担心将字符串表示为字符列表的效率问题。请放心，Haskell还有一些更高效的选项，适用于那些需要处理大量字符串的程序员。然而，就我们目前的需求而言，我们不需要处理大量字符串，因此基本的`String`类型完全足够了。
- en: List Comprehensions
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表推导式
- en: Haskell offers a powerful way to make new lists out of old lists. Suppose you
    have a list of times (in seconds),
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell提供了一种强大的方法，用新的列表从旧的列表中生成。假设你有一个时间列表（单位为秒），
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'and you want to have a list of positions for a rock that you threw up in the
    air at 30 m/s, with each position corresponding to one of the times in the time
    list. In Exercise 2.2, you wrote a function `yRock30` to produce the position
    of the rock when given the time. Perhaps your function looked something like the
    following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望得到一个位置列表，表示你以30米/秒的速度将一块石头抛向空中，每个位置对应时间列表中的某个时间点。在练习2.2中，你编写了一个`yRock30`函数来计算给定时间的石头位置。也许你的函数看起来像下面这样：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The code below produces the desired list of positions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成所需的位置列表：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The definition of `xs` is an example of a *list comprehension*. The syntax
    for a list comprehension consists of square brackets, a vertical bar, and a left
    arrow, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`xs`的定义是一个*列表推导式*的例子。列表推导式的语法包括方括号、竖线和左箭头，如下所示：'
- en: '[ function of *item* | *item* >- *list* ]'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 函数 *item* | *item* >- *list* ]'
- en: This means that, given a function and a list, Haskell will compute that function
    for each item in the list and then form a list of the resulting values. In our
    example above, for each `t` in `ts`, Haskell will compute `yRock30 t` and form
    a list of these values. The list `xs` of positions will be the same length as
    the original list `ts` of times.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，给定一个函数和一个列表，Haskell会对列表中的每个元素计算该函数，然后形成一个包含计算结果值的列表。在我们上面的例子中，对于`ts`中的每个`t`，Haskell会计算`yRock30
    t`并形成这些值的列表。位置列表`xs`将与原始的时间列表`ts`具有相同的长度。
- en: List comprehensions, in conjunction with the `sum` and `product` functions,
    allow us to write elegant Haskell expressions that mimic the sigma and pi notation
    in mathematics for sums and products. [Table 5-4](ch05.xhtml#ch5tab4) shows the
    correspondence between mathematical and Haskell notations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式与`sum`和`product`函数结合使用，使我们能够编写优雅的Haskell表达式，模拟数学中的求和和求积符号（sigma和pi表示法）。[表5-4](ch05.xhtml#ch5tab4)展示了数学表示法与Haskell表示法之间的对应关系。
- en: '**Table 5-4:** Sum and Product Notation in Haskell'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-4：** Haskell中的求和和积符号'
- en: '| **Mathematical notation** | **Haskell notation** |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **数学表示法** | **Haskell表示法** |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ![Image](Images/061equ01.jpg) | `sum [f(i) &#124; i <- [m..n]]` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| ![Image](Images/061equ01.jpg) | `sum [f(i) &#124; i <- [m..n]]` |'
- en: '| ![Image](Images/061equ02.jpg) | `product [f(i) &#124; i <- [m..n]]` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| ![Image](Images/061equ02.jpg) | `product [f(i) &#124; i <- [m..n]]` |'
- en: Infinite Lists
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无穷列表
- en: Haskell is a lazy language, meaning that it does not always evaluate everything
    in the order you might expect. Instead, it waits to see if values are needed before
    doing any actual work. Haskell’s laziness allows for the possibility of infinite
    lists. Of course, Haskell never actually creates an infinite list, but you can
    think of the list as infinite because Haskell is willing to continue down the
    list as far as it needs to. The list [1..] is an example of an infinite list.
    If you ask GHCi to show you this list, it will go on indefinitely. You can enter
    CTRL-C or something similar to stop the endless printing of numbers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell是一种懒惰语言，这意味着它并不总是按照你预期的顺序计算所有内容。相反，它会等待查看是否需要某些值，然后才会实际执行工作。Haskell的懒惰特性使得无穷列表成为可能。当然，Haskell并不会实际创建一个无穷列表，但你可以把这个列表当作无穷列表，因为Haskell愿意根据需要继续计算列表中的元素。列表[1..]就是一个无穷列表的例子。如果你请求GHCi显示这个列表，它将不断打印下去。你可以按CTRL-C或类似的操作来停止无休止的数字打印。
- en: An infinite list can be convenient when you don’t know in advance exactly how
    much of a list you will want or need. For example, we might want to compute a
    list of positions of a particle at 0.01 s time increments. We may not know in
    advance the length of time over which we want this information. If we write our
    function so that it returns an infinite list of positions, the function will be
    simpler because it doesn’t need to know the total number of positions to calculate.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不知道事先需要多少列表元素时，无穷列表非常方便。例如，我们可能想要计算一个粒子在每0.01秒增量下的位置列表。我们可能无法预先知道我们需要获取这一信息的时间长度。如果我们编写函数返回一个无穷列表的位置，那么该函数会更简单，因为它不需要知道计算位置的总数。
- en: 'A good way to view the first several elements of an infinite list is with the
    `take` function. Try the following in GHCi:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 查看无穷列表的前几个元素的一个好方法是使用`take`函数。在GHCi中尝试以下操作：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: GHCi shows you the first 10 elements of the infinite list [3..].
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: GHCi显示了无穷列表[3..]的前10个元素。
- en: Two Prelude functions from [Table 5-2](ch05.xhtml#ch5tab2) create infinite lists.
    The function repeat takes a single expression and returns an infinite list with
    the expression repeated an infinite number of times. By itself, this function
    doesn’t seem very useful, but in combination with other functions and techniques
    we’ll learn about later, it can be useful.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 [表 5-2](ch05.xhtml#ch5tab2) 的两个 Prelude 函数可以创建无限列表。函数 repeat 接受一个表达式，并返回一个由该表达式重复无限次构成的无限列表。单独使用时，这个函数似乎没有太大用处，但结合我们稍后将学到的其他函数和技巧，它可以变得非常有用。
- en: 'The Prelude function cycle takes a (finite) list and returns the infinite list
    formed by cycling through the elements of the finite list over and over again.
    You can get an idea of what cycle does by asking GHCi to show you the first several
    elements of such a list, like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Prelude 函数 cycle 接受一个（有限）列表，并返回一个无限列表，该列表是通过反复循环有限列表中的元素得到的。你可以通过让 GHCi 显示这个列表的前几个元素，来了解
    cycle 是如何工作的，如下所示：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: List Constructors and Pattern Matching
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表构造器与模式匹配
- en: The colon (`:`) operator (called *cons* for historical reasons having to do
    with the early functional programming language Lisp) from [Table 1-2](ch01.xhtml#ch1tab2)
    can be used to attach a single item of type `a` to a list with type `[a]`. For
    example, 3:[[4](bib.xhtml#bib4),[5](bib.xhtml#bib5)] is the same as [[3](bib.xhtml#bib3),[4](bib.xhtml#bib4),[5](bib.xhtml#bib5)],
    and 3:[] is the same as [[3](bib.xhtml#bib3)].
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`:` 运算符（由于早期函数式编程语言 Lisp 的历史原因，它被称为 *cons*）来自于 [表 1-2](ch01.xhtml#ch1tab2)，可以用于将类型为
    `a` 的单个元素附加到类型为 `[a]` 的列表中。例如，3:[[4](bib.xhtml#bib4),[5](bib.xhtml#bib5)] 与 [[3](bib.xhtml#bib3),[4](bib.xhtml#bib4),[5](bib.xhtml#bib5)]
    是等价的，而 3:[] 与 [[3](bib.xhtml#bib3)] 也是等价的。'
- en: In [Chapter 3](ch03.xhtml), we saw how we could use pattern matching on the
    `Bool` type. The `Bool` type has two patterns, `False` and `True`. The list type
    also has two patterns. A list is either the empty list [] or the cons x:xs of
    an item x with a list xs. Every list is exactly one of these two mutually exclusive
    and exhaustive possibilities. In fact, Haskell internally regards lists as being
    formed out of the two *constructors* (also called *data constructors*,) [] and
    :. Each type in Haskell has one or more data constructors that are used to form
    expressions of that type. Therefore, a data constructor is a way of making an
    expression of a particular type. When we define our own types in [Chapter 10](ch10.xhtml),
    we will see that data constructors are an essential part of the definition for
    the type.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '在 [第 3 章](ch03.xhtml) 中，我们看到了如何对 `Bool` 类型进行模式匹配。`Bool` 类型有两个模式，`False` 和 `True`。列表类型也有两个模式。一个列表要么是空列表
    []，要么是带有一个项 x 和列表 xs 的 cons x:xs。每个列表都恰好是这两种互斥且穷尽的可能之一。事实上，Haskell 内部将列表视为由两个
    *构造器*（也叫 *数据构造器*）[] 和 : 组成的。Haskell 中的每个类型都有一个或多个数据构造器，用于构造该类型的表达式。因此，数据构造器是一种构造特定类型表达式的方法。当我们在
    [第 10 章](ch10.xhtml) 中定义我们自己的类型时，我们将看到数据构造器是类型定义中不可或缺的一部分。'
- en: The list we think of as [[13](bib.xhtml#bib13),[6](bib.xhtml#bib6),[4](bib.xhtml#bib4)]
    is represented internally as 13:6:4:[], which means 13:(6:(4:[])) when we allow
    for the right associativity of :. [Table 5-5](ch05.xhtml#ch5tab5) shows the data
    constructors for the Boolean and list types.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所认为的列表 [[13](bib.xhtml#bib13),[6](bib.xhtml#bib6),[4](bib.xhtml#bib4)] 在内部表示为
    13:6:4:[]，这意味着 13:(6:(4:[]))，考虑到 `:` 的右结合性时如此表示。[表 5-5](ch05.xhtml#ch5tab5) 显示了布尔型和列表类型的数据构造器。
- en: '**Table 5-5:** Data Constructors for the Boolean and List Types'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-5：** 布尔型和列表类型的数据构造器'
- en: '| **Type** | **Data constructors** |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **数据构造器** |'
- en: '| --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Bool` | `False`, `True` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `Bool` | `False`, `True` |'
- en: '| `[a]` | `[]`, `:` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `[a]` | `[]`, `:` |'
- en: The fundamental mechanism for pattern matching in Haskell is the `case`-`of`
    construction. If we are pattern matching on a `Bool`, there will be two cases
    corresponding to the two data constructors `False` and `True` from which all values
    of type `Bool` are constructed. If we are pattern matching on a list, there will
    be two cases corresponding to the two data constructors `[]` and `:` from which
    all lists are constructed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 中用于模式匹配的基本机制是 `case`-`of` 结构。如果我们对 `Bool` 类型进行模式匹配，则会有两个对应的情况，分别是 `False`
    和 `True`，它们是构造 `Bool` 类型的两个数据构造器。如果我们对列表进行模式匹配，则会有两个对应的情况，分别是 `[]` 和 `:`，它们是构造所有列表的两个数据构造器。
- en: 'Let’s look at an example of defining a function on lists using pattern matching.
    Let’s define a function sndItem that returns the second element of a list, or
    gives an error if the list has fewer than two elements. The idea is that sndItem
    [[8](bib.xhtml#bib8),[6](bib.xhtml#bib6),[7](bib.xhtml#bib7),[5](bib.xhtml#bib5)]
    should return 6\. Our first definition uses the `case-of` construction:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一个使用模式匹配定义函数的例子。我们来定义一个函数` sndItem`，它返回列表的第二个元素，如果列表少于两个元素则返回错误。我们的想法是，`
    sndItem [[8](bib.xhtml#bib8),[6](bib.xhtml#bib6),[7](bib.xhtml#bib7),[5](bib.xhtml#bib5)]`应该返回6。我们第一个定义使用了`case-of`构造：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the case where `ys` is the empty list, we use the error function, which has
    type `[Char] -> a`, meaning that it takes a string as input and can serve as any
    type. The error function halts execution and returns the given string as a message.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ys`为空列表的情况下，我们使用错误函数，该函数的类型是`[Char] -> a`，意味着它接受一个字符串作为输入，并且可以作为任何类型。错误函数会终止执行并返回给定的字符串作为消息。
- en: In the case where the input is the cons of an item and a list, the notation
    `(x:xs)` indicates that the item will be assigned the name `x` and the list will
    be assigned the name `xs` for use in the body of the definition (the body is the
    expression to the right of the arrow). For example, if `ys` is the list `[1879,3,14]`,
    then `x` will be assigned the value `1879` and `xs` will be assigned the value
    `[3,14]`. This assignment of the names `x` and `xs` is *local*, meaning that it
    only holds in the body of the definition. Outside of the definition body, the
    names `x` and `xs` may have another meaning or no meaning at all.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入是`cons`一个元素和一个列表的形式，那么表示法`(x:xs)`表示该元素将被赋值给名称`x`，而列表将被赋值给名称`xs`，以便在定义的主体中使用（主体是箭头右侧的表达式）。例如，如果`ys`是列表`[1879,3,14]`，那么`x`将被赋值为`1879`，而`xs`将被赋值为`[3,14]`。这种`x`和`xs`的赋值是*局部的*，意味着它只在定义的主体内有效。在定义主体之外，`x`和`xs`可能有其他含义，甚至没有任何含义。
- en: The expression `null xs` returns `True` if `xs` is empty and `False` otherwise.
    If `xs` is empty, the original list `x:xs` had only one element, so we give the
    one-element error. If `xs` is not empty, its first element (its `head`) is the
    second element of the original list, and hence the value we should return.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`null xs`如果`xs`为空则返回`True`，否则返回`False`。如果`xs`为空，则原始列表`x:xs`只有一个元素，因此我们返回该单一元素的错误。如果`xs`不为空，则其第一个元素（`head`）就是原始列表的第二个元素，因此我们应该返回该值。
- en: If the value we are pattern matching (`ys` from earlier) is also an input to
    a function, we can do pattern matching directly on the input rather than using
    the `case-of` construction.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在进行模式匹配的值（之前的`ys`）也是某个函数的输入，我们可以直接在输入上进行模式匹配，而不是使用`case-of`构造。
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that we no longer need the local variable `ys` in `sndItem2`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在` sndItem2`中不再需要局部变量` ys`。
- en: In pattern matching on the input, the definition is expressed in parts, with
    one part for each data constructor of the input type. In this case, the input
    type is a list, and the data constructors for a list are the empty list and cons,
    so part 1 of the definition defines `sndItem2` for the empty list and part 2 of
    the definition defines the function for the cons of an item with a list.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在对输入进行模式匹配时，定义被分成几个部分，每个部分对应输入类型的一个数据构造器。在这个例子中，输入类型是一个列表，而列表的构造器有空列表和`cons`，所以定义的第一部分为空列表定义了`
    sndItem2`，第二部分为`cons`一个元素和一个列表定义了函数。
- en: 'We can make an even nicer function definition by going one step further and
    using additional pattern matching on the xs list in sndItem. Let’s define a function
    `sndItem3` that does the same thing as `sndItem` but uses even more pattern matching:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过进一步的改进，使用额外的模式匹配来改进函数定义，特别是在` sndItem`中的`xs`列表。我们来定义一个函数` sndItem3`，它与`
    sndItem`做相同的事情，但使用了更多的模式匹配：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Case 1 of `sndItem` remains unchanged. Case 2 of `sndItem` splits into two subcases,
    depending on whether the `xs` in `sndItem` is the empty list or the cons of an
    item with a list.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '` sndItem`的第一个案例保持不变。` sndItem`的第二个案例分为两个子案例，取决于` sndItem`中的` xs`是空列表还是`cons`一个元素和一个列表。'
- en: Notice the underscore character (`_`) in the last line. Names that begin with
    an underscore in Haskell are names that we never intend to refer to. We could
    have written (x:z:zs) in place of `(x:z:_)`. The underscore means that we can’t
    be bothered to give the list a real name because we have no intention of using
    it or referring to it again. We make no reference to this list in the definition
    body, so there is no motivation to give it a proper name. Sometimes it is helpful
    to the code reader (who might be you) to give a name to something that never gets
    used. If you want to give something a name *and* signal that it never gets used,
    you can use a name that begins with an underscore, such as `_zs`. Note finally
    that the cons operator (:) is right associative, so the expression `x:z:_` is
    read as `x:(z:_)`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一行中的下划线字符（`_`）。在 Haskell 中，以下划线开头的名字是我们永远不打算引用的名字。我们本可以用`(x:z:zs)`来替代`(x:z:_)`。下划线表示我们懒得给这个列表起一个真实的名字，因为我们没有打算再次使用它或引用它。在定义体中我们没有引用这个列表，所以没有必要给它一个合适的名字。有时候，给一个永远不会被使用的东西起个名字，对代码阅读者（可能是你）是有帮助的。如果你想给某个东西起个名字，并且表明它永远不会被使用，你可以使用一个以下划线开头的名字，比如`_zs`。最后需要注意的是，`cons`操作符（`:`）是右结合的，因此表达式`x:z:_`应当理解为`x:(z:_)`。
- en: Because the value we are pattern matching is the input to our function, we can
    do pattern matching on the input rather than use the `case-of` construction.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们进行模式匹配的值是传递给函数的输入，所以我们可以对输入进行模式匹配，而不必使用`case-of`结构。
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: 'This chapter introduced lists. Each member of a list must have the same type.
    Square brackets serve two roles for lists. A type enclosed in square brackets
    is a list type, and a sequence of items enclosed in square brackets and separated
    by commas forms a list. A type variable serves as a placeholder for any type.
    Several list functions have types with type variables because they don’t care
    about the underlying type of a list. Since addition, subtraction, multiplication,
    and division only work between numbers with the same type in Haskell, we introduced
    two type-conversion functions for situations in which conversion is necessary.
    A list comprehension is a method to form a new list from an existing list. Haskell
    allows for infinite lists because it is a lazy language. Lists are formed from
    two constructors: the empty list and the cons operator. Pattern matching can be
    used to define a function that takes a list as input. There are two patterns that
    a list may have: either it is the empty list or it is the cons of an element and
    another list.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了列表。列表中的每个成员必须具有相同的类型。方括号在列表中有两个作用：方括号中包含的类型表示列表类型，而方括号中包含并用逗号分隔的项则形成一个列表。类型变量作为任何类型的占位符。许多列表函数的类型中有类型变量，因为它们不关心列表的底层类型。由于加法、减法、乘法和除法仅在
    Haskell 中的相同类型的数字之间有效，因此我们引入了两个类型转换函数，用于需要转换的情况。列表推导是一种从现有列表形成新列表的方法。由于 Haskell
    是懒惰语言，它支持无限列表。列表由两个构造器构成：空列表和 `cons` 操作符。可以使用模式匹配来定义一个以列表为输入的函数。列表可能具有两种模式：它要么是空列表，要么是某个元素和另一个列表的
    `cons`。
- en: Exercises
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Exercise 5.1.** Give an abbreviation for the following list using the double
    dot (`..`) notation. Use GHCi to check that your expression does the right thing.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.1.** 使用双点（`..`）表示法给以下列表提供一个缩写。使用 GHCi 检查你的表达式是否正确。'
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Exercise 5.2.** Write a function `sndItem0 :: [a] -> a` that does the same
    thing as sndItem but does not use any pattern matching.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.2.** 编写一个函数`sndItem0 :: [a] -> a`，它与`sndItem`的功能相同，但不使用任何模式匹配。'
- en: '**Exercise 5.3.** What is the type of the following expression?'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.3.** 以下表达式的类型是什么？'
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What is the value of the expression?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式的值是多少？
- en: '**Exercise 5.4.** Write a function with type `Int -> [Int]` and describe in
    words what it does.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.4.** 编写一个类型为`Int -> [Int]`的函数，并用文字描述它的功能。'
- en: '**Exercise 5.5.** Write a function `null''` that does the same thing as the
    Prelude function null. Use the Prelude function length in your definition of `null''`
    but do not use the function null.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.5.** 编写一个函数`null''`，它与 Prelude 中的 `null` 函数功能相同。在定义 `null''` 时使用 Prelude
    函数 `length`，但不要使用 `null` 函数。'
- en: '**Exercise 5.6.** Write a function `last''` that does the same thing as the
    Prelude function last. Use the Prelude functions head and reverse in your definition
    of `last''` but do not use the function last.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.6.** 编写一个函数`last''`，它与 Prelude 中的 `last` 函数功能相同。在定义 `last''` 时使用 Prelude
    函数 `head` 和 `reverse`，但不要使用 `last` 函数。'
- en: '**Exercise 5.7.** Write a function `palindrome :: String -> Bool` that returns
    True if the input string is a palindrome (a word like *radar* that is spelled
    the same backward as it is forward) and False otherwise.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.7.** 编写一个函数 `palindrome :: String -> Bool`，如果输入字符串是回文（例如 *radar*，正读和倒读都相同），则返回
    True，否则返回 False。'
- en: '**Exercise 5.8.** What are the first five elements of the infinite list [9,1..]?'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.8.** 无限列表 [9,1..] 的前五个元素是什么？'
- en: '**Exercise 5.9.** Write a function `cycle''` that does the same thing as the
    Prelude function cycle. Use the Prelude functions repeat and concat in your definition
    of `cycle''` but do not use the function cycle.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.9.** 编写一个函数 `cycle''`，实现与 Prelude 中的函数 cycle 相同的功能。在定义 `cycle''` 时使用
    Prelude 中的函数 repeat 和 concat，但不要使用 cycle 函数。'
- en: '**Exercise 5.10.** Which of the following are valid Haskell expressions? If
    an expression is valid, give its type. If an expression is not valid, say what
    is wrong with it.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.10.** 以下哪些是有效的 Haskell 表达式？如果一个表达式有效，请给出其类型。如果表达式无效，请说明哪里出错了。'
- en: (a) `["hello",42]`
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: (a) `["hello",42]`
- en: (b) `['h',"ello"]`
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: (b) `['h',"ello"]`
- en: (c) `['a','b','c']`
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: (c) `['a','b','c']`
- en: (d) `length ['w','h','o']`
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: (d) `length ['w','h','o']`
- en: (e) `length "hello"`
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: (e) `length "hello"`
- en: '(f) `reverse` (Hint: this is a valid Haskell expression, and it has a well-defined
    type, even though GHCi cannot print the expression.)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: (f) `reverse`（提示：这是一个有效的 Haskell 表达式，并且它有一个明确定义的类型，尽管 GHCi 无法打印该表达式。）
- en: '**Exercise 5.11.** In an arithmetic sequence, if the specified last element
    does not occur in the sequence,'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.11.** 在一个算术序列中，如果指定的最后一个元素没有出现在序列中，'
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: the result seems to depend on whether you are using whole numbers. Explore this
    and try to find a general rule for where an arithmetic sequence will end.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 结果似乎取决于你是否使用整数。探讨这一点，并尝试找到一个通用规则，说明算术序列将在哪里结束。
- en: '**Exercise 5.12.** In the 1730s, Leonhard Euler showed that'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.12.** 在 1730 年代，莱昂哈德·欧拉证明了：'
- en: '![Image](Images/065equ01.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/065equ01.jpg)'
- en: Write a Haskell expression to evaluate
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Haskell 表达式来求值
- en: '![Image](Images/066equ01.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/066equ01.jpg)'
- en: '**Exercise 5.13.** The number *n*!, called “*n* factorial,” is the product
    of the positive integers less than or equal to *n*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.13.** 数字 *n*!，称为 "*n* 阶乘"，是小于或等于 *n* 的所有正整数的乘积：'
- en: '*n*! = *n*(*n* – 1) . . . 1'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*! = *n*(*n* – 1) . . . 1'
- en: 'Here’s an example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: 5! = 5 × 4 × 3 × 2 × 1 = 120
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 5! = 5 × 4 × 3 × 2 × 1 = 120
- en: Using the `product` function, write a factorial function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `product` 函数编写一个阶乘函数。
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Exercise 5.14.** The exponential function is equal to the following limit:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.14.** 指数函数等于以下极限：'
- en: '![Image](Images/066equ02.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/066equ02.jpg)'
- en: Write a function
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'that takes a real number *x* as input and produces an infinite list of successive
    approximations to exp(*x*):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个实数 *x* 作为输入，并生成一个无限长的列表，包含对 exp(*x*) 的连续逼近：
- en: '![Image](Images/066equ03.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/066equ03.jpg)'
- en: How big does *n* need to be to get within 1 percent of the correct value for
    *x* = 1? How big does *n* need to be to get within 1 percent of the correct value
    for *x* = 10?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使得 *x* = 1 时的值与正确值的误差在 1% 以内需要多大 *n*？对于 *x* = 10，*n* 需要多大才能使得误差在 1% 以内？
- en: '**Exercise 5.15.** The exponential function is equal to the following infinite
    series:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 5.15.** 指数函数等于以下无限级数：'
- en: '![Image](Images/066equ04.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/066equ04.jpg)'
- en: Write a function
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'that takes a real number *x* as input and produces an infinite list of successive
    approximations to exp(*x*):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个实数 *x* 作为输入，并生成一个无限长的列表，包含对 exp(*x*) 的连续逼近：
- en: '![Image](Images/067equ01.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/067equ01.jpg)'
- en: How big does *n* need to be for
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下情况，*n* 需要多大：
- en: '![Image](Images/067equ02.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/067equ02.jpg)'
- en: to be within 1 percent of the correct value for *x* = 1? How big does *n* need
    to be to get within 1 percent of the correct value for *x* = 10? You may want
    to use the function `fromIntegral` here.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使得 *x* = 1 时的值与正确值的误差在 1% 以内需要多大 *n*？对于 *x* = 10，*n* 需要多大才能使得误差在 1% 以内？你可能需要在这里使用函数
    `fromIntegral`。
