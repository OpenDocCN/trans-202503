- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10**  '
- en: INSTRUCTION SET ARCHITECTURE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令集架构**  '
- en: '![Image](../images/comm1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/comm1.jpg)  '
- en: This chapter discusses the implementation of a CPU’s instruction set. Although
    the choice of a given instruction set is usually beyond a software engineer’s
    control, understanding the decisions a hardware design engineer has to make when
    designing a CPU’s instruction set can definitely help you write better code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了CPU指令集的实现。尽管给定指令集的选择通常超出了软件工程师的控制范围，但理解硬件设计工程师在设计CPU指令集时必须做出的决策，肯定能帮助你编写更高效的代码。
- en: CPU instruction sets contain several tradeoffs based on assumptions that computer
    architects make about the way software engineers write code. If the machine instructions
    you choose match those assumptions, your code will probably run faster and require
    fewer machine resources. Conversely, if your code violates the assumptions, chances
    are pretty good it won’t perform as well as it otherwise could.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 'CPU指令集包含若干基于计算机架构师对软件工程师编写代码方式假设的权衡。如果你选择的机器指令符合这些假设，你的代码可能会运行得更快，并且需要更少的机器资源。相反，如果你的代码违反了这些假设，它的性能很可能不会像本应表现得那样好。  '
- en: Although studying the instruction set may seem like a task suited only to assembly
    language programmers, even high-level language programmers can benefit from doing
    so. After all, every HLL statement maps to some sequence of machine instructions,
    and the general concepts of instruction set design are portable across architectures.
    Even if you never intend to write software using assembly language, it’s important
    to understand how the underlying machine instructions work and how they were designed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然研究指令集看似只适合汇编语言程序员，但即便是高级语言程序员也能从中受益。毕竟，每个高级语言（HLL）语句都会映射到某些机器指令序列，而指令集设计的一般概念在不同架构之间是可以迁移的。即使你从不打算使用汇编语言编写软件，理解底层机器指令的工作原理以及它们是如何设计的依然很重要。  '
- en: '**10.1 The Importance of Instruction Set Design**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.1 指令集设计的重要性**  '
- en: While features like caches, pipelining, and superscalar implementation can all
    be grafted onto a CPU long after the original design is obsolete, it’s very difficult
    to change the instruction set once a CPU is in production and people are writing
    software using it. Therefore, instruction set design requires very careful consideration;
    the designer must get the *[instruction set architecture (ISA)](gloss01.xhtml#gloss01_125)*
    correct from the start of the design cycle.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管像缓存、流水线和超标量实现这样的特性可以在原始设计过时之后加入到CPU中，但一旦CPU进入生产阶段并且人们开始使用它编写软件，改变指令集就变得非常困难。因此，指令集设计需要非常谨慎的考虑；设计师必须从设计周期的开始就确保*【指令集架构（ISA）】(gloss01.xhtml#gloss01_125)*的正确性。  '
- en: 'You might assume that the “kitchen sink” approach to instruction set design—in
    which you include every instruction you can dream up—is best. However, instruction
    set design is the epitome of compromise management. Why can’t we have it all?
    Well, in the real world there are some nasty realities that prevent this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能会认为“厨房水槽”式的指令集设计方法——即你能想到的每一条指令都包括在内——是最好的。然而，指令集设计是妥协管理的典范。为什么我们不能拥有一切？实际上，现实世界中有一些让人难以接受的现实阻止了这一点：  '
- en: '**Silicon real estate** The first nasty reality is that each feature requires
    some number of transistors on the CPU’s silicon die (chip), so CPU designers have
    a “silicon budget”—a finite number of transistors to work with. There simply aren’t
    enough transistors to support putting every possible feature on a CPU. The original
    8086 processor, for example, had a silicon budget of fewer than 30,000 transistors.
    The 1999 Pentium III processor had a budget of over 9 million transistors. The
    2019 AWS Graviton2 (ARM) CPU has over 30 billion transistors.^([1](footnotes.xhtml#fn10_1a))
    These three budgets reflect the differences in semiconductor technology from 1978
    to today.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**硅片资源** 第一个现实问题是，每个特性都需要在CPU的硅片（芯片）上占用一定数量的晶体管，因此CPU设计师有一个“硅片预算”——即有限的晶体管数量。显然，没有足够的晶体管来支持在CPU上加入每一个可能的特性。例如，原始的8086处理器的硅片预算不到30,000个晶体管。1999年的Pentium
    III处理器的预算超过900万个晶体管。2019年的AWS Graviton2（ARM）CPU拥有超过300亿个晶体管。（^([1](footnotes.xhtml#fn10_1a))）这三种预算反映了从1978年到今天半导体技术的差异。  '
- en: '**Cost** Although it’s possible to use billions of transistors on a CPU today,
    the more transistors used, the more expensive the CPU. For example, at the beginning
    of 2018, Intel i7 processors using billions of transistors cost hundreds of dollars,
    whereas contemporary CPUs with 30,000 transistors cost less than a dollar.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**成本** 尽管今天在 CPU 上使用数十亿个晶体管是可能的，但使用的晶体管越多，CPU 的成本就越高。例如，在 2018 年初，使用数十亿晶体管的英特尔
    i7 处理器的价格为数百美元，而当时的现代 CPU 拥有 30,000 个晶体管，价格却低于一美元。'
- en: '**Expandability** It’s very difficult to anticipate all the features people
    will want. For example, Intel’s MMX and SIMD instruction enhancements were added
    to make multimedia programming more practical on the Pentium processor. Back in
    1978, when Intel created the first 8086 processor, very few people could have
    predicted the need for these instructions. A CPU designer must allow for making
    extensions to the instruction set in future members of the CPU family to accommodate
    currently unanticipated needs.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展性** 很难预见人们未来会需要哪些功能。例如，英特尔的 MMX 和 SIMD 指令扩展是为了使多媒体编程在奔腾处理器上更加实用而添加的。回到
    1978 年，当英特尔创建第一款 8086 处理器时，几乎没有人能预测到这些指令的需求。CPU 设计师必须为在未来的 CPU 系列中扩展指令集预留空间，以满足当前无法预见的需求。'
- en: '**Legacy support for old instructions** This nasty reality is almost the opposite
    of expandability. Often, an instruction that the CPU designer feels is important
    now turns out to be less useful than expected. For example, the `loop` and `enter`
    instructions on the 80x86 CPU see very little use in modern high-performance programs.
    It’s commonly the case that programs never use some of the instructions in a CPU
    adopting the kitchen sink approach. Unfortunately, once an instruction is added
    to the instruction set, it has to be supported in all future versions of the processor,
    unless few enough programs use the instruction that CPU designers are willing
    to let those programs break.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**对旧指令的遗留支持** 这种残酷的现实几乎与可扩展性相反。通常，CPU 设计师认为重要的某个指令，最终会发现它的实用性远不如预期。例如，80x86
    CPU 上的 `loop` 和 `enter` 指令在现代高性能程序中几乎没有使用。通常情况下，采用万象俱全方法的 CPU 中有些指令根本不会被程序使用。不幸的是，一旦指令被添加到指令集中，它必须在所有未来版本的处理器中得到支持，除非极少数程序使用该指令，以至于
    CPU 设计师愿意让这些程序不再支持。'
- en: '**Complexity** A CPU designer must consider the assembly programmers and compiler
    writers who will be using the chip. A CPU employing the kitchen sink approach
    might appeal to someone who’s already familiar with that CPU, but no one else
    will want to learn an overly complex system.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**复杂性** 一个 CPU 设计师必须考虑到汇编程序员和编译器开发人员将如何使用这个芯片。采用万象俱全方法的 CPU 可能会吸引已经熟悉该 CPU
    的人，但其他人不会愿意学习一个过于复杂的系统。'
- en: 'These problems with the kitchen sink approach all have a common solution: design
    a simple instruction set for the first version of the CPU, and leave room for
    later expansion. This is one of the main reasons the 80x86 has proven to be so
    popular and long-lived. Intel started with a relatively simple CPU and figured
    out how to extend the instruction set over the years to accommodate new features.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 采用万象俱全方法所面临的问题有一个共同的解决方案：为 CPU 的第一个版本设计一个简单的指令集，并为后续扩展留下空间。这是 80x86 之所以如此受欢迎且长寿的主要原因之一。英特尔从一个相对简单的
    CPU 开始，并在多年里找到了一种扩展指令集的方法，以适应新的功能。
- en: '**10.2 Basic Instruction Design Goals**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.2 基本指令设计目标**'
- en: The efficiency of your programs largely depends upon the instructions that they
    use. Short instructions use very little memory and often execute rapidly, but
    they can’t tackle big tasks. Larger instructions can handle more complex tasks,
    with a single instruction often doing the work of several short instructions,
    but they may consume excessive memory or require many machine cycles to execute.
    To enable software engineers to write the best possible code, computer architects
    must strike a balance between the two.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序效率在很大程度上取决于它们使用的指令。短指令使用极少的内存，且通常执行速度快，但它们无法处理大型任务。较大的指令可以处理更复杂的任务，单个指令通常能完成多个短指令的工作，但它们可能会消耗过多内存或需要执行多个机器周期。为了让软件工程师能够编写出最佳的代码，计算机架构师必须在两者之间找到平衡。
- en: In a typical CPU, the computer encodes instructions as numeric values (operation
    codes, or *opcodes*) and stores them in memory. Encoding these instructions is
    one of the major tasks in instruction set design, requiring careful thought. Instructions
    must each have a unique opcode, so the CPU can differentiate them. With an *n*-bit
    number, there are 2^(*n*) different possible opcodes, so to encode *m* instructions
    requires at least log[2](*m*) bits. The main point to keep in mind is that the
    size of individual CPU instructions is dependent on the total number of instructions
    that the CPU supports.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的CPU中，计算机将指令编码为数字值（操作码，或*opcodes*），并将其存储在内存中。对这些指令进行编码是指令集设计中的一项主要任务，需要仔细考虑。每条指令必须有一个唯一的操作码，以便CPU能够区分它们。使用*n*位数字，可以有2^(*n*)个不同的操作码，因此编码*m*条指令至少需要log[2](*m*)位。需要记住的要点是，单个CPU指令的大小取决于CPU支持的指令总数。
- en: Encoding opcodes is a little more involved than assigning a unique numeric value
    to each instruction. As the previous chapter discussed, decoding each instruction
    and executing the specified task requires actual circuitry. With a 7-bit opcode,
    we could encode 128 different instructions. To decode each of these 128 instructions
    requires a 7- to 128-line decoder—an expensive piece of circuitry. However, assuming
    that the instruction opcodes contain certain (binary) patterns, a single large
    decoder can often be replaced by several smaller, less expensive ones.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 编码操作码比为每条指令分配一个唯一的数字值更复杂。如前一章所讨论的，解码每条指令并执行指定的任务需要实际的电路。对于一个7位操作码，我们可以编码128条不同的指令。要解码这128条指令，需要一个7到128行的解码器——这是一块昂贵的电路。然而，假设指令操作码包含某些（按位）模式，一个大型解码器通常可以通过几个更小、更便宜的解码器来替代。
- en: If an instruction set contains 128 unrelated instructions, there’s little you
    can do other than decode the entire bit string for each instruction. However,
    in most architectures the instructions fall into categories. On the 80x86 CPUs,
    for example, `mov(eax,` `ebx);` and `mov(ecx,` `edx);` have different opcodes,
    because they’re different instructions, but they’re obviously related in that
    they both move data from one register to another. The only difference is their
    source and destination operands. Thus, CPU designers could encode instructions
    like `mov` with a *subopcode*, and then they could encode the instruction’s operands
    using other bit fields within the opcode.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个指令集包含128个不相关的指令，除了对每条指令解码整个比特串外，你几乎无能为力。然而，在大多数架构中，指令是有分类的。例如，在80x86的CPU中，`mov(eax,`
    `ebx);` 和 `mov(ecx,` `edx);` 有不同的操作码，因为它们是不同的指令，但显然它们是相关的，因为它们都将数据从一个寄存器移动到另一个寄存器。唯一的区别是它们的源操作数和目标操作数。因此，CPU设计师可以用*子操作码*对像`mov`这样的指令进行编码，然后使用操作码中的其他位字段来编码指令的操作数。
- en: For example, given an instruction set with only eight instructions, each with
    two operands, and each operand having only one of four possible values, we could
    encode the instructions using three packed fields containing 3, 2, and 2 bits,
    respectively (see [Figure 10-1](ch10.xhtml#ch10fig01)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定一个仅包含八条指令的指令集，每条指令有两个操作数，且每个操作数只有四个可能值中的一个，我们可以使用三个打包字段进行编码，分别包含3、2和2位（见[图10-1](ch10.xhtml#ch10fig01)）。
- en: '![image](../images/10fig01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig01.jpg)'
- en: '*Figure 10-1: Separating an opcode into several fields to simplify decoding*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：将操作码分成几个字段以简化解码*'
- en: 'This encoding needs only three simple decoders to determine what the CPU should
    do. While this is a basic example, it demonstrates one very important facet of
    instruction set design: opcodes should be easy to decode. The easiest way to simplify
    the opcode is to construct it using several different bit fields. The smaller
    these bit fields are, the easier it will be for the hardware to decode and execute
    the instruction.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编码只需要三个简单的解码器来确定CPU应该执行的操作。虽然这是一个基础示例，但它展示了指令集设计中的一个非常重要的方面：操作码应该易于解码。简化操作码的最简单方法是使用多个不同的位字段来构造它。这些位字段越小，硬件解码和执行指令就越容易。
- en: The CPU designer’s goal, then, is to assign an appropriate number of bits to
    the opcode’s instruction field and to its operand fields. Choosing more bits for
    the instruction field lets the opcode encode more instructions, just as choosing
    more bits for the operand fields lets the opcode specify a larger number of operands
    (often memory locations or registers). You might think that when encoding 2^(*n*)
    different instructions using *n* bits, you’d have very little leeway in choosing
    the size of the instruction. It’s going to take *n* bits to encode those 2^(*n*)
    instructions; you can’t do it with any fewer. It *is* possible, however, to use
    more than *n* bits. This might seem wasteful, but sometimes it’s advantageous.
    Again, picking an appropriate instruction size is one of the more important aspects
    of instruction set design.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，CPU 设计师的目标是为操作码的指令字段和操作数字段分配适当数量的位。为指令字段选择更多的位可以让操作码编码更多的指令，就像为操作数字段选择更多的位可以让操作码指定更多的操作数（通常是内存位置或寄存器）。你可能会认为，当使用
    *n* 位编码 2^(*n*) 个不同的指令时，你在选择指令大小上几乎没有什么余地。为了编码这 2^(*n*) 个指令，肯定需要 *n* 位；你无法用更少的位来做到这一点。然而，*n*
    位以上是可以使用的。这可能看起来浪费，但有时却是有利的。同样，选择适当的指令大小是指令集设计中更重要的方面之一。
- en: '***10.2.1 Choosing Opcode Length***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.2.1 选择操作码长度***'
- en: 'Opcode length isn’t arbitrary. Assuming that a CPU is capable of reading bytes
    from memory, the opcode will probably have to be some multiple of 8 bits long.
    If the CPU is not capable of reading bytes from memory (most RISC CPUs read memory
    only in 32- or 64-bit chunks), the opcode will be the same size as the smallest
    object the CPU can read from memory at one time. Any attempt to shrink the opcode
    size below this limit is futile. In this chapter, we’ll work with the first case:
    opcodes that must have a length that is a multiple of 8 bits.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 操作码的长度不是任意的。假设 CPU 能够从内存中读取字节，那么操作码可能必须是 8 位的倍数。如果 CPU 无法从内存中读取字节（大多数 RISC CPU
    只能以 32 位或 64 位为单位读取内存），那么操作码的大小将与 CPU 能够一次从内存读取的最小对象的大小相同。任何试图将操作码大小缩小到这一限制以下的尝试都是徒劳的。在本章中，我们将讨论第一种情况：操作码必须是
    8 位的倍数。
- en: Another point to consider is the size of an instruction’s operands. Some CPU
    designers include all operands in their opcode. Other CPU designers don’t count
    operands like immediate constants or address displacements as part of the opcode,
    and this is the approach we’ll take.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的点是指令操作数的大小。一些 CPU 设计师将所有操作数包含在他们的操作码中。另一些 CPU 设计师则不将像立即数或地址偏移量这样的操作数算作操作码的一部分，我们将采用这种方法。
- en: An 8-bit opcode can encode only 256 different instructions. Even if we don’t
    count instruction operands as part of the opcode, having only 256 different instructions
    is a stringent limit. Though CPUs with 8-bit opcodes exist, modern processors
    tend to have far more than 256 different instructions. Because opcodes must have
    a length that is a multiple of 8 bits, the next smallest possible opcode size
    is 16 bits. A 2-byte opcode can encode up to 65,536 different instructions, though
    the instructions will be larger.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 8 位的操作码只能编码 256 个不同的指令。即使我们不将指令操作数算作操作码的一部分，只有 256 个不同指令也是一个严格的限制。尽管存在 8
    位操作码的 CPU，但现代处理器通常有超过 256 个不同的指令。由于操作码的长度必须是 8 位的倍数，所以下一个最小的操作码大小是 16 位。一个 2 字节的操作码可以编码最多
    65,536 个不同的指令，尽管这些指令会更大。
- en: When reducing instruction size is an important design goal, CPU designers often
    employ data compression theory. The first step is to analyze programs written
    for a typical CPU and count how many times each instruction occurs over a large
    number of applications. The second step is to create a list of these instructions,
    sorted by their frequency of use. Next, the designer assigns the 1-byte opcodes
    to the most frequently used instructions; 2-byte opcodes to the next most frequently
    used instructions; and opcodes of 3 or more bytes to the rarely used instructions.
    Although this scheme requires opcodes with a maximum size of 3 or more bytes,
    most of the actual instructions in a program will use 1- or 2-byte opcodes. The
    average opcode length will be somewhere between 1 and 2 bytes (let’s say 1.5 bytes),
    and a typical program will be shorter than had all the instructions employed a
    2-byte opcode (see [Figure 10-2](ch10.xhtml#ch10fig02)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当减少指令大小是一个重要设计目标时，CPU设计师通常会采用数据压缩理论。第一步是分析为典型CPU编写的程序，并统计每条指令在大量应用中出现的频率。第二步是创建这些指令的列表，并按使用频率进行排序。接下来，设计师将1字节的操作码分配给最常用的指令；2字节的操作码分配给次常用的指令；3字节或更多字节的操作码分配给使用较少的指令。尽管这种方案需要操作码的最大大小为3字节或更多，但大多数程序中的实际指令将使用1字节或2字节的操作码。平均操作码长度将在1字节和2字节之间（假设为1.5字节），而且典型程序的长度将比所有指令都采用2字节操作码时要短（参见[图10-2](ch10.xhtml#ch10fig02)）。
- en: '![image](../images/10fig02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig02.jpg)'
- en: '*Figure 10-2: Encoding instructions using a variable-length opcode*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：使用可变长度操作码编码指令*'
- en: Although using variable-length instructions allows us to create smaller programs,
    it comes at a price. First, decoding variable-length instructions is a bit more
    complicated than decoding fixed-length instructions. Before decoding a particular
    instruction field, the CPU must first decode the instruction’s size, which consumes
    time. This may affect the CPU’s overall performance by introducing delays in the
    decoding step, which in turn limits the CPU’s maximum clock speed (because those
    delays stretch out a single clock period, thus reducing the CPU’s clock frequency).
    Variable-length instructions also make decoding multiple instructions in a pipeline
    difficult, because the CPU can’t easily determine the instruction boundaries in
    the prefetch queue.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用可变长度指令可以让我们创建更小的程序，但这也有代价。首先，解码可变长度指令比解码固定长度指令要复杂一些。在解码特定指令字段之前，CPU必须首先解码指令的大小，这会消耗一定时间。这可能会影响CPU的整体性能，因解码步骤的延迟会限制CPU的最大时钟速度（因为这些延迟拉长了一个时钟周期，从而降低了CPU的时钟频率）。可变长度指令还会使得在流水线中解码多个指令变得困难，因为CPU无法轻松地确定预取队列中的指令边界。
- en: For these reasons and others, most popular RISC architectures avoid variable-length
    instructions. However, in this chapter, we’ll study a variable-length approach,
    because saving memory is an admirable goal.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因及其他原因，大多数流行的RISC架构都避免使用可变长度指令。然而，在本章中，我们将研究一种可变长度方法，因为节省内存是一个值得追求的目标。
- en: '***10.2.2 Planning for the Future***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.2.2 面向未来的规划***'
- en: Before actually choosing the instructions to implement in a CPU, designers must
    plan for the future. As explained earlier, the need for new instructions will
    undoubtedly arise after the initial design, so it’s wise to reserve some opcodes
    specifically for expansion purposes. Given the instruction opcode format in [Figure
    10-2](ch10.xhtml#ch10fig02), it might not be a bad idea to reserve one block of
    64 1-byte opcodes, half (4,096) of the 2-byte opcodes, and half (1,048,576) of
    the 3-byte opcodes for future use. Giving up 64 of the very valuable 1-byte opcodes
    may seem extravagant, but history suggests that such foresight is rewarded.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际选择要在CPU中实现的指令之前，设计师必须为未来做规划。如前所述，初始设计后，新的指令需求无疑会出现，因此明智的做法是专门为扩展预留一些操作码。鉴于[图10-2](ch10.xhtml#ch10fig02)中的指令操作码格式，预留64个1字节操作码块、半数（4,096个）2字节操作码和半数（1,048,576个）3字节操作码以备将来使用，这可能不是个坏主意。放弃64个极为宝贵的1字节操作码似乎有些奢侈，但历史表明，这种远见最终会得到回报。
- en: '***10.2.3 Choosing Instructions***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.2.3 选择指令***'
- en: The next step is to choose the instructions to implement. Even if nearly half
    the instructions have been reserved for future expansion, that doesn’t mean that
    all the remaining opcodes must be used to implement instructions. A designer can
    leave a number of these instructions unimplemented, effectively reserving them
    for the future as well. The right approach is not to use up the opcodes as quickly
    as possible, but rather to produce a consistent and complete instruction set given
    the design compromises. It’s much easier to add an instruction later than it is
    to remove one, so, for the first go-round, it’s generally better to go with a
    simpler design.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是选择要实现的指令。即使近一半的指令已经为将来扩展预留，也并不意味着所有剩余的操作码必须用于实现指令。设计师可以将其中一些指令保持未实现，实际上也是为未来保留。正确的方法不是尽可能快地使用完操作码，而是根据设计妥协，生成一个一致且完整的指令集。添加指令比删除指令容易得多，因此，在第一次设计时，通常最好采用更简单的设计。
- en: 'First, choose some generic instruction types. Early in the design process it’s
    important to limit your choices to very common instructions. Other processors’
    instruction sets are probably the best place to look for suggestions. For example,
    most processors have the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择一些通用的指令类型。在设计初期，限制选择常见的指令非常重要。其他处理器的指令集可能是寻找建议的最佳地方。例如，大多数处理器都有以下指令：
- en: Data movement instructions (such as `mov`)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据移动指令（例如`mov`）
- en: Arithmetic and logical instructions (such as `add`, `sub`, `and`, `or`, `not`)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术与逻辑指令（例如`add`、`sub`、`and`、`or`、`not`）
- en: Comparison instructions
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较指令
- en: Conditional jump instructions (generally used after the comparison instructions)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件跳转指令（通常在比较指令后使用）
- en: Input/output instructions
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入/输出指令
- en: Other miscellaneous instructions
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他杂项指令
- en: The initial instruction set should comprise a reasonable number of instructions
    that will allow programmers to write efficient programs, without exceeding the
    silicon budget or violating other design constraints. This requires CPU designers
    to make strategic decisions based on careful research, experimentation, and simulation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 初始指令集应包括合理数量的指令，以使程序员能够编写高效的程序，同时不超出硅片预算或违反其他设计约束。这要求 CPU 设计师基于深入的研究、实验和仿真做出战略决策。
- en: '***10.2.4 Assigning Opcodes to Instructions***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.2.4 指令操作码分配***'
- en: After choosing the initial instructions, the CPU designer assigns opcodes to
    them. The first step in this process is to group the instructions according to
    the characteristics they share. For example, an `add` instruction probably supports
    the exact same set of operands as the `sub` instruction, so it makes sense to
    group these two instructions together. On the other hand, the `not` and `neg`
    instructions each generally require only a single operand. Therefore, it makes
    sense to put these two instructions in the same group, but one separate from the
    `add` and `sub` group.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择初步指令后，CPU 设计师将为其分配操作码。这个过程的第一步是根据指令所共享的特征对指令进行分组。例如，`add` 指令可能支持与 `sub` 指令完全相同的操作数，因此将这两条指令分组是合乎逻辑的。另一方面，`not`
    和 `neg` 指令通常只需要一个操作数。因此，将这两条指令放入同一组是合理的，但与 `add` 和 `sub` 分开。
- en: Once all the instructions are grouped, the next step is to encode them. A typical
    encoding scheme uses some bits to select the group, some to select a particular
    instruction from that group, and some to encode the operand types (such as registers,
    memory locations, and constants). The number of bits needed to encode all this
    information can have a direct impact on the instruction’s size, regardless of
    how often the instruction is used. For example, suppose 2 bits are needed to select
    an instruction’s group, 4 bits to select the instruction within that group, and
    6 bits to specify the instruction’s operand types. In this case, the instructions
    are not going to fit into an 8-bit opcode. On the other hand, if all we need is
    to push one of eight different registers onto the stack, 4 bits will be enough
    to specify the `push` instruction group, and 3 bits will be enough to specify
    the register.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有指令被分组，下一步就是对它们进行编码。典型的编码方案使用一些位来选择组别，使用一些位来选择该组中的特定指令，还有一些位用于编码操作数类型（例如寄存器、内存位置和常量）。编码所有这些信息所需的位数会直接影响指令的大小，而不管指令的使用频率如何。例如，假设需要2位来选择指令的组，4位来选择该组中的指令，6位来指定指令的操作数类型。在这种情况下，指令将无法适应8位的操作码。另一方面，如果我们只需要将8个不同寄存器中的一个推入栈中，那么4位就足以指定`push`指令组，3位足以指定寄存器。
- en: 'Encoding instruction operands with a minimal amount of space is always a problem,
    because many instructions allow a large number of operands. For example, the generic
    32-bit 80x86 `mov` instruction allows two operands and requires a 2-byte opcode.^([2](footnotes.xhtml#fn10_2a))
    However, Intel noticed that `mov(`disp`, eax);` and `mov(eax,` disp`);` occur
    frequently in programs, so it created a special 1-byte version of these instructions
    to reduce their size and, consequently, the size of programs that use them. Intel
    did not remove the 2-byte versions of these instructions, though: there are two
    different instructions that store EAX into memory and two different instructions
    that load EAX from memory. A compiler or assembler will always emit the shorter
    versions of each pair of instructions.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最少空间对指令操作数进行编码始终是一个问题，因为许多指令允许多个操作数。例如，通用的32位80x86 `mov`指令允许两个操作数并且需要2字节的操作码。^([2](footnotes.xhtml#fn10_2a))
    然而，英特尔注意到`mov(`disp`, eax);`和`mov(eax,` disp`);`在程序中经常出现，因此它创建了这些指令的特殊1字节版本，以减少它们的大小，从而减小使用它们的程序的大小。然而，英特尔并没有移除这些指令的2字节版本：有两个不同的指令将EAX存储到内存中，还有两个不同的指令从内存中加载EAX。编译器或汇编器将始终生成每对指令中的较短版本。
- en: 'Intel made an important tradeoff with the `mov` instruction: it gave up an
    extra opcode in order to provide a shorter version of one variant of each instruction.
    Actually, Intel uses this trick all over the place to create shorter and easier-to-decode
    instructions. Back in 1978, creating redundant instructions to reduce program
    size was a good compromise given the cost of memory. Today, however, a CPU designer
    would probably use those redundant opcodes for different purposes.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔在`mov`指令上做了一个重要的权衡：它放弃了一个额外的操作码，以提供每个指令变体的更短版本。事实上，英特尔在很多地方都使用了这个技巧，以创建更短且更易解码的指令。回到1978年，为了减少程序大小，创建冗余指令是一个很好的折衷方案，因为当时内存的成本较高。然而，今天的CPU设计师可能会将这些冗余操作码用于其他目的。
- en: '**10.3 The Y86 Hypothetical Processor**'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.3 Y86假设处理器**'
- en: 'Because of enhancements made to the 80x86 processor family over time, Intel’s
    design goals in 1978, and the evolution of computer architecture, the encoding
    of 80x86 instructions is very complex and somewhat illogical. In short, the 80x86
    is not a good introductory example of instruction set design. To work around this,
    we’ll discuss instruction set design in two stages: first, we’ll develop a trivial
    instruction set for the Y86, a hypothetical processor that is a small subset of
    the 80x86, and then we’ll expand our discussion to the full 80x86 instruction
    set.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于80x86处理器家族随着时间的推移进行了改进，英特尔在1978年的设计目标，以及计算机架构的演变，80x86指令的编码非常复杂且有些不合逻辑。简而言之，80x86并不是一个很好的指令集设计入门示例。为了绕过这一点，我们将分两个阶段讨论指令集设计：首先，我们将为Y86开发一个简单的指令集，Y86是一个80x86的小子集，然后我们将扩展讨论到完整的80x86指令集。
- en: '***10.3.1 Y86 Limitations***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.3.1 Y86的局限性***'
- en: 'The hypothetical Y86 processor is a *very* stripped-down version of the 80x86
    CPUs. It supports only:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设的Y86处理器是80x86 CPU的*非常*简化版本。它仅支持：
- en: 'One operand size: 16 bits. This simplification frees us from having to encode
    the operand size as part of the opcode (thereby reducing the total number of opcodes
    we’ll need).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个操作数大小：16 位。这个简化使我们不必将操作数大小作为操作码的一部分进行编码（从而减少我们所需的操作码总数）。
- en: 'Four 16-bit registers: AX, BX, CX, and DX. This lets us encode register operands
    with only 2 bits (versus the 3 bits the 80x86 family requires to encode eight
    registers).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个 16 位寄存器：AX、BX、CX 和 DX。这使我们能够仅用 2 位编码寄存器操作数（相比 80x86 系列需要 3 位来编码八个寄存器）。
- en: A 16-bit address bus with a maximum of 65,536 bytes of addressable memory.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 16 位的地址总线，最大可寻址 65,536 字节的内存。
- en: These simplifications, plus a very limited instruction set, will allow us to
    encode all Y86 instructions using a 1-byte opcode and a 2-byte displacement/offset
    when applicable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简化，加上非常有限的指令集，将使我们能够通过 1 字节的操作码和在适用时 2 字节的位移/偏移量来编码所有 Y86 指令。
- en: '***10.3.2 Y86 Instructions***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.3.2 Y86 指令***'
- en: Including both forms of the `mov` instruction, the Y86 CPU still provides only
    18 basic instructions. Seven of these instructions have two operands, eight have
    one operand, and five have no operands at all. The instructions are `mov` (two
    forms), `add`, `sub`, `cmp`, `and`, `or`, `not`, `je`, `jne`, `jb`, `jbe`, `ja`,
    `jae`, `jmp`, `get`, `put`, and `halt`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 包括两种形式的 `mov` 指令，Y86 CPU 仍然只提供 18 条基本指令。这些指令中，七条有两个操作数，八条有一个操作数，五条没有操作数。指令包括
    `mov`（两种形式）、`add`、`sub`、`cmp`、`and`、`or`、`not`、`je`、`jne`、`jb`、`jbe`、`ja`、`jae`、`jmp`、`get`、`put`
    和 `halt`。
- en: '**10.3.2.1 The mov Instruction**'
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.3.2.1 mov 指令**'
- en: 'The `mov` instruction comes in two forms, merged into the same instruction
    class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov` 指令有两种形式，合并到同一个指令类别中：'
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In these forms, reg is either register `ax`, `bx`, `cx`, or `dx`; memory is
    an operand specifying a memory location; and constant is a numeric constant using
    hexadecimal notation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些形式中，reg 是寄存器 `ax`、`bx`、`cx` 或 `dx`；内存是指定内存位置的操作数；常数是使用十六进制表示的数字常数。
- en: '**10.3.2.2 Arithmetic and Logical Instructions**'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.3.2.2 算术和逻辑指令**'
- en: 'The arithmetic and logical instructions are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 算术和逻辑指令如下：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `add` instruction adds the value of the first operand to the value of the
    second, storing the sum in the second operand. The `sub` instruction subtracts
    the value of the first operand from the value of the second, storing the difference
    in the second operand. The `cmp` instruction compares the value of the first operand
    against the value of the second and saves the result of the comparison for use
    by the conditional jump instructions (described in the next section). The `and`
    and `or` instructions compute bitwise logical operations between their two operands
    and store the result in the second operand. The `not` instruction appears separately
    because it supports only a single operand. `not` is the bitwise logical operation
    that inverts the bits of its single memory or register operand.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 指令将第一个操作数的值加到第二个操作数的值，并将结果存储在第二个操作数中。`sub` 指令将第一个操作数的值从第二个操作数的值中减去，并将差值存储在第二个操作数中。`cmp`
    指令将第一个操作数的值与第二个操作数的值进行比较，并保存比较结果以供条件跳转指令（在下一节中描述）使用。`and` 和 `or` 指令计算它们两个操作数之间的按位逻辑运算，并将结果存储在第二个操作数中。`not`
    指令单独出现，因为它只支持单个操作数。`not` 是按位逻辑操作，它反转其单个内存或寄存器操作数的位。'
- en: '**10.3.2.3 Control Transfer Instructions**'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.3.2.3 控制转移指令**'
- en: 'The *control transfer instructions* interrupt the execution of instructions
    stored in sequential memory locations and transfer control to instructions stored
    at some other point in memory. They do this either unconditionally, or conditionally
    based upon the result from a `cmp` instruction. These are the control transfer
    instructions:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制转移指令* 中断顺序存储在内存位置的指令执行，并将控制权转移到存储在内存其他位置的指令。这些指令可以是无条件的，也可以是根据 `cmp` 指令的结果有条件地执行。控制转移指令包括：'
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first six instructions (`ja`, `jae`, `jb`, `jbe`, `je`, and `jne`) let you
    check the result of the previous `cmp` instruction—that is, the result of the
    comparison of that instruction’s first and second operands.^([3](footnotes.xhtml#fn10_3a))
    For example, if you compare the AX and BX registers with a `cmp(ax,` `bx);` instruction
    and then execute the `ja` instruction, the Y86 CPU will jump to the specified
    destination location if AX is greater than BX. If AX is not greater than BX, control
    will fall through to the next instruction in the program. In contrast to the first
    six instructions, the `jmp` instruction unconditionally transfers control to the
    instruction at the destination address.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前六条指令（`ja`、`jae`、`jb`、`jbe`、`je` 和 `jne`）允许你检查前一条 `cmp` 指令的结果——即该指令的第一个和第二个操作数的比较结果。^([3](footnotes.xhtml#fn10_3a))
    例如，如果你使用 `cmp(ax,` `bx);` 指令比较 AX 和 BX 寄存器，然后执行 `ja` 指令，若 AX 大于 BX，Y86 CPU 将跳转到指定的目标位置。如果
    AX 不大于 BX，控制流将继续执行程序中的下一条指令。与前六条指令不同，`jmp` 指令无条件地将控制转移到目标地址的指令。
- en: '**10.3.2.4 Miscellaneous Instructions**'
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.3.2.4 杂项指令**'
- en: 'The Y86 supports three instructions that do not have any operands:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Y86 支持三条没有操作数的指令：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `get` and `put` instructions let you read and write integer values: `get`
    prompts the user for a hexadecimal value and then stores that value into the AX
    register; `put` displays the value of the AX register in hexadecimal format. The
    `halt` instruction terminates program execution.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 和 `put` 指令让你读取和写入整数值：`get` 提示用户输入一个十六进制值，并将该值存储到 AX 寄存器中；`put` 显示 AX
    寄存器的十六进制值。`halt` 指令终止程序执行。'
- en: '***10.3.3 Operand Types and Addressing Modes on the Y86***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.3.3 Y86 的操作数类型和寻址模式***'
- en: 'Before assigning opcodes, we need to look at the operands these instructions
    support. The 18 Y86 instructions use five different operand types: registers,
    constants, and three memory-addressing modes (the *indirect* addressing mode,
    the *indexed* addressing mode, and the *direct* addressing mode). See [Chapter
    6](ch06.xhtml#ch06) for more details on these addressing modes.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配操作码之前，我们需要查看这些指令支持的操作数。18 条 Y86 指令使用五种不同的操作数类型：寄存器、常数以及三种内存寻址模式（*间接*寻址模式、*索引*寻址模式和*直接*寻址模式）。有关这些寻址模式的更多细节，请参见[第六章](ch06.xhtml#ch06)。
- en: '***10.3.4 Encoding Y86 Instructions***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.3.4 编码 Y86 指令***'
- en: Because a real CPU uses logic circuitry to decode the opcodes and act appropriately
    on them, it’s not a good idea to arbitrarily assign opcodes to machine instructions.
    Instead, a typical CPU opcode uses a certain number of bits to denote the instruction
    class (such as `mov`, `add`, and `sub`), and a certain number of bits to encode
    each operand.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因为真实的 CPU 使用逻辑电路解码操作码并相应地执行操作，所以随意分配操作码给机器指令并不好。通常，CPU 操作码使用一定数量的比特来表示指令类别（如
    `mov`、`add` 和 `sub`），并使用一定数量的比特来编码每个操作数。
- en: A typical Y86 instruction takes the form shown in [Figure 10-3](ch10.xhtml#ch10fig03).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一条典型的 Y86 指令如[图 10-3](ch10.xhtml#ch10fig03)所示。
- en: '![image](../images/10fig03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig03.jpg)'
- en: '*Figure 10-3: Basic Y86 instruction encoding*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：基本 Y86 指令编码*'
- en: The basic instruction is either 1 or 3 bytes long, and its opcode consists of
    a single byte containing three fields. The first field, consisting of the HO 3
    bits, defines the instruction, and these 3 bits provide eight possible combinations.
    As there are 18 different Y86 instructions, we’ll have to pull some tricks to
    handle the remaining 10 instructions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基本指令长度为 1 或 3 字节，其操作码由一个字节组成，该字节包含三个字段。第一个字段由高位 3 比特组成，用于定义指令，这 3 比特提供了八种可能的组合。由于有
    18 条不同的 Y86 指令，我们需要采取一些方法来处理剩余的 10 条指令。
- en: '**10.3.4.1 Eight Generic Y86 Instructions**'
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.3.4.1 八条通用 Y86 指令**'
- en: As you can see in [Figure 10-3](ch10.xhtml#ch10fig03), seven of the eight basic
    opcodes encode the `or`, `and`, `cmp`, `sub`, and `add` instructions, as well
    as both versions of the `mov` instruction. The eighth, `000`, is an *expansion
    opcode*. This special instruction class, which we’ll return to shortly, provides
    a mechanism that allows us to expand the set of available instructions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 10-3](ch10.xhtml#ch10fig03)所示，八个基本操作码中的七个用于编码 `or`、`and`、`cmp`、`sub` 和 `add`
    指令，以及两种版本的 `mov` 指令。第八个 `000` 是 *扩展操作码*。这个特殊的指令类别，我们稍后会讨论，它提供了一种机制，允许我们扩展可用指令集。
- en: To determine the full opcode for a particular instruction, you simply select
    the appropriate bits for the `iii`, `rr`, and `mmm` fields (identified in [Figure
    10-3](ch10.xhtml#ch10fig03)). The `rr` field contains the destination register
    (except for the version of the `mov` instruction whose `iii` field is `111`),
    and the `mmm` field encodes the source register. For example, to encode the `mov(bx,
    ax);` instruction you would select `iii` = `110` (`mov(`reg`,` reg`);`), `rr`
    = `00` (`ax`), and `mmm` `= 001` (`bx`). This produces the 1-byte instruction
    `%11000001`, or `$c0`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定特定指令的完整操作码，你只需选择适当的`iii`、`rr`和`mmm`字段的位（见[图 10-3](ch10.xhtml#ch10fig03)）。`rr`字段包含目标寄存器（除了`mov`指令的版本，其`iii`字段为`111`），`mmm`字段编码源寄存器。例如，要编码`mov(bx,
    ax);`指令，你需要选择`iii` = `110`（`mov(`reg`,` reg`);`），`rr` = `00`（`ax`），`mmm` = `001`（`bx`）。这将生成1字节的指令`%11000001`，即`$c0`。
- en: 'Some Y86 instructions are larger than 1 byte. To illustrate why this is necessary,
    take, for example, the instruction `mov([1000], ax);`, which loads the AX register
    with the value stored at memory location `$1000`. The encoding for the opcode
    is `%11000110`, or `$c6`. However, the encoding for the `mov([2000], ax);` instruction
    is also `$c6`. Clearly these two instructions do different things: one loads the
    AX register from memory location `$1000`, while the other loads the AX register
    from memory location `$2000`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Y86指令的大小大于1字节。为了说明为什么需要这种方式，举个例子，考虑`mov([1000], ax);`指令，它将存储在内存位置`$1000`的值加载到AX寄存器中。该操作码的编码是`%11000110`，即`$c6`。然而，`mov([2000],
    ax);`指令的编码也是`$c6`。显然，这两条指令执行的操作不同：一条将AX寄存器从内存位置`$1000`加载，而另一条则从内存位置`$2000`加载AX寄存器。
- en: In order to differentiate between instructions that encode an address using
    the [xxxx] or [xxxx`+bx`] addressing modes, or to encode a constant using the
    immediate addressing mode, you must append the 16-bit address or constant to the
    instruction’s opcode. Within this 16-bit address or constant, the LO byte follows
    the opcode in memory and the HO byte follows the LO byte. So, the 3-byte encoding
    for `mov([1000], ax);` would be `$c6,` `$00,` `$10`, and the 3-byte encoding for
    `mov([2000], ax);` would be `$c6,` `$00,` `$20`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分使用[xxxx]或[xxxx`+bx`]寻址模式编码地址的指令，或使用立即寻址模式编码常数的指令，你必须将16位地址或常数附加到指令的操作码中。在这个16位地址或常数中，LO字节在内存中紧随操作码，HO字节则紧跟LO字节。因此，`mov([1000],
    ax);`的3字节编码为`$c6`、`$00`、`$10`，而`mov([2000], ax);`的3字节编码为`$c6`、`$00`、`$20`。
- en: '**10.3.4.2 The Special Expansion Opcode**'
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.3.4.2 特殊扩展操作码**'
- en: The special opcode in [Figure 10-3](ch10.xhtml#ch10fig03) allows the Y86 CPU
    to expand the set of available instructions that can be encoded using a single
    byte. This opcode handles several zero- and one-operand instructions, as shown
    in [Figures 10-4](ch10.xhtml#ch10fig04) and [10-5](ch10.xhtml#ch10fig05).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-3](ch10.xhtml#ch10fig03)中的特殊操作码使Y86 CPU能够扩展可通过单字节编码的指令集。该操作码处理多个零操作数和单操作数指令，如[图
    10-4](ch10.xhtml#ch10fig04)和[图 10-5](ch10.xhtml#ch10fig05)所示。'
- en: '[Figure 10-4](ch10.xhtml#ch10fig04) shows the encodings of four one-operand
    instruction classes. The first 2-bit encoding for the `rr` field, `%00`, further
    expands the instruction set by providing a way to encode the zero-operand instructions
    shown in [Figure 10-5](ch10.xhtml#ch10fig05). Five of these instructions are illegal
    instruction opcodes; the three valid opcodes are the `halt` instruction, which
    terminates program execution; the `get` instruction, which reads a hexadecimal
    value from the user and stores it in the AX register; and the `put` instruction,
    which outputs the value in the AX register.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-4](ch10.xhtml#ch10fig04)展示了四种单操作数指令类的编码。`rr`字段的前2位编码`%00`进一步扩展了指令集，通过提供一种编码零操作数指令的方法，如[图
    10-5](ch10.xhtml#ch10fig05)所示。这些指令中有五条是非法操作码；三条合法操作码是`halt`指令，用于终止程序执行；`get`指令，用于从用户读取十六进制值并存储到AX寄存器中；以及`put`指令，用于输出AX寄存器中的值。'
- en: '![image](../images/10fig04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig04.jpg)'
- en: '*Figure 10-4: Single-operand instruction encodings (`iii = %000`)*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：单操作数指令编码（`iii = %000`）*'
- en: '![image](../images/10fig05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig05.jpg)'
- en: '*Figure 10-5: Zero-operand instruction encodings (`iii = %000` and `rr = %00`)*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：零操作数指令编码（`iii = %000`和`rr = %00`）*'
- en: The second 2-bit encoding for the `rr` field, `%01`, is also part of an expansion
    opcode that provides all the Y86 jump instructions (see [Figure 10-6](ch10.xhtml#ch10fig06)).
    The third `rr` field encoding, `%10`, is for the `not` instruction. The fourth
    `rr` field encoding is currently unassigned. Any attempt to execute an opcode
    with an `iii` field encoding of `%000` and an `rr` field encoding of `%11` will
    halt the processor with an illegal instruction error. As previously discussed,
    CPU designers often reserve unassigned opcodes like this one so they can extend
    the instruction set in the future (as Intel did when moving from the 80286 processor
    to the 80386 or from the 32-bit x86 processors to the 64-bit x86-64 processors).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`rr` 字段的第二个 2 位编码 `%01` 也是一个扩展操作码的一部分，提供了所有 Y86 跳转指令（参见 [图 10-6](ch10.xhtml#ch10fig06)）。第三个
    `rr` 字段编码 `%10` 用于 `not` 指令。第四个 `rr` 字段编码目前尚未分配。任何试图执行 `iii` 字段编码为 `%000` 且 `rr`
    字段编码为 `%11` 的操作码的操作都会导致处理器因非法指令错误而停止。正如前面所讨论的，CPU 设计师通常会保留未分配的操作码，以便未来扩展指令集（如英特尔在从
    80286 处理器过渡到 80386 或从 32 位 x86 处理器过渡到 64 位 x86-64 处理器时所做的那样）。'
- en: The seven jump instructions in the Y86 instruction set all take the form `j`xx
    address`;`. The `jmp` instruction copies the 16-bit address value that follows
    the opcode into the instruction pointer register, causing the CPU to fetch the
    next instruction from the target address of the `jmp`. The remaining six instructions—`ja`,
    `jae`, `jb`, `jbe`, `je`, and `jne`—test some condition and, if it is `true`,
    copy the address value into the instruction pointer register. The eighth opcode,
    `%00001111`, is another illegal opcode. These encodings are shown in [Figure 10-6](ch10.xhtml#ch10fig06).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Y86 指令集中的七个跳转指令都采用 `j`xx 地址`;` 的形式。`jmp` 指令将跟随操作码后的 16 位地址值复制到指令指针寄存器中，导致 CPU
    从 `jmp` 的目标地址获取下一条指令。其余六条指令—`ja`、`jae`、`jb`、`jbe`、`je` 和 `jne`—会测试某个条件，如果条件为 `true`，则将地址值复制到指令指针寄存器中。第八个操作码
    `%00001111` 是另一个非法操作码。这些编码显示在 [图 10-6](ch10.xhtml#ch10fig06) 中。
- en: '![image](../images/10fig06.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig06.jpg)'
- en: '*Figure 10-6: Jump instruction encodings*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：跳转指令编码*'
- en: '***10.3.5 Examples of Encoding Y86 Instructions***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.3.5 编码 Y86 指令的示例***'
- en: The Y86 processor does not execute instructions as human-readable strings of
    characters like `mov(ax, bx);`. Instead, it fetches instructions as bit patterns,
    such as `$c1`, from memory, then decodes and executes those bit patterns. Human-readable
    instructions like `mov(ax,` `bx);` and `add(5,` `cx);` must first be converted
    into binary representation, or *[machine code](gloss01.xhtml#gloss01_142)*. This
    section will explore this conversion.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Y86 处理器并不像人类可读的字符串（例如 `mov(ax, bx);`）那样执行指令。相反，它从内存中获取指令的位模式，例如 `$c1`，然后解码并执行这些位模式。像
    `mov(ax,` `bx);` 和 `add(5,` `cx);` 这样的可读指令必须首先转换为二进制表示，或 *[机器码](gloss01.xhtml#gloss01_142)*。本节将探讨这种转换。
- en: '**10.3.5.1 The add Instruction**'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.3.5.1 add 指令**'
- en: We’ll start our conversion with a very simple example, the `add(cx,` `dx);`
    instruction. Once you’ve chosen the instruction, you look it up in one of the
    opcode figures from the previous section. The `add` instruction is in the first
    group (see [Figure 10-3](ch10.xhtml#ch10fig03)) and has an `iii` field of `%101`.
    The source operand is `cx`, so the `mmm` field is `%010`. The destination operand
    is `dx`, so the `rr` field is `%11`. Merging these bits produces the opcode `%10111010`,
    or `$ba` (see [Figure 10-7](ch10.xhtml#ch10fig07)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个非常简单的例子开始转换，即 `add(cx,` `dx);` 指令。一旦选择了指令，就可以在前一节的操作码图中查找该指令。`add` 指令位于第一组（参见
    [图 10-3](ch10.xhtml#ch10fig03)），其 `iii` 字段为 `%101`。源操作数是 `cx`，因此 `mmm` 字段为 `%010`。目标操作数是
    `dx`，所以 `rr` 字段为 `%11`。将这些位合并产生操作码 `%10111010`，即 `$ba`（参见 [图 10-7](ch10.xhtml#ch10fig07)）。
- en: '![image](../images/10fig07.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig07.jpg)'
- en: '*Figure 10-7: Encoding the `add(` `cx,` `dx` `);` instruction*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-7：编码 `add(` `cx,` `dx` `);` 指令*'
- en: Now consider the `add(5, ax)` instruction. Because it has an immediate source
    operand (a constant), the `mmm` field will be `%111` (see [Figure 10-3](ch10.xhtml#ch10fig03)).
    The destination register operand is `ax` (`%00`), and the instruction class field
    is `%101`, so the full opcode becomes `%10100111`, or `$a7`. However, we’re not
    finished yet. We also have to include the 16-bit constant `$0005` as part of the
    instruction, with the LO byte of the constant following the opcode, and the HO
    byte of the constant following its LO byte, because the bytes are arranged in
    little-endian order. So, the sequence of bytes in memory, from lowest address
    to highest address, is `$a7,` `$05,` `$00` (see [Figure 10-8](ch10.xhtml#ch10fig08)).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑`add(5, ax)`指令。由于它有一个立即数源操作数（常数），`mmm`字段将是`%111`（见[图10-3](ch10.xhtml#ch10fig03)）。目标寄存器操作数是`ax`（`%00`），指令类字段是`%101`，所以完整的操作码为`%10100111`，即`$a7`。然而，我们还没有完成。我们还必须将16位常数`$0005`作为指令的一部分，常数的低字节紧随操作码之后，高字节紧随低字节之后，因为字节是以小端字节序排列的。因此，内存中的字节序列从最低地址到最高地址是`$a7,`
    `$05,` `$00`（见[图10-8](ch10.xhtml#ch10fig08)）。
- en: '![image](../images/10fig08.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig08.jpg)'
- en: '*Figure 10-8: Encoding the `add(` `5,` `ax` `);` instruction*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-8：编码`add(` `5,` `ax` `);`指令*'
- en: 'The `add([2ff+bx],` `cx)` instruction also contains a 16-bit constant that
    is the displacement portion of the indexed addressing mode. To encode this instruction,
    we use the following field values: `iii` = `%101`, `rr` = `%10`, and `mmm` = `%101`.
    This produces the opcode byte `%10110101`, or `$b5`. The complete instruction
    also requires the constant `$2ff`, so the full instruction is the 3-byte sequence
    `$b5,` `$ff,` `$02` (see [Figure 10-9](ch10.xhtml#ch10fig09)).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`add([2ff+bx],` `cx)`指令还包含一个16位常数，它是索引寻址模式中的位移部分。为了编码这条指令，我们使用以下字段值：`iii` =
    `%101`，`rr` = `%10`，`mmm` = `%101`。这产生了操作码字节`%10110101`，即`$b5`。完整的指令还需要常数`$2ff`，因此完整的指令是3字节序列`$b5,`
    `$ff,` `$02`（见[图10-9](ch10.xhtml#ch10fig09)）。'
- en: '![image](../images/10fig09.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig09.jpg)'
- en: '*Figure 10-9: Encoding the `add(` `[$2ff+bx],` `cx` `);` instruction*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-9：编码`add(` `[$2ff+bx],` `cx` `);`指令*'
- en: Now consider `add([1000],` `ax)`. This instruction adds the 16-bit contents
    of memory locations `$1000` and `$1001` to the value in the AX register. Once
    again, `iii` = `%101` for the `add` instruction. The destination register is `ax`,
    so `rr` = `%00`. Finally, the addressing mode is the displacement-only addressing
    mode, so `mmm` = `%110`. This forms the opcode `%10100110`, or `$a6`. The complete
    instruction is 3 bytes long, because it must also encode the displacement (address)
    of the memory location in the 2 bytes following the opcode. Therefore, the complete
    3-byte sequence is `$a6,` `$00,` `$10` (see [Figure 10-10](ch10.xhtml#ch10fig10)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑`add([1000],` `ax)`。该指令将内存位置`$1000`和`$1001`中的16位内容加到AX寄存器中的值上。再次强调，`iii`
    = `%101`用于`add`指令。目标寄存器是`ax`，因此`rr` = `%00`。最后，寻址模式是仅位移寻址模式，因此`mmm` = `%110`。这就形成了操作码`%10100110`，即`$a6`。完整的指令长度为3个字节，因为它还必须在操作码后的2个字节中编码内存位置的位移（地址）。因此，完整的3字节序列是`$a6,`
    `$00,` `$10`（见[图10-10](ch10.xhtml#ch10fig10)）。
- en: '![image](../images/10fig10.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig10.jpg)'
- en: '*Figure 10-10: Encoding the `add(` `[1000],` `ax` `);` instruction*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-10：编码`add(` `[1000],` `ax` `);`指令*'
- en: 'The last addressing mode to consider is the register indirect addressing mode,
    `[bx]`. The `add([bx],bx)` instruction uses the following encoded values: `mmm`
    = `%101`, `rr` = `%01` (`bx`), and `mmm` = `%100` (`[bx]`). Because the value
    in the BX register completely specifies the memory address, there’s no need to
    attach a displacement field to the instruction’s encoding. Hence, this instruction
    is only 1 byte long (see [Figure 10-11](ch10.xhtml#ch10fig11)).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要考虑的寻址模式是寄存器间接寻址模式`[bx]`。`add([bx],bx)`指令使用以下编码值：`mmm` = `%101`，`rr` = `%01`（`bx`），`mmm`
    = `%100`（`[bx]`）。由于BX寄存器中的值完全指定了内存地址，因此无需为指令编码附加位移字段。因此，该指令仅为1个字节长（见[图10-11](ch10.xhtml#ch10fig11)）。
- en: '![image](../images/10fig11.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig11.jpg)'
- en: '*Figure 10-11: Encoding the `add([bx],` `bx);` instruction*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-11：编码`add([bx],` `bx);`指令*'
- en: You use a similar approach to encode the `sub`, `cmp`, `and`, and `or` instructions.
    The only difference between encoding these instructions and the `add` instruction
    is the value you use for the `iii` field in the opcode.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用类似的方法来编码`sub`、`cmp`、`and`和`or`指令。编码这些指令与`add`指令之间唯一的区别在于你在操作码中的`iii`字段使用的值。
- en: '**10.3.5.2 The mov Instruction**'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.3.5.2 mov指令**'
- en: The Y86 `mov` instruction is special, because it comes in two forms. The only
    difference between the encoding of the `add` instruction and the encoding of the
    `mov` instruction’s first form (`iii` = `%110`) is the `iii` field. This form
    of `mov` copies either a constant or data from the register or memory address
    specified by the `mmm` field into the destination register specified by the `rr`
    field.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Y86 的 `mov` 指令是特别的，因为它有两种形式。`add` 指令的编码和 `mov` 指令第一种形式的编码（`iii` = `%110`）之间的唯一区别是
    `iii` 字段。这种形式的 `mov` 将常量或由 `mmm` 字段指定的寄存器或内存地址的数据复制到由 `rr` 字段指定的目标寄存器。
- en: 'The second form of the `mov` instruction (`iii` = `%111`) copies data from
    the source register specified by the `rr` field to a destination memory location
    specified by the `mmm` field. In this form of the `mov` instruction, the source
    and destination meanings of the `rr` and `mmm` fields are reversed: `rr` is the
    source field and `mmm` is the destination field. Another difference between the
    two forms of `mov` is that in its second form, the `mmm` field may contain only
    the values `%100` (`[bx]`), `%101` (`[disp+bx]`), and `%110` (`[disp]`). The destination
    values can’t be any of the registers encoded by `mmm` field values in the range
    `%000` through `%011` or a constant encoded by an `mmm` field of `%111`. These
    encodings are illegal because the first form of the `mov` handles cases with a
    register destination, and because storing data into a constant doesn’t make any
    sense.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式的 `mov` 指令（`iii` = `%111`）将数据从 `rr` 字段指定的源寄存器复制到 `mmm` 字段指定的目标内存位置。在这种形式的
    `mov` 指令中，`rr` 和 `mmm` 字段的源和目标含义是颠倒的：`rr` 是源字段，`mmm` 是目标字段。另一种区别是，在第二种形式的 `mov`
    指令中，`mmm` 字段只能包含 `%100` (`[bx]`)、`%101` (`[disp+bx]`) 和 `%110` (`[disp]`) 这些值。目标值不能是
    `mmm` 字段在 `%000` 到 `%011` 范围内编码的任何寄存器，或者是由 `mmm` 字段为 `%111` 编码的常量。这些编码是非法的，因为
    `mov` 的第一种形式处理的是寄存器目标的情况，而且将数据存储到常量中没有任何意义。
- en: '**10.3.5.3 The not Instruction**'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.3.5.3 not 指令**'
- en: 'The `not` instruction is the only instruction with a single memory/register
    operand that the Y86 processor supports. It has the following syntax:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`not` 指令是 Y86 处理器支持的唯一具有单一内存/寄存器操作数的指令。它的语法如下：'
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'or:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: where address represents one of the memory addressing modes (`[bx]`, `[disp+bx]`,
    or `[disp]`). You may not specify a constant operand for the `not` instruction.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，地址表示一种内存寻址模式（`[bx]`、`[disp+bx]` 或 `[disp]`）。你不能为 `not` 指令指定常量操作数。
- en: Because `not` has only a single operand, it needs only the `mmm` field to encode
    that operand. An `iii` field of `%000` and an `rr` field of `%10` identify the
    `not` instruction. In fact, whenever the `iii` field contains `0`, the CPU knows
    that it has to decode bits beyond the `iii` field to identify the instruction.
    In this case, the `rr` field specifies whether we’ve encoded `not` or one of the
    other specially encoded instructions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `not` 只有一个操作数，所以它只需要 `mmm` 字段来编码该操作数。`iii` 字段为 `%000` 和 `rr` 字段为 `%10` 可以标识
    `not` 指令。实际上，只要 `iii` 字段包含 `0`，CPU 就知道它必须解码超出 `iii` 字段的位来识别指令。在这种情况下，`rr` 字段指定我们编码的是
    `not` 还是其他一些特殊编码的指令。
- en: To encode an instruction like `not(ax)`, specify `%000` for the `iii` field
    and `%10` for the `rr` field, then encode the `mmm` field the same way you would
    encode it for the `add` instruction. Because `mmm` *= `%000` for AX, `not(ax)`
    would be encoded as `%00010000`, or `$10` (see [Figure 10-12](ch10.xhtml#ch10fig12)).*
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要编码类似 `not(ax)` 的指令，指定 `iii` 字段为 `%000`，`rr` 字段为 `%10`，然后按照 `add` 指令的编码方式编码
    `mmm` 字段。因为 `mmm` *= `%000` 对应于 AX，`not(ax)` 将被编码为 `%00010000`，即 `$10`（参见 [图 10-12](ch10.xhtml#ch10fig12)）。*
- en: '*![image](../images/10fig12.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*![image](../images/10fig12.jpg)'
- en: '*Figure 10-12: Encoding the `not(AX);` instruction*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-12: 编码 `not(AX);` 指令*'
- en: The `not` instruction does not allow an immediate, or constant, operand, so
    the opcode `%00010111` (`$17`) is an illegal opcode.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`not` 指令不允许立即数或常量操作数，因此操作码 `%00010111` (`$17`) 是非法的操作码。'
- en: '**10.3.5.4 The Jump Instructions**'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.3.5.4 跳转指令**'
- en: The Y86 jump instructions also use the special encoding, meaning that the `iii`
    field for jump instructions is always `%000`. These instructions are always 3
    bytes long. The first byte, the opcode, specifies which jump instruction to execute,
    and the next 2 bytes specify the address in memory to which the CPU transfers
    control (if the condition is met, in the case of the conditional jumps). There
    are seven different Y86 jump instructions, six conditional jumps, and one unconditional
    jump, `jmp`. All seven of these instructions set `iii` = `%000` and `rr` = `%01`,
    so they differ only by their `mmm` fields. The eighth possible opcode, with an
    `mmm` field value of `%111`, is an illegal opcode (see [Figure 10-6](ch10.xhtml#ch10fig06)).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Y86 跳转指令也使用特殊编码，这意味着跳转指令的`iii`字段总是`%000`。这些指令总是 3 字节长。第一个字节是操作码，指定要执行的跳转指令，接下来的
    2 个字节指定内存中 CPU 要跳转到的地址（如果条件满足，针对条件跳转的情况）。Y86 有七种不同的跳转指令，六种条件跳转和一种无条件跳转`jmp`。这七种指令都将`iii`
    = `%000`和`rr` = `%01`，因此它们仅在`mmm`字段上有所不同。第八个可能的操作码，`mmm`字段值为`%111`，是非法操作码（见[图
    10-6](ch10.xhtml#ch10fig06)）。
- en: Encoding these instructions is relatively straightforward. Picking the instruction
    you want to encode completely determines the opcode. The opcode values fall in
    the range `$08` through `$0e` (`$0f` is the illegal opcode).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 编码这些指令相对简单。选择你要编码的指令就能完全确定操作码。操作码的值范围是`$08`到`$0e`（`$0f`是非法操作码）。
- en: The only field that requires some thought is the 16-bit operand that follows
    the opcode. This field holds the address of the target instruction to which the
    unconditional jump always transfers, and to which the conditional jumps transfer
    if the transfer condition is `true`. To properly encode this 16-bit operand, you
    must know the address of the opcode byte of the target instruction. If you’ve
    already converted the target instruction to binary form and stored it into memory,
    you’re all set—just specify the target instruction’s address as the sole operand
    of the jump instruction. On the other hand, if you haven’t yet written, converted,
    and placed the target instruction into memory, knowing its address would seem
    to require a bit of divination. Fortunately, you can figure it out by computing
    the lengths of all the instructions between the current jump instruction you’re
    encoding and the target instruction—but unfortunately, this is an arduous task.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要考虑的字段是操作码后面的 16 位操作数。这个字段保存目标指令的地址，目标指令是无条件跳转总是跳转到的指令，也是条件跳转在条件为`true`时跳转到的指令。要正确编码这个
    16 位操作数，你必须知道目标指令操作码字节的地址。如果你已经将目标指令转换成二进制形式并存储到内存中，那么就不成问题——只需将目标指令的地址指定为跳转指令的唯一操作数。另一方面，如果你还没有编写、转换并将目标指令放入内存，那么知道它的地址似乎需要一些预言的技巧。幸运的是，你可以通过计算当前跳转指令和目标指令之间所有指令的长度来弄清楚——但不幸的是，这是一个艰巨的任务。
- en: The best way to calculate the distance is to write all your instructions down
    on paper, compute their lengths (which is easy, because all instructions are either
    1 or 3 bytes long depending on whether they have a 16-bit operand), and then assign
    an appropriate address to each instruction. Once you’ve done this, you’ll know
    the starting address for each instruction, and you can put target address operands
    into your jump instructions as you encode them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 计算距离的最佳方法是将所有指令写在纸上，计算它们的长度（这很容易，因为所有指令要么是 1 字节，要么是 3 字节，具体取决于是否有 16 位操作数），然后为每条指令分配一个合适的地址。完成后，你就知道每条指令的起始地址，并且可以在编码时将目标地址操作数放入你的跳转指令中。
- en: '**10.3.5.5 The Zero-Operand Instructions**'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.3.5.5 零操作数指令**'
- en: The remaining instructions, the zero-operand instructions, are the easiest to
    encode. Because they have no operands, they are always 1 byte long. These instructions
    always have `iii` = `%000` and `rr` = `%00`, and `mmm` specifies the particular
    instruction opcode (see [Figure 10-5](ch10.xhtml#ch10fig05)). Note that the Y86
    CPU leaves five of these instructions undefined (so we can use these opcodes for
    future expansion).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的指令，即零操作数指令，是最容易编码的。因为它们没有操作数，所以它们总是 1 字节长。这些指令总是具有`iii` = `%000`和`rr` = `%00`，而`mmm`指定特定的指令操作码（见[图
    10-5](ch10.xhtml#ch10fig05)）。注意，Y86 CPU 将五个这样的指令未定义（因此我们可以将这些操作码用于未来的扩展）。
- en: '***10.3.6 Extending the Y86 Instruction Set***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.3.6 扩展 Y86 指令集***'
- en: The Y86 CPU is a trivial CPU, suitable only for demonstrating how to encode
    machine instructions. However, as with any good CPU, the Y86 design allows for
    expansion by adding new instructions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Y86 CPU是一个简单的CPU，仅适合用于演示如何编码机器指令。然而，和任何优秀的CPU一样，Y86设计允许通过添加新指令来进行扩展。
- en: You can extend the number of instructions in a CPU’s instruction set by using
    either undefined or illegal opcodes. So, because the Y86 CPU has several illegal
    and undefined opcodes, we’ll use them to expand the instruction set.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用未定义或非法操作码来扩展CPU的指令集。因此，由于Y86 CPU有几个非法和未定义的操作码，我们将利用它们来扩展指令集。
- en: Using undefined opcodes to define new instructions works best when there are
    undefined bit patterns within an opcode group, and the new instruction you want
    to add falls into that same group. For example, the opcode `%00011`mmm falls into
    the same group as the `not` instruction, which also has an `iii` field value of
    `%000`. If you decided that you really needed a `neg` (negate) instruction, using
    the `%00011`mmm opcode makes sense because you’d probably expect `neg` to use
    the same syntax as the `not` instruction. Likewise, if you want to add a zero-operand
    instruction to the instruction set, Y86 has five undefined zero-operand instructions
    for you to choose from (`%0000000..%00000100`; see [Figure 10-5](ch10.xhtml#ch10fig05)).
    You’d just appropriate one of these opcodes and assign your instruction to it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未定义操作码来定义新指令最有效的方法是，当操作码组内有未定义的位模式，并且你想要添加的新指令属于同一组时。例如，操作码`%00011`mmm属于与`not`指令相同的组，`not`指令的`iii`字段值也是`%000`。如果你决定确实需要一个`neg`（取反）指令，使用`%00011`mmm操作码是合理的，因为你可能希望`neg`指令使用与`not`指令相同的语法。同样，如果你想向指令集中添加一个零操作数指令，Y86提供了五个未定义的零操作数指令供你选择（`%0000000..%00000100`；见[图10-5](ch10.xhtml#ch10fig05)）。你只需占用其中一个操作码，并将你的指令分配给它。
- en: Unfortunately, the Y86 CPU doesn’t have many illegal opcodes available. For
    example, if you wanted to add the `shl` (shift left), `shr` (shift right), `rol`
    (rotate left), and `ror` (rotate right) instructions as single-operand instructions,
    there’s not enough space within the group of single-operand instruction opcodes
    to do so (only `%00011`mmm is currently open). Likewise, there are no two-operand
    opcodes open, so if you wanted to add an `xor` (exclusive OR) instruction or some
    other two-operand instruction, you’d be out of luck.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Y86 CPU没有很多非法操作码可用。例如，如果你想添加`shl`（左移）、`shr`（右移）、`rol`（左旋转）和`ror`（右旋转）指令作为单操作数指令，那么单操作数指令操作码组内没有足够的空间（目前只有`%00011`mmm是开放的）。同样，也没有开放的双操作数操作码，因此如果你想添加`xor`（异或）指令或其他双操作数指令，你将会遇到困难。
- en: A common way to handle this dilemma, and one the Intel designers have employed,
    is to use one of the undefined opcodes as a prefix opcode byte. For example, the
    opcode `$ff` is illegal (it corresponds to a `mov(dx,` constant`)` instruction),
    but we can use it as a special prefix byte to further expand the instruction set
    (see [Figure 10-13](ch10.xhtml#ch10fig13)).^([4](footnotes.xhtml#fn10_4a))
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种困境的一种常见方法，也是英特尔设计师采用的方法，是使用未定义的操作码作为前缀操作码字节。例如，操作码`$ff`是非法的（它对应于`mov(dx,`常量`)`指令），但我们可以将其用作特殊前缀字节，进一步扩展指令集（见[图10-13](ch10.xhtml#ch10fig13)）。^([4](footnotes.xhtml#fn10_4a))
- en: '![image](../images/10fig13.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig13.jpg)'
- en: '*Figure 10-13: Using a prefix byte to extend the instruction set*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-13：使用前缀字节扩展指令集*'
- en: Whenever the CPU encounters a prefix byte in memory, it reads and decodes the
    next byte in memory as the actual opcode. However, it doesn’t treat the second
    byte as it would a standard opcode that did not follow a prefix byte. Instead,
    it allows the CPU designer to create a completely new opcode scheme, independent
    of the original instruction set. A single-expansion opcode byte allows CPU designers
    to add up to 256 more instructions to the instruction set. For even more instructions,
    designers can use additional illegal opcode bytes (in the original instruction
    set) to add still more expansion opcodes, each with its own independent instruction
    set; or they can follow the opcode expansion prefix byte with a 2-byte opcode
    (yielding up to 65,536 new instructions); or they can execute any other scheme
    they can dream up.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 CPU 在内存中遇到前缀字节时，它会读取并解码内存中的下一个字节作为实际的操作码。然而，它不会像处理没有前缀字节的标准操作码那样处理第二个字节。相反，它允许
    CPU 设计师创建一个完全新的操作码方案，独立于原始指令集。单字节扩展操作码允许 CPU 设计师将最多 256 条指令添加到指令集中。为了增加更多的指令，设计师可以使用原始指令集中未使用的非法操作码字节来添加更多的扩展操作码，每个扩展操作码都有自己独立的指令集；或者他们可以在操作码扩展前缀字节后添加一个
    2 字节的操作码（最多增加 65,536 条新指令）；或者他们可以执行任何他们能想到的其他方案。
- en: Of course, one big drawback of this approach is that it increases the size of
    the new instructions by 1 byte, because each instruction now requires the prefix
    byte as part of the opcode. This also increases the cost of the circuitry (since
    decoding prefix bytes and multiple instruction sets is fairly complex), so you
    don’t want to use this scheme for the basic instruction set. Nevertheless, it
    is a good way to expand the instruction set when you’ve run out of opcodes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种方法的一个重大缺点是它将新指令的大小增加了 1 字节，因为每条指令现在都需要将前缀字节作为操作码的一部分。这也增加了电路的成本（因为解码前缀字节和多重指令集相对复杂），所以你不希望对基本指令集使用这种方案。尽管如此，当操作码用尽时，这是一种扩展指令集的好方法。
- en: '**10.4 Encoding 80x86 Instructions**'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.4 编码 80x86 指令**'
- en: 'The Y86 processor is simple to understand; we can easily encode instructions
    by hand for it, and it’s a great vehicle for learning how to assign opcodes. It’s
    also a purely hypothetical device intended only as a teaching tool. So, it’s time
    to take a look at the machine instruction format for a real CPU: the 80x86\. After
    all, the programs you write will run on a real CPU, so to fully appreciate what
    your compilers are doing with your code—so you can choose the best statements
    and data structures when writing that code—you need to understand how real instructions
    are encoded.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Y86 处理器易于理解；我们可以轻松地手动为其编码指令，它是学习如何分配操作码的绝佳工具。它也是一个完全假设的设备，仅作为教学工具。因此，是时候看一看真实
    CPU 的机器指令格式了：80x86。毕竟，你编写的程序将在真实的 CPU 上运行，因此，为了充分理解编译器如何处理你的代码——以便在编写代码时选择最佳的语句和数据结构——你需要理解真实指令是如何编码的。
- en: Even if you’re using a different CPU, studying the 80x86 instruction encoding
    is helpful. They don’t call the 80x86 a *complex* instruction set computer (CISC)
    chip for nothing. Although more complex instruction encodings do exist, no one
    would challenge the assertion that it’s one of the more complex instruction sets
    in common use today. Therefore, exploring it will provide valuable insight into
    the operation of other real-world CPUs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你使用的是不同的 CPU，研究 80x86 指令编码仍然很有帮助。他们之所以称 80x86 为*复杂*指令集计算机（CISC）芯片，绝非没有理由。虽然确实存在更复杂的指令编码，但没有人会挑战它是目前常用的更复杂的指令集之一的说法。因此，探索它将为理解其他现实世界
    CPU 的运行提供宝贵的见解。
- en: The generic 80x86 32-bit instruction takes the form shown in [Figure 10-14](ch10.xhtml#ch10fig14).^([5](footnotes.xhtml#fn10_5a))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通用 80x86 32 位指令的形式如[图 10-14](ch10.xhtml#ch10fig14)所示。^([5](footnotes.xhtml#fn10_5a))
- en: '![image](../images/10fig14.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig14.jpg)'
- en: '*Figure 10-14: 80x86 32-bit instruction encoding*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-14：80x86 32 位指令编码*'
- en: '**NOTE**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although this diagram seems to imply that instructions can be up to 16 bytes
    long, 15 bytes is actually the limit.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管这个图表似乎暗示指令的最大长度可以达到 16 字节，但实际上 15 字节才是上限。*'
- en: The prefix bytes are not the same as the opcode expansion prefix byte that we
    discussed in the previous section. Instead, the 80x86 prefix bytes modify the
    behavior of existing instructions. An instruction may have a maximum of four prefix
    bytes attached to it, but the 80x86 supports more than four different prefix values.
    The behaviors of many prefix bytes are mutually exclusive, and the results of
    an instruction will be undefined if you prepend a pair of mutually exclusive prefix
    bytes to it. We’ll take a look at a couple of these prefix bytes in a moment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀字节不同于我们在上一节讨论的操作码扩展前缀字节。相反，80x86前缀字节修改现有指令的行为。每条指令最多可以附加四个前缀字节，但80x86支持超过四个不同的前缀值。许多前缀字节的行为是互斥的，如果你在指令前添加一对互斥的前缀字节，指令的结果将是未定义的。稍后我们将看一下这些前缀字节中的几个。
- en: 'The (32-bit) 80x86 supports two basic opcode sizes: a standard 1-byte opcode
    and a 2-byte opcode consisting of a `$0f` opcode expansion prefix byte and a second
    byte specifying the actual instruction. One way to think of this opcode expansion
    prefix byte is as an 8-bit extension of the `iii` field in the Y86 encoding. This
    enables the encoding of up to 512 different instruction classes, although the
    80x86 doesn’t yet use them all. In reality, various instruction classes use certain
    bits in this opcode expansion prefix byte for decidedly non-instruction-class
    purposes. For example, consider the `add` instruction opcode shown in [Figure
    10-15](ch10.xhtml#ch10fig15).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: （32位）80x86支持两种基本的操作码大小：标准的1字节操作码和由`$0f`操作码扩展前缀字节和第二个字节组成的2字节操作码，后者指定实际的指令。可以将这个操作码扩展前缀字节视为Y86编码中`iii`字段的8位扩展。这使得能够编码最多512种不同的指令类别，尽管80x86并没有全部使用它们。实际上，许多指令类别使用此操作码扩展前缀字节中的某些位，用于明确与指令类别无关的用途。例如，考虑一下[图10-15](ch10.xhtml#ch10fig15)中显示的`add`指令操作码。
- en: Bit 1 (`d`) specifies the direction of the transfer. If this bit is `0`, then
    the destination operand is a memory location, such as in `add(al,` `[ebx]);`.
    If this bit is `1`, the destination operand is a register, as in `add([ebx],`
    `al);`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 位1（`d`）指定传输的方向。如果该位为`0`，则目标操作数是一个内存位置，例如`add(al,` `[ebx]);`。如果该位为`1`，则目标操作数是一个寄存器，如`add([ebx],`
    `al);`。
- en: '![image](../images/10fig15.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig15.jpg)'
- en: '*Figure 10-15: 80x86 `add` opcode*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-15：80x86 `add`操作码*'
- en: 'Bit 0 (`s`) specifies the size of the operands the `add` instruction operates
    upon. There’s a problem here, however. The 32-bit 80x86 family supports up to
    three different operand sizes: 8-bit operands, 16-bit operands, and 32-bit operands.
    With a single size bit, the instruction can encode only two of these three different
    sizes. In 32-bit operating systems, the vast majority of operands are either 8
    bits or 32 bits, so the 80x86 CPU uses the size bit in the opcode to encode those
    sizes. For 16-bit operands, which occur less frequently than 8-bit or 32-bit operands,
    Intel uses a special opcode prefix byte to specify the size. As long as instructions
    that have 16-bit operands occur less than one out of every eight instructions
    (which is generally the case), this is more compact than adding another bit to
    the instruction’s size. Using a size prefix byte allowed Intel’s designers to
    extend the number of operand sizes without having to change the instruction encoding
    inherited from the original 16-bit processors in this CPU family.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 位0（`s`）指定`add`指令操作的操作数的大小。然而，这里有个问题。32位80x86家族支持最多三种不同的操作数大小：8位操作数、16位操作数和32位操作数。通过一个大小位，指令只能编码这三种大小中的两种。在32位操作系统中，绝大多数操作数是8位或32位的，因此80x86
    CPU使用操作码中的大小位来编码这些大小。对于16位操作数，它们的出现频率低于8位或32位操作数，Intel使用一个特殊的操作码前缀字节来指定大小。只要16位操作数的指令出现频率低于每八条指令中的一条（这通常是情况），这种方式比在指令大小中添加另一个位更为紧凑。使用大小前缀字节使得Intel的设计者能够扩展操作数的大小数量，而无需改变来自原始16位处理器的指令编码。
- en: Note that the AMD/Intel 64-bit architectures go even crazier with opcode prefix
    bytes. However, the CPU operates in a special 64-bit mode; effectively, the 64-bit
    80x86 CPUs (often called the *X86-64 CPUs*) have two completely different instruction
    sets, each with its own encoding. The X86-64 CPUs can switch between 64- and 32-bit
    modes to handle programs written in either of the different instruction sets.
    The encoding in this chapter covers the 32-bit variant; see the Intel or AMD documentation
    for details on the 64-bit version.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，AMD/Intel 的 64 位架构在操作码前缀字节上更为复杂。然而，CPU 在特殊的 64 位模式下运行；实际上，64 位 80x86 CPU（通常称为
    *X86-64 CPUs*）具有两种完全不同的指令集，每种指令集有自己的编码。X86-64 CPU 可以在 64 位和 32 位模式之间切换，以处理使用不同指令集编写的程序。本章中的编码覆盖的是
    32 位变体；有关 64 位版本的详细信息，请参阅 Intel 或 AMD 文档。
- en: '***10.4.1 Encoding Instruction Operands***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.4.1 编码指令操作数***'
- en: The `mod-reg-r/m` byte (see [Figure 10-14](ch10.xhtml#ch10fig14)) provides the
    encoding for instruction operands by specifying the base addressing mode used
    to access them as well as their size. This byte contains the fields shown in [Figure
    10-16](ch10.xhtml#ch10fig16).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod-reg-r/m` 字节（见 [图 10-14](ch10.xhtml#ch10fig14)）通过指定用于访问操作数的基本寻址模式及其大小，提供了指令操作数的编码。这个字节包含了在
    [图 10-16](ch10.xhtml#ch10fig16) 中展示的字段。'
- en: '![image](../images/10fig16.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig16.jpg)'
- en: '*Figure 10-16: `mod-reg-r/m` byte*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-16：`mod-reg-r/m` 字节*'
- en: The `reg` field almost always specifies an 80x86 register. However, depending
    on the instruction, the register specified by `reg` can be either the source or
    the destination operand. To distinguish between the two, many instructions’ upcodes
    include the `d` (direction) field, which contains a value of `0` when `reg` is
    the source and a value of `1` when it’s the destination operand.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`reg` 字段几乎总是指定一个 80x86 寄存器。然而，根据指令的不同，`reg` 指定的寄存器可以是源操作数也可以是目标操作数。为了区分这两者，许多指令的上码包含了
    `d`（方向）字段，当 `reg` 是源操作数时，`d` 的值为 `0`，当 `reg` 是目标操作数时，`d` 的值为 `1`。'
- en: This field uses the 3-bit register encodings found in [Table 10-1](ch10.xhtml#ch10tab01).
    As just discussed, the size bit in the instruction’s opcode indicates whether
    the `reg` field specifies an 8- or 32-bit register (when operating under a modern,
    32-bit operating system). To make the `reg` field specify a 16-bit register, you
    must set the size bit in the opcode to `1`, as well as adding an extra prefix
    byte.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段使用在 [表 10-1](ch10.xhtml#ch10tab01) 中找到的 3 位寄存器编码。如前所述，指令操作码中的大小位指示 `reg`
    字段是指定 8 位还是 32 位寄存器（当在现代 32 位操作系统下运行时）。为了使 `reg` 字段指定一个 16 位寄存器，你必须将操作码中的大小位设置为
    `1`，并且添加一个额外的前缀字节。
- en: '**Table 10-1:** `reg` Field Encodings'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-1：** `reg` 字段编码'
- en: '| **reg value** | **Register if data size is 8 bits** | **Register if data
    size is 16 bits** | **Register if data size is 32 bits** |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **reg 值** | **数据大小为 8 位时的寄存器** | **数据大小为 16 位时的寄存器** | **数据大小为 32 位时的寄存器**
    |'
- en: '| `%000` | `al` | `ax` | `eax` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `%000` | `al` | `ax` | `eax` |'
- en: '| `%001` | `cl` | `cx` | `ecx` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `%001` | `cl` | `cx` | `ecx` |'
- en: '| `%010` | `dl` | `dx` | `edx` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `%010` | `dl` | `dx` | `edx` |'
- en: '| `%011` | `bl` | `bx` | `ebx` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `%011` | `bl` | `bx` | `ebx` |'
- en: '| `%100` | `ah` | `sp` | `esp` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `%100` | `ah` | `sp` | `esp` |'
- en: '| `%101` | `ch` | `bp` | `ebp` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `%101` | `ch` | `bp` | `ebp` |'
- en: '| `%110` | `dh` | `si` | `esi` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `%110` | `dh` | `si` | `esi` |'
- en: '| `%111` | `bh` | `di` | `edi` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `%111` | `bh` | `di` | `edi` |'
- en: With the `d` bit in the opcode of a two-operand instruction indicating whether
    the `reg` field contains the source or destination operand, the `mod` and `r/m`
    fields together specify the other of the two operands. In the case of a single-operand
    instruction like `not` or `neg`, the `reg` field contains an opcode extension,
    and `mod` and `r/m` combine to specify the only operand. The operand addressing
    modes specified by the `mod` and `r/m` fields are listed in [Tables 10-2](#ch10tab02)
    and [10-3](#ch10tab03).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在双操作数指令的操作码中，`d` 位指示 `reg` 字段是包含源操作数还是目标操作数，`mod` 和 `r/m` 字段一起指定另一个操作数。在像 `not`
    或 `neg` 这样的单操作数指令中，`reg` 字段包含操作码扩展，`mod` 和 `r/m` 字段组合在一起指定唯一的操作数。`mod` 和 `r/m`
    字段指定的操作数寻址模式列在 [表 10-2](#ch10tab02) 和 [10-3](#ch10tab03) 中。
- en: '**Table 10-2:** `mod` Field Encodings'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-2：** `mod` 字段编码'
- en: '| mod | **Description** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| mod | **描述** |'
- en: '| `%00` | Specifies register-indirect addressing mode (with two exceptions:
    scaled-index [`sib`] addressing modes with no displacement operand when `r/m =
    %100`; and displacement-only addressing mode when `r/m = %101`). |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `%00` | 指定寄存器间接寻址模式（有两个例外：当 `r/m = %100` 时，没有位移操作数的缩放索引[`sib`]寻址模式；当 `r/m
    = %101` 时，仅为位移的寻址模式）。 |'
- en: '| `%01` | Specifies that a 1-byte signed displacement follows the addressing
    mode byte(s). |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `%01` | 指定后续有一个 1 字节的有符号位移紧跟在寻址模式字节之后。 |'
- en: '| `%10` | Specifies that a 1-byte signed displacement follows the addressing
    mode byte(s). |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `%10` | 指定后续有一个 1 字节的有符号位移紧跟在寻址模式字节之后。 |'
- en: '| `%11` | Specifies direct register access. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `%11` | 指定直接寄存器访问。 |'
- en: '**Table 10-3:** `mod-r/m` Encodings'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-3：** `mod-r/m` 编码'
- en: '| mod | r/m | **Addressing mode** |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| mod | r/m | **寻址模式** |'
- en: '| `%00` | `%000` | `[eax]` |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `%00` | `%000` | `[eax]` |'
- en: '| `%01` | `%000` | `[eax+`disp[8]`]` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `%01` | `%000` | `[eax+`disp[8]`]` |'
- en: '| `%10` | `%000` | `[eax+`disp[32]`]` |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `%10` | `%000` | `[eax+`disp[32]`]` |'
- en: '| `%11` | `%000` | `al`, `ax`, or `eax` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `%11` | `%000` | `al`、`ax` 或 `eax` |'
- en: '| `%00` | `%001` | `[ecx]` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `%00` | `%001` | `[ecx]` |'
- en: '| `%01` | `%001` | `[ecx+`disp[8]`]` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `%01` | `%001` | `[ecx+`disp[8]`]` |'
- en: '| `%10` | `%001` | `[ecx+`disp[32]`]` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `%10` | `%001` | `[ecx+`disp[32]`]` |'
- en: '| `%11` | `%001` | `cl`, `cx`, or `ecx` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `%11` | `%001` | `cl`、`cx` 或 `ecx` |'
- en: '| `%00` | `%010` | `[edx]` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `%00` | `%010` | `[edx]` |'
- en: '| `%01` | `%010` | `[edx+`disp[8]`]` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `%01` | `%010` | `[edx+`disp[8]`]` |'
- en: '| `%10` | `%010` | `[edx+`disp[32]`]` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `%10` | `%010` | `[edx+`disp[32]`]` |'
- en: '| `%11` | `%010` | `dl`, `dx`, or `edx` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `%11` | `%010` | `dl`、`dx` 或 `edx` |'
- en: '| `%00` | `%011` | `[ebx]` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `%00` | `%011` | `[ebx]` |'
- en: '| `%01` | `%011` | `[ebx+`disp[8]`]` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `%01` | `%011` | `[ebx+`disp[8]`]` |'
- en: '| `%10` | `%011` | `[ebx+`disp[32]`]` |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `%10` | `%011` | `[ebx+`disp[32]`]` |'
- en: '| `%11` | `%011` | `bl`, `bx`, or `ebx` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `%11` | `%011` | `bl`、`bx` 或 `ebx` |'
- en: '| `%00` | `%100` | Scaled-index (`sib`) mode |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `%00` | `%100` | 扩展索引（`sib`）模式 |'
- en: '| `%01` | `%100` | `sib` + disp[8] mode |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `%01` | `%100` | `sib` + disp[8] 模式 |'
- en: '| `%10` | `%100` | `sib` + disp[32] mode |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `%10` | `%100` | `sib` + disp[32] 模式 |'
- en: '| `%11` | `%100` | `ah`, `sp`, or `esp` |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `%11` | `%100` | `ah`、`sp` 或 `esp` |'
- en: '| `%00` | `%101` | Displacement-only mode (32-bit displacement) |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `%00` | `%101` | 仅位移模式（32 位位移） |'
- en: '| `%01` | `%101` | `[ebp+`disp[8]`]` |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `%01` | `%101` | `[ebp+`disp[8]`]` |'
- en: '| `%10` | `%101` | `[ebp+`disp[32]`]` |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `%10` | `%101` | `[ebp+`disp[32]`]` |'
- en: '| `%11` | `%101` | `ch`, `bp`, or `ebp` |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `%11` | `%101` | `ch`、`bp` 或 `ebp` |'
- en: '| `%00` | `%110` | `[esi]` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `%00` | `%110` | `[esi]` |'
- en: '| `%01` | `%110` | `[esi+`disp[8]`]` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `%01` | `%110` | `[esi+`disp[8]`]` |'
- en: '| `%10` | `%110` | `[esi+`disp[32]`]` |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `%10` | `%110` | `[esi+`disp[32]`]` |'
- en: '| `%11` | `%110` | `dh`, `si`, or `esi` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `%11` | `%110` | `dh`、`si` 或 `esi` |'
- en: '| `%00` | `%111` | `[edi]` |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `%00` | `%111` | `[edi]` |'
- en: '| `%01` | `%111` | `[edi+`disp[8]`]` |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `%01` | `%111` | `[edi+`disp[8]`]` |'
- en: '| `%10` | `%111` | `[edi+`disp[32]`]` |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `%10` | `%111` | `[edi+`disp[32]`]` |'
- en: '| `%11` | `%111` | `bh`, `di`, or `edi` |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `%11` | `%111` | `bh`、`di` 或 `edi` |'
- en: 'There are a couple of interesting things to note about [Tables 10-2](ch10.xhtml#ch10tab02)
    and [10-3](ch10.xhtml#ch10tab03). First, there are two different forms of the
    [reg+disp] addressing modes: one form with an 8-bit displacement and one form
    with a 32-bit displacement. Addressing modes whose displacement falls in the range
    –128 through +127 require only a single byte after the opcode to encode the displacement.
    Instructions with a displacement that falls within this range will be shorter
    and sometimes faster than instructions whose displacement values are not within
    this range and thus require 4 bytes after the opcode.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '关于 [表 10-2](ch10.xhtml#ch10tab02) 和 [10-3](ch10.xhtml#ch10tab03) 有几个有趣的地方需要注意。首先，`[reg+disp]`
    寻址模式有两种不同的形式：一种形式使用 8 位位移，另一种形式使用 32 位位移。位移范围在 -128 到 +127 之间的寻址模式，仅需要在操作码后面添加一个字节来编码位移。位移值位于此范围内的指令比位移值超出此范围并需要
    4 字节编码的指令通常更短且有时更快。 '
- en: The second thing to note is that there is no `[ebp]` addressing mode. If you
    look at the entry in [Table 10-3](ch10.xhtml#ch10tab03) where this addressing
    mode logically belongs (where `r/m` is `%101` and `mod` is `%00`), you’ll find
    that its slot is occupied by the 32-bit displacement-only addressing mode. The
    basic encoding scheme for addressing modes didn’t allow for a displacement-only
    addressing mode, so Intel “stole” the encoding for `[ebp]` and used that for the
    displacement-only mode. Fortunately, anything you can do with the `[ebp]` addressing
    mode you can also do with the `[ebp+`disp[8]`]` addressing mode by setting the
    8-bit displacement to `0`. While such an instruction is a bit longer than it would
    otherwise need to be if the `[ebp]` addressing mode existed, the same capabilities
    are still there. Intel wisely chose to replace this particular register-indirect
    addressing mode, anticipating that programmers would use it less often than the
    other register-indirect addressing modes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点需要注意的是，**[ebp]** 寄存器寻址模式并不存在。如果你查看 [表 10-3](ch10.xhtml#ch10tab03) 中这个寻址模式应当属于的位置（即
    `r/m` 为 `%101` 且 `mod` 为 `%00`），你会发现该位置被 32 位位移仅寻址模式所占用。寻址模式的基本编码方案并不允许仅使用位移的寻址模式，因此英特尔“偷用了”`[ebp]`的编码，并将其用于仅位移寻址模式。幸运的是，使用`[ebp]`寻址模式时，你可以通过将
    8 位位移设置为 `0`，改用 `[ebp+disp[8]]` 寻址模式来完成相同的操作。尽管这样的指令比实际存在`[ebp]`寻址模式时会稍微长一些，但其功能是一样的。英特尔明智地选择用这种方式替代特定的寄存器间接寻址模式，预见到程序员使用它的频率会比其他寄存器间接寻址模式要少。
- en: Another thing you’ll notice missing from this table are addressing modes of
    the form `[esp]`, `[esp+`disp[8]`]`, and `[esp+`disp[32]`]`. Intel’s designers
    borrowed the encodings for these three addressing modes to support the *[scaled-index
    addressing](gloss01.xhtml#gloss01_222)* modes they added to their 32-bit processors
    in the 80x86 family.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会发现表格中缺少了以下几种寻址模式：`[esp]`、`[esp+disp[8]]` 和 `[esp+disp[32]]`。英特尔的设计师借用了这三种寻址模式的编码，以支持它们在
    80x86 系列的 32 位处理器中添加的 *[缩放索引寻址](gloss01.xhtml#gloss01_222)* 模式。
- en: If `r/m` = `%100` and `mod` = `%00`, this specifies an addressing mode of the
    form `[reg`[`1`]`32+reg`[`2`]`32*n]`. This scaled-index addressing mode computes
    the final address in memory as the sum of `reg`[`2`] multiplied by n (n = `1`,
    `2`, `4`, or `8`) and `reg`[`1`]. Programs most often use this addressing mode
    when `reg`[`1`] is a pointer holding the base address of an array of bytes (n
    = `1`), words (n = `2`), double words (n = `4`), or quad words (n = `8`), and
    `reg`[`2`] holds the index into that array.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `r/m` = `%100` 且 `mod` = `%00`，这表示一种寻址模式，形式为 `[reg[1]32+reg[2]32*n]`。这种缩放索引寻址模式通过将
    `reg[2]` 乘以 n（n = `1`、`2`、`4` 或 `8`），再加上 `reg[1]`，来计算内存中的最终地址。程序通常在 `reg[1]` 是指向字节数组（n
    = `1`）、字数组（n = `2`）、双字数组（n = `4`）或四字数组（n = `8`）的基地址的指针时使用此寻址模式，`reg[2]` 存储该数组的索引。
- en: If `r/m` = `%100` and `mod` = `%01`, this specifies an addressing mode of the
    form `[reg`[`1`]`32+reg`[`2`]`32*`n`+`disp[`8`]`]`. This scaled-index addressing
    mode computes the final address in memory as the sum of `reg`[`2`] multiplied
    by n (n = `1`, `2`, `4`, or `8`), `reg`[`1`], and the 8-bit signed displacement
    (sign-extended to 32 bits). Programs most often use this addressing mode when
    `reg`[`1`] is a pointer holding the base address of an array of records, `reg`[`2`]
    holds the index into that array, and disp[`8`] provides the offset to a desired
    field in the record.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `r/m` = `%100` 且 `mod` = `%01`，这表示一种寻址模式，形式为 `[reg[1]32+reg[2]32*n+disp[8]]`。这种缩放索引寻址模式通过将
    `reg[2]` 乘以 n（n = `1`、`2`、`4` 或 `8`），再加上 `reg[1]` 和 8 位符号位移（符号扩展至 32 位），来计算内存中的最终地址。程序通常在
    `reg[1]` 是指向记录数组基地址的指针时使用此寻址模式，`reg[2]` 存储该数组的索引，`disp[8]` 提供指向记录中所需字段的偏移量。
- en: If `r/m` = `%100` and `mod` = `%10`, this specifies an addressing mode of the
    form `[reg`[`1`]`32+reg`[`2`]`32*n+`disp[`32`]`]`. This scaled-index addressing
    mode computes the final address in memory as the sum of `reg`[`2`] multiplied
    by n (n = `1`, `2`, `4`, or `8`), `reg`[`1`], and the 32-bit signed displacement.
    Programs most often use this addressing mode to index into static arrays of bytes,
    words, double words, or quad words.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `r/m` = `%100` 且 `mod` = `%10`，这表示一种寻址模式，形式为 `[reg[1]32+reg[2]32*n+disp[32]]`。这种缩放索引寻址模式通过将
    `reg[2]` 乘以 n（n = `1`、`2`、`4` 或 `8`），再加上 `reg[1]` 和 32 位符号位移，来计算内存中的最终地址。程序通常在对字节、字、双字或四字的静态数组进行索引时使用此寻址模式。
- en: If values corresponding to one of the `sib` modes appear in the `mod` and `r/m`
    fields, the addressing mode is a scaled-index addressing mode with a second byte
    (the `sib`) following the `mod-reg-r/m` byte, though don’t forget that the `mod`
    field still specifies a displacement size of 0, 1, or 4 bytes. [Figure 10-17](ch10.xhtml#ch10fig17)
    shows the layout of this extra `sib`, and [Tables 10-4](ch10.xhtml#ch10tab04),
    [10-5](ch10.xhtml#ch10tab05), and [10-6](ch10.xhtml#ch10tab06) explain the values
    for each of the `sib` fields.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `sib` 模式的某个值出现在 `mod` 和 `r/m` 字段中，那么寻址模式就是一个缩放索引寻址模式，并且在 `mod-reg-r/m` 字节之后会有一个第二个字节（即
    `sib`）。不过，不要忘记，`mod` 字段仍然指定了 0、1 或 4 字节的位移大小。[图 10-17](ch10.xhtml#ch10fig17) 显示了这个额外的
    `sib` 的布局，[表 10-4](ch10.xhtml#ch10tab04)、[表 10-5](ch10.xhtml#ch10tab05) 和 [表 10-6](ch10.xhtml#ch10tab06)
    解释了每个 `sib` 字段的值。
- en: '![image](../images/10fig17.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig17.jpg)'
- en: '*Figure 10-17: The `sib` (scaled-index byte) layout*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-17：`sib`（缩放索引字节）布局*'
- en: '**Table 10-4:** Scale Values'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-4：** 缩放值'
- en: '| **Scale value** | **Index * scale value** |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **缩放值** | **索引 * 缩放值** |'
- en: '| `%00` | Index * 1 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `%00` | 索引 * 1 |'
- en: '| `%01` | Index * 2 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `%01` | 索引 * 2 |'
- en: '| `%10` | Index * 4 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `%10` | 索引 * 4 |'
- en: '| `%11` | Index * 8 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `%11` | 索引 * 8 |'
- en: '**Table 10-5:** Register Values for `sib` Encoding'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-5：** `sib` 编码的寄存器值'
- en: '| **Index value** | **Register** |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **索引值** | **寄存器** |'
- en: '| `%000` | EAX |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `%000` | EAX |'
- en: '| `%001` | ECX |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `%001` | ECX |'
- en: '| `%010` | EDX |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `%010` | EDX |'
- en: '| `%011` | EBX |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `%011` | EBX |'
- en: '| `%100` | Illegal |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `%100` | 非法 |'
- en: '| `%101` | EBP |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `%101` | EBP |'
- en: '| `%110` | ESI |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `%110` | ESI |'
- en: '| `%111` | EDI |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `%111` | EDI |'
- en: '**Table 10-6:** Base Register Values for `sib` Encoding'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-6：** `sib` 编码的基址寄存器值'
- en: '| **Base value** | **Register** |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| **基址值** | **寄存器** |'
- en: '| `%000` | EAX |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `%000` | EAX |'
- en: '| `%001` | ECX |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `%001` | ECX |'
- en: '| `%010` | EDX |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `%010` | EDX |'
- en: '| `%011` | EBX |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `%011` | EBX |'
- en: '| `%100` | ESP |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `%100` | ESP |'
- en: '| `%101` | Displacement only if `mod` = `%00`, EBP if `mod` = `%01` or `%10`
    |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `%101` | 仅在 `mod` = `%00` 时为位移，如果 `mod` = `%01` 或 `%10` 则为 EBP |'
- en: '| `%110` | ESI |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `%110` | ESI |'
- en: '| `%111` | EDI |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `%111` | EDI |'
- en: The `mod-reg-r/m` and `sib` bytes are complex and convoluted, no question about
    that. The reason is that Intel reused its 16-bit addressing circuitry when it
    switched to the 32-bit format rather than simply abandoning it at that point.
    There were good hardware reasons for retaining it, but the result is a complex
    scheme for specifying addressing modes. As you can imagine, things got even worse
    when Intel and AMD developed the x86-64 architecture.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod-reg-r/m` 和 `sib` 字节是复杂且难以理解的，毫无疑问。原因在于英特尔在转换为 32 位格式时，重用了其 16 位寻址电路，而不是直接放弃它。在那个时候保留它是有合理的硬件原因的，但结果就是指定寻址模式的方案变得非常复杂。正如你可以想象的那样，当英特尔和
    AMD 开发出 x86-64 架构时，情况变得更加糟糕。'
- en: Note that if the `r/m` field of the `mod-reg-r/m` byte contains `%100` and `mod`
    does not contain `%11`, the addressing mode is a `sib` mode rather than the expected
    `[esp]`, `[esp+`disp[`8`]`]`, or `[esp+`disp[`32`]`]` mode. In this case the compiler
    or assembler will emit an extra `sib` byte immediately following the `mod-reg-r/m`
    byte. [Table 10-7](ch10.xhtml#ch10tab07) lists the various combinations of legal
    scaled-index addressing modes on the 80x86.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果 `mod-reg-r/m` 字节的 `r/m` 字段包含 `%100`，并且 `mod` 字段不包含 `%11`，那么寻址模式是 `sib`
    模式，而不是预期的 `[esp]`、`[esp+disp[8]]` 或 `[esp+disp[32]]` 模式。在这种情况下，编译器或汇编器会在 `mod-reg-r/m`
    字节之后立即生成一个额外的 `sib` 字节。[表 10-7](ch10.xhtml#ch10tab07) 列出了 80x86 上合法的缩放索引寻址模式的各种组合。
- en: In each of the addressing modes listed in [Table 10-7](ch10.xhtml#ch10tab07),
    the `mod` field of the `mod-reg-r/m` byte specifies the size of the displacement
    (0, 1, or 4 bytes). The base and index fields of the `sib` specify the base and
    index registers, respectively. Note that this addressing mode does not allow the
    use of ESP as an index register. Presumably, Intel left this particular mode undefined
    to allow for extending the addressing modes to 3 bytes in a future version of
    the CPU, although doing so seems a bit extreme.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 10-7](ch10.xhtml#ch10tab07)中列出的每种寻址模式下，`mod-reg-r/m` 字节的 `mod` 字段指定位移的大小（0、1
    或 4 字节）。`sib` 字段中的基址和索引字段分别指定基址寄存器和索引寄存器。请注意，该寻址模式不允许使用 ESP 作为索引寄存器。推测英特尔之所以将这一特定模式设为未定义，是为了允许将寻址模式扩展到
    3 字节，以便在未来版本的 CPU 中使用，尽管这样做看起来有点极端。
- en: Just as the `mod-reg-r/m` encoding replaced the `[ebp]` addressing mode with
    a displacement-only mode, the `sib` addressing format replaces the `[ebp+`index`*`scale`]`
    mode with a displacement-plus index mode (that is, no base register). If it turns
    out that you really need to use the `[ebp+`index`*`scale`]` addressing mode, you’ll
    have to use the `[`disp[`8`]`+ebp+`index`*`scale`]` mode instead, specifying a
    1-byte displacement value of `0`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `mod-reg-r/m` 编码用位移寻址模式替换了 `[ebp]` 寻址模式一样，`sib` 寻址格式用位移加索引模式（即没有基址寄存器）替换了
    `[ebp+`index`*`scale`]` 模式。如果你确实需要使用 `[ebp+`index`*`scale`]` 寻址模式，你需要改用 `[`disp[`8`]`+ebp+`index`*`scale`]`
    模式，并指定一个值为 `0` 的 1 字节位移。
- en: '**Table 10-7:** The Scaled-Index Addressing Modes'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-7：比例索引寻址模式**'
- en: '| mod | **Index** | **Legal scaled-index addressing modes^([6](footnotes.xhtml#fn10_6a))**
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| mod | **索引** | **合法的比例索引寻址模式^([6](footnotes.xhtml#fn10_6a))** |'
- en: '| `%00`Base ° `%101` | `%000` | `[`base[`32`]`+eax*`n`]` |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `%00`Base ° `%101` | `%000` | `[`base[`32`]`+eax*`n`]` |'
- en: '| `%001` | `[`base[`32`]`+ecx*`n`]` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `%001` | `[`base[`32`]`+ecx*`n`]` |'
- en: '| `%010` | `[`base[`32`]`+edx*`n`]` |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `%010` | `[`base[`32`]`+edx*`n`]` |'
- en: '| `%011` | `[`base[`32`]`+ebx*`n`]` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `%011` | `[`base[`32`]`+ebx*`n`]` |'
- en: '| `%100` | n/a^([7](footnotes.xhtml#fn10_7a)) |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `%100` | n/a^([7](footnotes.xhtml#fn10_7a)) |'
- en: '| `%101` | `[`base[`32`]`+ebp*`n`]` |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `%101` | `[`base[`32`]`+ebp*`n`]` |'
- en: '| `%110` | `[`base[`32`]`+esi*`n`]` |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `%110` | `[`base[`32`]`+esi*`n`]` |'
- en: '| `%111` | `[`base[`32`]`+edi*`n`]` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `%111` | `[`base[`32`]`+edi*`n`]` |'
- en: '| `%00`Base = `%101`^([8](footnotes.xhtml#fn10_8a)) | `%000` | `[`disp[`32`]`+eax*`n`]`
    |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `%00`Base = `%101`^([8](footnotes.xhtml#fn10_8a)) | `%000` | `[`disp[`32`]`+eax*`n`]`
    |'
- en: '| `%001` | `[`disp[`32`]`+ecx*`n`]` |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `%001` | `[`disp[`32`]`+ecx*`n`]` |'
- en: '| `%010` | `[`disp[`32`]`+edx*`n`]` |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `%010` | `[`disp[`32`]`+edx*`n`]` |'
- en: '| `%011` | `[`disp[`32`]`+ebx*`n`]` |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `%011` | `[`disp[`32`]`+ebx*`n`]` |'
- en: '| `%100` | n/a |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `%100` | n/a |'
- en: '| `%101` | `[`disp[`32`]`+ebp*`n`]` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `%101` | `[`disp[`32`]`+ebp*`n`]` |'
- en: '| `%110` | `[`disp[`32`]`+esi*`n`]` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `%110` | `[`disp[`32`]`+esi*`n`]` |'
- en: '| `%111` | `[`disp[`32`]`+edi*`n`]` |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `%111` | `[`disp[`32`]`+edi*`n`]` |'
- en: '| `%01` | `%000` | `[`disp[`8`]`+`base[`32`]`+eax*`n`]` |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `%01` | `%000` | `[`disp[`8`]`+`base[`32`]`+eax*`n`]` |'
- en: '| `%001` | `[`disp[`8`]`+`base[`32`]`+ecx*`n`]` |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `%001` | `[`disp[`8`]`+`base[`32`]`+ecx*`n`]` |'
- en: '| `%010` | `[`disp[`8`]`+`base[`32`]`+edx*`n`]` |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `%010` | `[`disp[`8`]`+`base[`32`]`+edx*`n`]` |'
- en: '| `%011` | `[`disp[`8`]`+`base[`32`]`+ebx*`n`]` |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `%011` | `[`disp[`8`]`+`base[`32`]`+ebx*`n`]` |'
- en: '| `%100` | n/a |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `%100` | n/a |'
- en: '| `%101` | `[`disp[`8`]`+`base[`32`]`+ebp*`n`]` |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `%101` | `[`disp[`8`]`+`base[`32`]`+ebp*`n`]` |'
- en: '| `%110` | `[`disp[`8`]`+`base[`32`]`+esi*`n`]` |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `%110` | `[`disp[`8`]`+`base[`32`]`+esi*`n`]` |'
- en: '| `%111` | `[`disp[`8`]`+`base[`32`]`+edi*`n`]` |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `%111` | `[`disp[`8`]`+`base[`32`]`+edi*`n`]` |'
- en: '| `%10` | `%000` | `[`disp[`32`]`+`base[`32`]`+eax*`n`]` |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `%10` | `%000` | `[`disp[`32`]`+`base[`32`]`+eax*`n`]` |'
- en: '| `%001` | `[`disp[`32`]`+`base[`32`]`+ecx*`n`]` |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `%001` | `[`disp[`32`]`+`base[`32`]`+ecx*`n`]` |'
- en: '| `%010` | `[`disp[`32`]`+`base[`32`]`+edx*`n`]` |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `%010` | `[`disp[`32`]`+`base[`32`]`+edx*`n`]` |'
- en: '| `%011` | `[`disp[`32`]`+`base[`32`]`+ebx*`n`]` |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `%011` | `[`disp[`32`]`+`base[`32`]`+ebx*`n`]` |'
- en: '| `%100` | n/a |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `%100` | n/a |'
- en: '| `%101` | `[`disp[`32`]`+`base[`32`]`+ebp*`n`]` |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `%101` | `[`disp[`32`]`+`base[`32`]`+ebp*`n`]` |'
- en: '| `%110` | `[`disp[`32`]`+`base[`32`]`+esi*`n`]` |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `%110` | `[`disp[`32`]`+`base[`32`]`+esi*`n`]` |'
- en: '| `%111` | `[`disp[`32`]`+`base[`32`]`+edi*`n`]` |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `%111` | `[`disp[`32`]`+`base[`32`]`+edi*`n`]` |'
- en: '***10.4.2 Encoding the add Instruction***'
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.4.2 编码 add 指令***'
- en: To help you figure out how to encode an instruction using this complex scheme,
    let’s look at an example of the 80x86 `add` instruction using various addressing
    modes. The `add` opcode is either `$00`, `$01`, `$02`, or `$03`, depending on
    its direction and size bits (see [Figure 10-15](ch10.xhtml#ch10fig15)). [Figures
    10-18](ch10.xhtml#ch10fig18) through [10-25](ch10.xhtml#ch10fig25) show how to
    encode various forms of the `add` instruction using different addressing modes.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你弄清楚如何使用这个复杂的方案来编码指令，我们来看一个使用各种寻址模式的 80x86 `add` 指令示例。`add` 操作码根据其方向和大小位可以是
    `$00`、`$01`、`$02` 或 `$03`（见 [图 10-15](ch10.xhtml#ch10fig15)）。[图 10-18](ch10.xhtml#ch10fig18)
    到 [10-25](ch10.xhtml#ch10fig25) 展示了如何使用不同的寻址模式编码 `add` 指令的各种形式。
- en: '![image](../images/10fig18.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig18.jpg)'
- en: '*Figure 10-18: Encoding the `add(al,` `cl);` instruction*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-18：编码 `add(al,` `cl);` 指令*'
- en: 'There is an interesting side effect of the `mod-reg-r/m` organization and direction
    bit: some instructions have two different legal opcodes. For example, we could
    also encode the `add(al,` `cl);` instruction shown in [Figure 10-18](ch10.xhtml#ch10fig18)
    as `$02,` `$c8` by reversing the positions of the AL and CL registers in the `reg`
    and `r/m` fields and then setting the `d` bit (bit 1) in the opcode to `1`. This
    applies to all instructions with two register operands and a direction bit, such
    as the `add(eax,` `ecx);` instruction in [Figure 10-19](ch10.xhtml#ch10fig19),
    which can also be encoded as `$03,` `$c8`.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod-reg-r/m` 组织和方向位有一个有趣的副作用：一些指令有两种合法的操作码。例如，我们也可以通过反转 `reg` 和 `r/m` 字段中
    AL 和 CL 寄存器的位置，并将操作码中的 `d` 位（第 1 位）设置为 `1`，将 `add(al,` `cl);` 指令（如 [图 10-18](ch10.xhtml#ch10fig18)
    所示）编码为 `$02,` `$c8`。这适用于所有具有两个寄存器操作数和方向位的指令，例如 [图 10-19](ch10.xhtml#ch10fig19)
    中的 `add(eax,` `ecx);` 指令，它也可以编码为 `$03,` `$c8`。'
- en: '![image](../images/10fig19.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig19.jpg)'
- en: '*Figure 10-19: Encoding the `add(eax,` `ecx);` instruction*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-19：编码 `add(eax,` `ecx);` 指令*'
- en: '![image](../images/10fig20.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig20.jpg)'
- en: '*Figure 10-20: Encoding the `add(disp,` `edx);` instruction*'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-20：编码 `add(disp,` `edx);` 指令*'
- en: '![image](../images/10fig21.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig21.jpg)'
- en: '*Figure 10-21: Encoding the `add([ebx],` `edi);` instruction*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-21：编码 `add([ebx],` `edi);` 指令*'
- en: '![image](../images/10fig22.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig22.jpg)'
- en: '*Figure 10-22: Encoding the `add([esi+disp``[8]``],` `eax);` instruction*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-22：编码 `add([esi+disp``[8]``],` `eax);` 指令*'
- en: '![image](../images/10fig23.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig23.jpg)'
- en: '*Figure 10-23: Encoding the `add([ebp+disp``[32]``],` `ebx);` instruction*'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-23：编码 `add([ebp+disp``[32]``],` `ebx);` 指令*'
- en: '![image](../images/10fig24.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig24.jpg)'
- en: '*Figure 10-24: Encoding the `add([disp``[32]``+eax*1],` `ebp);` instruction*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-24：编码 `add([disp``[32]``+eax*1],` `ebp);` 指令*'
- en: '![image](../images/10fig25.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig25.jpg)'
- en: '*Figure 10-25: Encoding the `add([ebx+edi*4],` `ecx);` instruction*'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-25：编码 `add([ebx+edi*4],` `ecx);` 指令*'
- en: '***10.4.3 Encoding Immediate (Constant) Operands on the x86***'
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.4.3 在 x86 上编码立即数（常量）操作数***'
- en: You may have noticed that the `mod-reg-r/m` and `sib` bytes don’t contain any
    bit combinations you can use to specify that an instruction contains an immediate
    operand. The 80x86 uses a completely different opcode to specify an immediate
    operand. [Figure 10-26](ch10.xhtml#ch10fig26) shows the basic encoding for an
    `add` immediate instruction.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`mod-reg-r/m` 和 `sib` 字节不包含任何可以用来指定指令包含立即操作数的位组合。80x86 使用完全不同的操作码来指定立即操作数。[图
    10-26](ch10.xhtml#ch10fig26) 显示了 `add` 立即数指令的基本编码。
- en: '![image](../images/10fig26.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/10fig26.jpg)'
- en: '*Figure 10-26: Encoding an `add` immediate instruction*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-26：编码 `add` 立即数指令*'
- en: There are three major differences between the encoding of the `add` immediate
    instruction and the standard `add` instruction. First, and most important, the
    opcode has a `1` in the HO bit position. This tells the CPU that the instruction
    has an immediate constant. This change alone, however, does not tell the CPU that
    it must execute an `add` instruction, as you’ll see shortly.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 立即数指令和标准 `add` 指令的编码有三个主要区别。首先，也是最重要的，操作码在 HO 位上有一个 `1`。这告诉 CPU 指令包含一个立即常数。然而，仅凭这一变化，并不能告诉
    CPU 必须执行 `add` 指令，正如你稍后将看到的那样。'
- en: The second difference is that there’s no direction bit in the opcode. This makes
    sense because you cannot specify a constant as a destination operand. Therefore,
    the destination operand is always the location specified by the `mod` and `r/m`
    bits in the `mod-reg-r/m` field.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是操作码中没有方向位。这是有道理的，因为你不能将常量指定为目标操作数。因此，目标操作数总是由 `mod-reg-r/m` 字段中的 `mod`
    和 `r/m` 位指定的位置。
- en: In place of the direction bit, the opcode has a sign-extension (`x`) bit. For
    8-bit operands, the CPU ignores the sign-extension bit. For 16-bit and 32-bit
    operands, the sign-extension bit specifies the size of the constant following
    the `add` instruction. If the sign-extension bit contains `0`, the constant is
    already the same size as the operand (either 16 or 32 bits). If the sign-extension
    bit contains `1`, the constant is a signed 8-bit value, and the CPU sign-extends
    this value to the appropriate size before adding it to the operand. This little
    trick often makes programs much shorter, because you commonly add small constants
    to 16- or 32-bit destination operands.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在方向位的位置，操作码有一个符号扩展（`x`）位。对于 8 位操作数，CPU 忽略符号扩展位。对于 16 位和 32 位操作数，符号扩展位指定了 `add`
    指令后常数的大小。如果符号扩展位为 `0`，则常数已经与操作数的大小相同（16 或 32 位）。如果符号扩展位为 `1`，则常数为带符号 8 位值，CPU
    会在将其加到操作数之前对该值进行符号扩展，扩展到适当的大小。这个小技巧通常会让程序变得更短，因为你常常会将小常数加到 16 位或 32 位的目标操作数中。
- en: The third difference between the `add` immediate and the standard `add` instruction
    is the meaning of the `reg` field in the `mod-reg-r/m` byte. Because the instruction
    implies that the source operand is a constant, and the `mod-r/m` fields specify
    the destination operand, the instruction does not need to use the `reg` field
    to specify an operand. Instead, the 80x86 CPU uses these 3 bits as an opcode extension.
    For the `add` immediate instruction, these 3 bits must contain `0`, and another
    bit pattern would correspond to a different instruction.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 立即数指令和标准 `add` 指令的第三个区别是 `mod-reg-r/m` 字节中 `reg` 字段的含义。由于该指令意味着源操作数是常数，而
    `mod-r/m` 字段指定了目标操作数，因此指令无需使用 `reg` 字段来指定操作数。相反，80x86 CPU 使用这 3 位作为操作码扩展。对于 `add`
    立即数指令，这 3 位必须为 `0`，而其他位模式则对应于不同的指令。'
- en: When a constant is added to a memory location, any displacement associated with
    that memory location immediately precedes the constant data in the instruction
    sequence.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当常数被加到内存位置时，任何与该内存位置相关的位移值会立即出现在常数数据之前。
- en: '***10.4.4 Encoding 8-, 16-, and 32-Bit Operands***'
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.4.4 编码 8 位、16 位和 32 位操作数***'
- en: 'When designing the 8086, Intel used one opcode bit (`s`) to specify whether
    the operand sizes were 8 or 16 bits. Later, when it extended the 80x86 architecture
    to 32 bits with the introduction of the 80386, Intel had a problem: with this
    single operand size bit, it could encode only two sizes, but it needed to encode
    three (8, 16, and 32 bits). To solve this problem, Intel used an *operand-size
    prefix byte*.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计 8086 时，英特尔使用了一个操作码位（`s`）来指定操作数大小是 8 位还是 16 位。后来，当英特尔通过引入 80386 将 80x86 架构扩展到
    32 位时，英特尔遇到了一个问题：使用这个单一的操作数大小位，它只能编码两种大小，但需要编码三种（8 位、16 位和 32 位）。为了解决这个问题，英特尔使用了一个
    *操作数大小前缀字节*。
- en: Intel studied its instruction set and concluded that in a 32-bit environment,
    programs were likely to use 8-bit and 32-bit operands far more often than 16-bit
    operands. Therefore, it decided to let the size bit (`s`) in the opcode select
    between 8- and 32-bit operands, as described in the previous sections. Although
    modern 32-bit programs don’t use 16-bit operands very often, they do need them
    now and then. So, Intel lets you prefix a 32-bit instruction with the operand-size
    prefix byte, whose value is `$66`, and this prefix byte tells the CPU that the
    operands contain 16-bit data rather than 32-bit data.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔研究了其指令集，得出结论：在 32 位环境中，程序更可能使用 8 位和 32 位操作数，而不是 16 位操作数。因此，它决定让操作码中的大小位（`s`）在
    8 位和 32 位操作数之间进行选择，正如前面章节所描述的那样。尽管现代 32 位程序不常使用 16 位操作数，但有时仍然需要使用它们。因此，英特尔允许你在
    32 位指令前加上操作数大小前缀字节，其值为 `$66`，该前缀字节告诉 CPU 操作数包含的是 16 位数据，而不是 32 位数据。
- en: You do not have to explicitly add an operand-size prefix byte to your 16-bit
    instructions; the assembler or compiler takes care of this automatically for you.
    However, do keep in mind that whenever you use a 16-bit object in a 32-bit program,
    the instruction is 1 byte longer because of the prefix value. Therefore, you should
    be careful about using 16-bit instructions if size and, to a lesser extent, speed
    are important.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 16 位指令，你不必显式添加操作数大小前缀字节；汇编器或编译器会自动处理这个问题。然而，请记住，当你在 32 位程序中使用 16 位对象时，由于前缀值的原因，指令会多出
    1 个字节。因此，如果大小和（在较小程度上）速度很重要，你应该小心使用 16 位指令。
- en: '***10.4.5 Encoding 64-Bit Operands***'
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.4.5 编码 64 位操作数***'
- en: When running in 64-bit mode, Intel and AMD x84-64 processors use special opcode
    prefix bytes to specify 64-bit registers. There are 16 REX opcode bytes that handle
    64-bit operands and addressing modes. Because there weren’t 16 single-byte opcodes
    available, AMD (who designed the instruction set) chose to repurpose 16 existing
    opcodes (the 1-byte opcode variants for the `inc(`reg`)` and `dec(`reg`)` instructions).
    There are still 2-byte variants of these instructions, so rather than eliminating
    the instructions altogether, AMD just removed the 1-byte versions. However, standard
    32-bit code (a lot of which certainly uses those 1-byte increment and decrement
    instructions) can no longer run on the 64-bit model. That’s why AMD and Intel
    introduced new 32-bit and 64-bit operation modes—so the CPUs could run both older
    32-bit code and newer 64-bit code on the same piece of silicon.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在 64 位模式下运行时，英特尔和 AMD 的 x84-64 处理器使用特殊的操作码前缀字节来指定 64 位寄存器。有 16 个 REX 操作码字节用于处理
    64 位操作数和寻址模式。由于没有 16 个可用的单字节操作码，AMD（该指令集的设计者）选择重新利用 16 个现有的操作码（`inc(`reg`)` 和
    `dec(`reg`)` 指令的 1 字节操作码变体）。这些指令仍然有 2 字节变体，因此 AMD 并没有完全删除这些指令，而是仅移除了 1 字节版本。然而，标准的
    32 位代码（其中很多确实使用这些 1 字节的增量和递减指令）不能再在 64 位模型上运行。这就是为什么 AMD 和英特尔引入了新的 32 位和 64 位操作模式——使得
    CPU 可以在同一块硅片上运行旧的 32 位代码和新的 64 位代码。
- en: '***10.4.6 Alternate Encodings for Instructions***'
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***10.4.6 指令的替代编码***'
- en: As noted earlier in this chapter, one of Intel’s primary design goals for the
    80x86 was to create an instruction set that allowed programmers to write very
    short programs in order to save memory, which was precious at the time. One way
    Intel did this was to create alternative encodings of some very commonly used
    instructions. These alternative instructions were shorter than their standard
    counterparts, and Intel hoped that programmers would make extensive use of the
    shorter versions, thereby creating shorter programs.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，英特尔为 80x86 设计的主要目标之一是创建一个指令集，使程序员能够编写非常短的程序，以节省当时非常宝贵的内存。英特尔实现这一目标的一种方法是为一些常用指令创建替代编码。这些替代指令比其标准对应指令更短，英特尔希望程序员能广泛使用这些较短版本，从而编写出更短的程序。
- en: A good example of these alternative instructions are the `add(`constant`,` accumulator`);`
    instructions, where the accumulator is `al`, `ax`, or `eax`. The 80x86 provides
    1-byte opcodes for `add(`constant`, al);` and `add(`constant`, eax);`, which are
    `$04` and `$05`, respectively. With a 1-byte opcode and no `mod-reg-r/m` byte,
    these instructions are 1 byte shorter than their standard `add` immediate counterparts.
    The `add(`constant`,` `ax);` instruction requires an operand-size prefix, so its
    opcode is effectively 2 bytes. However, this is still 1 byte shorter than the
    corresponding standard `add` immediate.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这些替代指令的一个好例子是 `add(`constant`,` accumulator`);` 指令，其中累加器为 `al`、`ax` 或 `eax`。80x86
    为 `add(`constant`, al);` 和 `add(`constant`, eax);` 提供了 1 字节的操作码，分别为 `$04` 和 `$05`。由于是
    1 字节的操作码且没有 `mod-reg-r/m` 字节，这些指令比其标准的 `add` 立即数指令短 1 字节。`add(`constant`, `ax);`
    指令需要一个操作数大小前缀，因此其操作码实际上是 2 字节的。然而，这仍然比对应的标准 `add` 立即数指令少 1 字节。
- en: You don’t have to specify anything special to use these instructions. Any decent
    assembler or compiler will automatically choose the shortest possible instruction
    it can use when translating your source code into machine code. However, you should
    note that Intel provides alternative encodings only for the accumulator registers.
    Therefore, if you have a choice of several instructions to use and the accumulator
    registers are among these choices, the AL, AX, and EAX registers are often your
    best bet. However, this option is usually available only to assembly language
    programmers.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些指令不需要指定任何特殊内容。任何合适的汇编器或编译器在将源代码转换为机器代码时，都会自动选择它可以使用的最短指令。然而，您应该注意，英特尔只为累加器寄存器提供了替代编码。因此，如果您有多个指令可供选择，并且这些选择中包含累加器寄存器，通常来说，AL、AX
    和 EAX 寄存器是最佳选择。然而，这个选项通常只对汇编语言程序员可用。
- en: '**10.5 Implications of Instruction Set Design to the Programmer**'
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.5 指令集设计对程序员的影响**'
- en: 'Only by knowing the computer’s architecture and, in particular, how the CPU
    encodes machine instructions, can you make the most efficient use of the machine’s
    instructions. By studying instruction set design, you can gain a clear understanding
    of the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 只有通过了解计算机架构，特别是 CPU 如何编码机器指令，您才能最有效地使用计算机的指令。通过研究指令集设计，您可以清楚地了解以下内容：
- en: Why some instructions are shorter than others
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么有些指令比其他指令短
- en: Why some instructions are faster than others
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么有些指令比其他指令执行得更快
- en: Which constant values the CPU can handle efficiently
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 能高效处理哪些常量值
- en: Whether constants are more efficient than memory locations
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量是否比内存位置更高效
- en: Why certain arithmetic and logical operations are more efficient than others
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么某些算术和逻辑操作比其他操作更高效
- en: Which types of arithmetic expressions are more easily translated into machine
    code than other types
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些类型的算术表达式比其他类型更容易被翻译成机器代码
- en: Why code is less efficient if it transfers control over a large distance in
    the object code
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么如果代码在目标代码中控制流跨越较大的距离，会导致效率降低
- en: . . . and so on.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ……等等。
- en: By studying instruction set design, you become more aware of the implications
    of the code you write (even in an HLL) in terms of efficient operation on the
    CPU. Armed with this knowledge, you’ll be better equipped to write great code.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通过研究指令集设计，你将更加意识到你所编写代码的影响（即使是在高级语言中），这些影响在 CPU 上的高效运行方面尤为重要。掌握了这些知识后，你将能够编写出更优秀的代码。
- en: '**10.6 For More Information**'
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.6 更多信息**'
- en: 'Hennessy, John L., and David A. Patterson. *Computer Architecture: A Quantitative
    Approach*. 5th ed. Waltham, MA: Elsevier, 2012.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 'Hennessy, John L., 和 David A. Patterson. *计算机架构：量化方法*. 第5版. Waltham, MA: Elsevier,
    2012年。'
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Hyde, Randall. *汇编语言艺术*. 第2版. 旧金山：No Starch Press, 2010年。
- en: Intel. “Intel® 64 and IA-32 Architectures Software Developer Manuals.” Last
    updated November 11, 2019\. *[https://software.intel.com/en-us/articles/intel-sdm/](https://software.intel.com/en-us/articles/intel-sdm/).**
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Intel. “Intel® 64 和 IA-32 架构软件开发者手册。”最后更新于2019年11月11日。 *[https://software.intel.com/en-us/articles/intel-sdm/](https://software.intel.com/en-us/articles/intel-sdm/).*
