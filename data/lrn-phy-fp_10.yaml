- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: TUPLES AND TYPE CONSTRUCTORS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与类型构造器
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: A tuple is an ordered collection of values. There are tuples for ordered pairs,
    ordered triples, ordered quadruples, and so on. The types of the values in a tuple
    are generally different, but they could be the same.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是有序值的集合。对于有序对、有序三元组、有序四元组等，均有对应的元组类型。元组中值的类型通常是不同的，但也可以相同。
- en: 'In this chapter, we’ll discuss tuples and their generalization: the type constructor.
    Function types, list types, and tuple types are all examples of type constructors.
    We’ll present a unified way to think about these type constructors, which on the
    surface appear different, but all share essential features. Finally, we’ll revisit
    numerical integration to show how tuples, in conjunction with iteration, give
    a way to perform numerical integration that we will later generalize to solve
    differential equations.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将讨论元组及其推广：类型构造器。函数类型、列表类型和元组类型都是类型构造器的例子。我们将介绍一种统一的方式来思考这些类型构造器，表面上看它们似乎不同，但它们都有共同的特征。最后，我们将重新审视数值积分，展示如何结合元组和迭代，给出一种执行数值积分的方法，稍后我们将推广这一方法来求解微分方程。
- en: Pairs
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对
- en: 'The simplest tuple is the pair. A pair type is specified by giving an ordered
    pair `(a,b)` of types `a` and `b`, separated by a comma and enclosed in parentheses.
    If `x :: a` and `y :: b`, then `(x,y) :: (a,b)`. The value `(x,y)` has the type
    `(a,b)`. The comma and parentheses have two uses: they form the type `(a,b)` and
    they form the value `(x,y)` of that type.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '最简单的元组是对。一个对类型通过给出一个有序对`(a,b)`来指定，其中`a`和`b`是两种类型，并用逗号分隔并用括号括起来。如果`x :: a`且`y
    :: b`，那么`(x,y) :: (a,b)`。值`(x,y)`的类型是`(a,b)`。逗号和括号有两个作用：它们构成了类型`(a,b)`，也构成了该类型的值`(x,y)`。'
- en: 'For example, here is a pair composed of a `String` describing a person’s name
    and an `Int` representing the person’s score on an exam:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个元组，由描述一个人姓名的`String`和表示该人考试成绩的`Int`组成：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the pair type is `(String,Int)` and the pair value is `("Albert`
    `Einstein", 79)`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，元组类型是`(String,Int)`，元组值是`("Albert" ` `Einstein", 79)`。
- en: 'To get some experience with tuples, let’s write a function `pythag` that computes
    the hypotenuse of a right triangle from the lengths of its two sides. We’ll pass
    the two side lengths to the function using a pair. Here is one way to write this
    function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解元组，让我们编写一个函数`pythag`，计算直角三角形的斜边长，已知它的两个直角边的长度。我们将通过一个元组将这两个边长传递给函数。以下是编写这个函数的一种方式：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This type signature shows us that `pythag` expects a pair of two `R`s as input
    and produces an `R` as output. The fact that in the second line we call the input
    `(x,y)` (rather than a simple variable like `p`) means that this definition uses
    pattern matching on the input. This is similar to the pattern matching we saw
    earlier for `Bool` and for lists. Pattern matching for pairs is simple because
    there is only one pattern: every pair has the form `(x,y)`. Recall that `Bool`
    has two patterns (`True` and `False`) and that lists have two patterns (the empty
    list `[]` and the cons of an element and a list `x:xs`).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类型签名表明，`pythag`期望一个由两个`R`类型组成的对作为输入，并产生一个`R`类型作为输出。第二行中我们将输入称为`(x,y)`（而不是像`p`这样的简单变量），意味着这个定义在输入上使用了模式匹配。这类似于我们之前看到的`Bool`和列表的模式匹配。对于对的模式匹配很简单，因为只有一个模式：每个对都有形式`(x,y)`。回想一下，`Bool`有两个模式（`True`和`False`），列表有两个模式（空列表`[]`和包含一个元素及列表的`x:xs`）。
- en: 'A couple of Prelude functions deal with pairs. The `fst` function takes a pair
    as input and returns the first component of the pair as output. The `snd` function
    takes a pair as input and returns the second component of the pair as output.
    We can test this behavior in GHCi:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个Prelude函数用于处理对。`fst`函数接受一个对作为输入，返回对的第一个元素作为输出。`snd`函数接受一个对作为输入，返回对的第二个元素作为输出。我们可以在GHCi中测试这个行为：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The types of functions `fst` and `snd` are given entirely in terms of type variables,
    indicating that these functions care nothing for the type of the payload.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`fst`和`snd`这两个函数的类型完全由类型变量给出，表明这些函数与载荷的类型无关。'
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In general, there are two ways to get data out of a type like a pair that contains
    multiple pieces of data. One way is pattern matching, and the other is using functions
    like `fst` and `snd`, generally called *eliminators*. While it is theoretically
    possible to write code that uses only pattern matching and never uses eliminators,
    eliminators are sometimes simpler, so it is nice to have access to both. The eliminators
    `fst` and `snd` are particularly useful if you process some data that results
    in a pair and you just want one part of it. An example is the function `integral'`
    in the last section of this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，有两种方式可以从像包含多个数据项的对这样的类型中获取数据。一种方式是模式匹配，另一种是使用像`fst`和`snd`这样的函数，通常被称为*消解器*。虽然理论上可以写出只使用模式匹配而不使用消解器的代码，但有时消解器更简单，所以能够同时使用两者是很方便的。如果你处理的数据结果是一个对，并且你只需要其中的一部分，那么消解器`fst`和`snd`就特别有用。一个例子是本章最后一节中的`integral'`函数。
- en: Currying a Function of Two Variables
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对二元函数进行柯里化
- en: 'In [Chapter 6](ch06.xhtml), we talked about currying as a way to think of a
    function as accepting more than one argument. Using a higher-order function, we
    can write our hypotenuse function as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.xhtml)中，我们讨论了柯里化，作为一种将函数视为接受多个参数的方式。通过使用高阶函数，我们可以将斜边函数写成如下形式：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Tuples offer an alternative way to write a function of two variables. Although
    `pythag` and `pythagCurried` are different Haskell functions with different types,
    they’re doing the same thing mathematically: they are both expressing the mathematical
    function that finds the hypotenuse. Let’s call `pythag` the *tuple form* of the
    hypotenuse function and `pythagCurried` the *curried form* of the hypotenuse function.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 元组提供了另一种写二元函数的方式。虽然`pythag`和`pythagCurried`是不同的Haskell函数，具有不同的类型，但它们在数学上做的是同样的事情：它们都表示寻找斜边的数学函数。我们将`pythag`称为斜边函数的*元组形式*，将`pythagCurried`称为斜边函数的*柯里化形式*。
- en: These two ways of encoding a function of two variables are mutually exclusive.
    You need to pick one or the other for a particular function; you can’t use both.
    Notice that the tuple form `pythag` requires the use of parentheses and a comma
    around the two arguments. That’s because you need to have a tuple as input! Notice
    that the curried form `pythagCurried` has no parentheses and no comma. It’s not
    that the comma is optional; no comma can be present.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种编码二元函数的方式是互斥的。你必须为一个特定的函数选择其中一种方式；不能同时使用这两者。请注意，元组形式的`pythag`需要使用括号和逗号来包围两个参数。这是因为你需要一个元组作为输入！请注意，柯里化形式的`pythagCurried`没有括号也没有逗号。并不是逗号是可选的，而是逗号不能出现。
- en: Sometimes you might use one form but realize later on that you wish you had
    used the other. Haskell provides two functions to let you convert between forms.
    To convert from tuple form to curried form, Haskell provides the function `curry`.
    The function `curry pythag` is exactly the same function as `pythagCurried` we
    defined earlier. The function `uncurry pythagCurried` is the same as the function
    `pythag`. However, it does not make sense to write `curry pythagCurried` or `uncurry
    pythag`; these constructions will produce type errors when the compiler tries
    to read them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能会使用一种形式，但后来意识到你希望使用另一种形式。Haskell提供了两个函数让你在这两种形式之间转换。为了从元组形式转换为柯里化形式，Haskell提供了函数`curry`。函数`curry
    pythag`与我们之前定义的`pythagCurried`完全相同。函数`uncurry pythagCurried`与函数`pythag`相同。然而，写`curry
    pythagCurried`或`uncurry pythag`是没有意义的；当编译器尝试读取它们时，这些构造会产生类型错误。
- en: If we load these functions into GHCi (code files are available at [*https://lpfp.io*](https://lpfp.io)),
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些函数加载到GHCi中（代码文件可以在[*https://lpfp.io*](https://lpfp.io)找到），
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'we can see that the types of `pythagCurried` and `curry pythag` are the same:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`pythagCurried`和`curry pythag`的类型是相同的：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also see that the types of `pythag` and `uncurry pythagCurried` are
    the same:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到，`pythag`和`uncurry pythagCurried`的类型是相同的：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Take a look at the types for `curry` and `uncurry`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`curry`和`uncurry`的类型：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Figure 9-1](ch09.xhtml#ch9fig1) attempts to explain these complex types. The
    two types shown in the figure are alternative ways to encode a function of two
    variables. The higher-order functions `curry` and `uncurry` transform one two-variable
    function type into the other.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-1](ch09.xhtml#ch9fig1)试图解释这些复杂的类型。图中显示的两种类型是编码一个二元函数的不同方式。高阶函数`curry`和`uncurry`将一种二元函数类型转换成另一种。'
- en: '![Image](Images/116fig01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/116fig01.jpg)'
- en: '*Figure 9-1: Two types for a function of two variables. The higher-order functions
    curry and uncurry transform a two-variable function of one type into the other
    type.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：两变量函数的两种类型。高阶函数 `curry` 和 `uncurry` 将一种类型的两变量函数转换为另一种类型的函数。*'
- en: Triples
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三元组
- en: 'In addition to pairs, you can make triples, or tuples with even more components.
    However, the functions `fst` and `snd` work only with pairs. To access elements
    of triples and larger tuples, the standard method is to use pattern matching.
    For example, functions that pick out the components of triples can be defined
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配对之外，你还可以创建三元组，或者具有更多组成部分的元组。然而，`fst` 和 `snd` 函数仅适用于配对。要访问三元组和更大元组的元素，标准方法是使用模式匹配。例如，可以按如下方式定义提取三元组组件的函数：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The definitions of `fst3`, `snd3`, and `thd3` use pattern matching to assign
    names to the items in the triple. These names can then be used on the right-hand
    side of the definition to indicate the value we want the function to return. In
    the function `fst3`, the values `y` and `z` are not used. Because they are not
    used, it is in some sense superfluous to give them names. In the definition of
    `snd3`, the `_` (underscore) character is used as a placeholder to represent a
    quantity that doesn’t get used in the expression that follows. In the definition
    of `snd3`, we use underscores in the first and third slots of the triple. This
    signals that it is superfluous to give these items names since the names are not
    used in the definition. In the definition of `thd3`, we show an alternate use
    of underscores. Here we start the variable name with an underscore, indicating
    it won’t be used, but we give it a name for our own use, perhaps to remind us
    of the purpose of that variable. Using underscores for quantities that aren’t
    used is a best practice, because the compiler will generate warnings about unused
    variables, which are often errors. To distinguish these genuine errors (frequently
    misspellings) from items you don’t want to use, employ the underscore.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`fst3`、`snd3` 和 `thd3` 的定义使用模式匹配为三元组中的元素分配名称。这些名称随后可以在定义的右侧用于表示我们希望函数返回的值。在
    `fst3` 函数中，`y` 和 `z` 的值没有被使用。因为它们没有被使用，从某种意义上说，给它们命名是多余的。在 `snd3` 的定义中，`_`（下划线）字符被用作占位符，表示在后续表达式中不使用该量。在
    `snd3` 的定义中，我们在三元组的第一和第三个位置使用下划线。这表明给这些元素命名是多余的，因为在定义中没有使用这些名称。在 `thd3` 的定义中，我们展示了下划线的另一种用法。这里我们以一个下划线开始变量名称，表明它不会被使用，但我们仍然为自己命名，可能是为了提醒我们该变量的用途。对于那些不被使用的量，使用下划线是最佳实践，因为编译器会生成关于未使用变量的警告，这通常是错误。为了将这些真正的错误（通常是拼写错误）与那些你不想使用的项区分开来，可以使用下划线。'
- en: Comparing Lists and Tuples
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较列表和元组
- en: A tuple is different from a list in that every element of a list must have the
    same type. On the other hand, unlike a list, the type of a tuple says exactly
    how many elements the tuple has. If an expression has type `[Int]`, for example,
    it can be a list of zero, one, two, or more `Int`s. However, if an expression
    has type `(String,Int)`, it is a pair consisting of exactly one `String` and exactly
    one `Int`. If you want to combine exactly two things or exactly three things,
    a tuple is what you want. Beyond three items, tuples rapidly become unwieldy.
    Lists, on the other hand, are often very long. A list can happily contain thousands
    of elements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与列表不同，列表中的每个元素必须具有相同的类型。另一方面，与列表不同，元组的类型明确表示元组包含多少个元素。例如，如果一个表达式的类型是 `[Int]`，它可以是一个包含零个、一个、两个或更多
    `Int` 的列表。然而，如果一个表达式的类型是 `(String, Int)`，它就是一个包含一个 `String` 和一个 `Int` 的配对。如果你想要组合正好两个或正好三个元素，元组就是你需要的。超过三个元素后，元组会迅速变得难以操作。另一方面，列表通常很长。一个列表可以包含成千上万个元素。
- en: Before we discuss lists of pairs, we’ll take a short detour to look at a class
    of types that will be helpful for that discussion.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论配对列表之前，我们将绕开一点，简要介绍一种对于该讨论有帮助的类型类别。
- en: Maybe Types
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可能的类型
- en: We saw in [Chapter 5](ch05.xhtml) that for any type `a` there is another type
    `[a]` consisting of lists of elements that each have type `a`. Such a list may
    have zero, one, two, or more elements of type `a`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 5 章](ch05.xhtml)中看到，对于任何类型 `a`，都有另一种类型 `[a]`，它由每个元素类型为 `a` 的列表组成。这样的列表可以包含零个、一个、两个或更多类型为
    `a` 的元素。
- en: 'Similarly, for any type `a` there is another type `Maybe a` consisting of zero
    or one element of type `a`. To motivate this new data type, imagine that we are
    writing a function `findFirst` that will search through a list for the first element
    that meets some criterion. We might want such a function to have the following
    type:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于任何类型`a`，都有一个新的类型`Maybe a`，它由零个或一个类型为`a`的元素组成。为了说明这个新数据类型的动机，假设我们正在编写一个函数`findFirst`，它将在列表中查找第一个符合某些条件的元素。我们可能希望这个函数具有如下类型：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The type indicates our intent to have the function `findFirst` accept a predicate
    and a list of elements of type `b` as input and provide a single element of type
    `b` as output. But what if the list contains no element that meets our criterion?
    In that case, there is a problem because the function `findFirst` has no way to
    come up with an element of type `b`, but the type *demands* that the function
    return an element of type `b`. One possibility is for `findFirst` to use the `error`
    function if no suitable element is found, but this is an extreme measure and will
    halt the program so that no later recovery is possible.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该类型表示我们希望函数`findFirst`接受一个谓词和一个类型为`b`的元素列表作为输入，并返回一个类型为`b`的单个元素作为输出。但如果列表中没有符合我们条件的元素怎么办？在这种情况下，问题就来了，因为函数`findFirst`无法提供一个类型为`b`的元素，而该类型却*要求*函数返回一个类型为`b`的元素。一个可能的做法是，如果没有找到合适的元素，`findFirst`可以使用`error`函数，但这是一个极端的做法，会终止程序，使得后续无法恢复。
- en: 'A better solution is to use a different type signature, like so:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是使用不同的类型签名，像这样：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If `findFirstMaybe` finds an element `x :: b` that meets the criterion, it
    will return `Just x`. If it finds no element of type `b` that meets the criterion,
    `find` `FirstMaybe` will return `Nothing`. Let’s see what the function definition
    looks like:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '如果`findFirstMaybe`找到一个符合条件的元素`x :: b`，它将返回`Just x`。如果没有找到符合条件的`b`类型元素，`findFirstMaybe`将返回`Nothing`。我们来看一下函数定义是怎样的：'
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The expression `dropWhile (not . p) xs` is what remains of the list `xs` after
    the longest possible sequence of elements that do *not* satisfy the predicate
    are removed from the front of the list. The `case` construction allows us to do
    pattern matching on the expression `dropWhile (not . p) xs`, asking which of the
    two list patterns the expression matches and returning an appropriate result in
    each case.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`dropWhile (not . p) xs`是对列表`xs`进行处理后，移除掉前面最长的一段不满足谓词`p`的元素后剩下的部分。`case`结构允许我们对表达式`dropWhile
    (not . p) xs`进行模式匹配，检查该表达式匹配的是哪种列表模式，并在每种情况下返回适当的结果。
- en: 'The type `Maybe a` has two patterns. (Recall that `Bool` has two patterns,
    lists have two patterns, and tuples have one pattern.) A value of `Maybe a` is
    either `Nothing` or `Just x` for some `x :: a`. The value `Nothing` is the way
    of specifying zero elements of type `a`, and the value `Just x` is the way of
    specifying one element of type `a` (namely `x`). [Table 9-1](ch09.xhtml#ch9tab1)
    shows some expressions involving `Maybe` and their types.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '类型`Maybe a`有两个模式。（回忆一下，`Bool`有两个模式，列表有两个模式，元组有一个模式。）`Maybe a`的值要么是`Nothing`，要么是`Just
    x`，其中`x :: a`。`Nothing`表示没有类型为`a`的元素，而`Just x`表示一个类型为`a`的元素（即`x`）。[表9-1](ch09.xhtml#ch9tab1)展示了涉及`Maybe`的一些表达式及其类型。'
- en: '**Table 9-1:** Expressions Involving Maybe and Their Types'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-1：** 涉及Maybe的表达式及其类型'
- en: '| **Expression** |  | **Type** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **类型** |'
- en: '| --- | --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Nothing` | `::` | `Maybe a` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `Nothing` | `::` | `Maybe a` |'
- en: '| `Just "me"` | `::` | `Maybe [Char]` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `Just "我"` | `::` | `Maybe [Char]` |'
- en: '| `Just ''X''` | `::` | `Maybe Char` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `Just ''X''` | `::` | `Maybe Char` |'
- en: '| `Just False` | `::` | `Maybe Bool` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `Just False` | `::` | `Maybe Bool` |'
- en: '| `Just 4` | `::` | `Num a => Maybe a` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `Just 4` | `::` | `Num a => Maybe a` |'
- en: '[Table 9-2](ch09.xhtml#ch9tab2) shows a comparison of expressions having `Maybe`
    types with expressions having the underlying type.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[表9-2](ch09.xhtml#ch9tab2)展示了`Maybe`类型表达式与基础类型表达式的比较。'
- en: '**Table 9-2:** Comparison of Maybe Type and Underlying Type Expressions'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-2：** Maybe类型与基础类型表达式的比较'
- en: '| **Type** | **Expressions with this type** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **具有此类型的表达式** |'
- en: '| --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Bool` | `False`, `True` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `Bool` | `False`, `True` |'
- en: '| `Maybe Bool` | `Just False`, `Just True`, `Nothing` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `Maybe Bool` | `Just False`, `Just True`, `Nothing` |'
- en: '| `Char` | `''h''`, `''7''` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `Char` | `''h''`, `''7''` |'
- en: '| `Maybe Char` | `Just ''h''`, `Just ''7''`, `Nothing` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `Maybe Char` | `Just ''h''`, `Just ''7''`, `Nothing` |'
- en: '| `String` | `"Monday"`, `"Tuesday"` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `String` | `"星期一"`, `"星期二"` |'
- en: '| `Maybe String` | `Just "Monday"`, `Just "Tuesday"`, `Nothing` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `Maybe String` | `Just "星期一"`, `Just "星期二"`, `Nothing` |'
- en: '| `Int` | `3`, `7`, `-13` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `Int` | `3`, `7`, `-13` |'
- en: '| `Maybe Int` | `Just 3`, `Just 7`, `Just (-13)`, `Nothing` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `Maybe Int` | `Just 3`，`Just 7`，`Just (-13)`，`Nothing` |'
- en: '[Table 9-2](ch09.xhtml#ch9tab2) shows four things: for each type `a` there
    is a type `Maybe a`; an expression of type `Maybe String`, unless it is `Nothing`,
    holds a value of type `String`; an expression of type `String` can be made into
    an expression of type `Maybe String` by prefixing the expression with the constructor
    `Just`; and these observations about the `String` type are also valid for `Bool`,
    `Char`, or any other type.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-2](ch09.xhtml#ch9tab2)展示了四个内容：对于每种类型 `a`，都有一个类型 `Maybe a`；一个类型为 `Maybe
    String` 的表达式，除非它是 `Nothing`，否则持有一个类型为 `String` 的值；一个类型为 `String` 的表达式可以通过前缀构造函数
    `Just` 转换成类型为 `Maybe String` 的表达式；这些关于 `String` 类型的观察对于 `Bool`、`Char` 或任何其他类型也适用。'
- en: Now that we have the `Maybe` type under our belt, let’s take a look at lists
    of pairs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了 `Maybe` 类型，让我们来看一下配对列表。
- en: Lists of Pairs
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配对列表
- en: Just as we can form lists of lists, we can make pairs of pairs, lists of pairs,
    pairs of lists, and more complicated things. The list of pairs is probably the
    most useful of these (although lists of lists are very useful), for reasons we
    will see next.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以形成列表的列表一样，我们也可以生成成对的对、配对的列表、列表的对以及更复杂的结构。配对列表可能是这些结构中最有用的一种（虽然列表的列表也非常有用），原因我们接下来会看到。
- en: 'To form a list of pairs, we can use the Prelude function `zip`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了形成一对对的列表，我们可以使用 Prelude 函数 `zip`：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `zip` function takes two lists and pairs their first elements, their second
    elements, and so on until the end of the shorter list. [Table 9-3](ch09.xhtml#ch9tab3)
    shows some examples of how to use `zip`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip` 函数接受两个列表，并将它们的第一个元素、第二个元素等配对，直到较短列表的末尾。 [表 9-3](ch09.xhtml#ch9tab3) 显示了如何使用
    `zip` 的一些示例。'
- en: '**Table 9-3:** Examples of `zip` and `zipWith`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-3：** `zip` 和 `zipWith` 的示例'
- en: '| **Expression** |  | **Evaluates to** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **计算结果** |'
- en: '| --- | --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `zip [1,2,3] [4,5,6]` | ⇝ | `[(1,4),(2,5),(3,6)]` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `zip [1,2,3] [4,5,6]` | ⇝ | `[(1,4),(2,5),(3,6)]` |'
- en: '| `zip [1,2] [4,5,6]` | ⇝ | `[(1,4),(2,5)]` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `zip [1,2] [4,5,6]` | ⇝ | `[(1,4),(2,5)]` |'
- en: '| `zip [5..7] "who"` | ⇝ | `[(5,''w''),(6,''h''),(7,''o'')]` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `zip [5..7] "who"` | ⇝ | `[(5,''w''),(6,''h''),(7,''o'')]` |'
- en: '| `zipWith (+) [1,2,3] [4,5,6]` | ⇝ | `[5,7,9]` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `zipWith (+) [1,2,3] [4,5,6]` | ⇝ | `[5,7,9]` |'
- en: '| `zipWith (-) [1,2,3] [4,5,6]` | ⇝ | `[-3,-3,-3]` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `zipWith (-) [1,2,3] [4,5,6]` | ⇝ | `[-3,-3,-3]` |'
- en: '| `zipWith (*) [1,2,3] [4,5,6]` | ⇝ | `[4,10,18]` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `zipWith (*) [1,2,3] [4,5,6]` | ⇝ | `[4,10,18]` |'
- en: The Prelude function `zipWith` is a high-power relative of `zip` that goes one
    step further and applies a function to each pair of values that `zip` would have
    generated.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Prelude 函数 `zipWith` 是 `zip` 的高效变体，它更进一步，并将一个函数应用于 `zip` 本会生成的每一对值。
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first argument to `zipWith` is a higher-order function that describes what
    to do with an element of type `a` (from the first list) and an element of type
    `b` (from the second list). The second argument to `zipWith` is the first list,
    and the third argument to `zipWith` is the second list.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`zipWith` 的第一个参数是一个高阶函数，描述如何处理类型为 `a` 的元素（来自第一个列表）和类型为 `b` 的元素（来自第二个列表）。`zipWith`
    的第二个参数是第一个列表，第三个参数是第二个列表。'
- en: The Prelude function `unzip` takes a lists of pairs and turns it into a pair
    of lists.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Prelude 函数 `unzip` 接受一对对的列表，并将其转换为一对列表。
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One use for a list of pairs is a lookup table. In a lookup table, the first
    item of each pair serves as a *key* and the second item of each pair serves as
    a *value*. Such a pair is referred to as a *key-value pair*. The following list
    of pairs is a lookup table containing the final numeric grade for the History
    of Western Civilization course taken by three famous scientists. The name of each
    person acts as the key, and the grade is the value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 配对列表的一个用途是查找表。在查找表中，每对中的第一个元素充当 *键*，第二个元素充当 *值*。这样的对称被称为 *键值对*。以下是一个包含三位著名科学家所修“西方文明史”课程最终成绩的查找表。每个人的名字作为键，成绩作为值。
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Prelude function `lookup` takes a key and a lookup table and returns the
    corresponding value, if there is one. The function `lookup` returns a `Maybe`
    type to allow for the possibility that the key is not found in the lookup table.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Prelude 函数 `lookup` 接受一个键和一个查找表，并返回相应的值（如果有的话）。函数 `lookup` 返回一个 `Maybe` 类型，以允许键在查找表中未找到的情况。
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tuples and List Comprehensions
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组和列表推导
- en: 'Later, we’ll want to have a way to use list comprehensions to form lists of
    pairs (*x*,*y*) we want to plot. In [Chapter 11](ch11.xhtml), for example, we’ll
    meet a plotting function called `plotPath` that takes a list of pairs of numbers
    as input, usually `[(R,R)]`, and produces a plot. We can use list comprehensions
    to transform our data into a form suitable for plotting. If we wanted to plot
    position as a function of time, we could form a list of time-position pairs as
    follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以后，我们会希望使用列表推导式来形成我们想要绘制的对（*x*,*y*）的列表。例如，在[第11章](ch11.xhtml)中，我们会遇到一个绘图函数`plotPath`，它接受一个由数字对组成的列表作为输入，通常是`[(R,R)]`，并生成一个图表。我们可以使用列表推导式将数据转换为适合绘图的形式。如果我们想要绘制位置随时间变化的图像，可以按照以下方式形成一个时间-位置对的列表：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The same list of pairs can be formed with `map`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的对列表可以通过`map`生成：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Besides mapping, a list comprehension can filter data based on a Boolean expression.
    Let’s continue our example of forming a list of time-position pairs with `yRock30`.
    Suppose we want to only have pairs in our list while the rock is in the air (*y*
    > 0).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了映射，列表推导式还可以基于布尔表达式过滤数据。让我们继续用`yRock30`形成时间-位置对的例子。假设我们只希望在岩石在空中时（*y* > 0）保留对。
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After we give the list that the values of `t` come from, we add a comma and
    then the Boolean expression to use for filtering. The computer will form a list,
    as before, but now only keep values for which the Boolean expression returns `True`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在给出`t`值来源的列表后，我们添加一个逗号，然后是用于过滤的布尔表达式。计算机会像以前一样生成一个列表，但现在只保留布尔表达式返回`True`的值。
- en: We can achieve the same effect with a combination of `map` and `filter`. We
    can do the filtering first,
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`map`和`filter`的组合实现相同的效果。我们可以先进行过滤，
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'or we can do the mapping first:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以先进行映射：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The application operator `$` from [Table 1-2](ch01.xhtml#ch1tab2) has a precedence
    of 0, so the expressions on each side of it are evaluated before they are combined.
    In this way, the application operator serves as a kind of one-symbol parentheses.
    The same effect could have been produced by enclosing the entire `map` line above
    in parentheses.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-2](ch01.xhtml#ch1tab2)中的应用操作符`$`的优先级为0，因此它两侧的表达式会在合并之前先被计算。通过这种方式，应用操作符充当了一种单符号的括号。通过将整个`map`行用括号括起来，也能达到相同的效果。'
- en: Note the use of the `_` (underscore) character in the anonymous function just
    shown. Since the conditional expression only depends on the second item in the
    pair, there is no need to give a name to the first item in the pair.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在刚才展示的匿名函数中使用了`_`（下划线）字符。由于条件表达式仅依赖于对中的第二项，因此没有必要给对中的第一项命名。
- en: The type of a pair is formed from two existing types. The type of a triple is
    formed from three existing types. The idea of a *type constructor*, which we explore
    in the next section, provides a unifying framework for constructing new types
    from old.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一对的类型是由两个现有类型组成的。三元组的类型是由三个现有类型组成的。*类型构造器*的概念（我们将在下一节探讨）提供了一个统一的框架，用于从旧的类型构建新的类型。
- en: Type Constructors and Kinds
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型构造器与种类
- en: '`Maybe Int` is a type, `Maybe Bool` is a type, and `Maybe R` is a type, but
    `Maybe` itself is not a type. It’s what’s called a *type constructor*. A type
    constructor is an object that takes zero or more types as input and produces a
    type as output. `Maybe` is a one-place type constructor, taking the type `Int`
    as input and producing the type `Maybe Int` as output. In other words, `Maybe`
    is a function at the type level. A zero-place type constructor is the same as
    a type. To keep track of this complexity, Haskell assigns a *kind* to each type
    and type constructor. A type, such as `R`, has the kind `*`. GHCi has the command
    :kind (or `:k` for short) to ask about the kind of something.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe Int`是一个类型，`Maybe Bool`是一个类型，`Maybe R`是一个类型，但`Maybe`本身不是一个类型。它是一个*类型构造器*。类型构造器是一个接受零个或多个类型作为输入并生成一个类型作为输出的对象。`Maybe`是一个一元类型构造器，它接受类型`Int`作为输入并生成类型`Maybe
    Int`作为输出。换句话说，`Maybe`是一个类型层面的函数。一个零元类型构造器与一个类型相同。为了跟踪这种复杂性，Haskell为每个类型和类型构造器分配了一个*种类*。例如，`R`具有种类`*`。GHCi有一个命令`:kind`（简写为`:k`），用于查询某个对象的种类。'
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A one-place type constructor, such as `Maybe`, has the kind `* -> *`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个一元类型构造器，例如`Maybe`，具有种类`* -> *`。
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once we apply `Maybe` to `R`, the resulting `Maybe R` is once again a type,
    with the kind `*`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将`Maybe`应用于`R`，得到的`Maybe R`再次是一个类型，具有种类`*`。
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Types have the kind `*`, one-place type constructors have the kind `* -> *`,
    and there are objects with more complicated kinds as well. It is interesting to
    note that you can ask GHCi for the kind of a type class.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 类型的种类为 `*`，单位置类型构造器的种类为 `* -> *`，而且还有一些种类更为复杂的对象。值得注意的是，你可以询问 GHCi 一个类型类的种类。
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This kind means that, when provided with a type, the type class `Num` produces
    a constraint.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这种种类意味着，当提供一个类型时，类型类 `Num` 会生成一个约束。
- en: Function types, list types, and tuple types are all special cases of types constructed
    with a type constructor. Haskell provides special syntax for function types, list
    types, and tuple types, so it may aid our understanding to give regular names
    to the type constructors that produce functions, lists, and tuples. The `type`
    keyword, which was introduced in [Chapter 4](ch04.xhtml) to make `R` a synonym
    for `Double`, can also be used for parameterized types.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型、列表类型和元组类型都是由类型构造器构造的特殊类型。Haskell 为函数类型、列表类型和元组类型提供了特殊语法，因此我们可以通过为生成函数、列表和元组的类型构造器命名，来帮助理解它们。`type`
    关键字，在[第 4 章](ch04.xhtml)中用于将 `R` 作为 `Double` 的同义词，也可以用于参数化类型。
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`List`, like `Maybe`, is a one-place type constructor. It takes one type as
    input and produces a type as output. `Function` and `Pair` are two-place type
    constructors. They take two types as input and produce a type as output. `Triple`
    is a three-place type constructor. It takes three types as input and produces
    a type as output.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`（列表），像 `Maybe`（可能），是一个单一位置的类型构造器。它接受一个类型作为输入，并生成一个类型作为输出。`Function`（函数）和
    `Pair`（对）是双位置的类型构造器。它们接受两个类型作为输入，并生成一个类型作为输出。`Triple`（三元组）是一个三位置的类型构造器。它接受三个类型作为输入，并生成一个类型作为输出。'
- en: '[Table 9-4](ch09.xhtml#ch9tab4) shows the kinds of some type constructors and
    type classes.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-4](ch09.xhtml#ch9tab4) 展示了某些类型构造器和类型类的种类。'
- en: '**Table 9-4:** Kinds of Several Type Constructors and Type Classes'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-4：** 各种类型构造器和类型类的种类'
- en: '| **Type constructor/class** |  | **Kind** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **类型构造器/类** |  | **种类** |'
- en: '| --- | --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Integer` | `::` | `*` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `Integer` | `::` | `*` |'
- en: '| `R -> R` | `::` | `*` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `R -> R` | `::` | `*` |'
- en: '| `[String]` | `::` | `*` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `[String]` | `::` | `*` |'
- en: '| `(Int,String)` | `::` | `*` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `(Int,String)` | `::` | `*` |'
- en: '| `Maybe Int` | `::` | `*` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `Maybe Int` | `::` | `*` |'
- en: '| `()` | `::` | `*` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `()` | `::` | `*` |'
- en: '| `List` | `::` | `* -> *` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `List` | `::` | `* -> *` |'
- en: '| `[]` | `::` | `* -> *` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `[]` | `::` | `* -> *` |'
- en: '| `Maybe` | `::` | `* -> *` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `Maybe` | `::` | `* -> *` |'
- en: '| `IO` | `::` | `* -> *` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `IO` | `::` | `* -> *` |'
- en: '| `Function` | `::` | `* -> * -> *` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `Function` | `::` | `* -> * -> *` |'
- en: '| `(->)` | `::` | `* -> * -> *` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `(->)` | `::` | `* -> * -> *` |'
- en: '| `Pair` | `::` | `* -> * -> *` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `Pair` | `::` | `* -> * -> *` |'
- en: '| `(,)` | `::` | `* -> * -> *` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `(,)` | `::` | `* -> * -> *` |'
- en: '| `Either` | `::` | `* -> * -> *` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `Either` | `::` | `* -> * -> *` |'
- en: '| `Triple` | `::` | `* -> * -> * -> *` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `Triple` | `::` | `* -> * -> * -> *` |'
- en: '| `(,,)` | `::` | `* -> * -> * -> *` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `(,,)` | `::` | `* -> * -> * -> *` |'
- en: '| `Num` | `::` | `* -> Constraint` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `Num` | `::` | `* -> Constraint` |'
- en: '| `Foldable` | `::` | `(* -> *) -> Constraint` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `Foldable` | `::` | `(* -> *) -> Constraint` |'
- en: Basic types, function types, list types, tuple types, `Maybe` types, and the
    unit type all have the kind `*`. One-place type constructors, such as `List`,
    `Maybe`, and `IO`, have the kind `* -> *`, which indicates that they take a type
    as input and produce a type as output. Note that the symbol `[]`, which is the
    empty list and hence is a data constructor for the list type, serves double duty
    as a type constructor for the list type. In this role it does the same thing as
    the `List` type constructor we defined above. `IO` is a type constructor that
    turns a pure type into a type with side effects; we’ll discuss it in [Chapter
    11](ch11.xhtml).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型、函数类型、列表类型、元组类型、`Maybe` 类型和单位类型的种类都是 `*`。单位置类型构造器，如 `List`、`Maybe` 和 `IO`，具有
    `* -> *` 的种类，这意味着它们接受一个类型作为输入并生成一个类型作为输出。请注意，符号 `[]`，它是空列表，因此是列表类型的数据构造器，同时也作为列表类型的类型构造器发挥作用。在这个角色中，它的作用与我们上面定义的
    `List` 类型构造器相同。`IO` 是一个类型构造器，它将一个纯粹的类型转换为带有副作用的类型；我们将在[第 11 章](ch11.xhtml)中讨论它。
- en: Two-place type constructors, such as `Function`, `Pair`, and `Either` have the
    kind `* -> * -> *` to indicate that they take two types as input and produce a
    type as output. The symbol `(->)` is the same as the `Function` type constructor
    we defined above and `(,)` is the same as `Pair`. A three-place type constructor,
    such as `Triple`, has the kind `* -> * -> * -> *` to indicate that it takes three
    types as input and produces a type as output. The symbol `(,,)` is the same as
    `Triple`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 二元类型构造器，如 `Function`、`Pair` 和 `Either`，具有 kind `* -> * -> *`，表示它们接受两个类型作为输入并产生一个类型作为输出。符号
    `(->)` 与我们之前定义的 `Function` 类型构造器相同，`(,)` 与 `Pair` 相同。三元类型构造器，如 `Triple`，具有 kind
    `* -> * -> * -> *`，表示它接受三个类型作为输入并产生一个类型作为输出。符号 `(,,)` 与 `Triple` 相同。
- en: '[Table 9-5](ch09.xhtml#ch9tab5) shows the meanings of various kinds in Haskell.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-5](ch09.xhtml#ch9tab5) 显示了 Haskell 中各种 kind 的含义。'
- en: '**Table 9-5:** Meanings of Kinds'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-5：** Kinds 的含义'
- en: '| **Kind** | **Meaning** |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **Kind** | **含义** |'
- en: '| --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `*` | Type |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 类型 |'
- en: '| `* -> *` | One-place type constructor |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `* -> *` | 一元类型构造器 |'
- en: '| `* -> * -> *` | Two-place type constructor |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `* -> * -> *` | 二元类型构造器 |'
- en: '| `* -> * -> * -> *` | Three-place type constructor |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `* -> * -> * -> *` | 三元类型构造器 |'
- en: '| `* -> Constraint` | Type class for types |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `* -> Constraint` | 类型的类型类 |'
- en: '| `(* -> *) -> Constraint` | Type class for type constructors |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `(* -> *) -> Constraint` | 类型构造器的类型类 |'
- en: Each type class also has a kind. A type class takes a type or type constructor
    as input and produces a constraint as output. The basic type classes we discussed
    in [Chapter 8](ch08.xhtml) have the kind `* -> Constraint`, meaning they take
    a type as input and produce a type-class constraint as output. The type class
    `Foldable` has the kind `(* -> *) -> Constraint`, meaning that it takes a type
    constructor (such as `List` or `Maybe`) as input and produces a type-class constraint
    as output. `List` and `Maybe` are instances of `Foldable`, but `IO` is not.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型类也有一个 kind。类型类接受一个类型或类型构造器作为输入，并产生一个约束作为输出。我们在[第 8 章](ch08.xhtml)讨论的基本类型类具有
    kind `* -> Constraint`，意味着它们接受一个类型作为输入，并产生一个类型类约束作为输出。类型类 `Foldable` 的 kind 是
    `(* -> *) -> Constraint`，意味着它接受一个类型构造器（如 `List` 或 `Maybe`）作为输入，并产生一个类型类约束作为输出。`List`
    和 `Maybe` 是 `Foldable` 的实例，但 `IO` 不是。
- en: Our final use of tuples in this chapter is in numerical integration. By using
    a tuple together with `iterate`, we get a method for numerical integration that
    we can later generalize to a method for solving a differential equation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们对元组的最终使用是在数值积分中。通过将元组与 `iterate` 一起使用，我们获得了一种数值积分的方法，稍后我们可以将其推广为解决微分方程的方法。
- en: Numerical Integration Redux
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值积分 Redux
- en: We looked at numerical integration in [Chapter 6](ch06.xhtml), where we used
    a list comprehension to sum the areas of rectangles under a curve. Now that we
    have tuples, we can present an alternative method for numerical integration that
    comes closer to the method we’ll later use to solve differential equations. The
    idea is that if we pair up the current value of the integration variable (let’s
    call it time) with the accumulating value of the integral, we can proceed step
    by step to get the entire integral. To take one step forward, we increment the
    time by the time step and increment the running total that will ultimately be
    our integral by the area of one rectangle under the curve.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 6 章](ch06.xhtml)中讨论了数值积分，在那里我们使用了列表推导来计算曲线下方矩形的面积。现在我们有了元组，我们可以提出一种数值积分的替代方法，这种方法更接近我们后来用来解决微分方程的方法。这个思想是，如果我们将当前积分变量的值（假设为时间）与当前积分值配对，我们就可以一步步地得到整个积分。为了向前推进一步，我们将时间增加一个时间步长，并通过曲线下一个矩形的面积来增加最终得到的积分的累积值。
- en: 'The function that advances one step looks like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 推进一步的函数如下所示：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The function `oneStep` names the incoming time step `dt`, the function to be
    integrated `f`, the current value of the integration variable `t`, and the current
    accumulating value of the integral `y`. It then returns a pair with the integration
    variable increased by the time step and the current value of the integral increased
    by the area f t * dt of one rectangle under the function `f`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `oneStep` 将传入的时间步长命名为 `dt`，被积分的函数命名为 `f`，当前积分变量的值命名为 `t`，当前积分值的累积值命名为 `y`。然后它返回一个元组，包含增加了时间步长的积分变量值和通过函数
    `f` 下一个矩形面积 `f t * dt` 增加的当前积分值。
- en: To compute the integral, we iterate the single step as long as the independent
    variable is less than the upper limit.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算积分，我们在自变量小于上限时反复执行单步操作。
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The expression `oneStep dt f :: (R,R) -> (R,R)` is a function that updates
    the current time-integral pair by one time step. Since this function has the type
    `a -> a`, it can be iterated with `iterate`. The expression iterate (oneStep dt
    f) (a + dt/2,0) produces an infinite list of time-integral pairs, starting with
    the time a + dt/2, which is in the middle of the first time interval, and an initial
    value of 0 for the value of the integral that will accumulate as we iterate.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '表达式 `oneStep dt f :: (R,R) -> (R,R)` 是一个通过一个时间步长更新当前时间积分对的函数。由于该函数的类型是 `a ->
    a`，它可以与 `iterate` 一起迭代。表达式 `iterate (oneStep dt f) (a + dt/2,0)` 会生成一个无限的时间积分对列表，起始时间是
    `a + dt/2`，即第一个时间区间的中间值，初始积分值为 0，随着迭代积累。'
- en: By acting on the infinite list with `dropWhile (\(t,_) -> t < b)`, we drop the
    initial pairs whose times are less than the upper limit `b` to obtain an infinite
    list whose first pair has a time very close to the upper limit `b`. Acting on
    this infinite list with `head` returns the pair whose time is very close to the
    upper limit. Finally, acting on this pair with `snd` returns the value of the
    integral.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对无限列表应用 `dropWhile (\(t,_) -> t < b)`，我们丢弃了时间小于上限 `b` 的初始对，以获得一个无限列表，其第一个对的时间非常接近上限
    `b`。然后，应用 `head` 对这个无限列表进行操作，返回时间非常接近上限的对。最后，对该对应用 `snd`，返回积分的值。
- en: 'For convenience, here is the `Integration` type from [Chapter 6](ch06.xhtml)
    that we used earlier in the type signature of `integral''`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为方便起见，这里是 [第6章](ch06.xhtml) 中我们之前在 `integral'` 的类型签名中使用的 `Integration` 类型：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced tuples, a way to combine two or more values into a single
    value. We then looked at type constructors, functions at the type level that form
    an output type from an input type. We ended the chapter by using tuples to introduce
    an alternative way to achieve numerical integration using `iterate`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了元组，它是一种将两个或更多值组合成一个单一值的方式。接着我们讨论了类型构造函数，它是在类型层面上的函数，用来从输入类型形成输出类型。我们通过使用元组介绍了一种使用
    `iterate` 来实现数值积分的替代方法，结束了这一章。
- en: In the next chapter, we’ll return to physics, look at kinematics in three dimensions,
    and develop the data type we’ll use for vectors.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到物理学，研究三维运动学，并开发我们将用于向量的数据类型。
- en: Exercises
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习题
- en: '**Exercise 9.1.** Write a function'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.1.** 编写一个函数'
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: that takes as input polar coordinates (*r*, *θ*), with *θ* in radians, and returns
    as output a pair (x, y) of Cartesian coordinates.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受极坐标 (*r*, *θ*)，其中 *θ* 是弧度表示，并返回一对笛卡尔坐标 (x, y) 作为输出。
- en: '**Exercise 9.2.** Explain in words the meaning of the types of `curry` and
    `uncurry`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.2.** 用语言解释 `curry` 和 `uncurry` 的类型含义。'
- en: '**Exercise 9.3.** The Prelude function'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.3.** Prelude 函数'
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: is slightly problematic in that it causes a runtime error if it is passed an
    empty list. Write a function
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些问题，因为如果传入一个空列表，它会导致运行时错误。编写一个函数
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: that returns `Nothing` if passed the empty list and `Just x` otherwise, where
    `x` is the first element (the head) of the given list. Replace the undefined with
    your own code. (You can use undefined in your own functions as a placeholder if
    you want your code to load before you are finished writing it.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传入空列表，它返回 `Nothing`，否则返回 `Just x`，其中 `x` 是给定列表的第一个元素（头部）。用你自己的代码替换 `undefined`。（如果你希望在代码未写完之前加载代码，可以在自己的函数中使用
    `undefined` 作为占位符。）
- en: '**Exercise 9.4.** We mentioned earlier that the type `Maybe a` is a bit like
    the type `[a]`, except that elements of `Maybe a` are constrained to have zero
    or one element. To make this analogy precise, write a function'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.4.** 我们之前提到，类型 `Maybe a` 有点像类型 `[a]`，不同之处在于 `Maybe a` 的元素只能有零个或一个。为了使这个类比更加精确，编写一个函数'
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: that makes a list out of a `Maybe` type. What list should `Nothing` map to?
    What list should `Just x` map to?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它将一个 `Maybe` 类型转换为一个列表。`Nothing` 应该映射到哪个列表？`Just x` 应该映射到哪个列表？
- en: '**Exercise 9.5.** Find out and explain what happens when `zip` is used with
    two lists that don’t have the same length.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.5.** 查明并解释当 `zip` 与两个长度不相同的列表一起使用时会发生什么。'
- en: '**Exercise 9.6.** Define a function'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.6.** 定义一个函数'
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'that turns a pair of lists into a list of pairs. (Hint: consider using `curry`
    or `uncurry`.)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它将一对列表转换为一对元素的列表。（提示：可以考虑使用 `curry` 或 `uncurry`。）
- en: '**Exercise 9.7.** The dot operator (`.`) is for function composition. If we
    do `unzip` followed by `zip''`, we have a function with the following type signature:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.7.** 点操作符 (`.`) 用于函数组合。如果我们先做 `unzip` 再做 `zip''`，我们会得到一个具有以下类型签名的函数：'
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Is this the identity function? (In other words, does it always return the expression
    it was given?) If so, how do you know? If not, give a counterexample.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是恒等函数吗？（换句话说，它是否总是返回给定的表达式？）如果是，你怎么知道？如果不是，请给出反例。
- en: 'If we do `zip''` followed by `unzip`, we have a function with the following
    type signature:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们先使用 `zip'` 再使用 `unzip`，我们会得到一个具有以下类型签名的函数：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Is this the identity function?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是恒等函数吗？
- en: '**Exercise 9.8.** Using the `grades` lookup table from earlier, show how to
    use the `lookup` function to produce the value `Just 89`. Also show how to use
    the `lookup` function to produce the value `Nothing`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.8.** 使用之前的 `grades` 查找表，展示如何使用 `lookup` 函数来生成值 `Just 89`。还要展示如何使用 `lookup`
    函数生成值 `Nothing`。'
- en: '**Exercise 9.9.** Translate the following mathematical function into Haskell:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.9.** 将以下数学函数翻译成 Haskell：'
- en: '*x*(*r*, *θ*, *ϕ*) = *r* sin *θ* cos *ϕ*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*(*r*, *θ*, *ϕ*) = *r* sin *θ* cos *ϕ*'
- en: Use a triple for the input to the function `x`. Give a type signature as well
    as a function definition.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三元组作为函数 `x` 的输入。同时给出类型签名以及函数定义。
- en: '**Exercise 9.10.** A car starts from rest and accelerates at 5 m/s² along a
    straight, level highway. We want to make an infinite list `tvPairs` of time-velocity
    pairs for this car, one every second. Here is our code for `tvPairs`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.10.** 一辆汽车从静止开始，在一条平直的公路上以 5 m/s² 的加速度行驶。我们想要为这辆车生成一个无限长的时间-速度对 `tvPairs`
    列表，每秒一个。以下是 `tvPairs` 的代码：'
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Write a type signature and function definition for `tvUpdate`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `tvUpdate` 编写类型签名和函数定义。
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The list `tvPairs` should look like [(0,0),(1,5),(2,10),(3,15),...]. After you
    write the function `tvUpdate`, use the `take` function to see the first several
    elements of `tvPairs`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 `tvPairs` 应该看起来像 [(0,0),(1,5),(2,10),(3,15),...]。在编写 `tvUpdate` 函数后，使用 `take`
    函数查看 `tvPairs` 的前几个元素。
- en: '**Exercise 9.11.** A Fibonacci sequence is one in which each term is the sum
    of the previous two terms. The first several terms are 1, 1, 2, 3, 5, 8, 13, 21,
    34, 55\. Write a sequence'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.11.** 斐波那契数列是这样的序列：每一项是前两项的和。前几个项是 1, 1, 2, 3, 5, 8, 13, 21, 34, 55。编写一个序列'
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: for the (infinite) list of Fibonacci numbers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 用于（无限）斐波那契数列。
- en: As a suggestion, write a helping sequence
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 建议编写一个辅助序列
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: using the function `iterate`. The first several terms of fibHelper should be
    [(0,1),(1,1),(1,2),(2,3),(3,5),...]. Then write the sequence `fibonacci` using
    `fibHelper`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数 `iterate`。`fibHelper` 的前几个项应为 [(0,1),(1,1),(1,2),(2,3),(3,5),...]。然后使用
    `fibHelper` 编写 `fibonacci` 序列。
- en: '**Exercise 9.12.** The factorial function takes a non-negative integer and
    returns the product of all positive integers up to and including the given integer.
    It is usually denoted with an exclamation point. For example, 5! = 5 × 4 × 3 ×
    2 × 1 = 120\. We define 0! = 1\. The purpose of this exercise is to write a factorial
    function'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.12.** 阶乘函数接受一个非负整数并返回从 1 到该整数的所有正整数的积。通常用感叹号表示。例如，5! = 5 × 4 × 3 × 2
    × 1 = 120。我们定义 0! = 1。本练习的目的是编写一个阶乘函数'
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'using `iterate`. The suggestion in Exercise 9.11 is useful here as well (write
    a sequence `factHelper :: [(Int,Int)]` using `iterate` and then define `fact`
    to get its values from this sequence using the `!!` operator).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 `iterate`。练习 9.11 中的建议在这里也有用（编写一个序列 `factHelper :: [(Int,Int)]`，使用 `iterate`，然后定义
    `fact` 来通过 `!!` 运算符从该序列中获取值）。'
- en: '**Exercise 9.13.** Write the following function using a list comprehension
    rather than a map:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.13.** 使用列表推导式编写以下函数，而不是使用 map：'
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Exercise 9.14.** Suppose we throw a rock straight up in the air at 15 m/s.
    Use a list comprehension to make a list of (time, position, velocity) triples
    (type `[(R,R,R)]`) for an interval of time while the rock is in the air. Your
    list should have enough triples to let the data make a reasonably smooth graph
    if plotted.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.14.** 假设我们以 15 m/s 的速度将一块石头垂直抛向空中。使用列表推导式生成一个 (时间, 位置, 速度) 三元组的列表（类型为
    `[(R,R,R)]`），记录石头在空中的时间间隔。你的列表应该包含足够的三元组，以便如果绘制数据，图形看起来会比较平滑。'
- en: '**Exercise 9.15.** Tuples can be nested, like `((3,4),5)`. Although this pair
    contains three numbers, it is not the same as a triple. Write a function'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.15.** 元组可以嵌套，比如 `((3,4),5)`。尽管这个对包含三个数字，但它与三元组不同。编写一个函数'
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: that converts a pair whose first component is a pair into a triple.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 它将一个第一个分量是对的对转换为三元组。
