- en: Chapter 5. Pushing the Envelope
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 推动极限
- en: In this chapter, you’ll find techniques that you usually won’t need but can,
    from time to time, be very useful. For example, sometimes it’s useful to extend
    GNU `make`’s language by creating new functions in C or even Guile. This chapter
    shows how to do that and more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你会发现一些通常不需要的技巧，但有时它们会非常有用。例如，有时通过在 C 语言或甚至 Guile 中创建新函数来扩展 GNU `make` 的语言是非常有用的。本章将展示如何做到这一点以及更多内容。
- en: Doing Arithmetic
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做算术
- en: 'GNU `make` has no built-in arithmetic capability. But it is possible to create
    functions for addition, subtraction, multiplication, and division of integers.
    You can also create functions for integer comparisons, such as greater than or
    not equal. These functions are implemented entirely using GNU `make`’s built-in
    list and string manipulation functions: `$(subst)`, `$(filter)`, `$(filter-out)`,
    `$(words)`, `$(wordlist)`, `$(call)`, `$(foreach)`, and `$(if)`. After we define
    our arithmetic functions, we’ll implement a simple calculator in GNU `make`.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 没有内建的算术功能。但我们可以为整数的加法、减法、乘法和除法创建函数。还可以为整数比较（例如大于、不等于）创建函数。这些函数完全通过
    GNU `make` 的内建列表和字符串处理函数实现：`$(subst)`、`$(filter)`、`$(filter-out)`、`$(words)`、`$(wordlist)`、`$(call)`、`$(foreach)`
    和 `$(if)`。在定义完我们的算术函数后，我们将实现一个简单的计算器。
- en: To create an arithmetic library, we first need a representation of numbers.
    A simple way to represent a number is with a list containing that number of items.
    For example, for the arithmetic library, a number is a list of letter `x`s. So
    the number 5 is represented by `x x x x x`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个算术库，我们首先需要一个数字的表示法。表示一个数字的简单方法是使用包含该数量项的列表。例如，对于算术库，数字就是由字母 `x` 组成的列表。因此，数字
    5 表示为 `x x x x x`。
- en: 'Given this representation, we can use the `$(words)` function to convert from
    the internal form (all `x`s) to a human-readable form. For example, the following
    will output 5:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这种表示法，我们可以使用 `$(words)` 函数将内部形式（所有 `x`）转换为人类可读的形式。例如，以下代码将输出 5：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s create a user-defined function `decode` to translate from the `x` representation
    to a number:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个用户自定义函数 `decode`，将 `x` 表示法转换为数字：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To use `decode` in a makefile, we need to use the GNU `make` function `$(call)`,
    which can call a user-defined function with a set of arguments:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Makefile 中使用 `decode`，我们需要使用 GNU `make` 的 `$(call)` 函数，它可以通过一组参数调用用户自定义的函数：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The arguments will be stored in temporary variables called `$1`, `$2`, `$3`,
    and so on. In `decode`, which takes one argument—the number to decode—we just
    use `$1`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 参数将存储在名为 `$1`、`$2`、`$3` 等临时变量中。在 `decode` 中，它接受一个参数——即要解码的数字——我们只需使用 `$1`。
- en: Addition and Subtraction
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加法与减法
- en: 'Now that we have a representation, we can define functions for addition, increment
    (by 1), and decrement (by 1):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了表示法，可以定义加法、增量（加 1）和减量（减 1）的函数：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `plus` function makes a list of its two arguments; concatenation is enough
    to implement addition with the `x` representation. The `increment` function adds
    a single `x` to its argument. `decrement` strips the first `x` off its argument
    by asking for the entire string of `x`s starting from index 2\. For example, the
    following code will output 11:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`plus` 函数将其两个参数组成一个列表；通过连接字符串就能实现带有 `x` 表示法的加法运算。`increment` 函数向其参数中添加一个单独的
    `x`。`decrement` 函数通过从索引 2 开始请求整个由 `x` 组成的字符串，去除其参数中的第一个 `x`。例如，以下代码将输出 11：'
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice the nested calls to `plus` inside a call to `decode` so that we output
    the number 11 instead of a list of 11 `x`s.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `decode` 调用中的 `plus` 函数的嵌套调用，以便我们输出数字 11，而不是由 11 个 `x` 组成的列表。
- en: 'We can create another simple function, `double`, which doubles its argument:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建另一个简单的函数 `double`，它将参数翻倍：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implementing subtraction is more challenging that addition. But before we do
    that, let’s implement `max` and `min` functions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实现减法比加法更具挑战性。但在我们进行减法实现之前，先来实现 `max` 和 `min` 函数：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `max` function uses two GNU `make` built-in functions: `$(join)` and `$(subst)`.
    `$(join LIST1,LIST2)` takes two lists as arguments and joins the two lists together
    by concatenating the first element of `LIST1` with the first element of `LIST2`
    and so on through the list. If one list is longer than the other, the remaining
    items are just appended.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`max` 函数使用了两个 GNU `make` 内建函数：`$(join)` 和 `$(subst)`。`$(join LIST1,LIST2)`
    将两个列表作为参数，按顺序连接两个列表：将 `LIST1` 的第一个元素与 `LIST2` 的第一个元素连接，依此类推。如果一个列表比另一个长，剩余的项将直接附加到列表的末尾。'
- en: '`$(subst FROM,TO,LIST)` runs through a list and substitutes elements that match
    a `FROM` pattern with the `TO` value. To see how `max` works, consider the sequence
    of events in computing `$(call max,$(five),$(six))`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(subst FROM,TO,LIST)`遍历一个列表，并将匹配`FROM`模式的元素替换为`TO`值。为了了解`max`如何工作，考虑在计算`$(call
    max,$(five),$(six))`时发生的事件顺序：'
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, `$(join)` joins the list with five `x`s with the list with six `x`s,
    resulting in a list with six elements, the first five of which are `xx.` Then,
    `$(subst)` turns the first five `xx`s into `x`s. The final result is six `x`s,
    which is the maximum.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`$(join)`将包含五个`x`的列表与包含六个`x`的列表连接，结果是一个包含六个元素的列表，其中前五个是`xx`。然后，`$(subst)`将前五个`xx`转换为`x`。最终结果是六个`x`，这是最大值。
- en: 'To implement `min`, we use a similar trick, but we keep only the `xx`s and
    throw away the `x`s:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现`min`，我们使用类似的技巧，但我们只保留`xx`并丢弃`x`：
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `xx`s represent where the two lists could be joined. The shorter of the
    two lists will have only `xx`s. The `$(filter PATTERN,LIST)` function runs through
    the list and removes elements that do not match the pattern.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`xx`表示两个列表可能连接的位置。较短的列表只会包含`xx`。`$(filter PATTERN,LIST)`函数会遍历列表并移除与模式不匹配的元素。'
- en: 'A similar pattern works for subtraction:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的模式适用于减法操作：
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For a moment, ignore the `$(warning)` and `$(if)` parts of the definition,
    and focus on `$(filter-out)`. `$(filter-out)` is the opposite of `$(filter)`:
    it removes elements from a list that match the pattern. For example, we can see
    that the `$(filter-out)` here implements subtraction:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时忽略定义中的`$(warning)`和`$(if)`部分，专注于`$(filter-out)`。`$(filter-out)`是`$(filter)`的反操作：它从列表中移除与模式匹配的元素。例如，我们可以看到这里的`$(filter-out)`实现了减法操作：
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Unfortunately, this would also work if five and six were reversed, so we first
    need to check that the first argument is greater than or equal to the second.
    In the `subtract` definition, the special function `gte` (*greater than or equal*)
    returns a non-empty string if its first argument is greater than its second. We
    use `gte` to decide whether to do the subtraction or output a warning message
    using `$(warning)`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果将五和六的位置反转，这种方法也会奏效，因此我们首先需要检查第一个参数是否大于或等于第二个参数。在`subtract`定义中，特殊函数`gte`（*大于或等于*）将在第一个参数大于第二个参数时返回一个非空字符串。我们使用`gte`来决定是否进行减法操作或使用`$(warning)`输出警告消息。
- en: 'The `gte` function is implemented using two other functions for *greater than*
    (`gt`) and *equal* (`eq`):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`gte`函数是通过两个其他函数来实现的，分别用于*大于*（`gt`）和*等于*（`eq`）：'
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`gte` will return a non-empty string if either `gt` or `eq` returns a non-empty
    string.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`gt`或`eq`返回非空字符串，`gte`将返回一个非空字符串。
- en: 'The `eq` function is a bit of a mind-bender. It works out the number of elements
    in its two arguments, treats one argument as a pattern and the other as a list,
    and uses `$(filter)` to decide whether they are the same. Here’s an example where
    they are equal:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`eq`函数有点让人费解。它计算其两个参数中元素的数量，将一个参数视为模式，另一个作为列表，并使用`$(filter)`来判断它们是否相同。以下是一个它们相等的例子：'
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `eq` function converts both `$(five)`s to a list of five `x`s. These are
    then both converted to the number 5 using `$(words)`. The two 5s are fed to `$(filter)`.
    Because the two arguments of `$(filter)` are the same, the result is 5 and because
    5 is not an empty string, it is interpreted as meaning *true*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`eq`函数将两个`$(five)`都转换为由五个`x`组成的列表。然后，这些列表都通过`$(words)`转换为数字5。将这两个5传入`$(filter)`。由于`$(filter)`的两个参数相同，结果是5，而5不是空字符串，因此它被解释为*真*。'
- en: 'Here’s what happens when they are not:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当它们不相等时，发生了以下情况：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This proceeds as for `$(call eq,$(five),$(five))` but with `$(six)` in place
    of one of the `$(five)`s. Since `$(filter 5,6)` is an empty string, the result
    is false.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`$(call eq,$(five),$(five))`的过程类似，只不过用`$(six)`替换了其中一个`$(five)`。由于`$(filter
    5,6)`是一个空字符串，结果为假。
- en: 'So the `$(filter)` function acts as a kind of string equality operator; the
    two strings in our case are the lengths of the two number strings. The `gt` function
    is implemented in a similar way: it returns a non-empty string if the length of
    the first number string is not equal to the maximum of the two number strings.
    Here’s an example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`$(filter)`函数充当了一种字符串相等运算符；在我们的例子中，两个字符串分别是两个数字字符串的长度。`gt`函数的实现方式类似：如果第一个数字字符串的长度不等于两个数字字符串中的最大值，它返回一个非空字符串。下面是一个例子：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `gt` function works in a manner similar to `eq` (described previously) but
    uses `$(filter-out)` instead of `$(filter)`. It converts both `x`-representation
    numbers to digits but compares—using `$(filter-out)`—the first of them against
    the max of the two. When the first number is greater than the second, two different
    numbers are fed to `$(filter-out)`. Because they are different, `$(filter-out)`
    returns a non-empty string indicating true.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`gt` 函数的工作方式与 `eq`（前面描述的）类似，但使用 `$(filter-out)` 而不是 `$(filter)`。它将两个 `x` 表示的数字转换为数字，但使用
    `$(filter-out)` 比较它们中的第一个与两者的最大值。当第一个数字大于第二个时，两个不同的数字会传递给 `$(filter-out)`。由于它们不同，`$(filter-out)`
    会返回一个非空字符串，表示真。'
- en: 'Here’s an example in which the first number is less than the second:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，其中第一个数字小于第二个：
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, because the `max` of the two numbers is the same as the second number
    (because it’s the largest), `$(filter-out)` is fed the same number and returns
    an empty string indicating false.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，因为两个数字的 `max` 与第二个数字相同（因为它是最大的），所以 `$(filter-out)` 被传入相同的数字并返回一个空字符串，表示假。
- en: 'Similarly, we can define *not-equal* (`ne`), *less-than* (`lt`), and *less-than-or-equal*
    (`lte`) operators:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以定义 *不等于* (`ne`)，*小于* (`lt`)，和 *小于或等于* (`lte`) 操作符：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`lte` is defined in terms of `lt` and `eq`. Because a non-empty string means
    *true*, `lte` just concatenates the values returned by `lt` and `eq`; if either
    returned true, then `lte` returns true.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`lte` 是通过 `lt` 和 `eq` 定义的。因为非空字符串意味着 *真*，所以 `lte` 只会将 `lt` 和 `eq` 返回的值连接起来；如果其中任何一个返回真，那么
    `lte` 就返回真。'
- en: Multiplication and Division
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 乘法和除法
- en: 'We’ll have a pretty powerful arithmetic package after we define just three
    more functions: `multiply`, `divide`, and `encode`. `encode` is a way to create
    a number string of `x`s from an integer; we’ll leave that for last and then implement
    our calculator.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了另外三个函数：`multiply`、`divide` 和 `encode` 后，我们将拥有一个非常强大的算术包。`encode` 是将一个整数转化为一串
    `x` 字符的方式；我们将把它留到最后，并实现我们的计算器。
- en: 'Multiplication uses the `$(foreach VAR,LIST,DO)` function. It sets that variable
    named `VAR` to each element of `LIST` and does whatever `DO` says. So multiplication
    is easy to implement:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法使用 `$(foreach VAR,LIST,DO)` 函数。它将名为 `VAR` 的变量设置为 `LIST` 中的每个元素，并执行 `DO` 中指定的操作。因此，乘法很容易实现：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`multiply` just strings together its second argument for however many `x`s
    there are in the first argument. For example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiply` 将其第二个参数与第一个参数中有多少个 `x` 字符拼接在一起。例如：'
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`divide` is the most complex function of the lot because it requires recursion:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`divide` 是其中最复杂的函数，因为它需要递归：'
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If its first argument is less than its second, division returns `0` because
    the `ELSE` part of the `$(if)` is empty (see the `,)` at the end). If division
    is possible, `divide` works by repeated subtraction of the second argument from
    the first, using the `subtract` function. Each time it subtracts, it adds an `x`
    and calls `divide` again. Here’s an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个参数小于第二个，除法将返回 `0`，因为 `$(if)` 的 `ELSE` 部分是空的（见结尾的 `,)`）。如果可以进行除法，`divide`
    会通过从第一个参数中反复减去第二个参数来工作，使用 `subtract` 函数。每次减去时，它会添加一个 `x` 并再次调用 `divide`。以下是一个例子：
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, `gte` returns a non-empty string, so recursion happens. Next, `gte` returns
    an empty string, so no more recursion occurs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`gte` 返回一个非空字符串，因此会发生递归。接下来，`gte` 返回一个空字符串，因此不会再发生递归。
- en: 'We can avoid recursion in the special case of division by 2; we define the
    `halve` function to be the opposite of `double`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在除以 2 的特殊情况下避免递归；我们定义 `halve` 函数，它是 `double` 的反操作：
- en: '[PRE21]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By now you’ve seen all the functions used in `halve`. Work through an example,
    say `$(call halve,$(five))`, to see how it works.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经看过 `halve` 中使用的所有函数。通过一个例子，假设 `$(call halve,$(five))`，来查看它是如何工作的。
- en: 'The only tricky thing to do is turn a number a user enters into a string of
    `x`s. The `encode` function does this by deleting a substring of `x`s from a predefined
    list of `x`s:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要注意的事情是将用户输入的数字转换成一串 `x` 字符。`encode` 函数通过从预定义的 `x` 字符串中删除一个子串来完成这项工作：
- en: '[PRE22]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we are limited to entering numbers up to 65536\. We can fix that by changing
    the number of `x`s in `input_int`. Once we have the number in the encoding, only
    available memory limits the size of integers we can work with.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们限制了最多输入到 65536。我们可以通过改变 `input_int` 中的 `x` 数量来解决这个问题。一旦我们得到了编码中的数字，只有可用的内存限制了我们可以处理的整数大小。
- en: 'Using Our Arithmetic Library: A Calculator'
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用我们的算术库：一个计算器
- en: 'To really show off this library, here’s an implementation of a Reverse Polish
    Notation calculator written entirely in GNU `make` functions:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正展示这个库，下面是一个完全用 GNU `make` 函数编写的逆波兰表示法计算器实现：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The operators and numbers are passed into GNU `make` in the `calc` variable,
    separated by commas. For example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符和数字被传递到 GNU `make` 中的 `calc` 变量中，且通过逗号分隔。例如：
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Clearly, this is not what GNU `make` was designed for, but it does show the
    power of GNU `make` functions. Here’s the complete commented makefile:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不是 GNU `make` 的设计初衷，但它展示了 GNU `make` 函数的强大功能。下面是完整的注释版 makefile：
- en: '[PRE25]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You’ll get a closer look at these techniques in [Chapter 6](ch06.html "Chapter 6. The
    GNU Make Standard Library") when you learn about the GNU Make Standard Library.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第 6 章](ch06.html "第 6 章. GNU Make 标准库")中更详细地了解这些技术，当你学习 GNU Make 标准库时。
- en: Making an XML Bill of Materials
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作 XML 材料清单
- en: With standard GNU `make` output, it’s difficult to answer the question of what
    got built and why. This section presents a simple technique to get GNU `make`
    to create an XML file containing a *bill of materials (BOM)*. The BOM contains
    the names of all the files built by the makefile and is nested to show the prerequisites
    of each file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准的 GNU `make` 输出，很难回答构建了什么以及为什么。这一节介绍了一种简单的技术，可以让 GNU `make` 创建一个包含*材料清单（BOM）*的
    XML 文件。BOM 包含了 makefile 构建的所有文件的名称，并且通过嵌套结构显示每个文件的先决条件。
- en: An Example Makefile and BOM
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 Makefile 和 BOM
- en: '[Example 5-1](ch05.html#simple_makefile_to_illustrate_the_bom "Example 5-1. A
    simple makefile to illustrate the BOM") shows an example makefile. We’ll look
    at its BOM and then work backward to see how the BOM JSON file was generated.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-1](ch05.html#simple_makefile_to_illustrate_the_bom "示例 5-1. 一个简单的 makefile
    用来说明 BOM") 展示了一个示例 makefile。我们将查看其 BOM，然后反向追溯，以了解 BOM JSON 文件是如何生成的。'
- en: Example 5-1. A simple makefile to illustrate the BOM
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-1. 一个简单的 makefile 用来说明 BOM
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This makes `all` from `foo` and `bar.` In turn, `foo` is made from `baz`. Running
    this code in GNU `make` produces the following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例生成 `all`，由 `foo` 和 `bar` 构成。反过来，`foo` 是由 `baz` 构成的。在 GNU `make` 中运行这段代码，会产生如下输出：
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From the output, it’s impossible to identify the tree-ordering of the build
    or which files depend on which. In this case, the makefile is small and relatively
    easy to trace by hand; in a real makefile, hand tracing is almost impossible.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，无法识别构建的树形顺序或哪些文件依赖于哪些文件。在这种情况下，makefile 很小，手动追踪相对容易；但在实际的 makefile 中，手动追踪几乎是不可能的。
- en: 'It would be nice to produce output like that shown in [Example 5-2](ch05.html#xml_document_showing_the_structure_of_th
    "Example 5-2. An XML document showing the structure of the example makefile")
    that shows what was built and why:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 生成如[示例 5-2](ch05.html#xml_document_showing_the_structure_of_th "示例 5-2. 一个展示示例
    makefile 结构的 XML 文档")中所示的输出是很好的，它展示了构建了什么以及为什么：
- en: Example 5-2. An XML document showing the structure of the example makefile
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-2. 一个展示示例 makefile 结构的 XML 文档
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, each rule run by the makefile has a `<rule>` tag added with a `target`
    attribute giving the name of the target that the rule built. If the rule had any
    prerequisites, within the `<rule>`/`</rule>` pair a list of prerequisite rules
    would be enclosed in `<prereq>`/`</prereq>`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个由 makefile 执行的规则都添加了一个 `<rule>` 标签，并通过 `target` 属性给出了该规则构建的目标名称。如果规则有任何先决条件，在
    `<rule>`/`</rule>` 标签对中，会用 `<prereq>`/`</prereq>` 标签包围一个先决条件规则的列表。
- en: You can see the structure of the makefile reflected in the nesting of the tags.
    Loading the XML document into an XML editor (or simply into a web browser) allows
    you to expand and contract the tree at will to explore the structure of the makefile.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 makefile 的结构通过标签的嵌套反映出来。将 XML 文档加载到 XML 编辑器中（或者直接加载到网页浏览器）可以让你自由地展开和收缩树形结构，以探索
    makefile 的结构。
- en: How It Works
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: To create the output shown in [Example 5-2](ch05.html#xml_document_showing_the_structure_of_th
    "Example 5-2. An XML document showing the structure of the example makefile"),
    the example makefile is modified to include a special `bom` makefile using the
    standard `include bom` method. With that included, we can generate the XML output
    by running GNU `make` using a command line, such as `make bom-all`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建如[示例 5-2](ch05.html#xml_document_showing_the_structure_of_th "示例 5-2. 一个展示示例
    makefile 结构的 XML 文档")中所示的输出，示例 makefile 被修改，加入了一个使用标准 `include bom` 方法的特殊 `bom`
    makefile。加入后，我们可以通过运行 GNU `make` 使用命令行，如 `make bom-all` 来生成 XML 输出。
- en: '`bom-all` instructs GNU `make` to build the BOM starting with the `all` target.
    It’s as if you typed `make all`, but now an XML document will be created.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`bom-all`指示GNU `make`从`all`目标开始构建BOM。就像你输入了`make all`，但现在将创建一个XML文档。'
- en: By default, the XML document has the same name as the makefile but with `.xml`
    appended. If the example makefile was in `example.mk`, the XML document created
    would be called `example.mk.xml`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，XML文档的名称与makefile相同，但附加`.xml`。如果示例makefile是`example.mk`，则创建的XML文档将被命名为`example.mk.xml`。
- en: '[Example 5-3](ch05.html#bom_makefile_that_creates_xml_boms "Example 5-3. The
    bom makefile that creates XML BOMs") shows the contents of the `bom` makefile
    to include:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-3](ch05.html#bom_makefile_that_creates_xml_boms "示例 5-3. 创建XML BOM的bom
    makefile")显示了包含`bom` makefile的内容：'
- en: Example 5-3. The `bom` makefile that creates XML BOMs
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-3. 创建XML BOM的`bom` makefile
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First we determine the correct name for the XML file by extracting the name
    of the makefile that included `bom` into `PARENT_MAKEFILE` ➊, appending `.xml`,
    and storing the resulting name in `bom-file` ➋.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过提取包含`bom`的makefile的名称到`PARENT_MAKEFILE` ➊，将`.xml`附加到该名称上，并将结果存储在`bom-file`
    ➋中，从而确定XML文件的正确名称。
- en: 'Then we use a trick that’s appeared in this book a number of times: the `SHELL`
    hack. GNU `make` will expand the value of `$(SHELL)` for every rule that’s run
    in the makefile. And at the time that `$(SHELL)` is expanded, the per-rule automatic
    variables (such as `$@`) have already been set. So by modifying `SHELL`, we can
    perform some task for every rule in the makefile as it runs.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用本书中多次出现的一个技巧：`SHELL`黑客。GNU `make`将在执行makefile中的每条规则时展开`$(SHELL)`的值。当`$(SHELL)`被展开时，每条规则的自动变量（如`$@`）已经被设置。因此，通过修改`SHELL`，我们可以在每条规则执行时为makefile中的每个规则执行某些任务。
- en: At ➌, we store the original value of `SHELL` in `bom-old-shell` using an immediate
    assignment (`:=`), and we then redefine `SHELL` to be the expansion of `$(bom-run)`
    and the original shell at ➍. Because `$(bom-run)` actually expands to an empty
    string, the effect is that `bom-run` is expanded for each rule in the makefile,
    but the actual shell used is unaffected.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在➌处，我们使用立即赋值（`:=`）将`SHELL`的原始值存储在`bom-old-shell`中，然后在➍处重新定义`SHELL`为`$(bom-run)`的展开值和原始shell。因为`$(bom-run)`实际上展开为空字符串，所以其效果是`bom-run`在makefile的每条规则中展开，但实际使用的shell不受影响。
- en: '`bom-run` is defined at ➐. It uses `$(eval)` to store the relationship between
    the current target being built (the `$(if)` ensures that `$@` is defined) and
    its prerequisites. For example, when `foo` is being built, a call will be made
    to `bom-run` with `$@` set to `foo` and `$^` (the list of all prerequisites) set
    to `baz`. `bom-run` will set the value of `bom-prereq-foo` to `baz`. Later, the
    values of these `bom-prereq-X` variables are used to print out the XML tree.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`bom-run`在➐处定义。它使用`$(eval)`存储当前正在构建的目标（`$(if)`确保`$@`已定义）与其前提条件之间的关系。例如，当构建`foo`时，将调用`bom-run`，并将`$@`设置为`foo`，`$^`（所有前提条件的列表）设置为`baz`。`bom-run`将`bom-prereq-foo`的值设置为`baz`。稍后，这些`bom-prereq-X`变量的值将用于打印XML树。'
- en: At ➎, we define the pattern rule that handles the `bom-%` target. Because the
    prerequisite of `bom-%` is `%`, this pattern rule has the effect of building the
    target matching the `%` and then building `bom-%`. In our example, running `make
    bom-all` matches against this pattern rule to build `all` and then run the commands
    associated with `bom-%` with `$*` set to `all`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在➎处，我们定义了处理`bom-%`目标的模式规则。由于`bom-%`的前提条件是`%`，因此这个模式规则的效果是构建与`%`匹配的目标，然后构建`bom-%`。在我们的例子中，运行`make
    bom-all`会与这个模式规则匹配，先构建`all`，然后运行与`bom-%`关联的命令，`$*`设置为`all`。
- en: '`bom-%`’s commands first delete the `bom-file` and then recursively dump out
    the XML starting from `$*`. In this example, where the user did `make bom-all`,
    the `bom-%` commands call `bom-dump` with the argument `all`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`bom-%`的命令首先删除`bom-file`，然后从`$*`开始递归地转储XML。在这个例子中，当用户执行`make bom-all`时，`bom-%`的命令会调用`bom-dump`，并传递参数`all`。'
- en: 'We define `bom-dump` at ➏. It’s fairly routine: it uses a helper function `bom-write`
    to echo fragments of XML to the `bom-file` and calls itself for each of the targets
    in the prerequisites of each target it is dumping. Prerequisites are extracted
    from the `bom-prereq-X` variables created by `bom-run`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➏处定义了`bom-dump`。它相当常规：它使用一个辅助函数`bom-write`将XML片段回显到`bom-file`，并为每个它正在转储的目标的前提条件中的每个目标调用自身。前提条件是从`bom-run`创建的`bom-prereq-X`变量中提取的。
- en: Gotchas
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注意事项
- en: The technique in [Example 5-3](ch05.html#bom_makefile_that_creates_xml_boms
    "Example 5-3. The bom makefile that creates XML BOMs") comes with a few gotchas.
    One gotcha is that the technique can end up producing enormous amounts of output.
    This is because it will print the entire tree below any target. If a target appears
    multiple times in the tree, a large tree can be repeated many times in the output.
    Even for small projects, this can make the dump time for the XML very lengthy.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-3](ch05.html#bom_makefile_that_creates_xml_boms "示例 5-3. 生成 XML BOM 的
    bom makefile")中的技术有一些坑。一个坑是，这种技术最终可能会产生大量输出。这是因为它会打印任何目标下的整个树。如果一个目标在树中多次出现，那么即使是小项目，XML
    的转储时间也会很长。'
- en: 'As a workaround, we can change the definition of `bom-dump` to just dump the
    prerequisite information once for each target. This is much faster than the approach
    in [Example 5-3](ch05.html#bom_makefile_that_creates_xml_boms "Example 5-3. The
    bom makefile that creates XML BOMs") and could be processed by a script like the
    following to help understand the structure of the `make`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种变通方法，我们可以修改 `bom-dump` 的定义，只为每个目标转储一次先决条件信息。这比[示例 5-3](ch05.html#bom_makefile_that_creates_xml_boms
    "示例 5-3. 生成 XML BOM 的 bom makefile")中的方法要快得多，并且可以通过像以下这样的脚本来处理，以帮助理解 `make` 的结构：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For the example makefile in [Example 5-1](ch05.html#simple_makefile_to_illustrate_the_bom
    "Example 5-1. A simple makefile to illustrate the BOM"), the XML document now
    looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 5-1](ch05.html#simple_makefile_to_illustrate_the_bom "示例 5-1. 一个简单的 Makefile
    用于说明 BOM")中的示例 makefile，XML 文档现在如下所示：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Another gotcha is that if the makefile includes rules with no commands, those
    rules will cause a break in the tree outputted by the technique in [Example 5-3](ch05.html#bom_makefile_that_creates_xml_boms
    "Example 5-3. The bom makefile that creates XML BOMs"). For example, if the example
    makefile were this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个坑是，如果 makefile 包含没有命令的规则，这些规则会导致[示例 5-3](ch05.html#bom_makefile_that_creates_xml_boms
    "示例 5-3. 生成 XML BOM 的 bom makefile")中的技术输出的树中断。例如，如果示例 makefile 如下：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'the resulting XML would not mention `baz` at all because the rule for `foo`
    doesn’t have any commands. So `SHELL` is not expanded, and the hack doesn’t work.
    Here’s the XML in that case:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 XML 完全不会提到 `baz`，因为 `foo` 的规则没有任何命令。因此 `SHELL` 不会被展开，黑客方法无法生效。以下是这种情况下的
    XML：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As a workaround, we can modify `foo: baz` to include a useless command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '作为一种变通方法，我们可以修改 `foo: baz`，并为其添加一个无用的命令：'
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now the correct results will be generated.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将生成正确的结果。
- en: Advanced User-Defined Functions
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级用户定义函数
- en: In [Chapter 1](ch01.html "Chapter 1. The Basics Revisited"), we looked at creating
    user-defined functions in GNU `make`. Now we’ll look inside the GNU `make` source
    code to see how we can enhance GNU `make` with our own built-in functions by writing
    some C code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](ch01.html "第 1 章. 再次回顾基础")中，我们讨论了在 GNU `make` 中创建用户定义的函数。现在我们将深入了解
    GNU `make` 源代码，看看如何通过编写 C 代码来增强 GNU `make`，使其支持我们自己的内建函数。
- en: First, we get the GNU `make` source code from the Free Software Foundation.
    For this section, I’m working with GNU `make` 3.81\. Things haven’t changed much
    with GNU `make` 3.82 or 4.0.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从自由软件基金会获取 GNU `make` 源代码。对于这一部分，我使用的是 GNU `make` 3.81。对于 GNU `make` 3.82
    或 4.0，变化不大。
- en: 'Download `make-3.81.tar.gz`, and `gunzip` and `untar`, and then build GNU `make`
    using the standard `configure` and `make`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 `make-3.81.tar.gz`，然后使用 `gunzip` 和 `untar` 解压，再使用标准的 `configure` 和 `make`
    构建 GNU `make`：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With that done, we are left with a working GNU `make` in the same directory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 完成之后，我们得到一个在同一目录下工作的 GNU `make`。
- en: Getting Started Modifying GNU make
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始修改 GNU make
- en: 'It’s handy to be able to tell which GNU `make` you’re running, so as a first
    modification let’s change the message printed out when we ask for the version
    information. Here’s the default:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 能够知道自己正在运行哪个版本的 GNU `make` 非常方便。因此，作为第一次修改，我们将更改打印版本信息时显示的消息。默认信息如下：
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, I’m working on a Mac (that final string will change depending
    on the machine you are working with) with GNU `make` version 3.81.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我正在使用 Mac（该字符串会根据你使用的机器有所不同），并且使用的是 GNU `make` 版本 3.81。
- en: 'Let’s change that message so it prints `(with jgc''s modifications)` after
    the version number. To do that, we need to open the file `main.c` in a text editor
    and find the function `print_version` (at line 2,922), which looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改该消息，使其在版本号后打印 `(with jgc's modifications)`。为此，我们需要在文本编辑器中打开 `main.c` 文件，找到
    `print_version` 函数（位于第 2,922 行），它看起来像这样：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The first `printf` in `print_version` is where the version number is printed.
    We can modify it like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_version` 中的第一个 `printf` 是打印版本号的地方。我们可以像这样修改它：'
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Save the file, and then rerun `make`. Now enter **`make -v`**:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，再次运行 `make`。现在输入 **`make -v`**：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We now know which version we’re working with.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们正在使用哪个版本。
- en: Anatomy of a Built-In Function
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置函数的结构
- en: 'GNU `make`’s built-in functions are defined in the file `function.c`. To begin
    understanding how this file works, take a look at the table of functions that
    GNU `make` knows about. It’s called `function_table_init[]` and is on line 2,046\.
    Because it’s quite large, I’ve removed some lines from the middle:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 的内置函数在 `function.c` 文件中定义。为了开始理解这个文件如何工作，可以查看 GNU `make` 知道的函数表。这个表叫做
    `function_table_init[]`，位于第 2,046 行。由于这个表比较大，我删除了其中的一些行：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Each line defines a single function and consists of five pieces of information:
    the name of the function, the minimum number of arguments that the function must
    have, the maximum number of arguments (specifying a maximum of zero with a non-zero
    minimum means that the function can have an unlimited number of arguments), whether
    the arguments should be expanded, and the name of the C function that actually
    performs the function.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都定义了一个单独的函数，并包含五个信息项：函数的名称、函数必须具有的最小参数数量、最大参数数量（指定最小值非零且最大值为零，意味着该函数可以有无限数量的参数）、参数是否需要展开，以及实际执行函数的
    C 函数的名称。
- en: 'For example, here’s the definition of the `findstring` function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是 `findstring` 函数的定义：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`findstring` has a minimum of two arguments and a maximum of two, and the arguments
    should be expanded before calling the C function `func_findstring`. `func_findstring`
    (in `function.c` at line 819) does the work:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`findstring` 至少需要两个参数，最多两个参数，并且在调用 C 函数`func_findstring`之前，参数应当被展开。`func_findstring`（位于
    `function.c` 文件的第 819 行）完成实际的工作：'
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The C functions that implement GNU `make` built-in functions have three arguments:
    `o` (a pointer to a buffer into which output of the function should be written),
    `argv` (the arguments of the function as a null-terminated array of strings),
    and `funcname` (a string containing the name of the function; most functions don’t
    need this, but it can be helpful if one C routine handles more than one GNU `make`
    function).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 GNU `make` 内置函数的 C 函数有三个参数：`o`（指向一个缓冲区的指针，函数的输出将写入该缓冲区），`argv`（函数的参数，作为一个以
    null 结尾的字符串数组），以及 `funcname`（一个包含函数名称的字符串；大多数函数不需要这个，但如果一个 C 函数处理多个 GNU `make`
    函数时，它会很有用）。
- en: You can see that `func_findstring` just uses the standard C library `strstr`
    function to find the presence of its second argument (in `argv[1]`) in its first
    (in `argv[0]`).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`func_findstring` 仅使用标准 C 库中的 `strstr` 函数来查找第二个参数（在 `argv[1]` 中）是否出现在第一个参数中（在
    `argv[0]` 中）。
- en: '`func_findstring` uses a handy GNU `make` C function called `variable_buffer_
    output` (defined in `expand.c` at line 57). `variable_buffer_output` copies a
    string into the output buffer `o` of a GNU `make` function. The first argument
    should be the output buffer, the second the string to copy, and the last the amount
    of the string to copy.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`func_findstring` 使用了一个方便的 GNU `make` C 函数，名为 `variable_buffer_output`（定义在
    `expand.c` 文件的第 57 行）。`variable_buffer_output` 将一个字符串复制到 GNU `make` 函数的输出缓冲区 `o`
    中。第一个参数应该是输出缓冲区，第二个是要复制的字符串，最后一个是要复制的字符串的长度。'
- en: '`func_findstring` either copies all of its first argument (if the `strstr`
    was successful) or leaves `o` untouched (and hence, empty, because it is initialized
    to an empty string before `func_findstring` is called).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`func_findstring` 要么将第一个参数的全部内容复制到输出缓冲区 `o` 中（如果 `strstr` 成功），要么不改变 `o`（因此，`o`
    将保持为空，因为它在调用 `func_findstring` 之前被初始化为空字符串）。'
- en: With that, we have enough information to start making our own GNU `make` function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们就有足够的基础开始编写我们自己的 GNU `make` 函数了。
- en: Reverse a String
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转一个字符串
- en: There’s no easy way to reverse a string in GNU `make`, but it’s easy to write
    a C function that does and insert it into GNU `make`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GNU `make` 中没有直接的方法来反转一个字符串，但编写一个 C 函数来实现这一点并将其插入到 GNU `make` 中是很容易的。
- en: First, we’ll add the definition of `reverse` to the list of functions that GNU
    `make` knows about. `reverse` will have a single argument that must be expanded
    and will call a C function named `func_reverse`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将把 `reverse` 的定义添加到 GNU `make` 知道的函数列表中。`reverse` 将有一个必须展开的单一参数，并且将调用一个名为
    `func_reverse` 的 C 函数。
- en: 'Here’s the entry to add to the `function_table_init[]`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是需要添加到 `function_table_init[]` 中的条目：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we can define `func_reverse`, which reverses the string in `argv[0]` by
    swapping characters and then updates the output buffer `o`, as shown in [Example 5-4](ch05.html#defining_a_gnu_make_function_using_c
    "Example 5-4. Defining a GNU make function using C"):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义`func_reverse`，它通过交换字符来反转`argv[0]`中的字符串，并更新输出缓冲区`o`，如[示例5-4](ch05.html#defining_a_gnu_make_function_using_c
    "示例5-4. 使用C定义GNU make函数")所示：
- en: Example 5-4. Defining a GNU make function using C
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5-4. 使用C定义GNU make函数
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This function works by walking from the start and end of the string at the same
    time and swapping pairs of characters until `left` and `right` meet in the middle.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通过从字符串的起始和结尾同时遍历，并交换字符对，直到`left`和`right`在中间相遇。
- en: 'To test it, we can write a little makefile that tries three possibilities:
    an empty string, a string with even length, and a string with odd length, all
    calling the new built-in function `reverse`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，我们可以编写一个简单的makefile，尝试三种情况：一个空字符串、一个长度为偶数的字符串，以及一个长度为奇数的字符串，所有这些都调用新的内建函数`reverse`：
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output shows that it works correctly:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示它正常工作：
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Writing in C gives you access to the full range of C library functions; therefore,
    the GNU `make` built-in functions you can create are limited only by your imagination.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C语言编写可以访问完整的C标准库函数；因此，你可以创建的GNU `make`内建函数仅受你的想象力限制。
- en: GNU make 4.0 Loadable Objects
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GNU make 4.0 可加载对象
- en: Adding the `reverse` function to GNU `make` was fairly complex because we had
    to modify GNU `make`’s source code. But using GNU `make` 4.0 or later, you can
    add C functions to GNU `make` without changing the source code. GNU `make` 4.0
    added a `load` directive you can use to load a shared object containing GNU `make`
    functions written in C.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将`reverse`函数添加到GNU `make`中相当复杂，因为我们需要修改GNU `make`的源代码。但是使用GNU `make` 4.0或更高版本，你可以在不更改源代码的情况下将C函数添加到GNU
    `make`中。GNU `make` 4.0添加了一个`load`指令，允许你加载一个包含用C语言编写的GNU `make`函数的共享对象。
- en: 'You can turn the `reverse` function from [Example 5-4](ch05.html#defining_a_gnu_make_function_using_c
    "Example 5-4. Defining a GNU make function using C") into a loadable GNU `make`
    object by saving it in a file called `reverse.c` with some small modifications.
    Here’s the complete `reverse.c` file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将[示例5-4](ch05.html#defining_a_gnu_make_function_using_c "示例5-4. 使用C定义GNU
    make函数")中的`reverse`函数转换为可加载的GNU `make`对象，只需将其保存在名为`reverse.c`的文件中，并做一些小修改。下面是完整的`reverse.c`文件：
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `reverse` function is added to GNU `make` by the call to `gmk_add_function`
    at ➌. The function `reverse` is then available to use just like any other GNU
    `make` built-in function. The actual reversing of a string is handled by `func_reverse`,
    which calls a GNU `make` API function `gmk_alloc` to allocate space for the new
    string at ➋.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在➌处调用`gmk_add_function`，将`reverse`函数添加到GNU `make`中。然后，`reverse`函数就可以像任何其他GNU
    `make`内建函数一样使用。字符串的实际反转由`func_reverse`处理，它在➋处调用GNU `make`的API函数`gmk_alloc`为新字符串分配空间。
- en: At ➊ is a special, unused variable called `plugin_is_GPL_compatible`, which
    is required in any loadable module.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处是一个特殊的、未使用的变量`plugin_is_GPL_compatible`，它在任何可加载模块中都是必需的。
- en: 'To use the new `reverse` function, you need to compile the `reverse.c` file
    into a `.so` file and load it into GNU `make`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用新的`reverse`函数，你需要将`reverse.c`文件编译成`.so`文件并加载到GNU `make`中：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `load` directive loads the `.so`, and the rule at ➍ builds the `.so` from
    the `.c` file. If the `.so` file is missing when GNU `make` encounters the `load`
    directive, GNU `make` builds it (using the rule) and then restarts, parsing the
    makefile from the beginning.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`load`指令加载`.so`文件，规则➍从`.c`文件构建`.so`文件。如果在GNU `make`遇到`load`指令时`.so`文件缺失，GNU
    `make`会根据规则构建该文件并重新启动，从头解析makefile。'
- en: 'Once loaded, you can use `reverse` as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 加载后，你可以如下使用`reverse`：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that it is not necessary to use `$(call)`. The `reverse` function is
    just like any other built-in GNU `make` function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用`$(call)`并非必要。`reverse`函数就像任何其他内建的GNU `make`函数一样。
- en: Using Guile in GNU make
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GNU make中使用Guile
- en: GNU `make` 4.0 introduced a big change with the `$(guile)` function. This function’s
    argument is sent to the built-in Guile language and is executed by it. (GNU Guile
    is an implementation of Scheme, which itself is Lisp.) `$(guile)`’s return value
    is the return value from the Guile code that was executed after converting to
    a type that GNU `make` recognizes. Strictly speaking, GNU `make` doesn’t have
    data types (everything is a string), although it sometimes treats strings as other
    types (for example, a string with spaces in it is treated as a list by many functions).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: GNU `make` 4.0引入了一个重要的变化，即`$(guile)`函数。这个函数的参数被发送到内置的Guile语言并由它执行。（GNU Guile是Scheme的一个实现，而Scheme本身就是Lisp。）`$(guile)`的返回值是执行后的Guile代码返回的值，经过转换成GNU
    `make`能识别的类型。严格来说，GNU `make`没有数据类型（所有东西都是字符串），尽管它有时会把字符串当作其他类型（例如，包含空格的字符串在许多函数中会被当作列表）。
- en: 'Here’s how to reverse a list using `$(guile)` and the Guile function `reverse`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用`$(guile)`和Guile函数`reverse`反转一个列表的方法：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When run, this makefile will output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，这个Makefile将输出：
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It’s worth diving into ➊ to see what happens, because there are a couple of
    subtle points. The argument to `$(guile)` is first expanded by GNU `make`, so
    ➊ becomes:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 值得深入研究➊，看看会发生什么，因为有几个微妙的细节。`$(guile)`的参数首先由GNU `make`展开，所以➊变成了：
- en: '[PRE52]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'So the Guile code to be executed is `(reverse ''(liesl friedrich louisa kurt
    brigitta marta gretl))`. The GNU `make` variable `$(NAMES)` has been expanded
    into the list of names and is turned into a Guile list by wrapping it in `''(...)`.
    Because Guile has data types, you must use the correct syntax: in this case, you
    need to surround a list with parentheses and quote it with a single quote to tell
    Guile that this is a literal list (not a function invocation).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所以要执行的Guile代码是`(reverse '(liesl friedrich louisa kurt brigitta marta gretl))`。GNU
    `make`变量`$(NAMES)`已经被扩展成名字列表，并通过用`'(...)`将其包装变成了Guile列表。因为Guile有数据类型，你必须使用正确的语法：在这种情况下，你需要用圆括号括住一个列表，并用单引号引起来，告诉Guile这是一个字面意义的列表（而不是函数调用）。
- en: The Guile `reverse` function reverses this list and returns the reversed list.
    GNU `make` then converts the Guile list into a GNU `make` list (a string with
    spaces in it). Finally, `$(info)` displays the list.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Guile的`reverse`函数反转这个列表并返回反转后的列表。GNU `make`然后将Guile列表转换为GNU `make`列表（一个包含空格的字符串）。最后，`$(info)`显示该列表。
- en: 'Because Guile is a rich language, it’s possible to create more complex functions.
    Here, for example, is a GNU `make` function called `file-exists` that uses the
    Guile `access?` function to determine whether a file exists. It returns a Boolean
    value after converting the Guile `#t`/`#f` (true/false) value returned by `access?`
    to a GNU `make` Boolean (a non-empty string for true or an empty string for false):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Guile是一种功能强大的语言，因此可以创建更复杂的函数。例如，这里有一个名为`file-exists`的GNU `make`函数，它使用Guile的`access?`函数来判断一个文件是否存在。它返回一个布尔值，将Guile的`#t`/`#f`（真/假）值通过转换成GNU
    `make`的布尔值（非空字符串表示真，空字符串表示假）：
- en: '[PRE53]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice the double quotes around the parameter `$1`. Guile needs to know that
    the filename is actually a string.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意参数`$1`周围的双引号。Guile需要知道文件名实际上是一个字符串。
- en: 'You can build a more complex example by using the Guile `http-get` function
    to download data from the Web inside a makefile:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在Makefile中使用Guile的`http-get`函数从网络下载数据来构建一个更复杂的例子：
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, `http-get` gets the current UTC time from a web service that returns the
    time as a string in the body of the HTTP response.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`http-get`从一个Web服务中获取当前的UTC时间，该服务以字符串形式在HTTP响应的正文中返回时间。
- en: The `utc-time` variable contains the current UTC time. It works by retrieving
    the time from *[http://www.timeapi.org/utc/now/](http://www.timeapi.org/utc/now/)*
    using the Guile code stored in the `get-url` variable. The Guile code in `get-url`
    uses the `http-get` function to retrieve the header and body of a web page, and
    returns just the body.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`utc-time`变量包含当前的UTC时间。它通过使用存储在`get-url`变量中的Guile代码从*[http://www.timeapi.org/utc/now/](http://www.timeapi.org/utc/now/)*获取时间。`get-url`中的Guile代码使用`http-get`函数来获取网页的头部和正文，并只返回正文。'
- en: 'Notice how you can use the GNU `make define` directive to create large blocks
    of Guile code. If the Guile code becomes unwieldy, do this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何使用GNU `make define`指令来创建大量的Guile代码块。如果Guile代码变得庞大，可以这样做：
- en: '`$(guile (load "myfunctions.scm"))`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(guile (load "myfunctions.scm"))`'
- en: This is how you can store the Guile code in a file and load it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你如何将Guile代码存储在文件中并加载它。
- en: Self-Documenting Makefiles
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自文档化的Makefile
- en: Upon encountering a new makefile, many ask “What does this makefile do?” or
    “What are the important targets I need to know about?” For any sizable makefile,
    answering those questions can be difficult. In this section, I present a simple
    GNU `make` trick that you can use to make a makefile self-documenting and print
    out help automatically.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到一个新的 makefile，许多人会问：“这个 makefile 做什么？”或者“我需要了解哪些重要的目标？”对于任何规模较大的 makefile，回答这些问题可能会很困难。在本节中，我将介绍一个简单的
    GNU `make` 技巧，你可以使用它使 makefile 自动生成文档，并自动输出帮助信息。
- en: 'Before I show you how it works, here’s a small example. This makefile has three
    targets that the creator thinks you need to know about: `all`, `clean`, and `package`.
    They’ve documented the makefile by including some extra information with each
    target:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我向你展示它是如何工作的之前，这里有一个小示例。这个 makefile 有三个目标，创建者认为你需要了解：`all`、`clean` 和 `package`。他们通过为每个目标附加一些额外信息来记录这个
    makefile：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For each of the targets needing documentation, the makefile maintainer has
    added a call to a user-defined function `print-help` with two arguments: the name
    of the target and a brief description of that target. The call to `print-help`
    doesn’t interfere with the definition of the prerequisites of the rule because
    it always returns (or is expanded to) an empty string.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个需要文档化的目标，makefile 维护者添加了对用户自定义函数 `print-help` 的调用，传递了两个参数：目标的名称和该目标的简短描述。对
    `print-help` 的调用不会干扰规则的前提条件定义，因为它始终返回（或扩展为）空字符串。
- en: 'Typing `make` with this makefile outputs:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `make` 和这个 makefile 会输出：
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'and typing `make help` reveals:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `make help` 会显示：
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`make` automatically prints the names of the interesting targets and includes
    an explanation of what they do, as well as the line number of the makefile where
    you can find more information about the commands for that target.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 会自动打印出有趣的目标名称，并包括关于它们所做的事情的解释，以及 makefile 中你可以找到更多目标相关命令的信息所在的行号。'
- en: 'The interesting work is done by the included makefile `help-system.mak`. `help-system.mak`
    first defines the user-defined function `print-help`. `print-help` is the function
    called for each target that needs documenting:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的工作是由包含的 makefile `help-system.mak` 完成的。`help-system.mak` 首先定义了用户自定义函数 `print-help`。`print-help`
    是为每个需要文档化的目标调用的函数：
- en: '[PRE58]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`print-help` uses GNU `make`’s `$(warning)` function to output the appropriate
    message based on the two parameters passed to it. The first parameter (stored
    in `$1`) is the name of the target, and the second (in `$2`) is the help text;
    they are separated by `--`. `$(warning)` writes a message to the console and returns
    an empty string; hence, you can safely use `print-help` in the prerequisite list
    of a rule.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`print-help` 使用 GNU `make` 的 `$(warning)` 函数，根据传递给它的两个参数输出相应的消息。第一个参数（存储在 `$1`
    中）是目标的名称，第二个参数（在 `$2` 中）是帮助文本；它们通过 `--` 分隔。`$(warning)` 将消息写入控制台并返回一个空字符串；因此，你可以安全地在规则的前提条件列表中使用
    `print-help`。'
- en: '`print-help` decides whether it needs to print any message by examining the
    `need-help` variable, which will be the string `help` if the user specified `help`
    on the `make` command line, or empty if they did not. In either case, the expanded
    value of `print-help` is an empty string. `need-help` determines whether the user
    entered `help` on the command line by examining the built-in variable `MAKECMDGOALS`,
    which is a space-separated list of all the goals specified on the `make` command
    line. `need-help` filters out any goal that doesn’t match the text `help` and,
    hence, is the string `help` if `help` was in `MAKECMDGOALS` or empty otherwise.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`print-help` 通过检查 `need-help` 变量来决定是否需要打印任何消息。如果用户在 `make` 命令行中指定了 `help`，则
    `need-help` 变量的值为字符串 `help`，否则为空字符串。在任何情况下，`print-help` 的扩展值都是空字符串。`need-help`
    通过检查内置变量 `MAKECMDGOALS` 来判断用户是否在命令行中输入了 `help`，`MAKECMDGOALS` 是一个空格分隔的目标列表，列出了命令行中指定的所有目标。`need-help`
    会过滤掉任何不匹配文本 `help` 的目标，因此，如果 `MAKECMDGOALS` 中包含 `help`，`need-help` 为字符串 `help`，否则为空。'
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The definition of `need-help` and `print-help` are all we need to have `make`
    print out help on each target when run with `help` on the command line. The rest
    of `help-system.mak` prints the message `Type 'make help' to get help` when the
    user simply types `make.`
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`need-help` 和 `print-help` 的定义是我们所需要的，当命令行中输入 `help` 时，`make` 会打印出每个目标的帮助信息。`help-system.mak`
    的其余部分会在用户只输入 `make` 时打印出消息 `Type ''make help'' to get help`。'
- en: 'It defines a default goal for the makefile called `help`, which will be run
    if no other goal is specified on the command line:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 它为 makefile 定义了一个默认目标，名为 `help`，如果命令行中没有指定其他目标，则会运行此目标：
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This rule will output nothing if the user has asked for `help` (determined by
    the `need-help` variable), but if not, it will output the message containing the
    name of the `make` program (stored in `$(MAKE)`) followed by the appropriate parameter
    to load the makefile. This last part is subtle.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户请求了`help`（通过`need-help`变量确定），此规则将不输出任何内容；否则，它将输出包含`make`程序名称（存储在`$(MAKE)`中）以及加载makefile所需的适当参数的消息。这最后一部分是微妙的。
- en: If the makefile that included `help-system.mak` was simply called `Makefile`
    (or `makefile` or `GNUmakefile`), then GNU `make` would look for it automatically,
    and it’s enough to type `make help` to get help. If it was not, the actual makefile
    name needs to be specified with the `-f` parameter.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含`help-system.mak`的makefile文件名仅为`Makefile`（或`makefile`或`GNUmakefile`），那么GNU
    `make`会自动查找它，输入`make help`即可获得帮助。如果不是这种情况，则需要使用`-f`参数指定实际的makefile文件名。
- en: 'This rule uses a variable called `dash-f` to output the correct command line.
    `dash-f` contains nothing if one of the default makefile names was used, or it
    contains `-f` followed by the correct makefile name:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则使用名为`dash-f`的变量来输出正确的命令行。如果使用了默认的makefile文件名，则`dash-f`不包含任何内容；否则，它包含`-f`，后跟正确的makefile文件名：
- en: '[PRE61]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`dash-f` looks at the value of a variable called `parent-makefile`, which contains
    the name of the makefile that included `help-system.mak`. If it’s not a standard
    name, `dash-f` returns the name of the parent makefile with the `-f` option.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`dash-f`查看名为`parent-makefile`的变量的值，该变量包含了包含`help-system.mak`的makefile的文件名。如果它不是标准名称，`dash-f`会返回带有`-f`选项的父makefile文件名。'
- en: '`parent-makefile` is determined by looking at the `MAKEFILE_LIST`. `MAKEFILE_LIST`
    is a list of all the makefiles read so far in order. `help-system.mak` first determines
    its own name:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`parent-makefile`是通过查看`MAKEFILE_LIST`来确定的。`MAKEFILE_LIST`是一个按顺序列出已读取的所有makefile的列表。`help-system.mak`首先确定它自己的文件名：'
- en: '[PRE62]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then it gets the list of all the other makefiles included by removing `this-makefile`
    (that is, `help-system.mak`) from the `MAKEFILE_LIST`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它通过从`MAKEFILE_LIST`中移除`this-makefile`（即`help-system.mak`）来获取所有其他包含的makefile的列表：
- en: '[PRE63]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The final element of `other-makefiles` will be the parent of `help-system.mak`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`other-makefiles`的最后一个元素将是`help-system.mak`的父级：'
- en: '[PRE64]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You use the `last-element` function to get the last element of a spaceseparated
    list:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`last-element`函数获取以空格分隔的列表中的最后一个元素：
- en: '[PRE65]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`last-element` returns the last word in a list by getting the word count using
    `$(words)` and returning the word referenced by it. Because GNU `make`’s lists
    are counted from position 1, `$(words LIST)` is the index of the last element.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`last-element`通过使用`$(words)`获取单词计数并返回相应的单词，来返回列表中的最后一个单词。由于GNU `make`的列表是从位置1开始计数的，`$(words
    LIST)`表示最后一个元素的索引。'
- en: Documenting Makefiles with print-help
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`print-help`文档化Makefiles
- en: Documenting makefiles with `print-help` is easy. Just add the relevant `$(call
    print-help,target,description)` to the prerequisite list for each target you want
    to document. If you add the call right next to the commands that are used for
    the target, the help system not only prints help but also automatically points
    the user to the place in the makefile to look for more information.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`print-help`文档化makefile非常简单。只需将相关的`$(call print-help,target,description)`添加到每个要文档化的目标的前置条件列表中。如果将调用添加到用于该目标的命令旁边，帮助系统不仅会打印帮助，还会自动将用户指向makefile中查看更多信息的地方。
- en: It’s also easy to keep the documentation up to date because the description
    of a target is actually part of the definition of the target, not in a separate
    help list.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目标的描述实际上是目标定义的一部分，而不是单独的帮助列表，因此保持文档的更新也很容易。
- en: The Complete help-system.mak
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的help-system.mak
- en: 'Finally, here’s the full `help_system.mak` file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是完整的`help_system.mak`文件：
- en: '[PRE66]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Just `include help-system.mak` to start using this system in makefiles that
    could use documentation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 只需`include help-system.mak`，即可在需要文档的makefile中开始使用该系统。
- en: 'In [Chapter 6](ch06.html "Chapter 6. The GNU Make Standard Library"), we’ll
    look at a helpful resource, the GMSL project. Creating GNU `make` built-in functions
    is easy, but it does cause a maintenance problem: the next time GNU `make` is
    updated, we’ll need to port our changes to the new version. If we can do what
    we need with GNU `make` built-ins without modifying the source, then makefiles
    will be more portable. The GMSL provides lots of additional functionality without
    modifying the GNU `make` source.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章. GNU Make标准库")中，我们将介绍一个有用的资源——GMSL项目。创建GNU `make`内置函数很简单，但它确实带来了一个维护问题：下一次更新GNU
    `make`时，我们需要将更改移植到新版本。如果我们能够在不修改源代码的情况下使用GNU `make`内置功能完成需求，那么makefile将会更具可移植性。GMSL提供了大量额外的功能，而无需修改GNU
    `make`的源代码。
