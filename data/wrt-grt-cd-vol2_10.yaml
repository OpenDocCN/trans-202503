- en: '**10**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10**'
- en: '**STRING DATA TYPES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串数据类型**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: After integers, character strings are probably the most commonly used data type
    in modern programs; after arrays, they’re the second most commonly used composite
    data type. A string is a sequence of objects. Most often, the term *string* describes
    a sequence of character values, but it’s also possible to have strings of integers,
    real values, Boolean values, and so on (for example, I’ve already discussed bit
    strings in this book and in *WGC1*). In this chapter, though, we’ll stick to character
    strings.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在整数之后，字符字符串可能是现代程序中最常用的数据类型；仅次于数组，它们是第二常用的复合数据类型。字符串是对象的序列。通常，*字符串*这一术语描述的是字符值的序列，但也有可能存在由整数、实数、布尔值等组成的字符串（例如，我已经在本书和*WGC1*中讨论过位字符串）。不过在本章中，我们将专注于字符字符串。
- en: 'In general, a character string possesses two main attributes: a *length* and
    some *character data*. Character strings can also possess other attributes, such
    as the *maximum length* allowable for that particular variable or a *reference
    count* specifying how many different string variables refer to the same character
    string. We’ll look at these attributes and how programs can use them, as well
    as the various string formats and possible string operations. Specifically, this
    chapter discusses the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，字符字符串具有两个主要属性：*长度*和一些*字符数据*。字符字符串还可以具有其他属性，例如该特定变量的*最大长度*或*引用计数*，指示有多少不同的字符串变量引用相同的字符字符串。我们将研究这些属性及其程序如何使用它们，以及各种字符串格式和可能的字符串操作。具体而言，本章讨论以下主题：
- en: Character string formats including zero-terminated strings, length-prefixed
    strings, HLA strings, and 7-bit strings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串格式，包括零终止字符串、长度前缀字符串、HLA字符串和7位字符串
- en: When to use (and when not to use) standard library string processing functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用（以及何时不使用）标准库字符串处理函数
- en: Static, pseudo-dynamic, and dynamic strings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态、伪动态和动态字符串
- en: Reference counting and strings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用计数与字符串
- en: Unicode and UTF-8/UTF-16/UTF-32 character data in strings
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串中的Unicode和UTF-8/UTF-16/UTF-32字符数据
- en: String manipulation consumes a fair amount of CPU time in today’s applications.
    Therefore, it’s important to understand how programming languages represent and
    operate on character strings if you want to write code that manipulates strings
    efficiently. This chapter provides the basic information you’ll need to do so.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串操作在当今的应用程序中消耗了相当多的CPU时间。因此，如果你想编写高效操作字符串的代码，理解编程语言如何表示和操作字符字符串是非常重要的。本章提供了你所需要的基本信息。
- en: '**10.1 Character String Formats**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.1 字符串格式**'
- en: Different languages use different data structures to represent strings. Some
    string formats use less memory, others allow faster processing, some are more
    convenient to use, some are easy for compiler writers to implement, and some provide
    additional functionality for the programmer and operating system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编程语言使用不同的数据结构来表示字符串。一些字符串格式使用较少的内存，其他格式允许更快的处理，一些格式更方便使用，一些对编译器开发者来说更易于实现，而一些则为程序员和操作系统提供了额外的功能。
- en: 'Although their internal representations vary, all string formats have one thing
    in common: the character data. This is a sequence of 0 or more bytes (the term
    *sequence* implies that the order of the characters is important). How a program
    references this sequence of characters varies by format. In some string formats,
    the sequence of characters is kept in an array; in other string formats the program
    maintains a pointer to the sequence of characters elsewhere in memory.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们的内部表示方式各不相同，但所有字符串格式有一个共同点：字符数据。这是一系列0个或多个字节（*序列*一词意味着字符的顺序是重要的）。程序如何引用这组字符的方式因格式而异。在某些字符串格式中，字符序列存储在数组中；而在其他字符串格式中，程序保持指向内存中其他位置字符序列的指针。
- en: All character string formats share the length attribute; however, they use several
    different ways to represent the length of a string. Some string formats use a
    special *sentinel character* to mark the end of the string. Other formats precede
    the character data with a numeric value that specifies the number of characters
    in the sequence. Still others encode the length as a numeric value in a variable
    that is not connected to the character sequence. Some character string formats
    use a special bit (set or cleared) to mark the end of a string. Finally, some
    string formats use a combination of these methods. How a particular string format
    determines the length of a string can have a big impact on the performance of
    the functions that manipulate those strings. It can also affect how much extra
    storage is needed to represent string data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字符字符串格式都共享长度属性；然而，它们使用多种不同的方式来表示字符串的长度。有些字符串格式使用一个特殊的*哨兵字符*来标记字符串的结尾。其他格式则在字符数据之前加上一个指定字符序列长度的数值。还有一些将长度编码为一个与字符序列无关的变量中的数值。某些字符字符串格式使用一个特殊的位（设置或清除）来标记字符串的结尾。最后，某些字符串格式结合了这些方法。一个特定字符串格式如何确定字符串的长度，可能会对操作这些字符串的函数性能产生较大影响，也会影响表示字符串数据所需的额外存储空间。
- en: Some string formats provide additional attributes, such as a maximum length
    and reference count values, that certain string functions can use to operate on
    string data more efficiently. These extra attributes are optional insofar as they
    aren’t strictly necessary to define a string value. They do, however, allow string
    manipulation functions to provide certain tests for correctness or to work more
    efficiently than they would otherwise.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字符串格式提供附加的属性，如最大长度和引用计数值，这些属性可以让某些字符串函数更高效地操作字符串数据。这些附加属性是可选的，因为它们并不是定义字符串值所必须的。然而，它们确实允许字符串操作函数进行正确性检查或比其他方法更高效地工作。
- en: To help you better understand the reasoning behind the design of character strings,
    let’s look at some common string representations popularized by various languages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你更好地理解字符字符串设计背后的原因，我们来看一下由各种语言推广的几种常见字符串表示形式。
- en: '**10.1.1 Zero-Terminated Strings**'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.1.1 零终止字符串**'
- en: Without question, *zero-terminated strings* (see [Figure 10-1](ch10.xhtml#ch10fig1))
    are probably the most common string representation in use today, because this
    is the native string format for C, C++, and several other languages. In addition,
    you’ll find zero-terminated strings used in programs written in languages that
    don’t have a specific native string format, such as assembly language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，*零终止字符串*（见[图10-1](ch10.xhtml#ch10fig1)）可能是目前使用最广泛的字符串表示形式，因为这是C、C++及其他几种语言的本地字符串格式。此外，你还会发现零终止字符串用于一些没有特定本地字符串格式的语言编写的程序中，例如汇编语言。
- en: '![Image](../images/10fig01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig01.jpg)'
- en: '*Figure 10-1: Zero-terminated string format*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：零终止字符串格式*'
- en: 'A zero-terminated ASCII string, also called an *ASCIIz* string or a *zstring*,
    is a sequence containing zero or more 8-bit character codes and ending with a
    byte containing `0`—or, in the case of Unicode (UTF-16), a sequence containing
    zero or more 16-bit character codes and ending with a 16-bit word containing `0`.
    For UTF-32 strings, each item in the string is 32 bits (4 bytes) wide, ending
    with a 32-bit `0` value. For example, in C/C++, the ASCIIz string `"abc"` requires
    4 bytes: 1 byte for each of the three characters `a`, `b`, and `c`, followed by
    a `0` byte.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 零终止的ASCII字符串，也称为*ASCIIz*字符串或*zstring*，是包含零个或多个8位字符编码，并以包含`0`的字节结尾的序列——或者在Unicode（UTF-16）的情况下，是一个包含零个或多个16位字符编码并以一个包含`0`的16位字结尾的序列。对于UTF-32字符串，字符串中的每个项都是32位（4字节）宽，并以32位`0`值结尾。例如，在C/C++中，ASCIIz字符串`"abc"`需要4个字节：每个字符`a`、`b`、`c`各占1字节，后跟一个`0`字节。
- en: 'Zero-terminated strings have a few advantages over other string formats:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 零终止字符串相较于其他字符串格式有一些优势：
- en: Zero-terminated strings can represent strings of any practical length with only
    1 byte of overhead (2 bytes in UTF-16, 4 in UTF-32).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零终止字符串可以表示任何实际长度的字符串，且仅需1字节的开销（在UTF-16中为2字节，在UTF-32中为4字节）。
- en: Given the popularity of the C/C++ programming languages, high-performance string
    processing libraries are available that work well with zero-terminated strings.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于C/C++编程语言的流行，现有许多高性能的字符串处理库，它们能够很好地处理零终止字符串。
- en: Zero-terminated strings are easy to implement. Indeed, except for dealing with
    string literal constants, the C/C++ programming languages don’t provide native
    string support. As far as those languages are concerned, strings are just arrays
    of characters. That’s probably why C’s designers chose this format in the first
    place—so they wouldn’t have to clutter up the language with string operators.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零终止字符串易于实现。实际上，除了处理字符串字面常量外，C/C++ 编程语言并不提供本地的字符串支持。就这些语言而言，字符串只是字符数组。这也可能是 C
    的设计者最初选择这种格式的原因——这样他们就不需要用字符串操作符来混乱语言的设计。
- en: You can easily represent zero-terminated strings in any language that provides
    the ability to create an array of characters.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在任何提供创建字符数组能力的语言中轻松表示零终止字符串。
- en: 'However, zero-terminated strings also have disadvantages that mean they are
    not always the best choice for representing character string data:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，零终止字符串也有一些缺点，这意味着它们并不总是表示字符字符串数据的最佳选择：
- en: String functions often aren’t very efficient when operating on zero-terminated
    strings. Many string operations need to know the length of the string before working
    on the string data. The only reasonable way to compute the length of a zero-terminated
    string is to scan the string from the beginning to the end. The longer your strings
    are, the slower this function runs, so the zero-terminated string format isn’t
    the best choice if you need to process long strings.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当操作零终止字符串时，字符串函数通常效率较低。许多字符串操作需要在处理字符串数据之前知道字符串的长度。计算零终止字符串的长度的唯一合理方法是从头到尾扫描字符串。你的字符串越长，这个函数运行得就越慢，因此，如果你需要处理长字符串，零终止字符串格式不是最佳选择。
- en: Although it’s a minor problem, you cannot easily represent the character code
    `0` (such as the NUL character in ASCII and Unicode) with the zero-terminated
    string format.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管这是一个小问题，但你无法轻松地使用零终止字符串格式表示字符代码`0`（例如 ASCII 和 Unicode 中的 NUL 字符）。
- en: Zero-terminated strings don’t contain any information that tells you how long
    the string can grow beyond the terminating `0` byte. Therefore, some string functions,
    like concatenation, can only extend the length of an existing string variable
    and check for overflow if the caller explicitly passes the maximum length.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零终止字符串不包含任何信息，无法告诉你字符串可以扩展到终止 `0` 字节之后的长度。因此，一些字符串函数（如拼接）只能扩展现有字符串变量的长度，并且只有在调用者显式传递最大长度时才会检查溢出。
- en: 'As noted, one nice feature of zero-terminated strings is that you can easily
    implement them using pointers and arrays of characters. Consider the following
    C/C++ statement:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，零终止字符串的一个优点是你可以通过使用指针和字符数组轻松实现它们。考虑以下 C/C++ 语句：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s the code the Borland C++ v5.0 compiler generates for this statement:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Borland C++ v5.0 编译器为此语句生成的代码：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Borland C++ compiler simply emits the literal string `"Hello World"` to
    the global data segment in memory and then loads the `someCharPtrVar` variable
    with the address of the first character of this string literal in the data segment.
    From that point forward, the program can refer to the string data indirectly via
    this pointer. This is a very convenient scheme from the compiler writer’s point
    of view.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Borland C++ 编译器将字面字符串 `"Hello World"` 直接输出到内存的全局数据段，然后将 `someCharPtrVar` 变量加载为该字符串字面量在数据段中的第一个字符的地址。从那时起，程序可以通过这个指针间接引用字符串数据。从编译器编写者的角度来看，这是一种非常方便的方案。
- en: 'When using zero-terminated strings in a language like C, C++, Python, or any
    of a dozen other languages that have adopted C’s string format, you can improve
    the performance of your string-handling code sequences by keeping a few points
    in mind:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用像 C、C++、Python 或其他采用 C 字符串格式的语言时，你可以通过记住以下几点来提高字符串处理代码序列的性能：
- en: Try to use the language’s runtime library functions rather than attempting to
    code comparable functions yourself. Most compiler vendors provide highly optimized
    versions of their string functions that will probably run many times faster than
    code you would write yourself.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用语言的运行时库函数，而不是尝试自己编写类似的函数。大多数编译器供应商提供了高度优化的字符串函数版本，这些函数的运行速度可能比你自己编写的代码快得多。
- en: Once you’ve computed the length of a string by scanning the entire string, save
    that length for future use (rather than recomputing it every time you need it).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦通过扫描整个字符串计算了字符串的长度，应该将该长度保存以供将来使用（而不是每次需要时重新计算它）。
- en: Avoid copying string data from one string variable to another. Doing so is one
    of the more expensive operations (after length computation) in applications using
    zero-terminated strings.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将字符串数据从一个字符串变量复制到另一个。这样做是使用零终止字符串的应用程序中最昂贵的操作之一（仅次于长度计算）。
- en: The following subsections discuss each point in turn.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将依次讨论每个要点。
- en: '**10.1.1.1 When to Use C Standard Library String Functions**'
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.1.1.1 何时使用 C 标准库字符串函数**'
- en: 'Some programmers are skeptical that someone else could write faster or higher-quality
    code. But when it comes to standard library functions, you should avoid the temptation
    to replace them with code of your own choosing. Unless the library code you’re
    considering is especially bad, chances are you won’t come close to duplicating
    its efficiency. This is especially true for string functions that handle zero-terminated
    strings in languages like C and C++. There are three main reasons why standard
    libraries generally perform better than code you write yourself: experience, maturity,
    and inline substitution.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员怀疑别人能写出更快或更高质量的代码。但当涉及到标准库函数时，你应该避免用自己选择的代码替代它们。除非你考虑的库代码特别差，否则你很难接近它的效率。这一点在处理像
    C 和 C++ 中的零终止字符串的字符串函数时尤其如此。标准库通常比你自己编写的代码表现得更好，有三个主要原因：经验、成熟度和内联替换。
- en: 'The typical programmer who writes compiler runtime libraries has a lot of experience
    with string-handling functions. Although in the past new compilers were often
    accompanied by notoriously inefficient libraries, over time compiler programmers
    have gained considerable experience writing those library routines and have figured
    out how to deliver well-written string-handling functions. Unless you’ve spent
    considerable time writing those same types of routines, it’s highly unlikely that
    your code will perform as well as theirs. Many compiler vendors purchase their
    standard library code from a third party that specializes in writing library code,
    so now, even if the compiler you’re using is fairly new, it may have a good library.
    Few commercial compilers today contain horribly inefficient library code. For
    the most part, only research or “hobby” compilers contain library code so bad
    that you can easily write something better. Consider a simple example—the C standard
    library `strlen()` (string length) function. Here’s a typical implementation of
    `strlen()` that an inexperienced programmer might write:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 编写编译器运行时库的典型程序员在字符串处理函数方面有着丰富的经验。尽管过去新编译器往往伴随着效率低下的库，但随着时间的推移，编译器程序员积累了相当多的经验，编写出了高效的字符串处理函数。除非你花费了大量时间编写相同类型的例程，否则你的代码不太可能与他们的代码表现得一样好。许多编译器供应商会从专门编写库代码的第三方购买标准库代码，所以即使你使用的编译器相对较新，它也可能有一个不错的库。如今，几乎没有商业编译器包含效率极低的库代码。大多数情况下，只有研究型或“爱好者”编译器才会包含那么糟糕的库代码，以至于你可以轻松编写出更好的代码。考虑一个简单的例子——C
    标准库中的 `strlen()`（字符串长度）函数。以下是一个没有经验的程序员可能会编写的典型 `strlen()` 实现：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The 80x86 machine code that Microsoft’s Visual C++ compiler generates for `myStrlen()`
    is probably what any assembly programmer would expect:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 Visual C++ 编译器为 `myStrlen()` 生成的 80x86 机器代码可能是任何汇编程序员所预期的样子：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'No doubt, an experienced assembly language programmer could rearrange these
    particular instructions to speed them up a bit. Indeed, even an average 80x86
    assembly language programmer could point out that the 80x86 `scasb` instruction
    does most of the work in this code sequence. Although this code is fairly short
    and easy to understand, by no means will it run as fast as possible. An expert
    assembly language programmer might note that this loop repeats one iteration for
    each character in the string and accesses the characters in memory 1 byte at a
    time, and might improve upon it by unrolling^([1](footnotes.xhtml#ch10fn1)) the
    loop and processing more than one character per loop iteration. For example, consider
    the following HLA standard library `zstr.len()` function, which computes the length
    of a zero-terminated string by processing four characters at a time:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，一位经验丰富的汇编语言程序员可以重新排列这些特定的指令，稍微加速它。事实上，即使是一个普通的80x86汇编语言程序员，也能指出80x86的`scasb`指令在这段代码序列中完成了大部分工作。尽管这段代码相当简短且易于理解，但它并不会以最快的速度运行。一位专家级的汇编语言程序员可能会注意到，这个循环每次迭代处理字符串中的一个字符，并且一次访问一个字节的字符，它可能会通过展开^([1](footnotes.xhtml#ch10fn1))循环并在每次迭代中处理多个字符来改进它。例如，考虑以下HLA标准库的`zstr.len()`函数，它通过一次处理四个字符来计算零终止字符串的长度：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Even though this function is much longer and more complex than the simple example
    given earlier, it runs faster because it processes four characters per loop iteration
    rather than one, which means it executes far fewer loop iterations. Also, this
    code reduces loop overhead by unrolling eight copies of the loop (that is, expanding
    eight copies of the loop body inline), which saves the execution of 87 percent
    of the loop control instructions. As a result, this code runs anywhere from two
    to six times faster than the code given earlier; the exact savings depend upon
    the length of the string.^([2](footnotes.xhtml#ch10fn2))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个函数比之前给出的简单示例更长且更复杂，但它运行得更快，因为它每次循环迭代处理四个字符，而不是一个，这意味着它执行的循环迭代次数大大减少。此外，这段代码通过展开八个循环副本（即将循环体的八个副本内联展开）来减少循环开销，这节省了87%的循环控制指令的执行。因此，这段代码的运行速度比之前的代码快两到六倍；具体的节省取决于字符串的长度。^([2](footnotes.xhtml#ch10fn2))
- en: The second reason to avoid writing your own library functions is the maturity
    of the code. Most popular optimizing compilers available today have been around
    for a while. During this time, the compiler vendors have used their routines,
    determined where the bottlenecks lie, and optimized their code. When you write
    your own version of a standard library string-handling function, you probably
    won’t have comparable time to dedicate to optimizing it—you’ve got your entire
    application to worry about. Because of project time constraints, you’ll likely
    never go back and rewrite that string function to improve its performance. Even
    if there’s a slight performance advantage to your routine now, the compiler vendor
    may very well update their library in the future, and you could take advantage
    of those improvements by simply relinking the updated code with your project.
    However, if you write the library code yourself, it will never improve unless
    you explicitly update it yourself. Most people are too busy working on new projects
    to go back and clean up their old code, so the likelihood of improving self-written
    string functions in the future is quite low.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 避免自己编写库函数的第二个原因是代码的成熟度。现今大多数流行的优化编译器已经存在了一段时间。在此期间，编译器厂商已经使用了他们的例程，找出了瓶颈所在，并对他们的代码进行了优化。当你编写自己的标准库字符串处理函数时，你可能不会有足够的时间来进行优化——你还得处理整个应用程序。由于项目的时间限制，你很可能永远不会回过头来重写那个字符串函数以提高性能。即使你现在的程序有些微的性能优势，编译器厂商将来可能会更新他们的库，而你只需将更新后的代码与项目重新链接，就能利用这些改进。然而，如果你自己编写库代码，除非你明确更新它，否则它永远不会改进。大多数人都忙于处理新项目，没有时间回去清理旧代码，所以未来改进自己编写的字符串函数的可能性非常低。
- en: 'The third reason for using standard library string functions in a language
    like C or C++ is the most important: inline expansion. Many compilers recognize
    certain standard library function names and expand them inline to efficient machine
    code in place of the function call. This inline expansion can be many times faster
    than an explicit function call, especially if the function call contains several
    parameters. As a simple example, consider the following (almost trivial) C program:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 C 或 C++ 这样的语言中使用标准库字符串函数的第三个原因是最重要的：内联扩展。许多编译器能够识别某些标准库函数名，并将它们内联展开为高效的机器代码，取代函数调用。这个内联扩展通常比显式的函数调用快得多，尤其是在函数调用包含多个参数的情况下。举个简单的例子，考虑以下（几乎微不足道的）C
    程序：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The corresponding 64-bit x86-64 assembly code that Visual C++ produces is quite
    interesting:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++ 生成的相应的 64 位 x86-64 汇编代码相当有趣：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The compiler recognizes what’s going on and substitutes four inline instructions
    that copy the 12 bytes of the string from the literal constant in memory to the
    `localStr` variable (specifically, it copies 8 bytes using the XMM0 register and
    4 bytes using the EAX register; note that this code uses RCX to pass the address
    of `localStr` to the `printf()` function). The overhead of a call and return to
    an actual `strcpy()` function will be more expensive than this (and that’s without
    considering the work needed to copy the string data). This example demonstrates
    quite well why you should usually call standard library functions rather than
    writing your own “optimized” functions to do the same job.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器能够识别正在发生的事情，并替换为四条内联指令，将字符串的 12 个字节从内存中的字面常量复制到`localStr`变量中（具体来说，它使用 XMM0
    寄存器复制 8 个字节，使用 EAX 寄存器复制 4 个字节；注意，这段代码使用 RCX 将`localStr`的地址传递给`printf()`函数）。调用和返回一个实际的`strcpy()`函数的开销将比这个更昂贵（更不用说复制字符串数据所需的工作）。这个例子很好地演示了为什么你通常应该调用标准库函数，而不是编写你自己的“优化”函数来完成相同的工作。
- en: '**10.1.1.2 When Not to Use Standard Library Functions**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.1.1.2 何时不使用标准库函数**'
- en: Although, as you’ve seen, it’s usually better to call a standard library routine
    rather than writing your own version, there are some special situations when you
    should *not* rely on one or more library functions in the standard library.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如你所见，通常调用标准库例程要比编写你自己的版本更好，但在某些特殊情况下，你**不应该**依赖标准库中的一个或多个库函数。
- en: 'Library functions work great when they perform exactly the function you need—no
    more and no less. One area where programmers get into trouble is when they misuse
    a library function and call it to do something that it wasn’t really intended
    to do, or they need only part of the functionality it provides. For example, consider
    the C standard library `strcspn()` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当库函数完全执行你需要的功能时，它们非常有效——既不多也不少。程序员容易出问题的一个地方是，他们错误地使用库函数，调用它来做一些它并不真正打算做的事，或者他们只需要它提供功能的一部分。例如，考虑
    C 标准库中的`strcspn()`函数：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function returns the number of characters in the source string up to the
    first character it finds that also appears in the cset string. It’s not at all
    uncommon to see calls to this function that look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回源字符串中字符数，直到它找到一个在`cset`字符串中也出现的第一个字符为止。看到像这样的函数调用并不罕见：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The intent here is to return the number of characters in SomeString before
    the first occurrence of an `a` character in that string. That is, it attempts
    to do something like the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的是返回 SomeString 中第一次出现字符`a`之前的字符数。也就是说，它尝试做类似以下的事情：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Unfortunately, the call to the `strcspn()` function is probably a lot slower
    than this simple `while` loop implementation. That’s because `strcspn()` actually
    does a lot more work than search for a single character within a string. It looks
    for any character from a set of characters within the source string. The generic
    implementation of this function might be something like:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，调用`strcspn()`函数可能比这个简单的`while`循环实现要慢得多。这是因为`strcspn()`实际上做了比仅仅在字符串中查找单个字符更多的工作。它会在源字符串中查找来自一组字符的任何字符。这个函数的通用实现可能像这样：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With a little analysis (and noting that we have a pair of nested loops here),
    it’s clear that this code is slower than the code given earlier, even if you pass
    in a `cset` string containing a single character. This is a classic example of
    calling a function that is more general than you need, because it searches for
    any of several termination characters rather than the special case of a single
    terminating character. When a function does exactly what you want, using the standard
    library’s version of it is a good idea. However, when it does more than you need,
    using the standard library function can be expensive, and it’s better to write
    your own version.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过稍微分析（并注意到我们有一对嵌套循环），很明显这段代码比前面的代码慢，即使你传入一个只包含单个字符的 `cset` 字符串。这是一个经典的例子，展示了调用一个比实际需要更通用的函数，因为它会搜索多个终止字符，而不是单一终止字符的特殊情况。当一个函数完全符合你的需求时，使用标准库的版本是一个好主意。然而，当它做的事情超出你的需求时，使用标准库函数可能会非常昂贵，这时自己写一个版本会更好。
- en: '**10.1.1.3 Why to Avoid Length Recomputing Data**'
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.1.1.3 为什么要避免重新计算字符串长度**'
- en: 'The last example in the previous section demonstrates a common C programming
    mistake. Consider the coded fragment:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节的最后一个例子演示了一个常见的 C 编程错误。考虑以下代码片段：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On each iteration of this loop, the code tests the loop index to see if it
    is less than the length of the `cset` string. But because the loop body does not
    modify the `cset` string (and because, presumably, this is not a multithreaded
    application with another thread modifying the `cset` string), there’s really no
    need to recompute the string length on each iteration of this loop. Look at the
    code that the Microsoft Visual C++ 32-bit compiler emits for this code fragment:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环迭代中，代码都会测试循环索引，看它是否小于 `cset` 字符串的长度。但因为循环体没有修改 `cset` 字符串（并且假设这不是一个多线程应用程序，另一个线程没有修改
    `cset` 字符串），实际上没有必要在每次循环迭代中重新计算字符串长度。看一下微软 Visual C++ 32 位编译器为这段代码生成的机器代码：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Again, the machine code recalculates the string’s length on every iteration
    of the innermost `for` loop, but because the `cset` string’s length never changes,
    this is totally unnecessary. We can easily rectify this problem by rewriting the
    code fragment this way:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，机器代码在每次内层 `for` 循环的迭代中重新计算字符串的长度，但由于 `cset` 字符串的长度始终不变，这完全是不必要的。我们可以通过将代码片段重写成这样，轻松地解决这个问题：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: On the plus side, recent versions of Microsoft’s VC++ compiler will recognize
    this situation if you have optimizations turned on. As VC++ determines that the
    string length is a loop-invariant calculation (that is, its value does not change
    from one loop iteration to the next), VC++ will move the call to `strlen()` out
    of the loop. Unfortunately, VC++ can’t catch this in every situation. For example,
    if you call some function that VC++ doesn’t know about and you pass it the address
    of `localStr` as a (non-`const`) parameter, VC++ will have to assume that the
    string’s length could change (even if it doesn’t) and it won’t be able to move
    the `strlen()` call out of the loop.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你启用了优化，微软 VC++ 编译器的最新版本会识别这种情况。因为 VC++ 确定字符串长度是一个循环不变的计算（即它的值在每次循环迭代中都不会改变），VC++
    会把对 `strlen()` 的调用移出循环。不幸的是，VC++ 并不能在所有情况下都捕捉到这一点。例如，如果你调用一个 VC++ 不知道的函数，并将 `localStr`
    的地址作为一个（非 `const`）参数传递给它，VC++ 将不得不假设字符串的长度可能会改变（即使实际上没有改变），因此它无法将 `strlen()` 的调用移出循环。
- en: 'A fair number of string operations require the string’s length before they
    can execute. Consider the `strdup()` function commonly found in many C libraries.^([3](footnotes.xhtml#ch10fn3))
    The following code is a common implementation of this function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 很多字符串操作在执行之前需要知道字符串的长度。考虑 `strdup()` 函数，它在许多 C 库中常见。^([3](footnotes.xhtml#ch10fn3))
    以下代码是这个函数的常见实现：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Fundamentally, nothing is wrong with this implementation of `strdup()`. If
    you know absolutely nothing about the string object you’re passing as a parameter,
    then you must compute the string’s length so you know how much memory to allocate
    for a copy of that string. Consider, however, the following code sequence that
    calls `strdup()`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上讲，这个 `strdup()` 的实现没有错。如果你对传递的字符串对象一无所知，那么你必须计算字符串的长度，以便知道为该字符串的副本分配多少内存。然而，考虑以下调用
    `strdup()` 的代码序列：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The problem here is that you wind up calling `strlen()` twice: once for the
    explicit call to `strlen()` in this code fragment, and once for the call buried
    in the `strdup()` function. Worse, it isn’t obvious that you’re calling `strlen()`
    twice, so it’s not even clear that you’re wasting CPU cycles in this code. This
    is another example of calling a function that is more general than you need, causing
    the program to recompute the string’s length (an inefficient process). One solution
    is to provide a less general version of `strdup()`, say `strduplen()`, that lets
    you pass it the length of the string you’ve already computed. You could implement
    `strduplen()` as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是你会调用`strlen()`两次：一次是显式调用`strlen()`，另一次是在`strdup()`函数内部调用。更糟糕的是，这并不明显，因此你甚至无法察觉到你在这段代码中浪费了CPU周期。这是另一个例子，说明调用了一个比你实际需要的更通用的函数，导致程序重新计算字符串的长度（这是一种低效的过程）。一种解决方案是提供一个更不通用的版本，比如`strduplen()`，它允许你传递已经计算过的字符串长度。你可以按如下方式实现`strduplen()`：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice the use of `memcpy()` rather than `strcpy()` (or, better yet, `strncpy()`).
    Again, we already know the length of the string, so there’s no need to execute
    any code looking for the `0` terminating byte (as both `strcpy()` and `strncpy()`
    will do). Of course, this function implementation assumes that the caller passes
    the correct length, but that’s a standard C assumption for most string and array
    operations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`memcpy()`而不是`strcpy()`（或者更好的是`strncpy()`）。同样，我们已经知道字符串的长度，因此没有必要执行任何代码来查找终止字节`0`（这正是`strcpy()`和`strncpy()`所做的）。当然，这个函数实现假设调用者传递了正确的长度，但对于大多数字符串和数组操作来说，这是标准C语言的假设。
- en: '**10.1.1.4 Why to Avoid Copying Data**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**10.1.1.4 为什么要避免复制数据**'
- en: Copying strings, especially long strings, can be a time-consuming process on
    a computer. Most programs maintain string data in memory, and memory is much slower
    than the CPU (often by an order of magnitude or more). Although cache memory can
    help mitigate this problem, processing a lot of string data can eliminate other
    data from the cache and lead to thrashing problems if you don’t frequently reuse
    all the string data you move through the cache. It’s not always possible to avoid
    moving string data around, but many programs needlessly copy data, and that can
    hamper program performance.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 复制字符串，尤其是长字符串，可能是一个耗时的过程。大多数程序在内存中维护字符串数据，而内存比CPU慢得多（通常慢一个数量级或更多）。尽管缓存内存可以帮助缓解这个问题，但处理大量字符串数据可能会从缓存中移除其他数据，并且如果你不经常重用所有通过缓存移动的字符串数据，就会导致缓存抖动问题。虽然并非总能避免在字符串数据之间移动，但许多程序不必要地复制数据，这会影响程序性能。
- en: A better solution is to pass around *pointers* to zero-terminated strings rather
    than copying those strings from string variable to string variable. Pointers to
    zero-terminated strings can fit in registers and don’t consume much memory when
    you use memory variables to hold them. Therefore, passing pointers has far less
    impact on cache and CPU performance than copying string data among string variables.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是传递指向零终止字符串的*指针*，而不是将这些字符串从一个字符串变量复制到另一个字符串变量。指向零终止字符串的指针可以存储在寄存器中，并且在使用内存变量来存储它们时不会占用太多内存。因此，传递指针对缓存和CPU性能的影响远远小于在字符串变量之间复制字符串数据。
- en: As you’ve seen in this section, zero-terminated string functions are generally
    less efficient than functions that manipulate other types of strings. Furthermore,
    programs that utilize zero-terminated strings tend to make mistakes, such as calling
    `strlen()` multiple times or abusing generic functions to achieve specific goals.
    Fortunately, designing and using a more efficient string format is easy enough
    in languages whose native string format is the zero-terminated string.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本节中所看到的，零终止字符串函数通常比操作其他类型字符串的函数效率低。此外，使用零终止字符串的程序往往会出错，比如多次调用`strlen()`函数，或者滥用通用函数来实现特定的目标。幸运的是，在以零终止字符串为本地字符串格式的编程语言中，设计和使用更高效的字符串格式是相对简单的。
- en: '**10.1.2 Length-Prefixed Strings**'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.1.2 长度前缀字符串**'
- en: 'A second common string format, *length-prefixed strings*, overcomes some of
    the problems with zero-terminated strings. Length-prefixed strings are common
    in languages like Pascal; they generally consist of a single byte that specifies
    the length of the string, followed by zero or more 8-bit character codes (see
    [Figure 10-2](ch10.xhtml#ch10fig2)). In a length-prefixed scheme, the string `"String"`
    would consist of 4 bytes: the length byte (`6`), followed by the characters `S`,
    `t`, `r`, `i`, `n`, and `g`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种常见的字符串格式，*长度前缀字符串*，克服了零终止字符串的一些问题。长度前缀字符串在像 Pascal 这样的语言中很常见；它们通常由一个字节组成，指定字符串的长度，后面跟着零个或多个
    8 位字符代码（见 [图 10-2](ch10.xhtml#ch10fig2)）。在长度前缀方案中，字符串 `"String"` 由 4 个字节组成：长度字节（`6`），后面是字符
    `S`、`t`、`r`、`i`、`n` 和 `g`。
- en: '![Image](../images/10fig02.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig02.jpg)'
- en: '*Figure 10-2: Length-prefixed string format*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：长度前缀字符串格式*'
- en: 'Length-prefixed strings solve two of the problems associated with zeroterminated
    strings:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 长度前缀字符串解决了与零终止字符串相关的两个问题：
- en: NUL characters can be represented in length-prefixed strings.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NUL 字符可以在长度前缀字符串中表示。
- en: String operations are more efficient.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串操作更高效。
- en: Another advantage to length-prefixed strings is that the length is usually located
    at position `0` in the string (if we view the string as an array of characters),
    so the first character of the string begins at index `1` in the array representation
    of the string. For many string functions, having a `1`-based index into the character
    data is much more convenient than a `0`-based index (which zero-terminated strings
    use).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 长度前缀字符串的另一个优点是，长度通常位于字符串中的位置 `0`（如果我们将字符串视为字符数组），因此字符串的第一个字符在数组表示中从索引 `1` 开始。对于许多字符串函数，使用基于
    `1` 的索引比基于 `0` 的索引（零终止字符串使用的索引）要方便得多。
- en: Length-prefixed strings do suffer from their own drawbacks, the principal one
    being that they’re limited to a maximum of 255 characters in length (assuming
    a 1-byte length prefix). You can remove this limitation by using a 2- or 4-byte
    length value, but doing so increases the amount of overhead data from 1 to 2 or
    4 bytes. It also changes the starting index of the string from 1 to either 2 or
    4, eliminating the `1`-based index feature. While there are ways to overcome this
    problem, they entail even more overhead.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 长度前缀字符串确实有其自身的缺点，主要是它们的长度限制为最多 255 个字符（假设使用 1 字节长度前缀）。你可以通过使用 2 字节或 4 字节的长度值来去除这个限制，但这样会将额外的开销数据从
    1 字节增加到 2 字节或 4 字节。而且，它还会将字符串的起始索引从 1 改为 2 或 4，消除了 `1` 基索引的特点。虽然有方法可以克服这个问题，但它们会带来更多的开销。
- en: Many string functions are much more efficient with length-prefixed strings.
    Obviously, computing the length of a string is a trivial operation—it’s just a
    memory access—but other string functions that ultimately need the string’s length
    (such as concatenation and assignment) are usually more efficient than similar
    functions for zero-terminated strings. Furthermore, you don’t have to worry about
    recomputing the string’s length every time you call a string function that is
    built into the language’s standard library.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 许多字符串函数在长度前缀字符串上更高效。显然，计算字符串的长度是一个简单的操作——它只是一次内存访问——但其他最终需要字符串长度的字符串函数（如连接和赋值）通常比零终止字符串的类似函数更高效。此外，每次调用语言标准库中内置的字符串函数时，你不必担心重新计算字符串的长度。
- en: Despite these advantages, don’t get the impression that programs using length-prefixed
    string functions are always going to be efficient. You can still waste many CPU
    cycles by needlessly copying data. As with zero-terminated strings, if you use
    only a subset of a string function’s capabilities, you can waste lots of CPU cycles
    performing unnecessary tasks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这些优点，但不要产生这样的印象：使用长度前缀字符串函数的程序总是高效的。你仍然可以通过不必要地复制数据而浪费许多 CPU 周期。和零终止字符串一样，如果你只使用字符串函数的一部分功能，仍然会浪费大量
    CPU 周期来执行不必要的任务。
- en: 'When using length-prefixed string functions, keep the following points in mind:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用长度前缀字符串函数时，请记住以下几点：
- en: Try to use the language’s runtime library functions rather than attempting to
    code comparable functions yourself. Most compiler vendors provide highly optimized
    versions of their string functions that will probably run many times faster than
    code you would write yourself.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量使用语言的运行时库函数，而不是自己编写类似的函数。大多数编译器供应商提供的字符串函数经过高度优化，运行速度可能比你自己编写的代码快得多。
- en: Although computing the string length when using the length-prefixed string format
    is fairly trivial, many (Pascal) compilers actually emit a function call to extract
    the length value from the string’s data. The function call and return is far more
    expensive than retrieving the length value from a variable. So, once you compute
    the string’s length, consider saving that length in a local variable if you intend
    to use that value again. Of course, if a compiler is smart enough to replace a
    call to the length function with a simple data fetch from the string’s data structure,
    this “optimization” won’t buy you much.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管在使用带长度前缀的字符串格式时计算字符串长度相对简单，但许多（Pascal）编译器实际上会调用一个函数来从字符串数据中提取长度值。函数调用和返回比从变量中获取长度值要昂贵得多。因此，一旦计算出字符串的长度，如果打算再次使用该值，考虑将该长度保存在局部变量中。当然，如果编译器足够智能，能够将对长度函数的调用替换为从字符串数据结构中简单地获取数据，那么这种“优化”对你帮助不大。
- en: Avoid copying string data from one string variable to another. Doing so is one
    of the more expensive operations in programs using length-prefixed strings. Passing
    around pointers to strings has the same benefit as for zero-terminated strings.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将字符串数据从一个字符串变量复制到另一个。这样做是使用带长度前缀的字符串的程序中较为昂贵的操作之一。传递字符串的指针与零终止字符串的好处相同。
- en: '**10.1.3 Seven-Bit Strings**'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.1.3 七位字符串**'
- en: The 7-bit string format is an interesting option that works for 7-bit encodings
    like ASCII. It uses the (normally unused) higher-order bit of the characters in
    the string to indicate the end of the string. All but the last character code
    in the string has its HO bit clear, and the last character in the string has its
    HO bit set (see [Figure 10-3](ch10.xhtml#ch10fig3)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 7位字符串格式是一个有趣的选择，适用于像ASCII这样的7位编码。它使用字符串中字符的（通常未使用的）高阶位来表示字符串的结束。字符串中的每个字符代码，除了最后一个字符，其高阶位都是清除的，最后一个字符的高阶位是设置的（见[图10-3](ch10.xhtml#ch10fig3)）。
- en: '![Image](../images/10fig03.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig03.jpg)'
- en: '*Figure 10-3: Seven-bit string format*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3：七位字符串格式*'
- en: 'This 7-bit string format has several disadvantages:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种7位字符串格式有几个缺点：
- en: You have to scan the entire string in order to determine the length of the string.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须扫描整个字符串才能确定字符串的长度。
- en: You cannot have zero-length strings in this format.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种格式中不能有零长度的字符串。
- en: Few languages provide literal string constants for 7-bit strings.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很少有语言提供用于7位字符串的字面量字符串常量。
- en: You’re limited to a maximum of 128 character codes, although this is fine when
    you are using plain ASCII.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你最多只能有128个字符代码，尽管在使用普通ASCII时这并不成问题。
- en: 'However, the big advantage of 7-bit strings is that they don’t require any
    overhead bytes to encode the length. Assembly language (using a macro to create
    literal string constants) is probably the best language to use when dealing with
    7-bit strings. Because the benefit of 7-bit strings is that they’re compact and
    assembly language programmers tend to worry most about compactness, this is a
    good match. Here’s an HLA macro that converts a literal string constant to a 7-bit
    string:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，7位字符串的最大优势是它们不需要任何额外的字节来编码长度。当处理7位字符串时，汇编语言（使用宏来创建字面量字符串常量）可能是最适合的语言。因为7位字符串的优点是它们紧凑，而汇编语言程序员通常最关心紧凑性，因此这是一个很好的匹配。以下是一个HLA宏，它将字面量字符串常量转换为7位字符串：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Because few languages provide support for 7-bit strings, the first suggestion
    that applied to zero-terminated and length-prefixed strings doesn’t apply to 7-bit
    strings: you’ll probably have to write your own string-handling functions. Computing
    lengths and copying data are expensive operations even with 7-bit strings, however,
    so these two suggestions still apply:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于很少有语言支持7位字符串，第一个适用于零终止和带长度前缀字符串的建议并不适用于7位字符串：你可能必须编写自己的字符串处理函数。然而，即使是7位字符串，计算长度和复制数据也是昂贵的操作，所以这两条建议仍然适用：
- en: Once you’ve computed the length of a string by scanning the entire string, save
    that length for future use (rather than recomputing it every time you need it).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你通过扫描整个字符串计算出字符串的长度，就可以保存该长度以备将来使用（而不是每次需要时都重新计算它）。
- en: Avoid copying string data from one string variable to another. Doing so is one
    of the more expensive operations in programs using 7-bit strings.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将字符串数据从一个字符串变量复制到另一个。这样做是使用7位字符串的程序中成本较高的操作之一。
- en: '**10.1.4 HLA Strings**'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.1.4 HLA字符串**'
- en: As long as you’re not too concerned about a few extra bytes of overhead per
    string, you can create a string format that combines the advantages of both length-prefixed
    and zero-terminated strings without their respective disadvantages. The High-Level
    Assembly language has done this with its native string format.^([4](footnotes.xhtml#ch10fn4))
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你不太关心每个字符串多出的几个字节开销，你就可以创建一种结合了长度前缀和零终止字符串优点的字符串格式，而没有它们各自的缺点。高级汇编语言已经通过其原生字符串格式实现了这一点。^([4](footnotes.xhtml#ch10fn4))
- en: The biggest drawback to the HLA character string format is the amount of overhead
    required for each string (which can be significant, percentage-wise, if you’re
    in a memory-constrained environment and you process many small strings). HLA strings
    contain a length prefix and a zero-terminating byte, as well as some other information,
    totaling 9 bytes of overhead per string.^([5](footnotes.xhtml#ch10fn5))
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 字符串格式的最大缺点是每个字符串所需的开销（如果你在内存受限的环境中，并且处理许多小字符串，这个开销可能会非常显著）。HLA 字符串包含一个长度前缀和一个零终止字节，以及一些其他信息，每个字符串总共有
    9 个字节的开销。^([5](footnotes.xhtml#ch10fn5))
- en: The HLA string format uses a 4-byte length prefix, allowing character strings
    to be just over 4 billion characters long (far more than any practical application
    will use). HLA also appends a `0` byte to the character string data, so HLA strings
    are compatible with string functions that reference (but do not change the length
    of) zero-terminated strings. The remaining 4 bytes of overhead in an HLA string
    contain the maximum legal length for that string (plus a `0` terminating byte).
    Having this extra field allows HLA string functions to check for string overflow,
    if necessary. In memory, HLA strings take the form shown in [Figure 10-4](ch10.xhtml#ch10fig4).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 字符串格式使用一个 4 字节的长度前缀，使得字符字符串的长度可以达到超过 40 亿个字符（远远超出任何实际应用的需求）。HLA 还会在字符字符串数据后附加一个
    `0` 字节，因此 HLA 字符串与引用（但不更改长度）零终止字符串的字符串函数兼容。HLA 字符串中的剩余 4 字节开销包含该字符串的最大合法长度（加上一个
    `0` 终止字节）。这个额外的字段允许 HLA 字符串函数在必要时检查字符串溢出。在内存中，HLA 字符串的形式如图 [10-4](ch10.xhtml#ch10fig4)
    所示。
- en: '![Image](../images/10fig04.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig04.jpg)'
- en: '*Figure 10-4: HLA string format*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：HLA 字符串格式*'
- en: The 4 bytes immediately before the first character of the string contain the
    current string length. The 4 bytes preceding the current string length contain
    the maximum string length. Immediately following the character data is a `0` byte.
    Finally, HLA always ensures that the string data structure’s length is a multiple
    of 4 bytes for performance reasons, so there may be up to 3 additional bytes of
    padding at the end of the object in memory. (Note that the string shown in [Figure
    10-4](ch10.xhtml#ch10fig4) requires only 1 byte of padding to ensure that the
    data structure is a multiple of 4 bytes in length.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串第一个字符之前的 4 个字节包含当前字符串长度。当前字符串长度之前的 4 个字节包含最大字符串长度。紧随字符数据后面的是一个 `0` 字节。最后，HLA
    始终确保字符串数据结构的长度是 4 字节的倍数，以提高性能，因此在内存中对象的末尾可能会有最多 3 个额外的填充字节。（注意，图 [10-4](ch10.xhtml#ch10fig4)
    中显示的字符串只需要 1 个填充字节，以确保数据结构的长度是 4 字节的倍数。）
- en: 'HLA string variables are actually pointers that contain the byte address of
    the first character in the string. To access the length fields, you load the value
    of the string pointer into a 32-bit register, then access the length field at
    offset –4 from the register and the maximum length field at offset –8 from the
    register. Here’s an example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 字符串变量实际上是指针，包含字符串第一个字符的字节地址。要访问长度字段，你需要将字符串指针的值加载到一个 32 位寄存器中，然后从该寄存器偏移
    -4 处访问长度字段，从寄存器偏移 -8 处访问最大长度字段。以下是一个示例：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As noted earlier, the amount of memory reserved to hold an HLA string’s character
    data (including the `0` byte) is always a multiple of 4 bytes. Therefore, it’s
    always guaranteed that you can move data from one HLA string to another by copying
    double words rather than individual bytes. This allows string copy routines to
    run up to four times faster, because you execute one-fourth the number of loop
    iterations copying a string of double words as you would copying the string a
    byte at a time. For example, here’s the highly modified version of the pertinent
    code in the HLA `str.cpy()` function that copies one string to another:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，HLA 字符串的字符数据（包括 `0` 字节）所保留的内存量始终是 4 字节的倍数。因此，总是可以通过复制双字而不是单个字节来将数据从一个 HLA
    字符串移动到另一个 HLA 字符串。这使得字符串复制例程运行速度提高最多四倍，因为复制双字字符串的循环迭代次数是逐字节复制字符串的四分之一。例如，这是 HLA
    `str.cpy()` 函数中复制一个字符串到另一个字符串的高度修改版代码：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The HLA `str.cpy()` function also checks for string overflows and `NULL` pointer
    references (for clarity, that code does not appear in this example). However,
    the takeaway here is that HLA copies the strings as double words in order to improve
    performance.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: HLA `str.cpy()` 函数还会检查字符串溢出和 `NULL` 指针引用（为了清晰起见，这段代码在本示例中没有出现）。然而，重点是 HLA 以双字的形式复制字符串，以提高性能。
- en: 'One nice thing about HLA string variables is that (as read-only objects) HLA
    strings are compatible with zero-terminated strings. For example, if you have
    a function written in C or some other language that expects you to pass a zero-terminated
    string to it, you can call that function and pass an HLA string variable to it,
    like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 字符串变量的一个优点是（作为只读对象）HLA 字符串与零终止字符串兼容。例如，如果你有一个用 C 或其他语言编写的函数，要求你传递一个零终止的字符串，你可以调用该函数并传递一个
    HLA 字符串变量，如下所示：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The only catch is that the C function must not make any changes to the string
    that would affect its length (because the C code won’t update the `Length` field
    of the HLA string). Of course, you can always call a C `strlen()` function upon
    returning to update the length field yourself, but generally, it’s best not to
    pass HLA strings to a function that modifies zero-terminated strings.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要注意的是，C 函数不得对字符串进行任何会影响其长度的修改（因为 C 代码不会更新 HLA 字符串的 `Length` 字段）。当然，你可以在返回时调用
    C 的 `strlen()` 函数来更新长度字段，但通常最好不要将 HLA 字符串传递给会修改零终止字符串的函数。
- en: 'The comments on length-prefixed strings generally apply to HLA strings, specifically:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关于长度前缀字符串的评论通常适用于 HLA 字符串，具体而言：
- en: Try to use the HLA standard library functions rather than attempting to code
    comparable functions yourself. While you might want to check out the library function’s
    source code (available with HLA), most of the string functions do a good job on
    generic string data.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用 HLA 标准库函数，而不是自己编写相应的函数。尽管你可能想查看库函数的源代码（HLA 中提供了源代码），但大多数字符串函数对于通用字符串数据的处理都很不错。
- en: Although, in theory, you shouldn’t count on the explicit length field appearing
    in the HLA string data format, most programs simply grab the length from the 4
    bytes immediately preceding the string data, so there’s generally no need to save
    the length. Careful HLA programmers will actually call the `str.len()` function
    in the HLA standard library and simply save this value in a local variable for
    future use. However, accessing the length directly is probably safe.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然理论上你不应该依赖 HLA 字符串数据格式中显式的长度字段，但大多数程序会从字符串数据之前的 4 个字节获取长度，因此通常不需要保存长度。细心的 HLA
    程序员实际上会调用 HLA 标准库中的 `str.len()` 函数，并将此值保存在局部变量中以供将来使用。然而，直接访问长度通常是安全的。
- en: Avoid copying string data from one string variable to another. Doing so is one
    of the more expensive operations in programs using HLA strings.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将字符串数据从一个字符串变量复制到另一个字符串变量中。在使用 HLA 字符串的程序中，这种操作是相对昂贵的。
- en: '**10.1.5 Descriptor-Based Strings**'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.1.5 基于描述符的字符串**'
- en: 'The string formats we’ve considered up to this point have kept the attribute
    information (that is, the lengths and terminating bytes) for a string in memory
    along with the character data. A slightly more flexible scheme is to maintain
    such information in a record structure, known as a *descriptor*, that also contains
    a pointer to the character data. Consider the following Pascal/Delphi data structure
    (see [Figure 10-5](ch10.xhtml#ch10fig5)):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止我们讨论的字符串格式将属性信息（即长度和终止字节）与字符数据一起保存在内存中。一种稍微灵活一些的方案是将这些信息保存在一个记录结构中，该结构称为*描述符*，它还包含指向字符数据的指针。考虑以下
    Pascal/Delphi 数据结构（参见[图 10-5](ch10.xhtml#ch10fig5)）：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Image](../images/10fig05.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/10fig05.jpg)'
- en: '*Figure 10-5: String descriptors*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：字符串描述符*'
- en: Note that this data structure does not hold the actual character data. Instead,
    the `strData` pointer contains the address of the first character of the string.
    The `curLength` field specifies the current length of the string. You could add
    any other fields you like to this record, such as a maximum length field, although
    a maximum length isn’t usually necessary because most string formats employing
    a descriptor are dynamic (as the next section will discuss).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个数据结构并不保存实际的字符数据。相反，`strData`指针包含字符串第一个字符的地址。`curLength`字段指定字符串的当前长度。您可以根据需要向该记录添加其他字段，比如最大长度字段，尽管通常不需要最大长度，因为大多数采用描述符的字符串格式都是动态的（如下一节将讨论的那样）。
- en: An interesting attribute of a descriptor-based string system is that the actual
    character data associated with a string could be part of a larger string. Because
    no length or terminating bytes are in the actual character data, it’s possible
    to have the character data for two strings overlap (see [Figure 10-6](ch10.xhtml#ch10fig6)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 基于描述符的字符串系统的一个有趣特性是，与字符串相关的实际字符数据可能是一个更大字符串的一部分。由于实际字符数据中没有长度或终止字节，因此两个字符串的字符数据可以重叠（参见[图
    10-6](ch10.xhtml#ch10fig6)）。
- en: '![Image](../images/10fig06.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/10fig06.jpg)'
- en: '*Figure 10-6: Overlapping strings using descriptors*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：使用描述符的重叠字符串*'
- en: This example shows two strings—`"Hello World"` and `"World"`—that overlap. This
    can save memory and make certain functions, like `substring()`, very efficient.
    Of course, when strings overlap as these do, you can’t modify the string data
    because that could wipe out part of some other string.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了两个重叠的字符串——`"Hello World"`和`"World"`。这样可以节省内存，并使某些函数，如`substring()`，非常高效。当然，当字符串像这样重叠时，您不能修改字符串数据，因为那样可能会破坏其他字符串的一部分。
- en: The suggestions given for other string formats don’t apply as strongly to descriptor-based
    strings. Certainly, if standard libraries are available, you should call those
    functions because they’re probably more efficient than the ones you would write
    yourself. There is no need to save the length, because extracting the length field
    from the string’s descriptor is usually a minor task. Also, many descriptor-based
    string systems use *copy on write* (see *WGC1* and the section “Dynamic Strings”
    on [page 317](ch10.xhtml#page_317)) to reduce string copy overhead. In a string
    descriptor system, you should avoid making changes to a string, because the copy-on-write
    semantics generally require the system to make a complete copy of the string whenever
    you change a single character (something that isn’t necessary with other string
    formats).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 针对其他字符串格式的建议并不完全适用于基于描述符的字符串。确实，如果有标准库可用，您应该调用那些函数，因为它们可能比您自己编写的函数更高效。不需要保存长度，因为从字符串的描述符中提取长度字段通常是一个小任务。此外，许多基于描述符的字符串系统使用*写时复制*（参见*WGC1*和[第317页](ch10.xhtml#page_317)的“动态字符串”部分）来减少字符串复制的开销。在字符串描述符系统中，您应避免修改字符串，因为写时复制语义通常要求系统在您更改单个字符时对整个字符串进行完整复制（与其他字符串格式不同，这种操作通常是不必要的）。
- en: '**10.2 Static, Pseudo-Dynamic, and Dynamic Strings**'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.2 静态、伪动态和动态字符串**'
- en: 'Having covered the various string data formats, it’s time to consider where
    to store string data in memory. Strings can be classified according to when and
    where the system allocates storage for them. There are three categories: static
    strings, pseudo-dynamic strings, and dynamic strings.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了各种字符串数据格式之后，接下来需要考虑的是在哪里存储字符串数据。字符串可以根据系统何时以及何地分配存储来分类。它们有三种类别：静态字符串、伪动态字符串和动态字符串。
- en: '**10.2.1 Static Strings**'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.2.1 静态字符串**'
- en: 'Pure *static strings* are those whose maximum size a programmer chooses when
    writing the program. Pascal strings and Delphi *short strings* fall into this
    category. Arrays of characters that you use to hold zero-terminated strings in
    C/C++ also fall into this category, as do fixed-length arrays of characters. Consider
    the following declaration in Pascal:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 纯*静态字符串*是程序员在编写程序时选择其最大大小的字符串。Pascal字符串和Delphi*短字符串*属于这一类别。你在C/C++中用来保存零终止字符串的字符数组也属于这一类别，固定长度的字符数组也在此类之中。考虑以下在Pascal中的声明：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And here’s an example in C/C++:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个C/C++的例子：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While the program is running, there’s no way to increase the maximum sizes of
    these static strings. Nor is there any way to reduce the storage they will use;
    these string objects will consume 256 bytes at runtime, period. One advantage
    to pure static strings is that the compiler can determine their maximum length
    at compile time and implicitly pass this information to a string function so it
    can test for bounds violations at runtime.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序运行时，无法增加这些静态字符串的最大大小，也无法减少它们所使用的存储空间；这些字符串对象在运行时将消耗256字节的存储空间，且不可改变。纯静态字符串的一个优点是编译器可以在编译时确定它们的最大长度，并隐式地将此信息传递给字符串函数，以便在运行时检查边界溢出。
- en: '**10.2.2 Pseudo-Dynamic Strings**'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.2.2 伪动态字符串**'
- en: A pseudo-dynamic string is one whose length the system sets at runtime by calling
    a memory management function like `malloc()` to allocate storage for it. However,
    once the system allocates storage for the string, the maximum length of the string
    is fixed. HLA strings generally fall into this category.^([6](footnotes.xhtml#ch10fn6))
    An HLA programmer typically calls the `stralloc()` function to allocate storage
    for a string variable, after which that particular string object has a fixed length
    that cannot change.^([7](footnotes.xhtml#ch10fn7))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 伪动态字符串是系统通过调用像`malloc()`这样的内存管理函数在运行时为其分配存储空间的字符串。然而，一旦系统为该字符串分配了存储空间，字符串的最大长度就固定了。HLA字符串通常属于这一类别。^([6](footnotes.xhtml#ch10fn6))
    HLA程序员通常会调用`stralloc()`函数为字符串变量分配存储空间，之后该字符串对象的长度将固定，无法更改。^([7](footnotes.xhtml#ch10fn7))
- en: '**10.2.3 Dynamic Strings**'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.2.3 动态字符串**'
- en: Dynamic string systems, which typically use a descriptor-based format, automatically
    allocate sufficient storage for a string object whenever you create a new string
    or otherwise do something that affects an existing string. Operations like string
    assignment and substring extraction are relatively trivial in dynamic string systems—generally
    they copy only the string descriptor data, so these operations are fast. However,
    as noted in the section “Descriptor-Based Strings” on [page 315](ch10.xhtml#page_315),
    when using strings this way, you cannot store data back into a string object,
    because it could modify data that is part of other string objects in the system.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 动态字符串系统通常使用基于描述符的格式，每当创建新字符串或对现有字符串进行影响时，系统会自动为字符串对象分配足够的存储空间。在动态字符串系统中，像字符串赋值和子字符串提取这样的操作相对简单——通常它们只复制字符串描述符数据，因此这些操作很快。然而，正如在[第315页](ch10.xhtml#page_315)“基于描述符的字符串”一节中所提到的，使用这种方式的字符串时，无法将数据存储回字符串对象中，因为这可能会修改系统中其他字符串对象的数据。
- en: The solution to this problem is to use the copy-on-write technique. Whenever
    a string function needs to change characters in a dynamic string, the function
    first makes a copy of the string and then makes the necessary modifications to
    that copy. Research suggests that copy-on-write semantics can improve the performance
    of many typical applications, because operations like string assignment and substring
    extraction (which is just a partial string assignment) are far more common than
    the modification of character data within strings. The only drawback to this approach
    is that after several modifications to string data in memory, there may be sections
    of the string heap area that contain character data that’s no longer in use. To
    avoid a memory leak, dynamic string systems employing copy on write usually provide
    garbage collection code, which scans the string heap area looking for stale character
    data in order to recover that memory for other purposes. Unfortunately, depending
    on the algorithms in use, garbage collection can be quite slow.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使用写时复制技术。每当一个字符串函数需要修改动态字符串中的字符时，该函数首先会复制一份字符串，然后对那份副本进行必要的修改。研究表明，写时复制语义可以提高许多典型应用程序的性能，因为像字符串赋值和子字符串提取（其实只是部分字符串赋值）这样的操作，比修改字符串内的字符数据要常见得多。这种方法唯一的缺点是，在内存中对字符串数据进行多次修改后，字符串堆区域可能会包含一些不再使用的字符数据。为了避免内存泄漏，采用写时复制的动态字符串系统通常会提供垃圾回收代码，扫描字符串堆区域，寻找过时的字符数据，以便将这些内存回收用于其他目的。不幸的是，根据使用的算法不同，垃圾回收可能非常缓慢。
- en: '**NOTE**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*See [Chapter 9](ch09.xhtml#ch09) for more information on memory leaks and
    garbage collection.*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关内存泄漏和垃圾回收的更多信息，请参见[第9章](ch09.xhtml#ch09)。*'
- en: '**10.3 Reference Counting for Strings**'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.3 字符串的引用计数**'
- en: Consider the case where you have two string descriptors (or pointers) pointing
    at the same string data in memory. Clearly, you can’t deallocate the storage associated
    with one pointer while the program is still using the other pointer to access
    the same data. One common solution is to make the programmer responsible for keeping
    track of such details. Unfortunately, as applications become more complex, this
    approach often leads to dangling pointers, memory leaks, and other pointer-related
    problems in the software. A better solution is to allow the programmer to deallocate
    the storage for the character data in the string and to have the actual deallocation
    process hold off until the programmer releases the last pointer referencing that
    data. To accomplish this, a string system can use *reference counters*, which
    track the pointers and their associated data.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个字符串描述符（或指针）指向内存中相同的字符串数据。显然，在程序仍然使用另一个指针访问相同数据时，你不能释放与其中一个指针关联的存储空间。一个常见的解决方案是让程序员负责跟踪这些细节。不幸的是，随着应用程序变得更加复杂，这种方法往往会导致悬空指针、内存泄漏和其他与指针相关的问题。一个更好的解决方案是允许程序员释放字符串中字符数据的存储空间，并且让实际的释放过程推迟，直到程序员释放掉最后一个引用该数据的指针。为了实现这一点，字符串系统可以使用*引用计数器*，它们跟踪指针及其关联的数据。
- en: A reference counter is an integer that counts the number of pointers that reference
    a string’s character data in memory. Every time you assign the address of the
    string to some pointer, you increment the reference counter by 1\. Likewise, whenever
    you want to deallocate the storage associated with the character data for the
    string, you decrement the reference counter. Deallocation of the storage for the
    actual character data doesn’t happen until the reference counter decrements to
    0.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数器是一个整数，用来统计内存中引用字符串字符数据的指针数量。每次将字符串的地址赋值给某个指针时，引用计数器加1。同样，当你想要释放与字符串字符数据关联的存储空间时，引用计数器减1。直到引用计数器减到0，才会真正释放字符数据的存储空间。
- en: Reference counting works great when the language handles the details of string
    assignment automatically for you. If you try to implement reference counting manually,
    you must be sure to always increment the reference counter when you assign a string
    pointer to some other pointer variable. The best way to do this is to never assign
    pointers directly, but rather handle all string assignments via some function
    (or macro) call that updates the reference counters in addition to copying the
    pointer data. If your code fails to update the reference counter properly, you’ll
    wind up with dangling pointers or memory leaks.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数在语言自动处理字符串赋值的细节时效果很好。如果你尝试手动实现引用计数，必须确保每次将字符串指针赋值给其他指针变量时，都要始终递增引用计数器。最好的做法是不要直接赋值指针，而是通过某个函数（或宏）调用来处理所有字符串赋值，这样不仅能复制指针数据，还能更新引用计数器。如果你的代码未能正确更新引用计数器，最终可能会出现悬空指针或内存泄漏。
- en: '**10.4 Delphi Strings**'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.4 Delphi 字符串**'
- en: Although Delphi provides a “short string” format that is compatible with the
    length-prefixed strings in earlier versions of Delphi and Turbo Pascal, later
    versions of Delphi (v4.0 and later) use dynamic strings for their native string
    format. While this string format is unpublished (and, therefore, subject to change),
    indications are that Delphi’s string format is very similar to HLA’s. Delphi uses
    a zero-terminated sequence of characters with a leading string length and a reference
    counter (rather than a maximum length as HLA uses). [Figure 10-7](ch10.xhtml#ch10fig7)
    shows the layout of a Delphi string in memory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Delphi 提供了与早期版本 Delphi 和 Turbo Pascal 中的长度前缀字符串兼容的“短字符串”格式，但从 Delphi v4.0
    版本开始，后续版本使用动态字符串作为其本地字符串格式。虽然这种字符串格式未公开（因此可能会发生变化），但有迹象表明，Delphi 的字符串格式与 HLA 非常相似。Delphi
    使用一个零终止的字符序列，前面有字符串长度和引用计数器（而不是像 HLA 使用的最大长度）。[图 10-7](ch10.xhtml#ch10fig7) 显示了
    Delphi 字符串在内存中的布局。
- en: '![Image](../images/10fig07.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig07.jpg)'
- en: '*Figure 10-7: Delphi string data format*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-7：Delphi 字符串数据格式*'
- en: As with HLA, Delphi string variables are pointers holding the address of the
    first character of the actual string data. To access the length and reference
    counter fields, the Delphi string routines use a negative offset of –4 and –8
    from the character data’s base address. However, because this string format is
    not published, applications should never access the length or reference counter
    fields directly (for example, these fields could be 64-bit values one day). Delphi
    provides a length function that extracts the string length for you, and there’s
    really no need for your applications to access the reference counter field because
    the Delphi string functions maintain it automatically.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HLA 一样，Delphi 字符串变量是指针，指向实际字符串数据的第一个字符地址。为了访问长度和引用计数字段，Delphi 字符串例程使用从字符数据基地址偏移的负值
    -4 和 -8。然而，由于这种字符串格式并未公开，应用程序不应直接访问长度或引用计数字段（例如，这些字段将来可能会变为 64 位值）。Delphi 提供了一个长度函数来提取字符串长度，而你的应用程序实际上无需访问引用计数字段，因为
    Delphi 字符串函数会自动维护它。
- en: '**10.5 Using Strings in a High-Level Language**'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.5 在高级语言中使用字符串**'
- en: 'Strings are a very common data type in high-level programming languages. Because
    applications often make extensive use of string data, many HLLs provide libraries
    with lots of complex string manipulation routines that hide considerable complexity
    from the programmer. Unfortunately, it’s easy to forget the amount of work involved
    in a typical string operation when you execute a statement like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是高级编程语言中非常常见的数据类型。由于应用程序经常大量使用字符串数据，许多高级编程语言提供了包含大量复杂字符串操作例程的库，这些操作例程将相当复杂的细节隐藏在程序员的视野之外。不幸的是，当你执行像下面这样的语句时，很容易忽视典型字符串操作所涉及的工作量：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In a typical Pascal implementation, this assignment statement calls a function
    that winds up copying each character from the string literal to the storage reserved
    for the aLengthPrefixedString variable. That is, this statement roughly expands
    to the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的 Pascal 实现中，这个赋值语句会调用一个函数，将字符串字面量的每个字符复制到为 aLengthPrefixedString 变量保留的存储空间中。也就是说，这个语句大致展开为如下：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code doesn’t even include the overhead of the procedure call, return, and
    parameter passing. As noted throughout the chapter, copying string data is one
    of the more expensive operations programs commonly do. This is why many HLLs have
    switched to dynamic strings and copy-on-write semantics—string assignments are
    far more efficient when you copy only a pointer rather than all of the character
    data. This is not to suggest that copy on write is always better, but for many
    string operations—such as assignment, substring, and other operations that do
    not change the string’s character data—it can be very efficient.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码甚至不包括过程调用、返回和参数传递的开销。正如本章各处提到的，复制字符串数据是程序中常见的昂贵操作之一。这就是为什么许多高级语言（HLL）已转向动态字符串和写时复制语义——当你仅复制指针而不是所有字符数据时，字符串赋值要高效得多。这并不是说写时复制总是更好，但对于许多字符串操作——比如赋值、子字符串操作和其他不会改变字符串字符数据的操作——它可以非常高效。
- en: Although few programming languages give you the option of choosing which string
    format you want to use, many do let you create pointers to strings, so you can
    manually support copy on write. If you’re willing to write your own string-handling
    functions, you can create some very efficient programs by avoiding the use of
    your language’s built-in string-handling capabilities. For example, the substring
    operation in C is usually handled by the `strncpy()` function and is often implemented
    like so:^([8](footnotes.xhtml#ch10fn8))
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管很少有编程语言允许你选择想要使用的字符串格式，但许多语言允许你创建指向字符串的指针，因此你可以手动支持写时复制。如果你愿意编写自己的字符串处理函数，通过避免使用语言内置的字符串处理功能，你可以创建一些非常高效的程序。例如，C语言中的子字符串操作通常由`strncpy()`函数处理，通常像这样实现：^([8](footnotes.xhtml#ch10fn8))
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A typical “substring” operation might use `strncpy()` as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的“子字符串”操作可能会像下面这样使用`strncpy()`：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: where substring is the destination string object, fullString is the source string,
    start is the starting index of the substring to copy, and length is the length
    of the substring to copy.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 其中substring是目标字符串对象，fullString是源字符串，start是要复制的子字符串的起始索引，length是要复制的子字符串的长度。
- en: 'If you create a descriptor-based string format in C using a `struct`, similar
    to the HLA record in “Descriptor-Based Strings” on [page 315](ch10.xhtml#page_315),
    you could do a substring operation with the following two statements in C:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用C语言中的`struct`创建一个基于描述符的字符串格式，类似于《基于描述符的字符串》一章中“描述符式字符串”部分提到的HLA记录，在C语言中，你可以通过以下两个语句进行子字符串操作：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code executes much faster than the `strncpy()` version.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的执行速度比`strncpy()`版本要快得多。
- en: Sometimes, a particular programming language won’t provide access to the underlying
    string data representation it supports, and you’ll have to live with the performance
    loss, switch languages, or write your own string-handling code in assembly language.
    Generally, though, there are alternatives to copying string data in your applications,
    such as using a string descriptor as in the example just given.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，某些编程语言不会提供访问其支持的底层字符串数据表示的功能，你将不得不忍受性能损失、切换语言，或者编写自己的汇编语言字符串处理代码。然而，通常来说，在应用程序中有替代方法来避免复制字符串数据，比如使用字符串描述符，就像刚才的示例所示。
- en: '**10.6 Unicode Character Data in Strings**'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.6 Unicode字符数据在字符串中的应用**'
- en: 'Up to this point, we’ve assumed that each character in a string consumes exactly
    1 byte of storage. We’ve also assumed the use of the 7-bit ASCII character set
    when discussing the character data appearing in a string. Traditionally, this
    has been the way programming languages have represented a string’s character data.
    Today, however, the ASCII character set is too limited for worldwide use, and
    several new character sets have risen in popularity, including the Unicode variants:
    UTF-8, UTF-16, UTF-32, and UTF-7\. Because these character formats can have a
    big impact on the efficiency of string functions that operate upon them, we’ll
    spend some time covering them.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假设字符串中的每个字符都占用精确的1字节存储空间。我们还假设在讨论字符串中的字符数据时使用的是7位ASCII字符集。传统上，这一直是编程语言表示字符串字符数据的方式。然而，今天，ASCII字符集对于全球使用来说太有限了，许多新的字符集已经逐渐流行起来，其中包括Unicode的变体：UTF-8、UTF-16、UTF-32和UTF-7。因为这些字符格式可能对操作它们的字符串函数的效率产生重大影响，我们将花一些时间讨论它们。
- en: '**10.6.1 The Unicode Character Set**'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.6.1 Unicode字符集**'
- en: A few decades back, engineers at Aldus, NeXT, Sun, Apple Computer, IBM, Microsoft,
    the Research Library Group, and Xerox realized that their new computer systems
    with bitmaps and user-selectable fonts could display far more than 256 different
    characters at one time. At the time, *double-byte character sets (DBCSs)* were
    the most common solution. DBCSs had a couple of issues, however. First, as they
    were typically variable-length encodings, DBCSs required special library code;
    common character/string algorithms that depended upon fixed-length character encodings
    would not work properly with them. Second, there was no consistent standard—different
    DBCSs used the same encoding for different characters. So, wanting to avoid these
    compatibility problems, the engineers sought a different route.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年前，Aldus、NeXT、Sun、Apple Computer、IBM、Microsoft、研究图书馆集团和Xerox的工程师意识到，他们的新计算机系统支持位图和用户可选择字体，可以同时显示比256个字符更多的字符。当时，*双字节字符集（DBCSs）*是最常见的解决方案。然而，DBCSs有几个问题。首先，作为典型的可变长度编码，DBCSs需要特殊的库代码；依赖固定长度字符编码的常见字符/字符串算法在它们上面无法正常工作。其次，没有统一的标准——不同的DBCSs对不同的字符使用相同的编码。因此，为了避免这些兼容性问题，工程师们寻找了另一种解决方案。
- en: The solution they came up with was the Unicode character set. The engineers
    who originally developed Unicode chose a 2-byte character size. Like DBCSs, this
    approach still required special library code (existing single-byte string functions
    would not always work with 2-byte characters), but other than changing the size
    of a character, most existing string algorithms would still work with 2-byte characters.
    The Unicode definition included all of the (known/living) character sets at the
    time, giving each character a unique encoding, to avoid the consistency problems
    that plagued differing DBCSs.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 他们想出的解决方案是Unicode字符集。最初开发Unicode的工程师选择了2字节字符大小。像DBCSs一样，这种方法仍然需要特殊的库代码（现有的单字节字符串函数并不总是能与2字节字符兼容），但除了改变字符的大小外，大多数现有的字符串算法仍然可以与2字节字符一起使用。Unicode的定义包括了当时所有的（已知/在用的）字符集，为每个字符分配了唯一的编码，以避免不同DBCSs所困扰的一致性问题。
- en: The original Unicode standard used a 16-bit word to represent each character.
    Therefore, Unicode supported up to 65,536 different character codes—a huge advance
    over the 256 possible codes that are representable with an 8-bit byte. Furthermore,
    Unicode is upward compatible from ASCII. If the HO 9 bits^([9](footnotes.xhtml#ch10fn9))
    of a Unicode character’s binary representation contain `0`, then the LO 7 bits
    use the standard ASCII code. If the HO 9 bits contain some nonzero value, then
    the 16 bits form an extended character code (extended from ASCII, that is). If
    you’re wondering why so many different character codes are necessary, note that,
    at the time, certain Asian character sets contained 4,096 characters. The Unicode
    character set even provided a set of codes you could use to create an application-defined
    character set. Approximately half of the 65,536 possible character codes have
    been defined, and the remaining character encodings are reserved for future expansion.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的Unicode标准使用16位字表示每个字符。因此，Unicode支持最多65,536个不同的字符编码——相比8位字节能够表示的256个编码，这是一个巨大的进步。此外，Unicode向下兼容ASCII。如果Unicode字符的高9位^([9](footnotes.xhtml#ch10fn9))的二进制表示中包含`0`，则低7位使用标准ASCII码。如果高9位包含非零值，则16位形成扩展字符编码（即从ASCII扩展过来）。如果你在想为什么需要这么多不同的字符编码，值得注意的是，当时某些亚洲字符集包含了4,096个字符。Unicode字符集甚至提供了一组编码，可以用来创建自定义的字符集。65,536个可能的字符编码中，大约一半已经被定义，剩余的字符编码保留用于未来扩展。
- en: Today, Unicode is a universal character set, long replacing ASCII and older
    DBCSs. All modern operating systems (including macOS, Windows, Linux, iOS, Android,
    and Unix), web browsers, and most modern applications provide Unicode support.
    Unicode Consortium, a nonprofit corporation, maintains the Unicode standard. By
    maintaining the standard, Unicode, Inc. (*[https://home.unicode.org](https://home.unicode.org)*),
    helps guarantee that a character you write on one system will display as you expect
    on a different system or application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，Unicode已经成为一个通用字符集，长期取代了ASCII和旧版的双字节字符集（DBCS）。所有现代操作系统（包括macOS、Windows、Linux、iOS、Android和Unix）、网页浏览器以及大多数现代应用程序都支持Unicode。Unicode联盟是一个非营利机构，负责维护Unicode标准。通过维护该标准，Unicode公司（*[https://home.unicode.org](https://home.unicode.org)）帮助确保你在一个系统上写下的字符能够在不同的系统或应用程序中按预期显示。
- en: '**10.6.2 Unicode Code Points**'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.6.2 Unicode代码点**'
- en: Alas, as well thought-out as the original Unicode standard was, it couldn’t
    have anticipated the explosion in characters that would occur. Emojis, astrological
    symbols, arrows, pointers, and a wide variety of symbols introduced for the internet,
    mobile devices, and web browsers have greatly expanded the Unicode symbol repertoire
    (along with a desire to support historic, obsolete, and rare scripts). In 1996,
    systems engineers discovered that 65,536 symbols were insufficient. Rather than
    require 3 or 4 bytes for each Unicode character, those in charge of the Unicode
    definition gave up on trying to create a fixed-size representation of characters
    and allowed for opaque (and multiple) encodings of Unicode characters. Today,
    Unicode defines 1,112,064 code points, far exceeding the 2-byte capacity originally
    set aside for Unicode characters.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜的是，尽管最初的 Unicode 标准设计得非常周到，但它无法预见到字符的激增。表情符号、星座符号、箭头、指针以及为互联网、移动设备和网页浏览器引入的各种符号大大扩展了
    Unicode 符号的范围（同时也带来了对历史、过时和稀有文字的支持需求）。1996年，系统工程师发现 65,536 个符号已经不够用了。为了避免每个 Unicode
    字符需要 3 或 4 个字节，负责 Unicode 定义的人员放弃了创建固定大小字符表示的想法，转而允许 Unicode 字符使用不透明的（且可变的）编码。如今，Unicode
    定义了 1,112,064 个代码点，远超最初为 Unicode 字符设置的 2 字节容量。
- en: A Unicode *code point* is simply an integer value that Unicode associates with
    a particular character symbol; you can think of it as the Unicode equivalent of
    the ASCII code for a character. The convention for Unicode code points is to specify
    the value in hexadecimal with a `U+` prefix; for example, `U+0041` is the Unicode
    code point for the letter *A*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode *代码点* 只是一个整数值，Unicode 将其与特定字符符号关联；你可以将其视为字符的 Unicode 等价物，类似于 ASCII 代码。Unicode
    代码点的约定是以十六进制表示，并以 `U+` 前缀指定；例如，`U+0041` 是字母 *A* 的 Unicode 代码点。
- en: '**NOTE**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*See* [https://en.wikipedia.org/wiki/Unicode#General_Category_property](https://en.wikipedia.org/wiki/Unicode#General_Category_property)
    *for more details on code points.*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*查看更多关于代码点的详细信息，请访问* [https://en.wikipedia.org/wiki/Unicode#General_Category_property](https://en.wikipedia.org/wiki/Unicode#General_Category_property)
    *。*'
- en: '**10.6.3 Unicode Code Planes**'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.6.3 Unicode 编码平面**'
- en: Because of its history, blocks of 65,536 characters are special in Unicode—they
    are known as a *multilingual plane*. The first multilingual plane, `U+000000`
    to `U+00FFFF`, roughly corresponds to the original 16-bit Unicode definition;
    the Unicode standard calls this the *Basic Multilingual Plane (BMP)*. Planes 1
    (`U+010000` to `U+01FFFF`), 2 (`U+020000` to `U+02FFFF`), and 14 (`U+0E0000` to
    `U+0EFFFF`) are supplementary planes. Unicode reserves planes 3 through 13 for
    future expansion and planes 15 and 16 for user-defined character sets.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，Unicode 中的 65,536 个字符块具有特殊意义——它们被称为*多语言平面*。第一个多语言平面，`U+000000` 到 `U+00FFFF`，大致对应于最初的
    16 位 Unicode 定义；Unicode 标准将其称为*基本多语言平面（BMP）*。平面 1（`U+010000` 到 `U+01FFFF`）、平面
    2（`U+020000` 到 `U+02FFFF`）和平面 14（`U+0E0000` 到 `U+0EFFFF`）是补充平面。Unicode 保留平面 3
    到 13 供未来扩展，平面 15 和 16 用于用户自定义字符集。
- en: 'The Unicode standard defines code points in the range `U+000000` to `U+10FFFF`.
    Note that `0x10ffff` is 1,114,111, which is where most of the 1,112,064 characters
    in the Unicode character set come from; the remaining 2,048 code points are reserved
    for use as *surrogates*, which are Unicode extensions. *Unicode scalar* is another
    term you might hear; this is a value from the set of all Unicode code points *except*
    the 2,048 surrogate code points. The HO two hexadecimal digits of the six-digit
    code point value specify the multilingual plane. Why 17 planes? The reason, as
    you’ll see in a moment, is that Unicode uses special multiword entries to encode
    code points beyond `U+FFFF`. Each of the two possible extensions encodes 10 bits,
    for a total of 20 bits; 20 bits gives you 16 multilingual planes, which, plus
    the original BMP, produces 17 multilingual planes. This is also why code points
    fall in the range `U+000000` to `U+10FFFF`: it takes 21 bits to encode the 16
    multilingual planes plus the BMP.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 标准定义了范围为 `U+000000` 到 `U+10FFFF` 的代码点。请注意，`0x10FFFF` 是 1,114,111，这是
    Unicode 字符集中的大部分 1,112,064 个字符的来源；其余的 2,048 个代码点被保留用于作为*替代符*，即 Unicode 扩展。你可能还会听到另一个术语——*Unicode
    标量*；这是指来自所有 Unicode 代码点集合的值，*但不包括*那 2,048 个替代符代码点。六位数的代码点值中的前两位十六进制数字指定了多语言平面。为什么有
    17 个平面？原因是，正如你将看到的，Unicode 使用特殊的多字条目来编码 `U+FFFF` 以外的代码点。每个扩展编码 10 位，共 20 位；20
    位可以表示 16 个多语言平面，加上原始的 BMP，总共 17 个多语言平面。这也是为什么代码点范围是 `U+000000` 到 `U+10FFFF`：编码这
    16 个多语言平面加上 BMP 需要 21 位。
- en: '**10.6.4 Surrogate Code Points**'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.6.4 代理代码点**'
- en: As noted earlier, Unicode began life as a 16-bit (2-byte) character set encoding.
    When it became apparent that 16 bits were insufficient to handle all the possible
    characters that existed at the time, an expansion was necessary. As of Unicode
    v2.0, the Unicode, Inc., organization extended the definition of Unicode to include
    multiword characters. Now Unicode uses surrogate code points (`U+D800` through
    `U+DFFF`) to encode values larger than `U+FFFF`. [Figure 10-8](ch10.xhtml#ch10fig8)
    shows the encoding.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Unicode 最初是一个 16 位（2 字节）字符集编码。当16位的编码容量显然不足以处理当时所有可能的字符时，便需要扩展。从 Unicode
    v2.0 开始，Unicode, Inc. 组织扩展了 Unicode 的定义，以包括多字字符。现在 Unicode 使用代理代码点（`U+D800` 到
    `U+DFFF`）来编码大于 `U+FFFF` 的值。[图 10-8](ch10.xhtml#ch10fig8) 显示了编码方式。
- en: '![Image](../images/10fig08.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig08.jpg)'
- en: '*Figure 10-8: Surrogate code point encoding for Unicode planes 1 through 16*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-8：Unicode 平面 1 到 16 的代理代码点编码*'
- en: Note that the two words (unit 1/high surrogate and unit 2/low surrogate) always
    appear together. The unit 1 value (with HO bits `%110110`) specifies the upper
    10 bits (`b[10]`..`b[19]`) of the Unicode scalar, and the unit 2 value (with HO
    bits `%110111`) specifies the lower 10 bits (`b[0]`..`b[9]`) of the Unicode scalar.
    Therefore, the value of bits `b[16]`..`b[19]` plus 1 specifies Unicode plane 1
    through 16\. Bits `b[0]`..`b[15]` specify the Unicode scalar value within the
    plane.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两个单词（单元 1/高代理和单元 2/低代理）总是一起出现。单元 1 的值（带有 HO 位 `%110110`）指定 Unicode 标量的上
    10 位（`b[10]`..`b[19]`），而单元 2 的值（带有 HO 位 `%110111`）指定 Unicode 标量的下 10 位（`b[0]`..`b[9]`）。因此，位
    `b[16]`..`b[19]` 加 1 的值指定 Unicode 平面 1 到 16。位 `b[0]`..`b[15]` 指定平面内的 Unicode 标量值。
- en: Note that surrogate codes only appear in the BMP. None of the other multilingual
    planes contain surrogate codes. Bits `b[0]`..`b[19]` extracted from the unit 1
    and 2 values always specify a Unicode scalar value (even if the values fall in
    the range `U+D800` through `U+DFFF`).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代理代码仅出现在基本多文种平面（BMP）中。其他多语言平面不包含代理代码。位 `b[0]`..`b[19]` 从单元 1 和 2 提取的值始终指定一个
    Unicode 标量值（即使该值落在 `U+D800` 到 `U+DFFF` 范围内）。
- en: '**10.6.5 Glyphs, Characters, and Grapheme Clusters**'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.6.5 字形、字符和字形簇**'
- en: Each Unicode code point has a unique name. For example, `U+0045` has the name
    “LATIN CAPITAL LETTER A.” Note that the symbol *A* is *not* the name of the character.
    *A* is a *glyph*—a series of strokes (one horizontal and two slanted strokes)
    that a device draws in order to represent the character.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Unicode 码点都有一个唯一的名称。例如，`U+0045` 的名称是 “LATIN CAPITAL LETTER A”。请注意，符号 *A*
    不是字符的名称。*A* 是一个 *字形*——设备通过绘制一系列笔画（一个水平笔画和两个倾斜笔画）来表示该字符。
- en: There are many different glyphs for the single Unicode character “LATIN CAPITAL
    LETTER A.” For example, a Times Roman A and a Times Roman Italic *A* have different
    glyphs, but Unicode doesn’t differentiate between them (or between the *A* character
    in any two different fonts). The character “LATIN CAPITAL LETTER A” remains `U+0045`
    regardless of the font or style you use to draw it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 单一的 Unicode 字符 “LATIN CAPITAL LETTER A” 有许多不同的字形。例如，Times Roman A 和 Times Roman
    Italic *A* 有不同的字形，但 Unicode 不区分它们（也不区分 *A* 字符在任何两种不同字体中的差异）。字符 “LATIN CAPITAL
    LETTER A” 始终是 `U+0045`，无论你使用何种字体或样式来绘制它。
- en: 'As an interesting side note, if you have access to the Swift programming language,
    you can print the name of any Unicode character using the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一句，如果你有使用 Swift 编程语言的权限，你可以通过以下代码打印任何 Unicode 字符的名称：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So, what exactly is a character in Unicode? Unicode scalars are Unicode characters,
    but there’s a difference between what you’d normally call a character and the
    definition of a Unicode character (scalar). For example, is *é* one character
    or two? Consider the following Swift code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Unicode 中的字符究竟是什么？Unicode 标量是 Unicode 字符，但通常所说的字符和 Unicode 字符（标量）的定义之间是有区别的。例如，*é*
    是一个字符还是两个字符？考虑以下 Swift 代码：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`"\u{301}"` is the Swift syntax for specifying a Unicode scalar value within
    a string; in this particular case `301` is the hexadecimal code for the *combining
    acute accent* character.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`"\u{301}"` 是 Swift 语法中指定字符串内 Unicode 标量值的方式；在这个特定的例子中，`301` 是 *组合尖音符* 字符的十六进制代码。'
- en: 'The first `print` statement:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `print` 语句：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: prints the character (producing `é` on the output, as we expect).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 打印该字符（输出 `é`，正如我们所期望的）。
- en: 'The second `print` statement prints the number of characters Swift determines
    are present in the string:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `print` 语句打印出 Swift 确定字符串中包含的字符数量：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This prints `1` to the standard output.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在标准输出中打印 `1`。
- en: 'The third `print` statement prints the number of elements (UTF-16 elements^([10](footnotes.xhtml#ch10fn10)))
    in the string:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个`print`语句打印字符串中的元素数量（UTF-16 元素^([10](footnotes.xhtml#ch10fn10)))：
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This prints `2` on the standard output, because the string holds 2 words of
    UTF-16 data.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这在标准输出中打印 `2`，因为字符串包含 2 个 UTF-16 数据单元。
- en: So, again, is this one character or two? Internally (assuming UTF-16 encoding),
    the computer sets aside 4 bytes of memory for this single character (two 16-bit
    Unicode scalar values).^([11](footnotes.xhtml#ch10fn11)) On the screen, however,
    the output takes only one character position and looks like a single character
    to the user. When this character appears within a text editor and the cursor is
    immediately to the right of the character, the user expects that pressing the
    backspace key will delete it. From the user’s perspective, then, this is a single
    character (as Swift reports when you print the `count` attribute of the string).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这到底是一个字符还是两个字符呢？在内部（假设使用 UTF-16 编码），计算机为这个单一字符分配了 4 字节的内存（两个 16 位 Unicode
    标量值）。^([11](footnotes.xhtml#ch10fn11)) 然而，在屏幕上，输出仅占用一个字符位置，并且看起来就像是一个字符。当这个字符出现在文本编辑器中，并且光标紧挨字符的右侧时，用户期望按下退格键时能够删除它。从用户的角度来看，这确实是一个字符（就像当你打印字符串的
    `count` 属性时 Swift 所报告的那样）。
- en: In Unicode, however, a character is largely equivalent to a code point. This
    is not what people normally think of as a character. In Unicode terminology, a
    *grapheme cluster* is what people normally call a character—it’s a sequence of
    one or more Unicode code points that combine to form a single language element
    (that is, a single character). So, when we talk about characters with respect
    to symbols that an application displays to an end user, we’re really talking about
    grapheme clusters.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Unicode 中，字符大体上等同于一个代码点。这并不是人们通常所认为的字符。在 Unicode 术语中，*字素簇* 是人们通常所称为字符的东西——它是一个或多个
    Unicode 代码点的序列，组合成一个单一的语言元素（即单一字符）。因此，当我们谈论应用程序向终端用户展示的符号时，实际上是在谈论字素簇。
- en: 'Grapheme clusters can make life miserable for software developers. Consider
    the following Swift code (a modification of the earlier example):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 字素簇（Grapheme clusters）可能会让软件开发者感到头痛。考虑以下的 Swift 代码（对之前示例的修改）：
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This code produces the same `é` and `1` outputs from the first two `print`
    statements. The following produces `é`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从前两个 `print` 语句中产生相同的 `é` 和 `1` 输出。以下代码输出 `é`：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: and this `print` statement produces `1`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个 `print` 语句输出的是 `1`。
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, the third `print` statement:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第三个 `print` 语句：
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: displays `3` rather than `2` (as in the original example).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 显示 `3` 而不是原示例中的 `2`。
- en: There are definitely three Unicode scalar values in this string (`U+0065`, `U+0301`,
    and `U+0301`). When printing, the operating system combines the `e` and the two
    acute accent combining characters to form the single character `é` and then outputs
    the character to the standard output device. Swift is smart enough to know that
    this combination creates a single output symbol on the display, so printing the
    result of the `count` attribute continues to output `1`. However, there are (undeniably)
    three Unicode code points in this string, so printing `utf16.count` produces `3`
    on output.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串中无疑有三个 Unicode 标量值（`U+0065`、`U+0301` 和 `U+0301`）。在打印时，操作系统将字符 `e` 和两个急音符组合字符组合成单一字符
    `é`，然后将该字符输出到标准输出设备。Swift 足够聪明，知道这个组合会在显示器上生成一个单一输出符号，因此打印 `count` 属性的结果仍然输出 `1`。然而，这个字符串中确实包含（不可否认的）三个
    Unicode 代码点，因此打印 `utf16.count` 时输出的是 `3`。
- en: '**10.6.6 Unicode Normals and Canonical Equivalence**'
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.6.6 Unicode 标准与规范等价性**'
- en: 'The Unicode character *é* actually existed on personal computers long before
    Unicode came along. It’s part of the original IBM PC character set and also part
    of the Latin-1 character set (used, for example, on old DEC terminals). As it
    turns out, Unicode uses the Latin-1 character set for the code points in the range
    `U+00A0` to `U+00FF`, and `U+00E9` just happens to correspond to the *é* character.
    Therefore, we can modify the earlier program as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 字符 *é* 实际上早在 Unicode 出现之前就已经存在于个人电脑中。它是原始 IBM PC 字符集的一部分，也是 Latin-1
    字符集的一部分（例如在旧款 DEC 终端上使用）。事实证明，Unicode 使用 Latin-1 字符集来表示从 `U+00A0` 到 `U+00FF` 范围内的代码点，而
    `U+00E9` 正好对应于 *é* 字符。因此，我们可以像之前那样修改程序：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And here are the outputs from this program:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该程序的输出：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Ouch! Three different strings all producing `é` but containing a different number
    of code points. Imagine how this complicates programming strings containing Unicode
    characters. For example, if you have the following three strings (Swift syntax)
    and you try to compare them, what will the result be?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！三个不同的字符串都产生 `é`，但包含不同数量的代码点。想象一下，这将如何使得包含 Unicode 字符的编程字符串更加复杂。例如，如果你有以下三个字符串（Swift
    语法），并且尝试比较它们，结果会是什么？
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To the user, all three strings look the same on the screen. However, they clearly
    contain different values. If you compare them to see if they are equal, will the
    result be `true` or `false`?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对用户来说，这三种字符串在屏幕上看起来是相同的。然而，它们明显包含不同的值。如果你比较它们看看是否相等，结果是`true`还是`false`？
- en: Ultimately, that depends upon whose string libraries you’re using. Most current
    string libraries would return `false` if you compared these strings for equality.
    Interestingly enough, Swift will claim that `eAccent1` is equal to `eAccent2`,
    but it isn’t smart enough to report that `eAccent1` is equal to `eAccent3` or
    that `eAccent2` is equal to `eAccent3`—despite the fact that it displays the same
    symbol for all three strings. Many languages’ string libraries simply report that
    all three strings are unequal.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这取决于你使用的字符串库。大多数当前的字符串库在比较这些字符串是否相等时会返回 `false`。有趣的是，Swift 会声称 `eAccent1`
    等于 `eAccent2`，但它不够聪明，无法报告 `eAccent1` 等于 `eAccent3`，或者 `eAccent2` 等于 `eAccent3`——尽管它为所有三个字符串显示相同的符号。许多语言的字符串库简单地报告这三个字符串都不相等。
- en: The three Unicode/Swift strings `"\u{E9}"`, `"e\u{301}"`, and `"e\u{301}\u{301}"`
    all produce the same output on the display. Therefore, they are canonically equivalent
    according to the Unicode standard. Some string libraries won’t report any of these
    strings as being equivalent. Some, like the one accompanying Swift, will handle
    small canonical equivalences (such as `"\u{E9}" == "e\u{301}"`) but not arbitrary
    sequences that should be equivalent (probably a good balance of correctness versus
    efficiency; it can be computationally expensive to handle all the weird cases
    that won’t normally happen, such as `"e\u{301}\u{301}"`).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个 Unicode/Swift 字符串 `"\u{E9}"`、`"e\u{301}"` 和 `"e\u{301}\u{301}"` 在显示上都产生相同的输出。因此，根据
    Unicode 标准，它们是规范等价的。一些字符串库不会报告这些字符串中的任何一个是相等的。像 Swift 附带的字符串库会处理小的规范等价性（例如，`"\u{E9}"
    == "e\u{301}"`），但不会处理那些应该等价的任意序列（可能是正确性与效率之间的一个良好平衡；处理所有那些通常不会发生的奇怪情况（如 `"e\u{301}\u{301}"`）可能在计算上代价较高）。
- en: Unicode defines *normal forms* for Unicode strings. One aspect of normal form
    is to replace canonically equivalent sequences with an equivalent sequence—for
    example, replace `"e\u{309}"` by `"\u{E9}"` or replace `"\u{E9}"` by `"e\u{309}"`
    (usually, the shorter form is preferable). Some Unicode sequences allow multiple
    combining characters. Often, the order of the combining characters is irrelevant
    to producing the desired grapheme cluster. However, it’s easier to compare two
    such strings if the combining characters are in a specified order. Normalizing
    Unicode strings may also produce results whose combining characters always appear
    in a fixed order (thereby improving efficiency of string comparisons).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 定义了*正常形式*用于 Unicode 字符串。正常形式的一个方面是将规范等价的序列替换为等价序列——例如，将 `"e\u{309}"`
    替换为 `"\u{E9}"` 或将 `"\u{E9}"` 替换为 `"e\u{309}"`（通常，较短的形式更为优选）。一些 Unicode 序列允许多个组合字符。通常，组合字符的顺序对于产生期望的字形聚集体是无关紧要的。然而，如果组合字符按指定顺序排列，比较两个这样的字符串会更容易。规范化
    Unicode 字符串还可能产生其组合字符总是按固定顺序出现的结果（从而提高字符串比较的效率）。
- en: '**10.6.7 Unicode Encodings**'
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.6.7 Unicode 编码**'
- en: As of Unicode v2.0, the standard supports a 21-bit character space capable of
    handling over a million characters (though most of the code points remain reserved
    for future use). Rather than use a fixed-size 3-byte (or worse, 4-byte) encoding
    to allow the larger character set, Unicode, Inc., allows different encodings—UTF-32,
    UTF-16, and UTF-8—each with its own advantages and disadvantages.^([12](footnotes.xhtml#ch10fn12))
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Unicode v2.0 起，标准支持一个 21 位的字符空间，能够处理超过百万个字符（尽管大多数代码点仍保留供未来使用）。为了允许更大的字符集，Unicode,
    Inc. 允许不同的编码——UTF-32、UTF-16 和 UTF-8——每种编码都有自己的优缺点。^([12](footnotes.xhtml#ch10fn12))
- en: UTF-32 uses 32-bit integers to hold Unicode scalars. The advantage to this scheme
    is that a 32-bit integer can represent every Unicode scalar value (which requires
    only 21 bits). Programs that require random access to characters in strings—without
    having to search for surrogate pairs—and other constant-time operations are (mostly)
    possible when using UTF-32\. The obvious drawback to UTF-32 is that each Unicode
    scalar value requires 4 bytes of storage—twice that of the original Unicode definition
    and four times that of ASCII characters. It may seem that using two or four times
    as much storage (over ASCII and the original Unicode) is a small price to pay.
    After all, modern machines have several orders of magnitude more storage than
    they did when Unicode first appeared. However, that extra storage has a huge impact
    on performance, because those additional bytes quickly consume cache storage.
    Furthermore, modern string processing libraries often operate on character strings
    8 bytes at a time (on 64-bit machines). With ASCII characters, that means a given
    string function can process up to eight characters concurrently; with UTF-32,
    that same string function can operate on only two characters concurrently. As
    a result, the UTF-32 version will run four times slower than the ASCII version.
    Ultimately, even Unicode scalar values are insufficient to represent all Unicode
    characters (that is, many Unicode characters require a sequence of Unicode scalars),
    so using UTF-32 doesn’t solve the problem.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-32 使用 32 位整数来存储 Unicode 标量值。这种方案的优点在于，32 位整数可以表示每个 Unicode 标量值（只需要 21 位）。需要随机访问字符串中的字符的程序——无需查找代理对——以及其他常数时间操作，在使用
    UTF-32 时（大多）是可能的。UTF-32 的明显缺点是，每个 Unicode 标量值需要 4 个字节的存储空间——是原始 Unicode 定义的两倍，ASCII
    字符的四倍。看起来使用两倍或四倍的存储空间（相比 ASCII 和原始 Unicode）似乎是一个小代价。毕竟，现代计算机的存储容量比 Unicode 刚出现时大了几个数量级。然而，这额外的存储空间对性能有巨大影响，因为这些额外的字节会迅速占用缓存存储空间。此外，现代字符串处理库通常每次操作
    8 字节（在 64 位机器上）。对于 ASCII 字符，这意味着给定的字符串函数可以并发处理最多 8 个字符；而对于 UTF-32，相同的字符串函数只能并发处理
    2 个字符。因此，UTF-32 版本的运行速度会比 ASCII 版本慢四倍。最终，甚至 Unicode 标量值也不足以表示所有 Unicode 字符（即，许多
    Unicode 字符需要一系列 Unicode 标量），所以使用 UTF-32 并不能解决这个问题。
- en: The second encoding format the Unicode supports is UTF-16\. As the name suggests,
    UTF-16 uses 16-bit (unsigned) integers to represent Unicode values. To handle
    scalar values greater than `0xFFFF`, UTF-16 uses the surrogate pair scheme to
    represent values in the range `0x010000` to `0x10FFFF` (see “Surrogate Code Points”
    on [page 323](ch10.xhtml#page_323)). Because the vast majority of useful characters
    fit into 16 bits, most UTF-16 characters require only 2 bytes. For those rare
    cases where surrogates are necessary, UTF-16 requires 2 words (32 bits) to represent
    the character.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 支持的第二种编码格式是 UTF-16。顾名思义，UTF-16 使用 16 位（无符号）整数来表示 Unicode 值。为了处理大于 `0xFFFF`
    的标量值，UTF-16 使用代理对方案来表示范围从 `0x010000` 到 `0x10FFFF` 的值（请参见 [第 323 页](ch10.xhtml#page_323)的“代理代码点”）。因为绝大多数有用字符适合
    16 位表示，所以大多数 UTF-16 字符只需要 2 个字节。对于那些需要代理的少数情况，UTF-16 需要 2 个字（32 位）来表示该字符。
- en: The last encoding, and unquestionably the most popular, is UTF-8\. The UTF-8
    encoding is forward compatible from the ASCII character set. In particular, all
    ASCII characters have a single-byte representation (their original ASCII code,
    where the HO bit of the byte containing the character contains a `0` bit). If
    the UTF-8 HO bit is `1`, then UTF-8 requires between 1 and 3 additional bytes
    to represent the Unicode code point. [Table 10-1](ch10.xhtml#ch10tab1) provides
    the UTF-8 encoding schema.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种编码方式，毫无疑问是最流行的，是 UTF-8。UTF-8 编码与 ASCII 字符集向前兼容。特别是，所有 ASCII 字符都有单字节表示（它们原始的
    ASCII 码，其中包含字符的字节的 HO 位为 `0`）。如果 UTF-8 的 HO 位为 `1`，那么 UTF-8 需要 1 到 3 个附加字节来表示
    Unicode 代码点。[表格 10-1](ch10.xhtml#ch10tab1) 提供了 UTF-8 编码方案。
- en: '**Table 10-1:** UTF Encoding'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 10-1：** UTF 编码'
- en: '| **Bytes** | **Bits for code point** | **First code point** | **Last code
    point** | **Byte 1** | **Byte 2** | **Byte 3** | **Byte 4** |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| **字节数** | **代码点的位数** | **第一个代码点** | **最后一个代码点** | **字节 1** | **字节 2** | **字节
    3** | **字节 4** |'
- en: '| `1` | `7` | `U+00` | `U+7F` | `0`*xxxxxxx* |  |  |  |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `7` | `U+00` | `U+7F` | `0`*xxxxxxx* |  |  |  |'
- en: '| `2` | `11` | `U+80` | `U+7FF` | `110`*xxxxx* | `10`*xxxxxx* |  |  |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `11` | `U+80` | `U+7FF` | `110`*xxxxx* | `10`*xxxxxx* |  |  |'
- en: '| `3` | `16` | `U+800` | `U+FFFF` | `1110`*xxxx* | `10`*xxxxxx* | `10`*xxxxxx*
    |  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `3` | `16` | `U+800` | `U+FFFF` | `1110`*xxxx* | `10`*xxxxxx* | `10`*xxxxxx*
    |  |'
- en: '| `4` | `21` | `U+10000` | `U+10FFFF` | `11110`*xxx* | `10`*xxxxxx* | `10`*xxxxxx*
    | `10`*xxxxxx* |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `4` | `21` | `U+10000` | `U+10FFFF` | `11110`*xxx* | `10`*xxxxxx* | `10`*xxxxxx*
    | `10`*xxxxxx* |'
- en: The “xxx . . . ” bits are the Unicode code point bits. For multibyte sequences,
    Byte 1 contains the HO bits, Byte 2 contains the next HO bits (LO bits compared
    to byte 1), and so on. For example, the 2-byte sequence (`%11011111`, `%10000001`)
    corresponds to the Unicode scalar `%0000_0111_1100_0001` (`U+07C1`).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: “xxx . . . ”位是Unicode代码点位。对于多字节序列，第1字节包含高位位，第2字节包含下一个高位位（与字节1的低位相比），依此类推。例如，2字节序列（`%11011111`，`%10000001`）对应的Unicode标量是`%0000_0111_1100_0001`（`U+07C1`）。
- en: UTF-8 encoding is probably the most common encoding in use. Most web pages use
    it. Most C standard library string functions will operate on UTF-8 text without
    modification (although some C standard library functions can produce malformed
    UTF-8 strings if the programmer isn’t careful with them).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8编码可能是最常用的编码。大多数网页使用它。大多数C标准库字符串函数将处理UTF-8文本而无需修改（尽管一些C标准库函数可能会在程序员不小心的情况下生成格式错误的UTF-8字符串）。
- en: Different languages and operating systems use different encodings as their default.
    For example, macOS and Windows tend to use UTF-16 encoding, whereas most Unix
    systems use UTF-8\. Some variants of Python use UTF-32 as their native character
    format. By and large, though, most programming languages use UTF-8 because they
    can continue to use older ASCII-based character processing libraries to process
    UTF-8 characters. Apple’s Swift is one of the first programming languages that
    attempts to do Unicode right (though there is a huge performance hit for doing
    so).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的语言和操作系统使用不同的编码作为默认编码。例如，macOS和Windows通常使用UTF-16编码，而大多数Unix系统使用UTF-8。Python的一些变种使用UTF-32作为其本地字符格式。不过，总体而言，大多数编程语言使用UTF-8，因为它们可以继续使用基于ASCII的旧字符处理库来处理UTF-8字符。Apple的Swift是最早尝试正确处理Unicode的编程语言之一（尽管这样做会带来巨大的性能损失）。
- en: '**10.6.8 Unicode Combining Characters**'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**10.6.8 Unicode 组合字符**'
- en: Although UTF-8 and UTF-16 encodings are much more compact than UTF-32, the CPU
    overhead and algorithmic complexities of dealing with multibyte (or multiword)
    characters sets complicates their use (introducing bugs and performance issues).
    Despite the issues of wasting memory (especially in the cache), why not simply
    define characters as 32-bit entities and be done with it? This seems like it would
    simplify string processing algorithms, improving performance and reducing the
    likelihood of defects in the code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管UTF-8和UTF-16编码比UTF-32更加紧凑，但处理多字节（或多字）字符集的CPU开销和算法复杂性使得它们的使用变得复杂（可能引入错误和性能问题）。尽管浪费内存（特别是在缓存中）是个问题，为什么不直接将字符定义为32位实体，然后就此了事呢？这看起来能简化字符串处理算法，提高性能，并减少代码中的缺陷概率。
- en: 'The problem with this theory is that you cannot represent all possible grapheme
    clusters with only 21 bits (or even 32 bits) of storage. Many grapheme clusters
    consist of several concatenated Unicode code points. Here’s an example from Chris
    Eidhof and Ole Begemann’s *Advanced Swift* (CreateSpace, 2017):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个理论的问题在于，仅用21位（甚至32位）的存储空间无法表示所有可能的字形簇。许多字形簇由几个连接在一起的Unicode代码点组成。以下是Chris
    Eidhof和Ole Begemann的*高级Swift*（CreateSpace，2017年）中的一个示例：
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Each of these Unicode grapheme clusters produces an identical character: an
    `ó` with a dot underneath the character (this is a character from the Yoruba character
    set). The character sequence (`U+1ECD`, `U+300`) is an `o` with a dot under it
    followed by a combining acute. The character sequence (`U+F2`, `U+323`) is an
    `ó` followed by a combining dot. The character sequence (`U+6F`, `U+323`, `U+300`)
    is an `o` followed by a combining dot, followed by a combining acute. Finally,
    the character sequence (`U+6F`, `U+300`, `U+323`) is an `o` followed by a combining
    acute, followed by a combining dot. All four strings produce the same output.
    Indeed, the Swift string comparisons treat all four strings as equal:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Unicode字形簇都会产生一个相同的字符：带下点的`ó`字符（这是来自约鲁巴字符集的字符）。字符序列（`U+1ECD`，`U+300`）是带下点的`o`，后面跟着一个组合尖音符。字符序列（`U+F2`，`U+323`）是`ó`后跟一个组合点。字符序列（`U+6F`，`U+323`，`U+300`）是`o`，后跟一个组合点，再后跟一个组合尖音符。最后，字符序列（`U+6F`，`U+300`，`U+323`）是`o`，后跟一个组合尖音符，再后跟一个组合点。所有四个字符串都会产生相同的输出。事实上，Swift字符串比较将这四个字符串视为相等：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that there is not a single Unicode scalar value that will produce this
    character. You must combine at least two Unicode scalars (or as many as three)
    to produce this grapheme cluster on the output device. Even if you used UTF-32
    encoding, it would still require two (32-bit) scalars to produce this particular
    output.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并没有单一的 Unicode 标量值可以产生这个字符。你必须至少结合两个 Unicode 标量（或者最多三个）才能在输出设备上显示这个字形簇。即使使用
    UTF-32 编码，仍然需要两个（32 位）标量来产生这个特定的输出。
- en: Emojis present another challenge that can’t be solved using UTF-32\. Consider
    the Unicode scalar `U+1F471`. This prints an emoji of a person with blond hair.
    If we add a skin color modifier to this, we obtain (`U+1F471`, `U+1F3FF`), which
    produces a person with a dark skin tone (and blond hair). In both cases we have
    a single character displaying on the screen. The first example uses a single Unicode
    scalar value, but the second example requires two. There is no way to encode this
    with a single UTF-32 value.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 表情符号提出了另一个挑战，无法通过 UTF-32 解决。考虑 Unicode 标量 `U+1F471`。它显示的是一个金发的人的表情符号。如果我们在此基础上添加皮肤颜色修饰符，则得到（`U+1F471`，`U+1F3FF`），显示的是一个深色肤色（并且有金发）的人。在这两种情况下，屏幕上显示的是一个单一字符。第一个例子使用一个
    Unicode 标量值，而第二个例子则需要两个。没有办法用单个 UTF-32 值来编码这个字符。
- en: The bottom line is that certain Unicode grapheme clusters will require multiple
    scalars, no matter how many bits we assign to the scalar (it’s possible to combine
    30 or 40 scalars into a single grapheme cluster, for example). That means we’re
    stuck dealing with multiword sequences to represent a single “character” regardless
    of how hard we try to avoid it. This is why UTF-32 has never really taken off.
    It doesn’t solve the problem of random access into a string of Unicode characters.
    If you’ve got to deal with normalizing and combining Unicode scalars, it’s more
    efficient to use UTF-8 or UTF-16 encodings.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的结论是，某些 Unicode 字形簇将需要多个标量，不管我们为标量分配多少位（例如，可能将 30 或 40 个标量组合成一个字形簇）。这意味着我们不得不处理多个单词序列来表示一个单一的“字符”，无论我们如何努力避免这种情况。这就是为什么
    UTF-32 从未真正流行的原因。它并没有解决随机访问 Unicode 字符串的问题。如果你必须处理 Unicode 标量的归一化和组合，使用 UTF-8
    或 UTF-16 编码会更高效。
- en: Again, most languages and operating systems today support Unicode in one form
    or another (typically using UTF-8 or UTF-16 encoding). Despite the obvious problems
    with dealing with multibyte character sets, modern programs need to deal with
    Unicode strings rather than simple ASCII strings. Swift, which is almost “pure
    Unicode,” doesn’t even offer much in the way of standard ASCII character support.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如今大多数编程语言和操作系统都以某种形式支持 Unicode（通常使用 UTF-8 或 UTF-16 编码）。尽管处理多字节字符集存在明显问题，但现代程序需要处理
    Unicode 字符串，而不是简单的 ASCII 字符串。几乎“纯 Unicode”的 Swift 甚至没有提供多少标准 ASCII 字符支持。
- en: '**10.7 Unicode String Functions and Performance**'
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.7 Unicode 字符串函数与性能**'
- en: 'Unicode strings have one fundamental problem: because Unicode is a multibyte
    character set, the number of bytes in a character string is not equal to the number
    of characters (or, more importantly, the number of glyphs) in the string. Unfortunately,
    the only way to determine the length of a string is to scan all bytes in the string
    (from the beginning to the end) and count those characters. In this respect, the
    performance of a Unicode string length function will be proportional to the size
    of the string, just as it is for zero-terminated strings.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 字符串有一个根本问题：由于 Unicode 是一种多字节字符集，字符字符串中的字节数并不等于字符串中的字符数（或者更重要的，字形数）。不幸的是，确定字符串长度的唯一方法是扫描字符串中的所有字节（从开始到结束），并计算这些字符。在这方面，Unicode
    字符串长度函数的性能将与字符串的大小成正比，就像零终止字符串一样。
- en: Worse still, the only way to compute the index of a character position in a
    string (that is, the offset in bytes from the beginning of the string) is to scan
    from the beginning of the string and count off the desired number of characters.
    Even zero-terminated (ASCII) strings don’t suffer from this problem. In Unicode,
    functions like substring or insert/delete characters in a string can be very expensive.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，计算字符串中字符位置的索引（即，从字符串开始处的字节偏移量）的唯一方法是从字符串的开头扫描，并计算所需的字符数。即使是零终止（ASCII）字符串也不会遇到这个问题。在
    Unicode 中，像子字符串或插入/删除字符这样的函数可能非常昂贵。
- en: The Swift standard library’s string function performance suffers as a result
    of the language’s Unicode purity. Swift programmers have to exercise caution when
    processing strings because operations that would normally be fast in C/C++ or
    other languages can be a source of performance problems in Swift’s Unicode environment.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 标准库的字符串函数性能受限于语言的 Unicode 纯净性。Swift 程序员在处理字符串时必须小心，因为在 C/C++ 或其他语言中通常很快的操作，在
    Swift 的 Unicode 环境下可能会成为性能问题的根源。
- en: '**10.8 For More Information**'
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**10.8 更多信息**'
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Hyde, Randall. *汇编语言艺术*. 第二版. 旧金山：No Starch Press, 2010。
- en: '———. *Write Great Code, Volume 1: Understanding the Machine*. 2nd ed. San Francisco:
    No Starch Press, 2020.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ———. *编写高效代码，第1卷：理解计算机*. 第二版. 旧金山：No Starch Press, 2020。
