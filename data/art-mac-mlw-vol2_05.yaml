- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 4 NETWORK STATE AND STATISTICS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4 网络状态与统计
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Most Mac malware specimens make extensive use of the network for tasks such
    as exfiltrating data, downloading additional payloads, or communicating with command-and-control
    servers. If you can observe these unauthorized network events, you can turn them
    into a powerful detection heuristic. In this chapter, I’ll show you exactly how
    to create a snapshot of network activity, such as established connections and
    listening sockets, and tie each event to the process responsible for it. This
    information should play a vital role in any malware detection system, as it can
    detect even previously unknown malware.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Mac恶意软件样本会广泛使用网络进行数据外泄、下载额外的负载或与命令与控制服务器通信。如果你能够观察到这些未经授权的网络事件，你可以将它们转化为强大的检测启发式方法。在本章中，我将向你展示如何创建网络活动快照，例如已建立的连接和监听套接字，并将每个事件与其相关的进程关联起来。这些信息应在任何恶意软件检测系统中发挥重要作用，因为它可以检测到甚至是之前未知的恶意软件。
- en: 'I’ll concentrate on two approaches to enumerating network information: the
    proc_pid* APIs and the APIs found in the private *NetworkStatistics* framework.
    You can find complete code for both approaches in the Chapter 4 folder in this
    book’s GitHub repository.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我将集中讨论两种枚举网络信息的方法：proc_pid* APIs和私有*NetworkStatistics*框架中的APIs。你可以在本书GitHub仓库的第4章文件夹中找到这两种方法的完整代码。
- en: Host-Based vs. Network-Centric Collection
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于主机与网络中心的收集
- en: Generally, network information is captured either on the host or externally,
    at the network level (for example, via network security appliances). Though there
    are pros and cons to both approaches, this chapter focuses on the former. For
    malware detection, I prefer the host-based approach, as it can reliably identify
    the specific process responsible for observed network events.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，网络信息要么在主机上捕获，要么在网络级别（例如，通过网络安全设备）外部捕获。尽管这两种方法各有优缺点，但本章重点讨论前者。在恶意软件检测方面，我更倾向于主机级方法，因为它可以可靠地识别导致观察到的网络事件的特定进程。
- en: It’s hard to overstate the value of being able to tie a network event to a process.
    This link allows you to closely inspect the process accessing the network and
    apply other heuristics to it to determine whether it might be malicious. For example,
    a persistently installed, non-notarized binary accessing the network may indeed
    be malware. Identifying the responsible process can also help uncover malware
    trying to masquerade its traffic as legitimate; a standard HTTP/S request originating
    from a signed and notarized browser is probably benign, while the same request
    associated with an unrecognized process is definitely worth examining more closely.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 很难过度强调将网络事件与进程关联起来的价值。这个链接使你能够仔细检查访问网络的进程，并对其应用其他启发式方法，以确定它是否可能是恶意的。例如，一个持久安装的、未经认证的二进制文件访问网络时，可能确实是恶意软件。识别相关进程还可以帮助发现伪装其流量为合法的恶意软件；来自签名和经过认证浏览器的标准HTTP/S请求可能是良性的，而与一个未被识别的进程关联的相同请求，肯定值得更仔细地检查。
- en: Another advantage of collecting networking information at the host level is
    that network traffic is usually encrypted, and a host-based approach can often
    avoid the complexities of network-level encryption, which gets applied later.
    You’ll see this benefit in [Chapter 7](chapter7.xhtml), which covers host-based
    approaches for continuously monitoring networking traffic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机级别收集网络信息的另一个优点是，网络流量通常是加密的，而基于主机的方法通常可以避免后续应用的网络级加密的复杂性。你将在[第7章](chapter7.xhtml)中看到这一点，该章节介绍了用于持续监控网络流量的基于主机的方法。
- en: Malicious Networking Activity
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恶意网络活动
- en: 'Of course, the fact that a program accesses the network doesn’t mean it is
    malware. Most legitimate software on your computer likely uses the network. Still,
    certain types of network activity are more common in malware than in legitimate
    software. Here are a few examples of network activity that you should examine
    more closely:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，程序访问网络并不意味着它是恶意软件。计算机上的大多数合法软件可能都会使用网络。不过，某些类型的网络活动在恶意软件中比在合法软件中更常见。以下是一些你应当更仔细检查的网络活动示例：
- en: '**Listening sockets open to any remote connection** Malware may expose remote
    access by connecting a local shell to a socket that listens for connections from
    an external interface.'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**对任何远程连接开放的监听套接字** 恶意软件可能通过将本地shell连接到监听来自外部接口的连接的套接字，来暴露远程访问。'
- en: ''
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Beacon requests that occur at regular intervals** Implants and other persistent
    malware may regularly check in with their command-and-control servers.'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Beacon请求定期发生** 植入物和其他持久性恶意软件可能会定期与其指挥与控制服务器进行通信。'
- en: ''
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Large amounts of uploaded data** Malware often exfiltrates data from an infected
    system.'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**大量上传数据** 恶意软件通常会从感染的系统中窃取数据。'
- en: 'Let’s consider some examples of malware and their network interactions. We’ll
    start with a specimen known as Dummy (named so by yours truly, as it’s rather
    simple minded). The malware creates an interactive shell that gives a remote attacker
    the ability to execute arbitrary commands on the infected host. Specifically,
    it persistently executes the following bash script containing Python code (which
    I’ve formatted to improve readability):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些恶意软件及其网络交互的例子。我们从一个名为Dummy的样本开始（这个名字是我自己取的，因为它相当简单）。该恶意软件创建了一个交互式shell，允许远程攻击者在感染的主机上执行任意命令。具体来说，它会持久执行以下包含Python代码的bash脚本（我已经格式化以提高可读性）：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code connects to the attacker’s server, found at 185.243.115.230 on port
    1337\. It then duplicates the standard in (stdin), out (stdout), and error (stderr)
    streams (whose file descriptors are 0, 1, and 2, respectively) to the connected
    socket. Lastly, it executes */bin/sh* with the -i flag to complete the setup of
    an interactive reverse shell. If you enumerated network connections on the infected
    host (for example, using the macOS lsof utility, which lists open file descriptors
    from all processes), you would see a connection belonging to this Python-based
    shell:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码连接到攻击者的服务器，位于185.243.115.230，端口为1337。然后，它将标准输入（stdin）、标准输出（stdout）和标准错误输出（stderr）流（文件描述符分别为0、1和2）复制到已连接的套接字。最后，它执行*/bin/sh*并加上-i标志，以完成交互式反向shell的设置。如果你在感染主机上枚举网络连接（例如，使用macOS的lsof工具，列出所有进程的开放文件描述符），你将看到一个属于这个基于Python的shell的连接：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our second example is tied to a suspected Chinese hacker group best known for
    its Alchimist [*sic*] attack framework.^([1](#chapter4-1)) When executed, the
    malicious code drops a dynamic library named *payload.so*. If we open this library
    (originally written in Go) in a decompiler, we can see that it contains logic
    to bind a shell to a listening socket:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个例子与一个涉嫌的中国黑客团体有关，该团体以其Alchimist [*sic*]攻击框架而闻名。^([1](#chapter4-1)) 当执行时，恶意代码会丢下一个名为*payload.so*的动态库。如果我们在反编译器中打开这个库（最初是用Go语言编写的），我们可以看到它包含将shell绑定到监听套接字的逻辑：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It first reads a custom environment variable (NOTTY_PORT) to build a network
    address string of the format *0.0.0.0:port*. If no port is specified, it defaults
    to 4444\. Next, it invokes the Listen method from the Go *net* library to create
    a listening TCP socket. A method named handle_connection handles any connection
    to this socket. Using my network enumeration tool Netiquette ([Figure 4-1](chapter4.xhtml#fig4-1)),
    you can see the malware’s listening socket.^([2](#chapter4-2))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先读取一个自定义环境变量（NOTTY_PORT），以构建一个格式为*0.0.0.0:port*的网络地址字符串。如果没有指定端口，它会默认为4444。接下来，它调用Go
    *net*库中的Listen方法来创建一个监听TCP套接字。一个名为handle_connection的方法处理任何与此套接字的连接。使用我的网络枚举工具Netiquette（[图4-1](chapter4.xhtml#fig4-1)），你可以看到恶意软件的监听套接字。^([2](#chapter4-2))
- en: '![](../images/Figure4-1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-1.jpg)'
- en: 'Figure 4-1: Netiquette showing the listening socket on port 4444'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1：Netiquette显示4444端口上的监听套接字
- en: The astute reader may have noticed that the socket listening on port 4444 is
    tied to a process named *loader* and not directly to the malicious *payload.so*
    library. This is because macOS tracks network events at the process level, not
    at the library level. Unfortunately, the researchers who uncovered the threat
    didn’t obtain the program that hosts the library, so I wrote the *loader* program
    to load and execute the malicious library for dynamic analysis.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的读者可能已经注意到，监听4444端口的套接字与名为*loader*的进程相关，而不是直接与恶意的*payload.so*库相关。这是因为macOS在进程级别跟踪网络事件，而不是在库级别。不幸的是，发现这一威胁的研究人员没有获取到托管该库的程序，因此我编写了*loader*程序来加载并执行恶意库，以进行动态分析。
- en: Any code that uses system APIs to enumerate network connections can identify
    only the process from which the network activity originated. This activity could
    originate directly from code in the process’s main binary or, as is the case here,
    from one of the libraries loaded in its address space, providing yet another reason
    why it’s worth enumerating and analyzing a process’s loaded libraries, as we did
    in [Chapter 1](chapter1.xhtml).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用系统 API 列举网络连接的代码只能识别网络活动来源的进程。此活动可能直接来自进程主二进制文件中的代码，或者如这里所示，来自其地址空间中加载的某个库，这为我们提供了另一个理由，说明为何值得列举和分析进程加载的库，正如我们在
    [第 1 章](chapter1.xhtml) 中所做的那样。
- en: 'Let’s consider one last sample. Rather than invoke a shell, the advanced persistent
    threat (APT) implant oRAT takes the more common approach of establishing a connection
    to an attacker’s command-and- control server. Using this connection, it can receive
    tasking to execute a wide range of actions that afford the remote attack complete
    control over the infected host.^([3](#chapter4-3)) Rather unusually, it performs
    all tasking, as well as regular “heartbeat” check-ins, over a single multiplexed
    persistent connection. We can find the configuration for this connection, such
    as the protocol and address of the server, embedded directly in the oRAT binary.
    The information is encrypted, but as the decryption key is embedded in the binary
    as well, we can easily decrypt or dump it from memory at runtime, as discussed
    in Chapter 9 of *The Art of Mac Malware*, Volume 1\. Here is a snippet of the
    decrypted configuration containing information about the command-and-control server:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑最后一个示例。与调用 shell 不同，先进的持续威胁（APT）植入程序 oRAT 采取了更常见的方式，通过与攻击者的命令与控制服务器建立连接来进行操作。通过这个连接，它可以接收任务，执行广泛的操作，使远程攻击者完全控制感染的主机。^([3](#chapter4-3))
    不同寻常的是，它通过单个多路复用的持久连接执行所有任务，包括定期的“心跳”检查。我们可以在 oRAT 的二进制文件中找到该连接的配置，如协议和服务器地址。虽然这些信息是加密的，但由于解密密钥也嵌入在二进制文件中，我们可以轻松地在运行时解密或从内存中提取出来，正如《Mac
    恶意软件艺术》第一卷第 9 章所讨论的那样。以下是包含命令与控制服务器信息的解密配置片段：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the configuration, the value for the Network key controls whether oRAT will
    communicate over TCP or UDP and whether it will encrypt its network traffic. A
    value of stcp indicates TCP encrypted via Go’s Transport Layer Security (TLS)
    package.^([4](#chapter4-4)) The configuration also reveals that the traffic is
    destined for the command-and-control server at *darwin.github.wiki* and will take
    place over port 53\. Though traffic over this port is traditionally dedicated
    to DNS, there is nothing stopping malware authors from also making use of it,
    perhaps to blend in with legitimate DNS traffic or to slip through firewalls that
    normally allow outgoing traffic on this port.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置中，Network 键的值控制 oRAT 是否通过 TCP 或 UDP 进行通信，以及是否对其网络流量进行加密。值为 stcp 表示通过 Go 的传输层安全（TLS）包加密的
    TCP。^([4](#chapter4-4)) 配置还揭示了流量将发送到位于 *darwin.github.wiki* 的命令与控制服务器，并将通过端口 53
    进行传输。尽管此端口的流量传统上用于 DNS，但没有什么能阻止恶意软件作者利用它，也许是为了与合法的 DNS 流量混淆，或者通过防火墙，它通常允许通过该端口的出站流量。
- en: Once the malware is running, we can readily observe the connection to the attacker’s
    server, either programmatically or manually, via system or third-party networking
    tools. I’ll now focus on the former, showing you how to programmatically enumerate
    sockets and network connections, provide metadata for each, and identify the process
    responsible for the network activity.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件开始运行，我们可以通过系统或第三方网络工具，编程或手动地轻松观察到与攻击者服务器的连接。我将专注于前者，展示如何编程列举套接字和网络连接，为每个连接提供元数据，并识别负责网络活动的进程。
- en: Capturing the Network State
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获网络状态
- en: There are several ways to capture network activity, such as with listening sockets
    and established connections. One method is to use various proc_pid* APIs. This
    workflow is inspired by Palomino Labs’s *get_process_handles* project.^([5](#chapter4-5))
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获网络活动有多种方式，例如使用监听套接字和已建立的连接。一个方法是使用各种 `proc_pid*` API。这一工作流灵感来源于 Palomino Labs
    的 *get_process_handles* 项目。^([5](#chapter4-5))
- en: First, we’ll invoke the proc_pidinfo function with a process ID and the PROC_PIDLISTFDS
    constant to get a list of all file descriptors currently opened by the specified
    process. We’re interested in this list of file descriptors because it will also
    include sockets. To extract just the sockets, we’ll iterate over all the file
    descriptors, focusing on those whose type is set to PROX_FDTYPE_SOCKET.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将调用proc_pidinfo函数，传入进程ID和PROC_PIDLISTFDS常量，以获取指定进程当前打开的所有文件描述符的列表。我们对这个文件描述符列表感兴趣，因为它也会包括套接字。为了只提取套接字，我们将遍历所有文件描述符，关注那些类型设置为PROX_FDTYPE_SOCKET的文件描述符。
- en: Certain socket types have names prefixed with AF, which stands for *address
    family*. Some of these sockets (for example, those whose type is AF_UNIX) are
    local, and programs can use them as an interprocess communication (IPC) mechanism.
    These aren’t generally related to malicious activity, so we can ignore them, especially
    in this context of enumerating network activity. However, for sockets of type
    AF_INET (used for IPv4 connections) or AF_INET6 (used for IPv6 connections), we
    can extract information such as their protocol (UDP or TCP), local port, and address.
    For TCP sockets, we’ll also extract their remote port, address, and state (whether
    it’s listening, established, and so on).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 某些套接字类型的名称以AF为前缀，表示*地址族*。这些套接字中的一些（例如，类型为AF_UNIX的套接字）是本地套接字，程序可以将其用作进程间通信（IPC）机制。这些通常与恶意活动无关，因此我们可以忽略它们，尤其是在枚举网络活动的上下文中。然而，对于类型为AF_INET（用于IPv4连接）或AF_INET6（用于IPv6连接）的套接字，我们可以提取诸如协议（UDP或TCP）、本地端口和地址等信息。对于TCP套接字，我们还将提取它们的远程端口、地址和状态（无论它是监听、已建立连接等）。
- en: Let’s walk through code that implements this functionality, which you can find
    in this chapter’s *enumerateNetworkConnections* project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现此功能的代码进行逐步讲解，您可以在本章的*enumerateNetworkConnections*项目中找到该代码。
- en: '#### Retrieving Process File Descriptors'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 检索进程文件描述符'
- en: We begin with a call to the proc_pidinfo API, passing it a process ID, the PROC
    _PIDLISTFDS flag, and three arguments set to zero to obtain the size needed for
    the full list of the process’s open file descriptors ([Listing 4-1](chapter4.xhtml#Lis4-1)).
    It’s common, especially for older C-based APIs such as proc_pid*, to call the
    function first with a NULL buffer and zero-byte length to obtain the true length
    required to store the data. A subsequent call to the same API with a new size
    and newly allocated buffer will then return the requested data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用proc_pidinfo API，传入进程ID、PROC_PIDLISTFDS标志和三个设置为零的参数，以获取进程打开的所有文件描述符的完整列表所需的大小（[Listing
    4-1](chapter4.xhtml#Lis4-1)）。通常，尤其是对于基于C的旧API（如proc_pid*），我们会先调用该函数，传入一个NULL的缓冲区和零字节的长度，以获取存储数据所需的真实长度。然后，再次调用相同的API，传入新的大小和新分配的缓冲区，就能返回请求的数据。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 4-1: Obtaining a process’s file descriptors'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-1：获取进程的文件描述符
- en: 'Once we’ve obtained this necessary size and allocated an appropriate buffer
    ❶, we reinvoke proc_pidinfo, this time with the buffer and its size, to retrieve
    the process’s file descriptors ❷. When the function returns, the provided buffer
    will contain a list of proc_fdinfo structures: one for each of the process’s open
    file descriptors. The header file *sys/proc_info.h* defines these structures as
    follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了所需的大小并分配了合适的缓冲区❶，我们会重新调用proc_pidinfo，这次传入缓冲区和其大小，以检索进程的文件描述符❷。当函数返回时，提供的缓冲区将包含一个proc_fdinfo结构体的列表：每个结构体对应进程的一个打开的文件描述符。头文件*sys/proc_info.h*定义了这些结构体，如下所示：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'They contain just two members: a file descriptor (proc_fd) and the file descriptor
    type (proc_fdtype).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它们仅包含两个成员：一个文件描述符（proc_fd）和文件描述符类型（proc_fdtype）。
- en: Extracting Network Sockets
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提取网络套接字
- en: With a list of a process’s file descriptors, you can now iterate over each to
    find any sockets ([Listing 4-2](chapter4.xhtml#Lis4-2)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过获取进程的文件描述符列表，您现在可以遍历每个文件描述符，查找任何套接字（[Listing 4-2](chapter4.xhtml#Lis4-2)）。
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 4-2: Iterating over a list of file descriptors ignoring non-sockets'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-2：遍历文件描述符列表，忽略非套接字类型
- en: As the buffer has been populated with a list of proc_fdinfo structures, the
    code scopes the iteration by taking the buffer’s size and dividing it by the PROC_PIDLISTFD_SIZE
    constant to obtain the number of items in the array. This constant conveniently
    holds the proc_fdinfo structure size. Next, the code examines each file descriptor’s
    type by checking the proc_fdtype member of each proc_fdinfo structure. Sockets
    have a type of PROX_FDTYPE _SOCKET; the code ignores file descriptors of any other
    type by executing the continue statement, which causes the current iteration of
    the for loop to terminate prematurely and the next to commence, meaning it will
    begin processing the next file descriptor.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓冲区已填充了一个 `proc_fdinfo` 结构体的列表，代码通过取缓冲区的大小并将其除以 `PROC_PIDLISTFD_SIZE` 常量来确定数组中的项目数量。这个常量便捷地保存了
    `proc_fdinfo` 结构体的大小。接下来，代码通过检查每个 `proc_fdinfo` 结构体的 `proc_fdtype` 成员来检查每个文件描述符的类型。套接字的类型是
    `PROX_FDTYPE_SOCKET`；代码通过执行 `continue` 语句忽略任何其他类型的文件描述符，这会导致当前的 `for` 循环迭代提前终止并开始下一个迭代，也就是说，它会开始处理下一个文件描述符。
- en: Obtaining Socket Details
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取套接字详细信息
- en: 'Now, to get detailed information about the sockets, we invoke the proc_pidfdinfo
    function. It takes five parameters: the process ID, the file descriptor, a value
    indicating the type of information we’re requesting from the file descriptor,
    an out pointer to a structure, and the structure’s size ([Listing 4-3](chapter4.xhtml#Lis4-3)).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了获取关于套接字的详细信息，我们调用 `proc_pidfdinfo` 函数。它接受五个参数：进程 ID、文件描述符、一个指示我们请求的文件描述符信息类型的值、一个指向结构体的输出指针，以及该结构体的大小（[列表
    4-3](chapter4.xhtml#Lis4-3)）。
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 4-3: Obtaining information about a socket file descriptor'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-3：获取套接字文件描述符信息
- en: 'Because we’ll place this code in the for loop iterating over the list of a
    process’s sockets ([Listing 4-2](chapter4.xhtml#Lis4-2)), we can reference each
    socket by indexing into this list: fdInfo[i].proc_fd. The PROC_PIDFDSOCKETINFO
    constant instructs the API to return socket information, while the PROC_PIDFDSOCKETINFO_SIZE
    constant contains the size of a socket_fdinfo structure. You can find both in
    Apple’s *sys/proc_info.h* file.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将把这段代码放入一个遍历进程套接字列表的 `for` 循环中（[列表 4-2](chapter4.xhtml#Lis4-2)），我们可以通过索引此列表来引用每个套接字：`fdInfo[i].proc_fd`。`PROC_PIDFDSOCKETINFO`
    常量指示 API 返回套接字信息，而 `PROC_PIDFDSOCKETINFO_SIZE` 常量包含 `socket_fdinfo` 结构体的大小。你可以在
    Apple 的 *sys/proc_info.h* 文件中找到这两个常量。
- en: I mentioned that not all sockets are related to network activity. As such, the
    code focuses only on the networking sockets whose family is either AF_INET or
    AF_INET6. These sockets are often referred to as Internet Protocol (IP) sockets.
    We can find a socket’s family in the socket_fdinfo structure by examining the
    soi_family member of its psi member ([Listing 4-4](chapter4.xhtml#Lis4-4)).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过，并非所有套接字都与网络活动相关。因此，代码仅关注协议族为 `AF_INET` 或 `AF_INET6` 的网络套接字。这些套接字通常被称为互联网协议（IP）套接字。我们可以通过检查
    `socket_fdinfo` 结构体中 `psi` 成员的 `soi_family` 成员来找到套接字的协议族（[列表 4-4](chapter4.xhtml#Lis4-4)）。
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 4-4: Examining a socket’s family'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-4：检查套接字的协议族
- en: Because we execute this code within the for loop, we skip any non-IP socket
    by executing the continue statement, which advances to the next.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在 `for` 循环中执行这段代码，所以通过执行 `continue` 语句跳过任何非 IP 套接字，直接跳到下一个。
- en: The remainder of the code extracts various information from the socket _fdinfo
    structure and saves it into a dictionary. You’ve already seen this family, which
    should be either AF_INET or AF_INET6 ([Listing 4-5](chapter4.xhtml#Lis4-5)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分从 `socket_fdinfo` 结构体中提取各种信息并将其保存到字典中。你已经看过这个协议族，它应该是 `AF_INET` 或 `AF_INET6`（[列表
    4-5](chapter4.xhtml#Lis4-5)）。
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 4-5: Extracting a socket’s family type'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-5：提取套接字的协议族类型
- en: We can find the socket’s protocol in the soi_kind member of the psi structure.
    (Recall that psi is a socket_info structure.) It’s important to take into account
    the differences between protocols when extracting information from the socket,
    because you’ll have to reference different structures. For UDP sockets, which
    have soi_kind set to SOCKINFO_IN, we use the pri_in member of the soi_proto structure,
    whose type is in_sockinfo. On the other hand, for TCP sockets (SOCKINFO_TCP),
    we use pri_tcp, a tcp_sockinfo structure ([Listing 4-6](chapter4.xhtml#Lis4-6)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `psi` 结构体的 `soi_kind` 成员中找到套接字的协议。（回想一下，`psi` 是一个 `socket_info` 结构体。）在提取套接字信息时，考虑到协议之间的差异非常重要，因为你将需要引用不同的结构体。对于
    UDP 套接字，其 `soi_kind` 设置为 `SOCKINFO_IN`，我们使用 `soi_proto` 结构体中的 `pri_in` 成员，它的类型是
    `in_sockinfo`。另一方面，对于 TCP 套接字（`SOCKINFO_TCP`），我们使用 `pri_tcp`，它是一个 `tcp_sockinfo`
    结构体（[列表 4-6](chapter4.xhtml#Lis4-6)）。
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 4-6: Extracting UDP or TCP socket structures'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-6：提取UDP或TCP套接字结构
- en: Once we’ve identified the appropriate structure, extracting information such
    as the local and remote endpoints for the socket is largely the same for either
    socket type. Even so, UDP sockets generally aren’t bound, so information about
    the remote endpoint won’t always be available. Moreover, these sockets are stateless,
    whereas TCP sockets will have a state.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了合适的结构，从套接字中提取本地和远程端点等信息对于任何套接字类型来说大致相同。尽管如此，UDP套接字通常没有绑定，因此远程端点的信息并不总是可用的。此外，这些套接字是无状态的，而TCP套接字会有状态。
- en: Let’s now look at the code to extract information of interest from a TCP socket,
    starting with both the local and remote ports ([Listing 4-7](chapter4.xhtml#Lis4-7)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下从TCP套接字中提取感兴趣信息的代码，从本地和远程端口开始（[列表 4-7](chapter4.xhtml#Lis4-7)）。
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 4-7: Extracting the local and remote ports from a TCP socket'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-7：从TCP套接字中提取本地和远程端口
- en: We can find the local and remote ports in the insi_lport ❶ and insi_fport ❷
    members of the tcpsi_ini structure, itself an in_sockinfo structure. As these
    ports are stored in network-byte ordering, we convert them to host-byte ordering
    with the ntohs API.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在tcpsi_ini结构体中的insi_lport ❶和insi_fport ❷成员中找到本地和远程端口，tcpsi_ini结构体本身是in_sockinfo结构体。由于这些端口以网络字节序存储，我们通过ntohs
    API将其转换为主机字节序。
- en: Next, we retrieve the local and remote addresses from the same tcpsi_ini structure.
    Which structure members we access depends on whether the addresses are IPv4 or
    IPv6\. In [Listing 4-8](chapter4.xhtml#Lis4-8), we extract IPv4 (AF_INET) addresses.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从相同的tcpsi_ini结构体中检索本地和远程地址。我们访问哪个结构成员取决于地址是IPv4还是IPv6。在[列表 4-8](chapter4.xhtml#Lis4-8)中，我们提取IPv4（AF_INET）地址。
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 4-8: Extracting local and remote IPv4 addresses'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-8：提取本地和远程IPv4地址
- en: As shown in the code, we invoke the inet_ntop function to convert the IP addresses
    to human-readable strings. The local address is in the insi_laddr member ❶, while
    the remote address is in insi_faddr ❷. The addresses specify their maximum length
    using the INET_ADDRSTRLEN constant, which also accounts for a NULL terminator.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，我们调用inet_ntop函数将IP地址转换为人类可读的字符串。当地地址位于insi_laddr成员 ❶中，而远程地址则位于insi_faddr
    ❷中。地址通过INET_ADDRSTRLEN常量指定其最大长度，该常量还包括NULL终止符。
- en: For IPv6 (AF_INET6) sockets, we use the inet_ntop function once again but pass
    it an in6_addr structure (named ina_6 in the in_sockinfo structure). Also note
    that the output buffers should be of size INET6_ADDRSTRLEN ([Listing 4-9](chapter4.xhtml#Lis4-9)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IPv6（AF_INET6）套接字，我们再次使用inet_ntop函数，但传递给它一个in6_addr结构体（在in_sockinfo结构体中命名为ina_6）。还需要注意的是，输出缓冲区的大小应为INET6_ADDRSTRLEN（[列表
    4-9](chapter4.xhtml#Lis4-9)）。
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 4-9: Extracting local and remote IPv6 addresses'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-9：提取本地和远程IPv6地址
- en: 'Finally, we can find the state of the TCP connection (whether it’s closed,
    listening, established, and so on) in the tcpsi_state member of the tcp_sockinfo
    structure. The *sys/proc_info.h* header file defines the possible states as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在tcp_sockinfo结构体的tcpsi_state成员中找到TCP连接的状态（无论是关闭、监听、已建立连接等）。*sys/proc_info.h*头文件定义了可能的状态，如下所示：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In [Listing 4-10](chapter4.xhtml#Lis4-10), we convert a subset of these numeric
    values to human-readable strings with a simple switch statement.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 4-10](chapter4.xhtml#Lis4-10)中，我们使用一个简单的switch语句将这些数值的子集转换为人类可读的字符串。
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 4-10: Converting TCP states (tcpsi_state) to human-readable strings'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-10：将TCP状态（tcpsi_state）转换为人类可读的字符串
- en: Now, what if you wanted to resolve the destination IP address to a domain? One
    option is to use the getaddrinfo API, which can accomplish this synchronously.
    This function will reach out to DNS servers to map the IP address to a domain,
    so you may want to perform this operation in a separate thread or use its asynchronous
    version, getaddrinfo_a. [Listing 4-11](chapter4.xhtml#Lis4-11) shows a simple
    helper function that accepts an IP address as a char* string and then attempts
    to resolve it to a domain and return it as a string object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你想将目标IP地址解析为域名，该怎么办呢？一种选择是使用getaddrinfo API，它可以同步完成此操作。此函数将访问DNS服务器，将IP地址映射到域名，因此你可能希望在一个单独的线程中执行此操作，或者使用其异步版本getaddrinfo_a。[列表
    4-11](chapter4.xhtml#Lis4-11)展示了一个简单的辅助函数，它接受一个IP地址作为char*字符串，然后尝试将其解析为域名并返回为字符串对象。
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 4-11: Resolving an address to a domain'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-11：将地址解析为域名
- en: IP addresses can resolve to multiple hostnames or none at all. The latter case
    is common in malware that includes a hardcoded IP address for its remote server,
    which may not have a domain name entry.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址可能解析为多个主机名，或者根本没有解析到任何主机名。后一种情况在恶意软件中很常见，这些恶意软件包含硬编码的远程服务器 IP 地址，而该地址可能没有域名条目。
- en: The IP address-to-host resolution code first invokes the getaddrinfo function
    with the passed-in IP address ❶. If this call succeeds, it allocates and initializes
    a list of structures of type addrinfo for the specified address, as there may
    be multiple responses. The code then begins iterating over this list ❷, invoking
    the getnameinfo function on the addrinfo structures ❸. If the getnameinfo function
    succeeds, the code converts the name to a string object and exits the loop, though
    it could also keep iterating to build up a list of all resolved names.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址到主机的解析代码首先调用 getaddrinfo 函数，并传入指定的 IP 地址 ❶。如果此调用成功，它会为指定的地址分配并初始化一个 addrinfo
    类型的结构体列表，因为可能会有多个响应。接下来，代码开始遍历这个列表 ❷，在 addrinfo 结构体上调用 getnameinfo 函数 ❸。如果 getnameinfo
    函数成功，代码将该名称转换为字符串对象并退出循环，尽管它也可以继续遍历以构建所有解析名称的列表。
- en: Running the Tool
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行工具
- en: 'Let’s compile and run the network enumeration code, found in the *enumerateNetworkConnections*
    project, on a system that is infected with Dummy. The code looks at only one process
    at a time, so we specify the process ID (96202) belonging to the instance of Dummy’s
    Python script as an argument:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并运行网络枚举代码，该代码位于*enumerateNetworkConnections*项目中，在感染 Dummy 的系统上运行。该代码一次只查看一个进程，因此我们将
    Dummy Python 脚本实例的进程 ID（96202）作为参数指定：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As expected, the tool is able to enumerate Dummy’s connection to the attacker’s
    command-and-control server. Specifically, it shows the information about both
    the local and remote endpoints of the connection, as well as the connection’s
    family, protocol, and state.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，该工具能够枚举 Dummy 与攻击者的指挥控制服务器之间的连接。具体来说，它显示了连接的本地和远程端点的信息，以及连接的协议族、协议和状态。
- en: To improve this code in production, you would likely want to enumerate all network
    connections, not only those for the single process a user specified. You could
    easily extend the code to first retrieve a list of running processes and then
    iterate through this list to enumerate each process’s network connections. Recall
    that in [Chapter 1](chapter1.xhtml) I showed how to retrieve a list of process
    IDs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在生产环境中改进此代码，你可能希望列举所有网络连接，而不仅仅是用户指定的单一进程的连接。你可以轻松扩展代码，首先检索正在运行的进程列表，然后遍历该列表，列举每个进程的网络连接。回想一下，在[第
    1 章](chapter1.xhtml)中，我展示了如何检索进程 ID 列表。
- en: Enumerating Network Connections
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举网络连接
- en: I noted that one minor downside to using the proc_pid* APIs is that they are
    process specific. That is to say they don’t return information about system-wide
    network activity. Although we could easily iterate over each process to get a
    broader look at the system’s network activity, the private *NetworkStatistics*
    framework provides a more efficient way to accomplish this task. It also offers
    statistics about each connection, which can help us detect malware specimens (for
    example, those that exfiltrate large amounts of data from an infected system).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我注意到，使用 proc_pid* API 的一个小缺点是它们是特定于进程的。也就是说，它们不会返回关于系统范围内网络活动的信息。虽然我们可以很容易地遍历每个进程，以更广泛地查看系统的网络活动，但私有的*NetworkStatistics*框架提供了一种更高效的方式来完成此任务。它还提供有关每个连接的统计信息，这有助于我们检测恶意软件样本（例如，那些从感染系统中大量提取数据的恶意软件）。
- en: In this section, we’ll use this framework to take a one-time snapshot of global
    network activity, and in [Chapter 7](chapter7.xhtml), we’ll leverage it to continually
    receive updates about network activity as it occurs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用该框架拍摄全球网络活动的快照，在[第 7 章](chapter7.xhtml)中，我们将利用它持续接收关于网络活动的更新。
- en: 'The *NetworkStatistics* framework underlies a relatively unknown networking
    utility that macOS ships with: nettop. When executed from the terminal, nettop
    displays system-wide network activity grouped by process. Here is the abridged
    output from nettop when run on my Mac:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*NetworkStatistics* 框架是 macOS 随附的一个相对鲜为人知的网络实用工具的基础：nettop。当从终端执行 nettop 时，它会显示按进程分组的系统范围内的网络活动。以下是我在
    Mac 上运行 nettop 时的简化输出：'
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can use otool to see that nettop leverages the *NetworkStatistics* framework.
    In older versions of macOS, you’ll find this framework in */System/Library/PrivateFrameworks/*,
    while on newer versions, it’s stored in the *dyld* shared cache:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用otool查看nettop如何利用*NetworkStatistics*框架。在旧版macOS中，您会在*/System/Library/PrivateFrameworks/*目录下找到此框架，而在新版中，它存储在*dyld*共享缓存中：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let’s programmatically enumerate system-wide network activity using this framework,
    which can provide us with network statistic objects representing listening sockets,
    network connections, and more. The macOS guru Jonathan Levin first documented
    this approach in his netbottom command line tool.^([6](#chapter4-6)) The code
    presented in this section, and in this chapter’s *enumerateNetworkStatistics*
    project, is directly inspired by his project.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编程方式使用这个框架枚举全系统的网络活动，它可以为我们提供表示监听套接字、网络连接等的网络统计对象。macOS大师Jonathan Levin首先在他的netbottom命令行工具中记录了这种方法。（^([6](#chapter4-6))）本节中展示的代码，以及本章的*enumerateNetworkStatistics*项目，直接受到了他的项目启发。
- en: '#### Linking to NetworkStatistics'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 链接到NetworkStatistics'
- en: Any program that leverages a framework must either be linked in at compile time
    or dynamically loaded at runtime. In Xcode, you can add a framework to the Link
    Binary with Libraries list under Build Phases ([Figure 4-2](chapter4.xhtml#fig4-2)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用框架的程序必须在编译时链接，或者在运行时动态加载。在Xcode中，您可以在“构建阶段”下的“链接二进制文件与库”列表中添加框架（[图4-2](chapter4.xhtml#fig4-2)）。
- en: '![](../images/Figure4-2.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-2.jpg)'
- en: 'Figure 4-2: Linking to the NetworkStatistics framework'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2：链接到NetworkStatistics框架
- en: Because the *NetworkStatistics* framework is private, there is no publicly available
    header file, so you’ll have to manually define its APIs and constants. For example,
    you can create an instance of a network statistic manager using the NStatManagerCreate
    API, but you must first define this API, as shown in [Listing 4-12](chapter4.xhtml#Lis4-12).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*NetworkStatistics*框架是私有的，因此没有公开的头文件，所以您必须手动定义其API和常量。例如，您可以使用NStatManagerCreate
    API创建网络统计管理器，但必须首先定义此API，如[清单4-12](chapter4.xhtml#Lis4-12)所示。
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 4-12: A function definition for the private NStatManagerCreate API'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-12：私有NStatManagerCreate API的函数定义
- en: Similarly, you must define all constants, such as the keys in the dictionary
    that describe each network statistic object. For example, [Listing 4-13](chapter4.xhtml#Lis4-13)
    shows how you would define kNStatSrcKeyPID, the key that holds the ID of the process
    responsible for the network connection in question.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您必须定义所有常量，例如描述每个网络统计对象的字典中的键。例如，[清单4-13](chapter4.xhtml#Lis4-13)展示了如何定义kNStatSrcKeyPID，这是保存负责网络连接的进程ID的键。
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 4-13: A definition of the private kNStatSrcKeyPID constant'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-13：私有kNStatSrcKeyPID常量的定义
- en: See this chapter’s *enumerateNetworkStatistics* project’s header file for all
    function and constant definitions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本章的*enumerateNetworkStatistics*项目的头文件，以获取所有函数和常量定义。
- en: Creating Network Statistic Managers
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建网络统计管理器
- en: Now that we’ve linked to the *NetworkStatistics* framework and defined the necessary
    APIs and constants, it’s time to write some code. In [Listing 4-14](chapter4.xhtml#Lis4-14),
    we create a network statistic manager via the NStatManagerCreate API. This manager
    is an opaque object required for subsequent *NetworkStatistics* API calls.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经链接到*NetworkStatistics*框架并定义了必要的API和常量，接下来是编写代码。在[清单4-14](chapter4.xhtml#Lis4-14)中，我们通过NStatManagerCreate
    API创建了一个网络统计管理器。这个管理器是一个不透明对象，后续的*NetworkStatistics* API调用需要它。
- en: As its first parameter, NStatManagerCreate API takes a memory allocator. Here,
    we use the default allocator, kCFAllocatorDefault. The second parameter is a dispatch
    queue, where we’ll execute the callback block specified in the third argument.
    I recommend using a custom dispatch queue rather than the main thread’s dispatch
    queue to avoid overusing, and potentially blocking, the main thread.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: NStatManagerCreate API的第一个参数是内存分配器。在这里，我们使用默认分配器kCFAllocatorDefault。第二个参数是一个调度队列，我们将在其中执行第三个参数指定的回调块。我建议使用自定义调度队列，而不是主线程的调度队列，以避免过度使用并可能阻塞主线程。
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 4-14: Initializing a network statistic manager'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-14：初始化网络统计管理器
- en: 'After we initialize the dispatch queue ❶, we invoke NStatManagerCreate to create
    a manager object. The last parameter for this API is a callback block that the
    framework will invoke during a query. It takes two arguments: an NStatSourceRef
    object representing a network statistic and an integer whose meaning is unknown
    (but that also doesn’t appear relevant to our code) ❷. In the next section, I’ll
    explain how to extract network information of interest when the framework invokes
    this callback.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化调度队列❶之后，我们调用NStatManagerCreate来创建一个管理对象。这个API的最后一个参数是一个回调块，框架会在查询期间调用它。它接受两个参数：一个表示网络统计信息的NStatSourceRef对象，以及一个整数，其含义不明（但似乎与我们的代码无关）❷。在下一节中，我将解释当框架调用这个回调时，如何提取感兴趣的网络信息。
- en: Defining Callback Logic
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义回调逻辑
- en: 'The framework will invoke the NStatManagerCreate callback block automatically
    when we kick off a query using the NStatManagerQueryAllSourcesDescriptions API,
    which is discussed shortly. To extract information from each network statistic
    object passed into the callback block, we invoke the NStatSourceSetDescriptionBlock
    API to specify yet another callback block. Here is this function’s definition:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用NStatManagerQueryAllSourcesDescriptions API启动查询时，框架会自动调用NStatManagerCreate回调块，这将在稍后讨论。为了从传入回调块的每个网络统计对象中提取信息，我们调用NStatSourceSetDescriptionBlock
    API来指定另一个回调块。以下是该函数的定义：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We call this function with the NStatSourceRef object and a callback block, which
    the framework will invoke asynchronously with a dictionary containing information
    about the network statistic object ([Listing 4-15](chapter4.xhtml#Lis4-15)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用NStatSourceRef对象和一个回调块来调用这个函数，框架将在异步调用时，传入一个包含网络统计信息对象的字典（参见[列表4-15](chapter4.xhtml#Lis4-15)）。
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 4-15: Setting a description callback block'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-15：设置描述回调块
- en: As it stands, the code won’t perform any operation until we start a query. Once
    we’ve started a query, it will invoke this block; for now, we simply print out
    the dictionary that describes the network statistic object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，代码在启动查询之前不会执行任何操作。一旦启动查询，它将调用此块；目前，我们只是简单地打印出描述网络统计对象的字典。
- en: Starting Queries
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动查询
- en: Before starting a query, we must tell the framework what network statistics
    we’re interested in. For statistics on all TCP and UDP network sockets and connections,
    we invoke the NStatManagerAddAllTCP and NStatManagerAddAllUDP functions, respectively.
    As you can see in [Listing 4-16](chapter4.xhtml#Lis4-16), both take a network
    statistic manager (which we’ve previously created) as their only argument.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始查询之前，我们必须告诉框架我们感兴趣的网络统计信息。对于所有TCP和UDP网络套接字及连接的统计信息，我们分别调用NStatManagerAddAllTCP和NStatManagerAddAllUDP函数。如[列表4-16](chapter4.xhtml#Lis4-16)所示，这两个函数的唯一参数是一个我们之前创建的网络统计管理器。
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 4-16: Querying for statistics about TCP and UDP network events'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-16：查询TCP和UDP网络事件的统计信息
- en: Now we can kick off the query via the NStatManagerQueryAllSourcesDescriptions
    function ([Listing 4-17](chapter4.xhtml#Lis4-17)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过NStatManagerQueryAllSourcesDescriptions函数启动查询（参见[列表4-17](chapter4.xhtml#Lis4-17)）。
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 4-17: Querying all network sources'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-17：查询所有网络源
- en: Once we invoke the NStatManagerQueryAllSourcesDescriptions function ❶, the network
    statistic query will begin, invoking the callback block we set for each network
    statistic object to provide a comprehensive snapshot of the current state of the
    network.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们调用NStatManagerQueryAllSourcesDescriptions函数❶，网络统计查询就会开始，框架会为每个网络统计对象调用我们设置的回调块，以提供当前网络状态的全面快照。
- en: The NStatManagerQueryAllSourcesDescriptions function takes the network statistic
    manager and yet another callback block to invoke when the network query completes.
    In this implementation, we’re interested in a one-time snapshot of the network,
    so we signal a semaphore ❷ on which the main thread is waiting ❸. When the query
    completes, we clean up the network statistic manager using the NStatManagerDestroy
    function ❹.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: NStatManagerQueryAllSourcesDescriptions函数接受网络统计管理器和另一个回调块，该回调块将在网络查询完成时被调用。在此实现中，我们感兴趣的是网络的快照，因此我们会发送一个信号量❷，主线程会在此信号量上等待❸。查询完成后，我们使用NStatManagerDestroy函数清理网络统计管理器❹。
- en: Running the Tool
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行工具
- en: 'If we compile and run this code, it will enumerate all network connections
    and listening sockets, including Dummy’s remote shell connection:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译并运行这段代码，它将枚举所有网络连接和监听套接字，包括Dummy的远程Shell连接：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The local address (kNStatSrcKeyLocal) and remote address (kNStatSrcKeyRemote)
    are stored in NSData objects, which contain sockaddr_in or sockaddr_in6 structures.
    If you want to convert them into printable strings, you’ll need to invoke routines
    such as inet_ntop. [Listing 4-18](chapter4.xhtml#Lis4-18) shows the code to do
    this.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本地地址（kNStatSrcKeyLocal）和远程地址（kNStatSrcKeyRemote）存储在NSData对象中，这些对象包含sockaddr_in或sockaddr_in6结构。如果你想将它们转换为可打印的字符串，你需要调用像inet_ntop这样的例程。[Listing
    4-18](chapter4.xhtml#Lis4-18)展示了实现这一操作的代码。
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 4-18: Converting a data object into a human-readable address and port'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-18：将数据对象转换为人类可读的地址和端口
- en: 'This simple helper function accepts a network statistic address and then extracts
    and formats the port and IP address for both IPv4 ❶ and IPv6 addresses ❷. Here,
    it prints out both the source and destination endpoints ❸ to provide more readable
    output. As an example, the following output displays statistics about Dummy’s
    reverse shell:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的辅助函数接受一个网络统计地址，然后提取并格式化IPv4 ❶和IPv6地址 ❷的端口和IP地址。在这里，它打印出源端点和目标端点 ❸，以提供更可读的输出。例如，以下输出显示了关于Dummy反向Shell的统计信息：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Although not shown in this abridged output, the network statistic dictionary
    also contains kNStatSrcKeyTxBytes and kNStatSrcKeyRxBytes keys, which hold the
    number of bytes uploaded and downloaded, respectively. [Listing 4-19](chapter4.xhtml#Lis4-19)
    shows how one might programmatically extract these traffic statistics as unsigned
    long integers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个简化的输出中未显示，网络统计字典还包含kNStatSrcKeyTxBytes和kNStatSrcKeyRxBytes键，分别表示上传和下载的字节数。[Listing
    4-19](chapter4.xhtml#Lis4-19)展示了如何以编程方式提取这些流量统计数据作为无符号长整型数值。
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 4-19: Extracting traffic statistics'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-19：提取流量统计信息
- en: This data can help us gain insight into traffic trends. For example, a connection
    with a large number of uploaded bytes tied to an unknown process may reveal malware
    exfiltrating a large amount of data to a remote server.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据可以帮助我们洞察流量趋势。例如，一个上传字节数非常大的连接，且与一个未知进程相关，可能会揭示恶意软件正在向远程服务器泄露大量数据。
- en: Conclusion
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: The majority of malware interacts with the network, providing us with the opportunity
    to build powerful heuristics. In this chapter, I presented two methods of programmatically
    enumerating the state of a network and then associating this state with the responsible
    processes. The ability to identify the process responsible for a listening socket
    or established connection is essential for accurately detecting malware and is
    one of the main advantages of host-based approaches over network-centric ones.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数恶意软件与网络进行交互，这为我们提供了构建强大启发式方法的机会。在本章中，我介绍了两种程序化枚举网络状态并将该状态与相应进程关联的方法。能够识别负责监听套接字或已建立连接的进程是准确检测恶意软件的关键，是基于主机的方法相对于以网络为中心的方法的主要优势之一。
- en: So far, we’ve built heuristics based on information gleaned from processes (in
    [Chapter 1](chapter1.xhtml)), binaries (in [Chapter 2](chapter2.xhtml)), code
    signing (in [Chapter 3](chapter3.xhtml)), and the network (in this chapter). But
    the operating system provides other sources of detection as well. In the next
    chapter, you’ll dive into the detection of persistence techniques.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经根据从进程（在[第1章](chapter1.xhtml)）、二进制文件（在[第2章](chapter2.xhtml)）、代码签名（在[第3章](chapter3.xhtml)）以及网络（在本章）中获取的信息，构建了启发式方法。但操作系统也提供了其他检测来源。在下一章中，你将深入了解持久化技术的检测。
- en: Notes
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '[  1](#chapter4_1).  Patrick Wardle, “The Mac Malware of 2022,” Objective-See,
    January 1, 2023, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x71<wbr>.html#<wbr>-insekt*](https://objective-see.org/blog/blog_0x71.html#-insekt).'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  1](#chapter4_1).  Patrick Wardle，《2022年Mac恶意软件》，Objective-See，2023年1月1日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x71<wbr>.html#<wbr>-insekt*](https://objective-see.org/blog/blog_0x71.html#-insekt)。'
- en: '[  2](#chapter4_2).  See [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/products<wbr>/netiquette<wbr>.html*](https://objective-see.org/products/netiquette.html).'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  2](#chapter4_2).  见[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/products<wbr>/netiquette<wbr>.html*](https://objective-see.org/products/netiquette.html)。'
- en: '[  3](#chapter4_3).  Patrick Wardle, “Making oRAT Go,” paper presented at Objective
    by the Sea v5, Spain, October 7, 2022, [*https://<wbr>objectivebythesea<wbr>.org<wbr>/v5<wbr>/talks<wbr>/OBTS<wbr>_v5<wbr>_pWardle<wbr>.pdf*](https://objectivebythesea.org/v5/talks/OBTS_v5_pWardle.pdf).'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  3](#chapter4_3).  Patrick Wardle，《让oRAT启动》，在西班牙Objective by the Sea v5大会上发表的论文，2022年10月7日，[*https://<wbr>objectivebythesea<wbr>.org<wbr>/v5<wbr>/talks<wbr>/OBTS<wbr>_v5<wbr>_pWardle<wbr>.pdf*](https://objectivebythesea.org/v5/talks/OBTS_v5_pWardle.pdf)。'
- en: '[  4](#chapter4_4).  Daniel Lunghi and Jaromir Horejsi, “New APT Group Earth
    Berberoka Targets Gambling Websites with Old and New Malware,” TrendMicro, April
    27, 2022, [*https://<wbr>www<wbr>.trendmicro<wbr>.com<wbr>/en<wbr>_ph<wbr>/research<wbr>/22<wbr>/d<wbr>/new<wbr>-apt<wbr>-group<wbr>-earth<wbr>-berberoka<wbr>-targets<wbr>-gambling<wbr>-websites<wbr>-with<wbr>-old<wbr>.html*](https://www.trendmicro.com/en_ph/research/22/d/new-apt-group-earth-berberoka-targets-gambling-websites-with-old.html).'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  4](#chapter4_4). 丹尼尔·伦吉和贾罗米尔·霍雷西，“新APT组织Earth Berberoka通过旧和新恶意软件攻击赌博网站”，趋势科技，2022年4月27日，[*https://<wbr>www<wbr>.trendmicro<wbr>.com<wbr>/en<wbr>_ph<wbr>/research<wbr>/22<wbr>/d<wbr>/new<wbr>-apt<wbr>-group<wbr>-earth<wbr>-berberoka<wbr>-targets<wbr>-gambling<wbr>-websites<wbr>-with<wbr>-old<wbr>.html*](https://www.trendmicro.com/en_ph/research/22/d/new-apt-group-earth-berberoka-targets-gambling-websites-with-old.html)。'
- en: '[  5](#chapter4_5).  See [*https://<wbr>github<wbr>.com<wbr>/palominolabs<wbr>/get<wbr>_process<wbr>_handles*](https://github.com/palominolabs/get_process_handles).'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  5](#chapter4_5). 参见 [*https://<wbr>github<wbr>.com<wbr>/palominolabs<wbr>/get<wbr>_process<wbr>_handles*](https://github.com/palominolabs/get_process_handles)。'
- en: '[  6](#chapter4_6).  See [*http://<wbr>newosxbook<wbr>.com<wbr>/src<wbr>.jl<wbr>?tree<wbr>=listings&file<wbr>=netbottom<wbr>.c*](http://newosxbook.com/src.jl?tree=listings&file=netbottom.c).'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  6](#chapter4_6). 参见 [*http://<wbr>newosxbook<wbr>.com<wbr>/src<wbr>.jl<wbr>?tree<wbr>=listings&file<wbr>=netbottom<wbr>.c*](http://newosxbook.com/src.jl?tree=listings&file=netbottom.c)。'
