- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Working with Preexisting Images
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用已有的图像
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: 'Sketch 13: Loading and Displaying an Image'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 13：加载并显示图像
- en: 'Images are everywhere in cyberspace, and even people without explicit computer
    skills know the names of the image formats, or at least the file suffixes: GIF,
    JPEG, BMP, PNG, and so on. Each of these sequences of letters is symbolic of a
    different way of storing images in computer form, and each has specific pros and
    cons for different purposes. GIF images were developed for use on the early internet,
    and they can have transparent color as well as the ability to store animations.
    The JPEG (or JPG) format is used by almost all digital cameras, and it compresses
    pictures into relatively few bytes.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图像在网络空间无处不在，即使是没有显式计算机技能的人，也知道图像格式的名称，或者至少知道文件后缀：GIF、JPEG、BMP、PNG 等等。这些字母组合象征着不同的方式来以计算机形式存储图像，每种格式都有其特定的优缺点，适用于不同的目的。GIF
    图像是为早期互联网使用而开发的，它们支持透明颜色，并且能够存储动画。JPEG（或 JPG）格式被几乎所有数码相机使用，并且能够将图片压缩成相对较少的字节。
- en: You should recognize the importance of images and how complex a task it is to
    read data from one of these file formats. A program to read most GIF files would
    require more than a thousand lines of code. The fact that Processing provides
    an easy-to-use facility to read, display, and write images is one of its many
    advantages over other programming languages.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该认识到图像的重要性以及从这些文件格式中读取数据的复杂性。一个用来读取大多数 GIF 文件的程序可能需要超过一千行代码。Processing 提供了一个易于使用的功能来读取、显示和写入图像，这是它相较于其他编程语言的许多优势之一。
- en: Processing has a type that represents an image, much as an integer is represented
    by the `int` type, and the system can read an image file into a variable with
    one call to a function. The type is `PImage` (short for *Processing Image*), and
    the function is `loadImage()`. For the image to load, it should be saved in the
    same folder as the sketch file, or in a subfolder called *data*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 中有一个类型表示图像，就像整数用 `int` 类型表示一样，系统可以通过调用一个函数将图像文件读取到变量中。这个类型是 `PImage`（*Processing
    图像* 的缩写），而函数是 `loadImage()`。为了加载图像，图像应该保存在与草图文件相同的文件夹中，或保存在名为 *data* 的子文件夹中。
- en: Example A
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 A
- en: 'Let’s assume that an image file named *image.jpg* exists and that we want to
    read this image and display it in the sketch window. The first thing to do is
    declare a `PImage` variable, `im`, into which we’ll place the image 1. Inside
    of `setup()`, we will create a sketch window (using `size()`) and read the image.
    The following statement reads the image and assigns it to the variable `im`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个名为 *image.jpg* 的图像文件，我们想读取该图像并将其显示在草图窗口中。首先要做的是声明一个 `PImage` 变量 `im`，并将图像放入其中。然后，在
    `setup()` 函数内，我们将创建一个草图窗口（使用 `size()`）并读取图像。以下语句读取图像并将其分配给变量 `im`：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now the image data is stored in some internal form in the variable `im`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，图像数据以某种内部形式存储在变量 `im` 中。
- en: 'Displaying the image is done from the `draw()` function, although it could
    be done in this instance from `setup()` as well. The Processing system gives us
    a function named `image()` that will draw a `PImage` into the sketch window at
    a particular (*x*, *y*) location (specifying the location of the upper-left corner
    of the image). The following call draws the image so that its upper-left corner
    corresponds to the window’s upper-left corner:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 显示图像是在 `draw()` 函数中完成的，尽管在这个例子中也可以从 `setup()` 中完成。Processing 系统提供了一个名为 `image()`
    的函数，该函数将在草图窗口的特定 (*x*, *y*) 位置绘制一个 `PImage`（指定图像的左上角位置）。以下调用会将图像绘制，使其左上角与窗口的左上角对齐：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example B
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 B
- en: This program is the same as Example A, but it draws the image at location `(150,
    30)` 1. Now the image is more neatly displayed in the available space.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序与示例 A 相同，但它将图像绘制在位置 `(150, 30)` 1。现在图像在可用空间中更加整齐地显示。
- en: 'Sketch 14: Images—Theory and Practice'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 14：图像——理论与实践
- en: Images are used often in the visual arts, and Processing was designed for artists,
    so it’s no surprise that images are pretty easy to use in the program. There are
    some basic things you need to know, though.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图像在视觉艺术中被广泛使用，Processing 是为艺术家设计的，所以图像在程序中使用起来非常简单也不意外。不过，还是有一些基本的内容需要了解。
- en: One is that for an image to be used on a computer, it must be digitized; that
    is, it must be turned into numbers. If an image was not created by a computer
    in the first place, then it has to be scanned or photographed, and each location
    on the original image must be given a number indicating the color seen there.
    The result is a two-dimensional array of numbers, each of which represents the
    color at a specific location. Each small area of an image is considered to be
    uniform in color, even if it’s not, so the most prominent color is selected to
    represent the entire area. This color is stored at the corresponding (*x*, *y*)
    location in the internal representation, and it’s called a picture element, or
    pixel for short. The complete collection of these pixels is an approximation of
    the original image. Drawing an image on screen means setting the pixels on a portion
    of the computer screen to match those in the image. This is what the `image()`
    function does in Processing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是，要在计算机上使用图像，必须将其数字化；也就是说，必须将其转化为数字。如果图像最初不是由计算机创建的，那么它必须经过扫描或拍照处理，每个原始图像上的位置都必须赋予一个数字，表示该位置的颜色。结果是一个二维的数字数组，每个数字表示特定位置的颜色。图像中的每个小区域被认为是颜色统一的，即使实际上并非如此，因此选取最突出的颜色来代表整个区域。这个颜色被存储在内部表示中的对应(*x*,
    *y*)位置，它被称为图像元素，简称为像素。所有这些像素的完整集合是对原始图像的近似。将图像绘制到屏幕上意味着将计算机屏幕上一部分的像素设置为与图像中的像素匹配。这正是`image()`函数在Processing中的作用。
- en: Images are most often thought of as being *N*×*M* pixels in size, where *N*
    is the number of rows and *M* is the number of columns. The total number of pixels
    in such an image is *N*×*M*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图像通常被认为是*N*×*M*像素大小，其中*N*是行数，*M*是列数。这样的图像的总像素数是*N*×*M*。
- en: 'The `PImage` data type offers programmers a variety of ways to access the pixels
    in an image and manipulate them. Properties of an image can be accessed using
    “.” (dot) notation. For a `PImage` variable named `myImage`, for example, we have
    the following properties:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`PImage`数据类型为程序员提供了多种访问图像像素并操作它们的方式。可以使用“.”（点）符号来访问图像的属性。例如，对于一个名为`myImage`的`PImage`变量，我们有以下属性：'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We often wish to create a graphics area that is the same size as a particular
    image, but the `size()` function in `setup()` can only use constants to set the
    window size. To get around this, we can add `surface.setResizable(true)` to `setup()`.
    It lets us resize the graphics area while the sketch is running with a call to
    `surface.setSize()`, which can use non-constants like `myImage.width`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们常常希望创建一个与特定图像大小相同的图形区域，但`setup()`中的`size()`函数只能使用常量来设置窗口大小。为了解决这个问题，我们可以在`setup()`中添加`surface.setResizable(true)`。它允许我们在草图运行时通过调用`surface.setSize()`来调整图形区域的大小，该函数可以使用诸如`myImage.width`这样的非常量。
- en: 'Individual pixel values can be accessed using functions that return or set
    colors based on (*x, y*) coordinates:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用返回或设置基于(*x, y*)坐标的颜色的函数来访问单个像素的值：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we simply call `get()` or `set()` with no image specified, Processing assumes
    that the image being referenced is whatever is being displayed in the sketch window.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仅仅调用`get()`或`set()`而没有指定图像，Processing会假设所引用的图像就是当前在草图窗口中显示的图像。
- en: Example A
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 A
- en: This sketch reads an image file and checks to see if it was read in successfully
    1; if not, the program is ended by calling the function named `exit()`. The `loadImage()`
    function returns a special value named `null` if the image could not be read,
    so that can be used as an indicator that the image file, for example, was not
    found. If the image is okay, the program sets the size of the sketch window to
    be the same size as that image, using the image’s `width` and `height` properties
    2. When the `setup()` function displays the image, it will fill the entire window.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图读取一个图像文件，并检查是否成功读取1；如果没有，程序会通过调用名为`exit()`的函数来结束。`loadImage()`函数如果无法读取图像，会返回一个名为`null`的特殊值，作为图像文件未找到的指示符。例如，图像文件未找到。如果图像正常，程序会使用图像的`width`和`height`属性2，将草图窗口的大小设置为与图像相同。当`setup()`函数显示图像时，它会填满整个窗口。
- en: Example B
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 B
- en: The second sketch does not call `exit()` if the image file can’t be opened.
    Instead, it displays an error message in the graphics window 1.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个草图如果无法打开图像文件，不会调用`exit()`。相反，它会在图形窗口中显示一个错误信息1。
- en: 'Sketch 15: Manipulating Images I—Aspect Ratio'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 15：图像操作 I——纵横比
- en: 'In the previous sketch we used the size of an image to define the size of the
    sketch window. It’s also possible to change the size of an image so that it fits
    into an existing space. The `resize()` function, part of the `PImage` data type,
    can be used to specify a new size for an image. It does not make a copy but resizes
    the `PImage` itself. Here’s an example call to this function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的草图中，我们使用图像的大小来定义草图窗口的大小。也可以改变图像的大小，使其适应已有的空间。`resize()` 函数是 `PImage` 数据类型的一部分，可以用来指定图像的新大小。它不会创建副本，而是直接调整
    `PImage` 本身的大小。以下是对该函数的示例调用：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This call will cause the image stored in the `img` variable to be expanded or
    contracted to be `w` pixels wide by `h` pixels high.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用会导致存储在 `img` 变量中的图像被扩展或收缩，使其宽度为 `w` 像素，高度为 `h` 像素。
- en: Example A
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 A
- en: In the first example, we scale the image to be the size of the window, which
    is 240×480\. Note that the image has been distorted, squashed from the sides and
    made taller. Also note that all of the work is done in `setup()`, and `draw()`
    has no code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们将图像缩放到窗口的大小，即 240×480。注意，图像已经发生了失真，从两侧压缩并被拉伸得更高。还要注意，所有工作都在 `setup()`
    中完成，`draw()` 中没有代码。
- en: Any image has an aspect ratio, which is the relationship between the width and
    height of the image. It is often expressed as *w*:*h*. For example, 16:9 would
    be the aspect ratio of an image that had 16 pixels in the x-direction (width)
    for every 9 pixels in the y-direction (height). The aspect ratio is sometimes
    expressed as a fraction, dividing the height into the width, so the ratio of 16:9
    would be written as 1.8 in this way. The reason that the image in Example A looks
    odd is that the aspect ratio has been changed by forcing the image to fit into
    an arbitrary rectangle.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 任何图像都有一个长宽比，这是图像宽度和高度之间的关系。它通常表示为 *w*:*h*。例如，16:9 就是一个图像的长宽比，表示每 9 个像素的 y 方向（高度）对应
    16 个像素的 x 方向（宽度）。长宽比有时也会以分数的形式表示，将高度除以宽度，这样 16:9 的比率就可以写成 1.8。示例 A 中的图像看起来奇怪的原因是长宽比被改变了，强行将图像适配到了一个任意的矩形框中。
- en: Example B
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 B
- en: 'This sketch draws an image into a window, scaling it so that the aspect ratio
    remains intact. The first thing to be done is to compute the aspect ratio of the
    original image:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图将图像绘制到一个窗口中，并进行缩放，以确保长宽比保持不变。首先要做的是计算原始图像的长宽比：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We use `float` variables here because the aspect ratio will be a fraction.
    When we place an image into a fixed space, its largest dimension (height or width)
    determines the overall size of the image within the window. We’ll adjust the largest
    side of the image to exactly fit the corresponding side of the window 2, whether
    that means making the image larger or smaller. The other dimension of the image
    is kept proportional to this new scaled value. So if the image is taller than
    it is wide, we will map the height of the image to the height of the window:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 `float` 变量，因为长宽比将是一个分数。当我们将图像放入固定的空间时，图像的最大维度（高度或宽度）决定了图像在窗口中的整体大小。我们将调整图像的最大边以精确适应窗口的对应边，无论这意味着将图像放大还是缩小。图像的另一维度将保持与这个新缩放值成比例。因此，如果图像比宽度高，我们将把图像的高度映射到窗口的高度：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'and the width will be in proportion to the original aspect ratio (converted
    to an integer):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度将与原始长宽比成比例（转换为整数）：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now the image can be resized for display:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以调整图像大小进行显示：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Sketch 16: Manipulating Images II—Cropping'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 16：图像操作 II—裁剪
- en: Cropping an image refers to the removal of some outer parts. You could think
    of it more generally as the selection of an arbitrary rectangular sub-image. We
    crop images to make a more appealing image or to remove extraneous material. In
    Paint or Photoshop we use the mouse, clicking first on the desired upper-left
    corner of the cropped image, then dragging the mouse to the desired new lower-right
    corner, and releasing the button. All parts of the image outside of the selected
    rectangle will be discarded. This sketch will crop an image and optionally expand
    the cropped region to fill the entire image window.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 裁剪图像是指去除图像的一些外部部分。你可以更一般地认为它是选择一个任意的矩形子图像。我们裁剪图像是为了使图像更具吸引力或去除不必要的部分。在画图或 Photoshop
    中，我们使用鼠标，首先点击裁剪图像的左上角，然后拖动鼠标到新的右下角，松开按钮。所有选定矩形框外的部分都会被丢弃。这个草图会裁剪图像，并可以选择将裁剪后的区域扩展以填充整个图像窗口。
- en: 'First the image is read in and the sketch window is resized to fit the image.
    The `draw()` function displays the image (named `img`) centered in the window
    using the following code 2:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先读取图像并将草图窗口的大小调整为适应图像。`draw()`函数使用以下代码2将图像（命名为`img`）居中显示在窗口中：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the image has not been cropped, `width-img.width` will be 0, and the call
    will be `image(img, 0, 0)`. Otherwise the image will be smaller than the window,
    and (`width-img.width)/2` will be the number of pixels needed on the left to center
    the cropped image. The same is done for height, which places the image in the
    center of the window.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像尚未被裁剪，则`width-img.width`为0，调用将是`image(img, 0, 0)`。否则，图像将小于窗口，并且`(width-img.width)/2`将是需要在左边放置的像素数，以便将裁剪后的图像居中。高度也是如此，将图像放置在窗口的中心。
- en: When the mouse button is pressed (`mousePressed()`), the cropping process starts,
    using the point where the cursor is, which is saved as `x0` and `y0`. Then a rectangle
    is drawn from this location to the current mouse coordinates, implementing a rubber
    band rectangle 3.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标按钮被按下时（`mousePressed()`），裁剪过程开始，使用鼠标光标所在的位置，该位置被保存为`x0`和`y0`。然后从这个位置绘制一个矩形到当前的鼠标坐标，实现一个橡皮筋矩形3。
- en: 'When the mouse button is released, the mouse coordinates are evaluated to ensure
    that the current `mouseX` and `mouseY` represent the lower-right corner of the
    crop box; in other words, make sure that `mouseX` is bigger than it was when the
    mouse button was pressed, and the same for `mouseY`. If not, the values of `x0`
    and `y0` are swapped with the values of `mouseX` and `mouseY`. Then we create
    a cropped image with the `get()` function, using the upper-left and lower-right
    coordinates 4:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标按钮释放时，会评估鼠标坐标，以确保当前的`mouseX`和`mouseY`表示裁剪框的右下角；换句话说，确保`mouseX`比鼠标按钮按下时的值大，`mouseY`也是如此。如果不是，则交换`x0`和`y0`的值与`mouseX`和`mouseY`的值。然后我们使用`get()`函数创建一个裁剪后的图像，使用左上角和右下角的坐标4：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `get()` function returns a rectangular region of an image specified by a
    coordinate pair, a width, and a height. In the preceding call (`x0`, `y0`) are
    the upper-left coordinates, the width is the distance between the `mouseX` value
    and the upper-left *x* value, and the height is the distance between `mouseY`
    and the upper-left *y* value. In this case, `get()` is using the image displayed
    in the sketch window as the original.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`函数返回由坐标对、宽度和高度指定的图像的矩形区域。在前面的调用中，`(x0, y0)`是左上角的坐标，宽度是`mouseX`值与左上角的*x*值之间的距离，高度是`mouseY`与左上角的*y*值之间的距离。在这种情况下，`get()`使用的是显示在草图窗口中的图像作为原始图像。'
- en: The sub-image returned by the `get()` function becomes the current image to
    be displayed in `draw()` (the variable `img`) centered in the window 5.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`函数返回的子图像成为当前需要在`draw()`中显示的图像（变量`img`），并居中显示在窗口5中。'
- en: 'A new idea in this sketch is the test to see which mouse button was pressed.
    In the `mouseReleased()` function, this statement tests for the right mouse button:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图中的一个新想法是测试按下了哪个鼠标按钮。在`mouseReleased()`函数中，以下语句用来测试右键鼠标按钮：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If that was the one released, the sub-image is rescaled to fit the window.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果释放的是该按钮，子图像会被重新缩放以适应窗口。
- en: At 1 we resize the graphics window to be the size of the image, as we’ve done
    before.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步，我们将图形窗口的大小调整为与图像大小相同，正如我们之前所做的那样。
- en: 'Sketch 17: Manipulating Images III—Magnifier'
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图17：图像操作 III——放大镜
- en: Some computers have a “magnifying glass” object that is controlled by the mouse
    and displays a close-up (magnified) view of a part of the screen. It allows people
    with a minor visual impairment to see things more clearly, and it allows everyone
    to get a better look at menus and other screen-based objects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一些电脑有一个由鼠标控制的“放大镜”对象，显示屏幕一部分的放大视图。它帮助有轻度视力障碍的人看得更清楚，同时也让每个人都能更好地查看菜单和其他基于屏幕的对象。
- en: Magnification is done by increasing the size of each pixel in the original image.
    If each pixel in the original becomes four pixels (in a square) in the new image,
    then the size of the new image will be double that of the original, giving the
    appearance of a magnified version, as shown in [Figure 17-1](#figure17-1). The
    image will contain no more detail than the original; it will just be easier to
    see.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 放大是通过增加原始图像中每个像素的大小来实现的。如果原始图像中的每个像素变成四个像素（以正方形排列），那么新图像的大小将是原始图像的两倍，从而呈现出放大效果，如[图17-1](#figure17-1)所示。图像的细节不会比原始图像更多，只是看起来更容易看清楚。
- en: '![f17001](Images/f17001.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![f17001](Images/f17001.png)'
- en: 'Figure 17-1: Magnifying an image'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-1：放大图像
- en: 'Implementing a magnifying glass is a simple matter using the functions that
    Processing provides. First we display the target image and use the techniques
    discussed in previous sketches to select a rectangular region in the sketch window
    to be magnified. By pressing the mouse button, the user selects a square beginning
    at the mouse coordinates with a size of 50×50 1. The Processing functions `mousePressed()`
    and `mouseReleased()` are called when the button is pressed and released 3, and
    we use these functions to set a flag variable named `mag`. If `mag` is set, we
    copy the selected part of the original image into another `PImage` named `sub`
    using the `get()` function. The copied image is then resized to be 100×100 pixels
    using the `resize()` function 2:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实现放大镜是使用Processing提供的函数来完成的。首先，我们显示目标图像，并使用之前讨论的技巧在草图窗口中选择一个矩形区域进行放大。按下鼠标按钮时，用户从鼠标坐标开始选择一个50×50大小的正方形1。按下和释放按钮时会调用Processing函数`mousePressed()`和`mouseReleased()`
    3，我们使用这些函数来设置一个名为`mag`的标志变量。如果`mag`被设置，我们使用`get()`函数将选定的原始图像部分复制到另一个名为`sub`的`PImage`中。然后，通过`resize()`函数将复制的图像调整为100×100像素2：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Taking a 50×50 image and making it 100×100 effectively doubles its size. Now
    the resized image is drawn on the screen at the location from which it was copied,
    more or less. The new image is larger than the extracted one, so the new position
    is approximate, and some pixels from the original will be hidden behind the new,
    larger copy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将一张50×50的图像调整为100×100，实际上是将其大小翻倍。现在，调整大小后的图像将大致在原来被复制的地方显示。新图像比原始图像大，因此新的位置是近似的，一些原图中的像素将被新图像覆盖。
- en: 'Sketch 18: Rotation'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图18：旋转
- en: When rotating something, we always need to specify an axis of rotation, which
    in two dimensions is a *point* and an angle. A rotation is specified using a call
    to the function `rotate()`,
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转某物时，我们始终需要指定旋转轴，在二维情况下就是一个*点*和一个角度。旋转是通过调用`rotate()`函数来指定的，
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: where `angle` is specified in radians. A circle contains 2π radians and also
    360 degrees, so to convert from degrees to radians means multiplying the degrees
    by 3.14159/180.0, or by using the Processing function `radians(x)`. The point
    (axis) about which the rotation will take place is the origin of the window’s
    coordinate system, (0, 0), by default. It is the upper-left corner of the window,
    and the rotation will be *clockwise* about this point.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`angle`以弧度为单位指定。一个圆包含2π弧度，也包含360度，所以从度数转换为弧度的方法是将度数乘以3.14159/180.0，或者使用Processing的`radians(x)`函数。旋转将围绕窗口坐标系的原点(0,
    0)进行，默认情况下原点位于窗口的左上角，旋转将是围绕这个点*顺时针*进行的。
- en: When a rotation is specified, all things drawn from that point on will be rotated.
    Calling `rotate()` again rotates by a further angle. Turning off the rotation
    is not possible as such, but a call to `rotate (-angle)` will undo the call to
    `rotate(angle)`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定旋转时，从该点开始绘制的所有物体都会被旋转。再次调用`rotate()`函数将会进行进一步的旋转。旋转本身无法直接关闭，但通过调用`rotate(-angle)`可以撤销`rotate(angle)`的效果。
- en: Example A
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例A
- en: The first example draws a figure illustrating rotations. A horizontal line is
    drawn and labeled 1, followed by a line that is rotated by 10 degrees 2 and then
    by one rotated by 20 degrees 3. To avoid having the text rotated, the rotation
    is “undone” (rotated by the negative angle) before drawing the text labels.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例绘制了一个表示旋转的图形。先绘制一条水平线并标记为1，接着是旋转了10度的线2，再旋转了20度的线3。为了避免文本被旋转，旋转会在绘制文本标签之前被“撤销”（以负角度进行旋转）。
- en: Example B
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例B
- en: A line is drawn from the origin. It has a small ball on the end. This line is
    rotated from 0 to 90 degrees in small steps, with each step displayed within `draw()`
    because the line and ball are drawn there. When the line is rotating clockwise,
    the angle is incremented by 0.01 radians each time `draw()` is called 1. When
    the line becomes vertical and further rotation would take it out of the field
    of view, the change in angle for each frame (variable `d`) is changed to `-d`
    2. Now the line rotates back to its original position, and at that point (0 degrees)
    the value of `d` is changed to become positive again. The object, which looks
    like a pendulum, bounces between 90 degrees and 0 degrees.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从原点画出一条线，线的末端有一个小球。线从 0 度旋转到 90 度，按小步长旋转，每次 `draw()` 被调用时都会显示每一步的结果，因为线和小球都会在其中被绘制。当线顺时针旋转时，每次调用
    `draw()` 时，角度会增加 0.01 弧度 1。当线变为垂直时，进一步旋转会使其超出视野，之后每帧的角度变化（变量 `d`）会改为 `-d` 2。现在，线开始旋转回原始位置，在
    0 度时，`d` 的值再次变为正数。这个看起来像秋千摆动的物体在 90 度和 0 度之间来回摆动。
- en: The rotation angle is reset to 0 each time `draw()` is called.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `draw()` 时，旋转角度都会重置为 0。
- en: 'Sketch 19: Rotating About Any Point—Translation'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 19：围绕任意点旋转—平移
- en: Being able to rotate objects is essential, but only being able to rotate about
    the upper-left corner of the screen is inconvenient. Rotation about an object’s
    center is what we usually want, but it requires knowledge of the object. Objects
    can be complex things in graphics; an object might be just a circle or square,
    or it might be a building or a car. Processing cannot be expected to know what
    an object is or where the center might be. However, Processing makes it possible
    to move the center of rotation to any coordinate we choose, using the `translate()`
    function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 能够旋转物体是至关重要的，但仅仅能围绕屏幕的左上角旋转物体是很不方便的。通常我们希望围绕物体的中心旋转，但这需要了解物体的具体情况。物体在图形中可能是复杂的；一个物体可能只是一个圆或方块，或者它可能是一个建筑物或一辆车。我们不能期望
    Processing 知道一个物体是什么，或者它的中心在哪里。然而，Processing 使得我们可以使用 `translate()` 函数将旋转中心移动到我们选择的任何坐标。
- en: '`translate()` takes an x- and a y-coordinate and changes the origin to that
    location for all future drawing. The following example moves the origin to the
    location (100, 200) in the window, which now becomes the coordinate (0, 0):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`translate()` 接受 x 和 y 坐标，并将原点移动到该位置，用于所有未来的绘制。以下示例将原点移动到窗口中的 (100, 200) 位置，现在这个位置变成了坐标
    (0, 0)：'
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The word translate means, in mathematical terms, to *reposition*, so a translation
    involves changing the position of an object. If we translate the origin to (50,
    50) and then draw a circle at (0, 0), the circle will appear at window coordinates
    (50, 50) on the screen. Further circles will be drawn relative to window coordinates
    (50, 50).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学术语中，`translate` 这个词意味着*重新定位*，因此平移涉及到改变物体的位置。如果我们将原点平移到 (50, 50)，然后在 (0, 0)
    画一个圆，这个圆将出现在屏幕的窗口坐标 (50, 50) 处。进一步的圆将相对于窗口坐标 (50, 50) 被绘制。
- en: Because rotations always use (0, 0) as the axis, this means we can set the axis
    to any coordinates we like and rotate an object about any point.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因为旋转总是以 (0, 0) 作为轴心，这意味着我们可以将轴心设置为我们喜欢的任何坐标，并围绕任何点旋转物体。
- en: Example A
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 A
- en: As a basic example, we’ll draw a circle at (0, 0) using the `ellipse()` function
    1 and then call `translate()` to change the origin to (50, 50). A second call
    to `ellipse()` that is exactly the same as the first draws the circle at screen
    coordinates (50, 50). A further `ellipse()` call drawing a circle at (30, 40)
    draws the circle at screen coordinates (80, 90); that is, (30, 40) relative to
    the new origin at (50, 50).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个基本示例，我们将使用 `ellipse()` 函数 1 在 (0, 0) 画一个圆，然后调用 `translate()` 将原点移到 (50,
    50)。第二次调用与第一次完全相同的 `ellipse()` 会在屏幕坐标 (50, 50) 画出圆。进一步的 `ellipse()` 调用，在 (30,
    40) 画一个圆，最终会在屏幕坐标 (80, 90) 画出圆；也就是说，(30, 40) 是相对于新原点 (50, 50) 的位置。
- en: Example B
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 B
- en: In this sketch we rotate a line about its center. The process is to `translate()`
    to the center of the line, in this case (150, 100) 1; rotate by the current angle
    2; and then draw the line. The coordinates of the line must reflect the fact that
    the origin is the line’s center, not one end. Because the center of the line is
    at (150, 100), the line should be drawn from −50 to +50 in the x-direction so
    as to be 100 pixels long. The translated coordinates of the start would be (150
    − 50, 200 − 100 − 0), or (100, 100). The coordinates of the endpoint will simply
    be 100 pixels further in x, or (200, 100). A small circle is drawn at the midpoint
    (origin) so that it can be seen.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个草图中，我们将一条线绕其中心旋转。过程是：`translate()` 到线的中心，这里是（150，100）1；按当前角度旋转2；然后绘制这条线。线的坐标必须反映原点是线的中心而非一端的事实。由于线的中心在（150，100），因此线应当从
    x 方向的 −50 绘制到 +50，长度为 100 像素。起始点的平移坐标将是（150 − 50，200 − 100 − 0），即（100，100）。端点的坐标将在
    x 方向上再向前 100 像素，即（200，100）。在中点（原点）处绘制一个小圆圈，以便能够看到它。
- en: The rotation angle increases each time `draw()` is called 3. Since the line
    is drawn each time `draw()` is called, the image shows a slowly rotating line.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `draw()` 时，旋转角度都会增加3。由于每次调用 `draw()` 时都会绘制这条线，图像就会呈现出缓慢旋转的效果。
- en: 'Sketch 20: Rotating an Image'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Sketch 20: 旋转图像'
- en: Rotation and translation can be applied to complex objects as well as simple
    lines and circles. In particular, we can rotate images about arbitrary points
    by any angle.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转和平移不仅适用于简单的线条和圆形，也适用于复杂的对象。特别是，我们可以绕任意点按任意角度旋转图像。
- en: There can be a problem in determining how to place the image so that it lies
    entirely on the screen. Images are rectangular, and rotating them increases their
    width or height. If we don’t place the image properly within the window, one or
    more corners could rotate out of the window’s boundaries, as shown in [Figure
    20-1](#figure20-1).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定如何放置图像以确保其完全位于屏幕上时，可能会遇到问题。图像是矩形的，旋转它们会增加它们的宽度或高度。如果我们没有将图像正确地放置在窗口中，图像的一个或多个角落可能会旋转到窗口的边界之外，如[图
    20-1](#figure20-1)所示。
- en: '![g20001a](Images/g20001a.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![g20001a](Images/g20001a.png)'
- en: 'Figure 20-1: Rotating an image out of the window’s boundaries'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '图 20-1: 图像旋转出窗口边界'
- en: 'The top pair of images shows the result of rotating an image that was displayed
    in the upper-left corner of the window. Rotating by 45 degrees moves half of the
    image off of the screen. The bottom pair of images shows what can happen when
    an image is rotated about its center without a large enough window: the corners
    of the image are cut off.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上方的两幅图像展示了将图像旋转的结果，图像原本显示在窗口的左上角。旋转45度会使图像的一半超出屏幕。下方的两幅图像展示了当图像围绕其中心旋转时，若窗口大小不足会发生什么：图像的角落被裁剪掉。
- en: This sketch displays a continuously rotating image. The image is read in, and
    the window size is set to *double* the image size in each dimension 1. The `draw()`
    function translates the origin to the center of the image and then rotates the
    image by `angle` and displays it, thus rotating the image about its own center
    2. The value of `angle` is then increased by a tiny amount for the next time `draw()`
    is called 3. The image appears in the center of the window and appears to rotate.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图展示了一个持续旋转的图像。图像被读取后，窗口大小设置为图像每个维度的*两倍*1。`draw()` 函数将原点平移到图像的中心，然后旋转图像 `angle`
    角度并显示，从而使图像围绕其自身的中心旋转2。然后，`angle` 的值会增加一个微小的量，以便下次调用 `draw()` 时使用3。图像出现在窗口的中心，并且看起来在旋转。
- en: 'Sketch 21: Getting the Value of a Pixel'
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Sketch 21: 获取像素值'
- en: 'While developing Sketch 14, we discussed how to get a pixel value from a `PImage`
    using the `get()` function. We can get the color value of the pixel at (`x`, `y`)
    in a `PImage` named `im` as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 Sketch 14 时，我们讨论了如何使用 `get()` 函数从 `PImage` 中获取像素值。我们可以按如下方式获取名为 `im` 的 `PImage`
    中坐标为（`x`，`y`）的像素的颜色值：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The picture currently being displayed in the sketch window has a privileged
    position because it can be accessed without using a variable. A pixel value on
    the screen can be obtained by simply calling `get()`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当前显示在草图窗口中的图片处于优先位置，因为它可以在不使用变量的情况下访问。通过调用 `get()`，我们可以直接获取屏幕上的像素值：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can therefore get the color of the pixel at the current mouse position with
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过以下方式获取当前鼠标位置处像素的颜色：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This sketch loads an image and allows the user to click any pixel to see its
    color, which will be displayed on the right side of the screen as a colored bar
    and as RGB values in text form. First the sketch loads an image and sizes the
    window to fit it, with an extra region on the right side. In `draw()` it displays
    the image with a background color of (200, 200, 200) 1; when the mouse button
    is pressed, it assigns the pixel value (color) at the `mouseX`, `mouseY` coordinates
    to the color variable `c` 3; then it displays the color on the right side of the
    image and the RGB values as text at the upper-right corner of the screen 2. Whenever
    the mouse button is clicked, the color value displayed will change.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该草图加载一张图像，并允许用户点击任何像素查看其颜色，颜色将以彩条的形式显示在屏幕右侧，并以文本形式显示RGB值。首先，草图加载一张图像并调整窗口大小以适应它，右侧有额外区域。在`draw()`中，它用背景色（200，200，200）1显示图像；当按下鼠标按钮时，它将`mouseX`、`mouseY`坐标处的像素值（颜色）赋值给颜色变量`c`3；然后，它将在图像右侧显示颜色，并在屏幕的右上角以文本形式显示RGB值2。每当点击鼠标按钮时，显示的颜色值将发生变化。
- en: 'Sketch 22: Setting and Changing the Values of Pixels'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 22：设置和更改像素的值
- en: Pixel values in an image, including the drawing area, can be changed using the
    `set()` function. We specify a pixel location using coordinates and identify the
    color to draw at that point. For example,
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图像中的像素值，包括绘图区域，可以使用`set()`函数进行更改。我们使用坐标指定像素位置，并确定要在该点绘制的颜色。例如，
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This sets the pixel in the graphics area at location (`i`,`j`) to yellow, or
    RGB (255, 255, 0). If the coordinates lie outside of the window, the pixel will
    be drawn but will not be visible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把图形区域中位置（`i`，`j`）的像素设置为黄色，或RGB（255，255，0）。如果坐标超出了窗口范围，像素将被绘制，但不可见。
- en: 'We can set a color for *all* pixels in the window using the `background()`
    function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`background()`函数为窗口中的*所有*像素设置颜色：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This call fills the sketch window with orange.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该调用将草图窗口填充为橙色。
- en: Example A
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 A
- en: 'Setting all pixels in the window without using the `background()` function
    requires a loop*—*two nested loops, in fact. The first loop examines all pixels
    in the horizontal direction; that is, all pixels in a specified row. The second
    loop looks at all possible values of `i`, which is to say all rows. The first
    loop is nested within the second so that all pixels in all rows are modified:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用`background()`函数而要设置窗口中的所有像素，需要使用一个循环*—*实际上是两个嵌套的循环。第一个循环检查水平方向上的所有像素；也就是说，检查指定行中的所有像素。第二个循环查看`i`的所有可能值，也就是所有行。第一个循环嵌套在第二个循环中，以便修改所有行中的所有像素：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This sets all pixels in the sketch window to orange.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把草图窗口中的所有像素设置为橙色。
- en: Example B
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 B
- en: The pixel values of an image can be modified before the image is displayed in
    the sketch window. Not only can the color be replaced, but a pixel value can be
    changed more subtly to a variation of what is already there. This example first
    loads and displays an image. When the program detects a button press with `mousePressed()`,
    it sets the flag `grey` 2, which indicates that the image on the screen is to
    be modified, pixel by pixel, in a loop like that of the previous example. In this
    case, we replace the RGB value of each pixel on the screen with its brightness
    value 1, and the result is a grey image showing no color. When the mouse button
    is released (`mouseReleased()`), the program clears the flag (sets it to `false`),
    and the image is displayed in color again 3.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像显示在草图窗口之前，可以修改图像的像素值。我们不仅可以替换颜色，还可以对现有像素值进行更细微的变化，得到与原有值不同的变化。例如，该示例首先加载并显示图像。当程序检测到通过`mousePressed()`按下按钮时，它设置标志`grey`为2，这表示要按像前一个示例中那样逐个像素修改屏幕上的图像。在这种情况下，我们用每个像素的亮度值1替换屏幕上每个像素的RGB值，结果是显示没有颜色的灰色图像。当鼠标按钮释放时（`mouseReleased()`），程序清除该标志（将其设置为`false`），图像将重新显示为彩色3。
- en: 'Sketch 23: Changing the Values of Pixels—Thresholding'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 23：更改像素的值—阈值处理
- en: 'The act of thresholding an image changes the color value of each pixel to either
    black or white, depending on the original color or brightness. Thresholding creates
    a binary image: each pixel can be thought of as being either *on* or *off*. Why
    do this? Some images have content that is fundamentally binary: a scan of a page
    of text has black characters on a white background. In other cases, it is a way
    to simplify an image so that we can perform other operations, such as detecting
    edges or faces. Thresholding an image of red blood cells might facilitate counting
    them, for example.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对图像进行阈值处理会将每个像素的颜色值改为黑色或白色，具体取决于原始的颜色或亮度。阈值处理会生成一张二值图像：每个像素可以被视为是*开启*还是*关闭*。为什么要这样做？有些图像的内容本质上是二值的：例如，一张文本页的扫描图像上有黑色字符和白色背景。在其他情况下，这是一种简化图像的方式，以便我们可以进行其他操作，比如检测边缘或人脸。例如，对红细胞图像进行阈值处理可能有助于对其进行计数。
- en: Thresholding an image is a two-step process. First we determine a threshold
    value—one that retains the required features of the image. We usually do this
    by examining all of the pixels in the image and computing a value using some statistical
    formula. A threshold value is a number between 0 and 255; all pixel brightness
    values smaller than the threshold will be set to black (0), and those greater
    will be set to white (255). The second step is looking at all of the pixels and
    actually applying the threshold.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值处理图像是一个两步过程。首先，我们确定一个阈值——这个值保留了图像的必要特征。我们通常通过检查图像中的所有像素并使用某些统计公式计算出一个值来实现这一点。阈值值是一个介于
    0 到 255 之间的数字；所有小于阈值的像素亮度值将被设置为黑色 (0)，而大于阈值的则会被设置为白色 (255)。第二步是查看所有像素并实际应用该阈值。
- en: 'To address the second step first, applying the threshold is a simple matter
    of looking at each pixel and deciding whether it is less than or greater than
    `threshold`. Weassign the pixel value to the variable `g`, extract the brightness,
    and then test it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了先解决第二步，应用阈值其实很简单：只需查看每个像素并判断它是否小于或大于 `threshold`。我们将像素值赋给变量 `g`，提取亮度，然后进行测试：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The value `black` is the color (0, 0, 0), and `white` is (255, 255, 255).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`black` 的值是颜色 (0, 0, 0)，而 `white` 的值是 (255, 255, 255)。'
- en: 'In this sketch, we will determine the threshold manually, using the mouse position.
    This is the horizontal position of the mouse as a percentage of the total window
    width:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将手动确定阈值，使用鼠标的位置。这是鼠标的水平位置，表示为窗口宽度的百分比：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If we multiply this fraction by 255, we get a value between 0 and 255 1 that
    is in proportion to how far to the right the mouse is. We’ll use this value as
    a threshold. When the mouse is on the left side of the window, the threshold will
    be small and most of the image will be white; when the mouse is on the right,
    the threshold will be large and the image will be largely black.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个分数乘以 255，就会得到一个介于 0 到 255 之间的值，这个值与鼠标的位置远离窗口左侧的程度成正比。我们将使用这个值作为阈值。当鼠标在窗口的左侧时，阈值会很小，大部分图像会是白色；当鼠标在右侧时，阈值会很大，图像大部分会是黑色。
- en: If the `draw()` function calculates and applies the threshold, it will be dynamic,
    and we can watch the image change as the mouse moves.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `draw()` 函数计算并应用了阈值，它将变得动态，我们可以在鼠标移动时观察图像的变化。
- en: 'Sketch 24: User-Defined Functions'
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 24：用户自定义函数
- en: 'Up to this point, we have been using drawing functions provided by the Processing
    system: `ellipse()`, `line()`, `mousePressed()`, and so on. We have not analyzed
    the concept of functions much, partly because it appears fairly obvious what is
    going on. However, if we wish to create our own functions, there are some things
    we need to understand.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 Processing 系统提供的绘图函数：`ellipse()`、`line()`、`mousePressed()` 等等。我们还没有深入分析函数的概念，部分原因是函数的作用看起来比较明显。然而，如果我们想要创建自己的函数，有一些内容是我们需要理解的。
- en: A function is a name given to a collection of code. When the name of the function
    is used in a statement, that function is said to be invoked or called, and the
    code within the function is executed. This means that functions can be executed
    from many different places without repeating the code itself, merely by calling
    it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是给一段代码集合起的名字。当函数的名字在语句中被使用时，称该函数被调用，函数内部的代码将被执行。这意味着，函数可以从许多不同的地方执行，而无需重复编写代码，只需调用它即可。
- en: 'A function can return a value: we’ve used such functions before. For example,
    `color()` and `get()` return colors and pixel values. Functions that do not return
    a value are said to return `void`, and that’s the reason for the word `void` in
    front of `setup()` and `draw()`. They are functions that do not return a value.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以返回一个值：我们以前使用过这样的函数。例如，`color()` 和 `get()` 返回颜色和像素值。没有返回值的函数被称为返回 `void`，这也是
    `setup()` 和 `draw()` 前面有 `void` 关键字的原因。它们是没有返回值的函数。
- en: 'To create a new function, we must follow the same syntax as `setup()` and `draw()`:
    we write the return type, the function name, parentheses, and then the function
    body in curly brackets. For example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新函数，我们必须遵循与 `setup()` 和 `draw()` 相同的语法：我们先写返回类型，再写函数名、括号，然后是花括号中的函数体。例如：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Above, `newFunctionA()` does not return a value, and it is called or invoked
    using the function call `newFunctionA();`. `newFunctionB()` returns an integer
    value and must have a `return` statement indicating the value to be returned.
    This type of function is called as if it were part of an expression:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`newFunctionA()` 不返回值，它是通过函数调用 `newFunctionA();` 来调用的。`newFunctionB()` 返回一个整数值，必须有一个
    `return` 语句来指示要返回的值。这种类型的函数像是表达式的一部分被调用：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There can be more than one `return` statement in a function, but only one will
    be executed, because once a function returns, no other code in the function can
    execute.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以有多个 `return` 语句，但只有一个会被执行，因为一旦函数返回，函数中的其他代码就无法再执行。
- en: 'Functions may have parameters or arguments, values that are given to the function
    when it is called. When calling the function `color()`, we list three values in
    the parentheses: red, green, and blue. These variables are specifically passed
    for use by the function, and their values are available to do calculations within
    the function.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以有参数或实参，即在调用函数时传递给函数的值。当调用函数 `color()` 时，我们在括号中列出三个值：红色、绿色和蓝色。这些变量专门传递给函数使用，并且它们的值可用于在函数内部进行计算。
- en: 'Let’s make a function that calculates the distance between two points, (x0,
    y0) and (x1, y1):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，计算两点之间的距离，(x0, y0) 和 (x1, y1)：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The arguments to the function are named `x0`, `y0`, `x1`, and `y1`, and they
    have types, in this case integer (`int`). The arguments are used to calculate
    the distance between the points (x0, y0) and (x1, y1) as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给函数的参数分别命名为 `x0`、`y0`、`x1` 和 `y1`，并且它们有类型，在本例中为整数类型（`int`）。这些参数用于计算两点 (x0,
    y0) 和 (x1, y1) 之间的距离，计算公式如下：
- en: '![C02eq001](Images/C02eq001.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![C02eq001](Images/C02eq001.png)'
- en: 'This sketch uses two mouse clicks to determine the points: (x0, y0) 2 and (x1,
    y1) 3. It draws a marker at each point and displays the distance between them
    as a text message at the bottom of the window 1.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图使用两次鼠标点击来确定两个点：(x0, y0) 2 和 (x1, y1) 3。它在每个点上绘制一个标记，并在窗口底部显示它们之间的距离作为文本信息
    1。
- en: 'Sketch 25: Elements of Programming Style'
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 25：编程风格的元素
- en: Style in a program refers to aspects of the code that don’t usually impact the
    execution but that do have an effect on how other people read, modify, or repair
    it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的风格指的是代码的一些方面，这些方面通常不会影响程序的执行，但会影响其他人在阅读、修改或修复代码时的体验。
- en: For example, there is a way to place human-readable text within a program for
    other programmers to read. Any text that follows a pair of slashes is called a
    comment, and it is ignored by Processing, as is any text in between the symbols
    `/*` and `*/`, which delineate comments that can span many lines. Programs should
    have relevant comments embedded within the code to explain what is going on to
    any human beings looking at it. Comments should be clear, offer an explanation,
    and never simply repeat the code itself. The nature of the comments in a program
    is one aspect of what we call programming style.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一种方法可以在程序中插入人类可读的文本供其他程序员阅读。任何在一对斜杠后面的文本被称为注释，Processing 会忽略它们，像 `/*` 和
    `*/` 之间的文本也会被忽略，它们标示了可以跨越多行的注释。程序应在代码中嵌入相关的注释，以便让任何查看代码的人理解发生了什么。注释应该清晰、提供解释，而不是简单地重复代码本身。程序中的注释性质是我们所说的编程风格的一部分。
- en: 'Another aspect of style is the use of indentation to convey structure. There
    is no single correct way to indent, but the standard shown in the sketches in
    this book has certain consistent features. For example, the “{” and “}” characters
    used to enclose blocks of code always line up with each other vertically so that
    the blocks are easy to identify. The only exception is when they are on the same
    line:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 风格的另一个方面是使用缩进来传达结构。没有一种单一的正确缩进方式，但本书中的草图所示标准有一些一致的特征。例如，用于包围代码块的“{”和“}”字符始终垂直对齐，以便容易识别代码块。唯一的例外是它们在同一行时：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In other books, you might see another style:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他书籍中，你可能会看到另一种风格：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The location of brackets doesn’t matter to the programming language’s compiler,
    but a programmer should be consistent.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 括号的位置对编程语言的编译器来说并不重要，但程序员应该保持一致性。
- en: Variables should have meaningful names. The variables `x0` and `y0` above represent
    x- and y-coordinates, so the names make sense. A variable named `pixelCount` should
    contain a count of pixels. It is pretty easy to give variables good names, and
    doing so does not impact how fast the code is or how much memory it requires in
    order to execute.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 变量应该有有意义的名称。上面`x0`和`y0`代表x和y坐标，因此这些名称是合适的。一个名为`pixelCount`的变量应该包含像素的计数。给变量起个好名字是很容易的，而且这么做不会影响代码的执行速度或占用的内存量。
- en: 'Numeric constants should be named like variables so that the purpose of the
    constant can be inferred from the name. A perfect example is `PI` instead of 3.1415\.
    A program should contain very few if any numerical constants, and names should
    be used instead. Consider the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 数字常量应该像变量一样命名，以便从名称中推断出常量的用途。一个完美的例子是`PI`而不是3.1415。一个程序应该尽量避免使用数字常量，而应该使用名称。考虑以下代码：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The number 0.01745 is meaningless to most people. Now consider this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 数字0.01745对大多数人来说没有意义。现在考虑以下内容：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is better. Two times PI/360 is the conversion between radians and degrees.
    Best would be
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这更好。两倍的 PI/360 是弧度和角度之间的转换。最好的做法是：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: where `degrees_to_radians` equals `0.01745`. Now anyone reading the code can
    easily see what is happening.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`degrees_to_radians`等于`0.01745`。现在任何阅读代码的人都能轻松看出发生了什么。
- en: The code in this sketch does the same thing as the previous sketch, but it shows
    better style. Note, though, that it takes more space on the screen—this is typical,
    and it’s why these rules are not followed all of the time, even in this book (where
    it’s important for the text to fit on a single page).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图中的代码与前一个草图做的是一样的，但它展示了更好的风格。不过，请注意，它占用了更多的屏幕空间——这是典型的情况，也正是这些规则并非总是被遵循的原因，即便在本书中（因为文本需要适应一页纸）。
- en: 'Sketch 26: Duplicating Images—More Functions'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图26：复制图像—更多的函数
- en: The purpose of this sketch is to give you some ideas about how to organize code
    into functions properly. This program will read an image, make a copy, and increase
    the brightness of the copy. The brighter version will be displayed when a mouse
    button is pressed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图的目的是给你一些关于如何将代码组织成函数的想法。这个程序将读取一张图像，创建其副本，并增加副本的亮度。当鼠标按钮按下时，亮度增强的版本将被显示出来。
- en: 'The first function is named `brighten()`. It is passed an image (named `img`)
    and an integer value (named `val`) as parameters. Its purpose is to increase the
    brightness value in an image by a specified amount. It does this by extracting
    the HSB value from each pixel in turn in a nested loop 2, adding the amount `val`
    to the brightness portion, and saving the pixel back in the image. This is the
    essential code 3:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数被命名为`brighten()`。它接收一个图像（命名为`img`）和一个整数值（命名为`val`）作为参数。它的作用是通过指定的数量增加图像的亮度值。它通过嵌套循环逐个提取每个像素的HSB值，将`val`值加到亮度部分，并将像素保存回图像中。这是关键代码：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We will use a new feature in `draw()`. Processing provides us with a variable
    named `mousePressed` 1 that is `true` if a mouse button is depressed and `false`
    otherwise, and this can be used in place of the `mousePressed()` callback function
    in very simple cases. In this instance, we display the brightness-enhanced image
    when the mouse button is pressed, and the original otherwise.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`draw()`中使用一个新特性。Processing 提供了一个名为`mousePressed`的变量，若鼠标按钮被按下，它的值为`true`，否则为`false`，在非常简单的情况下，可以用它替代`mousePressed()`回调函数。在这种情况下，当鼠标按钮被按下时，我们显示亮度增强后的图像，否则显示原始图像。
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The second function in this sketch makes a copy of the original image. We define
    the duplicate function as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图中的第二个函数创建了原始图像的副本。我们定义复制函数如下：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'According to the definition of this function, the function takes an image as
    an argument and returns an image. In fact, it returns a new image that is a copy
    of the one passed in. The Processing-supplied function that creates a new image
    is named `createImage()` 4, and it has this form:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个函数的定义，函数接受一张图像作为参数并返回一张图像。事实上，它返回的是一张新的图像，作为传入图像的副本。Processing 提供的创建新图像的函数名为`createImage()`
    4，它的形式如下：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The width and height should be self-explanatory; the constant `RGB` specifies
    the form of the image, which in this case is RGB color. The image returned by
    `CreateImage` is uninitialized, having pixels with unknown values, so after creating
    an image the same size as the one passed in, our `duplicate()` function sets each
    pixel in the new image to the value of the corresponding pixel in the original,
    with a standard nested loop.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度和高度应该不言自明；常量`RGB`指定了图像的形式，在这里是 RGB 颜色。`CreateImage`返回的图像是未初始化的，像素值未知，因此，在创建一张与传入图像相同大小的图像后，我们的`duplicate()`函数使用标准的嵌套循环将新图像中的每个像素设置为原始图像中对应像素的值。
