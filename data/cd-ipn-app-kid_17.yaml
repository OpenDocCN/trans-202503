- en: '14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '14'
- en: SETTING THE STAGE
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置舞台
- en: '![](Image00001.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00001.jpg)'
- en: Over the next several chapters, we’ll put your new skills to good use to build
    a game called *Schoolhouse Skateboarder* , where the player controls a skateboarder
    who has to jump over obstacles and collect gems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将运用你新学到的技能，制作一个名为 *Schoolhouse Skateboarder* 的游戏，在这个游戏中，玩家控制一个滑板车手，必须跳过障碍并收集宝石。
- en: In this chapter, you’ll set up your Xcode project file, add images for the player,
    and display a schoolyard background. [Figure 14-1](text00026.html#ch14fig1) is
    a preview of how the game will look on an iPhone. Players try to survive as long
    as possible by tapping to jump over obstacles, collecting gems and scoring points
    along the way. They lose when they tip over or fall down a hole.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将设置 Xcode 项目文件，添加玩家图像，并展示一个学校背景。[图 14-1](text00026.html#ch14fig1) 是游戏在
    iPhone 上的预览。玩家需要尽可能长时间地生存，通过点击跳过障碍物、收集宝石并沿途得分。若玩家翻倒或掉进洞里，则游戏失败。
- en: '![](Image00270.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00270.jpg)'
- en: '*Figure 14-1: The finished game*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-1：完成的游戏*'
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**我从哪里获得艺术和音效？**'
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了制作《Schoolhouse Skateboarder》所需的所有艺术和音效（可以从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    获得）。你不需要其他资源就能继续跟随。如果你想自定义，可以通过将滑板车手图像替换为你自己选择的角色，或者让某人代替收集宝石改为收集汉堡包来制作属于你的游戏。
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到本书结束时，你会受到启发，设计出属于自己的游戏。独立制作整个游戏，包括艺术和音效，能够带来非常有成就感。你可以完全掌控*你*的游戏的每个方面。
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上还有很多可以找到免费游戏艺术资源的地方：
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://opengameart.org/](http://opengameart.org/)*** 免费游戏艺术、音效和音乐'
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://freetems.net/](http://freetems.net/)*** 免费游戏艺术和音乐'
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** 免费的复古游戏音效制作工具'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Xcode 的 SpriteKit 制作游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内建的游戏引擎，用于制作二维（2D）游戏。*游戏引擎* 是一套工具，帮助你快速轻松地制作动画、使用音频和音效、创建菜单系统等。程序员使用游戏引擎，以便可以专注于真正重要的部分——让游戏变得有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，游戏由许多精灵（sprites）组成。*精灵* 是游戏中的 2D 图像。精灵可以是全屏图像，用来作为游戏的背景，或者是较小的图像，随着游戏进行而移动并执行某些动作。背景精灵设定了舞台。例如，在一款太空射击游戏中，背景精灵可能展示星空和行星的场景，而会有更小的精灵代表玩家的飞船、敌机、子弹、小行星和能量包。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit 是顶级的。其他游戏引擎需要写很多代码才能完成的任务，在 SpriteKit 中只需一两行代码就能实现，而且使用起来非常有趣！
- en: '![](Image00271.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 还提供了一个名为 SceneKit 的 3D 游戏引擎，但由于我们制作的是 2D 游戏，所以我们将继续使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **文件** ▸ **新建** ▸ **项目…**。在项目模板对话框中，选择
    **iOS**，选择 **游戏** 模板，然后点击 **下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中输入项目名称 SchoolhouseSkateboarder。选择 **SpriteKit** 作为游戏技术。由于我们的游戏仅会在
    iPhone（和 iPod touch）上运行，选择 **iPhone** 作为设备设置。然后点击 **下一步** 来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 即使什么都不改，你也可以运行这个项目，看到一个黑色的屏幕和一个写着 *Hello, World!* 的标签。每当你在模拟器中点击鼠标时，屏幕上会出现一个旋转的盒子（见
    [图 14-2](text00026.html#ch14fig2)），标签会缩小一秒钟。如果标签是横着显示的，你可以通过选择模拟器菜单中的 **硬件** ▸
    **左旋转** 来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用游戏模板创建新项目时，Xcode 会添加这个简单的互动功能，让你确保一切正常。
- en: '![](Image00272.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：在未做任何更改之前运行游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望在游戏中出现一个巨大的 *Hello, World!* 标签，首先我们来删除它。这个标签存在于 *场景编辑器* 中，场景编辑器是一个用于可视化设计
    SpriteKit 场景的工具，类似于使用故事板设计 UIKit 视图的方式。你可以将物体拖入场景编辑器，移动它们，调整它们的大小、颜色和其他属性。这个工具很有用，但与代码中能做到的相比，它有很多限制。因此，除了删除
    *Hello, World!* 标签外，我们在 Schoolhouse Skateboarder 游戏中将不再使用场景编辑器。要打开场景编辑器，点击项目导航器中的
    *GameScene.sks* 文件。加载后，你应该看到一个黑色的场景和 *Hello, World!* 标签。点击标签，然后按 DELETE 键。参见 [图
    14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并删除了 *Hello, World!* 标签，我们可以开始工作了——也就是开始享受游戏的乐趣！
- en: '**ADDING IMAGES**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有的图像作为资源添加到你的项目中。（资源只是你游戏中的一个元素，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载 ZIP 文件。下载完成后，你会在 *Downloads* 文件夹中看到一个名为 *ch14-images* 的文件夹，里面包含了你所需的所有图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片文件添加到你的项目中，你需要从 Finder 中将它们拖入 Xcode，并将它们放入资源目录中。（资源目录是 Xcode 项目中的一种特殊文件夹，用来存放和组织项目资源，如图片文件和图标。）它对于图片来说非常有用，因为它将相关的图片文件组织在一起。文件添加到资源目录后，你可以通过引用它们的文件名在代码中随时使用它们。我们使用的游戏模板已经包含了一个资源目录，名为
    *Assets.xcassets* ，这就是我们将要使用的目录。
- en: '![](Image00274.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *Assets.xcassets*。你应该能看到现有的资源，如 AppIcon 和飞船图片。你可以删除飞船图片，因为我们不会使用它。点击该图片，然后按
    DELETE 键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder 并导航到图片文件下载的文件夹。按 ⌘ -A 选择所有文件。文件选中后，将它们拖入 Xcode 资源目录，如 [图14-4](text00026.html#ch14fig4)
    所示。
- en: '![](Image00275.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图片文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到所有的图片文件都是 *.png* 文件。*PNG* 代表 *可移植网络图形*，它是 iOS 应用中最常用的图片文件类型，因为它在保持最佳图像质量的同时，文件大小最小。你也可以使用
    *.jpg* 文件，但推荐使用 *.png* 文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图片**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有的图片添加到项目中，让我们编写一些代码在应用中显示背景图片。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码已经自动添加到你的项目中了。在项目导航器中点击名为 *GameScene.swift* 的文件。你应该能看到已经存在的一些代码。这段代码有两个目的。首先，它给你展示了如何创建一个形状（旋转的方块）以及如何执行一个动作（让方块旋转）。其次，它让你可以立即运行新项目，确保一切都设置妥当。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，我们将删除大部分代码并添加我们自己的代码。请删除 *GameScene.swift* 中的所有内容，除了 didMove(to:) 函数和 update(_:)
    函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑都将在 GameScene 类中实现。可以将场景看作是应用中的一个视图或屏幕。GameScene 类将管理场景中发生的一切——如何显示精灵，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能有许多不同的场景——例如，一个标题场景，一个菜单场景，一个游戏场景和一个设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（只会发生一次的操作）、游戏循环或更新函数（游戏过程中反复发生的操作）以及用户交互函数（只有在用户点击或滑动时发生的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: setup函数didMove(to:)会在游戏首次启动时被调用。它非常适合设置场景的代码，例如添加初始精灵或设置玩家的分数和生命值的代码。它类似于你在[第10章](text00021.html#ch10)中用来设置AddBirthdayViewController中的日期选择器的viewDidLoad()方法，并且只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在将背景图片添加到场景之前，我们必须先设置场景的anchorPoint。将这行代码添加到didMove(to:)方法中（灰色的代码行表示一些已有的代码，用于布局）：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](Image00276.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张将定位在图钉所在的位置，并且如果纸张旋转，它将围绕图钉旋转。这与SpriteKit中锚点属性对精灵和场景的作用完全相同。游戏模板中的GameScene场景的锚点位于场景的中央，但我们希望将锚点设置在场景的左下角，因此我们将其设置为CGPoint.zero，或(0,
    0)。对于一些游戏，例如太空射击游戏，最好将锚点设置在场景的中间。但对于我们的游戏，地面位于屏幕底部，将锚点移到左下角会更方便操作。请参见[图 14-5](text00026.html#ch14fig5)，该图展示了不同锚点的位置。
- en: '![](Image00277.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点从(0, 0)到(1, 1)的不同位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在x坐标为0的位置时，它会位于屏幕的左边缘。当我们将精灵放置在y坐标为0的位置时，它会位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，从而改变精灵的位置和旋转方式。请参见[图 14-6](text00026.html#ch14fig6)，该图展示了使用不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图片，向didMove(to:)函数中添加以下代码行：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步解释一下我们刚才添加的五行代码。➊行创建了一个名为background的精灵，使用的是* [background@2x.png](mailto:background@2x.png)
    *文件或* [background@3x.png](mailto:background@3x.png) *文件。两个文件之前已经添加到资源目录，Xcode会自动选择正确的文件。你只需要在代码中引用它，称为“background”或“background.png”。要了解Xcode如何选择正确的文件，参见[《为不同屏幕分辨率调整图片大小》](text00026.html#ch14lev1sec7)，以及[第213页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以为变量名选择任何名称。但是，图像名必须与项目资源目录中添加的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建一个精灵时，我们将创建一个SKSpriteNode，就像我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ➋和➌行创建了常量xMid和yMid，它们将表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述它在屏幕上的位置。frame有一个x位置、一个y位置、一个宽度和一个高度（参见[图14-7](text00026.html#ch14fig7)）。midX属性给我们提供屏幕frame的中间x位置，midY则给我们提供屏幕frame的中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ➋行设置了我们的背景图像位置，使其居中显示在屏幕上，方法是使用xMid和yMid创建一个CGPoint，并将其赋值给精灵的位置属性。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，表示x和y坐标。当处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以保存两个值，一个是*x*，另一个是*y*，这使得它在处理2D游戏中的屏幕坐标时非常方便，因为游戏中的所有内容都使用x和y位置来定位。
- en: '**NOTE**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的内容都来自* Core Graphics框架*，这是一个苹果用于图形处理的框架。你会在Swift中经常看到这种命名方式——类或结构体的前两三个字母通常能告诉你这个对象的用途或来源。例如，所有SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。 '
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子元素*，意味着它被附加到了这个场景上。例如，如果场景发生变化，无论是变大、变小还是消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为场景的子元素或另一个精灵的子元素添加。每次添加精灵时，重要的是要考虑这个精灵的父对象应该是什么。例如，滑板手精灵是场景的子元素，但如果我们想为滑板手添加可互换的帽子，我们会使用一个作为滑板手精灵子元素的帽子精灵。这样，每当滑板手跳跃时，帽子就会留在滑板手头上，我们就不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏的玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择其中一种。由于我们的游戏是一个横向滚动的动作游戏，横屏方向（设备横着放，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏与横屏方向下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行该项目，你会注意到它可能默认以竖屏方向显示。让我们更改项目设置，使游戏仅在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中Portrait选项，同时保留两个横屏方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标列表，点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此列表将出现，图标将变为蓝色，表示列表区域已显示。确保选择了**SchoolhouseSkateboarder**目标。接下来，找到**Portrait**复选框并取消选中。保留横屏方向选项为选中状态。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们离目标更近了，但背景图像还没有填满整个屏幕。稍后我们将看看如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏现在以横屏方向运行时，你需要确保模拟器也处于横屏方向。要旋转它，从模拟器菜单中选择**硬件** ▸ **右旋**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要做额外的工作，以确保你创建的艺术作品资源在每个设备上都能正确显示。与基于
    UIKit 的应用程序（如我们的生日追踪器）相比，游戏在这一方面通常需要更多的工作，因为如果你只是简单地缩放图像，游戏艺术作品可能会显得被拉伸。为了避免这个问题，你需要为每个要支持的设备使用不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 提供了一种命名图像文件的系统，帮助你分辨哪些图像是为哪些设备准备的。例如，假设你想在游戏中添加一张滑板手的图像，而你有一张滑板手的图像文件，尺寸为
    100 像素宽和 100 像素高（100×100）。你应该将这张图像命名为 *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，尺寸为 200×200 像素，另一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，尺寸为 300×300
    像素。这三张文件应该是同一图像的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需引用图像文件名 skater，只要你在项目中正确命名了图像，Xcode 会自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《学校滑板》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被认为是 1x 图像。你只需要为老款设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 尺寸的图像，这些设备没有视网膜显示屏。因此，我们所有的图像文件都会带有* @2x *或* @3x
    *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图像分组在一起。如果你同时将尺寸不同的图像拖放到 Xcode 的资源目录中，Xcode
    会根据它们的命名自动识别它们是同一图像的不同尺寸并将它们分组在一起。见 [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们还有最后一个准备工作要处理，涉及背景图像。您可能已经注意到，当您使用 iPhone 7 模拟器运行游戏时，背景图像没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景尺寸的方式。游戏场景的大小将基于包含在我们项目中的*GameScene.sks*场景编辑器文件中的设置。我们在这个项目中不使用场景编辑器，因此需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并将其显示出来。由于 GameScene 是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**您学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您开始制作 *Schoolhouse Skateboarder* 游戏并学习了 SpriteKit。您学习了如何在 Xcode 中创建游戏项目并将资源（如图像）导入到项目中。您还学习了如何通过标准文件命名实践来支持各种设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，您创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来就该编程实现一些动作了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: SETTING THE STAGE
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置场景
- en: '![](Image00001.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00001.jpg)'
- en: Over the next several chapters, we’ll put your new skills to good use to build
    a game called *Schoolhouse Skateboarder* , where the player controls a skateboarder
    who has to jump over obstacles and collect gems.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将充分利用您的新技能，构建一款名为*Schoolhouse Skateboarder*的游戏，在这款游戏中，玩家控制一名滑板手，必须跳过障碍并收集宝石。
- en: In this chapter, you’ll set up your Xcode project file, add images for the player,
    and display a schoolyard background. [Figure 14-1](text00026.html#ch14fig1) is
    a preview of how the game will look on an iPhone. Players try to survive as long
    as possible by tapping to jump over obstacles, collecting gems and scoring points
    along the way. They lose when they tip over or fall down a hole.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将设置 Xcode 项目文件，添加玩家图像，并显示一个学校操场背景。[图 14-1](text00026.html#ch14fig1) 是游戏在
    iPhone 上显示的预览。玩家通过点击跳过障碍、收集宝石并得分，尽可能长时间生存。当玩家倾斜或掉进洞里时就会失败。
- en: '![](Image00270.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00270.jpg)'
- en: '*Figure 14-1: The finished game*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-1：完成的游戏*'
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**我从哪里获取艺术和音效？**'
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了你制作《Schoolhouse Skateboarder》所需的所有艺术和音效（可从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    获取）。你不需要其他任何东西来跟随本书的内容。如果你想自定义游戏，可以通过将滑板手图像替换成你选择的角色，或者让某人抓取汉堡而不是宝石，来定制你的游戏。
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在本书的结尾，你会受到启发，设计自己的游戏。独立创作整个游戏，包括艺术和音效，可以是非常有成就感的。你将完全控制 *你* 的游戏的每一个方面。
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上也有许多地方可以找到免费游戏艺术资源：
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://opengameart.org/](http://opengameart.org/)*** 免费游戏艺术、音效和音乐'
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://freetems.net/](http://freetems.net/)*** 免费游戏艺术和音乐'
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** 免费复古游戏音效创建工具'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Xcode 的 SpriteKit 制作游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内置的游戏引擎，用于制作二维（2D）游戏。*游戏引擎* 是一组工具，能够让你快速轻松地制作动画、使用音频和音效、创建菜单系统等。程序员使用游戏引擎是为了能够集中精力做真正重要的事情——让游戏有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个游戏由许多精灵组成。*精灵*是游戏中使用的二维图像。精灵可以是提供游戏背景的全屏图像，也可以是移动并执行各种动作的小图像。背景精灵设置了舞台。例如，在一款太空射击游戏中，背景精灵可能会展示一幅包含星星和行星的太空场景，同时还会有小精灵表示玩家的飞船、敌方飞船、子弹、陨石和能量补给。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有游戏引擎中，SpriteKit 是一流的。在其他游戏引擎中需要多行代码才能完成的任务，在 SpriteKit 中只需一两行代码就能完成，而且使用起来非常有趣！
- en: '![](Image00271.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 也有一个名为 SceneKit 的 3D 游戏引擎，但由于我们要构建的是一款 2D 游戏，所以我们将坚持使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **File** ▸ **New** ▸ **Project…**
    。在项目模板对话框中，选择 **iOS**，选择 **Game** 模板，然后点击 **Next**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中为你的项目命名为 SchoolhouseSkateboarder。选择 **SpriteKit** 作为游戏技术。由于我们的游戏将仅在
    iPhone（和 iPod touch）上运行，因此在设备设置中选择 **iPhone**。然后点击 **Next** 创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何更改的情况下，你可以运行这个项目，你会看到一个黑色的屏幕，上面有一个写着 *Hello, World!* 的标签。每当你在模拟器中点击鼠标，屏幕上会出现一个旋转的盒子（参见
    [图 14-2](text00026.html#ch14fig2)），标签会缩小一秒钟。如果标签显示侧向，你可以通过在模拟器菜单中选择 **硬件** ▸ **向左旋转**
    来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建一个新项目时，Xcode 会添加这个简单的交互，以便你确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：在对游戏模板创建的项目进行任何更改之前运行项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想在游戏中有一个巨大的 *Hello, World!* 标签，所以首先将其移除。这个标签存在于 *场景编辑器* 中，这是一个用于可视化设计 SpriteKit
    场景的工具，类似于在设计 UIKit 视图时使用的故事板。你可以将物体拖放到场景编辑器中，移动它们，调整大小、颜色和其他属性。这个工具很有用，但相比代码中的操作，它有很多限制。因此，除了删除
    *Hello, World!* 标签外，我们在 Schoolhouse Skateboarder 中不会使用场景编辑器。要打开场景编辑器，点击项目导航器中的
    *GameScene.sks* 文件。加载完成后，你应该能看到一个黑色的场景，并带有 *Hello, World!* 标签。点击标签，然后按 DELETE
    键。参见 [图 14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并删除了 *Hello, World!* 标签，我们可以开始进入正题——也就是进入有趣的部分！
- en: '**ADDING IMAGES**'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图片添加到你的项目中作为资源。（资源是你游戏中的任何东西，例如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载 ZIP 文件。下载完成后，你会在 *Downloads* 文件夹内看到一个名为 *ch14-images* 的文件夹，其中包含你所需的所有图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片文件添加到项目中，你需要将它们从 Finder 拖到 Xcode 中，并将其放入资源目录中。（资源目录是 Xcode 项目中的一种特殊文件夹，用于存储和组织项目资源，如图片文件和图标。）它对图片非常有用，因为它将相关的图片文件分组在一起。一旦文件进入资源目录，你就可以在代码中通过引用文件名来使用它们。我们使用的游戏模板已经带有一个资源目录，名为
    *Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *Assets.xcassets*。你应该能看到现有的资源，包括 AppIcon 和飞船图片。你可以删除飞船图片，因为我们不打算使用它。点击该图片，然后按
    DELETE 键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，导航到图像文件下载的文件夹。按⌘-A选择所有文件。选中文件后，将它们拖入Xcode的资源目录，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图像文件添加到项目的资源目录*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有的图像文件都是*.png*文件。*PNG*代表*可移植网络图形*，它是iOS应用中最常用的图像文件类型，因为它在保持最佳图像质量的同时，文件大小最小。你可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，让我们编写一些代码，在应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Game模板创建一个新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中名为*GameScene.swift*的文件。你应该会看到一些已经存在的代码。这个代码有两个目的。首先，它给了你一个创建形状（旋转的盒子）并执行动作（使盒子旋转）的示例。其次，它让你可以立即运行一个新项目，确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们将删除大部分代码，并添加我们自己的代码。继续删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE4]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将会在GameScene类中。可以把场景看作是应用中的一个视图或屏幕。GameScene类将管理场景中发生的一切——如何显示精灵，玩家如何与游戏互动，得分如何计算。复杂的游戏可能有许多独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一些只执行一次的操作），游戏循环或更新函数（游戏中反复执行的操作），以及用户交互函数（仅在用户点击或滑动时执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数didMove(to:)会在游戏首次启动时被调用。它非常适合用来设置场景的代码，例如添加初始精灵或设置玩家的分数和生命值。这类似于你在[第10章](text00021.html#ch10)中用来设置AddBirthdayViewController中的日期选择器的viewDidLoad()方法，并且它只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们需要设置场景的anchorPoint。将这行代码添加到didMove(to:)方法中（灰色的行表示一些现有的代码，用于放置）：
- en: '[PRE5]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](Image00276.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用大头针将一张纸固定在软木板上时，大头针就是锚点。纸张将定位在你放置大头针的位置，如果纸张旋转，它将围绕大头针旋转。这正是精灵和场景在
    SpriteKit 中如何使用 anchorPoint 属性的方式。游戏模板中的 GameScene 场景锚点位于场景的中心，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero，或者 (0, 0)。对于一些游戏，比如太空射击游戏，将锚点放在场景的中心更为合适。但对于我们的游戏，地面位于屏幕的底部，将锚点移到左下角会让工作更加方便。请参见[图14-5](text00026.html#ch14fig5)了解各种锚点的位置示例。
- en: '![](Image00277.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：从(0, 0)到(1, 1)的各种锚点位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在 x 轴位置为 0 时，它会位于屏幕的左边缘。而当我们将一个精灵放置在 y 轴位置为 0 时，它会位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将按步骤逐步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获得。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。查看[图14-6](text00026.html#ch14fig6)，了解如何通过不同的锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，请将以下代码行添加到 didMove(to:) 函数中：
- en: '[PRE6]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步解析刚才添加的五行代码。第 ➊ 行创建了一个名为 background 的精灵，使用的是* [background@2x.png](mailto:background@2x.png)*
    文件或* [background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已经添加到资产目录中，Xcode
    会自动选择正确的文件。你只需在代码中引用它为 "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参见
    “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)” 页 [213](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以随意使用任何变量名。然而，图像名必须与项目中添加到资产目录中的文件名一致。SKSpriteNode
    是 SpriteKit 中的精灵类，因此，当我们在游戏中创建一个精灵时，我们会创建一个 SKSpriteNode，就像我们在这里做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 位于➋和➌的代码创建了常量xMid和yMid，它们代表屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述它们在屏幕上的位置。frame有x坐标、y坐标、宽度和高度（见[图
    14-7](text00026.html#ch14fig7)）。midX属性给我们提供了屏幕frame的中间x坐标，midY则给出了中间y坐标。
- en: '![](Image00279.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 位于➍的代码通过使用xMid和yMid创建一个CGPoint并将其分配给精灵的位置属性，将背景图像的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x坐标和y坐标。当你处理屏幕坐标时，通常会使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以包含两个值，一个是*x*，一个是*y*，这使得在2D游戏中处理屏幕坐标非常方便，因为所有内容都是通过x和y位置来定位的。
- en: '**NOTE**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的都来自* Core Graphics框架*，这是苹果公司用于图形处理的框架。你会在Swift中看到这种命名系统，类或结构体的前两到三个字母通常会告诉你该对象的用途或来源。例如，所有SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 位于➎的代码通过调用addChild(_:)函数将背景图像添加到场景中。这个精灵现在是场景的*子对象*，这意味着它被附加到了这个场景。例如，如果场景发生变化，增大、缩小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，而每个精灵都作为场景的子对象或另一个精灵的子对象添加。当你添加一个精灵时，重要的是要考虑这个精灵的父对象应该是谁。例如，滑冰精灵是场景的子对象，但如果我们想给滑冰者添加可互换的帽子，我们会使用一个帽子精灵，它是滑冰者精灵的子对象。这样，每当滑冰者跳跃时，帽子会跟着滑冰者一起移动，我们就不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏的玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时适应纵向和横向模式运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后只选择那个方向。由于我们的游戏是一个水平滚动的动作游戏，因此横向模式（设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）是最合适的。
- en: '![](Image00280.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在纵向和横向模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行该项目，使用 iPhone 7 模拟器，你会注意到它可能默认是纵向显示。让我们修改项目设置，使游戏仅在横屏模式下运行。打开项目导航器，点击
    **SchoolhouseSkateboarder** 项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如 [图 14-9](text00026.html#ch14fig9)
    所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 14-10](text00026.html#ch14fig10) 中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中纵向选项，保留两个横向选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标列表，点击窗口左上角的方形图标，如 [图 14-10](text00026.html#ch14fig10) 所示。此时列表会出现，图标会变蓝，表示该列表区域已显示。确保选中了
    **SchoolhouseSkateboarder** 目标。现在找到 **纵向** 复选框并取消勾选，保留横向模式选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它在横屏模式下启动。我们已经越来越接近目标，但背景图像还没有填满屏幕。稍后我们将看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转模拟器，选择 **硬件** ▸ **向右旋转**，如 [图 14-11](text00026.html#ch14fig11)
    所示。
- en: '![](Image00284.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：将模拟器旋转方向与游戏匹配*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。相比于像我们的生日追踪器那样基于
    UIKit 的应用，游戏通常需要在这方面付出更多努力，因为如果你只是简单地放大或缩小，游戏艺术作品会看起来被拉伸。为了避免这个问题，你需要为每个想要支持的设备使用不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个命名图像文件的系统，帮助你识别不同设备的图像。例如，假设你想在游戏中添加一张滑板人物的图像，并且你有一张宽100像素、高100像素（100×100）的滑板人物图像文件。你会将这张图像命名为*skater.png*。你还需要创建一张名为*[skater@2x.png](mailto:skater@2x.png)*、尺寸为200×200像素的图像，以及另一张名为*[skater@3x.png](mailto:skater@3x.png)*、尺寸为300×300像素的图像。这三张文件应该是同一张图像的不同尺寸。如果游戏在iPhone
    4上运行，带有* @2x*后缀的文件会自动被使用。如果游戏在iPhone 6 Plus上运行，带有* @3x*后缀的文件会自动被使用。在你的代码中，你只需要引用文件名skater，Xcode会根据你在项目中正确命名的图像自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》游戏，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被视为1x图像。你只需要为那些有非视网膜显示屏的旧设备（如iPhone
    3GS或第一代iPad mini）提供1x大小的图像。因此，我们所有的图像文件都会有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会发现Xcode将这两张图像分组在一起。如果你同时将这些图像拖入Xcode资源目录，Xcode会自动识别它们是相同图像的不同尺寸，并将它们分组。见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：多个尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从背景图像的处理过渡之前，还有最后一项准备工作需要完成。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板在处理游戏场景尺寸时的方式。游戏场景的大小将根据包含在我们项目中的*GameScene.sks*场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码，以确保场景的尺寸正确。
- en: '![](Image00287.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，并找到viewDidLoad()方法。添加以下代码行以设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE7]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()` 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主要场景，我们希望它始终充满整个屏幕。我们在这里添加的代码决定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，以便它充满整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 *Schoolhouse Skateboarder* 游戏并学习了 SpriteKit。你学会了如何在 Xcode 中创建一个游戏项目并将资源（如图像）导入项目。你还学会了如何通过标准的文件命名实践支持各种设备的屏幕分辨率，并学会了如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在 [第15章](text00027.html#ch15)
    中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00001.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00001.jpg)'
- en: Over the next several chapters, we’ll put your new skills to good use to build
    a game called *Schoolhouse Skateboarder* , where the player controls a skateboarder
    who has to jump over obstacles and collect gems.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将充分利用你新学到的技能，制作一款名为 *Schoolhouse Skateboarder* 的游戏，在游戏中，玩家控制一个滑板少年，必须跳过障碍物并收集宝石。
- en: In this chapter, you’ll set up your Xcode project file, add images for the player,
    and display a schoolyard background. [Figure 14-1](text00026.html#ch14fig1) is
    a preview of how the game will look on an iPhone. Players try to survive as long
    as possible by tapping to jump over obstacles, collecting gems and scoring points
    along the way. They lose when they tip over or fall down a hole.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将设置 Xcode 项目文件，添加玩家的图像，并显示一个学校院子背景。[图14-1](text00026.html#ch14fig1) 是游戏在
    iPhone 上显示的预览。玩家通过点击屏幕跳过障碍物、收集宝石并得分，尽量生存更长时间。玩家摔倒或掉进洞里时游戏结束。
- en: '![](Image00270.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00270.jpg)'
- en: '*Figure 14-1: The finished game*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-1：完成的游戏*'
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**我在哪里可以获取艺术作品和音效？**'
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了制作 *Schoolhouse Skateboarder* 游戏所需的所有艺术作品和音效（可从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    获取）。你不需要其他任何东西来继续操作。如果你想定制它，可以通过替换滑板少年的图像来让游戏更具个性，或者你可以让角色抓汉堡而不是宝石。
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在本书结束时，你会受到启发，设计你自己的游戏。亲自制作整个游戏，包括艺术作品和音效，能带来极大的成就感。你对 *你的* 游戏的每一个方面都有完全的控制权。
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上也有许多地方可以找到免费的游戏艺术资源：
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://opengameart.org/](http://opengameart.org/)*** 免费的游戏艺术、音效和音乐'
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://freetems.net/](http://freetems.net/)*** 免费的游戏艺术和音乐'
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** 免费的复古游戏音效创建工具'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Xcode 的 SpriteKit 制作游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内建的游戏引擎，用于制作二维（2D）游戏。*游戏引擎*是一套工具，能够让你快速轻松地制作动画、使用音频和音效、创建菜单系统等等。程序员使用游戏引擎是为了专注于真正重要的事情——让游戏变得有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，游戏由许多精灵组成。*精灵*是游戏中使用的二维图像。精灵可以是全屏的图像，用于提供游戏背景，或者是可以移动并执行某些操作的较小图像。背景精灵设定了场景。例如，在一款太空射击游戏中，背景精灵可能显示星空和行星，而玩家的宇宙飞船、敌方飞船、子弹、小行星和强化物则由较小的精灵呈现。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit 是一流的。其他游戏引擎中需要许多行代码的任务，在 SpriteKit 中只需一两行代码就能完成，而且使用起来非常有趣！
- en: '![](Image00271.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 还有一个名为 SceneKit 的 3D 游戏引擎，但由于我们正在制作的是 2D 游戏，所以我们将继续使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **文件** ▸ **新建** ▸ **项目...**。在项目模板对话框中，选择
    **iOS**，选择 **游戏** 模板，然后点击 **下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中将项目命名为 SchoolhouseSkateboarder。选择 **SpriteKit** 作为游戏技术。由于我们的游戏仅在
    iPhone（和 iPod touch）上运行，选择 **iPhone** 作为设备设置。然后点击 **下一步** 来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 不进行任何更改，你可以运行这个项目，你将看到一个黑屏，上面有一个显示 *Hello, World!* 的标签。每次你在模拟器中点击鼠标的任何位置，屏幕上都会出现一个旋转的框（见
    [图 14-2](text00026.html#ch14fig2)），并且标签会缩小一秒钟。如果标签出现侧向显示，你可以通过从模拟器的菜单中选择 **硬件**
    ▸ **左旋转** 来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建新项目时，Xcode 会添加这个简单的交互功能，让你可以确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：在进行任何修改之前运行通过游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望在游戏中出现一个巨大的*Hello, World!*标签，所以我们先把它移除。这个标签存在于*场景编辑器*中，场景编辑器是一个用于可视化设计SpriteKit场景的工具，类似于在UIKit中使用故事板来设计视图。你可以将对象拖入场景编辑器，移动它们，调整它们的大小、颜色以及其他属性。这是一个非常有用的工具，但与代码中可以完成的功能相比，它有很多限制。因此，除了移除*Hello,
    World!*标签外，我们在Schoolhouse Skateboarder项目中将不再使用场景编辑器。要打开场景编辑器，点击项目导航器中的名为*GameScene.sks*的文件。加载完成后，你应该能看到一个黑色的场景和*Hello,
    World!*标签。点击该标签，然后按DELETE键。见[图 14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：删除游戏模板的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并移除了*Hello, World!*标签，接下来就可以进入正题——也就是进入有趣的部分了！
- en: '**ADDING IMAGES**'
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图片文件添加为项目的资源。（资源就是你游戏中的元素，例如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你会在*Downloads*文件夹中看到一个名为*ch14-images*的文件夹，里面包含了你所需要的所有图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片文件添加到项目中，你需要将它们从Finder中拖动到Xcode，并放入资源目录中。（资源目录是Xcode项目中的一种特殊文件夹，用于存储和组织项目资源，如图片文件和图标。）它对于图片非常有用，因为它将相关的图片文件组合在一起。一旦文件被放入资源目录，你可以在代码中通过引用它们的文件名来使用它们。我们使用的游戏模板已经包含了一个资源目录，名为*Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*Assets.xcassets*。你应该能看到现有的资源，AppIcon和飞船图片。你可以删除飞船图片，因为我们不打算使用它。点击它，然后按DELETE键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，导航到图片文件下载的文件夹。按⌘-A选择所有文件。选中后，将它们拖入Xcode的资源目录，如[图 14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图片文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，所有的图片文件都是*.png*格式的。*PNG*代表*便携式网络图形*，它是iOS应用中最常用的图片文件类型，因为它提供了最佳质量图像的最小文件大小。你也可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图片**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，接下来让我们写一些代码在应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Game模板创建新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中名为*GameScene.swift*的文件，你应该会看到已经有了一些代码。这些代码有两个目的。首先，它为你提供了如何创建一个形状（旋转的盒子）和如何执行一个动作（让盒子旋转）的示例。其次，它让你可以立即运行新项目，确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将删除大部分代码并添加自己的代码。请删除*GameScene.swift*中除didMove(to:)函数声明和update(_:)函数外的所有内容，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE8]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将位于GameScene类中。可以把场景想象成你应用中的一个视图或屏幕。GameScene类将管理场景中的一切——精灵的显示方式、玩家如何与游戏互动以及如何进行得分。复杂的游戏可能会有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（只执行一次的事情）、游戏循环或更新函数（在游戏过程中反复执行的事情）和用户交互函数（只有当用户点击或滑动时才会执行的事情）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的游戏首次启动时，setup函数didMove(to:)会被调用。这非常适合用于设置场景的代码，比如添加初始精灵或设置玩家的分数和生命值。这与[第10章](text00021.html#ch10)中用于设置AddBirthdayViewController里日期选择器的viewDidLoad()方法类似，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在将背景图像添加到场景之前，我们必须设置场景的anchorPoint。将这行代码添加到didMove(to:)方法中（灰色的行表示一些现有的代码，便于放置）：
- en: '[PRE9]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](Image00276.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用大头针把一张纸钉在软木板上时，大头针就是锚点。纸张的位置就是你放置大头针的地方，如果纸张旋转，它将围绕大头针旋转。这正是
    `anchorPoint` 属性在 SpriteKit 中与精灵和场景配合使用的方式。游戏模板中的 `GameScene` 其锚点位于场景的中央，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    `CGPoint.zero`，即 (0, 0)。对于一些游戏，例如太空射击游戏，锚点设置在场景的中央更好。但对于我们的游戏来说，由于地面位于屏幕的底部，将锚点移动到左下角会让我们更容易操作。有关各种锚点的示意图，请参见
    [图14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点位置的不同，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在 x 位置为 0 时，它会位于屏幕的左边缘。当我们将一个精灵放置在 y 位置为 0 时，它会位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步一步地构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，从而改变该精灵的位置和旋转方式。有关使用不同锚点旋转精灵的示例，请参见 [图14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵的锚点通常位于中心。我们不会更改任何精灵的锚点，因此我们将始终使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，向 `didMove(to:)` 函数中添加以下几行代码：
- en: '[PRE10]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析我们刚刚添加的五行代码。➊ 这一行创建了一个名为 `background` 的精灵，使用的是 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已经添加到资产目录中，Xcode
    会自动选择合适的文件。你只需要在代码中引用它为 "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参阅
    “[针对不同屏幕分辨率调整图片大小](text00026.html#ch14lev1sec7)” 第 [213 页](text00026.html#page_213)。注意，变量名不必与图像名称相匹配——你可以随意为变量命名。但是，图像名称必须与项目中添加到资产目录的文件名匹配。`SKSpriteNode`
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个 `SKSpriteNode`，就像我们在这里做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 位置在➋和➌行的代码创建了常量xMid和yMid，分别表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它在屏幕上的位置。一个框架有x位置、y位置、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕框架的中间x位置，而midY给出了屏幕框架的中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 位置在➍行的代码通过创建一个使用xMid和yMid的CGPoint，并将其赋值给精灵的位置属性，将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。当你处理屏幕坐标时，通常会使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以包含两个值，一个表示*
    x *，一个表示* y *，这使得它在处理2D游戏中的屏幕坐标时非常方便，因为游戏中的所有物体都是通过x和y坐标来定位的。
- en: '**NOTE**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自* Core Graphics框架*，这是苹果公司用于图形处理的框架。你会在Swift中经常看到这种命名系统——一个类或结构体的前两到三个字母通常会告诉你该对象的用途或来源。例如，所有的SpriteKit类，比如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 位置在➎行的代码通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它与该场景绑定在一起。例如，如果场景扩大、缩小或消失，这个子精灵也会发生相应变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为场景的子对象或其他精灵的子对象被添加。每当你添加一个精灵时，重要的是要考虑它的父对象应该是什么。例如，滑雪者精灵是场景的子对象，但如果我们想要在滑雪者身上加上可以更换的帽子，我们会使用一个帽子精灵，作为滑雪者精灵的子对象。这样，当滑雪者跳跃时，帽子就会跟着滑雪者一起移动，我们不必单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏如何进行：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此最好是决定哪种方向最适合你的游戏，然后选择那个方向。由于我们的游戏是一个水平滚动的动作游戏，因此横屏模式（设备横置，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，你会注意到它可能默认以竖屏模式启动。让我们更改项目设置，使游戏只在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目—它位于项目导航器顶部，并且旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目条目进入项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中Portrait选项，保持两个Landscape方向选项选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此列表将会出现，并且图标会变成蓝色，表示列表区域现在正在显示。确保选择了**SchoolhouseSkateboarder**目标。现在找到**Portrait**复选框并取消选中。保持横向方向选项选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横向模式启动。我们越来越接近目标了，但背景图像仍然没有填满整个屏幕。稍后我们将讨论如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转它，选择模拟器菜单中的**Hardware** ▸ **Rotate Right**，如[图
    14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你就需要处理不同的屏幕尺寸，这意味着你需要做更多的工作，以确保你创建的艺术资源能够在每个设备上正确显示。与像我们的生日追踪器这样的基于UIKit的应用程序相比，游戏通常在这方面需要更多的努力，因为如果你只是简单地放大或缩小，游戏的艺术资源会看起来被拉伸。为避免这个问题，你需要为每个要支持的设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图像文件的系统，帮助你区分哪些图像是针对哪些设备的。例如，假设你想在游戏中添加一个滑板车图像，且你有一个宽 100 像素、高 100
    像素（100×100）的滑板车图像文件。你会将该图像命名为*skater.png*。你还需要创建一个名为*[skater@2x.png](mailto:skater@2x.png)*的图像，大小为
    200×200 像素，另外再创建一个名为*[skater@3x.png](mailto:skater@3x.png)*的图像，大小为 300×300 像素。这三张文件应该是相同图像的三种不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需要引用该文件名为
    skater，只要你在项目中正确命名了这些图像，Xcode 就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《校园滑板车》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，比如* @2x *或* @3x*。没有后缀的图像，例如*skater.png*，被视为 1x 图像。你只需要为老旧设备（如
    iPhone 3GS 或第一代 iPad mini，具有非视网膜显示屏的设备）提供 1x 大小的图像。因此，我们所有的图像文件都会有* @2x *或* @3x
    *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资产目录，你会注意到
    Xcode 将这两张图像分组在一起。如果你同时将不同尺寸的图像拖入 Xcode 资产目录，Xcode 会根据命名规则自动识别它们是同一图像的不同尺寸，并将它们分组在一起。请参见[图
    14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资产目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一点准备工作要做。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将基于我们项目中包含的*GameScene.sks*场景编辑器文件中的设置。由于我们在这个项目中不会使用场景编辑器，因此我们需要添加代码，确保我们的场景大小合适。
- en: '![](Image00287.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE11]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主要场景，因此我们希望它始终填满整个屏幕。我们在此添加的代码确定了显示视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**您学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您开始制作《Schoolhouse Skateboarder》游戏并学习了 SpriteKit。您学会了如何在 Xcode 中创建一个游戏项目，并将资产（如图像）导入到项目中。您还学习了如何通过标准的文件命名方式支持各种设备屏幕分辨率，并了解了如何选择游戏中需要的图像类型。最后，您创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编程实现一些动作。在 [第 15 章](text00027.html#ch15)
    中，我们将添加我们的英雄和她滑行的地面，让一切开始移动，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Over the next several chapters, we’ll put your new skills to good use to build
    a game called *Schoolhouse Skateboarder* , where the player controls a skateboarder
    who has to jump over obstacles and collect gems.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将充分利用您的新技能，制作一款名为 *Schoolhouse Skateboarder* 的游戏，在这款游戏中，玩家控制一名滑板手，必须跳过障碍物并收集宝石。
- en: In this chapter, you’ll set up your Xcode project file, add images for the player,
    and display a schoolyard background. [Figure 14-1](text00026.html#ch14fig1) is
    a preview of how the game will look on an iPhone. Players try to survive as long
    as possible by tapping to jump over obstacles, collecting gems and scoring points
    along the way. They lose when they tip over or fall down a hole.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将设置 Xcode 项目文件，添加玩家图像，并显示一个操场背景。[图 14-1](text00026.html#ch14fig1)展示了游戏在
    iPhone 上的预览。玩家通过点击跳跃避开障碍物，收集宝石并得分，尽可能长时间生存。当他们翻倒或掉进坑里时就失败了。
- en: '![](Image00270.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00270.jpg)'
- en: '*Figure 14-1: The finished game*'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-1：完成的游戏*'
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**我从哪里获取艺术和音效？**'
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为您创建了制作《Schoolhouse Skateboarder》游戏所需的所有艺术和音效（可通过 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    获取）。您不需要其他任何东西来跟着教程做。如果您想定制，您可以通过替换滑板手图像来使游戏独具个性，或者您可以让角色抓取汉堡包而不是宝石。
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 希望通过本书的学习，您将激发设计自己游戏的灵感。自己制作整个游戏，包括艺术作品和音效，是一件非常有成就感的事。您将完全掌控*您的*游戏的每个方面。
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上还有许多地方可以找到免费游戏艺术资源供您使用：
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://opengameart.org/](http://opengameart.org/)*** 免费游戏艺术、音效和音乐'
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://freetems.net/](http://freetems.net/)*** 免费游戏艺术和音乐'
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** 免费复古游戏音效制作工具'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Xcode 的 SpriteKit 创建游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内置的游戏引擎，用于制作二维（2D）游戏。*游戏引擎* 是一组工具，允许你快速轻松地制作动画，使用音频和音效，创建菜单系统等。程序员使用游戏引擎是为了能够专注于真正重要的事情——让游戏有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，一个游戏由许多精灵组成。*精灵* 是游戏中使用的二维图像。精灵可以是提供游戏背景的全屏图像，也可以是移动并执行某些操作的小图像。背景精灵设置了场景。例如，在一款太空射击游戏中，背景精灵可能展示一个星空和行星的场景，而玩家的宇宙飞船、敌方飞船、子弹、小行星和能量补给等则会由更小的精灵表示。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit 是顶尖的。其他游戏引擎中需要写很多行代码才能完成的任务，在 SpriteKit 中只需要一两行代码就能实现，而且使用起来很有趣！
- en: '![](Image00271.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 还有一个 3D 游戏引擎，叫做 SceneKit，但由于我们正在制作 2D 游戏，所以我们将继续使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **文件** ▸ **新建** ▸ **项目…**。在项目模板对话框中，选择
    **iOS**，选择 **游戏** 模板，然后点击 **下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在“产品名称”字段中输入你的项目名称 SchoolhouseSkateboarder。选择 **SpriteKit** 作为游戏技术。由于我们的游戏只会在
    iPhone（和 iPod touch）上运行，因此在设备设置中选择 **iPhone**。然后点击 **下一步** 来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何更改的情况下，你可以运行这个项目，屏幕上会显示一个黑色背景，标签上写着*Hello, World!*。每次你在模拟器中点击鼠标的任何地方，屏幕上会出现一个旋转的框（见[图14-2](text00026.html#ch14fig2)），标签会缩小一秒钟。如果标签显示是横向的，你可以通过选择模拟器菜单中的**硬件**
    ▸ **左旋转**来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建一个新项目时，Xcode 会添加这个简单的交互功能，让你确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：在进行任何更改之前运行由游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想在游戏中显示一个巨大的*Hello, World!*标签，所以先将其移除。这个标签存在于*场景编辑器*中，场景编辑器是一个用于可视化设计 SpriteKit
    场景的工具，类似于在 UIKit 中使用 storyboard 设计视图。你可以将对象拖入场景编辑器，移动它们，调整它们的大小、颜色和其他属性。这个工具非常有用，但与在代码中可以做的事情相比，它有很多限制。因此，除了移除*Hello,
    World!*标签外，我们在《Schoolhouse Skateboarder》项目中不会再使用场景编辑器。要打开场景编辑器，点击项目导航器中的名为 *GameScene.sks*
    的文件。加载后，你应该会看到一个黑色场景和*Hello, World!*标签。点击标签，然后按 DELETE 键。见[图 14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并移除了*Hello, World!*标签，我们可以开始正式的工作——也就是有趣的部分！
- en: '**ADDING IMAGES**'
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有的图片作为资源添加到你的项目中。（资源就是游戏中的一个元素，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载 ZIP 文件。下载完成后，你会在 *Downloads* 文件夹中看到一个名为 *ch14-images* 的文件夹，里面包含了你所需要的所有图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片文件添加到你的项目中，你需要从 Finder 中拖动它们到 Xcode，并将它们放入一个资源目录中。（资源目录是 Xcode 项目中的一种特殊文件夹，用于存放和组织项目资源，如图片文件和图标。）它对图片非常有用，因为它会将相关的图片文件分组。文件进入资源目录后，你可以通过引用文件名在代码中使用它们。我们使用的游戏模板已经自带了一个资源目录，名为
    *Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资源、AppIcon 和飞船图片。你可以删除飞船图片，因为我们不会用到它。点击它，然后按
    DELETE 键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder，导航到下载的图片文件夹。按下 ⌘ -A 选择所有文件。选中后，将它们拖入 Xcode 的资源目录，如[图 14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图片文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到所有的图片文件都是 *.png* 文件。*PNG* 代表 *便携式网络图形*，它是 iOS 应用中最常见的图片文件类型，因为它以最小的文件大小提供最佳质量的图像。你也可以使用
    *.jpg* 文件，但推荐使用 *.png* 文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**背景：显示背景图片**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有的图像添加到项目中，接下来让我们编写一些代码，在我们的应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建一个新项目时，一些有用的代码会自动添加到你的项目中。在项目导航器中点击名为*GameScene.swift*的文件。你应该会看到已经存在的代码。这段代码有两个目的。首先，它给你展示了如何创建一个形状（旋转的盒子）以及如何执行一个动作（让盒子旋转）。其次，它让你可以立即运行新项目，并确保一切都设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们将删除大部分代码并添加我们自己的代码。请继续删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE12]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑都将在GameScene类中处理。你可以把一个场景看作是你应用中的一个视图或屏幕。GameScene类将管理场景内发生的一切——精灵的显示方式、玩家与游戏的互动方式以及得分方式。复杂的游戏可能会有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性发生的事情）、游戏循环或更新函数（游戏过程中反复发生的事情）和用户交互函数（只有在用户点击或滑动时发生的事情）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: setup函数didMove(to:)会在游戏首次启动时被调用。它非常适合用来设置场景的代码，比如添加初始精灵或设置玩家的分数和生命值。这与你在[第10章](text00021.html#ch10)中用来设置日期选择器的viewDidLoad()方法类似，并且它只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，必须先设置场景的anchorPoint。将以下代码行添加到didMove(to:)方法中（灰色的行表示一些现有代码，供参考）：
- en: '[PRE13]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](Image00276.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉把一张纸钉在软木板上时，图钉就是锚点。纸张将被定位在你放置图钉的地方，如果纸张旋转，它将围绕图钉旋转。这正是SpriteKit中锚点属性如何与精灵和场景一起工作的方式。游戏模板中的GameScene将锚点设置在场景的中心，但我们希望将锚点设置在场景的左下角，因此我们将其设置为CGPoint.zero，或(0,
    0)。对于某些游戏，比如太空射击游戏，将锚点设置在场景的中心更为合适。但对于我们的游戏来说，因为地面位于屏幕的底部，将锚点移到左下角将使操作更加方便。有关不同锚点位置的插图，请参见[图14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在x位置为0时，它将位于屏幕的左边缘。当我们将一个精灵放置在y位置为0时，它将位于屏幕的下边缘。
- en: '**NOTE**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建项目的每个代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式以及它如何旋转。有关使用不同锚点旋转精灵的示例，请参见[图14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用其中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，将以下代码行添加到didMove(to:)函数中：
- en: '[PRE14]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析我们刚刚添加的五行代码。第➊行创建了一个名为background的精灵，使用的是* [background@2x.png](mailto:background@2x.png)
    *文件或* [background@3x.png](mailto:background@3x.png) *文件。这两个文件早些时候已添加到资源目录中，Xcode会自动选择正确的文件。你只需在代码中引用它为“background”或“background.png”。要了解Xcode如何选择正确的文件，请参见“[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”[第213页](text00026.html#page_213)。请注意，变量名不需要与图像名匹配——你可以为变量名选择任何你喜欢的名称。然而，图像名称必须与项目中资源目录中添加的文件匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个SKSpriteNode，就像这里做的一样。*
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋行和➌行创建了常量xMid和yMid，它们表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述它在屏幕上的位置。一个frame有一个x位置、一个y位置、一个宽度和一个高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕frame的中间x位置，而midY给出了中间的y位置。
- en: '![](Image00279.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint，并将其赋值给精灵的position属性，从而将背景图片的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，它包含两个CGFloat值，分别表示x和y坐标。在处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以存储两个值，一个代表*x*，另一个代表*y*，这使得它在2D游戏中处理屏幕坐标时非常方便，因为在这种游戏中，一切都通过x和y位置来定位。
- en: '**NOTE**'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的所有内容都来自*Core Graphics框架*，这是一个用于图形处理的苹果框架。你会在Swift中经常看到这种命名方式——类或结构体的前两三个字母通常告诉你该对象的用途或来源。例如，所有的SpriteKit类，如*SKSpriteNode*，都以*SK*开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图片添加到场景中。这个精灵现在是场景的一个*子节点*，意味着它被附加到这个场景中。例如，如果场景发生变化（如缩放或消失），这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，所有精灵都是作为子对象添加到场景中，或者作为其他精灵的子对象。每次添加精灵时，考虑它的父对象非常重要。例如，滑冰精灵是场景的子对象，但如果我们想为滑冰者添加可更换的帽子，我们会使用一个帽子精灵，作为滑冰精灵的子对象。这样，当滑冰者跳跃时，帽子就会保持在滑冰者头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏的显示方式：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，然后选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，因此横屏模式（设备侧放，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏与横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，你会注意到它可能默认使用竖屏模式。让我们修改项目设置，让游戏仅在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中“竖屏”选项，保留两个横屏方向选项选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此列表将出现，并且图标会变成蓝色，表示列表区域现在正在显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**竖屏**复选框并取消选中，保留横屏方向选项选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们已经接近了，但背景图像还没有填满整个屏幕。稍后我们将看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在已运行在横屏方向，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **右旋**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源能在每个设备上正确显示。游戏在这方面比基于
    UIKit 的应用（如我们的生日追踪器）需要更多的努力，因为如果你只是简单地放大或缩小，游戏的艺术作品可能会变得拉伸。为了解决这个问题，你需要为每个你想要支持的设备使用一套不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个命名图像文件的系统，帮助你区分哪些图像适用于哪些设备。例如，假设你想在游戏中添加一个滑板运动员的图像，并且你有一个100×100像素（100×100）的滑板运动员图像文件。你应该将该图像命名为*skater.png*。你还需要创建一个命名为*[skater@2x.png](mailto:skater@2x.png)*的200×200像素图像，另一个命名为*[skater@3x.png](mailto:skater@3x.png)*的300×300像素图像。这三张文件应该是同一图像的三个不同尺寸。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件将自动被使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件将自动被使用。在你的代码中，你只需将文件名写为skater，只要你在项目中正确命名了这些图像，Xcode会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》游戏，我们将支持iPhone 4及以后的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，例如* @2x *或* @3x*。没有后缀的图片，例如* skater.png*，被认为是1x图像。你只需要为旧设备（如iPhone
    3GS或第一代iPad mini）提供1x大小的图像，这些设备没有视网膜显示屏。因此，我们所有的图像文件都将带有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为*[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图片分组在一起。如果你同时将图像拖入Xcode的资源目录，Xcode会根据图像的命名自动识别它们是同一图像的不同尺寸，并将它们分组。见[图
    14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理背景图像之前，还有最后一项准备工作需要完成。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图像没有填满整个屏幕，如[图 14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景尺寸的方式。游戏场景的大小将基于包含在我们项目中的*GameScene.sks*场景编辑文件中的设置进行调整。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE15]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了 GameScene 类的一个实例并展示它。由于 GameScene 是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示的视图的大小（宽度和高度），并设置新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 Schoolhouse Skateboarder 游戏，并学习了 SpriteKit。你学会了如何在 Xcode 中创建一个游戏项目并导入资产，如图像等。你还了解了如何通过标准文件命名实践来支持各种设备的屏幕分辨率，以及如何选择在游戏中需要的图像类型。最后，你创建并展示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: In this chapter, you’ll set up your Xcode project file, add images for the player,
    and display a schoolyard background. [Figure 14-1](text00026.html#ch14fig1) is
    a preview of how the game will look on an iPhone. Players try to survive as long
    as possible by tapping to jump over obstacles, collecting gems and scoring points
    along the way. They lose when they tip over or fall down a hole.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将设置你的 Xcode 项目文件，为玩家添加图片，并展示一个操场背景。[图 14-1](text00026.html#ch14fig1)是游戏在
    iPhone 上的预览。玩家通过点击屏幕跳过障碍、收集宝石并沿途得分，尽可能长时间生存。当玩家翻倒或掉进洞里时就会失败。
- en: '![](Image00270.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00270.jpg)'
- en: '*Figure 14-1: The finished game*'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-1：完成的游戏*'
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**我从哪里获得艺术和音效？**'
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了制作 Schoolhouse Skateboarder 所需的所有艺术和音效资源（可从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载）。你不需要其他任何东西来跟随本书。如果你想定制游戏，你可以通过将滑板手的图像替换为你选择的角色，或者让某个人拿着汉堡而不是宝石，来使游戏成为你自己的。
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到本书结束时，你会受到启发，设计自己的游戏。独立制作整个游戏，包括艺术作品和音效，能够带来很大的成就感。你将完全控制*你的*游戏的各个方面。
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上也有很多地方可以找到免费的游戏艺术资源：
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://opengameart.org/](http://opengameart.org/)*** 免费游戏艺术、声音和音乐'
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://freetems.net/](http://freetems.net/)*** 免费游戏艺术和音乐'
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** 免费复古游戏音效制作工具'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Xcode 的 SpriteKit 制作游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内建的游戏引擎，用于制作二维（2D）游戏。*游戏引擎*是一组工具，可以让你快速且轻松地制作动画、使用音频和音效、创建菜单系统等。程序员使用游戏引擎是为了能专注于真正重要的事情——让游戏更有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，游戏由许多精灵（sprites）组成。*精灵*是游戏中使用的 2D 图像。精灵可以是全屏图像，作为游戏的背景，也可以是较小的图像，移动并执行某些操作。背景精灵设置了游戏的舞台。例如，在一款太空射击游戏中，背景精灵可能会展示一个星空和行星的场景，而较小的精灵则用来表示玩家的飞船、敌方飞船、子弹、小行星和增强物。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit 非常优秀。其他游戏引擎中需要多行代码才能完成的任务，在 SpriteKit 中只需要一两行代码，而且使用起来很有趣！
- en: '![](Image00271.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 还有一个名为 SceneKit 的 3D 游戏引擎，但由于我们正在构建一个 2D 游戏，所以我们会坚持使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **文件** ▸ **新建** ▸ **项目...**
    。在项目模板对话框中，选择 **iOS**，选择 **游戏** 模板，然后点击 **下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在“产品名称”字段中将你的项目命名为 SchoolhouseSkateboarder。选择 **SpriteKit** 作为游戏技术。由于我们的游戏将只在
    iPhone（和 iPod touch）上运行，因此选择 **iPhone** 作为设备设置。然后点击 **下一步** 来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何更改的情况下，你可以运行这个项目，你会看到一个黑色屏幕，上面有一个写着*Hello, World!*的标签。每当你在模拟器中点击鼠标的任何地方，屏幕上会出现一个旋转的框（见[图
    14-2](text00026.html#ch14fig2)），并且标签会缩小一秒钟。如果标签显示的是横向的，你可以通过选择模拟器菜单中的**硬件** ▸
    **旋转左侧**来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建一个新项目时，Xcode 会添加这个简单的互动功能，以确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：在进行任何更改之前运行通过游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望在游戏中看到一个巨大的 *Hello, World!* 标签，首先将其移除。该标签存在于 *场景编辑器* 中，场景编辑器是一个用于可视化设计
    SpriteKit 场景的工具，类似于 UIKit 中用来设计视图的 storyboard。你可以将对象拖入场景编辑器，移动它们，改变大小、颜色及其他属性。这是一个有用的工具，但相比于代码中的实现，它有许多限制。因此，除了移除
    *Hello, World!* 标签外，我们不会在《Schoolhouse Skateboarder》项目中使用场景编辑器。要打开场景编辑器，请在项目导航器中点击名为
    *GameScene.sks* 的文件。加载后，你应该会看到一个黑色的场景，并且有 *Hello, World!* 标签。点击标签，然后按 DELETE。参见
    [图 14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并移除了*Hello, World!* 标签，我们可以开始正式的工作了——那就是，享受其中的乐趣！
- en: '**ADDING IMAGES**'
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图像添加到项目中作为资源。（资源只是你游戏中的一些元素，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载 ZIP 文件。下载完成后，你会在 *Downloads* 文件夹内看到一个名为 *ch14-images* 的文件夹，其中包含所有所需的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到项目中，你需要从 Finder 中将它们拖到 Xcode，并将它们放入资源目录中。（资源目录是 Xcode 项目中的一种特殊文件夹，用来存放和组织项目资源，如图像文件和图标。）它对于图像非常有用，因为它将相关的图像文件分组在一起。将文件放入资源目录后，你可以通过引用文件名在代码中随时使用它们。我们使用的游戏模板已经包含了一个资源目录，名为
    *Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *Assets.xcassets*。你应该能看到现有的资源，AppIcon 和飞船图像。由于我们不会使用飞船图像，你可以删除它。点击图像，然后按
    DELETE。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder 并导航到图像文件下载所在的文件夹。按 ⌘ -A 选择所有文件。一旦文件被高亮显示，像 [图 14-4](text00026.html#ch14fig4)
    所示，将它们拖入 Xcode 资源目录中。
- en: '![](Image00275.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图像文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有的图像文件都是 *.png* 文件。*PNG* 代表 *可移植网络图形*，它是 iOS 应用中最常用的图像文件格式，因为它在保持最佳质量的同时，文件大小最小。你可以使用
    *.jpg* 文件，但推荐使用 *.png* 文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已将所有图片添加到项目中，让我们编写代码在应用程序中显示背景图片。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建一个新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中名为*GameScene.swift*的文件，你应该能看到已经存在的一些代码。这些代码有两个目的。首先，它给你一个如何创建形状（旋转的盒子）以及如何执行动作（让盒子旋转）的示例。其次，它让你能够立即运行一个新项目，并确保一切都已正确设置。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将删除大部分代码并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，代码应如下所示：
- en: '*GameScene.swift*'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE16]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大多数逻辑都将在GameScene类中。可以把场景想象成你应用程序中的一个视图或屏幕。GameScene类将管理场景内发生的一切——如何显示精灵，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能会有许多独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（执行一次的操作）、游戏循环或更新函数（在游戏过程中反复执行的操作），以及用户交互函数（仅在用户点击或滑动时执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数didMove(to:)会在游戏开始时被调用。它非常适合用于设置场景的代码，例如添加初始精灵或设置玩家的得分和生命值。这与[第10章](text00021.html#ch10)中你用来设置AddBirthdayViewController中日期选择器的viewDidLoad()方法类似，且只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在将背景图片添加到场景之前，我们必须设置场景的anchorPoint。将这行代码添加到didMove(to:)方法中（灰色行表示一些现有的代码，仅用于参考）：
- en: '[PRE17]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](Image00276.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用大头针将一张纸固定在软木板上时，大头针就是锚点。纸张将根据你放置大头针的位置进行定位，如果纸张旋转，它将围绕大头针旋转。这正是锚点属性在
    SpriteKit 中与精灵和场景一起工作的方式。游戏模板的 GameScene 的锚点位于场景的中心，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero，或者 (0, 0)。对于某些游戏，例如太空射击游戏，将锚点设置在场景中心更为合适。但对于我们的游戏，地面位于屏幕底部，将锚点移到左下角会使操作更加简便。有关不同锚点的插图，请参见[图14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 位置为 0 时，它将位于屏幕的左边缘。当我们将精灵放置在 y 位置为 0 时，它将位于屏幕的下边缘。
- en: '**NOTE**'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获得。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式和旋转方式。有关使用不同锚点旋转精灵的示例，请参见[图14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要加载背景图像，向 didMove(to:) 函数中添加以下几行代码：
- en: '[PRE18]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看刚才添加的五行代码。➊ 处的代码创建了一个名为 background 的精灵，使用的是 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已经添加到资产目录中，Xcode
    会自动选择合适的文件。你只需要在代码中引用它为 "background" 或 "background.png"。要理解 Xcode 如何选择合适的文件，请参见
    “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)” 在[第213页](text00026.html#page_213)。注意，变量名不需要与图像名匹配——你可以为变量命名任何你想要的名称。然而，图像名必须与项目中添加到资产目录中的文件匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此，当我们在游戏中创建精灵时，我们将创建一个 SKSpriteNode，就像我们这里做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➋ 和 ➌ 行创建了常量 xMid 和 yMid，它们表示屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它在屏幕上的位置。框架有一个
    x 坐标、一个 y 坐标、一个宽度和一个高度（见[图 14-7](text00026.html#ch14fig7)）。midX 属性给出屏幕框架的中间 x
    坐标，midY 给出屏幕框架的中间 y 坐标。
- en: '![](Image00279.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➍ 行通过创建一个使用 xMid 和 yMid 的 CGPoint，并将其赋值给精灵的 position 属性，设置了背景图像的位置，使其处于屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 和 y 坐标。当你处理屏幕坐标时，通常会使用 CGFloat 数据类型，而不是
    Float 或 Double。一个 CGPoint 可以包含两个值，一个是 *x* 坐标，另一个是 *y* 坐标，这使得在处理二维游戏中的屏幕坐标时非常方便，因为所有的东西都使用
    x 和 y 坐标进行定位。
- en: '**NOTE**'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何内容都来自于* Core Graphics 框架*，这是苹果用于图形处理的框架。你会在 Swift 中经常看到这种命名系统——类或结构体的前两个或三个字母通常会告诉你该对象的用途或来源。例如，所有的
    SpriteKit 类，比如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➎ 行通过调用函数 addChild(_:) 向场景中添加背景图像。这个精灵现在是场景的*子对象*，意味着它附属于这个场景。例如，如果场景发生变化（变大、变小或消失），这个子精灵也会发生相应变化。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵都是场景的子对象或另一个精灵的子对象。每次添加精灵时，都要考虑这个精灵应该属于哪个父对象。例如，滑冰精灵是场景的子对象，但如果我们想给滑冰精灵添加可更换的帽子，我们会使用帽子精灵，它是滑冰精灵的子对象。这样，无论滑冰精灵跳跃时，帽子都会保持在滑冰精灵上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持纵向和横向模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后只选择那一个方向。由于我们的游戏是一个横向滚动的动作游戏，所以横向方向（设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在纵向与横向方向下的表现*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，你会发现它可能默认使用纵向方向。让我们修改项目设置，使得游戏仅在横向方向运行。前往项目导航器，点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中“纵向”选项，保留两个“横向”方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上没有看到“项目”和“目标”列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。这个列表将会出现，图标会变成蓝色，表示现在正在显示列表区域。确保选择了**SchoolhouseSkateboarder**目标。然后找到**纵向**复选框，取消选中它。保留横向方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横向方向启动。我们离目标更近了，但背景图像还没有填满屏幕。稍后我们将看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏现在以横向方向运行的情况下，你需要确保模拟器也处于横向方向。要旋转模拟器，选择模拟器菜单中的**硬件** ▸ **右旋**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。与像我们的生日追踪器这样的基于UIKit的应用相比，游戏在这方面通常需要更多的努力，因为如果你只是将游戏艺术作品放大或缩小，它会显得被拉伸。为避免这个问题，你需要为每个想要支持的设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图像文件的规则，帮助你判断哪些图像适用于哪些设备。例如，假设你想在游戏中添加一张滑板图片，并且你有一张宽 100 像素、高 100
    像素的滑板图像文件（100×100）。你会将这张图像命名为 *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，尺寸为 200×200 像素，另一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，尺寸为 300×300
    像素。这三张文件应该是同一图像的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件将自动被使用。在你的代码中，你只需引用图像文件名为 skater，Xcode 会根据你在项目中正确命名的图像自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被认为是 1x 图像。你只需要为那些具有非视网膜显示屏的旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 大小的图像。因此，我们所有的图像文件都会有* @2x *或* @3x *的后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会发现 Xcode 将这两张图像归类在一起。如果你同时将图像拖入 Xcode 资源目录，Xcode 会自动识别这些图像是同一图像的不同尺寸，因为它们的命名方式，并将它们归类在一起。请参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图像在资源目录中被归类在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理背景图像之前，还需要做最后的准备工作。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如 [图
    14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的 *GameScene.sks*
    场景编辑器文件中的设置来确定。在本项目中我们不会使用场景编辑器，因此我们需要添加代码以确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像未填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件并找到 viewDidLoad() 方法。添加以下代码行以设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE19]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了所显示视图的大小（宽度和高度），并设置了新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并了解了SpriteKit。你学习了如何在Xcode中创建一个游戏项目并将资产（例如图像）导入到项目中。你还了解了如何通过标准文件命名规范支持各种设备的屏幕分辨率，以及如何选择在游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作代码。在[第15章](text00027.html#ch15)中，我们将加入我们的英雄角色和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00270.jpg)'
  id: totrans-553
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00270.jpg)'
- en: '*Figure 14-1: The finished game*'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-1：完成的游戏*'
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**我从哪里获得艺术和音效？**'
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为你制作了制作《Schoolhouse Skateboarder》所需的所有艺术和音效素材（可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取）。你不需要其他素材就可以继续学习。如果你想定制它，你可以通过将滑板车手的图像替换为你选择的角色，或者让某个角色抓取汉堡而不是宝石，来让游戏变得独一无二。
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到本书结束时，你能受到启发，设计你自己的游戏。独立制作整个游戏，包括艺术作品和音效，能够带来成就感。你将完全掌控*你*的游戏的每个方面。
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多地方你可以在网上找到免费的游戏艺术素材：
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://opengameart.org/](http://opengameart.org/)** 免费游戏艺术、音效和音乐'
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://freetems.net/](http://freetems.net/)** 免费游戏艺术和音乐'
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://www.bfxr.net/](http://www.bfxr.net/)** 免费复古游戏音效制作工具'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Xcode的SpriteKit制作游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit是iOS内建的游戏引擎，用于制作二维（2D）游戏。*游戏引擎*是一组工具，能够让你快速轻松地制作动画、使用音频和音效、创建菜单系统等等。程序员使用游戏引擎，让他们能够专注于最重要的事情——让游戏变得有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个游戏由许多精灵组成。*精灵*是游戏中使用的二维图像。精灵可以是提供游戏背景的全屏图像，也可以是小型图像，它们在游戏中移动并执行各种操作。背景精灵设置了舞台。例如，在一个太空射击游戏中，背景精灵可能展示一个星空和行星的场景，而玩家的飞船、敌方飞船、子弹、小行星和能量道具等则是较小的精灵。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit是一流的。其他游戏引擎需要很多行代码才能完成的任务，在SpriteKit中只需一两行代码就能实现，而且使用起来很有趣！
- en: '![](Image00271.jpg)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS还有一个名为SceneKit的3D游戏引擎，但由于我们正在开发一款2D游戏，因此我们将继续使用SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的SpriteKit项目。打开Xcode并选择**文件** ▸ **新建** ▸ **项目…**。在项目模板对话框中，选择**iOS**，选择**游戏**模板，然后点击**下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中将你的项目命名为SchoolhouseSkateboarder。选择**SpriteKit**作为游戏技术。由于我们的游戏只会在iPhone（和iPod
    touch）上运行，选择**iPhone**作为设备设置。然后点击**下一步**来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何更改的情况下，你可以运行这个项目，并且你会看到一个黑色的屏幕，屏幕上有一个写着*Hello, World!*的标签。每当你在模拟器中点击鼠标时，屏幕上会出现一个旋转的盒子（见[图
    14-2](text00026.html#ch14fig2)），并且标签会缩小一秒钟。如果标签显示为侧向，你可以通过选择模拟器菜单中的**硬件** ▸ **旋转左侧**来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建新项目时，Xcode会添加一个简单的交互功能，以确保一切正常运行。
- en: '![](Image00272.jpg)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：在进行任何更改之前运行由游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望游戏中出现一个巨大的*Hello, World!*标签，首先让我们删除它。该标签存在于*场景编辑器*中，这是一个用于可视化设计SpriteKit场景的工具，类似于在UIKit中使用故事板设计视图。你可以将对象拖入场景编辑器，移动它们，调整大小、颜色和其他属性。这个工具非常有用，但与代码中可以实现的功能相比，它有许多限制。因此，除了删除*Hello,
    World!*标签之外，我们不会在《Schoolhouse Skateboarder》游戏中使用场景编辑器。要打开场景编辑器，请在项目导航器中点击名为*GameScene.sks*的文件。加载后，你应该能看到一个黑色的场景，里面有*Hello,
    World!*标签。点击该标签，然后按DELETE键。参见[图 14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：删除游戏模板中的*Hello, World!*标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并删除了*Hello, World!*标签，我们可以开始真正的工作了——也就是有趣的部分！
- en: '**ADDING IMAGES**'
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图像作为资源添加到项目中。（资源就是你游戏中的元素，例如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你将在*Downloads*文件夹中找到一个名为*ch14-images*的文件夹，里面包含了所有需要的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到项目中，你需要将它们从Finder中拖到Xcode，并放入资源目录中。（资源目录是Xcode项目中的一种特殊文件夹，用来存储和组织项目资源，如图像文件和图标。）对于图像来说，它很有用，因为它将相关的图像文件归类在一起。一旦文件进入资源目录，你就可以在代码中通过引用它们的文件名来使用它们。我们使用的游戏模板已经有一个名为*Assets.xcassets*的资源目录，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资源，如AppIcon和飞船图像。你可以删除飞船图像，因为我们不会使用它。点击它然后按DELETE键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，导航到下载图像文件的文件夹。按⌘-A全选所有文件。选中它们后，将它们拖入Xcode资源目录，如[图 14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-587
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图像文件添加到项目的资源目录*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有的图像文件都是*.png*文件。*PNG*代表*便携式网络图形*，它是iOS应用中最常用的图像文件类型，因为它具有最小的文件大小和最佳的图像质量。你也可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，让我们写一些代码在应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码已经自动添加到你的项目中了。点击项目导航器中名为*GameScene.swift*的文件。你应该能看到已经存在的一些代码。这些代码有两个目的。首先，它给你一个如何创建形状（旋转的盒子）和如何执行动作（让盒子旋转）的示例。其次，它让你能够立即运行新项目，确保一切设置正常。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们将移除大部分代码并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数的声明和update(_:)函数，这样它看起来应如下所示：
- en: '*GameScene.swift*'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE20]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑都将位于 GameScene 类中。可以把场景看作是应用中的一个视图或屏幕。GameScene 类将管理场景内发生的所有事情——比如精灵的显示方式、玩家与游戏的互动方式以及得分的方式。复杂的游戏可能有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。而我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性操作），游戏循环或更新函数（在游戏过程中反复执行的操作），以及用户交互函数（只有在用户点击或滑动时执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: setup 函数 didMove(to:) 在游戏首次启动时调用。它非常适合用于设置场景的代码，比如添加初始精灵或设置玩家的得分和生命值的代码。它类似于你在
    [第10章](text00021.html#ch10) 中使用的 viewDidLoad() 方法，用于在 AddBirthdayViewController
    中设置日期选择器，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们必须先设置场景的 anchorPoint。将这行代码添加到 didMove(to:) 方法中（灰色行表示现有代码的位置）：
- en: '[PRE21]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](Image00276.jpg)'
  id: totrans-601
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的 anchorPoint 决定了精灵在场景中的位置。当你用图钉把纸张钉到软木板上时，图钉就是锚点。纸张将被定位在你放置图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是
    anchorPoint 属性在 SpriteKit 中处理精灵和场景的方式。Game 模板的 GameScene 场景将锚点设置在场景的中央，但我们希望将锚点设置在场景的左下角，所以我们将其设置为
    CGPoint.zero，或 (0, 0)。对于一些游戏，比如太空射击游戏，最好将锚点设置在场景的中央。但对于我们的游戏来说，因为地面位于屏幕底部，将锚点移到左下角会更容易操作。请参见
    [图14-5](text00026.html#ch14fig5)，查看不同锚点位置的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-603
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 位置为 0 时，它将位于屏幕的左边缘。当我们将精灵放置在 y 位置为 0 时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建项目的每一个代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置精灵的锚点，从而改变精灵的位置和旋转方式。请参见 [图 14-6](text00026.html#ch14fig6)，了解使用不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，将以下代码行添加到 `didMove(to:)` 函数中：
- en: '[PRE22]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析刚才添加的五行代码。➊ 这一行创建了一个名为 `background` 的精灵，使用 `*[background@2x.png](mailto:background@2x.png)*`
    文件或 `*[background@3x.png](mailto:background@3x.png)*` 文件。两个文件都已经添加到资源目录中，Xcode
    会自动选择正确的文件。你只需要在代码中引用它们为 "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参阅
    “[为不同屏幕分辨率调整图像尺寸](text00026.html#ch14lev1sec7)” 第 [213 页](text00026.html#page_213)。请注意，变量名不必与图像名匹配—你可以随便给变量命名。然而，图像名必须与项目中资源目录中的文件匹配。`SKSpriteNode`
    是 SpriteKit 中的精灵类，因此，当我们在游戏中创建精灵时，我们将创建一个 `SKSpriteNode`，就像这里一样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 和 ➌ 这两行创建了常量 `xMid` 和 `yMid`，它们表示屏幕的中间位置。`frame` 是 `GameScene` 的一个属性，它是一个
    `CGRect`（矩形），表示整个屏幕。每个场景和精灵都有一个框架，用于描述它们在屏幕上的位置。一个框架有一个 x 位置、一个 y 位置、一个宽度和一个高度（参见
    [图 14-7](text00026.html#ch14fig7)）。`midX` 属性给我们提供了屏幕框架的中间 x 位置，`midY` 给我们提供了中间的
    y 位置。
- en: '![](Image00279.jpg)'
  id: totrans-617
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ 这行代码将我们的背景图像位置设置为屏幕的中央，方法是使用 `xMid` 和 `yMid` 创建一个 `CGPoint`，并将其分配给精灵的 `position`
    属性。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGPoint` 是一个结构体，用于存储两个 `CGFloat` 值，分别表示 x 和 y 坐标。当处理屏幕坐标时，通常使用 `CGFloat` 作为数据类型，而不是
    `Float` 或 `Double`。一个 `CGPoint` 可以存储两个值，一个表示 *x* 坐标，一个表示 *y* 坐标，这使得它在 2D 游戏中处理屏幕坐标变得方便，因为在游戏中，一切都需要使用
    x 和 y 位置来定位。'
- en: '**NOTE**'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何内容都来自* Core Graphics框架*，这是一个用于图形的苹果框架。你会在Swift中经常看到这种命名方式——类或结构体的前两到三个字母通常会告诉你这个对象的用途或来源。例如，所有的SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: ➎这一行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子节点*，意味着它附加在这个场景上。例如，如果场景变大、变小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都是作为场景的子对象或另一个精灵的子对象添加的。每次添加精灵时，重要的是要考虑这个精灵的父对象应该是什么。例如，溜冰者精灵是场景的子节点，但如果我们想给溜冰者加上可更换的帽子，我们会使用一个帽子精灵，它是溜冰者精灵的子节点。这样，每当溜冰者跳跃时，帽子就会留在溜冰者身上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-624
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏播放方式：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个能在竖屏和横屏模式下都能运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，横屏方向（设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏方向下的样子*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，你会注意到它可能默认是竖屏方向。我们来更改项目设置，让游戏只在横屏模式下运行。转到项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-629
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-632
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选竖屏选项，保留勾选横屏方向的两个选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上没有看到项目和目标的列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。这个列表将会出现，图标会变为蓝色，表示现在显示了列表区域。确保**SchoolhouseSkateboarder**目标已被选中。然后找到**Portrait**复选框并取消勾选。保持横屏方向选项已勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行游戏，你会看到它以横屏模式启动。我们越来越接近目标了，但背景图像仍然没有填满整个屏幕。稍后我们将看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转模拟器，请从模拟器菜单中选择**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-637
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你需要处理的屏幕尺寸就越多，这意味着你需要额外工作，确保你创建的艺术资源能够在每个设备上正确显示。游戏在这方面通常比基于UIKit的应用程序（如我们的生日追踪器）需要更多的工作，因为如果你只是简单地缩放艺术资源，游戏的图像会显得拉伸。为避免这个问题，你必须为每个要支持的设备准备不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一套命名图像文件的规则，帮助你区分不同设备的图像。例如，假设你想要为游戏添加一张滑冰者的图片，而你的滑冰者图像文件是100像素宽、100像素高（100×100）。你会将该图像命名为*skater.png*。你还需要创建一个名为*
    [skater@2x.png](mailto:skater@2x.png) *的图像，尺寸为200×200像素，以及另一个名为* [skater@3x.png](mailto:skater@3x.png)
    *的图像，尺寸为300×300像素。这三张文件应该是同一张图片的三种不同尺寸。如果游戏在iPhone 4上运行，带有* @2x *后缀的文件会自动使用。如果游戏在iPhone
    6 Plus上运行，带有* @3x *后缀的文件会自动使用。在你的代码中，你只需引用文件名为skater ，只要你在项目中正确命名了图像，Xcode将显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《滑板学校》，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被认为是1x图像。你只需要为旧设备（如iPhone
    3GS或第一代iPad mini）包含1x大小的图像，因为这些设备没有视网膜显示屏。因此，我们所有的图像文件都会有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图像分组在一起。如果你同时将两张不同尺寸的图像拖入Xcode的资源目录，Xcode会根据它们的命名自动识别它们是同一图像的不同尺寸，并将它们分组在一起。请参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图像在资源目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作需要完成。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图像没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将根据包含在我们项目中的*GameScene.sks*场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，所以需要添加代码来确保场景的大小设置正确。
- en: '![](Image00287.jpg)'
  id: totrans-650
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE23]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了GameScene类的一个实例并显示它。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了显示视图的大小（宽度和高度），并设置新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并了解了SpriteKit。你学会了如何在Xcode中创建游戏项目并导入资源，例如图像。你还学会了如何通过标准的文件命名规则来支持不同设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了SpriteKit游戏项目，并准备好了所需的资源，解决了屏幕方向和分辨率的问题，接下来该编程一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-660
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '*Figure 14-1: The finished game*'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-1：完成的游戏*'
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  id: totrans-662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**我在哪里可以获得艺术和音效？**'
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了制作 Schoolhouse Skateboarder 所需的所有艺术和音效（可从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    获取）。你不需要其他任何东西就可以继续跟进。如果你想自定义，你可以通过将滑板手的图像替换为你选择的角色，或者你也可以让某个角色抓取汉堡而不是宝石，将游戏变得更加个性化。
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在本书结束时，你会受到启发，设计你自己的游戏。独自制作整个游戏，包括艺术作品和音效，是一项非常有意义的工作。你可以完全掌控*你*的游戏的每一个方面。
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上也有很多地方可以找到免费的游戏艺术资源：
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://opengameart.org/](http://opengameart.org/)*** 免费游戏艺术、声音和音乐'
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://freetems.net/](http://freetems.net/)*** 免费的游戏艺术和音乐'
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** 免费复古游戏音效制作工具'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-669
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 XCODE 的 SPRITEKIT 制作游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内置的游戏引擎，用于制作二维（2D）游戏。*游戏引擎*是一组工具，可以让你快速且轻松地制作动画、使用音频和音效、创建菜单系统等等。程序员使用游戏引擎是为了让他们专注于真正重要的部分——让游戏更有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个游戏由许多精灵组成。*精灵*是游戏中使用的 2D 图像。精灵可以是提供游戏背景的全屏图像，也可以是四处移动并执行任务的较小图像。背景精灵设定了舞台。例如，在一款太空射击游戏中，背景精灵可能展示了星空和行星的场景，而玩家的飞船、敌舰、子弹、小行星和能量提升物可能就是较小的精灵。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit 是顶级的。在其他游戏引擎中需要许多行代码才能完成的任务，在 SpriteKit 中只需一两行就能完成，而且使用起来非常有趣！
- en: '![](Image00271.jpg)'
  id: totrans-673
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 也有一个名为 SceneKit 的 3D 游戏引擎，但由于我们正在制作一个 2D 游戏，我们将坚持使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-676
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **File** ▸ **New** ▸ **Project…**
    。在项目模板对话框中，选择 **iOS** ，选择 **Game** 模板，然后点击 **Next** 。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中输入项目名称 SchoolhouseSkateboarder。选择 **SpriteKit** 作为游戏技术。由于我们的游戏仅在
    iPhone（和 iPod touch）上运行，选择 **iPhone** 作为设备设置。然后点击 **Next** 创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何更改的情况下，你可以运行这个项目，看到一个黑色的屏幕，上面有一个写着*Hello, World!*的标签。每次你在模拟器中点击鼠标时，屏幕上会出现一个旋转的框（见[图14-2](text00026.html#ch14fig2)），标签会瞬间缩小。如果标签是横着显示的，你可以通过从模拟器的菜单中选择**硬件**
    ▸ **左旋**来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建一个新项目时，Xcode都会添加这个简单的交互功能，以确保一切正常运行。
- en: '![](Image00272.jpg)'
  id: totrans-681
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：在做任何更改之前运行由游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望在游戏中有一个巨大的*Hello, World!*标签，首先让我们删除它。这个标签存在于*场景编辑器*中，这是一个用来可视化设计SpriteKit场景的工具，类似于用来设计UIKit视图的storyboards。你可以将对象拖入场景编辑器，移动它们，调整大小、颜色和其他属性。这个工具非常有用，但与通过代码可以实现的功能相比，它有很多局限性。因此，除了删除*Hello,
    World!*标签外，我们不会在《Schoolhouse Skateboarder》中使用场景编辑器。要打开场景编辑器，点击项目导航器中名为*GameScene.sks*的文件。加载后，你应该能看到一个黑色的场景和*Hello,
    World!*标签。点击标签，然后按DELETE键。请参见[图14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-684
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除游戏模板的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并删除了*Hello, World!*标签，我们可以开始真正的工作了——也就是享受乐趣！
- en: '**ADDING IMAGES**'
  id: totrans-687
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图像添加到项目中作为资源。（资源就是游戏中的一个元素，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你会在*Downloads*文件夹中看到一个名为*ch14-images*的文件夹，里面包含了所有需要的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到你的项目中，你需要从Finder将它们拖动到Xcode中，并将它们放入资源目录中。（资源目录是Xcode项目中的一种特殊文件夹，用来存储和组织项目资源，如图像文件和图标。）它对图像特别有用，因为它将相关的图像文件归为一组。一旦文件进入资源目录，你就可以通过引用文件名在代码中使用它们。我们使用的游戏模板已经包含了一个资源目录，名为*Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-691
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资源，如AppIcon和宇宙飞船图像。你可以删除宇宙飞船图像，因为我们不打算使用它。点击它，然后按DELETE键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，导航到下载图像文件的文件夹。按⌘-A全选它们。一旦它们被高亮显示，拖动它们到Xcode的资源目录中，如[图 14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-694
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图像文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有的图像文件都是*.png*文件。*PNG*代表*可移植网络图形*，它是iOS应用程序中最常用的图像文件类型，因为它提供了最佳质量图像且文件大小最小。你也可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图片添加到项目中，让我们写一些代码来在我们的应用程序中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中的*GameScene.swift*文件。你应该能看到已经存在的一些代码。这些代码有两个目的。首先，它给了你一个如何创建形状（旋转的方块）和如何执行动作（让方块旋转）的示例。其次，它让你可以立即运行一个新项目，确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将删除大部分代码并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，最终应该像这样：
- en: '*GameScene.swift*'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE24]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将位于GameScene类中。可以把一个场景看作你应用中的一个视图或屏幕。GameScene类将管理场景中的所有内容——如何显示精灵，玩家如何与游戏互动，以及如何进行计分。复杂的游戏可能有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（执行一次的操作）、游戏循环或更新函数（在游戏过程中反复执行的操作），以及用户交互函数（仅在用户点击或滑动时执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: setup函数didMove(to:)会在你的游戏第一次启动时被调用。它非常适合放置初始化场景的代码，例如添加初始精灵或设置玩家的得分和生命。它类似于你在[第10章](text00021.html#ch10)中用于设置日期选择器的viewDidLoad()方法，并且只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，必须设置场景的anchorPoint。将以下代码行添加到didMove(to:)方法中（灰色的行表示一些现有的代码，用于放置）：
- en: '[PRE25]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](Image00276.jpg)'
  id: totrans-708
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张将被放置在图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是
    anchorPoint 属性在 SpriteKit 中如何与精灵和场景一起工作的方式。游戏模板中的 GameScene 的锚点位于场景的中央，但我们希望锚点位于场景的左下角，因此我们将其设置为
    CGPoint.zero，或者 (0, 0)。对于一些游戏，比如太空射击游戏，将锚点设置在场景中央会更好。但对于我们的游戏，其中地面位于屏幕底部，将锚点移到左下角会更方便。有关各种锚点位置的说明，请参见
    [图 14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-710
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：从 (0, 0) 到 (1, 1) 的锚点不同位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 坐标为 0 的位置时，它将位于屏幕的左边缘。而当我们将精灵放置在 y 坐标为 0 的位置时，它将位于屏幕的下边缘。
- en: '**NOTE**'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式以及它的旋转方式。有关通过不同锚点旋转精灵的示例，请参见 [图 14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-717
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用其中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图片，将以下代码行添加到 didMove(to:) 函数中：
- en: '[PRE26]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步讲解刚刚添加的五行代码。➊ 这一行创建了一个名为 background 的精灵，使用的是 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件已经添加到资产目录中，Xcode 会自动选择正确的文件。你只需在代码中引用它们为
    "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参见 “[为不同屏幕分辨率调整图片大小](text00026.html#ch14lev1sec7)”
    [第 213 页](text00026.html#page_213)。请注意，变量名不必与图片名匹配——你可以为变量名使用任何你喜欢的名称。然而，图片名必须与项目中添加到资产目录中的文件匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个 SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: ➋和➌处的代码创建了常量xMid和yMid，它们代表屏幕的中央位置。frame是GameScene的一个属性，它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，用来描述它在屏幕上的位置。frame包含一个x位置、一个y位置、一个宽度和一个高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给出屏幕frame的中间x位置，midY给出屏幕frame的中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-724
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: ➍处的代码通过创建一个使用xMid和yMid的CGPoint，将背景图片的位置设置为屏幕的中央，并将其赋值给精灵的位置属性。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以包含两个值，一个用于*x*，另一个用于*y*，这使得它在2D游戏中处理屏幕坐标时非常方便，因为在这种游戏中，所有的物体都使用x和y坐标来定位。
- en: '**NOTE**'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自* Core Graphics框架*，这是Apple用于图形的一个框架。你会在Swift中经常看到这种命名系统——类或结构体的前两三个字母通常告诉你这个对象的用途或来源。例如，所有的SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: ➎处的代码通过调用函数addChild(_:)将背景图片添加到场景中。这个精灵现在是场景的*子对象*，意味着它附属于这个场景。例如，如果场景发生变化、缩小或消失，这个子精灵也会发生变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为该场景的子对象或另一个精灵的子对象进行添加。每当你添加一个精灵时，重要的是要考虑这个精灵的父对象应该是什么。例如，溜冰精灵是场景的子对象，但如果我们想要给溜冰者添加可以交换的帽子，我们会使用一个作为溜冰精灵子对象的帽子精灵。这样，每当溜冰者跳跃时，帽子会留在溜冰者头上，我们就不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-731
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个能够同时在纵向和横向模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择这一种。由于我们的游戏是一个水平滚动的动作游戏，横屏模式（设备横向放置，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-733
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在纵向和横向模式下的表现*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行该项目，你会发现它可能默认是竖屏模式。让我们修改项目设置，使游戏仅在横屏模式下运行。前往项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器顶部，旁边有一个蓝色图标，正如你在[图14-9](text00026.html#ch14fig9)中看到的那样。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-736
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-739
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中竖屏选项，保留选中两个横屏选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到屏幕上的项目和目标列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此列表将会显示，且图标会变为蓝色，表示列表区域已经显示。确保选中了**SchoolhouseSkateboarder**目标。现在找到**竖屏**复选框并取消勾选，保持横屏选项选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经接近了，但背景图像还没有填充整个屏幕。稍后我们将看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在运行在横屏模式下，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-744
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，首先需要决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理更多的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源在每个设备上都能正确显示。游戏在这方面的要求通常比基于
    UIKit 的应用程序（例如我们的生日追踪器）更多，因为如果你仅仅将游戏艺术资源放大或缩小，它们会显得被拉伸。为了解决这个问题，你需要为每个想要支持的设备准备一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-748
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一种命名图像文件的系统，帮助你识别哪些图像是用于哪些设备。例如，假设你想在游戏中添加一个滑板手的图像，并且你有一个 100 像素宽和 100
    像素高的滑板手图像文件（100×100）。你将命名该图像为 *skater.png*。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，尺寸为 200×200 像素，以及另一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，尺寸为 300×300
    像素。这三张文件应该是同一张图像的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6
    Plus 上运行，则会自动使用带有 *@3x* 后缀的文件。在你的代码中，你只需要引用文件名 skater ，只要你在项目中正确命名了这些图像，Xcode
    会自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，例如 *skater.png*，被视为 1x 图像。你只需要为那些没有视网膜显示屏的旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 大小的图像。因此，我们所有的图像文件将都带有 *@2x* 或 *@3x* 后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图片分组在一起。如果你同时将这两张图像拖入 Xcode 资源目录，Xcode
    会根据图像命名的方式自动识别它们是同一张图像的不同尺寸并将它们分组。请参见 [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-754
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图像在资源目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从背景图像部分继续之前，还有最后一个准备工作需要处理。你可能注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如
    [图 14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将基于我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置。由于我们在这个项目中不使用场景编辑器，因此我们需要添加代码，确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-757
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像未能填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，并找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE27]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-764
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《Schoolhouse Skateboarder》游戏并学习了 SpriteKit。你学会了如何在 Xcode 中创建游戏项目并将资源（如图像）导入项目。你还了解了如何通过标准的文件命名规范来支持各种设备屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个带有所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编程一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的主角和她滑行的地面，让所有元素开始移动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-767
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  id: totrans-768
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**我从哪里获取艺术素材和音效？**'
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了制作《Schoolhouse Skateboarder》所需的所有艺术素材和音效（可从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    获取）。你无需其他任何东西来继续学习。如果你想自定义它，你可以通过替换滑板手的图像，将游戏改成你自己的风格，或者让某个角色抓住汉堡而不是宝石。
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在本书结束时，你能受到启发，设计自己的游戏。自己完成整个游戏的制作，包括艺术作品和音效，可能是非常有成就感的。你可以完全控制*你*的游戏的每个方面。
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上也有很多地方可以找到免费的游戏艺术素材：
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://opengameart.org/](http://opengameart.org/)*** 免费游戏艺术、音效和音乐'
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://freetems.net/](http://freetems.net/)*** 免费游戏艺术和音乐'
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** 免费复古游戏声音创作工具'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-775
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Xcode 的 SpriteKit 制作游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内置的游戏引擎，用于制作二维（2D）游戏。*游戏引擎*是一套工具，能让你快速轻松地制作动画、使用音频和音效、创建菜单系统等。程序员使用游戏引擎是为了能专注于真正重要的事情——让游戏更有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，一款游戏由许多精灵组成。*精灵* 是游戏中使用的 2D 图像。精灵可以是全屏的图像，作为游戏的背景，也可以是较小的图像，移动并执行各种操作。背景精灵设定了舞台。例如，在一个太空射击游戏中，背景精灵可能会展示一个有星星和行星的太空场景，玩家的飞船、敌人的飞船、子弹、小行星和能量提升物品等则会有更小的精灵。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit 是顶级的。其他游戏引擎需要写很多行代码才能完成的任务，在 SpriteKit 中只需一两行代码即可完成，而且它非常好玩！
- en: '![](Image00271.jpg)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 还拥有一个名为 SceneKit 的 3D 游戏引擎，但由于我们正在制作一个 2D 游戏，我们将继续使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们需要做的是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **文件** ▸ **新建** ▸ **项目…** 。在项目模板对话框中，选择
    **iOS**，选择 **游戏** 模板，然后点击 **下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中为你的项目命名为 SchoolhouseSkateboarder。选择 **SpriteKit** 作为游戏技术。由于我们的游戏仅在
    iPhone（和 iPod touch）上运行，所以选择 **iPhone** 作为设备设置。然后点击 **下一步** 来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 如果什么都不改，你可以直接运行这个项目，看到一个黑色屏幕，上面有一个写着 *Hello, World!* 的标签。每次你在模拟器中点击鼠标的任何位置，屏幕上都会出现一个旋转的盒子（见
    [图 14-2](text00026.html#ch14fig2)），并且标签会瞬间缩小。如果标签出现横向显示，你可以通过选择模拟器菜单中的 **硬件**
    ▸ **旋转左侧** 来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建一个新项目时，Xcode 会自动添加这个简单的交互，确保一切正常运行。
- en: '![](Image00272.jpg)'
  id: totrans-787
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2: 在做任何修改之前运行由游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不希望在游戏中出现一个巨大的 *Hello, World!* 标签，所以先把它移除。这个标签存在于 *场景编辑器* 中，场景编辑器是一个用来可视化设计
    SpriteKit 场景的工具，类似于在 UIKit 中使用故事板来设计视图。你可以将对象拖入场景编辑器，移动它们，改变它们的大小、颜色和其他属性。这是一个非常有用的工具，但与代码中能够做到的相比，它有许多限制。因此，除了移除
    *Hello, World!* 标签，我们在《Schoolhouse Skateboarder》项目中不会使用场景编辑器。要打开场景编辑器，点击项目导航器中的
    *GameScene.sks* 文件。加载完成后，你应该能看到一个黑色的场景和 *Hello, World!* 标签。点击标签，然后按 DELETE 键。见
    [图 14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-790
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3: 删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并移除了 *Hello, World!* 标签，接下来可以开始我们的工作——当然，是与乐趣相关的工作！
- en: '**ADDING IMAGES**'
  id: totrans-793
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图像作为资源添加到项目中。（资源就是你游戏中的物品，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载 ZIP 文件。下载完成后，你会在 *Downloads* 文件夹中得到一个名为 *ch14-images* 的文件夹，里面包含了所有你需要的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到项目中，你需要从 Finder 拖动它们到 Xcode 中，并将它们放入资源目录中。（资源目录是 Xcode 项目中的一种特殊文件夹，用于存放和组织项目资源，如图像文件和图标。）它对图像特别有用，因为它将相关的图像文件组合在一起。一旦文件放入资源目录中，你可以通过引用它们的文件名在代码中任何地方使用它们。我们使用的游戏模板已经包含了一个名为
    *Assets.xcassets* 的资源目录，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-797
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *Assets.xcassets*。你应该能看到现有的资源，AppIcon 和飞船图像。你可以删除飞船图像，因为我们不再使用它。点击它，然后按
    DELETE 键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder 并导航到下载了图像文件的文件夹。按 ⌘ -A 选择所有文件。一旦它们被高亮显示，拖动它们到 Xcode 资源目录中，如 [图 14-4](text00026.html#ch14fig4)
    所示。
- en: '![](Image00275.jpg)'
  id: totrans-800
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图像文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有的图像文件都是 *.png* 文件。*PNG* 代表 *便携式网络图形*，它是 iOS 应用程序中最常用的图像文件类型，因为它在保持最佳图像质量的同时，文件大小最小。你可以使用
    *.jpg* 文件，但建议使用 *.png* 文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-803
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，让我们编写一些代码在应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建一个新项目时，某些有用的代码会自动添加到项目中。点击项目导航器中的名为 *GameScene.swift* 的文件。你应该能看到里面已经有一些代码。这些代码存在有两个原因。首先，它给了你一个如何创建形状（旋转盒子）和如何执行操作（让盒子旋转）的示例。其次，它让你能够立即运行新项目，确保一切都设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们将删除大部分代码并添加我们自己的代码。请删除 *GameScene.swift* 中的所有内容，除了 didMove(to:) 函数和 update(_:)
    函数的声明，最终应该是这样的：
- en: '*GameScene.swift*'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE28]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏的大部分逻辑将集中在 GameScene 类中。可以把场景看作是你应用中的一个视图或屏幕。GameScene 类将管理场景中发生的一切——如何显示精灵、玩家如何与游戏互动、以及如何进行计分。复杂的游戏可能会有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。而我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的操作）、游戏循环或更新函数（在游戏过程中反复执行的操作），以及用户交互函数（只有当用户点击或滑动时才会触发的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数 didMove(to:) 会在游戏首次启动时被调用。这对于设置场景的代码非常有用，例如添加初始精灵或设置玩家的分数和生命值。这与你在[第 10
    章](text00021.html#ch10)中用来设置 AddBirthdayViewController 中日期选择器的 viewDidLoad() 方法类似，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们必须先设置场景的 anchorPoint。将这行代码添加到 didMove(to:) 方法中（灰色的行表示现有代码，仅供放置参考）：
- en: '[PRE29]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](Image00276.jpg)'
  id: totrans-814
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉把一张纸钉在软木板上时，图钉就是锚点。纸张将被放置在图钉所在的位置，如果纸张旋转，它将围绕图钉旋转。这就是锚点属性在
    SpriteKit 中如何与精灵和场景一起工作的方式。Game 模板中的 GameScene 类的锚点位于场景的中央，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero 或 (0, 0)。对于一些游戏，比如太空射击游戏，将锚点设置在场景的中心更为合适。但对于我们的游戏来说，地面位于屏幕的底部，将锚点移动到左下角将使工作更为方便。请参见[图
    14-5](text00026.html#ch14fig5)以查看各种锚点的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-816
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点在 (0, 0) 到 (1, 1) 之间的各种位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们把精灵放在 x 轴位置为 0 时，它会位于屏幕的左边缘。当我们把精灵放在 y 轴位置为 0 时，它会位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建项目的每个代码文件，最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。请参见[图 14-6](text00026.html#ch14fig6)，了解如何使用不同的锚点旋转精灵。
- en: '![](Image00278.jpg)'
  id: totrans-823
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用精灵的中心点来定位它们。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，向didMove(to:)函数中添加以下代码：
- en: '[PRE30]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析我们刚刚添加的五行代码。第➊行创建了一个名为background的精灵，使用* [background@2x.png](mailto:background@2x.png)
    *文件或* [background@3x.png](mailto:background@3x.png) *文件。两个文件都已经提前添加到资源目录中，Xcode会自动选择合适的文件。你只需在代码中引用它，命名为“background”或“background.png”。要了解Xcode如何选择合适的文件，请参阅“[不同屏幕分辨率下的图片尺寸调整](text00026.html#ch14lev1sec7)”以及[第213页](text00026.html#page_213)。请注意，变量名不必与图片名匹配——你可以使用任何你想要的变量名。但图片名必须与项目中添加到资源目录中的文件名一致。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建一个精灵时，我们将创建一个SKSpriteNode，就像我们在这里做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们代表屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个描述其在屏幕上位置的frame。frame有一个x坐标、一个y坐标、一个宽度和一个高度（参见[图
    14-7](text00026.html#ch14fig7)）。midX属性给我们屏幕frame的中间x位置，midY给我们屏幕frame的中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-830
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过创建一个使用xMid和yMid的CGPoint并将其赋值给精灵的位置属性，将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，表示x和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以包含两个值，一个表示*x*，另一个表示*y*，这使得它在处理2D游戏中的屏幕坐标时非常方便，因为游戏中的一切都是基于x和y坐标来定位的。
- en: '**NOTE**'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自* Core Graphics框架*，这是一个用于图形的苹果框架。你会注意到这种命名方式在Swift中非常常见—类或结构体的前两个或三个字母通常会告诉你这个对象的用途或它来自哪里。例如，所有SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它与这个场景是绑定的。例如，如果场景发生变化，变大、缩小或消失，这个子精灵也会受到影响。在SpriteKit游戏中，场景始终是父对象，每个精灵作为该场景的子对象或者作为另一个精灵的子对象被添加。每次添加精灵时，重要的是要思考这个精灵的父对象应该是什么。例如，滑板精灵是场景的子对象，但如果我们想为滑板精灵添加可互换的帽子，我们会使用一个帽子精灵，它是滑板精灵的子对象。这样，每当滑板精灵跳跃时，帽子会一直保持在滑板精灵身上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-837
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并只选择那一种。由于我们的游戏是一个横向滚动的动作游戏，横屏方向（即设备侧卧，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-839
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏与横屏模式下的表现*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用iPhone 7模拟器，你会注意到它可能默认是竖屏模式。让我们更改项目设置，使得游戏只在横屏模式下运行。进入项目导航器并点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，正如在[图14-9](text00026.html#ch14fig9)中所见。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-842
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-845
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中竖屏选项，保持两个横屏方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此时，列表将会出现，图标会变为蓝色，表示该列表区域已显示。确保选择了**SchoolhouseSkateboarder**目标。接下来，找到**Portrait**复选框并取消选中它。保持横屏方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经接近完成了，但背景图像还没有完全填充屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转模拟器，选择模拟器菜单中的 **硬件** ▸ **右旋**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-850
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-852
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，应该先决定我们要支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理的屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的艺术资源在每个设备上都能正确显示。游戏通常比基于
    UIKit 的应用（例如我们的生日跟踪器）需要更多的工作，因为如果你只是简单地缩放艺术资源，游戏的图像会看起来被拉伸。为了避免这个问题，你需要为每个你想支持的设备准备一套不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-854
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套图像文件命名系统，帮助你区分哪些图像适用于哪些设备。例如，假设你想为你的游戏添加一张滑冰者的图像，并且你有一张宽 100 像素、高 100
    像素（100×100）的滑冰者图像文件。你应该将这张图像命名为 *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，尺寸为 200×200 像素，另再创建一张名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，尺寸为 300×300
    像素。这三张文件应该是同一张图像，只不过大小不同。如果游戏运行在 iPhone 4 上，带有 *@2x* 后缀的文件会自动被使用。若游戏运行在 iPhone
    6 Plus 上，带有 *@3x* 后缀的文件会自动被使用。在代码中，你只需要引用文件名 skater，只要你在项目中正确命名了图像，Xcode 就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《滑板学校》这款游戏，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被认为是 1x 图像。你只需要为旧设备提供
    1x 大小的图像，这些设备没有视网膜显示屏，比如 iPhone 3GS 或第一代 iPad mini。因此，我们所有的图像文件都会带有* @2x *或* @3x
    *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会发现 Xcode 将这两张图像分组在一起。如果你同时将多个图像拖入 Xcode 资源目录，Xcode 会根据图像的命名自动识别它们是同一图像的不同尺寸，并将它们分组在一起。请参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-860
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如
    [图 14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将基于我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置。由于我们在本项目中不会使用场景编辑器，因此我们需要添加代码来确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-863
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件并找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE31]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了 GameScene 类的一个实例并显示它。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该已经填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了关于 SpriteKit 的知识。你学习了如何在 Xcode 中创建一个游戏项目并将资源（如图片）导入到项目中。你还了解了通过标准文件命名惯例来支持各种设备屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作代码。在 [第 15 章](text00027.html#ch15)
    中，我们将添加我们的英雄角色和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-873
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了制作 Schoolhouse Skateboarder 所需的所有艺术作品和音效（可从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    获得）。你无需其他任何内容即可跟随本书进行。如果你想自定义，可以通过替换滑板手的图像为你选择的角色，或者让某个角色抓取汉堡而不是宝石，来让游戏更具个性。
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在本书结束时，你会受到启发，设计自己的游戏。自己制作整个游戏，包括艺术作品和音效，是一项很有成就感的工作。你将完全掌控 *你* 的游戏的每个方面。
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 网上也有很多地方可以找到免费的游戏艺术资源：
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://opengameart.org/](http://opengameart.org/)*** 免费的游戏艺术、音效和音乐'
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://freetems.net/](http://freetems.net/)*** 免费的游戏艺术和音乐'
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** 免费的复古游戏音效创建工具'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-880
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Xcode 的 SpriteKit 制作游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内置的游戏引擎，用于制作二维（2D）游戏。*游戏引擎* 是一组工具，允许你快速轻松地制作动画，使用音频和音效，创建菜单系统等。程序员使用游戏引擎，以便他们能够专注于真正重要的事情——让游戏有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，游戏由许多精灵组成。*精灵* 是游戏中使用的 2D 图像。精灵可以是全屏图像，为游戏提供背景，或者它们可以是较小的图像，移动并执行一些动作。背景精灵设置了游戏的舞台。例如，在一款太空射击游戏中，背景精灵可能显示带有星星和行星的太空场景，而会有较小的精灵代表玩家的宇宙飞船、敌舰、子弹、小行星和能量道具。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit 是一流的。其他游戏引擎中需要多行代码才能完成的任务，在 SpriteKit 中只需一两行代码即可实现，而且使用起来非常有趣！
- en: '![](Image00271.jpg)'
  id: totrans-884
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 还有一个名为 SceneKit 的 3D 游戏引擎，但由于我们要构建的是 2D 游戏，我们将继续使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-887
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **文件** ▸ **新建** ▸ **项目...**。在项目模板对话框中，选择
    **iOS**，选择 **游戏** 模板，然后点击 **下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在“产品名称”字段中命名你的项目为 SchoolhouseSkateboarder。选择 **SpriteKit** 作为游戏技术。由于我们的游戏只会在
    iPhone（和 iPod touch）上运行，选择 **iPhone** 作为设备设置。然后点击 **下一步** 来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何更改的情况下，你可以运行这个项目，你会看到一个黑屏，屏幕上有一个标签显示 *Hello, World!*。每次你在模拟器中点击鼠标，屏幕上会出现一个旋转的框（参见[图
    14-2](text00026.html#ch14fig2)），标签会缩小一秒钟。如果标签显示成侧面的，你可以通过在模拟器菜单中选择 **硬件** ▸ **向左旋转**
    来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用游戏模板创建新项目时，Xcode 都会添加这个简单的交互，以便你确保一切正常运行。
- en: '![](Image00272.jpg)'
  id: totrans-892
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：运行通过游戏模板创建的项目，在进行任何更改之前*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望游戏中有一个巨大的 *Hello, World!* 标签，让我们先去除它。这个标签存在于 *场景编辑器* 中，这是一个用于可视化设计 SpriteKit
    场景的工具，类似于在 UIKit 中使用故事板设计视图。你可以将对象拖入场景编辑器，移动它们，改变它们的大小、颜色和其他属性。这是一个有用的工具，但与在代码中能做到的事情相比，它有很多限制。因此，除了删除
    *Hello, World!* 标签，我们不会在《学校滑板》项目中使用场景编辑器。要打开场景编辑器，点击项目导航器中名为 *GameScene.sks* 的文件。加载后，你应该能看到一个黑色的场景，里面有
    *Hello, World!* 标签。点击标签，然后按 DELETE 键。参见[图 14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-895
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并删除了 *Hello, World!* 标签，我们可以开始正式工作——也就是开始享受乐趣！
- en: '**ADDING IMAGES**'
  id: totrans-898
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图片添加到项目中作为资源。（资源就是你游戏中的元素，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载 ZIP 文件。下载完成后，你会在 *Downloads* 文件夹中看到一个名为 *ch14-images* 的文件夹，里面包含了所有你需要的图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片文件添加到项目中，你需要从 Finder 中将它们拖入 Xcode，并将它们放入资源目录中。（资源目录是 Xcode 项目中的一种特殊文件夹，用于存放和组织项目资源，如图片文件和图标。）这对于图片来说非常有用，因为它将相关的图片文件分组在一起。一旦文件放入资源目录，你可以通过引用它们的文件名在代码中使用它们。我们使用的游戏模板已经自带了一个资源目录，名为
    *Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-902
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *Assets.xcassets*。你应该能看到现有的资源，AppIcon 和太空船图片。你可以删除太空船图片，因为我们不会使用它。点击它，然后按
    DELETE 键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder，导航到图片文件下载的文件夹。按 ⌘ -A 选择所有文件。文件高亮后，将它们拖入 Xcode 的资源目录中，如 [图 14-4](text00026.html#ch14fig4)
    所示。
- en: '![](Image00275.jpg)'
  id: totrans-905
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图片文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到所有的图片文件都是 *.png* 文件。*PNG* 代表 *便携式网络图形*，它是 iOS 应用中最常用的图片文件类型，因为它在保持最佳质量的同时文件大小最小。你可以使用
    *.jpg* 文件，但推荐使用 *.png* 文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-908
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**风景：显示背景图片**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有的图片添加到项目中，接下来我们编写一些代码在应用中显示背景图片。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码会自动添加到项目中。点击项目导航器中的 *GameScene.swift* 文件，你应该能看到一些现有的代码。这些代码有两个目的。首先，它为你提供了如何创建一个形状（旋转的盒子）以及如何执行一个动作（让盒子旋转）的示例。其次，它让你能立即运行新项目并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，我们将删除大部分代码，并添加我们自己的代码。请删除 *GameScene.swift* 中的所有内容，除了 didMove(to:) 函数和
    update(_:) 函数的声明，代码应该像这样：
- en: '*GameScene.swift*'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE32]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑都将在 GameScene 类中处理。可以把场景看作是应用中的一个视图或屏幕。GameScene 类将管理场景中发生的一切——如何显示精灵，玩家如何与游戏互动，以及如何计算得分。复杂的游戏可能会有多个独立的场景——例如标题场景、菜单场景、游戏场景和设置场景。而我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（只执行一次的操作），游戏循环或更新函数（在游戏过程中反复执行的操作），以及用户交互函数（只有在用户点击或滑动时才会执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数 didMove(to:) 会在游戏第一次启动时调用。它非常适合用来编写一些设置场景的代码，例如添加初始精灵或设置玩家的分数和生命值。它类似于你在
    [第 10 章](text00021.html#ch10) 中用来设置 AddBirthdayViewController 中日期选择器的 viewDidLoad()
    方法，而且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向场景中添加背景图片之前，我们需要设置场景的 anchorPoint。将以下代码行添加到 didMove(to:) 方法中（灰色行表示现有代码的占位符）：
- en: '[PRE33]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![](Image00276.jpg)'
  id: totrans-919
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张将放置在你放置图钉的位置，并且如果纸张旋转，它将围绕图钉旋转。这与SpriteKit中锚点属性如何作用于精灵和场景完全一致。游戏模板中的GameScene将锚点设置在场景的中心，但我们希望锚点位于场景的左下角，因此我们将其设置为CGPoint.zero，或(0,
    0)。对于某些游戏，如太空射击游戏，将锚点设置在场景中央会更好。但是对于我们的游戏，地面位于屏幕底部，将锚点移动到左下角会使操作更为便捷。参见[图14-5](text00026.html#ch14fig5)以查看不同锚点的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-921
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：从(0, 0)到(1, 1)的锚点位置示意图*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x坐标为0的位置时，它会位于屏幕的左边缘。当我们将精灵放置在y坐标为0的位置时，它会位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个项目的代码文件，最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式和旋转方式。参见[图14-6](text00026.html#ch14fig6)，查看不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-928
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用其中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，请在didMove(to:)函数中添加以下代码行：
- en: '[PRE34]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析刚刚添加的五行代码。第➊行创建了一个名为background的精灵，使用的是* [background@2x.png](mailto:background@2x.png)
    *文件或* [background@3x.png](mailto:background@3x.png) *文件。这两个文件之前已经添加到资源目录中，Xcode会自动选择正确的文件。你只需在代码中引用它为“background”或“background.png”。要了解Xcode如何选择正确的文件，请参见“[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”在[第213页](text00026.html#page_213)的内容。请注意，变量名不必与图像名匹配——你可以随意为变量命名。然而，图像名必须与项目中资源目录中添加的文件相匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个SKSpriteNode，就像我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋行和第➌行创建了常量 xMid 和 yMid，它们代表屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个描述其在屏幕上位置的
    frame。frame 有 x 坐标、y 坐标、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX 属性给出屏幕 frame
    的中间 x 坐标，midY 给出中间 y 坐标。
- en: '![](Image00279.jpg)'
  id: totrans-935
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：frame 描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用 xMid 和 yMid 创建一个 CGPoint，并将其分配给精灵的位置属性，从而将背景图像的位置设置为屏幕中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 和 y 坐标。在处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个 CGPoint 可以容纳两个值，一个表示*x*，一个表示*y*，这使得它在处理 2D 游戏中的屏幕坐标时非常方便，因为在
    2D 游戏中，所有的元素都通过 x 和 y 坐标来定位。
- en: '**NOTE**'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自* Core Graphics framework*，这是苹果公司用于图形处理的框架。你会在 Swift 中经常看到这种命名方式——类或结构体的前两个或三个字母通常会告诉你这个对象的用途或来源。例如，所有的
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数 addChild(_:) 将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它附属于这个场景。例如，如果场景扩展、缩小或消失，这个子精灵也会跟着变化。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵都是场景或其他精灵的子对象。每当你添加一个精灵时，重要的是要考虑该精灵的父对象应该是什么。例如，滑雪精灵是场景的子对象，但如果我们想要给滑雪精灵加上可替换的帽子，我们会使用一个帽子精灵，它是滑雪精灵的子对象。这样，每当滑雪精灵跳跃时，帽子会跟着一起动，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-942
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个既能在竖屏又能在横屏模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择这一种。由于我们的游戏是一个水平滚动的动作游戏，横屏模式（设备横向放置，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-944
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏与横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，你会注意到它可能会默认进入竖屏模式。让我们更改项目设置，使游戏仅以横屏模式运行。转到项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-947
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-950
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中“竖屏”选项，保留两个横屏方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到项目和目标的列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。这个列表将会出现，图标会变蓝，表示列表区域现在已显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**竖屏**复选框并取消选中。保留横屏方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们离目标更近了，但背景图像还没有完全填充屏幕。我们稍后会看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转它，从模拟器菜单中选择**硬件** ▸ **向右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-955
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-957
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，首先应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理更多的屏幕尺寸，这意味着你需要做额外的工作，确保你创建的艺术资源能够在每个设备上正确显示。与像我们的生日跟踪器这样的基于
    UIKit 的应用相比，游戏在这方面需要更多的工作，因为如果仅仅将艺术资源放大或缩小，游戏画面会显得拉伸。为了避免这个问题，你需要为每个你想支持的设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-959
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 提供了一个图像文件命名系统，帮助你区分哪些图像适用于哪些设备。例如，假设你想在游戏中添加一张滑冰者的图像，而你有一张宽 100 像素、高 100
    像素（100×100）的滑冰者图像文件，你可以将该图像命名为 *skater.png*。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，大小为 200×200 像素，另外还需要一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，大小为 300×300
    像素。这三张文件应该是同一张图像的三种不同大小。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件将自动被使用。在你的代码中，你只需要引用文件名 skater，只要你在项目中正确命名了图像，Xcode 会自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被认为是 1x 图像。你只需要为那些没有
    Retina 显示屏的老旧设备（例如 iPhone 3GS 或第一代 iPad mini）提供 1x 大小的图像。因此，我们所有的图像文件都会有* @2x
    *或* @3x* 后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图像组合在一起。如果你同时将多张图像拖入 Xcode 资源目录，Xcode 会根据它们的命名规则自动识别它们是同一图像的不同大小，并将它们分组在一起。请参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-965
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：多个尺寸的图像在资源目录中被组合在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一点准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像没有填满整个屏幕，如
    [图 14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板在处理游戏场景的大小时的方式。游戏场景的大小将基于我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置进行设置。我们在这个项目中不会使用场景编辑器，因此需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-968
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE35]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并将其显示出来。由于 GameScene 是我们游戏的主要场景，我们希望它始终填充整个屏幕。我们在这里添加的代码决定了显示视图的大小（宽度和高度），并设置了新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目，背景图像现在应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-975
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作 Schoolhouse Skateboarder 游戏并了解了 SpriteKit。你学习了如何在 Xcode 中创建游戏项目并导入资源，如图像。你还了解了如何通过标准文件命名规则支持不同设备的屏幕分辨率，并学习了如何选择在游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来是时候编写一些动作代码了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，让所有元素开始移动，并让玩家点击屏幕使她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-978
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到本书结束时，你会受到启发，设计你自己的游戏。自己制作整个游戏，包括艺术作品和音效，会是一种非常有成就感的体验。你对*你*的游戏的每个方面都拥有完全的控制权。
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 网上也有很多地方可以找到免费游戏艺术供你使用：
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://opengameart.org/](http://opengameart.org/)*** 免费游戏艺术、音效和音乐'
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://freetems.net/](http://freetems.net/)*** 免费游戏艺术和音乐'
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** 免费复古游戏音效制作工具'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-984
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 XCODE 的 SPRITEKIT 制作游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内建的游戏引擎，用于制作二维（2D）游戏。*游戏引擎* 是一套工具，可以让你快速轻松地制作动画、使用音频和音效、创建菜单系统等。程序员使用游戏引擎是为了专注于真正重要的事情——让游戏有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个游戏由许多精灵组成。*精灵* 是游戏中使用的 2D 图像。精灵可以是为游戏提供背景的全屏图像，或者是可以移动并执行操作的小图像。背景精灵设定了舞台。例如，在一款太空射击游戏中，背景精灵可能显示一幅有星星和行星的太空场景，而小精灵则代表玩家的宇宙飞船、敌方飞船、子弹、陨石和能量包。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit 是顶级的。其他游戏引擎中需要许多行代码才能完成的任务，在 SpriteKit 中只需一两行代码就能实现，而且使用起来非常有趣！
- en: '![](Image00271.jpg)'
  id: totrans-988
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 还有一个名为 SceneKit 的 3D 游戏引擎，但由于我们正在制作一个 2D 游戏，所以我们将继续使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-991
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode 并选择**文件** ▸ **新建** ▸ **项目…**。在项目模板对话框中，选择**iOS**，选择**游戏**模板，然后点击**下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中将您的项目命名为 SchoolhouseSkateboarder。选择**SpriteKit**作为游戏技术。由于我们的游戏仅在
    iPhone（和 iPod touch）上运行，请选择**iPhone**作为设备设置。然后点击**下一步**以创建您的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何更改的情况下，您可以运行此项目，您将看到一个黑色屏幕，上面有一个显示 *Hello, World!* 的标签。每次在模拟器中点击鼠标时，屏幕上会出现一个旋转的框（见[图14-2](text00026.html#ch14fig2)），标签会缩小一秒钟。如果标签出现横着的情况，您可以通过从模拟器菜单中选择**硬件**
    ▸ **旋转左**来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 每当使用游戏模板创建新项目时，Xcode 会添加这个简单的交互功能，以便您确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-996
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：在进行任何更改之前运行由游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望游戏中有一个巨大的 *Hello, World!* 标签，首先让我们删除它。这个标签存在于*场景编辑器*中，场景编辑器是一个用于可视化设计
    SpriteKit 场景的工具，类似于 UIKit 视图的 storyboard 设计方式。您可以将对象拖入场景编辑器中，移动它们，改变它们的大小、颜色和其他属性。这个工具非常有用，但与代码中能做的相比，它有许多局限性。因此，除了删除
    *Hello, World!* 标签外，我们在 Schoolhouse Skateboarder 中不会使用场景编辑器。要打开场景编辑器，请点击项目导航器中的名为
    *GameScene.sks* 的文件。加载完成后，您应该看到一个黑色场景，上面有 *Hello, World!* 标签。点击标签，然后按 DELETE 键。见[图14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-999
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并删除了 *Hello, World!* 标签，我们可以开始正式的工作——也就是好玩的工作了！
- en: '**ADDING IMAGES**'
  id: totrans-1002
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要将所有图像添加到项目中作为资源。（资源就是游戏中的一个元素，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载 ZIP 文件。下载完成后，您将在 *Downloads* 文件夹内找到一个名为 *ch14-images* 的文件夹，里面包含所有您需要的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片文件添加到项目中，您需要从 Finder 中将它们拖到 Xcode 中并放入资产目录中。（资产目录是 Xcode 项目中的一种特殊文件夹，用于存储和组织项目资源，如图片文件和图标。）它对图片文件非常有帮助，因为它将相关的图片文件组合在一起。一旦文件被放入资产目录中，您就可以通过引用它们的文件名在代码中的任何位置使用它们。我们使用的游戏模板已经带有一个资产目录，名为*Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-1006
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *Assets.xcassets*。您应该能看到现有的资产，AppIcon 和飞船图片。您可以删除飞船图片，因为我们不会使用它。点击它然后按
    DELETE 删除。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder 并导航到图片文件下载的文件夹。按 ⌘ -A 选择所有文件。选中后，将它们拖入 Xcode 资产目录，如 [图14-4](text00026.html#ch14fig4)
    所示。
- en: '![](Image00275.jpg)'
  id: totrans-1009
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图片文件添加到项目的资产目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到所有图片文件都是 *.png* 文件。*PNG* 代表 *Portable Network Graphics*，它是 iOS 应用中最常用的图片文件类型，因为它提供了最小的文件大小和最佳的图像质量。您可以使用
    *.jpg* 文件，但推荐使用 *.png* 文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-1012
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图片**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经将所有图片添加到项目中，接下来让我们编写一些代码，在应用中显示背景图片。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用游戏模板创建一个新项目时，一些有用的代码会自动添加到您的项目中。点击项目导航器中的 *GameScene.swift* 文件。您应该会看到一些已经写好的代码。这些代码存在有两个原因。首先，它给您展示了如何创建一个形状（旋转的方块）以及如何执行一个动作（让方块旋转）。其次，它允许您立即运行一个新项目，确保一切都已正确设置。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将删除大部分代码，并添加我们自己的代码。请继续删除 *GameScene.swift* 中的所有内容，除了 didMove(to:) 函数和
    update(_:) 函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE36]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑都将在 GameScene 类中实现。可以将场景视为应用中的一个视图或屏幕。GameScene 类将管理场景中的所有内容——如何显示精灵，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能有许多独立的场景——例如，一个标题场景、一个菜单场景、一个游戏场景和一个设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的操作）、游戏循环或更新函数（游戏过程中反复执行的操作），以及用户交互函数（仅在用户点击或滑动时执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏首次启动时，setup函数didMove(to:)会被调用。它非常适合设置场景的代码，比如添加初始精灵或设置玩家的分数和生命值。这类似于你在[第10章](text00021.html#ch10)中用于设置AddBirthdayViewController中的日期选择器的viewDidLoad()方法，并且它只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，必须先设置场景的anchorPoint。将以下代码行添加到didMove(to:)方法中（灰色行表示部分现有代码，用于说明位置）：
- en: '[PRE37]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![](Image00276.jpg)'
  id: totrans-1023
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉把一张纸钉在软木板上时，图钉就是锚点。纸张会被放置在图钉的位置，如果纸张旋转，它就会围绕图钉旋转。这正是anchorPoint属性在SpriteKit中与精灵和场景配合使用的方式。Game模板中的GameScene将锚点设置在场景的中间，但我们希望将锚点设置在场景的左下角，所以我们将其设置为CGPoint.zero，或者(0,
    0)。对于一些游戏，比如太空射击游戏，将锚点放在场景的中间更好。但对于我们的游戏，地面位于屏幕底部，将锚点移到左下角会让操作更加方便。请参见[图14-5](text00026.html#ch14fig5)查看各种锚点的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-1025
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点位置的不同，范围从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x坐标为0的位置时，它将位于屏幕的左边缘。而当我们将精灵放置在y坐标为0的位置时，它将位于屏幕的下边缘。
- en: '**NOTE**'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建每个项目的代码文件，最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置精灵的锚点，改变该精灵的定位方式以及它的旋转方式。请参见[图14-6](text00026.html#ch14fig6)查看通过不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-1032
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常会将其锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，向didMove(to:)函数中添加以下代码行：
- en: '[PRE38]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行讲解刚刚添加的五行代码。第➊行创建了一个名为background的精灵，使用的是*【background@2x.png】(mailto:background@2x.png)*文件或*【background@3x.png】(mailto:background@3x.png)*文件。这两个文件在之前已被添加到资源目录中，Xcode会自动选择正确的文件。你只需在代码中引用它为"background"或"background.png"。要了解Xcode如何选择正确的文件，请参阅“[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”第[213页](text00026.html#page_213)。请注意，变量名不需要与图像名匹配——你可以使用任何你想要的变量名。但图像名必须与项目中资源目录中添加的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个SKSpriteNode，就像我们在这里做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们将表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，用于描述它在屏幕上的位置。框架有x位置、y位置、宽度和高度（参见[图14-7](text00026.html#ch14fig7)）。midX属性给我们提供了屏幕框架的中间x位置，midY属性给我们提供了中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-1039
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过创建一个使用xMid和yMid的CGPoint并将其分配给精灵的position属性，将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，它包含两个CGFloat值，表示x坐标和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以包含两个值，一个表示*x*，一个表示*y*，这使得在2D游戏中处理屏幕坐标非常方便，因为在2D游戏中，所有位置都使用x和y坐标来定位。
- en: '**NOTE**'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '*以CG开头的任何东西* 都来自*Core Graphics框架*，这是Apple用于图形的框架。你会在Swift中经常看到这种命名系统——类或结构体的前两个或三个字母通常会告诉你该对象的用途或它来自哪里。例如，所有SpriteKit的类，如*SKSpriteNode*，都以*SK*开头。'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: ➎行通过调用函数addChild(_:)将背景图片添加到场景中。这个精灵现在是场景的*子对象*，这意味着它附属于这个场景。例如，如果场景变大、缩小或消失，这个子精灵也会发生相应变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为该场景的子对象或另一个精灵的子对象添加。每次添加精灵时，考虑该精灵的父对象非常重要。例如，滑冰精灵是场景的子对象，但如果我们想为滑冰者添加可更换的帽子，我们将使用一个帽子精灵，它是滑冰精灵的子对象。这样，每当滑冰者跳跃时，帽子会保持在滑冰者头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-1046
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，并仅选择那个方向。由于我们的游戏是一个水平滚动的动作游戏，因此横屏方向（设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-1048
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏方向下的样子*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用iPhone 7模拟器，你会注意到它可能默认以竖屏方向运行。让我们更改项目设置，使游戏仅在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-1051
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-1054
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中竖屏选项，保留两个横屏方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。该列表将出现，图标会变为蓝色，表示列表区域现在已显示。确保选中**SchoolhouseSkateboarder**目标。现在找到**Portrait**复选框并取消选中。保留横屏方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们已经接近完成，但背景图片还没有填满整个屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在已经在横屏方向运行，你需要确保模拟器也处于横屏方向。要旋转它，选择模拟器菜单中的**Hardware** ▸ **Rotate Right**，如[图
    14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-1059
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-1061
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解代码之前，我们需要决定支持哪些设备和屏幕分辨率。你支持的设备越多，你需要处理的屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的艺术作品资源在每个设备上都能正确显示。与基于
    UIKit 的应用程序（例如我们的生日追踪器）相比，游戏通常在这方面需要更多的努力，因为如果仅仅通过缩放来调整大小，游戏的艺术作品会显得被拉伸。为了避免这个问题，你需要为每个要支持的设备准备一组不同的图片。
- en: '![](Image00285.jpg)'
  id: totrans-1063
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一种命名图片文件的系统，帮助你识别哪些图片适用于哪些设备。例如，假设你想向游戏中添加一张滑板者的图片，且你的滑板者图片文件宽 100 像素，高
    100 像素（100×100）。你会将该图片命名为 *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图片，大小为 200×200 像素，另一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，大小为 300×300
    像素。这三张文件应为同一张图片的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需要引用文件名 skater，只要你在项目中正确命名了这些图片，Xcode 会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片文件都有一个后缀，比如* @2x *或* @3x*。没有后缀的图片文件，如* skater.png*，被视为 1x 图片。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 尺寸的图片，因为它们没有视网膜显示屏。因此，我们所有的图片文件都会带有* @2x *或* @3x
    *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资产目录，你会注意到 Xcode 将这两张图片组合在一起。如果你同时将不同尺寸的图片拖入 Xcode 资产目录，Xcode
    会自动识别它们是同一张图片的不同尺寸，并将它们组合在一起，因为它们的命名方式。请参见 [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-1069
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：多个尺寸的图片被组合在资产目录中。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行背景图像之前，还需要做最后一点准备。你可能注意到，当使用 iPhone 7 模拟器运行游戏时，背景图像没有填满整个屏幕，如[图 14-13](text00026.html#ch14fig13)所示。这是因为游戏模板在设置游戏场景的大小时的处理方式。游戏场景的大小将基于我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-1072
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE39]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并将其显示出来。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在，背景图像应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1079
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并了解了 SpriteKit。你学习了如何在 Xcode 中创建游戏项目并将资源（如图片）导入项目。你还学习了通过标准的文件命名方法来支持不同设备屏幕分辨率，以及如何选择在游戏中需要的图片类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个带有所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来就是编程一些动作了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-1082
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 网上也有很多地方可以找到免费游戏艺术供你使用：
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://opengameart.org/](http://opengameart.org/)*** 免费游戏艺术、音效和音乐'
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://freetems.net/](http://freetems.net/)*** 免费游戏艺术和音乐'
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** 免费复古游戏音效制作工具'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-1087
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Xcode 的 SpriteKit 制作游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内建的游戏引擎，用于制作二维（2D）游戏。*游戏引擎*是一组工具，可以让你快速轻松地制作动画、使用音频和音效、创建菜单系统等等。程序员使用游戏引擎是为了专注于真正重要的事情——让游戏变得有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个游戏由许多精灵（sprites）组成。一个*精灵*是游戏中使用的二维图像。精灵可以是全屏图像，用于提供游戏的背景，或者是较小的图像，用于移动和执行某些动作。背景精灵设置了游戏的舞台。例如，在一个太空射击游戏中，背景精灵可能会显示星空和行星的太空场景，而会有更小的精灵来表示玩家的飞船、敌人的飞船、子弹、陨石和能量补给。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit是顶尖的。其他游戏引擎中需要多行代码才能完成的任务，在SpriteKit中只需一两行代码就能完成，而且使用起来非常有趣！
- en: '![](Image00271.jpg)'
  id: totrans-1091
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS还拥有一个名为SceneKit的3D游戏引擎，但由于我们正在构建一个2D游戏，我们将继续使用SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-1094
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的SpriteKit项目。打开Xcode并选择**文件** ▸ **新建** ▸ **项目...** 在项目模板对话框中，选择**iOS**，选择**游戏**模板，然后点击**下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中为你的项目命名为SchoolhouseSkateboarder。选择**SpriteKit**作为游戏技术。由于我们的游戏只会在iPhone（和iPod
    touch）上运行，因此选择**iPhone**作为设备设置。然后点击**下一步**以创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 不做任何更改，你可以运行这个项目，你会看到一个黑色的屏幕，显示一个*Hello, World!*标签。每次你在模拟器中点击鼠标的任何位置，屏幕上都会出现一个旋转框（见[图14-2](text00026.html#ch14fig2)），而标签会在一秒钟内缩小。如果标签显示成横向的，你可以通过选择模拟器菜单中的**硬件**
    ▸ **向左旋转**来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建一个新项目时，Xcode都会添加这个简单的交互，以确保一切正常运行。
- en: '![](Image00272.jpg)'
  id: totrans-1099
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：在做任何更改之前运行由游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望在游戏中看到一个巨大的*Hello, World!*标签，首先让我们把它删除掉。这个标签存在于*场景编辑器*中，场景编辑器是一个用于可视化设计SpriteKit场景的工具，类似于使用故事板设计UIKit视图的方式。你可以将物体拖入场景编辑器，移动它们，改变它们的大小、颜色和其他属性。这是一个有用的工具，但与在代码中能够完成的工作相比，它有许多限制。因此，除了删除*Hello,
    World!*标签外，我们不会在《Schoolhouse Skateboarder》中使用场景编辑器。要打开场景编辑器，点击项目导航器中名为*GameScene.sks*的文件。加载完成后，你应该会看到一个黑色的场景，里面有*Hello,
    World!*标签。点击该标签，然后按DELETE键。见[图14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-1102
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除游戏模板中的*Hello, World!*标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并删除了*Hello, World!*标签，我们可以开始正式的工作——也就是有趣的部分！
- en: '**ADDING IMAGES**'
  id: totrans-1105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图像添加为项目的资源。（资源就是你游戏中的某个物品，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你将在*下载*文件夹内得到一个名为*ch14-images*的文件夹，里面包含了你需要的所有图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到你的项目中，你需要将它们从Finder拖入Xcode并放入资产目录。（资产目录是Xcode项目中的一种特殊文件夹，用于存放和组织项目资源，如图像文件和图标。）它对于图像来说非常有用，因为它将相关的图像文件分组在一起。一旦文件进入资产目录，你可以通过引用文件名在代码中随时使用它们。我们使用的游戏模板已经包含了一个名为*Assets.xcassets*的资产目录，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-1109
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*Assets.xcassets*。你应该会看到现有的资源，AppIcon和飞船图像。由于我们不使用飞船图像，你可以删除它。点击它然后按DELETE。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder并导航到下载图像文件的文件夹。按⌘-A选择所有文件。文件高亮后，将它们拖入Xcode的资产目录，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-1112
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图像文件添加到项目的资产目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到所有的图像文件都是*.png*文件。*PNG*代表*可移植网络图形*，它是iOS应用程序中最常用的图像文件类型，因为它以最小的文件大小提供最佳的图像质量。你可以使用*.jpg*文件，但建议使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-1115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，接下来我们编写一些代码来显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建一个新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中名为*GameScene.swift*的文件。你应该会看到那里已经有了一些代码。这个代码有两个目的。首先，它给你一个如何创建形状（旋转的盒子）和如何执行操作（让盒子旋转）的示例。其次，它让你可以立即运行新项目，并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将删除大部分代码并添加我们自己的代码。去掉*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE40]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将位于 `GameScene` 类中。可以将场景看作是应用中的一个视图或屏幕。`GameScene` 类将管理场景中的一切内容——如何显示精灵、玩家如何与游戏互动以及如何进行计分。复杂的游戏可能有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的代码）、游戏循环或更新函数（游戏过程中反复执行的代码）以及用户交互函数（只有当用户点击或滑动时才会执行的代码）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数 `didMove(to:)` 会在游戏首次启动时被调用。它非常适合用于设置场景的代码，比如添加初始精灵、设置玩家的分数和生命值等。它类似于你在[第10章](text00021.html#ch10)中用来设置
    `AddBirthdayViewController` 中日期选择器的 `viewDidLoad()` 方法，并且只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们必须先设置场景的 `anchorPoint`。将这行代码添加到 `didMove(to:)` 方法中（灰色的行表示一些现有代码，仅作位置参考）：
- en: '[PRE41]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![](Image00276.jpg)'
  id: totrans-1126
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵如何在场景中定位。就像你用图钉将一张纸钉在软木板上一样，图钉就是锚点。纸张将会被定位在你放置图钉的位置，并且如果纸张旋转，它会围绕图钉旋转。这正是
    `anchorPoint` 属性在 SpriteKit 中如何与精灵和场景配合使用的方式。游戏模板中的 `GameScene` 将它的锚点设置在场景的中央，但我们希望将锚点放在场景的左下角，因此我们将其设置为
    `CGPoint.zero` 或 (0, 0)。对于一些游戏，比如太空射击游戏，将锚点放在场景中心可能更好。但是对于我们的游戏来说，由于地面位于屏幕底部，将锚点移动到左下角将使得操作更加简便。请参见[图
    14-5](text00026.html#ch14fig5)，其中展示了各种锚点的位置。
- en: '![](Image00277.jpg)'
  id: totrans-1128
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点从(0, 0)到(1, 1)的各种位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 坐标为 0 的位置时，它将位于屏幕的左边缘。当我们将精灵放置在 y 坐标为 0 的位置时，它将位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。有关使用不同锚点旋转精灵的示例，请参见[图14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-1135
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载背景图片，向 didMove(to:) 函数中添加以下几行代码：
- en: '[PRE42]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析刚才添加的五行代码。➊ 处的代码创建了一个名为 background 的精灵，使用 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。两个文件之前已添加到资源目录，Xcode 会自动选择正确的文件。你只需要在代码中引用它们，使用
    "background" 或 "background.png" 即可。要了解 Xcode 如何选择正确的文件，请参见 “[为不同屏幕分辨率调整图片大小](text00026.html#ch14lev1sec7)”
    章节，位于 [第213页](text00026.html#page_213)。请注意，变量名不需要与图片名匹配——你可以随意为变量命名。然而，图片名必须与项目中资源目录中添加的文件名一致。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个 SKSpriteNode，就像我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 和 ➌ 处的代码创建了常量 xMid 和 yMid ，它们表示屏幕的中间位置。frame 是 GameScene 的一个属性 —— 它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，用来描述它在屏幕上的位置。一个框架有
    x 坐标、y 坐标、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX 属性给我们屏幕框架的中间 x 坐标，而 midY
    给我们屏幕框架的中间 y 坐标。
- en: '![](Image00279.jpg)'
  id: totrans-1142
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ 处的代码通过创建一个 CGPoint，使用 xMid 和 yMid，并将其赋值给精灵的 position 属性，从而将背景图像的位置设置为屏幕中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 和 y 坐标。当处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个 CGPoint 可以保存两个值，一个用于 *x* ，另一个用于 *y* ，这使得它在处理 2D 游戏中使用 x 和 y
    坐标定位屏幕元素时非常方便。
- en: '**NOTE**'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自于*Core Graphics框架*，这是苹果公司用于图形的框架。你会在Swift中经常看到这种命名系统——一个类或结构体的前两个或三个字母通常告诉你这个对象的用途或来源。例如，所有的SpriteKit类，比如*SKSpriteNode*，都以*SK*开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，这意味着它被附加到这个场景上。例如，如果场景发生变化（变大、变小或消失），这个子精灵也会发生相应的变化。在SpriteKit游戏中，场景总是父对象，每个精灵都作为场景的子对象或另一个精灵的子对象被添加。每当你添加一个精灵时，考虑它的父对象应该是什么是很重要的。例如，滑板精灵是场景的子对象，但如果我们想为滑板手添加可更换的帽子，我们可以使用一个帽子精灵，它是滑板手精灵的子对象。这样，每当滑板手跳跃时，帽子会保持在滑板手的头上，而我们不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-1149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个在竖屏和横屏模式下都能运行的游戏需要更多工作，因此通常最好决定哪种方向最适合你的游戏，然后选择其中之一。由于我们的游戏是一个横向滚动的动作游戏，横屏方向（设备横放，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-1151
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏方向下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能默认处于竖屏方向。让我们更改项目设置，使游戏只在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如你在[图14-9](text00026.html#ch14fig9)中看到的。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-1154
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-1157
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中竖屏选项，保留两个横屏方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。这个列表会出现，图标会变蓝，表示现在已显示列表区域。确保选中了**SchoolhouseSkateboarder**目标。然后找到**Portrait**复选框，取消选中它。保持横屏方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经接近完成，但背景图片还没有填满整个屏幕。稍后我们会看看如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在处于横屏模式，你需要确保模拟器也处于横屏模式。要旋转它，可以从模拟器菜单中选择 **硬件** ▸ **右旋**，如 [图 14-11](text00026.html#ch14fig11)
    所示。
- en: '![](Image00284.jpg)'
  id: totrans-1162
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-1164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们应该先决定要支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理的屏幕尺寸也越多，这意味着你需要额外的工作来确保你创建的艺术资源在每个设备上都能正确显示。相比像我们的生日追踪器那样的
    UIKit 应用，游戏通常在这方面需要更多的工作，因为如果你只是简单地放大或缩小，游戏的艺术作品会看起来被拉伸变形。为了解决这个问题，你需要为每个要支持的设备准备一套不同的图片资源。
- en: '![](Image00285.jpg)'
  id: totrans-1166
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图片文件的系统，帮助你区分不同设备的图片。例如，假设你想在游戏中添加一张滑冰者的图片，且你有一张宽 100 像素、高 100 像素（100×100）的滑冰者图片文件。你会将这张图片命名为
    *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)* 的图片，尺寸为 200×200
    像素，另外还需要一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为 300×300 像素。这三张文件应该是同一张图片的不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需引用文件名
    skater，只要你在项目中正确命名了图片，Xcode 会自动显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有后缀，比如* @2x *或* @3x*。没有后缀的图片，如* skater.png*，被认为是 1x 图像。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini，具有非 Retina 显示屏的设备）提供 1x 大小的图片。因此，我们所有的图片文件都会有* @2x *或*
    @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图片分组在一起。如果你同时将图片拖入Xcode资源目录，Xcode会自动识别它们是同一张图片的不同尺寸，因为它们的命名方式，并将它们分组在一起。请参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-1172
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图片在资源目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一步准备工作要做。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图片并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将根据包含在我们项目中的*GameScene.sks*场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码来确保我们的场景尺寸正确。
- en: '![](Image00287.jpg)'
  id: totrans-1175
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE43]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，以使它填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行项目。现在背景图片应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，你开始制作《滑板学校》游戏，并学习了SpriteKit。你学会了如何在Xcode中创建游戏项目并将资源（例如图片）导入项目中。你还学习了通过标准的文件命名实践来支持不同设备的屏幕分辨率，并了解如何选择游戏中所需的图片类型。最后，你创建并展示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编程一些动作。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-1185
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://opengameart.org/](http://opengameart.org/)** 免费游戏美术、音效和音乐'
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://freetems.net/](http://freetems.net/)** 免费游戏美术和音乐'
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://www.bfxr.net/](http://www.bfxr.net/)** 免费复古游戏音效创建工具'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-1189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Xcode 的 SpriteKit 制作游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内置的游戏引擎，用于制作二维（2D）游戏。*游戏引擎*是一组工具，可以让你快速且轻松地制作动画，使用音频和音效，创建菜单系统等等。程序员使用游戏引擎，以便专注于真正重要的事情——让游戏更有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个游戏由许多精灵组成。*精灵*是游戏中使用的二维图像。精灵可以是提供游戏背景的全屏图像，也可以是较小的图像，移动并执行某些操作。背景精灵设置了游戏的舞台。例如，在一款太空射击游戏中，背景精灵可能会显示一个包含星星和行星的太空场景，而会有较小的精灵代表玩家的宇宙飞船、敌方飞船、子弹、陨石和能量提升。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit 处于顶尖水平。其他游戏引擎中需要写很多行代码的任务，在 SpriteKit 中只需一两行代码就能完成，而且使用起来非常有趣！
- en: '![](Image00271.jpg)'
  id: totrans-1193
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 还有一个 3D 游戏引擎叫做 SceneKit，但由于我们要制作的是一个 2D 游戏，我们将坚持使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-1196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择**文件** ▸ **新建** ▸ **项目...**。在项目模板对话框中，选择**iOS**，选择**游戏**模板，然后点击**下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在“产品名称”字段中命名你的项目为 SchoolhouseSkateboarder。选择**SpriteKit**作为游戏技术。由于我们的游戏将只在
    iPhone（和 iPod touch）上运行，因此在“设备”设置中选择**iPhone**。然后点击**下一步**以创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何更改的情况下，你可以运行此项目，你会看到一个黑色屏幕，上面有一个标签写着*Hello, World!*。每当你在模拟器中点击鼠标时，屏幕上会出现一个旋转的框（见[图
    14-2](text00026.html#ch14fig2)），标签会缩小一秒钟。如果标签显示横着的，你可以通过在模拟器菜单中选择**硬件** ▸ **左旋**来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你使用游戏模板创建新项目时，Xcode 都会添加这个简单的交互，以确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-1201
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：在未做任何更改之前运行游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想在游戏中看到一个巨大的*Hello, World!*标签，首先我们要将其删除。这个标签存在于*场景编辑器*中，它是一个用于可视化设计SpriteKit场景的工具，类似于在UIKit中使用故事板来设计视图。你可以将对象拖入场景编辑器，移动它们，调整它们的大小、颜色和其他属性。虽然这是一个有用的工具，但与在代码中可以完成的工作相比，它有很多限制。因此，除了删除*Hello,
    World!*标签外，我们在《Schoolhouse Skateboarder》中不会使用场景编辑器。要打开场景编辑器，请点击项目导航器中的名为*GameScene.sks*的文件。一旦加载完成，你应该能看到一个黑色的场景和*Hello,
    World!*标签。点击标签，然后按DELETE。见[图14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-1204
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除游戏模板的*Hello, World!*标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并删除了*Hello, World!*标签，接下来我们就可以开始正事了——也就是开始享受乐趣！
- en: '**ADDING IMAGES**'
  id: totrans-1207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有的图像文件添加为项目的资产。（资产指的是你游戏中的元素，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你将在*Downloads*文件夹中找到一个名为*ch14-images*的文件夹，里面包含所有需要的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到项目中，你需要从Finder中将它们拖放到Xcode中，并放入资产目录中。（资产目录是Xcode项目中的一种特殊类型的文件夹，用于存放和组织项目资源，如图像文件和图标。）它对于图像很有用，因为它将相关的图像文件组合在一起。一旦文件放入资产目录，你可以通过引用它们的文件名在代码中随时使用它们。我们使用的Game模板自带一个资产目录，名为*Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-1211
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资产，如AppIcon和飞船图像。由于我们不会使用飞船图像，可以将其删除。点击它然后按DELETE。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，导航到图像文件下载的文件夹。按⌘ -A全选文件。选中后，将它们拖入Xcode的资产目录，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-1214
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图像文件添加到项目的资产目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有的图像文件都是*.png*格式的。*PNG*代表*便携式网络图形*，它是iOS应用程序中最常用的图像文件类型，因为它在提供最佳质量图像的同时，文件大小最小。你也可以使用*.jpg*格式的文件，但推荐使用*.png*格式的文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-1217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有的图像添加到项目中，让我们写一些代码，在应用程序中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建一个新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中的*GameScene.swift*文件，你应该会看到一些已经存在的代码。这些代码有两个目的。首先，它给你一个如何创建形状（旋转的盒子）和如何执行动作（让盒子旋转）的示例。其次，它让你能够立即运行新项目，并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，我们将删除大部分代码并添加我们自己的代码。去掉*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，代码应该是这样的：
- en: '*GameScene.swift*'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE44]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将会在GameScene类中。可以把场景看作是应用中的一个视图或屏幕。GameScene类将管理场景内发生的所有事情——精灵如何显示，玩家如何与游戏互动，得分如何进行。复杂的游戏可能会有多个独立的场景，例如标题场景、菜单场景、游戏场景和设置场景。而我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性操作），游戏循环或更新函数（游戏过程中反复发生的操作），以及用户交互函数（只有用户点击或滑动时才会发生的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的游戏第一次启动时，setup函数didMove(to:)会被调用。它非常适合用来设置场景的代码，比如添加初始精灵或设置玩家的得分和生命值。它类似于你在[第10章](text00021.html#ch10)中用于设置日期选择器的viewDidLoad()方法，并且它只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们必须设置场景的anchorPoint。将以下代码添加到didMove(to:)方法中（灰色行表示一些现有代码，用于位置设置）：
- en: '[PRE45]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![](Image00276.jpg)'
  id: totrans-1228
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用图钉把一张纸钉到软木板上时，图钉就是锚点。纸张会被定位在你放置图钉的位置，如果纸张旋转，它会围绕图钉旋转。这正是
    SpriteKit 中的 anchorPoint 属性在精灵和场景中的工作方式。游戏模板的 GameScene 将其锚点设置在场景的中间，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero，或者 (0, 0)。对于某些游戏，如太空射击游戏，最好将锚点设置在场景的中间。但对于我们的游戏，其中地面位于屏幕底部，将锚点移到左下角将使得操作更加方便。请参见[图14-5](text00026.html#ch14fig5)了解各种锚点的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-1230
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在 x 坐标为 0 的位置时，它将位于屏幕的左边缘。当我们将精灵放置在 y 坐标为 0 的位置时，它将位于屏幕的下边缘。
- en: '**NOTE**'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步地构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式以及旋转方式。请参见[图14-6](text00026.html#ch14fig6)了解如何通过不同的锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-1237
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图片，向 didMove(to:) 函数中添加以下代码行：
- en: '[PRE46]'
  id: totrans-1241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析我们刚刚添加的五行代码。第➊行创建了一个名为 background 的精灵，使用 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。两个文件之前已经添加到资产目录中，Xcode
    会自动选择正确的文件。你只需要在代码中将其引用为“background”或“background.png”。要了解 Xcode 如何选择正确的文件，请参阅“[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”[第213页](text00026.html#page_213)。注意，变量名不必与图像名匹配——你可以随意为变量命名。然而，图像名必须与在项目的资产目录中添加的文件匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个 SKSpriteNode，如同这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们代表屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述它在屏幕上的位置。frame有一个x位置、一个y位置、一个宽度和一个高度（参见[图14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕frame的中间x位置，midY给出了屏幕frame的中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-1244
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint，并将其赋值给精灵的位置属性，从而将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。在处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以保存两个值，一个表示*x*，另一个表示*y*，这使得在2D游戏中处理屏幕坐标变得非常方便，因为所有内容都使用x和y坐标来定位。
- en: '**NOTE**'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的东西来自* Core Graphics框架*，这是苹果用于图形的框架。你会在Swift中经常看到这种命名系统——类或结构体的前两个或三个字母通常告诉你该对象的用途或它来自哪里。例如，所有SpriteKit的类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用addChild(_:)函数将背景图片添加到场景中。这个精灵现在是场景的*子节点*，意味着它附属于这个场景。例如，如果场景发生变化，增大、缩小或消失，那么这个子节点精灵也会发生相应的变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为场景的子节点或其他精灵的子节点添加。当你添加一个精灵时，考虑它应该归属于哪个父对象是非常重要的。例如，滑冰者精灵是场景的子节点，但如果我们想给滑冰者加上可更换的帽子，我们会使用帽子精灵，帽子精灵会成为滑冰者精灵的子节点。这样，当滑冰者跳跃时，帽子会跟着滑冰者一起移动，而不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-1251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏如何进行：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时在竖屏和横屏模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后选择那一个。由于我们的游戏是一个水平滚动的动作游戏，横屏模式（即设备横放，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-1253
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，你会注意到它可能会默认进入竖屏方向。让我们更改项目设置，使游戏只在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-1256
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-1259
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中“Portrait”选项，保留两个横屏方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上没有看到项目和目标的列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此时列表会出现，并且该图标会变为蓝色，表示列表区域已经显示出来。确保选中了**SchoolhouseSkateboarder**目标。接下来找到**Portrait**复选框并取消选中，保持横屏方向选项选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们已经接近了，但背景图片仍未填满屏幕。稍后我们将看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在以横屏方向运行，你需要确保模拟器也处于横屏方向。要旋转它，请从模拟器菜单中选择**硬件** ▸ **右旋**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-1264
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-1266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，我们需要决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作，确保你创建的艺术资源能在每个设备上正确显示。相比于基于UIKit的应用程序（例如我们的生日追踪器），游戏在这方面通常需要更多的努力，因为如果仅仅放大或缩小，游戏的艺术作品会看起来被拉伸。为了避免这个问题，你需要为每个你想要支持的设备准备一组不同的图片。
- en: '![](Image00285.jpg)'
  id: totrans-1268
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个命名图片文件的系统，帮助你区分不同设备的图片。例如，假设你想要向游戏中添加一张滑板图片，你有一张宽100像素、高100像素（100×100）的滑板图片文件。你会将这张图片命名为*skater.png*。你还需要创建一张命名为*[skater@2x.png](mailto:skater@2x.png)*的图片，大小为200×200像素，再创建一张命名为*[skater@3x.png](mailto:skater@3x.png)*的图片，大小为300×300像素。这三张文件应该是相同的图片，只是尺寸不同。如果游戏运行在iPhone
    4上，带有*@2x*后缀的文件会自动被使用。如果游戏运行在iPhone 6 Plus上，带有*@3x*后缀的文件会自动被使用。在你的代码中，你只需引用文件名skater，确保你在项目中正确命名了图片，Xcode会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Schoolhouse Skateboarder，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750，以及1920×1080。
- en: '**NOTE**'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，比如* @2x *或* @3x*。没有后缀的图片，如*skater.png*，被认为是1x图片。你只需要为旧设备（如iPhone
    3GS或第一代iPad mini）提供1x尺寸的图片，因为这些设备没有视网膜显示屏。因此，我们所有的图片文件都会带有*@2x*或*@3x*后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图片归为一组。如果你同时将图片拖入Xcode资源目录，Xcode会根据文件名自动识别它们是同一张图片的不同尺寸，并将它们分组在一起。见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-1274
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图片在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理背景图片之前，还有最后一步准备工作。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图片没有填满整个屏幕，正如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板在处理游戏场景大小时的方式。游戏场景的大小将根据*GameScene.sks*场景编辑文件中的设置来确定，而该文件已包含在我们的项目中。我们在这个项目中不会使用场景编辑器，因此需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-1277
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE47]'
  id: totrans-1281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并将其显示出来。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了显示视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图片现在应该会填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并了解了 SpriteKit。你学会了如何在 Xcode 中创建一个游戏项目并将资源（如图片）导入项目。你还了解了通过标准文件命名方法支持各种设备屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个带有所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-1287
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://freetems.net/](http://freetems.net/)*** 免费游戏艺术和音乐'
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** 免费复古游戏音效创作工具'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-1290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 XCODE 的 SPRITEKIT 制作游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内置的游戏引擎，用于制作二维（2D）游戏。*游戏引擎* 是一组工具，可以让你快速轻松地制作动画、使用音频和音效、创建菜单系统等等。程序员使用游戏引擎是为了能专注于真正重要的事情——让游戏变得有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一款游戏由许多精灵组成。*精灵* 是游戏中使用的 2D 图像。精灵可以是全屏图像，为游戏提供背景，或者是可以移动并执行操作的小图像。背景精灵设置了舞台。例如，在一款太空射击游戏中，背景精灵可能展示一个带有星星和行星的太空场景，而会有更小的精灵表示玩家的宇宙飞船、敌人飞船、子弹、小行星和能量补给。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏引擎方面，SpriteKit 是顶级的。其他游戏引擎可能需要多行代码来完成的任务，在 SpriteKit 中只需一两行代码就能实现，而且使用起来非常有趣！
- en: '![](Image00271.jpg)'
  id: totrans-1294
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 还有一个名为 SceneKit 的 3D 游戏引擎，但由于我们正在制作一款 2D 游戏，我们将继续使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-1297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **文件** ▸ **新建** ▸ **项目...**。在项目模板对话框中，选择
    **iOS**，选择 **游戏** 模板，然后点击 **下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在“产品名称”字段中将你的项目命名为SchoolhouseSkateboarder。选择**SpriteKit**作为游戏技术。由于我们的游戏将只在iPhone（和iPod
    touch）上运行，选择**iPhone**作为设备设置。然后点击**下一步**来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何更改的情况下，你可以运行这个项目，你会看到一个黑色屏幕和一个写着*Hello, World!*的标签。每次你在模拟器中点击鼠标的任何地方，屏幕上都会出现一个旋转的框（见[图
    14-2](text00026.html#ch14fig2)），而标签会缩小一秒钟。如果标签显示横向，你可以通过选择模拟器菜单中的**硬件** ▸ **向左旋转**来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建一个新项目时，Xcode 会添加这个简单的互动，以确保一切正常运行。
- en: '![](Image00272.jpg)'
  id: totrans-1302
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：在做任何更改之前运行由游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不希望游戏中有一个巨大的*Hello, World!*标签，所以先把它移除。这个标签存在于*场景编辑器*中，场景编辑器是一个用来直观设计SpriteKit场景的工具，类似于用来设计UIKit视图的故事板。你可以将物体拖入场景编辑器，移动它们，改变它们的大小、颜色及其他属性。这个工具很有用，但相较于代码中能做的事情，它有很多局限性。因此，除了移除*Hello,
    World!*标签之外，我们不会在Schoolhouse Skateboarder中使用场景编辑器。要打开场景编辑器，点击项目导航器中的名为*GameScene.sks*的文件。加载完成后，你应该看到一个黑色的场景和*Hello,
    World!*标签。点击标签，然后按DELETE键。参见[图 14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-1305
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：删除游戏模板中的*Hello, World!* *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并移除了*Hello, World!*标签，我们可以开始正式的工作——也就是娱乐的工作！
- en: '**ADDING IMAGES**'
  id: totrans-1308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有的图片作为资源添加到你的项目中。（资源就是游戏中的任何物品，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载ZIP文件。下载完成后，你会在*下载*文件夹中找到一个名为*ch14-images*的文件夹，里面包含了你需要的所有图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片文件添加到项目中，您需要将它们从 Finder 拖到 Xcode 中，并将它们放入资源目录中。（资源目录是 Xcode 项目中的一种特殊文件夹，用于存储和组织项目资源，如图片文件和图标。）它对于图片很有帮助，因为它将相关的图片文件分组在一起。一旦文件被添加到资源目录中，您可以通过引用它们的文件名在代码中的任何位置使用它们。我们使用的游戏模板已经附带了一个资源目录，名为
    *Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-1312
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *Assets.xcassets*。您应该能看到现有的资源，如 AppIcon 和飞船图片。您可以删除飞船图片，因为我们不会使用它。点击它然后按
    DELETE 键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder，导航到下载图片文件的文件夹。按 ⌘ -A 选择所有文件。选中后，将它们拖到 Xcode 资源目录中，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-1315
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图片文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，所有图片文件都是 *.png* 文件。*PNG* 代表 *便携式网络图形*，它是 iOS 应用中使用最广泛的图片文件类型，因为它以最小的文件大小提供最佳的图片质量。您可以使用
    *.jpg* 文件，但推荐使用 *.png* 文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-1318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**景观：显示背景图片**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经将所有图片添加到项目中，让我们编写一些代码来在我们的应用中显示背景图片。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用游戏模板创建一个新项目时，一些有用的代码会自动添加到您的项目中。点击项目导航器中的 *GameScene.swift* 文件。您应该会看到已经存在的代码。这段代码有两个作用。首先，它向您展示了如何创建一个形状（旋转的盒子）以及如何执行一个动作（让盒子旋转）。其次，它允许您立即运行一个新项目并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将删除大部分代码并添加我们自己的代码。请删除 *GameScene.swift* 中的所有内容，除了 didMove(to:) 函数和 update(_:)
    函数的声明，最终代码应如下所示：
- en: '*GameScene.swift*'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE48]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏的大部分逻辑都将在 GameScene 类中。可以将场景看作是应用中的一个视图或屏幕。GameScene 类将管理场景中发生的所有事情——如何显示精灵、玩家如何与游戏互动以及如何进行计分。复杂的游戏可能有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的任务）、游戏循环或更新函数（在游戏过程中反复执行的任务）以及用户交互函数（仅在用户点击或滑动时执行的任务）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数 didMove(to:) 在游戏开始时调用。它非常适合用于设置场景的代码，例如添加初始精灵或设置玩家的分数和生命。它类似于你在[第10章](text00021.html#ch10)中用于设置
    AddBirthdayViewController 中的日期选择器的 viewDidLoad() 方法，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 在将背景图像添加到场景之前，我们需要设置场景的 anchorPoint。在 didMove(to:) 方法中添加这行代码（灰色行表示部分现有代码，用于位置参考）：
- en: '[PRE49]'
  id: totrans-1328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![](Image00276.jpg)'
  id: totrans-1329
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用图钉将一张纸固定在软木板上时，图钉就是锚点。纸张会定位在图钉的位置，如果纸张旋转，它会围绕图钉旋转。这正是
    SpriteKit 中的 anchorPoint 属性在精灵和场景中的工作原理。游戏模板中的 GameScene 场景的锚点位于场景的中间，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero，即 (0, 0)。对于一些游戏，例如太空射击游戏，将锚点放在场景的中间更为合适。但对于我们的游戏，其中地面位于屏幕底部，将锚点移到左下角会更方便。查看[图14-5](text00026.html#ch14fig5)，了解不同锚点的插图。
- en: '![](Image00277.jpg)'
  id: totrans-1331
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：从 (0, 0) 到 (1, 1) 的锚点位置变化*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在 x 坐标为 0 时，它将位于屏幕的左边缘。当我们将一个精灵放置在 y 坐标为 0 时，它将位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步为项目构建每个代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式和旋转方式。查看[图14-6](text00026.html#ch14fig6)，了解使用不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-1338
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要加载背景图像，请在 didMove(to:) 函数中添加以下代码行：
- en: '[PRE50]'
  id: totrans-1342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析我们刚刚添加的五行代码。位于 ➊ 的代码行创建了一个名为 background 的精灵，使用的是* [background@2x.png](mailto:background@2x.png)*
    文件或* [background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已被添加到资源目录，Xcode
    会自动选择正确的文件。你只需在代码中引用它为 "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参见
    “[不同屏幕分辨率下的图像大小调整](text00026.html#ch14lev1sec7)” 以及 [第 213 页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以随意为变量命名。然而，图像名称必须与添加到项目资源目录中的文件相匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个 SKSpriteNode，就像我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 位于 ➋ 和 ➌ 的代码行创建了常量 xMid 和 yMid，这将表示屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，用于描述它在屏幕上的位置。一个框架具有
    x 位置、y 位置、宽度和高度（见 [图 14-7](text00026.html#ch14fig7)）。midX 属性给我们提供了屏幕框架的中间 x 位置，midY
    给我们提供了屏幕框架的中间 y 位置。
- en: '![](Image00279.jpg)'
  id: totrans-1345
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 位于 ➍ 的代码行通过创建一个使用 xMid 和 yMid 的 CGPoint 并将其分配给精灵的 position 属性，将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 CGPoint 是一个结构体，保存两个 CGFloat 值，分别表示 x 和 y 坐标。当你处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个 CGPoint 可以保存两个值，一个用于 *x*，一个用于 *y*，这使得在 2D 游戏中处理屏幕坐标变得方便，因为在这个游戏中，一切都是使用
    x 和 y 位置来定位的。
- en: '**NOTE**'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的都来自* Core Graphics 框架*，这是一个用于图形的 Apple 框架。你会在 Swift 中经常看到这种命名系统——类或结构体的前两个或三个字母通常会告诉你该对象的用途或来源。例如，所有的
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: ➎行代码通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，这意味着它已经附加到场景上。例如，如果场景变大、变小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为该场景的子对象或另一个精灵的子对象被添加。每次添加精灵时，重要的是要考虑这个精灵的父对象应该是什么。例如，滑板精灵是场景的子对象，但如果我们想给滑板精灵加上可互换的帽子，我们会使用帽子精灵，它是滑板精灵的子对象。这样，无论滑板精灵跳跃与否，帽子都会留在滑板精灵身上，而我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-1352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种屏幕方向最适合你的游戏，并选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，因此横屏模式（设备横放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-1354
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏与横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能默认是竖屏模式。让我们更改项目设置，使游戏仅在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-1357
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-1360
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选竖屏选项，保留勾选两个横屏选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此列表将显示，并且图标会变为蓝色，表示列表区域已经显示。确保选中**SchoolhouseSkateboarder**目标。现在找到**竖屏**复选框并取消勾选，保留横屏选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经接近完成，但背景图像还没有填满整个屏幕。稍后我们将看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已在横屏模式下运行，你需要确保模拟器也设置为横屏模式。要旋转模拟器，从模拟器的菜单中选择**硬件** ▸ **右旋**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-1365
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-1367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。相比于基于
    UIKit 的应用（如我们的生日追踪器），游戏在这方面通常需要更多的努力，因为如果你只是简单地缩放图像，它可能会看起来被拉伸。为避免这个问题，你需要为每个你想支持的设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-1369
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 提供了一种图像文件命名系统，帮助你区分哪些图像是为哪些设备准备的。例如，假设你想在游戏中添加一张滑冰者的图像，且你有一张宽度为 100 像素，高度为
    100 像素（100×100）的滑冰者图像文件。你应该将该图像命名为 *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)*
    的 200×200 像素的图像，和另一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的 300×300 像素图像。这三张文件应该是同一张图像的三种不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需引用文件名
    skater，只要你在项目中正确命名了图像，Xcode 就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从 iPhone 4 起的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被视为 1x 图像。你只需要为旧设备（例如
    iPhone 3GS 或第一代 iPad mini）包含 1x 尺寸的图像，这些设备没有 Retina 屏幕。因此，我们所有的图像文件都会有* @2x *或*
    @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资产目录，你会注意到 Xcode 将这两张图像分组在一起。如果你同时将图像拖入 Xcode 资产目录，Xcode 会自动识别它们是同一张图像的不同尺寸，并根据它们的命名将它们分组在一起。参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-1375
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图像会在资产目录中分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一点准备工作。你可能注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图 14-13](text00026.html#ch14fig13)所示。这是因为
    Game 模板处理游戏场景大小的方式。游戏场景的大小将根据项目中包含的 *GameScene.sks* 场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，所以需要添加代码来确保我们的场景大小设置正确。
- en: '![](Image00287.jpg)'
  id: totrans-1378
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码行，设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE51]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了 GameScene 类的一个实例并显示它。由于 GameScene 是我们游戏的主场景，我们希望它始终填充整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，以便它填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图片应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏并了解了 SpriteKit。你学会了如何在 Xcode 中创建一个游戏项目并导入资源，例如图像。你还学会了通过标准的文件命名规范来支持不同设备的屏幕分辨率，以及如何选择在游戏中需要使用的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来该编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-1388
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** 免费的复古游戏音效创建工具'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-1390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 XCODE 的 SPRITEKIT 制作游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内置的游戏引擎，用于制作二维（2D）游戏。*游戏引擎* 是一组工具，可以让你快速轻松地制作动画、使用音频和音效、创建菜单系统等。程序员使用游戏引擎是为了能够专注于真正重要的事情——让游戏变得有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，游戏由许多精灵组成。*精灵* 是游戏中使用的 2D 图像。精灵可以是提供游戏背景的全屏图像，也可以是移动并执行某些动作的小图像。背景精灵设定了场景。例如，在一款太空射击游戏中，背景精灵可能会显示一个包含星星和行星的太空场景，而玩家的飞船、敌人飞船、子弹、小行星和强化道具都会是较小的精灵。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit 是顶级的。其他游戏引擎中需要编写多行代码的任务，在 SpriteKit 中只需一两行代码就能完成，而且使用起来非常有趣！
- en: '![](Image00271.jpg)'
  id: totrans-1394
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 还拥有一个名为 SceneKit 的 3D 游戏引擎，但由于我们正在制作一个 2D 游戏，我们将坚持使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-1397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **文件** ▸ **新建** ▸ **项目...**
    。在项目模板对话框中，选择 **iOS**，选择 **游戏** 模板，然后点击 **下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中将你的项目命名为 SchoolhouseSkateboarder。选择 **SpriteKit** 作为游戏技术。由于我们的游戏只在
    iPhone（和 iPod touch）上运行，选择 **iPhone** 作为设备设置。然后点击 **下一步** 创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不做任何更改的情况下运行这个项目，你会看到一个黑色的屏幕，显示一个写着 *Hello, World!* 的标签。每次你在模拟器中点击鼠标时，屏幕上都会出现一个旋转的方框（见
    [图 14-2](text00026.html#ch14fig2)），而标签会缩小一秒钟。如果标签显示是横着的，你可以通过选择模拟器菜单中的 **硬件**
    ▸ **向左旋转** 来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建一个新项目时，Xcode 会添加这个简单的交互，以便你确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-1402
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：在进行任何更改之前，运行由游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望在游戏中出现一个巨大的 *Hello, World!* 标签，首先让我们移除它。这个标签存在于 *场景编辑器* 中，场景编辑器是一个用于可视化设计
    SpriteKit 场景的工具，类似于 UIKit 用于设计视图的故事板。你可以将对象拖入场景编辑器，移动它们，改变它们的大小、颜色和其他属性。这个工具非常有用，但与代码中能够实现的功能相比，它有很多限制。因此，除了移除
    *Hello, World!* 标签之外，我们不会在《Schoolhouse Skateboarder》中使用场景编辑器。要打开场景编辑器，请在项目导航器中点击名为
    *GameScene.sks* 的文件。加载完成后，你应该能看到一个黑色的场景，并且有一个 *Hello, World!* 标签。点击标签，然后按 DELETE
    键。见 [图 14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-1405
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并移除了*Hello, World!*标签，接下来我们可以开始正事了——也就是乐趣的开始！
- en: '**ADDING IMAGES**'
  id: totrans-1408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图像作为资源添加到你的项目中。（资源就是你游戏中的物体，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你将在*Downloads*文件夹中看到一个名为*ch14-images*的文件夹，里面包含了所有你需要的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到你的项目中，你需要将它们从Finder拖到Xcode中，并将它们放入资源目录。（资源目录是Xcode项目中的一种特殊类型的文件夹，用于存放和组织项目资源，如图像文件和图标。）它对于图像非常有用，因为它将相关的图像文件分组在一起。图像文件进入资源目录后，你可以通过引用它们的文件名，在代码中随时使用它们。我们使用的游戏模板已经包含了一个资源目录，名为*Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-1412
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资源，包括AppIcon和飞船图像。由于我们不会使用飞船图像，你可以删除它。点击它，然后按DELETE键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，导航到下载图像文件的文件夹。按⌘-A选择所有文件。选中后，将它们拖入Xcode的资源目录，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-1415
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图像文件添加到项目的资源目录*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到所有的图像文件都是*.png*文件。*PNG*代表*可移植网络图形*，它是iOS应用中最常用的图像文件类型，因为它在提供最佳质量图像的同时，文件大小也最小。你可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-1418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，让我们编写一些代码，在应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建一个新项目时，一些有用的代码会自动添加到你的项目中。在项目导航器中点击名为*GameScene.swift*的文件。你应该会看到一些已经存在的代码。这个代码有两个目的。首先，它给你展示了如何创建一个形状（旋转的方块）以及如何执行一个动作（让方块旋转）。其次，它让你可以立刻运行新项目，确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个步骤，我们将删除大部分代码并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数的声明和update(_:)函数，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE52]'
  id: totrans-1423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将会在GameScene类中。可以将场景看作是应用中的一个视图或屏幕。GameScene类将管理场景中发生的所有事情——精灵如何显示、玩家如何与游戏互动，以及如何计算得分。复杂的游戏可能会有多个独立的场景——例如一个标题场景、一个菜单场景、一个游戏场景和一个设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的操作）、游戏循环或更新函数（在游戏过程中反复执行的操作），以及用户交互函数（仅在用户点击或滑动时触发的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数didMove(to:)在游戏首次启动时被调用。它非常适合用于设置场景的代码，例如添加初始精灵或设置玩家的分数和生命值的代码。它类似于你在[第10章](text00021.html#ch10)中用于设置AddBirthdayViewController中的日期选择器的viewDidLoad()方法，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图片添加到场景之前，我们需要设置场景的anchorPoint。将这行代码添加到didMove(to:)方法中（灰色的行表示一些现有代码，仅用于位置展示）：
- en: '[PRE53]'
  id: totrans-1428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![](Image00276.jpg)'
  id: totrans-1429
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张将被定位在图钉所在的位置，如果纸张旋转，它将围绕图钉旋转。这正是SpriteKit中锚点属性如何与精灵和场景一起工作的方式。游戏模板中的GameScene将其锚点设置在场景的中间，但我们希望锚点位于场景的左下角，因此我们将其设置为CGPoint.zero，即(0,
    0)。对于一些游戏，例如太空射击游戏，锚点设置在场景的中间可能更好。但对于我们的游戏，地面位于屏幕底部，将锚点移到左下角会使操作更加方便。有关各种锚点位置的示意图，请参见[图14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-1431
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在x位置为0时，它会位于屏幕的左边缘。当我们将一个精灵放置在y位置为0时，它会位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步地构建每个代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式以及旋转方式。有关使用不同锚点旋转精灵的示例，请参见[图 14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-1438
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用精灵的中心点来定位它们。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图片，请将以下代码行添加到 `didMove(to:)` 函数中：
- en: '[PRE54]'
  id: totrans-1442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来逐行解析我们刚刚添加的五行代码。➊ 处的代码创建了一个名为 `background` 的精灵，使用的是 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已添加到资源目录中，Xcode
    会自动选择正确的文件。你只需要在代码中引用它为 "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参见
    “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)” 章节，[第 213 页](text00026.html#page_213)。请注意，变量名不需要与图像名称匹配——你可以使用任何你想要的变量名。然而，图像名称必须与项目中添加到资源目录中的文件名一致。`SKSpriteNode`
    是 SpriteKit 中的精灵类，所以当我们在游戏中创建一个精灵时，我们会创建一个 `SKSpriteNode`，就像我们在这里做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 和 ➌ 处的代码创建了常量 `xMid` 和 `yMid`，它们表示屏幕的中间位置。`frame` 是 `GameScene` 的一个属性，它是一个
    `CGRect`（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它在屏幕上的位置。框架有一个 x 位置、一个 y 位置、一个宽度和一个高度（请参见[图
    14-7](text00026.html#ch14fig7)）。`midX` 属性给出了屏幕框架的中间 x 位置，而 `midY` 给出了屏幕框架的中间 y
    位置。
- en: '![](Image00279.jpg)'
  id: totrans-1445
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码将背景图像的位置设置为屏幕的中间，通过使用 `xMid` 和 `yMid` 创建一个 `CGPoint` 并将其分配给精灵的 `position`
    属性。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGPoint` 是一个结构体，它包含两个 `CGFloat` 值，分别表示 x 和 y 坐标。当你处理屏幕坐标时，通常使用 `CGFloat` 作为数据类型，而不是
    `Float` 或 `Double`。一个 `CGPoint` 可以存储两个值，一个是 *x*，另一个是 *y*，这使得它在处理 2D 游戏中的屏幕坐标时非常方便，因为一切都通过
    x 和 y 坐标来定位。'
- en: '**NOTE**'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何内容都来自于* Core Graphics框架*，这是苹果公司用于图形的框架。你会注意到，在Swift中，许多类或结构的前两个或三个字母通常会告诉你这个对象的用途或它的来源。例如，所有SpriteKit类，如*SKSpriteNode*，都以*SK*开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: ➎处的代码通过调用addChild(_:)函数将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它被附加到这个场景中。例如，如果场景发生变动（如放大、缩小或消失），这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为场景的子对象或其他精灵的子对象被添加。每次添加精灵时，重要的是要考虑这个精灵的父对象应该是什么。例如，滑冰者精灵是场景的子对象，但如果我们想要在滑冰者上添加可更换的帽子，我们可以使用一个帽子精灵，它是滑冰者精灵的子对象。这样，每当滑冰者跳跃时，帽子就会跟着滑冰者一起移动，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-1452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后只选择那个方向。由于我们的游戏是一个水平滚动的动作游戏，横屏模式（设备侧放，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-1454
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，你会注意到它可能默认使用竖屏模式。让我们更改项目设置，让游戏只在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-1457
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-1460
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消勾选竖屏选项，保留勾选横屏选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。该列表会显示出来，图标会变成蓝色，表示列表区域现在正在显示。确保选中了**SchoolhouseSkateboarder**目标。然后找到**竖屏**复选框并取消选中它。保持勾选横屏选项。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们越来越接近了，但背景图像尚未填满整个屏幕。稍后我们将看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已在横屏模式下运行，你需要确保模拟器也处于横屏模式。要旋转它，可以从模拟器的菜单中选择 **硬件** ▸ **右旋**，如 [图 14-11](text00026.html#ch14fig11)
    所示。
- en: '![](Image00284.jpg)'
  id: totrans-1465
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-1467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你就需要处理的屏幕尺寸差异就越大，这意味着你需要额外的工作来确保你创建的艺术资源能在每个设备上正确显示。与像我们的生日追踪器这样的
    UIKit 应用程序相比，游戏在这方面往往需要更多的努力，因为如果你只是简单地缩放图像，它会看起来被拉伸。为了避免这个问题，你必须为每个你想支持的设备准备一套不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-1469
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 为图像文件命名提供了一个系统，帮助你区分哪些图像是为哪些设备准备的。例如，假设你想在游戏中添加一张滑冰者的图片，并且你有一张宽 100 像素、高
    100 像素的滑冰者图像文件（100×100）。你应该将这张图片命名为 *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，大小为 200×200 像素，以及另一张名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，大小为 300×300
    像素。这三张文件应该是同一张图像的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动使用。如果游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件将自动使用。在你的代码中，你只需要引用文件名 skater，只要你在项目中正确命名了这些图像，Xcode 就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，比如* @2x *或* @3x*。没有后缀的图像，比如* skater.png*，被认为是 1x 图像。你只需要为那些没有视网膜显示屏的旧设备提供
    1x 尺寸的图像，比如 iPhone 3GS 或第一代 iPad mini。因此，我们所有的图像文件都会有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件分别命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资产目录，你会注意到Xcode将这两张图像归为一组。如果你同时将图像拖入Xcode资产目录，Xcode会自动识别它们是同一张图像的不同尺寸，并根据它们的命名将它们分组。参见[图
    14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-1475
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资产目录中被归为一组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一步准备工作需要完成。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图 14-13](text00026.html#ch14fig13)所示。这是因为Game模板在处理游戏场景大小时的方式。游戏场景的大小将基于我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。在这个项目中，我们不会使用场景编辑器，因此需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-1478
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行以设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE55]'
  id: totrans-1482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该能够填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了SpriteKit。你学会了如何在Xcode中创建游戏项目并导入资产，如图像到项目中。你还了解了如何通过标准文件命名实践支持不同设备的屏幕分辨率，并且学会了如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个SpriteKit游戏项目，并且准备好了所需的资源，同时解决了屏幕方向和分辨率的问题，接下来该编程实现一些动作了。在[第15章](text00027.html#ch15)中，我们将加入我们的英雄角色和她滑行的地面，让一切开始动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-1488
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  id: totrans-1489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用Xcode的SpriteKit制作游戏**'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内建的游戏引擎，用于制作二维（2D）游戏。*游戏引擎* 是一组工具，可以让你快速轻松地制作动画，使用音频和音效，创建菜单系统等等。程序员使用游戏引擎是为了能够专注于真正重要的事情——让游戏有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一款游戏由许多精灵组成。*精灵* 是游戏中使用的二维图像。精灵可以是提供游戏背景的全屏图像，也可以是移动并执行操作的较小图像。背景精灵设定了舞台。例如，在一款太空射击游戏中，背景精灵可能展示一幅星空和行星的场景，而还有更小的精灵代表玩家的飞船、敌方飞船、子弹、小行星和能量提升。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit 是一流的。在其他游戏引擎中需要多行代码才能完成的任务，在 SpriteKit 中只需一两行代码即可完成，而且使用起来非常有趣！
- en: '![](Image00271.jpg)'
  id: totrans-1493
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 还有一个名为 SceneKit 的 3D 游戏引擎，但由于我们要制作的是 2D 游戏，因此我们将继续使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-1496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **文件** ▸ **新建** ▸ **项目…**。在项目模板对话框中，选择
    **iOS**，选择 **游戏** 模板，然后点击 **下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中为你的项目命名为 SchoolhouseSkateboarder。选择 **SpriteKit** 作为游戏技术。由于我们的游戏仅在
    iPhone（和 iPod touch）上运行，请选择 **iPhone** 作为设备设置。然后点击 **下一步** 来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何更改的情况下，你可以运行这个项目，你将看到一个黑屏，上面有一个写着 *Hello, World!* 的标签。每次你在模拟器中点击鼠标，屏幕上就会出现一个旋转的框（见
    [图14-2](text00026.html#ch14fig2)），标签会缩小一秒钟。如果标签显示为横向，你可以通过选择模拟器菜单中的 **硬件** ▸ **旋转左侧**
    来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建新项目时，Xcode 会添加这个简单的交互，确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-1501
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：在未做任何更改之前运行由游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望游戏中出现一个巨大的*Hello, World!*标签，首先让我们移除它。该标签存在于*场景编辑器*中，这是一个用于可视化设计 SpriteKit
    场景的工具，类似于在 UIKit 中使用的 storyboard 来设计视图。你可以将对象拖入场景编辑器，移动它们，调整它们的大小、颜色及其他属性。虽然这个工具非常有用，但与代码中可以实现的功能相比，它有许多局限性。因此，除了删除*Hello,
    World!*标签外，我们在《Schoolhouse Skateboarder》项目中将不会使用场景编辑器。要打开场景编辑器，点击项目导航器中的*GameScene.sks*文件。加载完成后，你应该能看到一个黑色场景和*Hello,
    World!*标签。点击该标签，然后按 DELETE。参见[图 14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-1504
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：删除游戏模板中的*Hello, World!*标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并移除了*Hello, World!*标签，我们可以开始正事——也就是好玩的事情了！
- en: '**ADDING IMAGES**'
  id: totrans-1507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图片添加到项目中作为资源。（资源就是你游戏中的一些元素，例如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载
    ZIP 文件。下载完成后，你将在*Downloads*文件夹中看到一个名为*ch14-images*的文件夹，里面包含了所有你需要的图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片文件添加到项目中，你需要从 Finder 拖动它们到 Xcode，并将它们放入资源目录中。（资源目录是 Xcode 项目中的一种特殊文件夹，用于存放和组织项目资源，如图片文件和图标。）它对于图片很有帮助，因为它将相关的图片文件放在一起。一旦文件被放入资源目录，你可以通过引用文件名在代码中任何地方使用它们。我们使用的游戏模板已经带有一个资源目录，名为*Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-1511
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资源，如 AppIcon 和飞船图片。由于我们不会使用飞船图片，你可以删除它。点击它，然后按
    DELETE。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder，并导航到下载图片文件的文件夹。按 ⌘ -A 选择所有文件。一旦它们被高亮显示，拖动它们到 Xcode 资源目录中，如[图 14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-1514
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图片文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有图片文件都是*.png*格式的。*PNG*代表*可移植网络图形*，它是 iOS 应用中最常用的图片格式，因为它在提供最佳图像质量的同时，文件大小最小。你也可以使用*.jpg*格式的文件，但推荐使用*.png*格式。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-1517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图片**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图片添加到项目中，接下来我们将编写代码在应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Game模板创建新项目时，一些有用的代码会自动添加到项目中。点击项目导航器中的*GameScene.swift*文件，你应该能看到一些已经存在的代码。这段代码有两个目的。首先，它给你提供了如何创建形状（旋转的盒子）和执行操作（让盒子旋转）的示例。其次，它让你能够立即运行新项目，并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，我们将删除大部分现有代码，并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，最终应该像这样：
- en: '*GameScene.swift*'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE56]'
  id: totrans-1522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将会在GameScene类中。可以将场景视为应用中的一个视图或屏幕。GameScene类将管理场景中的所有内容——如何显示精灵，玩家如何与游戏互动，以及如何进行计分。复杂的游戏可能有多个独立的场景——例如标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性操作），游戏循环或更新函数（在游戏过程中反复执行的操作），以及用户交互函数（只有当用户点击或滑动时才会执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数didMove(to:)在游戏启动时会被调用。它非常适合用于设置场景的代码，比如添加初始精灵，或者设置玩家的得分和生命值。这类似于你在[第10章](text00021.html#ch10)中用于设置AddBirthdayViewController中的日期选择器的viewDidLoad()方法，并且它只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们必须先设置场景的anchorPoint。将这一行代码添加到didMove(to:)方法中（灰色的行表示一些现有代码，供参考）：
- en: '[PRE57]'
  id: totrans-1527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![](Image00276.jpg)'
  id: totrans-1528
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张将定位在图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是SpriteKit中anchorPoint属性如何与精灵和场景一起工作的方式。游戏模板中的GameScene的锚点位于场景的中央，但我们希望将锚点设置在场景的左下角，因此我们将其设置为CGPoint.zero，即(0,
    0)。对于某些游戏，比如太空射击游戏，最好将锚点设置在场景的中央。但对于我们的游戏，由于地面位于屏幕底部，将锚点移至左下角将使操作更容易。请参见[图14-5](text00026.html#ch14fig5)了解各种锚点的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-1530
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：从(0, 0)到(1, 1)的各种锚点位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在x位置为0时，它将位于屏幕的左边缘。当我们将精灵放置在y位置为0时，它将位于屏幕的下边缘。
- en: '**NOTE**'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个项目的代码文件。最终版本可以在* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式和旋转方式。请参见[图14-6](text00026.html#ch14fig6)了解使用不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-1537
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点放在中心。我们不会更改任何精灵的锚点，因此我们总是使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图片，将以下代码行添加到didMove(to:)函数中：
- en: '[PRE58]'
  id: totrans-1541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析刚才添加的五行代码。➊行创建了一个名为background的精灵，使用* [background@2x.png](mailto:background@2x.png)
    *文件或* [background@3x.png](mailto:background@3x.png) *文件。这两个文件之前已经添加到资产目录中，Xcode会自动选择正确的文件。你只需在代码中引用它为“background”或“background.png”。要了解Xcode如何选择正确的文件，请参见“[为不同屏幕分辨率调整图片大小](text00026.html#ch14lev1sec7)”以及[第213页](text00026.html#page_213)。注意，变量名不需要与图像名匹配——你可以随意为变量命名。然而，图像名必须与项目中资产目录中添加的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此，当我们在游戏中创建精灵时，我们将创建一个SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个描述其在屏幕上位置的frame。frame包含x位置、y位置、宽度和高度（参见[图14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕frame的中间x位置，midY给出了屏幕frame的中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-1544
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint并将其赋值给精灵的位置属性，从而将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，它包含两个CGFloat值，表示x和y坐标。在处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个单独的CGPoint可以保存两个值，一个表示*x*坐标，另一个表示*y*坐标，这使得在2D游戏中处理屏幕坐标时非常方便，因为游戏中的一切位置都需要使用x和y坐标。
- en: '**NOTE**'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以*CG*开头的东西都来自*Core Graphics框架*，这是Apple用于图形处理的框架。你会在Swift中经常看到这种命名系统——类或结构体的前两到三个字母通常告诉你这个对象的用途或来源。例如，所有的SpriteKit类，如*SKSpriteNode*，都以*SK*开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它与该场景相连。例如，如果场景发生变化（如扩大、缩小或消失），这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为该场景的子对象或另一个精灵的子对象被添加。每当你添加一个精灵时，重要的是要考虑这个精灵的父对象应该是谁。例如，溜冰者精灵是场景的子对象，但如果我们想为溜冰者添加可更换的帽子，我们会使用一个帽子精灵，它是溜冰者精灵的子对象。这样，当溜冰者跳跃时，帽子会保持在溜冰者头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-1551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏的呈现方式：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个既能在竖屏又能在横屏模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择这一种。由于我们的游戏是一个横向滚动的动作游戏，因此横屏模式（设备横置，如[图14-8](text00026.html#ch14fig8)所示）最为适合。
- en: '![](Image00280.jpg)'
  id: totrans-1553
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏与横屏模式下的显示效果。*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，你会注意到它可能默认以纵向方向运行。让我们更改项目设置，使游戏只在横向模式下运行。转到项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器顶部，旁边有一个蓝色图标，正如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-1556
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-1559
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选纵向选项，保留两个横向方向选项选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此列表将出现，图标将变为蓝色，表示列表区域现在已显示。确保选中**SchoolhouseSkateboarder**目标。现在找到**Portrait（纵向）**复选框并取消勾选。保留横向方向选项选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行游戏，你会发现它以横向方向启动。我们越来越接近目标，但背景图像还没有完全填满屏幕。稍后我们将看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经在横向方向运行，你需要确保模拟器也处于横向模式。要旋转模拟器，请选择**硬件** ▸ **向右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-1564
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏。*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-1566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，就必须处理更多不同的屏幕尺寸，这意味着你需要做额外的工作，确保你创建的艺术资源能在每个设备上正确显示。游戏比像我们这个《生日追踪器》这样的基于
    UIKit 的应用程序需要更多的工作，因为如果你只是简单地放大或缩小图像，游戏的艺术作品会显得拉伸。为了避免这个问题，你必须为每个要支持的设备使用一套不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-1568
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个图像文件命名系统，可以帮助你区分不同设备对应的图像。例如，假设你想在游戏中添加一个滑冰者的图像，且你有一个宽 100 像素、高 100
    像素（100×100）的滑冰者图像文件。你会将这个图像命名为 *skater.png*。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，大小为 200×200 像素，再创建一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，大小为 300×300
    像素。这三个文件应该是同一图像的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件将自动被使用。在你的代码中，你只需引用图像文件名 skater，只要你在项目中正确命名了图像文件，Xcode
    就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》游戏，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被视为 1x 图像。你只需要为具有非视网膜显示屏的旧设备（例如
    iPhone 3GS 或第一代 iPad mini）提供 1x 尺寸的图像。因此，我们所有的图像文件都会有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图像分组在一起。如果你同时将不同尺寸的图像拖入 Xcode 资源目录，Xcode
    会根据它们的命名规则自动识别它们是同一图像的不同尺寸，并将它们分组。请参见 [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-1574
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行背景图像处理之前，我们还有最后一项准备工作要做。你可能注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像没有填满整个屏幕，正如 [图
    14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将根据项目中包含的 *GameScene.sks*
    场景编辑文件中的设置来确定。在这个项目中我们不会使用场景编辑器，所以我们需要添加代码来确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-1577
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE59]'
  id: totrans-1581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示的视图的大小（宽度和高度），并设置了新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 Schoolhouse Skateboarder 游戏，并了解了 SpriteKit。你学会了如何在 Xcode 中创建一个游戏项目，并将资源（例如图片）导入项目中。你还了解了如何通过标准的文件命名惯例来支持不同设备的屏幕分辨率，并学会了如何选择在游戏中需要的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作代码。在[第 15 章](text00027.html#ch15)中，我们将添加我们的主角和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-1587
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 是 iOS 内置的 2D 游戏引擎。*游戏引擎*是一组工具，可以让你快速轻松地制作动画、使用音频和音效、创建菜单系统等等。程序员使用游戏引擎是为了能够专注于真正重要的事情——让游戏更有趣。
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个游戏包含许多精灵。*精灵*是游戏中使用的 2D 图像。精灵可以是提供游戏背景的全屏图像，也可以是移动并执行某些动作的较小图像。背景精灵设置了舞台。例如，在一款太空射击游戏中，背景精灵可能展示带有星星和行星的太空场景，而较小的精灵则是玩家的宇宙飞船、敌方飞船、子弹、小行星和能量包。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit 是一流的。其他游戏引擎中需要编写很多行代码才能完成的任务，在 SpriteKit 中只需一两行代码就能实现，而且使用起来非常有趣！
- en: '![](Image00271.jpg)'
  id: totrans-1591
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 还有一个名为 SceneKit 的 3D 游戏引擎，但由于我们正在制作的是一款 2D 游戏，所以我们将坚持使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-1594
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **文件** ▸ **新建** ▸ **项目…**。在项目模板对话框中，选择
    **iOS**，选择 **游戏** 模板，然后点击 **下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中将项目命名为 SchoolhouseSkateboarder。选择 **SpriteKit** 作为游戏技术。由于我们的游戏只会在
    iPhone（和 iPod touch）上运行，选择 **iPhone** 作为设备设置。然后点击 **下一步** 来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 不做任何更改，你可以运行该项目，屏幕上会显示一个黑色背景，标签上写着 *Hello, World!* 。每次你在模拟器中点击鼠标，屏幕上会出现一个旋转的框（见
    [图14-2](text00026.html#ch14fig2)），标签会缩小一秒钟。如果标签显示为横向，你可以通过从模拟器菜单中选择 **硬件** ▸ **向左旋转**
    来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建新项目时，Xcode 会添加这个简单的交互功能，以确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-1599
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：在进行任何更改之前运行游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望在游戏中看到一个巨大的 *Hello, World!* 标签，首先就将其删除。该标签存在于 *场景编辑器* 中，场景编辑器是一种用于可视化设计
    SpriteKit 场景的工具，类似于使用故事板设计 UIKit 视图的方式。你可以将对象拖入场景编辑器，移动它们，改变它们的大小、颜色及其他属性。虽然这是一个有用的工具，但它与代码中可以实现的功能相比有很多局限性。因此，除了删除
    *Hello, World!* 标签外，我们不会在 Schoolhouse Skateboarder 中使用场景编辑器。要打开场景编辑器，点击项目导航器中的
    *GameScene.sks* 文件。加载后，你应该能看到一个黑色场景，里面有 *Hello, World!* 标签。点击标签，然后按 DELETE 删除。见
    [图14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-1602
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并删除了 *Hello, World!* 标签，接下来就可以开始真正的工作了——也就是好玩的部分！
- en: '**ADDING IMAGES**'
  id: totrans-1605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图像作为资源添加到项目中。（资源就是你游戏中的任何物品，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载 ZIP 文件。下载完成后，你会在 *Downloads* 文件夹中看到一个名为 *ch14-images* 的文件夹，里面包含了所有需要的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到项目中，你需要从 Finder 中将它们拖动到 Xcode 中，并将其放入资源目录中。（资源目录是 Xcode 项目中一种特殊类型的文件夹，用于存放和组织项目资源，如图像文件和图标。）它对图像特别有帮助，因为它将相关的图像文件归类在一起。文件放入资源目录后，你可以在代码中通过引用文件名来使用它们。我们使用的游戏模板已经带有一个名为
    *Assets.xcassets* 的资源目录，这就是我们要使用的目录。
- en: '![](Image00274.jpg)'
  id: totrans-1609
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *Assets.xcassets*。你应该能看到现有的资源，包括 AppIcon 和飞船图像。由于我们不会使用飞船图像，你可以删除它。点击该图像，然后按
    DELETE 删除。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，导航到图像文件下载的文件夹。按⌘ -A选择所有文件。一旦文件被选中，拖动它们到Xcode的资源目录中，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-1612
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图像文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到所有的图像文件都是*.png*文件。*PNG*代表*便携式网络图形*，它是iOS应用程序中最常用的图像文件类型，因为它在保证最佳图像质量的同时，文件大小最小。你也可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-1615
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**景观：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，接下来我们编写代码，在应用程序中显示背景图片。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码已经自动添加到你的项目中。点击项目导航器中的*GameScene.swift*文件，你应该会看到一些已有的代码。这些代码有两个目的。首先，它为你提供了如何创建一个形状（旋转的盒子）以及如何执行一个动作（使盒子旋转）的示例。其次，它让你可以立即运行新项目，并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将删除大部分代码并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，这样它看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE60]'
  id: totrans-1620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑都将在GameScene类中完成。可以将场景看作是应用程序中的一个视图或屏幕。GameScene类将管理场景中的所有内容——如何显示精灵，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能会有许多不同的场景——例如标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的操作）、游戏循环或更新函数（在游戏中反复执行的操作）以及用户交互函数（仅在用户点击或滑动时执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数didMove(to:)在游戏开始时被调用。它非常适合用于设置场景的代码，例如添加初始精灵或设置玩家的分数和生命。这与[第10章](text00021.html#ch10)中你用于设置日期选择器的viewDidLoad()方法类似，且它只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图片添加到场景之前，我们必须设置场景的anchorPoint。将这一行代码添加到didMove(to:)方法中（灰色的代码行表示一些已存在的代码，供放置使用）：
- en: '[PRE61]'
  id: totrans-1625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '![](Image00276.jpg)'
  id: totrans-1626
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置方式。当你用图钉将一张纸固定在软木板上时，图钉就是锚点。纸张将定位在图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是
    SpriteKit 中 anchorPoint 属性在精灵和场景中的作用。游戏模板的 GameScene 场景的锚点在场景的中央，但我们希望锚点位于场景的左下角，因此我们将其设置为
    CGPoint.zero ，即 (0, 0)。对于某些游戏，比如太空射击游戏，将锚点放在场景中央更为合适。但对于我们的游戏来说，地面位于屏幕底部，将锚点移到左下角会使得操作更为方便。请参见[图
    14-5](text00026.html#ch14fig5)了解不同锚点位置的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-1628
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点从 (0, 0) 到 (1, 1) 的各种位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在 x 位置为 0 时，它将位于屏幕的左边缘。当我们将一个精灵放置在 y 位置为 0 时，它将位于屏幕的下边缘。
- en: '**NOTE**'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建项目的每个代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式和旋转方式。请参见[图 14-6](text00026.html#ch14fig6)了解不同锚点位置下精灵旋转的示例。
- en: '![](Image00278.jpg)'
  id: totrans-1635
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，向 didMove(to:) 函数中添加以下代码行：
- en: '[PRE62]'
  id: totrans-1639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解我们刚刚添加的五行代码。➊ 这一行创建了一个名为 background 的精灵，使用 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已经添加到资源目录中，Xcode
    会自动选择合适的文件。你只需在代码中将其引用为 "background" 或 "background.png"。要了解 Xcode 如何选择合适的文件，请参阅“[不同屏幕分辨率的图像尺寸调整](text00026.html#ch14lev1sec7)”第
    213 页。请注意，变量名不必与图像名称匹配—你可以为变量名使用任何你喜欢的名称。然而，图像名称必须与添加到项目资源目录中的文件名匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个 SKSpriteNode，正如我们在这里所做的。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 和 ➌ 这两行创建了常量 xMid 和 yMid，它们表示屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它在屏幕上的位置。一个框架有
    x 位置、y 位置、宽度和高度（见[图 14-7](text00026.html#ch14fig7)）。midX 属性给我们提供了屏幕框架中 x 方向的中间位置，midY
    给我们提供了屏幕框架中 y 方向的中间位置。
- en: '![](Image00279.jpg)'
  id: totrans-1642
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ 这一行通过使用 xMid 和 yMid 创建一个 CGPoint，将背景图像的位置设置为屏幕中央，并将其分配给精灵的位置属性。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，表示 x 和 y 坐标。当你处理屏幕坐标时，通常会使用 CGFloat 数据类型，而不是 Float
    或 Double。一个 CGPoint 可以存储两个值，一个是*x*，一个是*y*，这使得它在 2D 游戏中处理屏幕坐标时非常方便，因为游戏中的每个元素都需要使用
    x 和 y 坐标来定位。
- en: '**NOTE**'
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自* Core Graphics 框架*，这是一个 Apple 用于图形处理的框架。在 Swift 中，你会经常看到这种命名方式——类或结构体的前两个或三个字母通常告诉你这个对象的用途或来源。例如，所有
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 这一行通过调用函数 addChild(_:) 向场景中添加背景图像。这个精灵现在是场景的*子节点*，意味着它与这个场景绑定在一起。例如，如果场景发生缩放、改变或消失，这个子精灵也会受到影响。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵都作为场景的子节点或另一个精灵的子节点添加。当你添加精灵时，考虑它的父节点应该是什么是很重要的。例如，滑冰者精灵是场景的子节点，但如果我们想要为滑冰者添加可更换的帽子，我们会使用帽子精灵，它是滑冰者精灵的子节点。这样，滑冰者跳跃时，帽子会一直留在滑冰者身上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-1649
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后选择其中一种。由于我们的游戏是一个横向滚动的动作游戏，因此横屏（设备横置，如[图
    14-8](text00026.html#ch14fig8)所示）是最合适的选择。
- en: '![](Image00280.jpg)'
  id: totrans-1651
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏与横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能默认处于竖屏模式。让我们更改项目设置，使游戏只在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-1654
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一份项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-1657
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中竖屏选项，同时保留两个横屏方向选项选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在屏幕上看到项目和目标列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此时，列表将会显示出来，图标会变成蓝色，表示列表区域现在可见。确保选择了**SchoolhouseSkateboarder**目标。然后找到**竖屏**复选框并取消选中。保留横屏方向选项选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它在横屏模式下启动。我们越来越接近目标，但背景图像还没有完全填充屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在在横屏模式下运行，你需要确保模拟器也处于横屏模式。要旋转模拟器，可以在模拟器的菜单中选择**硬件** ▸ **向右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-1662
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-1664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们需要决定支持哪些设备和屏幕分辨率。你支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。与基于
    UIKit 的应用（如我们的生日追踪器）相比，游戏在这方面通常需要更多的努力，因为如果只是简单地缩放，游戏艺术图像可能会显得拉伸变形。为避免这个问题，你需要为每个支持的设备准备一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-1666
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图像文件的系统，帮助你区分不同设备使用的图像。例如，假设你想在游戏中加入一个滑冰者的图像，并且你有一个宽 100 像素、高 100
    像素（100×100）的滑冰者图像文件。你会将这个图像命名为 *skater.png* 。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像文件，尺寸为 200×200 像素，另一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像文件，尺寸为 300×300
    像素。这三个文件应该是同一张图像的不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6 Plus
    上运行，则会自动使用带有 *@3x* 后缀的文件。在你的代码中，你只需要引用文件名 skater ，只要你在项目中正确命名了图像，Xcode 就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被视为 1x 图像。你只需要为那些不支持视网膜显示的旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 大小的图像。因此，我们所有的图像文件都会带有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件分别命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*
    。如果你查看 *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两个图像归为一类。如果你同时将尺寸不同的图像拖入 Xcode 资源目录，Xcode
    会自动识别它们是同一张图像的不同尺寸，并将它们归在一起，这主要是因为它们的命名方式。请参见 [图 14-12](text00026.html#ch14fig12)
    。
- en: '![](Image00286.jpg)'
  id: totrans-1672
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：多个尺寸的图像被归类在资源目录中。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从背景图像部分继续之前，还有一件事需要准备好。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，正如在
    [图 14-13](text00026.html#ch14fig13) 中所示。这是因为 Game 模板处理游戏场景尺寸的方式。游戏场景的大小将基于我们项目中包含的
    *GameScene.sks* 场景编辑文件中的设置。由于我们在这个项目中不会使用场景编辑器，所以我们需要添加代码以确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-1675
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE63]'
  id: totrans-1679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主场景，我们希望它始终填充整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，以便它填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作“学校滑板手”游戏，并了解了SpriteKit。你学会了如何在Xcode中创建一个游戏项目并导入资源，如图像。你还学习了如何通过标准的文件命名惯例来支持各种设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并展示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了SpriteKit游戏项目，包含了所需的资源，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切开始运动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-1685
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个游戏由许多精灵组成。*精灵*是游戏中使用的2D图像。精灵可以是充满屏幕的图像，为游戏提供背景，或者是较小的图像，能够移动并执行各种动作。背景精灵为游戏设置舞台。例如，在一个太空射击游戏中，背景精灵可能会显示一个有星星和行星的太空场景，而玩家的飞船、敌人飞船、子弹、小行星和能量补给等则是较小的精灵。
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit是顶级的。其他游戏引擎需要很多行代码才能完成的任务，在SpriteKit中只需要一两行代码就能实现，而且使用起来非常有趣！
- en: '![](Image00271.jpg)'
  id: totrans-1688
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS还有一个名为SceneKit的3D游戏引擎，但由于我们正在制作一个2D游戏，我们将继续使用SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-1691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的SpriteKit项目。打开Xcode并选择**文件** ▸ **新建** ▸ **项目...**。在项目模板对话框中，选择**iOS**，选择**游戏**模板，然后点击**下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在“产品名称”字段中为你的项目命名为SchoolhouseSkateboarder。选择**SpriteKit**作为游戏技术。由于我们的游戏仅在iPhone（和iPod
    touch）上运行，请选择**iPhone**作为设备设置。然后点击**下一步**来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何更改的情况下，你可以运行这个项目，你将看到一个黑色屏幕，上面有一个标签显示*Hello, World!*。每次你在模拟器中点击鼠标时，屏幕上会出现一个旋转的框（见[图14-2](text00026.html#ch14fig2)），标签会缩小一秒钟。如果标签显示的是横向的，你可以通过选择模拟器菜单中的**硬件**
    ▸ **向左旋转**来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建新项目时，Xcode都会添加这种简单的交互，以确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-1696
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：在进行任何更改之前运行由游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望游戏中出现一个巨大的*Hello, World!*标签，让我们先删除它。这个标签存在于*场景编辑器*中，这是一个用于可视化设计SpriteKit场景的工具，类似于用故事板设计UIKit视图的方式。你可以将物体拖入场景编辑器，移动它们，改变它们的大小、颜色和其他属性。这是一个有用的工具，但与代码中能够做到的相比，它有很多局限性。因此，除了删除*Hello,
    World!*标签外，我们不会在《Schoolhouse Skateboarder》中使用场景编辑器。要打开场景编辑器，点击项目导航器中名为*GameScene.sks*的文件。加载后，你应该能看到一个黑色的场景，里面有*Hello,
    World!*标签。点击标签，然后按下DELETE键。见[图14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-1699
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除游戏模板中的*Hello, World!*标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并删除了*Hello, World!*标签，我们可以开始正式工作了——是的，就是开始有趣的工作！
- en: '**ADDING IMAGES**'
  id: totrans-1702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图像添加到你的项目中作为资源。（资源只是游戏中的某个物品，例如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你会在*Downloads*文件夹中找到一个名为*ch14-images*的文件夹，里面包含了所有你需要的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到你的项目中，你需要从Finder中拖动它们到Xcode中，并将它们放入资源目录中。（资源目录是Xcode项目中一种特殊类型的文件夹，用于存放和组织项目资源，如图像文件和图标。）它对于图像非常有用，因为它将相关的图像文件组织在一起。一旦文件放入资源目录，你可以在代码中通过引用它们的文件名来使用它们。我们使用的游戏模板已经包含了一个资源目录，名为*Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-1706
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资源，AppIcon和飞船图像。你可以删除飞船图像，因为我们不再使用它。点击它，然后按下DELETE键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder，导航到图像文件下载的文件夹。按 ⌘ -A 选择所有文件。一旦它们被高亮显示，将它们拖到 Xcode 的资产目录中，如 [图 14-4](text00026.html#ch14fig4)
    所示。
- en: '![](Image00275.jpg)'
  id: totrans-1709
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图像文件添加到项目的资产目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有的图像文件都是 *.png* 文件。*PNG* 代表 *Portable Network Graphics*，它是 iOS 应用程序中最常用的图像文件类型，因为它在保证最佳质量图像的同时，具有最小的文件大小。你可以使用
    *.jpg* 文件，但推荐使用 *.png* 文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-1712
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，让我们写一些代码在应用程序中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建一个新项目时，某些有用的代码会自动添加到你的项目中。点击项目导航器中名为 *GameScene.swift* 的文件，你应该会看到一些已经存在的代码。这些代码有两个目的。首先，它为你提供了如何创建形状（旋转的方块）和如何执行动作（使方块旋转）的示例。其次，它让你可以立即运行新项目，确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个步骤，我们将删除大部分代码并添加我们自己的代码。请删除 *GameScene.swift* 中的所有内容，除了 didMove(to:) 函数和
    update(_:) 函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE64]'
  id: totrans-1717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将位于 GameScene 类中。可以把场景看作是应用程序中的一个视图或屏幕。GameScene 类将管理场景中的所有内容——如何显示精灵，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（执行一次的操作），游戏循环或更新函数（游戏过程中反复执行的操作），以及用户交互函数（仅在用户点击或滑动时执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数 didMove(to:) 会在你的游戏首次启动时被调用。它非常适合用于设置场景的代码，比如添加初始精灵或设置玩家的得分和生命。它类似于你在 [第
    10 章](text00021.html#ch10) 中用来设置 AddBirthdayViewController 中日期选择器的 viewDidLoad()
    方法，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: 在将背景图像添加到场景之前，我们必须设置场景的 anchorPoint。将以下代码添加到 didMove(to:) 方法中（灰色行表示现有代码，仅供放置参考）：
- en: '[PRE65]'
  id: totrans-1722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![](Image00276.jpg)'
  id: totrans-1723
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用图钉把一张纸固定在软木板上时，图钉就是锚点。纸张将会根据你放置图钉的位置来定位，如果纸张旋转，它将围绕图钉旋转。这正是
    SpriteKit 中的锚点属性如何与精灵和场景一起工作的方式。游戏模板的 GameScene 将锚点设置在场景的中央，但我们希望锚点位于场景的左下角，因此我们将其设置为
    CGPoint.zero，或 (0, 0)。对于一些游戏，比如太空射击类游戏，将锚点放置在场景中央会更合适。但对于我们的游戏，地面位于屏幕的底部，将锚点移至左下角会使得操作更加方便。请参阅
    [图 14-5](text00026.html#ch14fig5) 查看不同锚点位置的示例。
- en: '![](Image00277.jpg)'
  id: totrans-1725
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点位置的不同范围，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 位置为 0 时，它将位于屏幕的左边缘。而当我们将精灵放置在 y 位置为 0 时，它将位于屏幕的下边缘。
- en: '**NOTE**'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步地构建每个代码文件，最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变该精灵的位置和旋转方式。请参阅 [图 14-6](text00026.html#ch14fig6) 查看旋转不同锚点的精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-1732
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用其中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图片，请将以下代码行添加到 didMove(to:) 函数中：
- en: '[PRE66]'
  id: totrans-1736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析刚刚添加的五行代码。第 ➊ 行创建了一个名为 background 的精灵，使用 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。两个文件都已添加到资源目录中，Xcode 会自动选择正确的文件。你只需在代码中引用它为
    "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参阅 “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”
    在 [第 213 页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以为变量名选择任何你喜欢的名称。然而，图像名必须与项目中添加到资源目录的文件名匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个 SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们代表屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述它在屏幕上的位置。frame有一个x坐标、一个y坐标、一个宽度和一个高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给我们屏幕frame的中间x坐标，midY给我们屏幕frame的中间y坐标。
- en: '![](Image00279.jpg)'
  id: totrans-1739
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint并将其赋值给精灵的位置属性，从而将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。当你处理屏幕坐标时，通常会使用CGFloat数据类型，而不是Float或Double。一个CGPoint可以保存两个值，一个用于*x*，另一个用于*y*，这使得它在2D游戏中处理屏幕坐标非常方便，因为在2D游戏中，所有的物体都是通过x和y坐标来定位的。
- en: '**NOTE**'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何内容都来自*Core Graphics框架*，这是一个用于图形处理的Apple框架。在Swift中你会经常看到这种命名规则——类或结构体的前两到三个字母通常会告诉你该对象的用途或来源。例如，所有的SpriteKit类，如*SKSpriteNode*，都以*SK*开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用addChild(_:)函数将背景图像添加到场景中。这个精灵现在是场景的*子节点*，这意味着它被附加到这个场景中。例如，如果场景发生变化（扩大、缩小或消失），这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为该场景的子节点或作为另一个精灵的子节点添加。每当你添加一个精灵时，重要的是要考虑该精灵的父节点应该是谁。例如，滑冰精灵是场景的子节点，但如果我们想给滑冰精灵添加可交换的帽子，我们会使用一个帽子精灵，它是滑冰精灵的子节点。这样，每当滑冰精灵跳跃时，帽子就会保持在滑冰精灵头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-1746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个能够同时适应竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（即设备侧着放置，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-1748
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能默认是竖屏模式。让我们更改项目设置，使游戏只在横屏模式下运行。前往项目导航器并点击 **SchoolhouseSkateboarder**
    项目——它位于项目导航器的顶部，旁边有一个蓝色的图标，正如你在[图 14-9](text00026.html#ch14fig9)中看到的那样。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-1751
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-1754
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选竖屏选项，保持横屏模式的两个选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到项目和目标的列表，点击窗口左上角的方形图标，正如你在[图 14-10](text00026.html#ch14fig10)中看到的那样。这个列表将会出现，图标会变蓝，表示该列表区域现在已显示。确保选择了
    **SchoolhouseSkateboarder** 目标。然后找到 **Portrait** 复选框并取消勾选。保持横屏方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它在横屏模式下启动。我们已经越来越接近了，但背景图像还没有填满屏幕。稍后我们将看看如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已在横屏模式下运行，你需要确保模拟器也是横屏模式。要旋转它，从模拟器的菜单中选择 **Hardware** ▸ **Rotate Right**，正如你在[图
    14-11](text00026.html#ch14fig11)中看到的那样。
- en: '![](Image00284.jpg)'
  id: totrans-1759
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-1761
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。与像我们的生日追踪器这样的基于
    UIKit 的应用程序相比，游戏在这方面往往需要更多的努力，因为如果只是简单地缩放图像，它会显得拉伸失真。为了避免这个问题，你需要为每个想要支持的设备使用一套不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-1763
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一套命名图片文件的系统，帮助你区分哪些图片是用于哪些设备。例如，假设你想要将一张滑板手的图片添加到你的游戏中，你有一张滑板手图片文件，宽度为100像素，高度为100像素（100×100）。你将这张图片命名为*skater.png*。你还需要创建一张命名为*[skater@2x.png](mailto:skater@2x.png)*的图片，大小为200×200像素，再创建一张命名为*[skater@3x.png](mailto:skater@3x.png)*的图片，大小为300×300像素。这三张文件应是同一张图片的三种不同尺寸。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件将自动被使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件将自动被使用。在你的代码中，你只需要引用文件名skater，只要你在项目中正确命名了图片，Xcode会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Schoolhouse Skateboarder，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，比如* @2x *或* @3x*。没有后缀的图片，例如*skater.png*，被认为是1x图片。你只需要为较旧的设备（例如iPhone
    3GS或第一代iPad mini）提供1x尺寸的图片，因为它们没有视网膜显示屏。因此，我们所有的图片文件都会有* @2x *或* @3x *的后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资产目录，你会注意到Xcode将这两张图片分组在一起。如果你同时将图片拖入Xcode资产目录，Xcode会根据它们的命名自动识别它们是同一张图片的不同尺寸，并将它们分组在一起。请参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-1769
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图片在资产目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还需要做最后一项准备工作。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图片没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在这个项目中不会使用场景编辑器，因此我们需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-1772
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片未填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行以设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE67]'
  id: totrans-1776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()`方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了所显示视图的大小（宽度和高度），并设置新场景的大小，以使其填满整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1779
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《学校滑板游戏》，并学习了SpriteKit。你了解了如何在Xcode中创建一个游戏项目并导入资源，比如图片。你还学习了通过标准的文件命名方式来支持各种设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作程序。在[第15章](text00027.html#ch15)中，我们将添加我们的主角和她滑行的地面，使一切都能动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-1782
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: 就游戏引擎而言，SpriteKit是一流的。其他游戏引擎需要很多行代码才能完成的任务，在SpriteKit中只需一两行代码就能实现，而且它非常好用！
- en: '![](Image00271.jpg)'
  id: totrans-1784
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS还有一个名为SceneKit的3D游戏引擎，但由于我们正在制作2D游戏，我们将继续使用SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-1787
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的SpriteKit项目。打开Xcode，选择**文件** ▸ **新建** ▸ **项目…**。在项目模板对话框中，选择**iOS**，选择**游戏**模板，然后点击**下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中将你的项目命名为SchoolhouseSkateboarder。选择**SpriteKit**作为游戏技术。由于我们的游戏只会在iPhone（和iPod
    touch）上运行，所以选择**iPhone**作为设备设置。然后点击**下一步**来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何修改的情况下，你可以运行这个项目，你将看到一个黑色屏幕，上面有一个写着*Hello, World!*的标签。每次你在模拟器中点击鼠标的任意位置，一个旋转的盒子会出现在屏幕上（见[图14-2](text00026.html#ch14fig2)），并且标签会缩小一秒钟。如果标签显示横着，你可以通过从模拟器菜单中选择**硬件**
    ▸ **向左旋转**来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用“游戏”模板创建新项目时，Xcode会自动添加这个简单的交互，确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-1792
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：在进行任何更改之前运行由游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想在游戏中看到一个巨大的*Hello, World!*标签，所以先将其删除。该标签位于*场景编辑器*中，场景编辑器是一个用于可视化设计SpriteKit场景的工具，类似于用于设计UIKit视图的故事板。你可以将对象拖入场景编辑器，调整位置、大小、颜色等属性。这个工具很有用，但相比代码，它有很多局限性。因此，除了删除*Hello,
    World!*标签，我们不会在Schoolhouse Skateboarder中使用场景编辑器。要打开场景编辑器，点击项目导航器中的*GameScene.sks*文件。加载后，你应该能看到一个黑色的场景和*Hello,
    World!*标签。点击该标签，然后按DELETE键。参见[图14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-1795
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除游戏模板中的*Hello, World!*标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并移除了*Hello, World!*标签，接下来可以开始正式的工作了——也就是有趣的部分！
- en: '**ADDING IMAGES**'
  id: totrans-1798
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图片作为资源添加到你的项目中。（资源就是游戏中的某个物品，比如精灵图或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你将在*下载*文件夹中看到一个名为*ch14-images*的文件夹，里面包含了所有需要的图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片文件添加到项目中，你需要将它们从Finder中拖入Xcode并放入资源目录中。（资源目录是Xcode项目中的一种特殊文件夹，用来存放和组织项目资源，如图片文件和图标。）它对于图片文件非常有用，因为它将相关的图片文件集中在一起。将文件放入资源目录后，你可以在代码中通过文件名引用它们。我们使用的游戏模板已经有一个名为*Assets.xcassets*的资源目录，这也是我们将要使用的目录。
- en: '![](Image00274.jpg)'
  id: totrans-1802
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*，你应该能看到现有的资源，AppIcon和飞船图像。由于我们不再使用飞船图像，可以删除它。点击它并按DELETE键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，找到下载的图片文件所在的文件夹。按⌘-A选择所有文件。当它们被选中后，将它们拖入Xcode的资源目录，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-1805
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图片文件添加到项目的资源目录*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到所有的图片文件都是*.png*文件。*PNG*代表*可移植网络图形*，它是iOS应用中最常用的图片文件类型，因为它具有最佳质量和最小的文件大小。你也可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-1808
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**背景图像的显示：展示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图片添加到项目中，接下来我们写一些代码来显示我们应用中的背景图片。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Game模板创建一个新项目时，项目中会自动添加一些有用的代码。点击项目导航器中的*GameScene.swift*文件，你应该会看到里面已经有一堆代码。这些代码有两个目的。首先，它为你提供了如何创建一个形状（旋转的方块）和如何执行一个动作（让方块旋转）的示例。其次，它让你可以立即运行一个新项目，并确保所有设置都正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，我们将移除大部分代码并添加我们自己的代码。现在请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，确保文件看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE68]'
  id: totrans-1813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏的大部分逻辑将会在GameScene类中实现。可以将场景看作是你应用中的一个视图或屏幕。GameScene类将管理场景中发生的一切——比如精灵如何显示，玩家如何与游戏互动，以及如何计算得分。复杂的游戏可能会有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有setup函数（一次性操作）、游戏循环或更新函数（游戏过程中不断发生的操作）以及用户交互函数（只有当用户点击或滑动时才会发生的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: setup函数didMove(to:)在游戏首次启动时被调用。它非常适合用于设置场景的代码，比如添加初始精灵或设置玩家的得分和生命数。这与你在[第10章](text00021.html#ch10)中使用的viewDidLoad()方法相似，后者用于在AddBirthdayViewController中设置日期选择器，它只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图片添加到场景之前，我们必须先设置场景的anchorPoint。将这行代码添加到didMove(to:)方法中（灰色的代码行表示已有代码，方便定位）：
- en: '[PRE69]'
  id: totrans-1818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '![](Image00276.jpg)'
  id: totrans-1819
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置方式。当你用图钉将纸张钉在软木板上时，图钉就是锚点。纸张将被放置在图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是锚点属性在SpriteKit中与精灵和场景的工作方式。游戏模板中的GameScene将其锚点设置在场景的中心，但我们希望将锚点设置在场景的左下角，因此我们将其设置为CGPoint.zero，即(0,
    0)。对于某些游戏，例如太空射击游戏，将锚点设置在场景的中心会更好。但对于我们的游戏，其中地面位于屏幕底部，将锚点移动到左下角会使工作更加便捷。查看[图14-5](text00026.html#ch14fig5)，了解不同锚点的位置示意图。
- en: '![](Image00277.jpg)'
  id: totrans-1821
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点位置的不同，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x位置为0时，它将位于屏幕的左边缘。当我们将精灵放置在y位置为0时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步为项目构建每个代码文件。最终版本可从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，从而改变该精灵的位置和旋转方式。查看[图14-6](text00026.html#ch14fig6)，了解通过不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-1828
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，将以下代码行添加到didMove(to:)函数中：
- en: '[PRE70]'
  id: totrans-1832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析刚刚添加的五行代码。第➊行创建了一个名为background的精灵，使用的是* [background@2x.png](mailto:background@2x.png)
    *文件或* [background@3x.png](mailto:background@3x.png) *文件。这两个文件之前已经添加到资源目录中，Xcode会自动选择正确的文件。你只需要在代码中引用它为“background”或“background.png”。要了解Xcode是如何选择正确文件的，查看[“为不同屏幕分辨率调整图像大小”](text00026.html#ch14lev1sec7)一节，见[第213页](text00026.html#page_213)。请注意，变量名不必与图像名相同——你可以为变量名使用任何名称。然而，图像名必须与项目中资源目录里添加的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此，当我们在游戏中创建精灵时，我们将创建一个SKSpriteNode，就像我们在这里做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➋ 和 ➌ 行创建了常量 xMid 和 yMid，表示屏幕的中间位置。`frame` 是 `GameScene` 的一个属性，它是一个 `CGRect`（矩形），表示整个屏幕。每个场景和精灵都有一个描述其在屏幕上位置的
    `frame`。一个框架有 x 坐标、y 坐标、宽度和高度（见 [图 14-7](text00026.html#ch14fig7)）。`midX` 属性给我们屏幕框架的中间
    x 坐标，`midY` 给我们屏幕框架的中间 y 坐标。
- en: '![](Image00279.jpg)'
  id: totrans-1835
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➍ 行通过创建一个 `CGPoint`，使用 xMid 和 yMid 来设置背景图像的位置为屏幕的中央，并将其赋值给精灵的 `position` 属性。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGPoint` 是一个结构体，包含两个 `CGFloat` 值，分别表示 x 和 y 坐标。当你处理屏幕坐标时，通常使用 `CGFloat` 作为数据类型，而不是
    `Float` 或 `Double`。一个 `CGPoint` 可以包含两个值，一个表示 *x* ，一个表示 *y* ，这使得在 2D 游戏中处理屏幕坐标变得方便，因为在这种游戏中，一切都是通过
    x 和 y 坐标来定位的。'
- en: '**NOTE**'
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自* Core Graphics 框架*，这是一个用于图形处理的 Apple 框架。你会在 Swift 中看到很多这种命名方式——类或结构体的前两三个字母通常会告诉你这个对象的用途或来源。例如，所有的
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➎ 行通过调用函数 `addChild(_:)` 将背景图像添加到场景中。这个精灵现在是场景的 *子节点*，意味着它与这个场景是关联的。例如，如果场景发生缩放、移动或消失，这个子节点精灵也会随之变化。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵都作为场景的子对象或者另一个精灵的子对象添加。每次添加精灵时，必须考虑该精灵的父对象应该是什么。例如，滑雪者精灵是场景的子节点，但如果我们想给滑雪者添加可更换的帽子，我们会使用一个帽子精灵，它是滑雪者精灵的子节点。这样，每当滑雪者跳跃时，帽子会一直留在滑雪者头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-1842
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个能同时在纵向和横向模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，横向模式（设备横着放，如
    [图 14-8](text00026.html#ch14fig8) 所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-1844
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在纵向和横向模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，您会注意到它可能会默认为纵向方向。我们来更改项目设置，让游戏仅在横向模式下运行。打开项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色的图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-1847
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，您可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-1850
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消勾选“纵向”选项，同时保留两个“横向”方向选项被勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的屏幕上看不到项目和目标的列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。该列表将出现，并且图标会变蓝，表示当前列表区域已经显示。确保选择了**SchoolhouseSkateboarder**目标。接下来找到**Portrait**复选框并取消勾选，保留横向方向选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，您会看到它以横向方向启动。我们越来越接近目标了，但背景图像仍未完全填充屏幕。我们稍后会看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 既然游戏已经在横向模式下运行，您还需要确保模拟器也处于横向模式。要旋转它，请在模拟器菜单中选择**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-1855
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-1857
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，应该决定支持哪些设备和屏幕分辨率。支持的设备越多，您将需要处理更多不同的屏幕大小，这意味着您需要额外的工作来确保您创建的艺术资源在每个设备上能够正确显示。与基于UIKit的应用程序（如我们的生日追踪器）相比，游戏通常在这一方面需要更多的努力，因为如果只是简单地缩放图像，游戏的艺术效果可能会被拉伸。为了解决这个问题，您必须为每个要支持的设备使用不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-1859
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图像文件的系统，帮助你识别哪些图像是针对哪些设备的。例如，假设你想在游戏中添加一张滑板车手的图像，并且你有一张宽度为 100 像素、高度为
    100 像素（100×100）的滑板车手图像。你会将这张图像命名为 *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，尺寸为 200×200 像素，另一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，尺寸为 300×300
    像素。这三张文件应该是相同图像的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件将自动被使用。在你的代码中，你只需引用文件名 skater，只要你在项目中正确命名了图像，Xcode 就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《滑板学校》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750，和
    1920×1080。
- en: '**NOTE**'
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被视为 1x 图像。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 大小的图像，这些设备没有视网膜显示屏。因此，我们所有的图像文件都会有 *@2x* 或 *@3x*
    后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会发现 Xcode 将这两张图片分组在一起。如果你同时将图像拖入 Xcode 资源目录，Xcode 会根据它们的命名自动识别它们是相同图像的不同尺寸，并将它们分组。请参见[图
    14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-1865
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还需要做最后一部分准备工作。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为 Game 模板处理游戏场景大小的方式。游戏场景的大小将根据包含在我们项目中的
    *GameScene.sks* 场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码来确保我们的场景大小合适。
- en: '![](Image00287.jpg)'
  id: totrans-1868
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE71]'
  id: totrans-1872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并显示出来。由于 GameScene 是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图片现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1875
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 Schoolhouse Skateboarder 游戏，并学习了关于 SpriteKit 的知识。你学会了如何在 Xcode 中创建游戏项目并导入资源，例如图片到项目中。你还了解了如何通过标准的文件命名方法支持各种设备屏幕分辨率，以及如何选择游戏中所需的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来是时候编程一些动作了。在 [第15章](text00027.html#ch15)
    中，我们将添加我们的英雄和她滑行的地面，让一切开始移动，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00271.jpg)'
  id: totrans-1878
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00271.jpg)'
- en: '**NOTE**'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 还拥有一个名为 SceneKit 的 3D 游戏引擎，但由于我们正在构建一个 2D 游戏，因此我们将使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-1881
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **文件** ▸ **新建** ▸ **项目…**。在项目模板对话框中，选择
    **iOS**，选择 **游戏** 模板，然后点击 **下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中将你的项目命名为 SchoolhouseSkateboarder。选择 **SpriteKit** 作为游戏技术。由于我们的游戏将只在
    iPhone（和 iPod touch）上运行，因此选择 **iPhone** 作为设备设置。然后点击 **下一步** 来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: 不改变任何设置，你可以运行这个项目，看到一个黑色的屏幕，屏幕上有一个显示 *Hello, World!* 的标签。每次你在模拟器中点击鼠标的任何位置，屏幕上会出现一个旋转的盒子（见
    [图 14-2](text00026.html#ch14fig2)），标签会缩小一秒钟。如果标签显示侧向，你可以通过在模拟器菜单中选择 **硬件** ▸ **左旋转**
    来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建一个新项目时，Xcode 会添加这个简单的交互功能，确保一切正常运行。
- en: '![](Image00272.jpg)'
  id: totrans-1886
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：在做任何更改之前运行游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不希望游戏中有一个巨大的*Hello, World!*标签，首先我们要移除它。这个标签存在于*场景编辑器*中，这是一个用于视觉设计SpriteKit场景的工具，类似于使用Storyboard设计UIKit视图的方式。你可以将对象拖入场景编辑器，移动它们，改变它们的大小、颜色和其他属性。这个工具很有用，但与代码中能做的相比，它有很多局限性。因此，除了删除*Hello,
    World!*标签外，我们不会在Schoolhouse Skateboarder项目中使用场景编辑器。要打开场景编辑器，点击项目导航器中的*GameScene.sks*文件。加载完成后，你应该看到一个黑色的场景和*Hello,
    World!*标签。点击标签，然后按DELETE。见[图14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-1889
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并移除了*Hello, World!*标签，我们可以开始正事了——也就是，开始享受乐趣！
- en: '**ADDING IMAGES**'
  id: totrans-1892
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图像添加到项目的资源中。（资源就是你游戏中的任何物品，例如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: 从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载ZIP文件。下载完成后，你将在*Downloads*文件夹中找到一个名为*ch14-images*的文件夹，里面包含所有需要的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到项目中，你需要从Finder将它们拖到Xcode并放入资源目录中。（资源目录是Xcode项目中一种特殊类型的文件夹，用于保存和组织项目资源，如图像文件和图标。）它对图像特别有用，因为它将相关的图像文件组合在一起。一旦文件被添加到资源目录中，你可以通过引用它们的文件名在代码中的任何地方使用它们。我们使用的游戏模板已经有一个资源目录，叫做*Assets.xcassets*，这就是我们将使用的目录。
- en: '![](Image00274.jpg)'
  id: totrans-1896
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资源，包括AppIcon和飞船图像。你可以删除飞船图像，因为我们不会使用它。点击它，然后按DELETE。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder并导航到下载图像文件的文件夹。按⌘ -A选择所有文件。选中后，将它们拖到Xcode的资源目录中，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-1899
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图像文件添加到项目的资源目录*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有的图像文件都是*.png*文件。*PNG*代表*可移植网络图形*，它是iOS应用程序中最常用的图像文件类型，因为它提供最佳质量的图像，同时文件大小最小。你也可以使用*.jpg*文件，但建议使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-1902
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，接下来让我们编写一些代码来在应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Game模板创建新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中名为*GameScene.swift*的文件，你应该会看到已经存在的一些代码。这段代码有两个目的。首先，它给你一个如何创建形状（旋转的方块）和如何执行动作（让方块旋转）的示例。其次，它让你能够立即运行一个新项目，并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将删除大部分代码并添加我们自己的代码。继续删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，直到它看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE72]'
  id: totrans-1907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将在GameScene类中。可以将场景看作是应用中的一个视图或屏幕。GameScene类将管理场景内发生的一切——如何显示精灵，玩家如何与游戏互动，以及得分如何进行。复杂的游戏可能有许多独立的场景，例如标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性发生的事情）、游戏循环或更新函数（游戏过程中反复发生的事情）以及用户交互函数（仅在用户点击或滑动时发生的事情）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: setup函数didMove(to:)在游戏首次启动时被调用。它非常适合用于设置场景的代码，例如添加初始精灵或设置玩家的得分和生命值的代码。它类似于你在[第10章](text00021.html#ch10)中用于设置AddBirthdayViewController中的日期选择器的viewDidLoad()方法，并且只调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，必须设置场景的anchorPoint。将以下代码行添加到didMove(to:)方法中（灰色行表示一些现有代码，用于放置位置）：
- en: '[PRE73]'
  id: totrans-1912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '![](Image00276.jpg)'
  id: totrans-1913
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用大头针将一张纸钉在软木板上时，大头针就是锚点。纸张将被定位在你放置大头针的位置，并且如果纸张旋转，它将围绕大头针旋转。这正是锚点属性在
    SpriteKit 中如何与精灵和场景一起工作的方式。游戏模板中的 GameScene 将其锚点设置在场景的中央，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero 或 (0, 0)。对于某些游戏，如太空射击游戏，将锚点设置在场景中央更为合适。但对于我们的游戏来说，因为地面位于屏幕的底部，将锚点移动到左下角会更容易操作。请参阅
    [图 14-5](text00026.html#ch14fig5) 以了解各种锚点的插图。
- en: '![](Image00277.jpg)'
  id: totrans-1915
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点的各种位置，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 位置为 0 时，它将位于屏幕的左边缘。而当我们将精灵放置在 y 位置为 0 时，它将位于屏幕的下边缘。
- en: '**NOTE**'
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步为项目构建每个代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置精灵的锚点，改变精灵的位置和旋转方式。请参阅 [图 14-6](text00026.html#ch14fig6) 以查看不同锚点下旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-1922
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它将如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵的锚点通常位于中心。我们不会更改任何精灵的锚点，所以我们将始终使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，请将以下代码行添加到 didMove(to:) 函数中：
- en: '[PRE74]'
  id: totrans-1926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看刚才添加的五行代码。第 ➊ 行创建了一个名为 background 的精灵，使用 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已经添加到资源目录中，Xcode
    会自动选择正确的文件。你只需要在代码中引用它为 "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参阅
    “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)” 第 213 页 [page 213](text00026.html#page_213)。请注意，变量名不必与图像名称匹配——你可以随意选择变量名。然而，图像名称必须与项目中添加到资源目录中的文件匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，所以当我们在游戏中创建一个精灵时，我们将创建一个 SKSpriteNode，就像这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 和 ➌ 这两行代码创建了常量 xMid 和 yMid，它们将表示屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个
    frame，用来描述它在屏幕上的位置。一个 frame 包含 x 位置、y 位置、宽度和高度（见 [图 14-7](text00026.html#ch14fig7)）。midX
    属性给出了屏幕框架的中间 x 位置，而 midY 给出了中间的 y 位置。
- en: '![](Image00279.jpg)'
  id: totrans-1929
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个 frame 描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ 行代码通过创建一个使用 xMid 和 yMid 的 CGPoint，并将其赋值给精灵的 position 属性，将我们的背景图像的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 和 y 坐标。当你处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个单独的 CGPoint 可以包含两个值，一个是 *x*，一个是 *y*，这使得它在处理 2D 游戏中的屏幕坐标时非常方便，因为所有元素都使用
    x 和 y 坐标来定位。
- en: '**NOTE**'
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自* Core Graphics framework*，这是苹果用于图形的框架。你会在 Swift 中经常看到这种命名系统——一个类或结构的前两个或三个字母通常告诉你该对象的用途或来源。例如，所有
    SpriteKit 类，如* SKSpriteNode*，都以* SK* 开头。'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 行代码通过调用函数 addChild(_:) 将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它附加在这个场景上。例如，如果场景变大、变小或消失，这个子精灵也会随之改变。在
    SpriteKit 游戏中，场景始终是父对象，而每个精灵都是作为该场景的子对象或另一个精灵的子对象添加的。每次添加精灵时，重要的是要考虑这个精灵的父对象应该是谁。例如，滑冰精灵是场景的子对象，但如果我们想在滑冰精灵上添加可互换的帽子，我们会使用帽子精灵，它是滑冰精灵的子对象。这样，每当滑冰精灵跳跃时，帽子就会留在滑冰精灵身上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-1936
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏如何进行：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个既能在竖屏又能在横屏模式下运行的游戏需要更多的工作，因此最好决定哪个方向最适合你的游戏，然后只选择那个方向。由于我们的游戏是一个水平滚动的动作游戏，横屏模式（设备侧放，如
    [图 14-8](text00026.html#ch14fig8) 所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-1938
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏与横屏模式下的显示效果。*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，你会注意到它可能默认以纵屏模式启动。让我们更改项目设置，使游戏仅在横屏模式下运行。前往项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器顶部，旁边有一个蓝色图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-1941
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-1944
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消勾选纵向选项，保留横屏方向的两个选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此列表将出现，图标会变为蓝色，表示列表区域已显示。确保选中了**SchoolhouseSkateboarder**目标。然后找到**纵向**复选框并取消勾选，保留横屏方向选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经接近完成，但背景图像还没有填满屏幕。稍后我们将解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转模拟器，选择模拟器菜单中的**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-1949
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-1951
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理不同的屏幕尺寸，这意味着你需要额外的工作，确保你创建的艺术资源能在每个设备上正确显示。游戏在这方面比像我们的生日跟踪器这样的基于UIKit的应用需要更多的工作，因为如果你只是缩放图像，游戏的艺术效果会显得被拉伸。为了避免这个问题，你需要为每个想要支持的设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-1953
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个命名图像文件的系统，帮助你识别哪些图像适用于哪些设备。例如，假设你想为游戏添加一张滑板车图像，你有一张宽 100 像素、高 100 像素的图像（100×100）。你会将这张图像命名为
    *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)* 的图像，大小为 200×200
    像素，再创建一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，大小为 300×300 像素。这三张文件应该是同一张图像的三种不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件将自动使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件将自动使用。在你的代码中，你只需要引用图像文件名
    skater，只要你正确命名了项目中的图像，Xcode 会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被认为是 1x 图像。你只需要为较旧的设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 大小的图像，因为这些设备没有 Retina 显示屏。因此，我们所有的图像文件都会带有* @2x
    *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 已将这两张图像归类在一起。如果你同时将图像拖放到 Xcode 资源目录中，Xcode
    会自动识别它们是同一图像的不同尺寸，因为它们的命名方式，并将它们分组在一起。见 [图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-1959
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图像被归类到资源目录中。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理背景图像之前，我们还需要做最后一点准备工作。你可能已经注意到，当使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如 [图14-13](text00026.html#ch14fig13)
    所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将基于 *GameScene.sks* 场景编辑器文件中的设置，该文件已包含在我们的项目中。我们在这个项目中不会使用场景编辑器，因此需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-1962
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码行以设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE75]'
  id: totrans-1966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图片现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1969
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 Schoolhouse Skateboarder 游戏并了解了 SpriteKit。你学会了如何在 Xcode 中创建一个游戏项目并将资源（如图像）导入项目。你还了解了通过标准文件命名规则来支持各种设备屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在 [第 15 章](text00027.html#ch15)
    中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-1972
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '**NOTE**'
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: '*iOS 还有一个名为 SceneKit 的 3D 游戏引擎，但由于我们正在构建一个 2D 游戏，我们将坚持使用 SpriteKit。*'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-1975
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **文件** ▸ **新建** ▸ **项目…**。在项目模板对话框中，选择
    **iOS**，选择 **游戏** 模板，然后点击 **下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中为你的项目命名为 SchoolhouseSkateboarder。选择 **SpriteKit** 作为游戏技术。由于我们的游戏将仅在
    iPhone（和 iPod touch）上运行，选择 **iPhone** 作为设备设置。然后点击 **下一步** 来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何修改的情况下，你可以运行这个项目，你会看到一个黑色的屏幕，上面有一个显示 *Hello, World!* 的标签。每当你在模拟器中点击鼠标的任何位置时，屏幕上会出现一个旋转的框（见
    [图 14-2](text00026.html#ch14fig2)），并且标签会缩小一秒钟。如果标签是横向显示的，你可以通过选择模拟器菜单中的 **硬件**
    ▸ **左旋** 来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用 Game 模板创建新项目时，Xcode 会添加这个简单的交互功能，以确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-1980
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：在进行任何更改之前运行由 Game 模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望在游戏中显示一个巨大的*Hello, World!*标签，首先将其删除。该标签存在于*场景编辑器*中，这是一个用于可视化设计SpriteKit场景的工具，类似于用来设计UIKit视图的故事板。你可以将对象拖放到场景编辑器中，移动它们，改变它们的大小、颜色和其他属性。这个工具很有用，但与代码中能做的事情相比，它有许多局限性。因此，除了删除*Hello,
    World!*标签外，我们在*Schoolhouse Skateboarder*项目中不会再使用场景编辑器。要打开场景编辑器，点击项目导航器中的名为*GameScene.sks*的文件。一旦加载完成，你应该会看到一个黑色的场景和*Hello,
    World!*标签。点击该标签，然后按DELETE键。参见[图14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-1983
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除游戏模板中的*Hello, World!*标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并删除了*Hello, World!*标签，我们可以开始正式的工作——也就是有趣的工作了！
- en: '**ADDING IMAGES**'
  id: totrans-1986
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有的图片作为资源添加到你的项目中。（资源就是你游戏中的某个元素，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你会在*Downloads*文件夹内看到一个名为*ch14-images*的文件夹，里面包含了你需要的所有图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片文件添加到你的项目中，你需要从Finder中拖动它们到Xcode并将它们放入资源目录中。（资源目录是Xcode项目中的一种特殊文件夹，用于存储和组织项目资源，如图片文件和图标。）它对图片很有帮助，因为它将相关的图片文件归类在一起。文件被放入资源目录后，你可以通过引用它们的文件名在代码中的任何地方使用它们。我们使用的游戏模板已经包含了一个名为*Assets.xcassets*的资源目录，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-1990
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资源，包括AppIcon和飞船图片。由于我们不再使用飞船图片，可以删除它。点击它，然后按DELETE键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，导航到下载图片文件的文件夹。按⌘ -A选择所有文件。一旦文件被高亮显示，拖动它们到Xcode的资源目录中，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-1993
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图片文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到所有的图片文件都是*.png*文件。*PNG*代表*便携式网络图形*，它是iOS应用中最常用的图片文件类型，因为它具有最小的文件大小和最佳的图像质量。你可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-1996
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图片**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图片添加到项目中，让我们写一些代码来显示应用中的背景图片。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Game模板创建新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中的*GameScene.swift*文件，你应该会看到已经存在的一些代码。这段代码有两个目的。首先，它给了你一个关于如何创建形状（旋转的盒子）以及如何执行动作（让盒子旋转）的示例。其次，它让你可以立即运行一个新项目，并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将删除大部分代码并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE76]'
  id: totrans-2001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将位于GameScene类中。可以把一个场景看作是应用中的一个视图或屏幕。GameScene类将管理场景中的所有内容——如何显示精灵，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能会有多个独立的场景——例如标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性发生的事情）、游戏循环或更新函数（游戏过程中反复发生的事情），以及用户交互函数（只有在用户点击或滑动时才会发生的事情）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
  zh: setup函数didMove(to:)在游戏首次启动时调用。它非常适合用于设置场景的代码，比如添加初始精灵或者设置玩家的分数和生命。它类似于你在[第10章](text00021.html#ch10)中用来设置AddBirthdayViewController中的日期选择器的viewDidLoad()方法，并且只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图片添加到场景之前，我们必须设置场景的anchorPoint。将以下代码行添加到didMove(to:)方法中（灰色行表示一些现有的代码，供参考）：
- en: '[PRE77]'
  id: totrans-2006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![](Image00276.jpg)'
  id: totrans-2007
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉把一张纸钉在软木板上时，图钉就是锚点。纸张将被放置在图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是锚点属性在
    SpriteKit 中与精灵和场景配合使用的方式。游戏模板中的 GameScene 将锚点设置在场景的中间，但我们希望将锚点设置在场景的左下角，所以我们将其设置为
    CGPoint.zero，或者 (0, 0)。对于某些游戏，比如太空射击游戏，将锚点放在场景中央可能更好。但对于我们的游戏，地面位于屏幕底部，将锚点移到左下角会更容易操作。请参见
    [图 14-5](text00026.html#ch14fig5) 了解不同锚点位置的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-2009
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：从 (0, 0) 到 (1, 1) 的锚点位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在 x 轴位置为 0 时，它将位于屏幕的左边缘。当我们将一个精灵放置在 y 轴位置为 0 时，它将位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个项目的代码文件。最终版本可以在* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *找到。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。请参见 [图 14-6](text00026.html#ch14fig6)，了解使用不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-2016
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点放在中心。我们不会更改任何精灵的锚点，所以我们将始终使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，请将以下代码行添加到 didMove(to:) 函数中：
- en: '[PRE78]'
  id: totrans-2020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解释一下我们刚刚添加的五行代码。➊ 这一行创建了一个名为 background 的精灵，使用的是 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。两个文件都已经提前添加到资产目录中，Xcode
    会自动选择正确的文件。你只需要在代码中引用它，名称为“background”或“background.png”。要了解 Xcode 如何选择正确的文件，请参阅
    “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)” 第 213 页的内容。请注意，变量名不必与图像名称匹配——你可以为变量使用任何名称。但是，图像名称必须与项目中资产目录里添加的文件匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建一个精灵时，我们将创建一个 SKSpriteNode，就像我们在这里所做的一样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: ➋和➌处的代码创建了常量xMid和yMid，它们代表屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述了它在屏幕上的位置。frame有一个x坐标、y坐标、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给我们屏幕frame的中间x位置，而midY给我们屏幕frame的中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-2023
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: ➍处的代码通过使用xMid和yMid创建一个CGPoint，并将其赋值给精灵的position属性，从而将背景图像的位置设置到屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。当处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以包含两个值，一个用于*x*，另一个用于*y*，这使得在2D游戏中处理屏幕坐标非常方便，因为所有的元素都是通过x和y坐标来定位的。
- en: '**NOTE**'
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的内容都来自于* Core Graphics框架*，这是苹果公司用于图形的框架。你会在Swift中经常看到这种命名方式——类或结构的前两三个字母通常告诉你该对象的用途或来源。例如，所有SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: ➎处的代码通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它附加在这个场景上。例如，如果场景发生变化——扩展、收缩或消失——这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为场景的子对象或其他精灵的子对象添加。当你添加一个精灵时，思考一下它应该有一个什么样的父对象是非常重要的。例如，滑冰者精灵是场景的子对象，但如果我们想给滑冰者加上可替换的帽子，我们可以使用一个帽子精灵，它是滑冰者精灵的子对象。这样，每当滑冰者跳跃时，帽子会留在滑冰者身上，我们就不必单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-2030
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可以在纵向和横向模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，横向模式（设备侧着放，如[图14-8](text00026.html#ch14fig8)所示）是最合适的。
- en: '![](Image00280.jpg)'
  id: totrans-2032
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在纵向与横向模式下的样子*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，你会注意到它可能默认显示为竖屏方向。让我们修改项目设置，让游戏只在横屏模式下运行。前往项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-2035
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-2038
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中竖屏选项，保持两个横屏方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到屏幕上的项目和目标列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。列表会出现，并且图标会变蓝，表示当前显示了列表区域。确保**SchoolhouseSkateboarder**目标被选中。现在找到**Portrait（竖屏）**复选框并取消选中它。保持横屏方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经越来越接近目标了，但背景图像还没有填满屏幕。稍后我们将解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在已经在横屏模式下运行，你还需要确保模拟器也处于横屏模式。要旋转它，可以从模拟器菜单中选择**硬件** ▸ **向右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-2043
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-2045
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，我们应该先决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理更多的屏幕尺寸，这意味着你需要做额外的工作来确保你创建的艺术资产能够在每个设备上正确显示。与基于
    UIKit 的应用程序（如我们的生日跟踪器）相比，游戏在这方面通常需要更多的工作，因为如果你仅仅放大或缩小，游戏的艺术图像看起来会被拉伸。为避免这个问题，你需要为每个想要支持的设备准备一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-2047
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个命名图像文件的系统，可以帮助你识别每个图像适用于哪些设备。例如，假设你想在游戏中添加一张滑冰者的图片，并且你有一张宽 100 像素、高
    100 像素（100×100）的滑冰者图像文件。你将把这张图像命名为 *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，大小为 200×200 像素，另外还有一张名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，大小为 300×300
    像素。这三张文件应该是同一张图像的三个不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。若游戏在 iPhone 6
    Plus 上运行，则会自动使用带有 *@3x* 后缀的文件。在代码中，你只需引用文件名 skater，只要你在项目中正确命名了这些图像，Xcode 将自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《滑板学校》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四个屏幕分辨率：960×640，1136×640，1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-2051
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有后缀，比如* @2x *或* @3x*。没有后缀的图像，比如* skater.png*，被认为是 1x 图像。你只需要为没有视网膜显示屏的旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 尺寸的图像。因此，我们所有的图像文件将具有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会发现 Xcode 将这两张图像分组在一起。如果你同时将图像拖放到 Xcode 资源目录中，Xcode 会根据图像的命名自动识别它们是同一张图像的不同尺寸，并将它们分组在一起。见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-2053
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像会在资源目录中分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理背景图像之后，我们还有最后一项准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如 [图
    14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将基于项目中包含的 *GameScene.sks*
    场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，因此需要添加代码以确保我们的场景尺寸正确。
- en: '![](Image00287.jpg)'
  id: totrans-2056
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件并找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE79]'
  id: totrans-2060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填充整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2063
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏并学习了SpriteKit。你学习了如何在Xcode中创建一个游戏项目并将资源（如图像）导入到项目中。你还学习了通过标准的文件命名规范来支持不同设备的屏幕分辨率，以及如何选择游戏中所需的图像类型。最后，你创建并展示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了SpriteKit游戏项目，准备好了所需的资源，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并让玩家点击屏幕使她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-2066
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '**CREATING THE GAME PROJECT**'
  id: totrans-2067
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建游戏项目**'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的游戏创建一个新的SpriteKit项目。打开Xcode，选择**文件** ▸ **新建** ▸ **项目...**。在项目模板对话框中，选择**iOS**，选择**游戏**模板，然后点击**下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中将你的项目命名为SchoolhouseSkateboarder。选择**SpriteKit**作为游戏技术。由于我们的游戏将只在iPhone（和iPod
    touch）上运行，选择**iPhone**作为设备设置。然后点击**下一步**来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
  zh: 不做任何更改，你可以运行这个项目，你会看到一个黑色屏幕，上面有一个标签写着*Hello, World!*。每次你在模拟器中点击鼠标，屏幕上都会出现一个旋转的框（见[图14-2](text00026.html#ch14fig2)），标签会缩小一秒钟。如果标签显示侧着，你可以通过从模拟器的菜单中选择**硬件**
    ▸ **向左旋转**来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用游戏模板创建新项目时，Xcode都会添加这种简单的交互功能，以确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-2072
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：运行通过游戏模板创建的项目，尚未进行任何更改*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望在游戏中出现一个巨大的 *Hello, World!* 标签，我们先把它移除。这个标签存在于 *场景编辑器* 中，这是一个用于可视化设计
    SpriteKit 场景的工具，类似于 UIKit 视图的故事板设计方式。你可以将对象拖入场景编辑器，移动它们，调整大小、颜色和其他属性。这个工具很有用，但与代码中能做到的相比，它有许多局限性。因此，除了移除
    *Hello, World!* 标签外，我们不会在 Schoolhouse Skateboarder 中使用场景编辑器。要打开场景编辑器，点击项目导航器中的
    *GameScene.sks* 文件。加载后，你应该能看到一个黑色的场景，里面有 *Hello, World!* 标签。点击标签，然后按 DELETE 键。见
    [图14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-2075
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并移除了 *Hello, World!* 标签，我们可以开始正事了——也就是开始玩得开心了！
- en: '**ADDING IMAGES**'
  id: totrans-2078
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图像添加到项目中作为资源。(资源就是游戏中的任何物品，比如精灵或音效。)
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载 ZIP 文件。下载完成后，你会在 *Downloads* 文件夹内看到一个名为 *ch14-images* 的文件夹，里面包含你需要的所有图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到项目中，你需要将它们从 Finder 拖到 Xcode 并放入资源目录。(资源目录是 Xcode 项目中的一种特殊文件夹，用来存储和组织项目资源，如图像文件和图标。)
    它对于图像非常有用，因为它将相关的图像文件组合在一起。一旦文件进入资源目录，你可以通过引用文件名在代码中随处使用它们。我们使用的游戏模板已经有了一个资源目录，名为
    *Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-2082
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *Assets.xcassets*。你应该能看到现有的资源，包括 AppIcon 和飞船图像。你可以删除飞船图像，因为我们不再使用它。点击它然后按
    DELETE 键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder，找到图像文件下载的文件夹。按 ⌘ -A 全选它们。选中后，将它们拖入 Xcode 资源目录，如 [图14-4](text00026.html#ch14fig4)
    所示。
- en: '![](Image00275.jpg)'
  id: totrans-2085
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图像文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有的图像文件都是 *.png* 文件。*PNG* 代表 *便携式网络图形*，它是 iOS 应用中最常用的图像文件类型，因为它在提供最佳质量图像的同时，文件大小最小。你也可以使用
    *.jpg* 文件，但推荐使用 *.png* 文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-2088
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图片**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，接下来我们写一些代码来在应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码已经自动添加到项目中。点击项目导航器中的*GameScene.swift*文件，你应该能看到里面已有一大段代码。这些代码有两个目的。首先，它为你提供了如何创建一个形状（旋转的方块）以及如何执行一个动作（让方块旋转）的示例。其次，它让你可以立即运行新项目，确保一切都已正确设置。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，我们将删除大部分代码并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，最终代码应该如下所示：
- en: '*GameScene.swift*'
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE80]'
  id: totrans-2093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大多数逻辑都将在GameScene类中完成。可以将一个场景看作是应用中的一个视图或屏幕。GameScene类将管理场景中的一切——如何显示精灵、玩家如何与游戏互动、以及如何计算分数。复杂的游戏可能会有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的操作），游戏循环或更新函数（在游戏过程中反复执行的操作），以及用户交互函数（只有当用户点击或滑动时才会执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: setup函数didMove(to:)会在游戏首次启动时被调用。它适合用于设置场景的代码，比如添加初始精灵或设置玩家的分数和生命值。它类似于你在[第10章](text00021.html#ch10)的AddBirthdayViewController中用来设置日期选择器的viewDidLoad()方法，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们需要设置场景的anchorPoint。将以下代码添加到didMove(to:)方法中（灰色部分是一些现有代码，表示位置）：
- en: '[PRE81]'
  id: totrans-2098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '![](Image00276.jpg)'
  id: totrans-2099
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张将被固定在图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是
    `anchorPoint` 属性在 SpriteKit 中如何与精灵和场景一起工作的方式。游戏模板中的 `GameScene` 的锚点在场景的中心，但我们希望锚点位于场景的左下角，所以我们将其设置为
    `CGPoint.zero` 或 (0, 0)。对于一些游戏，比如太空射击游戏，将锚点放在场景的中心更好。但对于我们的游戏，其中地面位于屏幕底部，将锚点移到左下角会更容易操作。有关不同锚点位置的示意图，请参见
    [图 14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-2101
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点的不同位置，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 位置为 0 时，它将位于屏幕的左边缘。当我们将精灵放置在 y 位置为 0 时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-2106
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。请参见 [图 14-6](text00026.html#ch14fig6) 了解不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-2108
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要加载我们的背景图像，请在 `didMove(to:)` 函数中添加以下几行代码：
- en: '[PRE82]'
  id: totrans-2112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步解析刚刚添加的五行代码。➊ 这一行创建了一个名为 `background` 的精灵，使用的是 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件早已添加到资源目录中，Xcode 会自动选择正确的文件。你只需在代码中引用它为
    "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参见 “[为不同屏幕分辨率调整图片大小](text00026.html#ch14lev1sec7)”
    第 213 页。请注意，变量名不必与图像名称相匹配——你可以为变量名使用任何名称。然而，图像名称必须与添加到项目资源目录中的文件匹配。`SKSpriteNode`
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们会创建一个 `SKSpriteNode`，就像我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量 xMid 和 yMid，它们表示屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它在屏幕上的位置。一个框架有
    x 位置、y 位置、宽度和高度（参见[图14-7](text00026.html#ch14fig7)）。midX 属性给出了屏幕框架的中间 x 位置，而 midY
    给出了中间 y 位置。
- en: '![](Image00279.jpg)'
  id: totrans-2115
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)  '
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个框架描述了精灵的位置和大小。*  '
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
  zh: '第➍行通过创建一个 CGPoint，使用 xMid 和 yMid 来设置背景图像的位置，使其位于屏幕的中间，并将其分配给精灵的位置属性。  '
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
  zh: 'CGPoint 是一个结构体，包含两个 CGFloat 值，表示 x 和 y 坐标。当你处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个 CGPoint 可以包含两个值，一个用于 *x*，另一个用于 *y*，这使得在 2D 游戏中处理屏幕坐标变得方便，因为在这些游戏中，所有东西都是通过
    x 和 y 坐标来定位的。  '
- en: '**NOTE**'
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**  '
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何内容都来自* Core Graphics 框架*，这是一个用于图形处理的苹果框架。你会在 Swift 中经常看到这种命名系统——一个类或结构体的前两到三个字母通常会告诉你该对象的用途或来源。例如，所有
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。  '
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
  zh: '第➎行通过调用 addChild(_:) 函数将背景图像添加到场景中。这个精灵现在是场景的*子节点*，意味着它附加在这个场景上。例如，如果场景发生了变化（如增大、缩小或消失），这个子精灵也会随之变化。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵都是该场景的子节点或其他精灵的子节点。每次添加一个精灵时，重要的是要考虑该精灵的父节点应该是什么。例如，滑冰者精灵是场景的子节点，但如果我们想给滑冰者加上可更换的帽子，我们可以使用一个帽子精灵，它是滑冰者精灵的子节点。这样，无论滑冰者跳跃，帽子都会随滑冰者一起移动，我们就不需要单独移动帽子。  '
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-2122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏如何播放：屏幕方向**  '
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: '创建一个在竖屏和横屏模式下都能运行的游戏需要更多的工作，因此通常最好选择最适合你游戏的方向。由于我们的游戏是一个横向滚动的动作游戏，横屏（设备侧放，如[图14-8](text00026.html#ch14fig8)所示）最为合适。  '
- en: '![](Image00280.jpg)'
  id: totrans-2124
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)  '
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏方向下的表现*  '
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行该项目，使用 iPhone 7 模拟器，你会发现它可能默认是纵向模式。让我们修改项目设置，使得游戏仅在横向模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-2127
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-2130
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中纵向选项，同时保留两个横向方向选项的勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在屏幕上看到项目和目标的列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此列表将显示出来，图标会变成蓝色，表示列表区域现在已显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**纵向**复选框并取消勾选。保留横向方向选项的勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横向模式启动。我们已经接近了，但背景图像还没有填充整个屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已在横向模式下运行，你需要确保你的模拟器也处于横向模式。要旋转它，选择模拟器菜单中的**硬件** ▸ **右旋**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-2135
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-2137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你需要处理的屏幕大小差异也就越大，这意味着你需要额外的工作来确保你创建的艺术资源在每个设备上都能正确显示。与我们基于
    UIKit 的应用程序（如生日追踪器）相比，游戏在这方面往往需要更多的努力，因为如果你只是简单地缩放，游戏的艺术图像会显得拉伸。为了避免这个问题，你必须为每个你想支持的设备使用一套不同的图像资源。
- en: '![](Image00285.jpg)'
  id: totrans-2139
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一套命名图像文件的规则，可以帮助你区分不同设备的图片。例如，假设你想在游戏中加入一个滑板者的图片，并且你有一张宽100像素，高100像素（100×100）的滑板者图片。你会将这张图片命名为*skater.png*。你还需要创建一张命名为*[skater@2x.png](mailto:skater@2x.png)*的200×200像素图片，以及一张命名为*[skater@3x.png](mailto:skater@3x.png)*的300×300像素图片。这三张文件应该是同一张图片的三种不同尺寸。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件将会自动使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件会自动使用。在你的代码中，你只需要引用文件名skater，只要你正确命名了项目中的图片，Xcode将显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Schoolhouse Skateboarder，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-2143
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，例如*@2x*或*@3x*。没有后缀的图片，例如*skater.png*，被视为1x图片。你只需要为那些具有非视网膜显示屏的旧设备（如iPhone
    3GS或第一代iPad mini）提供1x大小的图片。因此，我们所有的图片文件都会有*@2x*或*@3x*后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件分别命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图片归为一组。如果你同时将图片拖入Xcode的资源目录，Xcode会根据图片的命名自动识别它们是同一张图片的不同尺寸，并将它们分组在一起。见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-2145
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图片在资源目录中被归为一组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还有最后一项准备工作要做。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图片没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板处理游戏场景大小的方式。游戏场景的大小将基于我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，所以我们需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-2148
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE83]'
  id: totrans-2152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图片现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 Schoolhouse Skateboarder 游戏，并了解了 SpriteKit。你学会了如何在 Xcode 中创建游戏项目并将资源（例如图片）导入项目中。你还学会了通过标准的文件命名实践支持不同设备的屏幕分辨率，并了解了如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在 [第 15 章](text00027.html#ch15)
    中，我们将添加我们的英雄和她滑行的地面，使一切开始动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-2158
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的游戏创建一个新的 SpriteKit 项目。打开 Xcode，选择 **文件** ▸ **新建** ▸ **项目...**。在项目模板对话框中，选择
    **iOS**，选择 **游戏** 模板，然后点击 **下一步**。
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-2160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在产品名称字段中输入你的项目名称 SchoolhouseSkateboarder。选择 **SpriteKit** 作为游戏技术。由于我们的游戏只会在
    iPhone（和 iPod touch）上运行，因此选择 **iPhone** 作为设备设置。然后点击 **下一步** 来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何更改的情况下，你可以运行这个项目，你会看到一个黑色的屏幕，上面有一个标签写着 *Hello, World!*。每次你在模拟器中点击鼠标的任何地方，屏幕上都会出现一个旋转的框（见
    [图 14-2](text00026.html#ch14fig2)），而标签会缩小一秒钟。如果标签显示为侧着的，你可以通过选择模拟器菜单中的 **硬件**
    ▸ **左旋转** 来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建新项目时，Xcode 会自动添加这个简单的交互功能，确保一切正常运行。
- en: '![](Image00272.jpg)'
  id: totrans-2163
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：运行游戏模板创建的项目，在进行任何更改之前*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望在游戏中看到一个巨大的*Hello, World!*标签，让我们先去掉它。这个标签存在于*场景编辑器*中，场景编辑器是一个用于可视化设计SpriteKit场景的工具，类似于使用故事板来设计UIKit视图。你可以将对象拖入场景编辑器，移动它们，改变它们的大小、颜色和其他属性。这个工具很有用，但与代码中能做的事情相比，它有许多局限性。因此，除了去除*Hello,
    World!*标签外，我们不会在《Schoolhouse Skateboarder》中使用场景编辑器。要打开场景编辑器，点击项目导航器中名为*GameScene.sks*的文件。加载完成后，你应该看到一个黑色的场景，里面有*Hello,
    World!*标签。点击该标签，然后按DELETE。见[图14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-2166
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除游戏模板中的*Hello, World!*标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并去除了*Hello, World!*标签，我们可以开始进入正题——也就是玩得开心！
- en: '**ADDING IMAGES**'
  id: totrans-2169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图片添加到项目中作为资源。（资源就是你游戏中的任何物品，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你将在*Downloads*文件夹中看到一个名为*ch14-images*的文件夹，里面包含了你需要的所有图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片文件添加到项目中，你需要将它们从Finder中拖到Xcode中，并将其放入一个资源目录中。（资源目录是Xcode项目中的一种特殊文件夹，用于保存和组织项目资源，如图片文件和图标。）它对于图片非常有帮助，因为它将相关的图片文件组合在一起。一旦文件放入资源目录，你就可以通过引用它们的文件名在代码中随时使用它们。我们使用的游戏模板已经包含了一个资源目录，名为*Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-2173
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*Assets.xcassets*。你应该会看到现有的资源，包括AppIcon和宇宙飞船图像。你可以删除宇宙飞船图像，因为我们不会使用它。点击它然后按DELETE。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，进入图片文件下载的文件夹。按⌘ -A全选它们。一旦它们被高亮显示，将它们拖入Xcode资源目录，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-2176
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图片文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有图片文件都是*.png*文件。*PNG*代表*可移植网络图形*，它是iOS应用程序中最常用的图片文件类型，因为它具有最小的文件大小，同时还能提供最佳的图像质量。你也可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-2179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图片**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，接下来让我们写一些代码在应用程序中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中名为 *GameScene.swift* 的文件，你应该能看到已经存在的代码。这段代码有两个目的。首先，它为你提供了如何创建一个形状（旋转的方块）以及如何执行一个动作（让方块旋转）的示例。其次，它让你可以立即运行新项目，并确保一切已正确设置。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们将删除大部分代码并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了 `didMove(to:)` 函数和 `update(_:)`
    函数的声明，最终代码应该如下所示：
- en: '*GameScene.swift*'
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE84]'
  id: totrans-2184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏的大部分逻辑将会在 `GameScene` 类中。你可以把场景看作是应用程序中的一个视图或屏幕。`GameScene` 类将管理场景中发生的一切——精灵如何显示、玩家如何与游戏互动、以及如何进行得分。复杂的游戏可能有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（只执行一次的操作）、游戏循环或更新函数（游戏过程中不断发生的操作），以及用户交互函数（只有当用户点击或滑动时才会发生的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
  zh: '`didMove(to:)` 设置函数在你的游戏首次启动时被调用。它非常适合用于设置场景的代码，比如添加初始精灵或设置玩家的分数和生命值的代码。它类似于你在[第10章](text00021.html#ch10)中用来设置日期选择器的
    `viewDidLoad()` 方法，而且它只会被调用一次。'
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，必须设置场景的 `anchorPoint`。请将以下代码添加到 `didMove(to:)` 方法中（灰色的代码行表示一些现有代码，供参考）：
- en: '[PRE85]'
  id: totrans-2189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '![](Image00276.jpg)'
  id: totrans-2190
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉把一张纸钉到软木板上时，图钉就是锚点。纸张将定位在你放置图钉的位置，如果纸张旋转，它会围绕图钉旋转。这正是`anchorPoint`属性在SpriteKit中与精灵和场景的作用方式。游戏模板中的`GameScene`的锚点位于场景的中间，但我们希望将锚点设置为场景的左下角，所以我们将它设置为`CGPoint.zero`，即（0，0）。对于某些游戏，例如太空射击游戏，将锚点放在场景中央会更好。但对于我们的游戏，地面位于屏幕底部，将锚点移至左下角会更方便。有关各种锚点位置的示意图，请参见[图14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-2192
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：从(0, 0)到(1, 1)的锚点位置示例*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x坐标为0的位置时，它将位于屏幕的左边缘。当我们将精灵放置在y坐标为0的位置时，它将位于屏幕的下边缘。
- en: '**NOTE**'
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，从而改变精灵的定位方式和旋转方式。有关使用不同锚点旋转精灵的示例，请参见[图14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-2199
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载背景图像，请在`didMove(to:)`函数中添加以下几行代码：
- en: '[PRE86]'
  id: totrans-2203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析我们刚刚添加的五行代码。➊ 这一行创建了一个名为`background`的精灵，使用的是*`[background@2x.png](mailto:background@2x.png)`*文件或*`[background@3x.png](mailto:background@3x.png)`*文件。这两个文件之前已添加到资源目录中，Xcode会自动选择正确的文件。你只需要在代码中引用它为“background”或“background.png”。要了解Xcode如何选择正确的文件，请参见“[不同屏幕分辨率的图片大小设置](text00026.html#ch14lev1sec7)”第[213页](text00026.html#page_213)。请注意，变量名不必与图像名称匹配——你可以使用任何你想要的变量名。然而，图像名称必须与在项目的资源目录中添加的文件匹配。`SKSpriteNode`是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个`SKSpriteNode`，就像这里做的一样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
  zh: 位置在 ➋ 和 ➌ 的那两行创建了常量 xMid 和 yMid，这两个值将表示屏幕的中心位置。frame 是 GameScene 的一个属性——它是一个
    CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它在屏幕上的位置。一个框架有一个 x 坐标，一个 y 坐标，宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX
    属性给我们提供屏幕框架的中间 x 坐标，midY 则给我们提供中间的 y 坐标。
- en: '![](Image00279.jpg)'
  id: totrans-2206
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 位置在 ➍ 的那一行通过使用 xMid 和 yMid 创建一个 CGPoint，并将其赋值给精灵的位置属性，从而将背景图像的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 坐标和 y 坐标。当处理屏幕坐标时，通常使用 CGFloat 数据类型，而不是
    Float 或 Double。一个 CGPoint 可以包含两个值，一个用于 *x* ，一个用于 *y* ，这使得它在处理 2D 游戏中屏幕坐标时非常方便，因为在这种游戏中，一切都使用
    x 和 y 坐标进行定位。
- en: '**NOTE**'
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的内容都来自* Core Graphics 框架*，这是 Apple 提供的一个用于图形处理的框架。你会在 Swift 中经常看到这种命名方式——类或结构体的前两个或三个字母通常会告诉你该对象的用途或来源。例如，所有
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
  zh: 位置在 ➎ 的那一行通过调用函数 addChild(_:) 将背景图像添加到场景中。这个精灵现在是场景的*子节点*，意味着它附加在这个场景上。例如，如果场景发生变化（比如放大、缩小或消失），这个子精灵也会随之变化。在
    SpriteKit 游戏中，场景始终是父节点，而每个精灵都作为子节点被添加到场景中或另一个精灵中。每当你添加一个精灵时，必须考虑这个精灵的父节点应该是什么。例如，滑冰者精灵是场景的子节点，但如果我们想给滑冰者添加可更换的帽子，就需要使用一个帽子精灵，并将其设置为滑冰者精灵的子节点。这样，每当滑冰者跳跃时，帽子就会保持在滑冰者头上，我们也不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-2213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可以同时在竖屏和横屏模式下运行的游戏需要更多的工作，因此通常最好选择一个适合你游戏的屏幕方向，并仅使用那个方向。由于我们的游戏是一个横向滚动的动作游戏，因此横屏模式（如[图14-8](text00026.html#ch14fig8)所示）是最合适的。
- en: '![](Image00280.jpg)'
  id: totrans-2215
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行该项目，使用iPhone 7模拟器，你会发现它可能默认是纵向方向。让我们更改项目设置，使游戏仅以横向运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-2218
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-2221
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中“纵向”选项，保留两个“横向”方向选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到屏幕上列出的项目和目标，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此时列表将会出现，图标会变为蓝色，表示列表区域已显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**纵向**复选框并取消勾选，保持横向方向选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横向方向启动。我们已经接近完成，但背景图像还没有填充整个屏幕。稍后我们将看看如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在以横向方向运行，你需要确保模拟器也处于横向方向。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **右旋**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-2226
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-2228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你需要处理的不同屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的图像资源在每个设备上都能正确显示。与基于UIKit的应用程序（如我们的生日追踪器）相比，游戏在这方面通常需要更多的工作，因为如果你只是缩放图像，游戏的艺术作品可能会被拉伸。为避免这个问题，你需要为每个设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-2230
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个命名图片文件的系统，可以帮助你区分哪些图片适用于哪些设备。例如，假设你想在游戏中添加一个滑冰者的图片，并且你有一个宽度为 100 像素、高度为
    100 像素（100×100）的滑冰者图片文件。你可以将这个图片命名为 *skater.png*。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图片，尺寸为 200×200 像素，另一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为 300×300
    像素。这三张图片应该是同一张图片的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。若游戏在 iPhone 6
    Plus 上运行，则会自动使用 *@3x* 文件。在你的代码中，你只需要引用图片文件名 skater，只要你在项目中正确命名了图片，Xcode 会自动显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder 游戏，我们将支持从 iPhone 4 起的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，例如* @2x *或* @3x*。没有后缀的图片，例如* skater.png*，被认为是 1x 图片。你只需要为那些具有非
    Retina 显示的旧设备（如 iPhone 3GS 或第一代 iPad mini）包含 1x 大小的图片。因此，我们所有的图片文件都会带有* @2x *或*
    @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图片分组在一起。如果你同时将图片拖动到 Xcode 资源目录，Xcode 会自动识别它们是同一张图片的不同尺寸，并将它们分组在一起，这得益于它们的命名方式。参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-2236
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图片在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还有最后一项准备工作需要完成。你可能注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片没有填满整个屏幕，如 [图
    14-13](text00026.html#ch14fig13) 所示。这是因为 Game 模板处理游戏场景大小的方式。游戏场景的大小将基于我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码来确保我们的场景大小设置正确。
- en: '![](Image00287.jpg)'
  id: totrans-2239
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE87]'
  id: totrans-2243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示出来。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该已经填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《校园滑板》游戏并学习了SpriteKit。你学习了如何在Xcode中创建一个游戏项目并导入资源，例如图像。你还了解了如何通过标准的文件命名方式来支持各种设备的屏幕分辨率，并学习了如何选择在游戏中需要使用的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来就该编写一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切开始动起来，并让玩家点击屏幕使她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-2249
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在“产品名称”字段中将你的项目命名为SchoolhouseSkateboarder。选择**SpriteKit**作为游戏技术。由于我们的游戏仅在iPhone（和iPod
    touch）上运行，选择**iPhone**作为设备设置。然后点击**下一步**来创建你的游戏项目。
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不做任何修改直接运行这个项目，你会看到一个黑屏，上面有一个写着*Hello, World!*的标签。每当你在模拟器中点击鼠标时，屏幕上会出现一个旋转的框（见[图14-2](text00026.html#ch14fig2)），标签会缩小一秒钟。如果标签显示侧面朝上，你可以通过从模拟器菜单中选择**硬件**
    ▸ **向左旋转**来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建一个新项目时，Xcode会自动添加这种简单的交互方式，让你确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-2253
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：在做任何修改之前运行由游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-2255
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不想在游戏中看到一个巨大的 *Hello, World!* 标签，先将其移除。这个标签存在于 *场景编辑器* 中，场景编辑器是一个用来直观设计
    SpriteKit 场景的工具，类似于使用 storyboard 来设计 UIKit 视图。你可以将对象拖入场景编辑器，移动它们，调整它们的大小、颜色以及其他属性。这个工具很有用，但相比于代码，它有许多限制。因此，除了删除
    *Hello, World!* 标签之外，我们在 Schoolhouse Skateboarder 中不会使用场景编辑器。要打开场景编辑器，点击项目导航器中的
    *GameScene.sks* 文件。加载后，你应该能看到一个黑色的场景和 *Hello, World!* 标签。点击标签，然后按 DELETE 键。参见
    [图14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-2256
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除游戏模板中的* Hello, World!* 标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并删除了 *Hello, World!* 标签，可以开始正式的工作了——也就是有趣的部分！
- en: '**ADDING IMAGES**'
  id: totrans-2259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图像添加到项目中作为资源。（资源就是游戏中的元素，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载 ZIP 文件。下载完成后，你会在 *Downloads* 文件夹中看到一个名为 *ch14-images* 的文件夹，里面包含了所有需要的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到项目中，你需要从 Finder 中将它们拖放到 Xcode 中，并放入资源目录。（资源目录是 Xcode 项目中的一种特殊文件夹，用于存放和组织项目资源，如图像文件和图标。）对于图像来说，它非常有用，因为它将相关的图像文件组合在一起。一旦文件进入资源目录，你就可以通过引用文件名在代码中随处使用它们。我们使用的游戏模板已经附带了一个资源目录，名为
    *Assets.xcassets* ，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-2263
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *Assets.xcassets* 。你应该能看到现有的资源，包括 AppIcon 和太空船图像。你可以删除太空船图像，因为我们不会使用它。点击它，然后按
    DELETE 键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder，找到下载图像文件的文件夹。按 ⌘ -A 选择所有文件。一旦文件被选中，将它们拖入 Xcode 的资源目录，如 [图14-4](text00026.html#ch14fig4)
    所示。
- en: '![](Image00275.jpg)'
  id: totrans-2266
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图像文件添加到项目的资源目录*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有图像文件都是 *.png* 格式。*PNG* 代表 *可移植网络图形*，它是 iOS 应用程序中最常用的图像文件类型，因为它在提供最佳图像质量的同时，文件大小最小。你也可以使用
    *.jpg* 格式的文件，但推荐使用 *.png* 格式。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-2269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，让我们编写一些代码，在我们的应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Game 模板创建一个新项目时，某些有用的代码会自动添加到你的项目中。点击项目导航器中名为 *GameScene.swift* 的文件。你应该能看到已经存在的一些代码。这些代码有两个目的。首先，它给你一个如何创建形状（旋转的方块）以及如何执行动作（让方块旋转）的示例。其次，它让你能够立即运行一个新项目，并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们将删除大部分代码并添加我们自己的代码。请继续删除 *GameScene.swift* 中的所有内容，除了 `didMove(to:)`
    函数和 `update(_:)` 函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE88]'
  id: totrans-2274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑都将在 GameScene 类中完成。你可以把场景看作是你应用中的一个视图或屏幕。GameScene 类将管理场景中的所有内容——如何显示精灵、玩家如何与游戏互动、如何进行得分。复杂的游戏可能有许多独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性发生的事情），游戏循环或更新函数（在游戏中反复发生的事情），以及用户交互函数（只有当用户点击或滑动时才会发生的事情）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的游戏首次启动时，setup 函数 `didMove(to:)` 会被调用。它非常适合用于设置场景的代码，比如添加初始精灵或设置玩家的得分和生命值的代码。它类似于你在[第
    10 章](text00021.html#ch10)中用于设置 AddBirthdayViewController 中日期选择器的 `viewDidLoad()`
    方法，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们必须设置场景的 `anchorPoint`。在 `didMove(to:)` 方法中添加这一行代码（灰色的行表示现有的一些代码，仅供参考）：
- en: '[PRE89]'
  id: totrans-2279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '![](Image00276.jpg)'
  id: totrans-2280
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用图钉将纸张钉在软木板上时，图钉就是锚点。纸张将被定位到你放置图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是
    anchorPoint 属性在 SpriteKit 中与精灵和场景一起工作的方式。游戏模板的 GameScene 的锚点位于场景的中央，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero，或者 (0, 0)。对于一些游戏，例如太空射击游戏，将锚点放置在场景中心更为合适。但是对于我们的游戏来说，由于地面位于屏幕底部，将锚点移到左下角会更方便。有关不同锚点的示意图，请参见[图
    14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-2282
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点的不同位置，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 坐标为 0 时，它将位于屏幕的左边缘。而当我们将精灵放置在 y 坐标为 0 时，它将位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个代码文件，项目的最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置精灵的锚点，从而改变该精灵的定位方式和旋转方式。有关使用不同锚点旋转精灵的示例，请参见[图 14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-2289
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点放在中心。我们不会更改任何精灵的锚点，因此我们将始终使用精灵的中心点来定位它们。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-2292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，向 didMove(to:) 函数添加以下代码行：
- en: '[PRE90]'
  id: totrans-2293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析刚刚添加的五行代码。➊ 这一行创建了一个名为 background 的精灵，使用的是 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已添加到资源目录，Xcode 会自动选择正确的文件。你只需在代码中引用它为
    "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参见 “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”
    和 [第 213 页](text00026.html#page_213)。请注意，变量名不必与图像名称匹配——你可以使用任何你想要的变量名。但是，图像名称必须与添加到项目资源目录中的文件匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们会创建一个 SKSpriteNode，就像我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和第➌行创建了常量xMid和yMid，表示屏幕的中间位置。frame是GameScene的一个属性，它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述它们在屏幕上的位置。frame包含x位置、y位置、宽度和高度（参见[图
    14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕frame的中间x位置，midY给出了中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-2296
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-2298
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint，并将其赋值给精灵的position属性，从而将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，它包含两个CGFloat值，分别表示x和y坐标。当处理屏幕坐标时，通常使用CGFloat数据类型，而不是Float或Double。一个CGPoint可以保存两个值，一个表示*x*，一个表示*y*，这使得它在处理2D游戏中使用x和y坐标来定位对象时非常方便。
- en: '**NOTE**'
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自*Core Graphics框架*，这是Apple用于图形的框架。你会经常在Swift中看到这种命名方式——类或结构体的前两个或前三个字母通常告诉你该对象的用途或来源。例如，所有SpriteKit类（如*SKSpriteNode*）都以*SK*开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子节点*，这意味着它附加到该场景上。例如，如果场景发生变化、缩放或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为场景的子节点或另一个精灵的子节点添加。每次添加精灵时，都需要考虑该精灵的父节点应该是谁。例如，滑冰精灵是场景的子节点，但如果我们想为滑冰精灵添加可替换的帽子，可以使用一个帽子精灵，将它作为滑冰精灵的子节点。这样，每当滑冰精灵跳跃时，帽子会始终保持在精灵头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-2303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择那个方向。由于我们的游戏是一个水平滚动的动作游戏，横屏模式（设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-2305
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏模式下的表现*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能默认是竖屏模式。让我们修改项目设置，使游戏仅在横屏模式下运行。前往项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如在[图
    14-9](text00026.html#ch14fig9)中所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-2308
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-2311
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中竖屏选项，保留两个横屏选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，请点击窗口左上角的方形图标，如在[图 14-10](text00026.html#ch14fig10)中所示。这个列表将会显示出来，图标会变成蓝色，表示列表区域已显示。确保选中了**SchoolhouseSkateboarder**目标。现在找到**竖屏**复选框并取消选中它。保持横屏选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它已在横屏模式下启动。我们离目标更近了，但背景图像仍然没有填满屏幕。稍后我们将看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已在横屏模式下运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器菜单中选择**硬件** ▸ **右旋转**，如在[图 14-11](text00026.html#ch14fig11)中所示。
- en: '![](Image00284.jpg)'
  id: totrans-2316
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-2318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要额外工作，以确保你创建的艺术资源能在每个设备上正确显示。游戏通常比基于
    UIKit 的应用程序（如我们的生日追踪器）需要更多的工作，因为如果你仅仅将游戏艺术图像缩放上下，它们会看起来被拉伸。为避免这个问题，你需要为每个你想支持的设备准备不同的图像资源。
- en: '![](Image00285.jpg)'
  id: totrans-2320
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图像文件的系统，帮助你区分哪些图像适用于哪些设备。例如，假设你想在游戏中添加一张滑板图像，并且你有一个尺寸为 100 像素宽、100
    像素高（100×100）的滑板图像文件，你将把这个文件命名为 *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)*
    的 200×200 像素图像，以及一张名为 *[skater@3x.png](mailto:skater@3x.png)* 的 300×300 像素图像。这三张文件应该是同一张图像的不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件将自动被使用。在你的代码中，你只需引用文件名
    skater，只要你在项目中正确命名了图像，Xcode 将显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被认为是 1x 图像。你只需要为那些没有
    Retina 显示屏的旧设备（如 iPhone 3GS 或第一代 iPad mini）提供 1x 尺寸的图像。因此，我们所有的图像文件都会带有* @2x *或*
    @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件分别命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图像分组在一起。如果你同时将图像拖入 Xcode 资源目录，Xcode 会自动识别它们是同一张图像的不同尺寸，并将它们分组在一起，这得益于它们的命名方式。参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-2326
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理背景图像之前，还有最后一步准备工作。你可能注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像没有填满整个屏幕，如 [图 14-13](text00026.html#ch14fig13)
    所示。这是因为 Game 模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的 *GameScene.sks* 场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-2329
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下几行代码，设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE91]'
  id: totrans-2333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了显示视图的大小（宽度和高度），并设置新场景的大小，以便它填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在，背景图片应该会填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了SpriteKit。你学会了如何在Xcode中创建游戏项目并导入资源，如图像等。你还了解了通过标准文件命名规则支持各种设备屏幕分辨率，并学习了如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个SpriteKit游戏项目，包含了所需的资源，并解决了屏幕方向和分辨率的问题，接下来是时候编写一些动作代码了。在[第15章](text00027.html#ch15)，我们将添加我们的英雄角色以及她滑行的地面，制作移动效果，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-2339
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
  zh: 在不做任何更改的情况下，你可以运行这个项目，并看到一个黑屏，屏幕上有一个*Hello, World!* 标签。每当你在模拟器中点击鼠标时，屏幕上会出现一个旋转的框（参见[图
    14-2](text00026.html#ch14fig2)），并且标签会缩小一秒钟。如果标签显示横向，你可以通过在模拟器菜单中选择**硬件** ▸ **左旋转**来旋转模拟器窗口。
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用游戏模板创建一个新项目时，Xcode会添加这个简单的交互，确保一切正常工作。
- en: '![](Image00272.jpg)'
  id: totrans-2342
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：在进行任何更改之前运行由游戏模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-2344
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想在游戏中显示一个巨大的*Hello, World!* 标签，首先将其移除。这个标签存在于*场景编辑器*中，这是一个用于可视化设计SpriteKit场景的工具，类似于UIKit视图设计中使用的Storyboard。你可以将对象拖入场景编辑器，移动它们，调整大小、颜色和其他属性。这个工具可以很有用，但与通过代码能做的事情相比，它有许多局限性。因此，除了删除*Hello,
    World!* 标签外，我们在《Schoolhouse Skateboarder》游戏中不会使用场景编辑器。要打开场景编辑器，点击项目导航器中的*GameScene.sks*文件。加载完成后，你应该看到一个黑色的场景和*Hello,
    World!* 标签。点击标签，然后按DELETE键。参见[图 14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-2345
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：删除游戏模板的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经创建了项目并移除了*Hello, World!* 标签，我们可以开始正事了——也就是有趣的事情！
- en: '**ADDING IMAGES**'
  id: totrans-2348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图片作为资源添加到你的项目中。（资源就是你游戏中的一些元素，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载
    ZIP 文件。下载完成后，你将在*Downloads*文件夹中看到一个名为*ch14-images*的文件夹，里面包含你需要的所有图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片文件添加到项目中，你需要将它们从 Finder 拖到 Xcode 中，并放入一个资源目录。（资源目录是 Xcode 项目中的一种特殊文件夹，用于存放和组织项目资源，比如图片文件和图标。）它对于图片非常有帮助，因为它将相关的图片文件归类在一起。一旦文件进入资源目录，你可以在代码中通过引用它们的文件名来使用它们。我们使用的游戏模板已经自带了一个名为*Assets.xcassets*的资源目录，这就是我们将使用的目录。
- en: '![](Image00274.jpg)'
  id: totrans-2352
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资源，比如 AppIcon 和飞船图像。你可以删除飞船图像，因为我们不再使用它。点击它，然后按
    DELETE 键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder，导航到下载图片文件的文件夹。按 ⌘ -A 全选它们。选中后，将它们拖入 Xcode 的资源目录，如[图 14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-2355
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图片文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，所有图片文件都是*.png*格式的。*PNG*代表*可移植网络图形*，它是iOS应用中最常用的图片文件类型，因为它在保证最佳图像质量的同时，具有最小的文件大小。你可以使用*.jpg*文件，但推荐使用*.png*格式。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-2358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图片**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图片添加到项目中，让我们编写一些代码在应用中显示背景图片。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-2360
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码会自动添加到你的项目中。在项目导航器中点击名为*GameScene.swift*的文件。你应该能看到已经存在的一些代码。这些代码有两个目的。首先，它给了你一个如何创建形状（旋转的盒子）以及如何执行动作（让盒子旋转）的示例。其次，它让你能够立即运行新项目，确保一切设置正常。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将删除大部分代码，并添加我们自己的代码。继续删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，直到它看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE92]'
  id: totrans-2363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将会在 GameScene 类中。可以把一个场景想象成你应用中的一个视图或屏幕。GameScene 类将管理场景内发生的所有事情——如何显示精灵、玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能有许多不同的场景，例如标题场景、菜单场景、游戏场景和设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-2365
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性发生的事情）、游戏循环或更新函数（在游戏过程中反复发生的事情），以及用户交互函数（仅在用户点击或滑动时发生的事情）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数 didMove(to:) 在游戏首次启动时被调用。它非常适合用于设置场景的代码，例如添加初始精灵或设置玩家的得分和生命值的代码。它类似于你在[第
    10 章](text00021.html#ch10)中用来设置 AddBirthdayViewController 中日期选择器的 viewDidLoad()
    方法，并且它只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图片添加到场景之前，我们需要设置场景的锚点。将这行代码添加到 didMove(to:) 方法中（灰色的代码行表示已有代码，仅用于放置）：
- en: '[PRE93]'
  id: totrans-2368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '![](Image00276.jpg)'
  id: totrans-2369
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉将一张纸固定在软木板上时，图钉就是锚点。纸张将被固定在你放置图钉的位置，并且如果纸张旋转，它将围绕图钉旋转。这正是锚点属性在
    SpriteKit 中与精灵和场景的作用方式。游戏模板的 GameScene 场景将其锚点设置在场景的中间，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero，或者 (0, 0)。对于某些游戏，例如太空射击游戏，将锚点放置在场景的中间可能更好。但对于我们的游戏，地面位于屏幕底部，将锚点移动到左下角会更容易操作。有关各种锚点位置的示意图，请参见[图
    14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-2371
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点的各种位置，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 位置为 0 时，它将位于屏幕的左边缘。当我们将精灵放置在 y 位置为 0 时，它将位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-2376
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。请参见[图14-6](text00026.html#ch14fig6)，了解如何通过不同的锚点来旋转精灵。
- en: '![](Image00278.jpg)'
  id: totrans-2378
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会改变任何精灵的锚点，因此我们总是使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-2381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载背景图像，将以下代码添加到didMove(to:)函数中：
- en: '[PRE94]'
  id: totrans-2382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析一下刚才添加的五行代码。第➊行创建了一个名为background的精灵，使用的是* [background@2x.png](mailto:background@2x.png)*文件或*
    [background@3x.png](mailto:background@3x.png)*文件。两个文件之前已经添加到资源目录中，Xcode会自动选择正确的文件。你只需在代码中引用它，名称可以是“background”或“background.png”。要了解Xcode如何选择正确的文件，请参见“[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”一节，位于[第213页](text00026.html#page_213)。注意，变量名不必与图像名称匹配——你可以为变量命名任何你喜欢的名字。但图像名称必须与项目中资源目录中的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们实际上是在创建一个SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们代表屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，用来描述它在屏幕上的位置。一个frame包含x位置、y位置、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给我们提供屏幕frame的中间x位置，而midY则给我们提供中间的y位置。
- en: '![](Image00279.jpg)'
  id: totrans-2385
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行将我们的背景图像位置设置为屏幕的中央，通过使用xMid和yMid创建一个CGPoint，并将其赋值给精灵的position属性。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x坐标和y坐标。当处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以存储两个值，一个是*x*，一个是*y*，这使得在2D游戏中处理屏幕坐标变得非常方便，因为游戏中的所有位置都使用x和y坐标来描述。
- en: '**NOTE**'
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自* Core Graphics框架*，这是一个用于图形处理的苹果框架。你会注意到，在 Swift 中这种命名方式很常见——一个类或结构的前两三个字母通常告诉你这个对象是做什么的，或者它来自哪里。例如，所有的
    SpriteKit 类，比如* SKSpriteNode*，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 这一行通过调用函数 `addChild(_:)` 向场景中添加了背景图像。这个精灵现在是场景的*子对象*，这意味着它被附加到这个场景上。例如，如果场景发生变化，比如变大、变小或者消失，这个子精灵也会随之变化。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵都作为场景的子对象或者作为另一个精灵的子对象添加进去。每当你添加一个精灵时，重要的是要考虑这个精灵的父对象应该是谁。例如，滑板精灵是场景的子对象，但如果我们想要在滑板精灵上添加可更换的帽子，我们就会使用一个帽子精灵，它是滑板精灵的子对象。这样，每当滑板精灵跳跃时，帽子就会跟着滑板精灵一起移动，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-2392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-2394
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-2395
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能会默认使用竖屏模式。让我们修改项目设置，使得游戏只能在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色的图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-2397
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-2400
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选竖屏选项，保持两个横屏方向选项已勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-2402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此时列表会出现，图标会变为蓝色，表示现在已经显示了该列表区域。确保选中**SchoolhouseSkateboarder**目标。然后找到**Portrait**复选框并取消勾选。保持横屏方向选项已勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们离目标更近了，但背景图片仍然没有填满屏幕。稍后我们会看看如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-2404
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在以横屏方向运行，你需要确保模拟器也处于横屏方向。要旋转它，请从模拟器的菜单中选择 **硬件** ▸ **右旋**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-2405
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-2406
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-2407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**不同屏幕分辨率的图片尺寸调整**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术素材能够在每个设备上正确显示。与基于
    UIKit 的应用（如我们的生日追踪器）相比，游戏在这方面通常需要更多的工作，因为如果只是简单地缩放，游戏的艺术作品会看起来被拉伸。为了避免这个问题，你需要为每个要支持的设备准备一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-2409
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个系统，用于命名图像文件，帮助你区分哪些图像适用于哪些设备。例如，假设你想在游戏中添加一张滑冰者的图片，并且你有一张宽 100 像素、高
    100 像素的滑冰者图像文件（100×100）。你可以将这张图片命名为 *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图片，尺寸为 200×200 像素，以及另一张名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为 300×300
    像素。这三张文件应该是同一张图片的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件将自动被使用。在你的代码中，你可以仅引用文件名 skater，Xcode 会根据你在项目中正确命名的图像文件来显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-2412
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-2413
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被视为 1x 图像。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 大小的图像，因为这些设备没有视网膜显示屏。因此，我们所有的图像文件都会带有* @2x *或*
    @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图像分组在一起。如果你同时将不同尺寸的图像拖入Xcode的资源目录，Xcode会根据它们的命名方式自动识别它们是同一图像的不同尺寸并将它们分组在一起。见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-2415
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-2416
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们还有最后一点准备工作要做。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板处理游戏场景大小的方式。游戏场景的大小将根据包含在我们项目中的*GameScene.sks*场景编辑文件中的设置来确定。由于我们在本项目中不会使用场景编辑器，因此我们需要添加代码来确保我们的场景尺寸正确。
- en: '![](Image00287.jpg)'
  id: totrans-2418
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-2421
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE95]'
  id: totrans-2422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-2423
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了所显示视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在，背景图片应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《Schoolhouse Skateboarder》游戏，并了解了SpriteKit。你学会了如何在Xcode中创建游戏项目，并将图像等资源导入项目中。你还了解了如何通过标准的文件命名方法支持不同设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-2427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，让一切开始移动，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-2428
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用Game模板创建新项目时，Xcode都会添加这个简单的交互功能，以便你确保一切正常。
- en: '![](Image00272.jpg)'
  id: totrans-2430
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：在进行任何更改之前运行由Game模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们不想在游戏中看到一个巨大的 *Hello, World!* 标签，那就先把它移除。这个标签存在于 *场景编辑器* 中，这是一个用来可视化设计 SpriteKit
    场景的工具，类似于 UIKit 用来设计视图的 storyboard。你可以将对象拖入场景编辑器，移动它们，改变它们的大小、颜色以及其他属性。这个工具很有用，但相比于代码，它有很多局限性。因此，除了删除
    *Hello, World!* 标签外，我们在 Schoolhouse Skateboarder 中不会再使用场景编辑器。要打开场景编辑器，请点击项目导航栏中的
    *GameScene.sks* 文件。加载后，你应该会看到一个黑色的场景，并且有 *Hello, World!* 标签。点击标签，然后按 DELETE 键。见[图
    14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-2433
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-2435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并删除了 *Hello, World!* 标签，我们可以开始正式的工作——也就是娱乐工作！
- en: '**ADDING IMAGES**'
  id: totrans-2436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图像添加到项目中作为资源。（资源就是你游戏中的物品，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-2438
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载 ZIP 文件。下载完成后，你将在 *Downloads* 文件夹内得到一个名为 *ch14-images* 的文件夹，里面包含了所有需要的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到项目中，你需要将它们从 Finder 拖到 Xcode 中，并将其放入资源目录。（资源目录是 Xcode 项目中的一种特殊文件夹，用来保存和组织项目资源，如图像文件和图标。）它对图像特别有用，因为它将相关的图像文件分组在一起。文件进入资源目录后，你可以通过引用文件名在代码中随时使用它们。我们使用的游戏模板已经包含一个名为
    *Assets.xcassets* 的资源目录，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-2440
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航栏中点击 *Assets.xcassets*。你应该能看到现有的资源：AppIcon 和飞船图像。由于我们不会使用飞船图像，你可以将其删除。点击它，然后按
    DELETE 键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-2442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder，导航到下载图像文件的文件夹。按 ⌘ -A 选择所有文件。选中后，将它们拖动到 Xcode 的资源目录中，如[图 14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-2443
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图像文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-2445
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到所有图像文件都是*.png* 文件。*PNG* 代表 *便携式网络图形*，它是 iOS 应用中最常用的图像文件类型，因为它在保证最佳图像质量的同时，文件大小最小。你也可以使用*.jpg*
    文件，但推荐使用*.png* 文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-2446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图片添加到项目中，接下来我们编写一些代码来在应用中显示背景图片。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Game 模板创建新项目时，一些有用的代码会自动添加到项目中。点击项目导航器中的 *GameScene.swift* 文件，你应该会看到一些已经写好的代码。这段代码有两个目的。首先，它给你一个创建形状（旋转的盒子）和执行动作（让盒子旋转）的示例。其次，它让你能够立即运行新项目，并确保一切设置正常。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-2449
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将删除大部分代码并添加我们自己的代码。继续删除 *GameScene.swift* 中的所有内容，除了 didMove(to:) 函数和
    update(_:) 函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE96]'
  id: totrans-2451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑都将在 GameScene 类中。可以把一个场景看作是你应用中的一个视图或屏幕。GameScene 类将管理场景中发生的一切——如何显示精灵，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能会有多个独立的场景——例如，一个标题场景，一个菜单场景，一个游戏场景和一个设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（只会执行一次的操作）、游戏循环或更新函数（在游戏过程中反复执行的操作），以及用户交互函数（只有当用户点击或滑动时才会执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
  zh: setup 函数 didMove(to:) 会在游戏首次启动时被调用。它非常适合放置初始化场景的代码，例如添加初始精灵或设置玩家的分数和生命。它类似于你在
    [第 10 章](text00021.html#ch10) 中用于设置 AddBirthdayViewController 中日期选择器的 viewDidLoad()
    方法，并且只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
  zh: 在将背景图片添加到场景之前，我们需要设置场景的 anchorPoint。将这行代码添加到 didMove(to:) 方法中（灰色的代码行表示现有的代码，供参考）：
- en: '[PRE97]'
  id: totrans-2456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '![](Image00276.jpg)'
  id: totrans-2457
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用大头针将一张纸钉在软木板上时，大头针就是锚点。纸张将被放置在大头针的位置，如果纸张旋转，它将围绕大头针旋转。这正是
    SpriteKit 中锚点属性在精灵和场景中的作用。游戏模板中的 GameScene 将其锚点设置在场景的中央，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero ，即 (0, 0)。对于某些游戏，比如太空射击游戏，将锚点设置在场景中央会更好。但对于我们的游戏来说，由于地面位于屏幕底部，将锚点移动到左下角会更方便操作。查看[图
    14-5](text00026.html#ch14fig5)以了解各种锚点的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-2459
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：从 (0, 0) 到 (1, 1) 的各种锚点位置。*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-2461
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在 x 位置为 0 时，它会位于屏幕的左边缘。当我们将一个精灵放置在 y 位置为 0 时，它会位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步地构建项目的每个代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位和旋转方式。查看[图 14-6](text00026.html#ch14fig6)了解使用不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-2466
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载背景图片，请在 didMove(to:) 函数中添加以下代码行：
- en: '[PRE98]'
  id: totrans-2470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析刚才添加的五行代码。第 ➊ 行创建了一个名为 background 的精灵，使用 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。两个文件都已经添加到资源目录中，Xcode 会自动选择正确的文件。你只需要在代码中引用它为“background”或“background.png”。要了解
    Xcode 如何选择正确的文件，请参阅 “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)” 在[第 213 页](text00026.html#page_213)。请注意，变量名不需要与图像名匹配——你可以使用任何你想要的变量名。然而，图像名必须与添加到项目资源目录中的文件名匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们会创建一个 SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们代表屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述了它们在屏幕上的位置。一个frame有x位置、y位置、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕frame的中间x位置，midY给出了中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-2473
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint，并将其分配给精灵的position属性，从而将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。在处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以包含两个值，一个用于*x*，一个用于*y*，这使得它在2D游戏中处理屏幕坐标非常方便，因为所有元素的定位都使用x和y坐标。
- en: '**NOTE**'
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以*CG*开头的内容都来自*Core Graphics框架*，这是Apple用于图形的框架。你会经常在Swift中看到这种命名系统——类或结构体的前两到三个字母通常能告诉你该对象的用途或来源。例如，所有SpriteKit类，如*SKSpriteNode*，都以*SK*开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，这意味着它被附加到这个场景中。例如，如果场景发生增长、缩小或消失，子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，所有精灵都作为该场景的子对象或其他精灵的子对象被添加。每当你添加一个精灵时，重要的是要考虑该精灵的父对象应该是什么。例如，滑冰者精灵是场景的子对象，但如果我们想为滑冰者添加可更换的帽子，我们会使用一个帽子精灵，它是滑冰者精灵的子对象。这样，每当滑冰者跳跃时，帽子就会保持在滑冰者头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-2480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择那一个。由于我们的游戏是一个水平滚动的动作游戏，横屏模式（设备侧着放置，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-2482
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，您会注意到它可能默认使用竖屏方向。我们来更改项目设置，让游戏仅在横屏下运行。进入项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，并且旁边有一个蓝色图标，正如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-2485
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，您可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-2488
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选竖屏选项，保持两个横屏方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在屏幕上看不到项目和目标的列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。该列表将会出现，并且图标会变为蓝色，表示该列表区域现在正在显示。确保选中**SchoolhouseSkateboarder**目标。现在找到**Portrait**复选框并取消勾选。保持横屏方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，您会看到它在横屏方向启动。我们越来越接近了，但背景图像还没有填满屏幕。稍后我们将看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏现在在横屏方向运行，您需要确保模拟器也处于横屏方向。要旋转模拟器，请从模拟器菜单中选择**硬件** ▸ **右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-2493
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-2495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-2496
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。您支持的设备越多，就需要处理的屏幕大小就越多，这意味着您需要额外的工作来确保您创建的艺术资源能在每个设备上正确显示。与我们基于
    UIKit 的应用程序（例如生日追踪器）相比，游戏在这方面通常需要更多的努力，因为如果仅仅放大或缩小，游戏艺术图像会显得被拉伸。为了避免这个问题，您必须为每个想要支持的设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-2497
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图像文件的系统，帮助你判断哪些图像适用于哪些设备。例如，假设你想在游戏中添加一个滑板手的图像，并且你有一个宽 100 像素、高 100
    像素（100×100）的滑板手图像文件。你可以将该图像命名为 *skater.png*。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像文件，尺寸为 200×200 像素，以及一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像文件，尺寸为
    300×300 像素。这三张文件应该是同一图像的三种不同尺寸。如果游戏运行在 iPhone 4 上，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone
    6 Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需引用文件名 skater ，只要你正确命名了项目中的图像，Xcode 会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder 游戏，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-2500
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，比如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被认为是 1x 图像。你只需要为那些具有非视网膜显示屏的旧设备（例如
    iPhone 3GS 或第一代 iPad mini）提供 1x 大小的图像。因此，我们所有的图像文件都会带有 *@2x* 或 *@3x* 后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件名为*[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图片归为一组。如果你同时将这些图片拖入 Xcode 的资源目录，Xcode 会自动识别它们是同一张图片的不同尺寸，并将它们分组在一起，这要归功于它们的命名方式。请参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-2503
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如
    [图 14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板在处理游戏场景的大小时采用了某种方式。游戏场景的大小将基于我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置来确定。由于在这个项目中我们不会使用场景编辑器，因此我们需要添加代码，以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-2506
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE99]'
  id: totrans-2510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-2511
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个**GameScene**类的实例并显示它。由于**GameScene**是我们游戏的主场景，我们希望它始终填充整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图片现在应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作**Schoolhouse Skateboarder**游戏，并学习了SpriteKit。你学习了如何在Xcode中创建一个游戏项目并导入资源，例如图片，进入项目。你还学习了如何通过标准的文件命名方式支持各种设备的屏幕分辨率，以及如何选择游戏中需要使用的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-2515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了SpriteKit游戏项目，并准备好了所需的资源，解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，使一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00272.jpg)'
  id: totrans-2516
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00272.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-2517
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：在进行任何更改之前运行由Game模板创建的项目*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望游戏中有一个巨大的*Hello, World!*标签，让我们先把它去掉。这个标签存在于*场景编辑器*中，这是一个用于可视化设计SpriteKit场景的工具，类似于UIKit视图的故事板设计方式。你可以将对象拖入场景编辑器，移动它们，改变它们的大小、颜色和其他属性。这个工具可以很有用，但与代码中可以实现的功能相比，它有很多限制。因此，除了移除*Hello,
    World!*标签之外，我们不会在**Schoolhouse Skateboarder**中使用场景编辑器。要打开场景编辑器，点击项目导航器中名为*GameScene.sks*的文件。加载后，你应该能看到一个黑色的场景和*Hello,
    World!*标签。点击标签，然后按DELETE键。请参见[图14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-2519
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-2520
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除Game模板中的*Hello, World!*标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经创建了项目并移除了*Hello, World!*标签，我们可以开始进入正题了——也就是进入娱乐的世界！
- en: '**ADDING IMAGES**'
  id: totrans-2522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有的图片作为资源添加到项目中。（资源就是你游戏中的某个物品，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-2524
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你会在*下载*文件夹中得到一个名为*ch14-images*的文件夹，其中包含你所需的所有图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到你的项目中，你需要将它们从Finder中拖动到Xcode，并放入资源目录中。（资源目录是Xcode项目中的一种特殊文件夹，用于存储和组织项目资源，如图像文件和图标。）对于图像来说，这非常有帮助，因为它将相关的图像文件组合在一起。将文件放入资源目录后，你可以通过引用文件名在代码中的任何地方使用它们。我们使用的Game模板自带一个名为*Assets.xcassets*的资源目录，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-2526
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-2527
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*Assets.xcassets*。你应该能看到现有的资源，AppIcon和飞船图像。你可以删除飞船图像，因为我们不会使用它。点击它，然后按DELETE键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-2528
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，导航到下载图像文件的文件夹。按⌘-A选择所有文件。选中后，将它们拖入Xcode资源目录，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-2529
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-2530
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图像文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-2531
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到所有的图像文件都是*.png*格式的。*PNG*代表*可移植网络图形*，它是iOS应用中最常用的图像文件类型，因为它在保证最佳图像质量的同时，具有最小的文件大小。你也可以使用*.jpg*文件，但建议使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-2532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-2533
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，接下来让我们编写一些代码，在应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Game模板创建新项目时，一些有用的代码会自动添加到项目中。点击项目导航器中的*GameScene.swift*文件，你应该会看到一些已经存在的代码。这些代码有两个目的。首先，它展示了如何创建一个形状（旋转的方块）以及如何执行一个动作（让方块旋转）。其次，它让你可以立即运行一个新项目，并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将删除大部分代码，并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE100]'
  id: totrans-2537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-2538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑都将在GameScene类中完成。可以把场景想象成你应用中的一个视图或屏幕。GameScene类将管理场景中的所有内容——如何显示精灵，玩家如何与游戏互动，以及如何进行计分。复杂的游戏可能有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-2539
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的操作）、游戏循环或更新函数（游戏过程中不断执行的操作）以及用户交互函数（仅在用户点击或滑动时执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
  zh: setup函数didMove(to:)会在游戏开始时被调用。它非常适合用于设置场景的代码，比如添加初始精灵或设置玩家的分数和生命值的代码。它类似于你在[第10章](text00021.html#ch10)中用于设置AddBirthdayViewController中的日期选择器的viewDidLoad()方法，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向场景中添加背景图片之前，我们必须设置场景的anchorPoint。将以下代码行添加到didMove(to:)方法中（灰色行表示现有代码的部分，供参考）：
- en: '[PRE101]'
  id: totrans-2542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '![](Image00276.jpg)'
  id: totrans-2543
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张将位于你放置图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是SpriteKit中anchorPoint属性与精灵和场景的工作方式。游戏模板中的GameScene的锚点位于场景的中心，但我们希望锚点位于场景的左下角，因此我们将其设置为CGPoint.zero，即(0,
    0)。对于某些游戏，如太空射击游戏，最好将锚点设置在场景的中央。但对于我们的游戏，由于地面位于屏幕底部，将锚点移至左下角将使操作更加便捷。请参见[图 14-5](text00026.html#ch14fig5)以了解不同锚点的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-2545
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-2546
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点的不同位置，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-2547
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在x坐标为0的位置时，它将位于屏幕的左边缘。当我们将一个精灵放置在y坐标为0的位置时，它将位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-2548
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步一步地构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置精灵的锚点，改变该精灵的定位方式及旋转方式。请参见[图 14-6](text00026.html#ch14fig6)以了解不同锚点下旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-2552
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-2553
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-2555
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，将以下代码行添加到didMove(to:)函数中：
- en: '[PRE102]'
  id: totrans-2556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析刚才添加的五行代码。第➊行创建了一个名为background的精灵，使用* [background@2x.png](mailto:background@2x.png)*文件或*
    [background@3x.png](mailto:background@3x.png)*文件。两个文件都已提前添加到资产目录中，Xcode会自动选择正确的文件。你只需在代码中引用它，使用“background”或“background.png”。要了解Xcode如何选择正确的文件，请参见“[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”第[213页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以根据需要选择任何变量名。然而，图像名称必须与您在项目中的资产目录中添加的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，所以当我们在游戏中创建一个精灵时，我们实际上是在创建一个SKSpriteNode，正如我们这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-2558
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它在屏幕上的位置。一个框架具有x位置、y位置、宽度和高度（参见[图14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕框架的中间x位置，midY给出了屏幕框架的中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-2559
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行将我们的背景图像位置设置为屏幕的中间，方法是创建一个使用xMid和yMid的CGPoint，并将其赋值给精灵的位置属性。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-2562
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，表示x和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以包含两个值，一个用于*x*，一个用于*y*，这使得在二维游戏中处理屏幕坐标变得方便，因为一切都是通过x和y坐标来定位的。
- en: '**NOTE**'
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-2564
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何内容都来自* Core Graphics框架*，这是苹果公司用于图形处理的框架。你会在Swift中经常看到这种命名系统——一个类或结构体的前两三个字母通常会告诉你该对象的用途或来源。例如，所有的SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
  zh: ➎处的这一行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，这意味着它附属于这个场景。例如，如果场景发生变化，比如变大、变小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都会作为场景的子对象或另一个精灵的子对象添加。每次添加精灵时，重要的是要考虑这个精灵的父对象应该是谁。例如，滑板精灵是场景的子对象，但如果我们想给滑板精灵加上一顶可更换的帽子，我们会使用一个帽子精灵作为滑板精灵的子对象。这样，每当滑板精灵跳跃时，帽子就会留在滑板精灵上，而我们不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-2566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何进行播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持纵向和横向模式的游戏需要更多工作，因此通常最好决定哪种方向最适合你的游戏，并选择其中一种。由于我们的游戏是一个横向滚动的动作游戏，因此横屏方向（设备侧放，如[图14-8](text00026.html#ch14fig8)所示）是最合适的。
- en: '![](Image00280.jpg)'
  id: totrans-2568
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-2569
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在纵向和横向方向下的表现*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用iPhone 7模拟器，你会注意到它可能默认是纵向方向。让我们更改项目设置，使游戏只在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-2571
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-2574
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消勾选“纵向”选项，保留两个横向方向选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。这个列表将会出现，并且图标会变蓝，表示列表区域现在正在显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**纵向**复选框并取消勾选，保留横向方向选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横向方向启动。我们已经越来越接近了，但背景图像还没有填满屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-2578
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏运行在横屏方向下，你需要确保模拟器也处于横屏方向。要旋转模拟器，从模拟器的菜单中选择**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-2579
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-2581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-2582
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨代码之前，我们应该先决定支持哪些设备和屏幕分辨率。支持的设备越多，你需要处理的不同屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。游戏在这方面往往比基于
    UIKit 的应用（比如我们的生日追踪器）需要更多的努力，因为如果你只是简单地放大或缩小，游戏的艺术作品会显得拉伸变形。为了避免这个问题，你需要为每个你想要支持的设备使用一套不同的图片。
- en: '![](Image00285.jpg)'
  id: totrans-2583
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个系统用于命名图片文件，帮助你区分哪些图片是用于哪些设备的。例如，假设你想在游戏中添加一张滑冰者的图片，并且你有一张宽 100 像素、高
    100 像素（100×100）的滑冰者图片文件。你会将该图片命名为 *skater.png*。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图片，它的尺寸为 200×200 像素，再创建一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为 300×300
    像素。这三张文件应该是同一张图片的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需引用文件名 skater ，只要你正确命名了项目中的图片，Xcode 会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《学校滑板者》游戏，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-2586
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有后缀，如* @2x *或* @3x*。没有后缀的图片，例如* skater.png*，被认为是 1x 图片。你只需要为那些没有视网膜显示的旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 尺寸的图片。因此，我们所有的图片文件都会有 *@2x* 或 *@3x* 后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-2588
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图片分组在一起。如果你同时将图片拖入 Xcode 资源目录，Xcode 会自动识别它们是同一张图片的不同尺寸，并根据命名规则将它们分组。参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-2589
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-2590
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图片在资源目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一点准备工作。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板在处理游戏场景的大小时的方式。游戏场景的大小将基于包含在我们项目中的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在这个项目中不使用场景编辑器，因此我们需要添加代码，以确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-2592
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-2594
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行以设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-2595
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE103]'
  id: totrans-2596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-2597
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-2598
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图片应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-2600
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作Schoolhouse Skateboarder游戏，并学习了SpriteKit。你学习了如何在Xcode中创建游戏项目并导入资源（例如图像）。你还了解了如何通过标准的文件命名惯例支持不同设备的屏幕分辨率，以及如何选择在游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作代码。[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，使所有内容动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-2602
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  id: totrans-2603
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：运行由Game模板创建的项目，未进行任何更改之前的状态*'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-2604
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想在游戏中显示一个巨大的*Hello, World!*标签，让我们先移除它。这个标签存在于*场景编辑器*中，这是一个用于可视化设计 SpriteKit
    场景的工具，类似于在 UIKit 中使用的故事板设计视图。你可以将对象拖入场景编辑器，移动它们，改变它们的大小、颜色以及其他属性。这是一个有用的工具，但与在代码中能做的事情相比，它有很多局限性。因此，除了移除*Hello,
    World!*标签之外，我们不会在《Schoolhouse Skateboarder》游戏中使用场景编辑器。要打开场景编辑器，点击项目导航器中名为*GameScene.sks*的文件。一旦加载，你应该会看到一个黑色的场景，其中有*Hello,
    World!*标签。点击标签，然后按 DELETE。见[图 14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-2605
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并移除了*Hello, World!*标签，我们可以开始真正的工作了——也就是有趣的部分！
- en: '**ADDING IMAGES**'
  id: totrans-2608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图片添加到项目中作为资源。（资源就是你游戏中的一个元素，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-2610
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载
    ZIP 文件。下载完成后，你会在*Downloads*文件夹中看到一个名为*ch14-images*的文件夹，其中包含了所有需要的图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片文件添加到项目中，你需要从 Finder 将它们拖动到 Xcode 中，并放入一个资源目录中。（资源目录是 Xcode 项目中的一种特殊文件夹，用于存放和组织项目资源，如图片文件和图标。）它对图片非常有帮助，因为它将相关的图片文件分组在一起。一旦文件进入资源目录，你可以通过引用它们的文件名，在代码的任何地方使用这些图片。我们使用的游戏模板已经包含了一个名为*Assets.xcassets*的资源目录，这就是我们将要使用的目录。
- en: '![](Image00274.jpg)'
  id: totrans-2612
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资源，包括 AppIcon 和太空船图片。你可以删除太空船图片，因为我们不会使用它。点击它，然后按
    DELETE。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-2614
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder，导航到下载图片文件的文件夹。按 ⌘ -A 选择所有文件。选中后，将它们拖入 Xcode 的资源目录，如[图 14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-2615
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-2616
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图片文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，所有的图片文件都是*.png*格式的。*PNG*代表*可移植网络图形*，它是 iOS 应用程序中最常用的图片文件类型，因为它在保证最佳质量的同时，文件大小最小。你可以使用*.jpg*格式的文件，但推荐使用*.png*格式。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-2618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图片**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-2619
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图片添加到项目中，让我们编写一些代码在应用中显示背景图片。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-2620
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中的名为 *GameScene.swift* 的文件。你应该会看到里面已经有了一些代码。这些代码有两个目的。首先，它展示了如何创建一个形状（旋转的盒子）以及如何执行一个动作（让盒子旋转）。其次，它让你可以立即运行一个新项目，确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-2621
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将删除大部分代码并添加我们自己的代码。请删除 *GameScene.swift* 中的所有内容，除了 didMove(to:) 函数的声明和
    update(_:) 函数，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE104]'
  id: totrans-2623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将会在 GameScene 类中。可以把场景想象成你应用中的一个视图或屏幕。GameScene 类将管理场景中的所有内容——精灵如何显示、玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能会有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-2625
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的操作），游戏循环或更新函数（游戏中反复执行的操作），以及用户交互函数（只有当用户点击或滑动时才会执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-2626
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数 didMove(to:) 会在你的游戏首次启动时被调用。它非常适合用来设置场景的代码，例如添加初始精灵或设置玩家的得分和生命值的代码。它类似于你在
    [第 10 章](text00021.html#ch10) 中使用的 viewDidLoad() 方法，用来设置 AddBirthdayViewController
    中的日期选择器，并且只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图片添加到场景之前，必须先设置场景的 anchorPoint。将以下代码添加到 didMove(to:) 方法中（灰色行表示一些现有的代码，用于定位）：
- en: '[PRE105]'
  id: totrans-2628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '![](Image00276.jpg)'
  id: totrans-2629
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-2630
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点会决定精灵在场景中的位置。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张将被定位在你放置图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是
    SpriteKit 中锚点属性如何与精灵和场景一起工作的方式。游戏模板中的 GameScene 的锚点位于场景的中央，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero，或 (0, 0)。对于某些游戏，如太空射击游戏，将锚点设置在场景的中央可能更合适。但对于我们的游戏，由于地面位于屏幕底部，将锚点移动到左下角将使其更易于操作。请参见
    [图14-5](text00026.html#ch14fig5) 了解各种锚点位置的插图。
- en: '![](Image00277.jpg)'
  id: totrans-2631
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-2632
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-2633
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 坐标为 0 时，它将位于屏幕的左边缘。当我们将精灵放置在 y 坐标为 0 时，它将位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-2635
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建项目的每个代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-2637
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，从而改变该精灵的位置和旋转方式。请参见 [图14-6](text00026.html#ch14fig6) 了解使用不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-2638
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，请将以下代码行添加到 didMove(to:) 函数中：
- en: '[PRE106]'
  id: totrans-2642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-2643
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析刚刚添加的五行代码。➊ 这一行创建了一个名为 background 的精灵，使用的是 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。两个文件之前已经添加到资产目录中，Xcode
    会自动选择合适的文件。你只需要在代码中将其引用为 "background" 或 "background.png"。要了解 Xcode 如何选择合适的文件，请参见
    “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)” ，该内容位于 [第213页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以随意为变量命名。但图像名必须与已添加到项目资产目录中的文件匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们会创建一个 SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-2644
  prefs: []
  type: TYPE_NORMAL
  zh: ➋和➌这两行创建了常量xMid和yMid，它们将表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述它在屏幕上的位置。frame有x位置、y位置、宽度和高度（见[图
    14-7](text00026.html#ch14fig7)）。midX属性给我们提供了屏幕frame的中间x位置，而midY给我们提供了屏幕frame的中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-2645
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-2646
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-2647
  prefs: []
  type: TYPE_NORMAL
  zh: ➎这行代码通过使用xMid和yMid创建一个CGPoint，并将其分配给精灵的position属性，从而将背景图像的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，表示x和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以保存两个值，一个是*x*，另一个是*y*，这使得它在2D游戏中处理屏幕坐标变得非常方便，因为一切都使用x和y位置来定位。
- en: '**NOTE**'
  id: totrans-2649
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的内容都来自* Core Graphics framework*，这是一个苹果公司用于图形的框架。你会在 Swift 中经常看到这种命名系统——类或结构体的前两三个字母通常会告诉你该对象的用途或来源。例如，所有
    SpriteKit 类，如* SKSpriteNode*，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
  zh: ➏这行代码通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它被附加到这个场景上。例如，如果场景发生变化（变大、变小或消失），这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，而每个精灵都作为场景的子对象或其他精灵的子对象添加。每当你添加一个精灵时，重要的是要考虑它的父对象应该是什么。例如，滑冰者精灵是场景的子对象，但如果我们想在滑冰者上添加可更换的帽子，我们会使用一个帽子精灵，它是滑冰者精灵的子对象。这样，每当滑冰者跳跃时，帽子就会停留在滑冰者头上，而不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-2652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何进行游戏：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后选择其中一种。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（设备横置，如[图
    14-8](text00026.html#ch14fig8)所示）是最合适的。
- en: '![](Image00280.jpg)'
  id: totrans-2654
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行该项目，你会注意到它可能默认处于纵向模式。让我们更改项目设置，以便游戏仅在横屏模式下运行。前往项目导航器并点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，正如[图
    14-9](text00026.html#ch14fig9)中所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-2657
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标列表。
- en: '![](Image00283.jpg)'
  id: totrans-2660
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-2661
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中纵向选项，保持勾选两个横向方向选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-2662
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到项目和目标列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。列表将会出现，图标会变成蓝色，表示该列表区域现在已显示。确保已选择**SchoolhouseSkateboarder**目标。然后找到**纵向**复选框并取消选中，保持横向方向选项处于勾选状态。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会发现它已在横屏模式下启动。我们越来越接近了，但背景图像尚未填充整个屏幕。稍后我们将看看如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-2664
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏现在是横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **右旋**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-2665
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-2666
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-2667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-2668
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，应该先决定支持哪些设备和屏幕分辨率。支持的设备越多，你需要处理的不同屏幕尺寸也越多，这意味着你需要做额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。与基于
    UIKit 的应用程序（例如我们的生日追踪器）相比，游戏在这一领域需要更多的工作，因为如果你只是简单地放大或缩小，游戏的艺术资源会显得拉伸变形。为了避免这个问题，你必须为每个支持的设备准备不同的图像资源。
- en: '![](Image00285.jpg)'
  id: totrans-2669
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-2670
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个命名图片文件的系统，帮助你区分哪些图片是针对哪些设备的。例如，假设你想为你的游戏添加一张滑冰者的图片，而你有一张宽 100 像素、高
    100 像素（100×100）的滑冰者图片文件。你可以将这张图片命名为 *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图片，尺寸为 200×200 像素，再创建一张名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为 300×300
    像素。这三张文件应该是同一张图片的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需要引用文件名 skater，只要你在项目中正确命名了图片，Xcode 会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《学校滑板车手》游戏，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-2672
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-2673
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，例如* @2x *或* @3x*。没有后缀的图片，例如* skater.png*，被认为是 1x 图片。你只需要为那些没有视网膜显示屏的旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 大小的图片。因此，我们所有的图片文件都会带有 *@2x* 或 *@3x* 后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会发现 Xcode 已经将这两张图片分组在一起。如果你同时将同一张图片的不同尺寸拖入 Xcode 资源目录，Xcode
    会自动识别这些图片是同一张图片的不同尺寸，并根据它们的命名方式将它们分组在一起。参见 [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-2675
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-2676
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图片在资源目录中分组显示。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-2677
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完背景图片后，我们还有最后一项准备工作要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片并没有填满整个屏幕，如 [图
    14-13](text00026.html#ch14fig13) 所示。这是因为 Game 模板在处理游戏场景大小时的方式。游戏场景的大小将根据我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置来确定。由于我们在本项目中不会使用场景编辑器，因此我们需要添加代码以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-2678
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-2679
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-2681
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE107]'
  id: totrans-2682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-2683
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了所显示视图的大小（宽度和高度），并设置新场景的大小以使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-2684
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行项目。现在背景图片应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-2686
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《Schoolhouse Skateboarder》游戏，并了解了SpriteKit。你学会了如何在Xcode中创建一个游戏项目并导入资源，比如图片。你还了解了通过标准文件命名实践支持各种设备屏幕分辨率，并学会了如何选择游戏中需要的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-2687
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个带有所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切开始运动，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-2688
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  id: totrans-2689
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望游戏中有一个巨大的*Hello, World!*标签，所以我们先把它移除。这个标签存在于*场景编辑器*中，场景编辑器是一个用来可视化设计SpriteKit场景的工具，类似于使用故事板来设计UIKit视图。你可以将对象拖入场景编辑器，移动它们，改变它们的大小、颜色和其他属性。这个工具很有用，但相比代码，它有许多限制。因此，除了移除*Hello,
    World!*标签外，我们在《Schoolhouse Skateboarder》中不会使用场景编辑器。要打开场景编辑器，点击项目导航器中的*GameScene.sks*文件。一旦加载，你应该会看到一个黑色的场景和*Hello,
    World!*标签。点击标签，然后按DELETE键。参见[图14-3](text00026.html#ch14fig3)。
- en: '![](Image00273.jpg)'
  id: totrans-2690
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-2691
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并移除了*Hello, World!*标签，接下来我们可以开始进入正题——也就是玩得开心！
- en: '**ADDING IMAGES**'
  id: totrans-2693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图片作为资源添加到你的项目中。（资源就是游戏中的元素，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你会在*Downloads*文件夹中看到一个名为*ch14-images*的文件夹，里面包含了所有需要的图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到你的项目中，你需要将它们从 Finder 拖到 Xcode，并将它们放入资源目录中。（资源目录是 Xcode 项目中的一种特殊文件夹，用于存储和组织项目资源，如图像文件和图标。）它对图像文件非常有帮助，因为它将相关的图像文件归类在一起。一旦文件进入资源目录，你可以通过引用它们的文件名在代码中的任何地方使用它们。我们使用的游戏模板已经自带一个资源目录，叫做
    *Assets.xcassets*，这就是我们将使用的目录。
- en: '![](Image00274.jpg)'
  id: totrans-2697
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-2698
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *Assets.xcassets*。你应该看到现有的资源，包括 AppIcon 和飞船图像。你可以删除飞船图像，因为我们不会使用它。点击它，然后按
    DELETE 键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder，导航到下载图像文件的文件夹。按下 ⌘ -A 选择所有文件。一旦它们被高亮显示，将它们拖到 Xcode 的资源目录中，如[图 14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-2700
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-2701
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图像文件添加到项目的资源目录*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-2702
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有的图像文件都是*.png*文件。*PNG*代表*可移植网络图形*，它是 iOS 应用中最常用的图像文件类型，因为它在提供最佳图像质量的同时，文件大小最小。你可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-2703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，接下来我们编写一些代码来在应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-2705
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中的 *GameScene.swift* 文件。你应该能看到已经存在的一些代码。这段代码有两个目的。首先，它给你提供了如何创建形状（旋转的盒子）以及如何执行动作（让盒子旋转）的示例。其次，它让你可以立即运行新项目，确保一切都设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
  zh: 到了这个阶段，我们将删除大部分代码，并添加我们自己的代码。请删除 *GameScene.swift* 中的所有内容，除了 didMove(to:) 函数和
    update(_:) 函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-2707
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE108]'
  id: totrans-2708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将会在 GameScene 类中。可以将场景视为应用中的一个视图或屏幕。GameScene 类将管理场景内发生的一切——例如精灵如何显示，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能有许多独立的场景——例如标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的任务）、游戏循环或更新函数（在游戏过程中反复执行的任务）以及用户交互函数（仅在用户点击或滑动时执行的任务）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-2711
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的游戏首次启动时，`didMove(to:)` 设置函数会被调用。它非常适合用于设置场景的代码，比如添加初始精灵或设置玩家的分数和生命值。这类似于你在[第10章](text00021.html#ch10)中用于设置
    AddBirthdayViewController 中日期选择器的 `viewDidLoad()` 方法，而且它只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
  zh: 在将背景图像添加到场景之前，我们必须设置场景的 `anchorPoint`。将以下代码行添加到 `didMove(to:)` 方法中（灰色行表示一些已有代码，便于定位）：
- en: '[PRE109]'
  id: totrans-2713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '![](Image00276.jpg)'
  id: totrans-2714
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-2715
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张会被放置在你放置图钉的位置，如果纸张旋转，它将围绕图钉旋转。这与
    `anchorPoint` 属性在 SpriteKit 中如何与精灵和场景交互完全一致。游戏模板中的 GameScene 的锚点位于场景的中心，但我们希望将锚点放在场景的左下角，因此我们将其设置为
    `CGPoint.zero`，即 (0, 0)。对于某些游戏，例如太空射击游戏，将锚点放在场景中心会更好。但对于我们的游戏，地面位于屏幕的底部，将锚点移到左下角会使操作更方便。请参见[图14-5](text00026.html#ch14fig5)了解不同锚点位置的示例。
- en: '![](Image00277.jpg)'
  id: totrans-2716
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-2717
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-2718
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 坐标为 0 时，它会位于屏幕的左边缘。而当我们将精灵放置在 y 坐标为 0 时，它会位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-2720
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建每个代码文件，项目的最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-2721
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-2722
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式和旋转方式。请参见[图14-6](text00026.html#ch14fig6)了解旋转精灵的不同锚点示例。
- en: '![](Image00278.jpg)'
  id: totrans-2723
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点放置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-2726
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，将以下代码行添加到 `didMove(to:)` 函数中：
- en: '[PRE110]'
  id: totrans-2727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析我们刚刚添加的五行代码。➊ 处的代码创建了一个名为 background 的精灵，使用的是 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已经添加到资源目录中，Xcode
    会自动选择正确的文件。你只需要在代码中引用它，使用 "background" 或 "background.png" 即可。要了解 Xcode 如何选择正确的文件，请参阅
    “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)” 在 [第 213 页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以为变量名使用任何你想要的名称。然而，图像名必须与项目中资源目录中添加的文件匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们实际上是在创建一个 SKSpriteNode，就像我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 和 ➌ 处的代码创建了常量 xMid 和 yMid，它们代表屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，用来描述它在屏幕上的位置。一个框架具有
    x 位置、y 位置、宽度和高度（参见 [图 14-7](text00026.html#ch14fig7)）。midX 属性提供屏幕框架的中间 x 位置，而
    midY 提供屏幕框架的中间 y 位置。
- en: '![](Image00279.jpg)'
  id: totrans-2730
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-2731
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ 处的代码通过使用 xMid 和 yMid 创建一个 CGPoint，并将其赋值给精灵的位置属性，从而将背景图像的位置设置为屏幕的中心。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，表示 x 和 y 坐标。当你处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个 CGPoint 可以容纳两个值，一个表示 *x* ，一个表示 *y* ，这使得它在处理 2D 游戏中的屏幕坐标时非常方便，因为游戏中的所有物体都是基于
    x 和 y 位置来定位的。
- en: '**NOTE**'
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-2735
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自于* Core Graphics 框架*，这是苹果公司用于图形处理的框架。你会在 Swift 中经常看到这种命名系统——类或结构体的前两三个字母通常会告诉你该对象的用途或来源。例如，所有
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子*节点，这意味着它被附加到这个场景上。例如，如果场景发生变化，增大、缩小或消失，这个子精灵也会发生相应变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都会作为场景的子节点或另一个精灵的子节点被添加。每当你添加一个精灵时，重要的是要考虑这个精灵的父对象应该是什么。例如，滑冰者精灵是场景的子节点，但如果我们想给滑冰者添加可更换的帽子，我们就会使用一个帽子精灵，它是滑冰者精灵的子节点。这样，无论滑冰者跳跃，帽子都会留在滑冰者身上，我们也不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-2737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏如何进行：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-2738
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个既能在纵向也能在横向模式下运行的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，然后只选择那个方向。由于我们的游戏是一个水平滚动的动作游戏，因此横屏模式（设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-2739
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在纵向与横向模式下的表现*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-2741
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，你会注意到它可能默认是纵向模式。让我们更改项目设置，使游戏仅在横屏模式下运行。进入项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-2742
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-2743
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-2745
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-2746
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选纵向选项，保留横向两个方向选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此列表会出现，图标会变蓝，表示列表区域已显示。确保选择了**SchoolhouseSkateboarder**目标。接下来找到**Portrait**复选框并取消勾选。保留横屏选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们离目标越来越近了，但背景图像还没有填满屏幕。稍后我们会看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-2749
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经在横屏模式下运行，你需要确保模拟器也处于横屏模式。要旋转模拟器，请在模拟器的菜单中选择**硬件** ▸ **右旋**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-2750
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-2751
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-2752
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-2753
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，应该先决定我们将支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理的不同屏幕尺寸越多，这意味着你需要额外工作，以确保你创建的图像资源在每个设备上都能正确显示。与
    UIKit 基础的应用程序（例如我们的生日追踪器）相比，游戏通常在这方面需要更多的工作，因为如果你只是简单地将游戏艺术作品缩放，上下拉伸会使其看起来不正常。为避免这种问题，你必须为每个想要支持的设备使用不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-2754
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图像文件的系统，帮助你识别不同设备所使用的图像。例如，假设你想在游戏中添加一张滑冰者的图像，并且你有一张宽度为 100 像素、高度为
    100 像素（100×100）的滑冰者图像文件。你可以将这张图像命名为 *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)*、大小为
    200×200 像素的图像，和另一张名为 *[skater@3x.png](mailto:skater@3x.png)*、大小为 300×300 像素的图像。这三张文件应该是相同的图像，只是大小不同。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。若游戏在 iPhone 6 Plus 上运行，则会自动使用带有 *@3x* 后缀的文件。在你的代码中，你只需引用文件名
    skater，只要你正确命名了项目中的图像，Xcode 会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《学校滑板选手》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-2757
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，比如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被认为是 1x 图像。你只需要为那些没有视网膜显示屏的旧设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 大小的图像。因此，我们所有的图像文件都将带有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 已将这两张图像分组在一起。如果你同时将图像拖入 Xcode 资源目录，Xcode 会自动识别它们是同一图像的不同尺寸，并将它们分组在一起，正是因为它们的命名方式。请参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-2760
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资源目录中分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，正如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将基于我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在这个项目中不使用场景编辑器，所以需要添加代码来确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-2763
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，并找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE111]'
  id: totrans-2767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该已经填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了SpriteKit。你学会了如何在Xcode中创建游戏项目并将资源（如图像）导入项目中。你还了解了如何通过标准的文件命名规范支持不同设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个SpriteKit游戏项目，拥有了所需的资源，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作代码。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使所有元素动起来，并让玩家通过点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00273.jpg)'
  id: totrans-2773
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00273.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：删除游戏模板中的*Hello, World!* *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-2775
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并删除了*Hello, World!*标签，接下来就可以开始动手了——当然是指有趣的部分！
- en: '**ADDING IMAGES**'
  id: totrans-2776
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-2777
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图像添加到项目中作为资源。（资源就是游戏中的各种元素，例如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你会在*Downloads*文件夹中得到一个名为*ch14-images*的文件夹，里面包含了所有需要的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到你的项目中，你需要从Finder拖动它们到Xcode中，并将它们放入资源目录。（资源目录是Xcode项目中的一种特殊类型的文件夹，用来存储和组织项目资源，如图像文件和图标。）它对图像有帮助，因为它将相关的图像文件分组在一起。一旦文件放入资源目录中，你可以通过引用它们的文件名，在代码中任何地方使用它们。我们使用的游戏模板已经带有一个资源目录，名为*Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-2780
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资源，AppIcon和飞船图像。你可以删除飞船图像，因为我们不会使用它。点击它然后按DELETE键删除。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，导航到图像文件下载的文件夹。按⌘ -A选择所有文件。一旦它们被选中，将它们拖入Xcode资源目录，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-2783
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-2784
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图像文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到所有的图像文件都是*.png*文件。*PNG*代表*可移植网络图形*，它是iOS应用中最常用的图像文件类型，因为它具有最佳质量图像的最小文件大小。你也可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-2786
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-2787
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，让我们编写一些代码在我们的应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-2788
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码会自动添加到你的项目中。在项目导航器中点击名为*GameScene.swift*的文件。你应该已经看到一堆代码。这段代码有两个目的。首先，它给你提供了如何创建一个形状（旋转的方块）和如何执行一个动作（让方块旋转）的示例。其次，它让你能够立刻运行一个新项目，并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们将移除大部分代码并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数的声明和update(_:)函数，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE112]'
  id: totrans-2791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将集中在GameScene类中。可以把场景想象成应用中的一个视图或屏幕。GameScene类将管理场景中发生的所有事情——精灵应该如何显示，玩家如何与游戏互动，得分如何进行。复杂的游戏可能有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（只发生一次的事情）、游戏循环或更新函数（在游戏中反复发生的事情）以及用户交互函数（只有在用户点击或滑动时发生的事情）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
  zh: '`didMove(to:)` 函数在你的游戏首次启动时被调用。它非常适合用来设置场景的代码，例如添加初始精灵或设置玩家的分数和生命值的代码。它类似于你在
    [第 10 章](text00021.html#ch10) 中用来设置 AddBirthdayViewController 中日期选择器的 `viewDidLoad()`
    方法，并且它只会被调用一次。'
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-2795
  prefs: []
  type: TYPE_NORMAL
  zh: 在将背景图片添加到场景之前，我们必须设置场景的 `anchorPoint`。将以下代码行添加到 `didMove(to:)` 方法中（灰色的行表示一些现有的代码，仅为摆放之用）：
- en: '[PRE113]'
  id: totrans-2796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '![](Image00276.jpg)'
  id: totrans-2797
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-2798
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉把一张纸钉在软木板上时，图钉就是锚点。纸张会被放置在你放置图钉的位置，如果纸张旋转，它会围绕图钉旋转。这正是
    `anchorPoint` 属性在 SpriteKit 中如何与精灵和场景一起工作的方式。游戏模板中的 GameScene 的锚点在场景的中央，但我们希望锚点位于场景的左下角，因此我们将其设置为
    `CGPoint.zero`，即 (0, 0)。对于一些游戏，比如太空射击游戏，将锚点放在场景的中央会更好。但对于我们的游戏来说，由于地面在屏幕底部，将锚点移到左下角会使得操作更为方便。有关不同锚点位置的示意图，请参见
    [图 14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-2799
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-2800
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点位置的不同，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 位置为 0 时，它会位于屏幕的左边缘。而当我们将精灵放置在 y 位置为 0 时，它会位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获得。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-2805
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置精灵的锚点，改变该精灵的位置和旋转方式。有关使用不同锚点旋转精灵的示例，请参见 [图 14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-2806
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-2808
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点放在中心。我们不会更改任何精灵的锚点，因此我们将始终使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图片，请将以下代码添加到 `didMove(to:)` 函数中：
- en: '[PRE114]'
  id: totrans-2810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析一下刚才添加的五行代码。第➊行创建了一个名为`background`的精灵，使用*`[background@2x.png](mailto:background@2x.png)`*文件或*`[background@3x.png](mailto:background@3x.png)`*文件。两个文件都已提前添加到资源目录中，Xcode会自动选择正确的文件。你只需在代码中将其引用为“background”或“background.png”。要了解Xcode如何选择正确的文件，请参见“[为不同屏幕分辨率调整图片大小](text00026.html#ch14lev1sec7)”第213页。请注意，变量名不需要与图像名匹配——你可以为变量名使用任何你想要的名称。然而，图像名必须与项目中添加到资源目录的文件名匹配。`SKSpriteNode`是SpriteKit中的精灵类，因此，当我们在游戏中创建一个精灵时，我们实际上是在创建一个`SKSpriteNode`，就像这里做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-2812
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋行和第➌行创建了常量`xMid`和`yMid`，它们表示屏幕的中间位置。`frame`是`GameScene`的一个属性——它是一个`CGRect`（矩形），表示整个屏幕。每个场景和精灵都有一个`frame`，用来描述它们在屏幕上的位置。一个`frame`有x位置、y位置、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。`midX`属性给我们提供了屏幕`frame`的中间x位置，而`midY`则给出中间的y位置。
- en: '![](Image00279.jpg)'
  id: totrans-2813
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个`frame`描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-2815
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用`xMid`和`yMid`创建一个CGPoint，并将其分配给精灵的位置属性，从而将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGPoint`是一个结构体，包含两个`CGFloat`值，分别表示x和y坐标。当你处理屏幕坐标时，通常使用`CGFloat`作为数据类型，而不是`Float`或`Double`。一个`CGPoint`可以存储两个值，一个是*x*，一个是*y*，这使得它在2D游戏中处理屏幕坐标变得非常方便，因为在2D游戏中，一切都使用x和y的位置来定位。'
- en: '**NOTE**'
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-2818
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以*CG*开头的东西都来自*Core Graphics框架*，这是一个用于图形的Apple框架。你会在Swift中经常看到这种命名方式——类或结构体的前两个或三个字母通常告诉你该对象的用途或来源。例如，所有的SpriteKit类，如*SKSpriteNode*，都以*SK*开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
  zh: 位于➎的那一行通过调用函数addChild(_)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，这意味着它被附加到该场景上。例如，如果场景发生扩展、收缩或消失，这个子精灵也会发生相应变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为场景的子对象或另一个精灵的子对象被添加。每当你添加一个精灵时，重要的是要考虑这个精灵的父对象应该是什么。例如，滑板精灵是场景的子对象，但如果我们想要为滑板精灵添加可互换的帽子，我们会使用一个帽子精灵，它是滑板精灵的子对象。这样，当滑板精灵跳跃时，帽子会保持在滑板精灵上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-2820
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-2821
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可以在竖屏和横屏模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并仅选择这一种。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（即设备侧着放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-2822
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-2823
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏模式下的样子*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用iPhone 7模拟器，你会注意到它可能默认处于竖屏模式。让我们更改项目设置，使游戏仅在横屏模式下运行。进入项目导航器并点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-2825
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-2826
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-2827
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-2828
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-2829
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选竖屏选项，保持横屏方向的两个选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。该列表会出现，图标也会变为蓝色，表示列表区域现在正在显示。确保选中了**SchoolhouseSkateboarder**目标。然后找到**Portrait**复选框并取消勾选。保持横屏方向选项选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-2831
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们离目标更近了，但背景图像还没有填满屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-2832
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏现在运行在横屏模式下，你需要确保模拟器也处于横屏模式。要旋转模拟器，请从模拟器的菜单中选择**硬件** ▸ **右旋**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-2833
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-2834
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-2835
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你需要处理的不同屏幕尺寸就越多，这意味着你需要额外工作以确保你创建的艺术资源能够在每个设备上正确显示。游戏比像我们的生日追踪器这样的UIKit应用程序更需要在这方面付出更多努力，因为如果你只是简单地放大或缩小，游戏的艺术作品看起来会被拉伸。为避免这个问题，你需要为每个支持的设备使用不同的一组图片。
- en: '![](Image00285.jpg)'
  id: totrans-2837
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-2838
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个命名图片文件的系统，帮助你区分不同设备的图片。例如，假设你想在游戏中添加一个滑板运动员的图片，你有一张宽100像素，高100像素（100×100）的滑板运动员图片。你会将该图片命名为*skater.png*。你还需要创建一张命名为*[skater@2x.png](mailto:skater@2x.png)*，大小为200×200像素的图片，另一个命名为*[skater@3x.png](mailto:skater@3x.png)*，大小为300×300像素的图片。这三张文件应该是相同图片的三种不同尺寸。如果游戏在iPhone
    4上运行，*@2x*文件会自动被使用，因为它有方便的*@2x*后缀。如果游戏在iPhone 6 Plus上运行，*@3x*文件会自动被使用。在你的代码中，你只需引用文件名skater，Xcode会根据你在项目中正确命名的图片显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-2839
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Schoolhouse Skateboarder游戏，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-2840
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，例如* @2x *或* @3x*。没有后缀的图片，例如* skater.png*，被认为是1x图片。你只需要为旧设备（如iPhone
    3GS或第一代iPad mini）包含1x大小的图片，这些设备没有视网膜显示屏。因此，我们所有的图片文件都会有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-2842
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件分别命名为*[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图片组合在一起。如果你同时将图片拖入Xcode资源目录，Xcode会自动识别它们是同一张图片的不同尺寸，并将它们组合在一起，原因就在于它们的命名方式。参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-2843
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-2844
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图片被组合在资源目录中。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-2845
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还有一项最后的准备工作需要完成。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图片没有填满整个屏幕，如[图 14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将基于我们项目中包含的*GameScene.sks*场景编辑器文件中的设置。我们在这个项目中不会使用场景编辑器，因此需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-2846
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-2847
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-2848
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到`viewDidLoad()`方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-2849
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE115]'
  id: totrans-2850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-2851
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()`方法中的代码创建了一个`GameScene`类的实例并将其显示出来。由于`GameScene`是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图片应该已经填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2853
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《学校滑板者》游戏并学习了SpriteKit。你学会了如何在Xcode中创建一个游戏项目并将资源（如图片）导入项目中。你还了解了如何通过标准的文件命名实践来支持各种设备的屏幕分辨率，以及如何选择游戏中需要的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-2855
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来该编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，让一切开始运动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-2856
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  id: totrans-2857
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：删除游戏模板中的* Hello, World! *标签*'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-2858
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并移除了*Hello, World!*标签，接下来可以开始正事了——也就是好玩的事情！
- en: '**ADDING IMAGES**'
  id: totrans-2859
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-2860
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图片作为资源添加到项目中。（资源就是你游戏中的元素，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你将在*Downloads*文件夹中找到一个名为*ch14-images*的文件夹，里面包含了所有你需要的图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-2862
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到项目中，你需要从 Finder 中将它们拖入 Xcode，并将它们放入资源目录中。（资源目录是 Xcode 项目中的一种特殊文件夹，用于存储和组织项目资源，如图像文件和图标。）它对图像很有帮助，因为它将相关的图像文件归类在一起。一旦文件进入资源目录，你可以通过引用它们的文件名在代码中的任何地方使用它们。我们使用的游戏模板已经带有一个资源目录，名为
    *Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-2863
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-2864
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *Assets.xcassets*。你应该会看到现有的资源，包括 AppIcon 和飞船图像。你可以删除飞船图像，因为我们不会使用它。点击它然后按
    DELETE 删除。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-2865
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder，导航到下载图像文件的文件夹。按下⌘-A选择所有文件。一旦它们被选中，将它们拖入 Xcode 资源目录，如[图 14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-2866
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图像文件添加到你的项目资源目录*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-2868
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到所有图像文件都是 *.png* 文件。*PNG* 代表 *可移植网络图形*，它是 iOS 应用中最常用的图像文件类型，因为它以最小的文件大小提供最佳的图像质量。你也可以使用
    *.jpg* 文件，但推荐使用 *.png* 文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-2869
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图片**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-2870
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，让我们写一些代码来在我们的应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-2871
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中的 *GameScene.swift* 文件。你应该能看到已经存在的一些代码。这些代码有两个目的。首先，它为你提供了如何创建一个形状（旋转的盒子）以及如何执行一个动作（让盒子旋转）的示例。其次，它让你能够立即运行一个新项目并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-2872
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们将删除大部分代码并添加我们自己的代码。去掉 *GameScene.swift* 中的所有内容，除了 didMove(to:) 函数和 update(_:)
    函数的声明，让它看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-2873
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE116]'
  id: totrans-2874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-2875
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将会在 GameScene 类中。可以把场景看作是你应用中的一个视图或屏幕。GameScene 类将管理场景内发生的一切——如何显示精灵，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能有许多独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-2876
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的操作）、游戏循环或更新函数（在游戏过程中反复执行的操作）以及用户交互函数（只有当用户点击或滑动时才会执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-2877
  prefs: []
  type: TYPE_NORMAL
  zh: setup函数didMove(to:)在游戏开始时被调用。它非常适合用于设置场景的代码，比如添加初始精灵或者设置玩家的得分和生命值。它类似于你在[第10章](text00021.html#ch10)中用来设置日期选择器的viewDidLoad()方法，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-2878
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图片添加到场景之前，我们需要设置场景的anchorPoint。将这行代码添加到didMove(to:)方法中（灰色的代码行表示一些现有的代码，仅用于位置说明）：
- en: '[PRE117]'
  id: totrans-2879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '![](Image00276.jpg)'
  id: totrans-2880
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-2881
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张将根据你放置图钉的位置定位，并且如果纸张旋转，它会围绕图钉旋转。这正是anchorPoint属性在SpriteKit中的工作方式。游戏模板的GameScene的锚点位于场景的中间，但我们希望将锚点设置在场景的左下角，所以我们将它设置为CGPoint.zero，或者(0,
    0)。对于一些游戏，比如太空射击游戏，将锚点设置在场景的中间更为合适。但对于我们的游戏，因为地面位于屏幕底部，将锚点移到左下角会更容易处理。参见[图14-5](text00026.html#ch14fig5)了解不同锚点的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-2882
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-2883
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点位置从(0, 0)到(1, 1)的不同位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-2884
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x位置为0时，它将位于屏幕的左边缘。当我们将精灵放置在y位置为0时，它将位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-2885
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-2886
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-2887
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-2888
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。参见[图14-6](text00026.html#ch14fig6)了解不同锚点下精灵旋转的示例。
- en: '![](Image00278.jpg)'
  id: totrans-2889
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-2890
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-2891
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会改变任何精灵的锚点，所以我们将始终使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-2892
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图片，向didMove(to:)函数添加以下代码行：
- en: '[PRE118]'
  id: totrans-2893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-2894
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来逐行讲解刚才添加的五行代码。➊处的代码行创建了一个名为background的精灵，使用* [background@2x.png](mailto:background@2x.png)
    *文件或* [background@3x.png](mailto:background@3x.png) *文件。这两个文件之前已经添加到资源目录中，Xcode会自动选择正确的文件。你只需要在代码中引用它为“background”或“background.png”。要了解Xcode如何选择正确的文件，请参阅“[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”第[213页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以随意命名变量名。但图像名必须与项目中资源目录中添加的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们会创建一个SKSpriteNode，正如我们在这里所做的。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-2895
  prefs: []
  type: TYPE_NORMAL
  zh: ➋和➌处的代码行创建了常量xMid和yMid，它们将代表屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它在屏幕上的位置。一个框架有x位置、y位置、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给出屏幕框架的中间x位置，而midY给出中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-2896
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-2898
  prefs: []
  type: TYPE_NORMAL
  zh: ➍处的代码行通过使用xMid和yMid创建一个CGPoint，并将其分配给精灵的位置属性，从而将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-2899
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以保存两个值，一个用于*x*，一个用于*y*，这使得它在2D游戏中处理屏幕坐标时非常方便，因为所有内容都通过x和y的位置来定位。
- en: '**NOTE**'
  id: totrans-2900
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-2901
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的内容都来自* Core Graphics框架*，这是一个用于图形的Apple框架。你会在Swift中经常看到这种命名系统——类或结构体的前两三个字母通常会告诉你该对象的用途或来源。例如，所有的SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-2902
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，这意味着它附加到这个场景上。例如，如果场景变大、变小或消失，这个子精灵也会跟着变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都是该场景的子对象或另一个精灵的子对象。每当你添加一个精灵时，重要的是要考虑该精灵的父对象应该是什么。例如，滑冰者精灵是场景的子对象，但如果我们想为滑冰者添加可更换的帽子，我们会使用一个帽子精灵，它是滑冰者精灵的子对象。这样，每当滑冰者跳跃时，帽子会留在滑冰者头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-2903
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏的播放方式：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-2904
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个既能在竖屏又能在横屏模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后只选择那一种。由于我们的游戏是一个水平滚动的动作游戏，因此横屏模式（设备侧置，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-2905
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-2906
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏与横屏模式下的表现*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-2907
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，你会注意到它可能默认是竖屏模式。让我们更改项目设置，使得游戏只在横屏模式下运行。进入项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器顶部，旁边有一个蓝色图标，如你在[图
    14-9](text00026.html#ch14fig9)中看到的那样。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-2908
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-2909
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-2910
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-2911
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-2912
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中“Portrait”选项，保留两个横屏方向选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-2913
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上没有看到项目和目标列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。这个列表将会出现，并且图标会变成蓝色，表示列表区域现在正在显示。确保选中了**SchoolhouseSkateboarder**目标。然后找到**Portrait**复选框并取消选中，保持横屏方向选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经越来越接近了，但背景图像还没有填满整个屏幕。稍后我们会看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-2915
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已在横屏模式下运行，你需要确保模拟器也处于横屏模式。要旋转模拟器，选择**Hardware** ▸ **Rotate Right**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-2916
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-2917
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11: 旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-2918
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-2919
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的图像资源能够在每个设备上正确显示。游戏在这方面通常需要比基于
    UIKit 的应用程序（如我们的生日追踪器）更多的工作，因为如果你只是缩放图像，游戏的艺术作品看起来会被拉伸。为避免这个问题，你必须为每个支持的设备准备不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-2920
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-2921
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名规则来帮助你判断图像适用于哪些设备。例如，假设你想为游戏添加一张滑板手的图像，并且你有一张宽度为 100 像素、高度为 100 像素（100×100）的滑板手图像。你会将这张图像命名为
    *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)* 的图像，它的尺寸是 200×200
    像素，另外再创建一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，尺寸为 300×300 像素。这三张文件应该是同一张图像的三种不同尺寸。如果游戏运行在
    iPhone 4 上，带有 *@2x* 后缀的文件将自动被使用。如果游戏运行在 iPhone 6 Plus 上，则会自动使用带有 *@3x* 后缀的文件。在你的代码中，你只需引用图像名为
    skater，Xcode 会根据你在项目中正确命名的图像来显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-2922
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750，和
    1920×1080。
- en: '**NOTE**'
  id: totrans-2923
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-2924
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被认为是 1x 图像。你只需要为旧设备（例如
    iPhone 3GS 或第一代 iPad mini）包含 1x 尺寸的图像，因为这些设备没有视网膜显示屏。因此，我们所有的图像文件都会有* @2x *或*
    @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-2925
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件分别命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资产目录，你会注意到 Xcode 将这两张图片分组在一起。如果你同时将这两张图片拖入 Xcode 资产目录，Xcode
    会自动识别它们是同一张图片的不同尺寸，因为它们的命名方式，并将它们分组在一起。见 [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-2926
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-2927
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12: 具有多个尺寸的图像在资产目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-2928
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作需要完成。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为Game模板在处理游戏场景大小时的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在这个项目中不会使用场景编辑器，所以需要添加代码来确保场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-2929
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-2930
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填充整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件并找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-2932
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE119]'
  id: totrans-2933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-2934
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在此添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-2935
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2936
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-2937
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作*Schoolhouse Skateboarder*游戏，并学习了SpriteKit。你学习了如何在Xcode中创建游戏项目并导入资源，比如图像。你还了解了通过标准文件命名惯例来支持不同设备的屏幕分辨率，并学会了如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-2938
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了SpriteKit游戏项目，并且处理了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使所有元素移动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-2939
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  id: totrans-2940
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目并移除了*Hello, World!*标签，我们可以开始真正的工作了——当然是有趣的工作！
- en: '**ADDING IMAGES**'
  id: totrans-2941
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图像**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-2942
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图片添加到项目的资源中。（资源就是游戏中的各种物品，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
  zh: 从*[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*下载ZIP文件。下载完成后，你将在*Downloads*文件夹中得到一个名为*ch14-images*的文件夹，其中包含所有所需的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-2944
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到项目中，你需要将它们从Finder拖到Xcode，并放入资源目录中。（资源目录是Xcode项目中的一种特殊文件夹，用于存放和组织项目资源，如图像文件和图标。）它对于图像非常有用，因为它将相关的图像文件归类在一起。一旦文件添加到资源目录中，你就可以通过引用它们的文件名在代码中使用它们。我们使用的游戏模板已经带有一个资源目录，叫做*Assets.xcassets*，这就是我们将要使用的目录。
- en: '![](Image00274.jpg)'
  id: totrans-2945
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-2946
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航中的*Assets.xcassets*，你应该能看到现有的资源，AppIcon和飞船图像。你可以删除飞船图像，因为我们不再使用它。点击它，然后按DELETE键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-2947
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，导航到图像文件下载的文件夹。按⌘-A选择所有文件。一旦它们被高亮显示，拖动它们到Xcode的资源目录中，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-2948
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图像文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-2950
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到所有图像文件都是*.png*文件。*PNG*代表*便携式网络图形*，它是iOS应用中最常用的图像文件类型，因为它在保证最佳图像质量的同时具有最小的文件大小。你也可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-2951
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，我们来写一些代码，在我们的应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码会自动添加到项目中。点击项目导航中的名为*GameScene.swift*的文件，你应该能看到一些已经存在的代码。这里的代码有两个目的。首先，它给你一个如何创建形状（旋转的盒子）和如何执行动作（让盒子旋转）的示例。其次，它让你能够立即运行新项目，确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-2954
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将删除大部分代码并添加我们自己的代码。现在去掉*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-2955
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE120]'
  id: totrans-2956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-2957
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将位于GameScene类中。可以将场景看作是应用中的一个视图或屏幕。GameScene类将管理场景内发生的一切——如何显示精灵，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能会有许多独立的场景——例如，一个标题场景、一个菜单场景、一个游戏场景和一个设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-2958
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的操作）、游戏循环或更新函数（在游戏过程中反复执行的操作）以及用户交互函数（只有在用户点击或滑动时才会执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-2959
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数didMove(to:)会在游戏首次启动时调用。它非常适合用来设置场景的代码，比如添加初始精灵或设置玩家的得分和生命数。它类似于你在[第 10
    章](text00021.html#ch10)中用来设置AddBirthdayViewController中日期选择器的viewDidLoad()方法，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们必须先设置场景的anchorPoint。请在didMove(to:)方法中添加以下代码行（灰色行表示现有的代码，用于放置）：
- en: '[PRE121]'
  id: totrans-2961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '![](Image00276.jpg)'
  id: totrans-2962
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张将被定位在图钉所在的位置，如果纸张旋转，它将围绕图钉旋转。这正是SpriteKit中anchorPoint属性与精灵和场景的作用方式。游戏模板的GameScene将锚点设置在场景的中间，但我们希望锚点位于场景的左下角，所以我们将其设置为CGPoint.zero，或者(0,
    0)。对于一些游戏，比如太空射击游戏，将锚点设置在场景的中间会更好。但对于我们的游戏，地面位于屏幕底部，将锚点移到左下角会更方便使用。请参见[图 14-5](text00026.html#ch14fig5)，了解各种锚点的位置示意图。
- en: '![](Image00277.jpg)'
  id: totrans-2964
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点的不同位置，范围从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-2966
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x坐标为0的位置时，它将位于屏幕的左边缘。而当我们将精灵放置在y坐标为0的位置时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-2967
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-2968
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步一步地构建每个代码文件用于这些项目。最终版本可从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-2969
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-2970
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，从而改变精灵的位置和旋转方式。请参见[图 14-6](text00026.html#ch14fig6)，其中展示了使用不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-2971
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-2972
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-2973
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用其中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-2974
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要加载我们的背景图像，请在didMove(to:)函数中添加以下代码行：
- en: '[PRE122]'
  id: totrans-2975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-2976
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来逐行解析我们刚刚添加的五行代码。第➊行创建了一个名为background的精灵，使用的是* [background@2x.png](mailto:background@2x.png)
    *文件或* [background@3x.png](mailto:background@3x.png) *文件。这两个文件之前已经添加到资源目录中，Xcode会自动选择合适的文件。你只需要在代码中将其引用为"background"或"background.png"。要了解Xcode如何选择正确的文件，请参见[“为不同屏幕分辨率调整图像大小”](text00026.html#ch14lev1sec7)一节，[第213页](text00026.html#page_213)。请注意，变量名不必与图像名相同——你可以使用任何你喜欢的变量名。然而，图像名必须与项目中添加到资源目录的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们会创建一个SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-2977
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，表示屏幕的中心位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述了它在屏幕上的位置。frame有一个x位置，一个y位置，宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕frame的中间x位置，midY给出了中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-2978
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-2979
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-2980
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint，并将其赋值给精灵的位置属性，将我们的背景图像位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-2981
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。在处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以存储两个值，一个代表*x*，一个代表*y*，这使得在2D游戏中处理屏幕坐标时非常方便，因为所有物体的位置都是通过x和y坐标来确定的。
- en: '**NOTE**'
  id: totrans-2982
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-2983
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自* Core Graphics框架*，这是苹果公司用于图形处理的一个框架。你会在Swift中经常看到这种命名系统——类或结构体的前两个或三个字母通常会告诉你该对象的用途或来源。例如，所有SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-2984
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数 addChild(_:) 将背景图像添加到场景中。这个精灵现在是场景的*子节点*，这意味着它附加在这个场景上。例如，如果场景发生变化，大小缩放或消失，这个子精灵也会发生变化。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵都作为该场景的子节点或作为另一个精灵的子节点添加。每次添加精灵时，重要的是要考虑这个精灵的父节点应该是什么。例如，滑板精灵是场景的子节点，但如果我们想给滑板手加上一顶可以更换的帽子，我们会使用一个帽子精灵，它是滑板精灵的子节点。这样，每当滑板手跳跃时，帽子就会留在滑板手身上，我们也不必单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-2985
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏如何进行：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-2986
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个能够同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后只选择其中一种。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（即设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-2987
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-2988
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏方向下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-2989
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，你会注意到它可能默认是竖屏模式。让我们更改项目设置，使游戏只在横屏模式下运行。打开项目导航器，点击 **SchoolhouseSkateboarder**
    项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如你在[图 14-9](text00026.html#ch14fig9)中看到的那样。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-2990
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-2991
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-2992
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-2993
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-2994
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中竖屏选项，保留两个横屏方向选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-2995
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到项目和目标的列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。这个列表会出现，图标会变成蓝色，表示列表区域已经显示出来。确保选择了
    **SchoolhouseSkateboarder** 目标。现在找到 **竖屏** 复选框并取消勾选。保留横屏方向选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-2996
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们越来越接近目标，但背景图像仍然没有填满屏幕。稍后我们将看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-2997
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器菜单中选择 **硬件** ▸ **向右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-2998
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-2999
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-3000
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-3001
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你就需要处理不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。与像我们生日追踪器这样的基于
    UIKit 的应用程序相比，游戏在这方面通常需要更多的工作，因为如果你只是简单地放大或缩小，游戏的艺术作品会显得拉伸。为了避免这个问题，你必须为每个想要支持的设备使用不同的图片集。
- en: '![](Image00285.jpg)'
  id: totrans-3002
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-3003
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一种系统来命名图片文件，帮助你区分不同设备使用的图片。例如，假设你想为游戏添加一张滑板图片，并且你有一个宽 100 像素，高 100 像素（100×100）的滑板图片文件，你会将该图片命名为
    *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)*，尺寸为 200×200 像素的图片，再创建一张命名为
    *[skater@3x.png](mailto:skater@3x.png)*，尺寸为 300×300 像素的图片。这三张图片应该是同一张图片的三种不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需要引用文件名
    skater ，只要你在项目中正确命名了图片，Xcode 就会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-3004
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》游戏，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-3005
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-3006
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，例如* @2x *或* @3x*。没有后缀的图片，例如* skater.png*，被认为是 1x 图片。你只需要为那些没有视网膜显示屏的旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 大小的图片。因此，我们所有的图片文件都会带有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-3007
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图片分组在一起。如果你同时将图片拖入 Xcode 资源目录，Xcode 会自动识别它们是同一张图片的不同大小，并将它们分组在一起，这是由于它们的命名方式。参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-3008
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-3009
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：多种尺寸的图片在资源目录中分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-3010
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还有最后一件准备工作要做。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为 Game 模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置来决定。我们在这个项目中不会使用场景编辑器，所以我们需要添加代码，以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-3011
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-3012
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-3013
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-3014
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE123]'
  id: totrans-3015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-3016
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()` 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-3017
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图片现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3018
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-3019
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了 SpriteKit。你学会了如何在 Xcode 中创建一个游戏项目并将资源（例如图片）导入项目。你还了解了如何通过标准的文件命名规则支持各种设备的屏幕分辨率，以及如何选择游戏中需要的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个带有所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-3021
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '**ADDING IMAGES**'
  id: totrans-3022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**添加图片**'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图片添加到你的项目中作为资源。（资源就是你游戏中的某个元素，比如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-3024
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载 ZIP 文件。下载完成后，你将在 *Downloads* 文件夹中找到一个名为 *ch14-images* 的文件夹，里面包含了你所需的所有图片文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-3025
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到项目中，你需要从Finder中将它们拖入Xcode，并将其放入资源目录中。（资源目录是Xcode项目中的一种特殊文件夹，用于存放和组织项目资源，例如图像文件和图标。）它对图像非常有帮助，因为它将相关的图像文件分组在一起。一旦文件被放入资源目录中，你可以通过引用文件名在代码中任何地方使用它们。我们使用的游戏模板已经包含了一个资源目录，名为*Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-3026
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-3027
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*，你应该会看到现有的资源，包括AppIcon和飞船图像。你可以删除飞船图像，因为我们不会使用它。点击它然后按DELETE键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-3028
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，导航到图像文件下载的文件夹。按⌘-A选择所有文件。一旦它们被高亮显示，将它们拖动到Xcode资源目录中，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-3029
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-3030
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图像文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-3031
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到所有图像文件都是*.png*文件。*PNG*代表*可移植网络图形*，它是iOS应用中最常用的图像文件类型，因为它提供了最小的文件大小和最佳的图像质量。你也可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-3032
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-3033
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，让我们编写一些代码，在应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-3034
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建一个新项目时，一些有用的代码会自动添加到你的项目中。在项目导航器中点击名为*GameScene.swift*的文件，你应该会看到已经存在的一堆代码。这段代码有两个目的。首先，它向你展示了如何创建一个形状（旋转的盒子）以及如何执行一个动作（让盒子旋转）。其次，它让你可以立即运行新项目，并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-3035
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们将删除大部分代码并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-3036
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE124]'
  id: totrans-3037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-3038
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏的大部分逻辑将位于GameScene类中。可以将场景视为应用中的一个视图或屏幕。GameScene类将管理场景中发生的所有事情——如何显示精灵，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能有许多独立的场景，例如标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-3039
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（执行一次的操作）、游戏循环或更新函数（在游戏中不断执行的操作），以及用户交互函数（仅当用户点击或滑动时执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-3040
  prefs: []
  type: TYPE_NORMAL
  zh: '`didMove(to:)`设置函数在游戏开始时调用。它非常适合用来设置场景的代码，比如添加初始精灵或设置玩家的得分和生命值。它类似于你在[第10章](text00021.html#ch10)中使用的`viewDidLoad()`方法，用来设置`AddBirthdayViewController`中的日期选择器，并且它只会调用一次。'
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-3041
  prefs: []
  type: TYPE_NORMAL
  zh: 在将背景图片添加到场景之前，我们必须设置场景的`anchorPoint`。在`didMove(to:)`方法中添加这行代码（灰色的行表示已有代码，仅用于位置参考）：
- en: '[PRE125]'
  id: totrans-3042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '![](Image00276.jpg)'
  id: totrans-3043
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-3044
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用图钉把一张纸钉在软木板上时，图钉就是锚点。纸张将定位在你放置图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是`anchorPoint`属性在SpriteKit中与精灵和场景的工作方式。游戏模板中的GameScene的锚点在场景的中央，但我们希望锚点位于场景的左下角，因此我们将其设置为CGPoint.zero，或(0,
    0)。对于一些游戏，比如太空射击游戏，最好将锚点设置在场景的中央。但对于我们的游戏，地面位于屏幕底部，将锚点移到左下角将更容易操作。有关不同锚点位置的示意图，请参见[图14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-3045
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-3046
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-3047
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x位置为0时，它将位于屏幕的左边缘。而当我们将精灵放置在y位置为0时，它将位于屏幕的下边缘。
- en: '**NOTE**'
  id: totrans-3048
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-3049
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建每个代码文件，最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-3050
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-3051
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置精灵的锚点，从而改变精灵的定位方式和旋转方式。有关使用不同锚点旋转精灵的示例，请参见[图14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-3052
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-3053
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-3054
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常会将其锚点放在中心。我们不会更改任何精灵的锚点，因此我们将始终使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-3055
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图片，在`didMove(to:)`函数中添加以下代码行：
- en: '[PRE126]'
  id: totrans-3056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-3057
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看我们刚刚添加的五行代码。第 ➊ 行创建了一个名为 background 的精灵，使用* [background@2x.png](mailto:background@2x.png)*
    文件或* [background@3x.png](mailto:background@3x.png)* 文件。两个文件都已添加到资源目录中，Xcode 会自动选择正确的文件。你只需在代码中引用它，写作
    "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参阅 “[不同屏幕分辨率下的图片大小调整](text00026.html#ch14lev1sec7)”
    [第 213 页](text00026.html#page_213)。请注意，变量名不需要与图片名相匹配——你可以为变量名选择任何你喜欢的名称。然而，图片名必须与项目中资源目录中添加的文件名匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们会创建一个 SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-3058
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➋ 和 ➌ 行创建了常量 xMid 和 yMid，它们将表示屏幕的中间位置。frame 是 GameScene 的一个属性，它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它们在屏幕上的位置。框架包含
    x 位置、y 位置、宽度和高度（参见 [图 14-7](text00026.html#ch14fig7)）。midX 属性提供了屏幕框架的中间 x 位置，而
    midY 则提供了屏幕框架的中间 y 位置。
- en: '![](Image00279.jpg)'
  id: totrans-3059
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-3060
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-3061
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➍ 行通过创建一个使用 xMid 和 yMid 的 CGPoint 并将其赋值给精灵的 position 属性，设置了背景图片的位置，使其处于屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-3062
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，表示 x 和 y 坐标。在处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是 Float
    或 Double。一个 CGPoint 可以包含两个值，一个是 *x*，另一个是 *y*，这使得在 2D 游戏中处理屏幕坐标时非常方便，因为所有的位置都需要用到
    x 和 y 坐标。
- en: '**NOTE**'
  id: totrans-3063
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-3064
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自于* Core Graphics framework*，这是一个用于图形的苹果框架。你会在 Swift 中经常看到这种命名系统——一个类或结构体的前两到三个字母通常会告诉你这个对象的用途或来源。例如，所有的
    SpriteKit 类，比如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-3065
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它与场景绑定在一起。例如，如果场景变大、变小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，所有精灵都作为该场景的子对象或另一个精灵的子对象被添加。每当你添加一个精灵时，重要的是要思考该精灵的父对象应该是什么。例如，滑板者精灵是场景的子对象，但如果我们想要在滑板者上添加可互换的帽子，我们会使用帽子精灵，作为滑板者精灵的子对象。这样，每当滑板者跳跃时，帽子就会跟着滑板者，不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-3066
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-3067
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（即设备侧放，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-3068
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-3069
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏模式下的效果对比*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-3070
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用iPhone 7模拟器，你会注意到它可能默认是竖屏模式。让我们更改项目设置，让游戏仅以横屏模式运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目—它在项目导航器的顶部，并有一个蓝色图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-3071
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-3072
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-3073
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-3074
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-3075
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中竖屏选项，保留两个横屏方向选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-3076
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到项目和目标列表，可以点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。列表会出现，图标会变蓝，表示该列表区域现在正在显示。确保**SchoolhouseSkateboarder**目标被选中。现在找到**Portrait**复选框，并取消选中它。保持横屏方向选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-3077
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们离目标越来越近，但背景图像还没有填满屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-3078
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏以横屏模式运行，你还需要确保模拟器也处于横屏模式。要旋转它，请在模拟器菜单中选择**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-3079
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-3080
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-3081
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-3082
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理更多的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源在每个设备上都能正确显示。与基于
    UIKit 的应用程序（如我们的生日追踪器）相比，游戏通常在这方面需要更多的工作，因为如果你只是将艺术资源进行简单的放大或缩小，游戏的艺术图像会显得拉伸变形。为了避免这个问题，你需要为每个想要支持的设备准备不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-3083
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-3084
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个命名图像文件的系统，可以帮助你区分哪些图像适用于哪些设备。例如，假设你想要在游戏中添加一个滑板运动员的图像，并且你有一个宽度和高度都为
    100 像素（100×100）的滑板运动员图像文件。你会将该图像命名为 *skater.png*。你还需要创建一个命名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，它的尺寸为 200×200 像素，另一个命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，尺寸为 300×300
    像素。这三张文件应该是同一张图像的三种不同大小。如果游戏在 iPhone 4 上运行，系统会自动使用 *@2x* 文件，得益于便捷的 *@2x* 后缀。如果游戏在
    iPhone 6 Plus 上运行，则会自动使用 *@3x* 文件。在你的代码中，你只需要引用图像文件名 skater，Xcode 会根据你项目中正确命名的图像显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-3085
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持 iPhone 4 及以后的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-3086
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-3087
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被认为是 1x 图像。你只需要为那些没有视网膜显示屏的旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 大小的图像。因此，我们所有的图像文件都会有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-3088
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图像分组在一起。如果你同时将不同尺寸的图像拖入 Xcode 的资源目录，Xcode
    会自动识别它们是同一图像的不同大小，并将它们分组在一起，这是因为它们的命名方式。请参见 [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-3089
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-3090
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-3091
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理背景图片之前，还有最后一点准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片没有填满整个屏幕，如
    [图 14-13](text00026.html#ch14fig13) 所示。这是因为 Game 模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置来确定。由于我们在本项目中不会使用场景编辑器，所以我们需要添加代码来确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-3092
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-3093
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-3094
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-3095
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE127]'
  id: totrans-3096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-3097
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()` 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了显示的视图的大小（宽度和高度），并设置新场景的大小，使其填充整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-3098
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在，背景图片应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3099
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-3100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作 Schoolhouse Skateboarder 游戏，并学习了 SpriteKit。你学习了如何在 Xcode 中创建一个游戏项目并将图像等资源导入项目中。你还了解了如何通过标准的文件命名惯例支持各种设备屏幕分辨率，并且学会了如何选择游戏中需要的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-3101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作代码。在 [第 15 章](text00027.html#ch15)
    中，我们将添加我们的英雄角色和她滑行的地面，让所有物体开始移动，并让玩家点击屏幕使她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-3102
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  id: totrans-3103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将所有图像作为资源添加到项目中。（资源就是游戏中的元素，如精灵或音效。）
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-3104
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载 ZIP 文件。下载完成后，你将在 *Downloads* 文件夹内看到一个名为 *ch14-images* 的文件夹，里面包含了所有你需要的图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-3105
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到你的项目中，你需要从Finder中将它们拖入Xcode，并将它们放入资源目录中。（资源目录是Xcode项目中的一种特殊文件夹，用于存放和组织项目资源，如图像文件和图标。）它对于图像来说非常有用，因为它将相关的图像文件分组在一起。文件放入资源目录后，你可以通过引用文件名在代码中随时使用它们。我们使用的游戏模板已经自带了一个资源目录，名为*Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-3106
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-3107
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资源，AppIcon和飞船图像。你可以删除飞船图像，因为我们不会使用它。点击它，然后按DELETE键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-3108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，导航到图像文件下载的文件夹。按⌘-A选择所有文件。选中后，将它们拖入Xcode资源目录，如[图 14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-3109
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-3110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图像文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-3111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有的图像文件都是*.png*格式的。*PNG*代表*可移植网络图形*，它是iOS应用中最常用的图像文件类型，因为它具有最佳质量的同时文件大小最小。你也可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-3112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-3113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，接下来让我们编写一些代码，在应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-3114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建一个新项目时，一些有用的代码会自动添加到项目中。点击项目导航器中的*GameScene.swift*文件，你应该会看到里面已经有一堆代码。这些代码有两个目的。首先，它给了你一个如何创建形状（旋转的方块）和如何执行动作（让方块旋转）的示例。其次，它让你可以立即运行新项目，确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-3115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将删除大部分代码并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，最终代码应该是这样的：
- en: '*GameScene.swift*'
  id: totrans-3116
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE128]'
  id: totrans-3117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-3118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将位于GameScene类中。可以把场景看作是你应用中的一个视图或屏幕。GameScene类将管理场景中发生的所有事情——比如精灵如何显示，玩家如何与游戏互动，得分如何计算。复杂的游戏可能有多个独立的场景——例如标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-3119
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（只执行一次的操作）、游戏循环或更新函数（游戏过程中反复执行的操作），以及用户交互函数（仅在用户点击或滑动时执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-3120
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数didMove(to:)会在游戏首次启动时调用。它适用于设置场景的代码，例如添加初始精灵或设置玩家的分数和生命值。它类似于你在[第10章](text00021.html#ch10)的AddBirthdayViewController中用于设置日期选择器的viewDidLoad()方法，并且只调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-3121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图片添加到场景之前，我们必须设置场景的anchorPoint。请在didMove(to:)方法中添加这一行代码（灰色行表示现有代码的某些部分，用于放置）：
- en: '[PRE129]'
  id: totrans-3122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '![](Image00276.jpg)'
  id: totrans-3123
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-3124
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉将一张纸固定在软木板上时，图钉就是锚点。纸张会放置在你放置图钉的位置，如果纸张旋转，它会围绕图钉旋转。这正是anchorPoint属性在SpriteKit中如何与精灵和场景配合工作的方式。游戏模板的GameScene的锚点位于场景的中央，但我们希望将锚点设置在场景的左下角，因此我们将其设置为CGPoint.zero，或(0,
    0)。对于一些游戏，例如太空射击游戏，将锚点放置在场景中央会更好。但对于我们的游戏，由于地面位于屏幕底部，将锚点移到左下角会使操作更方便。请参见[图14-5](text00026.html#ch14fig5)，了解各种锚点的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-3125
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-3126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：从(0, 0)到(1, 1)的锚点位置示意图*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-3127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x位置为0时，它将位于屏幕的左边缘。而当我们将精灵放置在y位置为0时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-3128
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-3129
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-3130
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-3131
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。请参见[图14-6](text00026.html#ch14fig6)，其中展示了使用不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-3132
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-3133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-3134
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-3135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要加载我们的背景图片，请在didMove(to:)函数中添加以下代码行：
- en: '[PRE130]'
  id: totrans-3136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-3137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来逐行分析我们刚刚添加的五行代码。第➊行创建了一个名为 background 的精灵，使用 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已经添加到资源目录中，Xcode
    会自动选择合适的文件。你只需要在代码中引用它为 "background" 或 "background.png" 。要了解 Xcode 如何选择合适的文件，请参阅
    “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)” 在[第 213 页](text00026.html#page_213)。请注意，变量名不需要与图像名称匹配——你可以为变量名使用任何你想要的名称。然而，图像名称必须与项目中添加到资源目录的文件匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建一个精灵时，我们将创建一个 SKSpriteNode，如这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-3138
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋行和第➌行创建了常量 xMid 和 yMid，它们代表屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它们在屏幕上的位置。框架有一个
    x 位置、一个 y 位置、一个宽度和一个高度（参见[图 14-7](text00026.html#ch14fig7)）。midX 属性给我们屏幕框架的中间
    x 位置，midY 给我们屏幕框架的中间 y 位置。
- en: '![](Image00279.jpg)'
  id: totrans-3139
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-3140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-3141
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint，并将其赋值给精灵的位置属性，将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-3142
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 和 y 坐标。当你处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个 CGPoint 可以存储两个值，一个是 *x* ，另一个是 *y* ，这使得它在处理 2D 游戏中的屏幕坐标时非常方便，因为一切都通过
    x 和 y 的位置来定位。
- en: '**NOTE**'
  id: totrans-3143
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-3144
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自* Core Graphics framework*，这是一个用于图形的苹果框架。你会在 Swift 中经常看到这种命名系统——一个类或结构体的前两三个字母通常告诉你该对象的用途或来源。例如，所有的
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。 '
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-3145
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子节点*，这意味着它与场景绑定在一起。例如，如果场景发生变化，增大、缩小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都会作为场景的子节点或另一个精灵的子节点被添加。每次添加精灵时，考虑清楚这个精灵的父节点应该是什么很重要。例如，滑板精灵是场景的子节点，但如果我们想为滑板精灵添加可替换的帽子，我们会使用一个帽子精灵，作为滑板精灵的子节点。这样，每当滑板精灵跳跃时，帽子会保持在滑板精灵上，而我们不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-3146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏的操作方式：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-3147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此最好决定哪种方向最适合你的游戏，然后只选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，因此横屏方向（设备横置，正如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-3148
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-3149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏与横屏方向下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-3150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用iPhone 7模拟器，你会发现它可能会默认显示为竖屏。让我们更改项目设置，让游戏只在横屏下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，正如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-3151
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-3152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：点击项目条目访问项目设置，在项目导航器中查看。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-3153
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-3154
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-3155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消勾选竖屏选项，保留横屏方向的两个选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-3156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。这个列表会出现，图标会变蓝，表示列表区域现在已显示。确保选择了**SchoolhouseSkateboarder**目标。接下来找到**Portrait**复选框并取消勾选。保留横屏方向的选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-3157
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它已经在横屏方向启动了。我们越来越接近完成了，但背景图像还没有完全填充屏幕。稍后我们会讲解如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-3158
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在已在横屏方向运行，你需要确保模拟器也处于横屏方向。要旋转它，选择**Hardware** ▸ **Rotate Right**，正如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-3159
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-3160
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-3161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-3162
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解代码之前，我们应该先决定要支持哪些设备和屏幕分辨率。支持的设备越多，涉及到的屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的图像资源能够在每个设备上正确显示。与基于UIKit的应用（例如我们的生日追踪器）相比，游戏在这方面通常需要更多的努力，因为如果只是简单地将图像缩放，游戏中的艺术作品可能会显得被拉伸。为避免这种问题，你需要为每个想要支持的设备准备一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-3163
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-3164
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个命名图像文件的系统，帮助你区分不同设备的图像。例如，假设你想在游戏中添加一张滑板车手的图片，并且你有一张宽100像素、高100像素（100×100）的滑板车手图片文件，你会将该图片命名为*
    skater.png*。你还需要创建一张命名为*[skater@2x.png](mailto:skater@2x.png)*的图像，尺寸为200×200像素，以及另一张命名为*[skater@3x.png](mailto:skater@3x.png)*的图像，尺寸为300×300像素。这三张文件应该是同一张图片的三种不同尺寸。如果游戏运行在iPhone
    4上，带有*@2x*后缀的文件会自动被使用。如果游戏在iPhone 6 Plus上运行，则会自动使用带有*@3x*后缀的文件。在你的代码中，你只需要引用文件名为skater，Xcode会根据你在项目中正确命名的图像来显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-3165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-3166
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-3167
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，比如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被认为是1x图像。对于那些拥有非视网膜显示屏的旧设备，如iPhone
    3GS或第一代iPad mini，你只需要包含1x大小的图像。因此，我们所有的图像文件都会带有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-3168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资产目录，你会注意到Xcode将这两张图像归在了一起。如果你同时将多张图像拖入Xcode资产目录，Xcode会根据它们的命名自动识别它们是同一图像的不同尺寸，并将它们归在一起。见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-3169
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-3170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图像在资产目录中被归类在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-3171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从背景图像的处理步骤中继续之前，还有最后一些准备工作。你可能已经注意到，当使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为 Game 模板处理游戏场景大小的方式。游戏场景的大小将根据包含在我们项目中的
    *GameScene.sks* 场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码，确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-3172
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-3173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像未填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-3174
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-3175
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE131]'
  id: totrans-3176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-3177
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并将其显示出来。由于 GameScene 是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在此添加的代码确定了显示视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-3178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-3180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 Schoolhouse Skateboarder 游戏，并学习了 SpriteKit。你学习了如何在 Xcode 中创建一个游戏项目，并将资产（如图像）导入项目中。你还了解了如何通过标准的文件命名方法支持不同设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-3181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的主角和她滑行的地面，让一切开始运动，并允许玩家点击屏幕使她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-3182
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  id: totrans-3183
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    下载 ZIP 文件。下载完成后，你会在 *Downloads* 文件夹中看到一个名为 *ch14-images* 的文件夹，里面包含你所需的所有图像文件。
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-3184
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到你的项目中，你需要将它们从 Finder 拖动到 Xcode 中并将其放入资产目录中。（资产目录是 Xcode 项目中的一种特殊文件夹，用于存储和组织项目资源，如图像文件和图标。）它对图像文件非常有帮助，因为它将相关的图像文件分组在一起。一旦文件进入资产目录，你就可以通过引用文件名在代码中的任何地方使用它们。我们使用的
    Game 模板已经自带了一个名为 *Assets.xcassets* 的资产目录，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-3185
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-3186
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资源，如AppIcon和飞船图像。你可以删除飞船图像，因为我们不会使用它。点击它，然后按DELETE键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-3187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder并导航到下载图像文件的文件夹。按⌘ -A全选它们。一旦它们被选中，将它们拖到Xcode的资源目录中，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-3188
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-3189
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图像文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-3190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到所有的图像文件都是*.png*格式的。*PNG*代表*可移植网络图形*，它是iOS应用中最常用的图像文件类型，因为它在提供最佳质量图像的同时，文件大小最小。你可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-3191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-3192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图片添加到项目中，接下来我们编写一些代码来在应用中显示背景图片。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-3193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中名为*GameScene.swift*的文件。你应该能看到一大段已经存在的代码。这段代码存在有两个原因。首先，它给你提供了如何创建一个形状（旋转的盒子）以及如何执行一个动作（让盒子旋转）的示例。其次，它让你能够立即运行新项目并确保所有内容都已正确设置。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-3194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将删除大部分代码并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-3195
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE132]'
  id: totrans-3196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-3197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏的大部分逻辑将会在GameScene类中。可以将场景看作是应用中的一个视图或屏幕。GameScene类将管理场景中发生的一切——如何显示精灵，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能有多个独立的场景——例如标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-3198
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（执行一次的操作）、游戏循环或更新函数（在游戏过程中反复执行的操作），以及用户交互函数（只有在用户点击或滑动时才会执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-3199
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数didMove(to:)会在游戏开始时被调用。它非常适合用来编写设置场景的代码，例如添加初始精灵或设置玩家的分数和生命值。它类似于你在[第10章](text00021.html#ch10)中用于设置日期选择器的viewDidLoad()方法，并且只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-3200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，必须设置场景的锚点。将以下代码行添加到 didMove(to:) 方法中（灰色行表示一些现有代码，供参考）：
- en: '[PRE133]'
  id: totrans-3201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '![](Image00276.jpg)'
  id: totrans-3202
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-3203
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张会被定位在图钉所在的位置，如果纸张旋转，它会围绕图钉旋转。这正是锚点属性在
    SpriteKit 中与精灵和场景的作用方式。游戏模板中的 GameScene 将锚点设置在场景的中间，但我们希望锚点位于场景的左下角，因此我们将其设置为
    CGPoint.zero，或 (0, 0)。对于一些游戏，比如太空射击游戏，最好将锚点放在场景的中间。但对于我们的游戏，地面位于屏幕底部，将锚点移到左下角会更容易操作。有关不同锚点位置的示意图，请参见[图
    14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-3204
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-3205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点的不同位置，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-3206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 位置为 0 时，它将位于屏幕的左边缘。当我们将精灵放置在 y 位置为 0 时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-3207
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-3208
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步为项目构建每个代码文件。最终版本可以在* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-3209
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-3210
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。有关使用不同锚点旋转精灵的示例，请参见[图 14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-3211
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-3212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-3213
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用其中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-3214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要加载我们的背景图像，将以下代码行添加到 didMove(to:) 函数中：
- en: '[PRE134]'
  id: totrans-3215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-3216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看刚才添加的五行代码。➊ 处的代码创建了一个名为 `background` 的精灵，使用的是* [background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件早些时候已经添加到资产目录中，Xcode
    会自动选择合适的文件。你只需在代码中引用它为 "background" 或 "background.png"。要了解 Xcode 如何选择合适的文件，请参见
    “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)” 在 [第 213 页](text00026.html#page_213)。注意，变量名不必与图像名匹配——你可以自由选择变量名。然而，图像名称必须与项目中资产目录中添加的文件名匹配。`SKSpriteNode`
    是 `SpriteKit` 中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个 `SKSpriteNode`，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-3217
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 和 ➌ 处的代码创建了常量 `xMid` 和 `yMid`，它们将代表屏幕的中间位置。`frame` 是 `GameScene` 的一个属性——它是一个
    `CGRect`（矩形），代表整个屏幕。每个场景和精灵都有一个框架，描述了它在屏幕上的位置。框架有 x 位置、y 位置、宽度和高度（参见 [图 14-7](text00026.html#ch14fig7)）。`midX`
    属性提供了屏幕框架的中间 x 位置，而 `midY` 给出了屏幕的中间 y 位置。
- en: '![](Image00279.jpg)'
  id: totrans-3218
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-3219
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-3220
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ 处的代码通过使用 `xMid` 和 `yMid` 创建一个 `CGPoint`，并将其赋值给精灵的 `position` 属性，从而将我们的背景图像位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-3221
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGPoint` 是一个结构体，它包含两个 `CGFloat` 值，分别表示 x 和 y 坐标。当你处理屏幕坐标时，通常使用 `CGFloat` 作为数据类型，而不是
    `Float` 或 `Double`。一个 `CGPoint` 可以包含两个值，一个代表 *x*，另一个代表 *y*，这使得它在 2D 游戏中处理屏幕坐标变得非常方便，因为所有内容的位置都是通过
    x 和 y 坐标来确定的。'
- en: '**NOTE**'
  id: totrans-3222
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-3223
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的内容都来自* Core Graphics 框架*，这是一个苹果公司用于图形处理的框架。你会在 Swift 中经常看到这种命名方式——类或结构体的前两个或前三个字母通常告诉你这个对象的用途或来源。例如，所有的
    `SpriteKit` 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-3224
  prefs: []
  type: TYPE_NORMAL
  zh: ➎这一行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，这意味着它附加在这个场景上。例如，如果场景发生变化（如变大、变小或消失），这个子精灵也会发生相应变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都会作为场景的子对象或另一个精灵的子对象添加。每次添加精灵时，考虑这个精灵的父对象应该是什么非常重要。例如，滑板精灵是场景的子对象，但如果我们想给滑板精灵添加可更换的帽子，我们会使用一个帽子精灵，它是滑板精灵的子对象。这样，每当滑板精灵跳跃时，帽子就会留在滑板精灵身上，我们就不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-3225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-3226
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持纵屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合您的游戏，并仅选择这一种。由于我们的游戏是一个水平滚动的动作游戏，横屏模式（设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合理。
- en: '![](Image00280.jpg)'
  id: totrans-3227
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-3228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在纵屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-3229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，您会注意到它可能默认以纵屏模式启动。让我们更改项目设置，使游戏仅在横屏模式下运行。前往项目导航器，点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-3230
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-3231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-3232
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，您可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-3233
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-3234
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选纵屏选项，保持两个横屏方向选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-3235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有在屏幕上看到项目和目标的列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。这个列表会出现，图标会变成蓝色，表示列表区域现在正在显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**纵屏**复选框并取消勾选。保持横屏方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-3236
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，您会看到它以横屏模式启动。我们离目标更近了，但背景图像还没有填满整个屏幕。稍后我们将看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-3237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏现在以横屏模式运行，您需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **向右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-3238
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-3239
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-3240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-3241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源在每个设备上都能正确显示。与像我们的生日追踪器这样的
    UIKit 应用程序相比，游戏通常需要更多的工作，因为如果你只是简单地缩放图像，它会看起来被拉伸。因此，为了避免这个问题，你必须为每个你想支持的设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-3242
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-3243
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图像文件的系统，可以帮助你辨别哪些图像是用于哪些设备的。例如，假设你想在游戏中添加一张滑板车的图像，且你有一张 100 像素宽和
    100 像素高的滑板车图像文件（100×100）。你应该将该图像命名为 *skater.png* 。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，大小为 200×200 像素，再创建一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，大小为 300×300
    像素。这三张文件应为相同的图像，只是尺寸不同。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6
    Plus 上运行，则会自动使用带有 *@3x* 后缀的文件。在你的代码中，你只需引用文件名 skater ，只要你在项目中正确命名了图像，Xcode 就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-3244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《滑板学校》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750，和
    1920×1080。
- en: '**NOTE**'
  id: totrans-3245
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-3246
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被认为是 1x 图像。你只需要为那些具有非视网膜显示屏的旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 尺寸的图像。因此，我们所有的图像文件都将带有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-3247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*
    。如果你查看 *Assets.xcassets* 资产目录，你会注意到 Xcode 将这两张图像分组在一起。如果你同时将这些图像拖入 Xcode 资产目录，Xcode
    会自动识别它们是同一图像的不同尺寸，并将它们分组在一起，因为它们的命名方式。请参见 [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-3248
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-3249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：多个尺寸的图像在资产目录中分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-3250
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一点准备工作要做。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图像没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来决定。由于我们在本项目中不会使用场景编辑器，因此我们需要添加代码，以确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-3251
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-3252
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-3253
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航栏中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-3254
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE135]'
  id: totrans-3255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-3256
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了GameScene类的一个实例并将其显示出来。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示的视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-3257
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在，背景图像应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-3259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏并学习了SpriteKit。你学习了如何在Xcode中创建游戏项目并将资源（如图像）导入项目。你还学习了如何通过标准的文件命名实践来支持不同设备的屏幕分辨率，并了解了在游戏中选择所需图像类型的方法。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-3260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置好了SpriteKit游戏项目，并准备好了所需的资源，解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-3261
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  id: totrans-3262
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像文件添加到你的项目中，你需要将它们从Finder拖入Xcode，并将它们放入一个资源目录中。（资源目录是Xcode项目中的一种特殊类型文件夹，用于存放和组织项目资源，如图像文件和图标。）它对图像非常有用，因为它将相关的图像文件分组在一起。一旦文件进入资源目录，你就可以通过引用文件名在代码中随处使用它们。我们使用的游戏模板已经自带一个资源目录，名为*Assets.xcassets*，我们将使用这个目录。
- en: '![](Image00274.jpg)'
  id: totrans-3263
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-3264
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航栏中点击*Assets.xcassets*。你应该能看到现有的资源，包括AppIcon和飞船图像。你可以删除飞船图像，因为我们不会使用它。点击它，然后按DELETE。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-3265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder，导航到图像文件下载的文件夹。按 ⌘ -A 选择所有文件。选中后，将它们拖入 Xcode 的资源目录中，如[图 14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-3266
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-3267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图像文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-3268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到所有的图像文件都是 *.png* 格式的。*PNG* 代表 *可移植网络图形*，它是 iOS 应用中最常用的图像文件类型，因为它具有最佳质量的最小文件大小。你可以使用
    *.jpg* 文件，但推荐使用 *.png* 文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-3269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-3270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，接下来让我们编写一些代码，在我们的应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-3271
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Game 模板创建新项目时，系统会自动向你的项目中添加一些有用的代码。点击项目导航器中的 *GameScene.swift* 文件，你应该会看到一些已经存在的代码。这段代码有两个目的。首先，它向你展示如何创建一个形状（旋转的盒子）以及如何执行一个动作（让盒子旋转）。其次，它让你能够立即运行新项目，并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-3272
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，我们将删除大部分现有代码，并添加我们自己的代码。删除 *GameScene.swift* 文件中的所有内容，除了 didMove(to:)
    函数和 update(_:) 函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-3273
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE136]'
  id: totrans-3274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-3275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将集中在 GameScene 类中。可以将场景视为应用中的一个视图或屏幕。GameScene 类将管理场景中发生的一切——如何显示精灵，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能有多个独立的场景——例如标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-3276
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常包含设置函数（一次性执行的代码）、游戏循环或更新函数（在游戏过程中反复执行的代码）以及用户交互函数（仅在用户点击或滑动时执行的代码）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-3277
  prefs: []
  type: TYPE_NORMAL
  zh: setup 函数 didMove(to:) 会在游戏启动时被调用。它非常适合用来编写设置场景的代码，比如添加初始精灵或设置玩家的分数和生命。它类似于 [第
    10 章](text00021.html#ch10) 中用于设置 AddBirthdayViewController 的日期选择器的 viewDidLoad()
    方法，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-3278
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，必须设置场景的 anchorPoint。将这行代码添加到 didMove(to:) 方法中（灰色的行表示一些现有代码，仅供参考）：
- en: '[PRE137]'
  id: totrans-3279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '![](Image00276.jpg)'
  id: totrans-3280
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-3281
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉将一张纸钉到软木板上时，图钉就是锚点。纸张将定位在你放置图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是SpriteKit中anchorPoint属性如何与精灵和场景一起工作的方式。游戏模板中的GameScene将其锚点设置在场景的中央，但我们希望将锚点设置在场景的左下角，因此我们将其设置为CGPoint.zero，或者(0,
    0)。对于某些游戏，比如太空射击游戏，将锚点设置在场景的中央会更好。但对于我们的游戏来说，由于地面在屏幕底部，将锚点移到左下角将使得操作更加简便。请参见[图14-5](text00026.html#ch14fig5)了解各种锚点的位置示意。
- en: '![](Image00277.jpg)'
  id: totrans-3282
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-3283
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-3284
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x位置为0时，它将位于屏幕的左边缘。当我们将精灵放置在y位置为0时，它将位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-3285
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-3286
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个项目的代码文件。最终版本可从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-3287
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-3288
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。请参见[图14-6](text00026.html#ch14fig6)了解使用不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-3289
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-3290
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-3291
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-3292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，向didMove(to:)函数中添加以下几行代码：
- en: '[PRE138]'
  id: totrans-3293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-3294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解释一下我们刚刚添加的五行代码。➊行创建了一个名为background的精灵，使用的是* [background@2x.png](mailto:background@2x.png)
    *文件或* [background@3x.png](mailto:background@3x.png) *文件。两个文件之前已添加到资源目录中，Xcode会自动选择合适的文件。你只需要在代码中引用它，使用"background"或"background.png"即可。要了解Xcode如何选择正确的文件，请参见[“为不同屏幕分辨率调整图像大小”](text00026.html#ch14lev1sec7)在[第213页](text00026.html#page_213)的内容。请注意，变量名不必与图像名匹配——你可以为变量名使用任何你喜欢的名称。然而，图像名必须与项目中已添加到资源目录的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-3295
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，用来描述它在屏幕上的位置。框架包含x坐标、y坐标、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给我们提供了屏幕框架的中间x坐标，而midY属性给我们提供了屏幕框架的中间y坐标。
- en: '![](Image00279.jpg)'
  id: totrans-3296
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-3297
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-3298
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint，并将其赋值给精灵的位置属性，从而将背景图像的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-3299
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x坐标和y坐标。当处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个单一的CGPoint可以包含两个值，一个是*x*，一个是*y*，这使得在2D游戏中使用x和y坐标定位非常方便。
- en: '**NOTE**'
  id: totrans-3300
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-3301
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的内容都来自*Core Graphics框架*，这是苹果公司用于图形的框架。你会发现这种命名系统在Swift中非常常见——一个类或结构体的前两个或三个字母通常告诉你该对象的用途或来源。例如，所有SpriteKit类，如*SKSpriteNode*，都以*SK*开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-3302
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用addChild(_:)函数将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它附加在这个场景上。例如，如果场景发生变化（例如放大、缩小或消失），这个子精灵也会发生变化。在SpriteKit游戏中，场景始终是父对象，而每个精灵都会作为该场景的子对象或者作为另一个精灵的子对象添加进去。每当你添加一个精灵时，必须考虑该精灵的父对象应该是什么。例如，滑冰精灵是场景的子对象，但如果我们想为滑冰精灵添加可更换的帽子，我们可以使用一个帽子精灵，作为滑冰精灵的子对象。这样，当滑冰精灵跳跃时，帽子会保持在滑冰精灵的头上，我们就不必单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-3303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-3304
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时适用于竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择其中一种。由于我们的游戏是一个横向滚动的动作游戏，因此横屏方向（设备横置，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-3305
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-3306
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏方向下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-3307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能会默认竖屏显示。让我们修改项目设置，使游戏仅在横屏模式下运行。前往项目导航器并点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，正如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-3308
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-3309
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：点击项目导航器中的项目条目以访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-3310
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-3311
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-3312
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中Portrait选项，保留两个横屏方向选项选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-3313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此时列表会显示出来，图标会变蓝，表示列表区域现在已显示。确保选择了**SchoolhouseSkateboarder**目标。现在找到**Portrait**复选框并取消选中它。保持横屏模式选项已选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-3314
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它在横屏模式下启动。我们已经接近目标了，但背景图像还没有填满整个屏幕。稍后我们将看看如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-3315
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转模拟器，选择**硬件** ▸ **右旋**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-3316
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-3317
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-3318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-3319
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入代码之前，我们应该决定要支持哪些设备和屏幕分辨率。你支持的设备越多，你就需要处理不同的屏幕尺寸，这意味着你需要额外工作，确保你创建的艺术资源在每个设备上都能正确显示。与像我们的《生日跟踪器》这种基于
    UIKit 的应用相比，游戏在这方面通常需要更多的工作，因为如果你只是简单地放大或缩小，游戏的艺术作品会显得拉伸。为了避免这个问题，你必须为每个要支持的设备准备一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-3320
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-3321
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个系统用于命名图像文件，以帮助你识别图像适用于哪些设备。例如，假设你想在游戏中添加一个滑冰者的图像，并且你有一个宽100像素、高100像素（100×100）的滑冰者图像文件。你会将该图像命名为*skater.png*。你还需要创建一个命名为*[skater@2x.png](mailto:skater@2x.png)*的图像，大小为200×200像素，再创建另一个命名为*[skater@3x.png](mailto:skater@3x.png)*的图像，大小为300×300像素。这三张文件应该是相同图像的三种不同大小。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件会自动被使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件会自动被使用。在代码中，你只需要将图像文件名写为skater，只要你在项目中正确命名了图像，Xcode就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-3322
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-3323
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-3324
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被认为是1x图像。你只需要为老款设备（如iPhone
    3GS或第一代iPad mini）包含1x大小的图像，这些设备没有视网膜显示屏。因此，我们所有的图像文件都会有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-3325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图像分组在一起。如果你同时将不同大小的图像拖入Xcode资源目录，Xcode会根据它们的命名自动识别这些图像是同一图像的不同大小，并将它们分组在一起。请参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-3326
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-3327
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-3328
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理背景图像之前，我们还有一件事需要准备好。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在此项目中不使用场景编辑器，因此我们需要添加代码以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-3329
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-3330
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-3331
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-3332
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE139]'
  id: totrans-3333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-3334
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填充整个屏幕。我们在这里添加的代码决定了显示视图的大小（宽度和高度），并设置新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-3335
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-3337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作Schoolhouse Skateboarder游戏，并学习了SpriteKit。你学会了如何在Xcode中创建游戏项目并将资源（如图像）导入项目中。你还了解了如何通过标准文件命名实践支持各种设备屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-3338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来该编写一些动作程序了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00274.jpg)'
  id: totrans-3339
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00274.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-3340
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*Assets.xcassets*。你应该能看到现有的资产，如AppIcon和飞船图像。你可以删除飞船图像，因为我们不会使用它。点击它然后按DELETE删除。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-3341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder，导航到下载图片文件的文件夹。按⌘-A全选文件。选中后，将它们拖入Xcode的资产目录中，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-3342
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-3343
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图像文件添加到项目的资产目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-3344
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到所有的图片文件都是*.png*文件。*PNG*代表*便携式网络图形*，它是iOS应用中最常用的图像文件类型，因为它以最小的文件大小提供最佳质量的图像。你也可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-3345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-3346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已将所有图片添加到项目中，让我们编写一些代码在我们的应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-3347
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中的*GameScene.swift*文件。你应该看到已经存在的代码。这些代码有两个目的。首先，它给你一个示例，展示如何创建一个形状（旋转的盒子）以及如何执行一个动作（让盒子旋转）。其次，它让你可以立即运行一个新项目，确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-3348
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一步，我们将删除大部分代码并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-3349
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE140]'
  id: totrans-3350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-3351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑都将在GameScene类中。可以把场景看作是你应用中的一个视图或屏幕。GameScene类将管理场景内发生的一切——精灵应该如何显示，玩家如何与游戏互动，分数如何计算。复杂的游戏可能有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-3352
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一些只发生一次的操作）、游戏循环或更新函数（游戏过程中不断发生的操作）以及用户交互函数（只有当用户点击或滑动时才会发生的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-3353
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数didMove(to:)会在游戏启动时调用。它非常适合用来设置场景的代码，例如添加初始精灵或设置玩家的得分和生命数。它类似于你在[第10章](text00021.html#ch10)中用于设置AddBirthdayViewController中日期选择器的viewDidLoad()方法，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-3354
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图片添加到场景之前，必须设置场景的anchorPoint。将这行代码添加到didMove(to:)方法中（灰色的行表示一些现有代码，供参考）：
- en: '[PRE141]'
  id: totrans-3355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '![](Image00276.jpg)'
  id: totrans-3356
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-3357
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。就像你用图钉把一张纸钉在软木板上一样，图钉就是锚点。纸张将被放置在你放置图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是anchorPoint属性在SpriteKit中与精灵和场景配合工作的方式。Game模板的GameScene的锚点位于场景的中央，但我们希望将锚点设置在场景的左下角，因此我们将其设置为CGPoint.zero，即(0,
    0)。对于一些游戏，例如太空射击游戏，将锚点设置在场景中央会更好。但对于我们的游戏，因为地面位于屏幕底部，将锚点移到左下角会使得操作更方便。请参阅[图14-5](text00026.html#ch14fig5)，查看各种锚点位置的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-3358
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-3359
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：从(0, 0)到(1, 1)的各种锚点位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-3360
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x位置为0时，它将位于屏幕的左边缘。当我们将精灵放置在y位置为0时，它将位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-3361
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-3362
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步一步构建项目的每个代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获得。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-3363
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-3364
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式以及旋转方式。请参阅[图14-6](text00026.html#ch14fig6)来查看如何使用不同的锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-3365
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-3366
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-3367
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点放置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-3368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，请将以下代码行添加到didMove(to:)函数中：
- en: '[PRE142]'
  id: totrans-3369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-3370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看刚才添加的五行代码。第➊行创建了一个名为background的精灵，使用的是* [background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。两个文件都已提前添加到资产目录中，Xcode会自动选择正确的文件。你只需要在代码中引用它为“background”或“background.png”。要了解Xcode如何选择正确的文件，请参阅“[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”一节，见[第213页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以为变量名使用任何你想要的名称。然而，图像名必须与项目中资产目录中添加的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们实际上是在创建一个SKSpriteNode，就像我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-3371
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋行和第➌行创建了常量xMid和yMid，它们表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，用于描述它在屏幕上的位置。frame有一个x位置、一个y位置、一个宽度和一个高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕frame的中间x位置，midY给出了中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-3372
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-3373
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-3374
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过创建一个CGPoint，并使用xMid和yMid将其位置设置为屏幕的中央，然后将其分配给精灵的position属性，从而设置了背景图像的位置。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-3375
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，表示x和y坐标。在处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以包含两个值，一个表示*x*，一个表示*y*，这使得它在处理二维游戏中的屏幕坐标时非常方便，因为在二维游戏中，所有内容的位置都是通过x和y坐标来定位的。
- en: '**NOTE**'
  id: totrans-3376
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-3377
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的内容都来自* Core Graphics framework*，这是一个用于图形处理的苹果框架。你会在 Swift 中经常看到这种命名系统——类或结构体的前两到三个字母通常会告诉你该对象的用途或来源。例如，所有的
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-3378
  prefs: []
  type: TYPE_NORMAL
  zh: ➎这一行通过调用函数 addChild(_:) 将背景图像添加到场景中。这个精灵现在是场景的*子节点*，意味着它附加在这个场景上。例如，如果场景扩展、缩小或消失，这个子精灵也会如此。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵都作为该场景的子节点或作为另一个精灵的子节点添加。每当你添加一个精灵时，重要的是要考虑这个精灵的父对象应该是什么。例如，滑板精灵是场景的子节点，但如果我们想为滑板精灵添加可更换的帽子，我们会使用一个帽子精灵，它是滑板精灵的子节点。这样，每当滑板精灵跳跃时，帽子会保持在滑板精灵上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-3379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-3380
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后只选择那个方向。由于我们的游戏是一个水平滚动的动作游戏，横屏方向（设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）是最合适的。
- en: '![](Image00280.jpg)'
  id: totrans-3381
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-3382
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏与横屏方向下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-3383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行该项目，你会注意到它可能默认是竖屏方向。我们来更改项目设置，使游戏只能在横屏下运行。前往项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色的图标，正如你在[图
    14-9](text00026.html#ch14fig9)中看到的那样。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-3384
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-3385
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-3386
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-3387
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-3388
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中竖屏选项，同时保持两个横屏方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-3389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此时，列表会出现，图标会变成蓝色，表示列表区域现在已显示。确保**SchoolhouseSkateboarder**目标已选中。现在找到**Portrait**复选框并取消选中它。保持横屏方向的选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-3390
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经接近完成，但背景图片还没有完全填满屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-3391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转模拟器，请从模拟器的菜单中选择 **硬件** ▸ **向右旋转**，如 [图 14-11](text00026.html#ch14fig11)
    所示。
- en: '![](Image00284.jpg)'
  id: totrans-3392
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-3393
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-3394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-3395
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理的屏幕尺寸也越多，这意味着你需要额外的工作来确保你创建的艺术资源在每个设备上都能正确显示。与基于
    UIKit 的应用程序（如我们的生日跟踪器）相比，游戏在这方面通常需要更多的工作，因为如果你只是简单地缩放，游戏的艺术资源会显得拉伸变形。为了避免这个问题，你需要为每个你想支持的设备准备一组不同的图片资源。
- en: '![](Image00285.jpg)'
  id: totrans-3396
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-3397
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个系统来命名图片文件，帮助你识别哪些图片适用于哪些设备。例如，假设你想将一个滑板人物的图片添加到游戏中，且你有一张宽 100 像素、高
    100 像素（100×100）的滑板人物图片文件。你应该将这张图片命名为 *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图片，尺寸为 200×200 像素，以及一张名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为 300×300
    像素。这三张文件应该是同一张图片的三种不同大小。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6
    Plus 上运行，则会自动使用带有 *@3x* 后缀的文件。在你的代码中，你只需要引用文件名 skater ，只要你正确命名了项目中的图片，Xcode 会自动显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-3398
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-3399
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-3400
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片文件都有后缀，如* @2x *或* @3x*。没有后缀的图片文件，如* skater.png*，被视为 1x 图片。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini，这些设备没有视网膜显示屏）提供 1x 大小的图片。因此，我们所有的图片文件都会有* @2x *或* @3x
    *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-3401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名分别为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会发现
    Xcode 将这两张图片分到了一起。如果你同时将多个图像拖入 Xcode 资源目录，Xcode 会根据它们的命名自动识别它们是同一张图片的不同大小，并将它们分组。见[图
    14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-3402
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-3403
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-3404
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理背景图像之前，仍有最后一点准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，所以我们需要添加代码来确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-3405
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-3406
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-3407
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-3408
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE143]'
  id: totrans-3409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-3410
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-3411
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-3413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并了解了SpriteKit。你学会了如何在Xcode中创建游戏项目并将图像等资源导入项目中。你还学会了通过标准的文件命名惯例来支持各种设备屏幕分辨率，并了解了如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-3414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来该编写一些动作代码了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，让一切动起来，并让玩家通过点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-3415
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  id: totrans-3416
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*Assets.xcassets*。你应该能看到现有的资源，如应用图标和宇宙飞船图像。你可以删除宇宙飞船图像，因为我们不会使用它。点击它，然后按
    DELETE 键。
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-3417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开Finder并导航到下载图像文件的文件夹。按⌘ -A选择所有文件。一旦它们被高亮显示，拖动它们到Xcode的资源目录中，如[图14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-3418
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-3419
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图像文件添加到你的项目资源目录*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-3420
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有的图像文件都是*.png*文件。*PNG*代表*可移植网络图形*，它是iOS应用中最常用的图像文件类型，因为它在提供最佳图像质量的同时具有最小的文件大小。你也可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-3421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-3422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，接下来我们编写一些代码来在应用中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-3423
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建一个新项目时，某些有用的代码会自动添加到你的项目中。点击项目导航器中的*GameScene.swift*文件，你应该会看到已有一些代码。这些代码有两个目的。首先，它给你一个创建形状（旋转的盒子）和执行动作（让盒子旋转）的示例。其次，它让你可以立即运行一个新项目，确保所有内容都设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-3424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将删除大部分代码并添加我们自己的代码。请删除*GameScene.swift* 中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-3425
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE144]'
  id: totrans-3426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-3427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑都将在GameScene类中。可以将一个场景看作你应用中的一个视图或屏幕。GameScene类将管理场景中发生的所有事情——如何显示精灵，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-3428
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会包含设置函数（一次性执行的内容）、游戏循环或更新函数（在游戏过程中反复执行的内容）以及用户交互函数（仅在用户点击或滑动时执行的内容）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-3429
  prefs: []
  type: TYPE_NORMAL
  zh: didMove(to:) 设置函数在游戏首次启动时被调用。它非常适合用于设置场景的代码，比如添加初始精灵的代码，或者设置玩家的得分和生命值。这类似于你在[第10章](text00021.html#ch10)中用于设置AddBirthdayViewController中的日期选择器的viewDidLoad()方法，并且它只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-3430
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们必须设置场景的anchorPoint。将以下代码添加到didMove(to:)方法中（灰色行表示现有代码的位置）：
- en: '[PRE145]'
  id: totrans-3431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '![](Image00276.jpg)'
  id: totrans-3432
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-3433
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张将被定位在图钉的位置，并且如果纸张旋转，它将围绕图钉旋转。这正是
    SpriteKit 中的 anchorPoint 属性如何在精灵和场景中工作。游戏模板的 GameScene 将锚点设置在场景的中心，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero 或 (0, 0)。对于一些游戏，比如太空射击游戏，将锚点设置在场景的中心会更好。但对于我们的游戏，由于地面位于屏幕底部，将锚点移至左下角会更方便操作。有关各种锚点的说明，请参见[图
    14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-3434
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-3435
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：从 (0, 0) 到 (1, 1) 的不同锚点位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-3436
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 位置为 0 时，它将位于屏幕的左边缘。而当我们将精灵放置在 y 位置为 0 时，它将位于屏幕的下边缘。
- en: '**NOTE**'
  id: totrans-3437
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-3438
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步一步构建每个项目的代码文件。最终版本可从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-3439
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-3440
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置精灵的锚点，改变精灵的定位方式以及旋转方式。有关不同锚点旋转精灵的示例，请参见[图 14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-3441
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-3442
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-3443
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用精灵的中心点来定位它们。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-3444
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图片，请在 didMove(to:) 函数中添加以下代码行：
- en: '[PRE146]'
  id: totrans-3445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-3446
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看刚刚添加的五行代码。➊ 这一行创建了一个名为 background 的精灵，使用 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已经添加到资源目录中，Xcode
    会自动选择正确的文件。你只需在代码中引用它为 "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参阅
    “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)” 章节，见 [第 213 页](text00026.html#page_213)。请注意，变量名不必与图像名称匹配——你可以为变量名使用任何你喜欢的名称。然而，图像名称必须与项目中添加到资源目录的文件匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建一个精灵时，我们将创建一个 SKSpriteNode，就像这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-3447
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 和 ➌ 这两行创建了常量 xMid 和 yMid，它们将表示屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它在屏幕上的位置。一个框架有一个
    x 位置、一个 y 位置、一个宽度和一个高度（见 [图 14-7](text00026.html#ch14fig7)）。midX 属性给出屏幕框架的中间 x
    位置，midY 给出屏幕框架的中间 y 位置。
- en: '![](Image00279.jpg)'
  id: totrans-3448
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-3449
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-3450
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ 这行代码通过创建一个 CGPoint，使用 xMid 和 yMid 并将其赋值给精灵的位置属性，将背景图像的位置设置为屏幕的中心。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-3451
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 和 y 坐标。当处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个 CGPoint 可以容纳两个值，一个表示 *x*，一个表示 *y*，这使得它在处理二维游戏中的屏幕坐标时非常方便，因为游戏中的一切都是基于
    x 和 y 位置进行定位的。
- en: '**NOTE**'
  id: totrans-3452
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-3453
  prefs: []
  type: TYPE_NORMAL
  zh: '*以 CG 开头的任何东西都来自 Core Graphics 框架*，这是一个用于图形的苹果框架。你会经常看到这种命名方式，Swift 中的类或结构体的前两三个字母通常会告诉你这个对象是用来做什么的，或者它来自哪里。例如，所有
    SpriteKit 类，如 *SKSpriteNode*，都以 *SK* 开头。'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-3454
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 这行代码通过调用函数 addChild(_:) 将背景图像添加到场景中。这个精灵现在是场景的一个 *子节点*，这意味着它附属于这个场景。例如，如果场景发生变化（如扩大、缩小或消失），这个子精灵也会随之变化。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵都作为该场景的子对象或另一个精灵的子对象添加。每当你添加一个精灵时，重要的是要考虑这个精灵的父对象应该是谁。例如，滑雪者精灵是场景的子对象，但如果我们想为滑雪者添加可更换的帽子，我们将使用一个帽子精灵，它是滑雪者精灵的子对象。这样，每当滑雪者跳跃时，帽子会保持在滑雪者的头上，我们就不必单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-3455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏如何进行：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-3456
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个在竖屏和横屏模式下都能运行的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，然后只选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（设备侧放，如
    [图 14-8](text00026.html#ch14fig8) 所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-3457
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-3458
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏模式下的展示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-3459
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用iPhone 7模拟器，你会注意到它可能默认以竖屏方向启动。让我们更改项目设置，使游戏仅以横屏方向运行。转到项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如你在[图
    14-9](text00026.html#ch14fig9)中看到的那样。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-3460
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-3461
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-3462
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-3463
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-3464
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选Portrait选项，保持两个横屏方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-3465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此时，列表会出现，并且图标会变为蓝色，表示列表区域已经显示。确保选择了**SchoolhouseSkateboarder**目标。现在找到**Portrait**复选框并取消勾选。保持横屏方向选项为选中状态。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-3466
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们已经接近完成，但背景图片还没有填充整个屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-3467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经以横屏方向运行，你需要确保模拟器也处于横屏方向。要旋转模拟器，请从模拟器菜单中选择**Hardware** ▸ **Rotate Right**，如[图
    14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-3468
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-3469
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-3470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-3471
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理不同的屏幕尺寸，这意味着你需要额外工作来确保你创建的艺术资源能在每个设备上正确显示。与我们基于UIKit的应用程序（如生日追踪器）相比，游戏在这方面通常需要更多的工作，因为如果你只是简单地缩放图像，游戏的艺术资源会显得拉伸。为了避免这个问题，你需要为每个你想支持的设备使用不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-3472
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-3473
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个系统，用于命名图像文件，以帮助你区分哪些图像是针对哪些设备的。例如，假设你想要在游戏中添加一张滑冰者的图片，且你有一张宽 100 像素、高
    100 像素（100×100）的滑冰者图像文件。你应该将该图像命名为 *skater.png* 。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，尺寸为 200×200 像素，另需创建一张名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，尺寸为 300×300
    像素。这三张文件应该是同一张图像的三个不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将会自动使用。若游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件将会自动使用。在你的代码中，你只需要引用图像文件名 skater，只要你在项目中正确命名了图像，Xcode 将自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-3474
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-3475
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-3476
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被视为 1x 图像。你只需要为老旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 尺寸的图像，这些设备没有视网膜显示屏。因此，我们所有的图像文件将都带有* @2x *或* @3x
    *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-3477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*
    。如果你查看 *Assets.xcassets* 资源目录，你会注意到 Xcode 已将这两张图像分组在一起。如果你同时将图像拖放到 Xcode 资源目录中，Xcode
    会自动识别它们是同一张图像的不同尺寸，并根据命名规则将它们分组在一起。参见 [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-3478
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-3479
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-3480
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理背景图像之前，还有一项最后的准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像没有填满整个屏幕，如
    [图 14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板在处理游戏场景的大小时的方式。游戏场景的大小将根据我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置来确定。在这个项目中我们不会使用场景编辑器，因此我们需要添加代码以确保我们的场景大小合适。
- en: '![](Image00287.jpg)'
  id: totrans-3481
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-3482
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像未填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-3483
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，并找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-3484
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE147]'
  id: totrans-3485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-3486
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-3487
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图片应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-3489
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 Schoolhouse Skateboarder 游戏并学习了 SpriteKit。你学会了如何在 Xcode 中创建游戏项目并将资源（例如图片）导入到项目中。你还了解了通过标准的文件命名方式支持各种设备屏幕分辨率，以及如何选择游戏中需要的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-3490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切开始移动，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-3491
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  id: totrans-3492
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 Finder，导航到下载图片文件的文件夹。按 ⌘ -A 选择所有文件。一旦它们被高亮显示，拖动它们到 Xcode 资源目录中，如[图 14-4](text00026.html#ch14fig4)所示。
- en: '![](Image00275.jpg)'
  id: totrans-3493
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-3494
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图片文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-3495
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有的图片文件都是 *.png* 文件。*PNG* 代表 *可移植网络图形*，它是 iOS 应用中最常用的图片文件类型，因为它具有最小的文件大小和最佳的图像质量。你也可以使用
    *.jpg* 文件，但推荐使用 *.png* 文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-3496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图片**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-3497
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已将所有图片添加到项目中，让我们编写一些代码来在我们的应用中显示背景图片。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-3498
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建一个新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中名为 *GameScene.swift* 的文件。你应该会看到那里已经有一堆代码。这段代码有两个目的。首先，它给你一个创建形状（旋转盒子）并执行动作（让盒子旋转）的示例。其次，它让你可以立即运行新项目并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-3499
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，我们将删除大部分现有的代码并添加我们自己的代码。请删除 *GameScene.swift* 中的所有内容，除了 didMove(to:) 函数和
    update(_:) 函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-3500
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE148]'
  id: totrans-3501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-3502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将会在GameScene类中。可以将一个场景看作是你应用中的一个视图或屏幕。GameScene类将管理场景中发生的所有事情——例如精灵的显示方式、玩家如何与游戏互动以及如何进行计分。复杂的游戏可能会有多个独立的场景——例如标题场景、菜单场景、游戏场景和设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-3503
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（只执行一次的操作）、游戏循环或更新函数（在游戏过程中反复执行的操作）和用户交互函数（仅在用户点击或滑动时执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-3504
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的游戏首次启动时，setup函数didMove(to:)会被调用。它非常适合用于设置场景的代码，例如添加初始精灵或设置玩家的分数和生命值的代码。它类似于你在[第10章](text00021.html#ch10)中用来设置AddBirthdayViewController中的日期选择器的viewDidLoad()方法，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-3505
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向场景添加背景图像之前，我们必须先设置场景的锚点。将以下代码行添加到didMove(to:)方法中（灰色行表示一些现有代码，用于位置）：
- en: '[PRE149]'
  id: totrans-3506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '![](Image00276.jpg)'
  id: totrans-3507
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-3508
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉把一张纸固定在软木板上时，图钉就是锚点。纸张会被固定在你放置图钉的位置，如果纸张旋转，它会围绕图钉旋转。这正是SpriteKit中锚点属性与精灵和场景的工作原理。Game模板的GameScene的锚点位于场景的中心，但我们希望锚点位于场景的左下角，因此我们将其设置为CGPoint.zero，或(0,
    0)。对于某些游戏，例如太空射击游戏，最好将锚点设置在场景的中心。但对于我们的游戏，地面位于屏幕底部，将锚点移到左下角会更容易操作。请参见[图14-5](text00026.html#ch14fig5)查看不同锚点位置的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-3509
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-3510
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：从(0, 0)到(1, 1)的不同锚点位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-3511
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在x位置为0时，它将位于屏幕的左边缘。当我们将一个精灵放置在y位置为0时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-3512
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-3513
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-3514
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-3515
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变该精灵的定位方式和旋转方式。请参见[图14-6](text00026.html#ch14fig6)，了解如何使用不同的锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-3516
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-3517
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-3518
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心位置。我们不会改变任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-3519
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，在didMove(to:)函数中添加以下代码行：
- en: '[PRE150]'
  id: totrans-3520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-3521
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析刚刚添加的五行代码。➊处的代码创建了一个名为background的精灵，使用*背景@2x.png*文件或*背景@3x.png*文件。两个文件之前已被添加到资源目录中，Xcode会自动选择正确的文件。你只需在代码中引用它，命名为"background"或"background.png"。要了解Xcode如何选择正确的文件，请参阅“[为不同屏幕分辨率调整图像尺寸](text00026.html#ch14lev1sec7)”章节，[第213页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以为变量名选择任何你喜欢的名称。但是，图像名必须与添加到项目资源目录中的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此，当我们在游戏中创建精灵时，我们将创建一个SKSpriteNode，就像我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-3522
  prefs: []
  type: TYPE_NORMAL
  zh: ➋和➌处的代码创建了常量xMid和yMid，它们代表屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，用来描述它在屏幕上的位置。frame有一个x位置、y位置、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕frame的中间x位置，midY给出了屏幕frame的中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-3523
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-3524
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-3525
  prefs: []
  type: TYPE_NORMAL
  zh: ➎处的代码通过创建一个使用xMid和yMid的CGPoint，并将其赋值给精灵的position属性，来将背景图像的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-3526
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，表示x和y坐标。当处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以保存两个值，一个用于*x*，另一个用于*y*，这使得在2D游戏中处理屏幕坐标非常方便，因为所有内容都是通过x和y坐标来定位的。
- en: '**NOTE**'
  id: totrans-3527
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-3528
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自* Core Graphics框架*，这是一个用于图形的苹果框架。你会在Swift中经常看到这种命名系统——类或结构的前两三个字母通常会告诉你该对象的用途或来源。例如，所有的SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-3529
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图片添加到场景中。这个精灵现在是场景的*子节点*，这意味着它附加在这个场景上。例如，如果场景放大、缩小或消失，这个子节点精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，所有精灵都是作为场景的子节点或另一个精灵的子节点添加的。每当你添加一个精灵时，重要的是要考虑该精灵的父节点应该是什么。例如，滑板精灵是场景的子节点，但如果我们想为滑板精灵添加可更换的帽子，我们将使用帽子精灵，帽子精灵是滑板精灵的子节点。这样，每当滑板精灵跳跃时，帽子就会保持在滑板精灵上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-3530
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-3531
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持纵向和横向模式运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后选择那一个。由于我们的游戏是一个横向滚动的动作游戏，横向模式（设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-3532
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-3533
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在纵向和横向方向下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-3534
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行该项目，你会注意到它可能会默认进入纵向模式。让我们修改项目设置，使游戏只在横向模式下运行。转到项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-3535
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-3536
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目条目在项目导航器中访问项目设置*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-3537
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-3538
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-3539
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选“纵向”选项，同时保留两个“横向”方向选项的勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-3540
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到“项目”和“目标”列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。这个列表会出现，图标会变蓝，表示列表区域现在已显示。确保选中**SchoolhouseSkateboarder**目标。现在找到**纵向**复选框并取消勾选。保持横向方向选项被勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-3541
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们越来越接近目标，但背景图像还没有完全填充屏幕。稍后我们会看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-3542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转模拟器，从模拟器菜单中选择**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-3543
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-3544
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-3545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-3546
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源能在每个设备上正确显示。游戏在这方面通常比基于UIKit的应用程序（如我们的生日追踪器）需要更多的工作，因为如果你只是简单地放大或缩小，游戏的艺术作品会显得拉伸。为了避免这个问题，你必须为每个你想支持的设备使用一套不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-3547
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-3548
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个命名图片文件的系统，可以帮助你区分不同设备使用的图片。例如，假设你想在游戏中添加一个滑冰者的图像，且你有一个100像素宽、100像素高（100×100）的滑冰者图像文件。你可以将该图片命名为*skater.png*。你还需要创建一张命名为*[skater@2x.png](mailto:skater@2x.png)*的图片，尺寸为200×200像素，另外再创建一张命名为*[skater@3x.png](mailto:skater@3x.png)*的图片，尺寸为300×300像素。这三张文件应该是相同的图片，只是大小不同。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件会自动被使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件会自动被使用。在你的代码中，你只需要引用文件名skater，Xcode会根据你项目中正确命名的图片来显示相应的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-3549
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750，和1920×1080。
- en: '**NOTE**'
  id: totrans-3550
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-3551
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有后缀，如* @2x *或* @3x*。没有后缀的图片，例如*skater.png*，被认为是1x图像。你只需要为那些较旧的设备（例如iPhone
    3GS或第一代iPad mini，这些设备没有视网膜显示屏）包含1x大小的图片。因此，我们所有的图像文件都将有* @2x *或* @3x *的后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-3552
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图片分组在一起。如果你同时将不同尺寸的图片拖入 Xcode 资源目录，Xcode
    会根据它们的命名方式自动识别它们是同一张图片的不同尺寸，并将它们分组在一起。见 [图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-3553
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-3554
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：多尺寸的图像被分组在资源目录中。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-3555
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行背景图像之前，我们还有最后一步准备工作。你可能注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像没有填满整个屏幕，如 [图14-13](text00026.html#ch14fig13)
    所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将基于我们项目中包含的 *GameScene.sks* 场景编辑器文件中的设置。我们在这个项目中不会使用场景编辑器，所以我们需要添加代码，以确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-3556
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-3557
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-3558
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，并找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-3559
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE151]'
  id: totrans-3560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-3561
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并将其显示出来。由于 GameScene 是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了所显示视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-3562
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-3564
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 Schoolhouse Skateboarder 游戏，并学习了 SpriteKit。你学习了如何在 Xcode 中创建游戏项目并导入资源，如图片。你还了解了如何通过标准的文件命名惯例支持不同设备的屏幕分辨率，以及如何选择游戏中需要的图片类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-3565
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编程一些动作。在 [第15章](text00027.html#ch15)
    中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00275.jpg)'
  id: totrans-3566
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00275.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-3567
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：将图像文件添加到项目的资源目录*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-3568
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到所有的图像文件都是*.png*文件。*PNG*代表*便携式网络图形*，它是iOS应用程序中使用最广泛的图像文件类型，因为它具有最小的文件大小和最佳的图像质量。你也可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-3569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**背景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-3570
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，让我们写一些代码将背景图像显示在我们的应用中。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-3571
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建一个新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中名为*GameScene.swift*的文件，你应该能看到里面已经有一堆代码。这些代码有两个目的。首先，它给你展示了如何创建一个形状（旋转的方块）以及如何执行一个动作（让方块旋转）。其次，它让你能够立即运行新项目并确保一切配置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-3572
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个步骤，我们将删除大部分代码并添加我们自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，使它看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-3573
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE152]'
  id: totrans-3574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-3575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将在GameScene类中。可以把一个场景想象成你应用中的一个视图或屏幕。GameScene类将管理场景中发生的所有事情——如何显示精灵，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能会有许多独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-3576
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有初始化函数（只执行一次的操作）、游戏循环或更新函数（在游戏过程中反复执行的操作）以及用户交互函数（仅在用户点击或滑动时执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-3577
  prefs: []
  type: TYPE_NORMAL
  zh: didMove(to:)初始化函数会在你的游戏首次启动时调用。它非常适合用于设置场景的代码，例如添加初始精灵或设置玩家的分数和生命。它类似于你在[第10章](text00021.html#ch10)中用于设置AddBirthdayViewController中日期选择器的viewDidLoad()方法，并且它只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-3578
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为场景添加背景图像之前，必须先设置场景的anchorPoint。将这一行代码添加到didMove(to:)方法中（灰色行表示一些现有代码，用于放置）：
- en: '[PRE153]'
  id: totrans-3579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '![](Image00276.jpg)'
  id: totrans-3580
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-3581
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用图钉将一张纸固定在软木板上时，图钉就是锚点。纸张会根据你放置图钉的位置进行定位，如果纸张旋转，它会围绕图钉旋转。这正是SpriteKit中锚点属性在精灵和场景中的工作方式。游戏模板的GameScene将锚点设置在场景的中央，但我们希望锚点位于场景的左下角，因此我们将其设置为CGPoint.zero，即(0,
    0)。对于一些游戏，例如太空射击游戏，将锚点放在场景的中央可能更合适。但对于我们的游戏，地面位于屏幕底部，将锚点移动到左下角会让操作更方便。请参见[图14-5](text00026.html#ch14fig5)查看不同锚点位置的示例。
- en: '![](Image00277.jpg)'
  id: totrans-3582
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-3583
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-3584
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x位置为0时，它将位于屏幕的左边缘。而当我们将精灵放置在y位置为0时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-3585
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-3586
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建项目的每个代码文件。最终版本可从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-3587
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-3588
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。查看[图14-6](text00026.html#ch14fig6)，了解如何通过不同的锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-3589
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-3590
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-3591
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-3592
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，在didMove(to:)函数中添加以下代码行：
- en: '[PRE154]'
  id: totrans-3593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-3594
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起看一下我们刚刚添加的五行代码。➊这一行创建了一个名为background的精灵，使用的是* [background@2x.png](mailto:background@2x.png)*文件或*
    [background@3x.png](mailto:background@3x.png)*文件。这两个文件之前已添加到资源目录中，Xcode会自动选择正确的文件。你只需在代码中引用它为“background”或“background.png”即可。要了解Xcode如何选择正确的文件，请参阅“[为不同屏幕分辨率调整图片大小](text00026.html#ch14lev1sec7)”[第213页](text00026.html#page_213)。请注意，变量名不必与图片名匹配——你可以使用任何你喜欢的变量名。但图片名必须与项目中资源目录中添加的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-3595
  prefs: []
  type: TYPE_NORMAL
  zh: 线条 ➋ 和 ➌ 创建了常量 xMid 和 yMid，它们代表屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个
    frame，描述了它在屏幕上的位置。一个 frame 包含 x 坐标、y 坐标、宽度和高度（见[图 14-7](text00026.html#ch14fig7)）。midX
    属性给出屏幕框架的中间 x 坐标，而 midY 给出屏幕框架的中间 y 坐标。
- en: '![](Image00279.jpg)'
  id: totrans-3596
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-3597
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：frame 描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-3598
  prefs: []
  type: TYPE_NORMAL
  zh: 线条 ➍ 通过使用 xMid 和 yMid 创建一个 CGPoint，并将其分配给精灵的位置属性，从而将背景图像的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-3599
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 和 y 坐标。在处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个单独的 CGPoint 可以存储两个值，一个是 *x* 坐标，一个是 *y* 坐标，这使得它在处理 2D 游戏中的屏幕坐标时非常方便，因为游戏中的所有物体都使用
    x 和 y 坐标来定位。
- en: '**NOTE**'
  id: totrans-3600
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-3601
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自* Core Graphics 框架*，这是一个用于图形的苹果框架。你会注意到在 Swift 中这种命名系统的使用很普遍——类或结构体的前两三个字母通常能告诉你该对象的用途或来源。例如，所有
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-3602
  prefs: []
  type: TYPE_NORMAL
  zh: 线条 ➎ 通过调用函数 addChild(_:) 将背景图像添加到场景中。这个精灵现在是场景的*子节点*，这意味着它附属于这个场景。例如，如果场景发生变化（增大、缩小或消失），这个子精灵也会随之变化。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵都是该场景的子对象，或者是另一个精灵的子对象。每当你添加一个精灵时，重要的是要考虑该精灵的父节点应该是什么。例如，滑冰者精灵是场景的子节点，但如果我们想在滑冰者身上加上可更换的帽子，我们会使用一个帽子精灵，它是滑冰者精灵的子节点。这样，每当滑冰者跳跃时，帽子就会保持在滑冰者头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-3603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-3604
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个既能在竖屏又能在横屏模式下运行的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，然后只选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，所以横屏模式（设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-3605
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-3606
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-3607
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能默认以竖屏模式启动。让我们更改项目设置，使游戏仅在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-3608
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-3609
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-3610
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-3611
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-3612
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中竖屏选项，保留选中两个横屏方向选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-3613
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上没有看到项目和目标的列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此列表会出现，并且图标会变蓝，表示该列表区域现在被显示。确保选中了**SchoolhouseSkateboarder**目标。然后找到**竖屏**复选框并取消选中它。保留横屏方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-3614
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会发现它以横屏模式启动。我们离目标更近了，但背景图片还没有填满整个屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-3615
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已在横屏模式下运行，你需要确保模拟器也处于横屏模式。要旋转它，从模拟器的菜单中选择**硬件** ▸ **向右旋转**，正如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-3616
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-3617
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器的方向以匹配游戏的方向*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-3618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-3619
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你需要处理的屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的艺术资源在每个设备上都能正确显示。与基于
    UIKit 的应用程序（如我们的生日追踪器）相比，游戏在这一方面通常需要更多的努力，因为如果你只是简单地放大或缩小，游戏的艺术作品会显得拉伸变形。为了解决这个问题，你必须为每个想要支持的设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-3620
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-3621
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 为图片文件命名提供了一种系统，帮助你区分哪些图片适用于哪些设备。例如，假设你想要为游戏添加一张滑板选手的图片，且你有一张宽 100 像素，高
    100 像素（100×100）的图片文件，你会将该图片命名为 *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图片，尺寸为 200×200 像素，另外创建一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为 300×300
    像素。这三张图片应是同一张图片的不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的图片会自动被使用；如果游戏在 iPhone 6 Plus
    上运行，带有 *@3x* 后缀的图片会自动被使用。在你的代码中，你只需要引用文件名 skater，只要你正确命名了项目中的图片，Xcode 就会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-3622
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》游戏，我们将支持从iPhone 4及之后的设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-3623
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-3624
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，比如* @2x *或* @3x*。没有后缀的图片，比如* skater.png*，被认为是 1x 图片。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 尺寸的图片，因为这些设备没有视网膜显示屏。因此，我们所有的图片文件都会带有 *@2x* 或
    *@3x* 后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-3625
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件分别命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图片分组在一起。如果你同时将这两张不同大小的图片拖入 Xcode 资源目录，Xcode
    会自动识别它们是同一张图片的不同尺寸，并根据命名规则将它们分组在一起。参见 [图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-3626
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-3627
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图片在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-3628
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还有最后一项准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片没有填充整个屏幕，如
    [图14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板处理游戏场景尺寸的方式。游戏场景的大小会根据项目中包含的 *GameScene.sks*
    场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，所以我们需要添加代码来确保我们的场景尺寸正确。
- en: '![](Image00287.jpg)'
  id: totrans-3629
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-3630
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片没有填充整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-3631
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码行来设置场景的尺寸：
- en: '*GameViewController.swift*'
  id: totrans-3632
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE155]'
  id: totrans-3633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-3634
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，以便它填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-3635
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3636
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-3637
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 Schoolhouse Skateboarder 游戏，并学习了 SpriteKit。你学习了如何在 Xcode 中创建一个游戏项目，并将图像等资源导入到项目中。你还了解了如何通过标准的文件命名方法支持不同设备的屏幕分辨率，以及如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-3638
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在 [第15章](text00027.html#ch15)
    中，我们将添加我们的英雄和她滑行的地面，让一切开始运动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-3639
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  id: totrans-3640
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：将图像文件添加到项目的资源目录中*'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-3641
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到所有的图像文件都是 *.png* 格式的。*PNG* 代表 *便携式网络图形*，它是 iOS 应用中最常用的图像文件格式，因为它在保证最佳图像质量的同时，文件大小最小。你可以使用
    *.jpg* 文件，但推荐使用 *.png* 文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-3642
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-3643
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，接下来我们写一些代码来显示应用中的背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-3644
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Game 模板创建一个新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中的 *GameScene.swift* 文件，你应该能看到已经有一堆代码。这些代码有两个目的。首先，它给你展示了如何创建一个形状（旋转的盒子）以及如何执行一个动作（让盒子旋转）。其次，它让你可以立即运行一个新项目，确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-3645
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将删除大部分代码，并添加我们自己的代码。请删除 *GameScene.swift* 中的所有内容，除了 didMove(to:) 函数的声明和
    update(_:) 函数，这样它应该看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-3646
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE156]'
  id: totrans-3647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-3648
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将会在GameScene类中。可以把一个场景看作是你应用程序中的一个视图或屏幕。GameScene类将管理场景内发生的所有事情——精灵的显示方式、玩家如何与游戏互动以及如何进行计分。复杂的游戏可能有许多独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-3649
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（只执行一次的操作）、游戏循环或更新函数（在游戏中反复执行的操作）以及用户交互函数（只有在用户点击或滑动时才会执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-3650
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数didMove(to:)会在游戏启动时被调用。它非常适合用于设置场景的代码，比如添加初始精灵或设置玩家的分数和生命值的代码。这与你在[第10章](text00021.html#ch10)的AddBirthdayViewController中使用的viewDidLoad()方法类似，并且它只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-3651
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，必须设置场景的anchorPoint。将这行代码添加到didMove(to:)方法中（灰色的行表示现有代码的位置）：
- en: '[PRE157]'
  id: totrans-3652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '![](Image00276.jpg)'
  id: totrans-3653
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-3654
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位。当你用图钉把纸片钉在软木板上时，图钉就是锚点。纸片将会定位在你放置图钉的位置，如果纸片旋转，它会围绕图钉旋转。这与SpriteKit中精灵和场景的anchorPoint属性的工作原理完全一样。游戏模板中的GameScene的锚点位于场景的中间，但我们希望锚点位于场景的左下角，因此我们将其设置为CGPoint.zero，即(0,
    0)。对于某些游戏，比如太空射击游戏，最好将锚点放在场景的中间。但对于我们的游戏，因为地面位于屏幕的底部，将锚点移到左下角会更容易操作。有关各种锚点的示意图，请参见[图14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-3655
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-3656
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的各种位置，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-3657
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在x坐标为0的位置时，它将位于屏幕的左边缘。而当我们将一个精灵放置在y坐标为0的位置时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-3658
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-3659
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-3660
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-3661
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，从而改变精灵的位置和旋转方式。查看[图14-6](text00026.html#ch14fig6)，了解如何通过不同的锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-3662
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-3663
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-3664
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-3665
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要加载我们的背景图像，将以下代码添加到 didMove(to:) 函数中：
- en: '[PRE158]'
  id: totrans-3666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-3667
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行讲解刚刚添加的五行代码。➊ 行创建了一个名为 background 的精灵，使用 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。两个文件都已提前添加到资源目录中，Xcode
    会自动选择正确的文件。你只需在代码中将其引用为 "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参阅
    “[为不同屏幕分辨率调整图片大小](text00026.html#ch14lev1sec7)” 章节，[第213页](text00026.html#page_213)。请注意，变量名不需要与图像名匹配——你可以为变量名选择任何名称。然而，图像名必须与项目中资源目录中添加的文件名匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个 SKSpriteNode，如此处所示。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-3668
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 和 ➌ 行创建了常量 xMid 和 yMid，分别表示屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它在屏幕上的位置。框架有一个
    x 位置、一个 y 位置、一个宽度和一个高度（见[图14-7](text00026.html#ch14fig7)）。midX 属性给我们屏幕框架的中间 x
    位置，midY 属性给我们屏幕框架的中间 y 位置。
- en: '![](Image00279.jpg)'
  id: totrans-3669
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-3670
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-3671
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ 行通过使用 xMid 和 yMid 创建一个 CGPoint，并将其赋值给精灵的位置属性，从而将我们的背景图像定位到屏幕中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-3672
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 和 y 坐标。当你处理屏幕坐标时，通常使用 CGFloat 数据类型，而不是
    Float 或 Double。一个 CGPoint 可以保存两个值，一个用于 *x*，一个用于 *y*，这使得它在处理 2D 游戏中的屏幕坐标时非常方便，在这种游戏中，一切都使用
    x 和 y 坐标来定位。
- en: '**NOTE**'
  id: totrans-3673
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-3674
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的内容都来自* Core Graphics框架*，这是一个用于图形处理的Apple框架。在Swift中，你会经常看到这种命名系统——一个类或结构的前两个或三个字母通常会告诉你这个对象的用途或来源。例如，所有的SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-3675
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它附属于这个场景。例如，如果场景发生增长、缩小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都是该场景或另一个精灵的子对象。每当你添加一个精灵时，重要的是要考虑它的父对象应该是什么。例如，溜冰精灵是场景的子对象，但如果我们想给溜冰精灵添加可以更换的帽子，我们会使用一个帽子精灵，并将其设置为溜冰精灵的子对象。这样，每当溜冰精灵跳跃时，帽子会保持在溜冰精灵头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-3676
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-3677
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个既能在竖屏又能在横屏模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择其中一种。由于我们的游戏是一个横向滚动的动作游戏，横屏方向（设备侧放，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-3678
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-3679
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏与横屏方向下的表现*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-3680
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用iPhone 7模拟器，你会发现它可能会默认进入竖屏模式。让我们更改项目设置，使游戏仅在横屏模式下运行。进入项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-3681
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-3682
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-3683
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-3684
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-3685
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中竖屏选项，保持勾选横屏方向的两个选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-3686
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在屏幕上看到项目和目标的列表，点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此时，列表将显示出来，并且图标会变成蓝色，表示列表区域现在正在显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**Portrait**复选框并取消选中。保持横屏方向的选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-3687
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，您会看到它以横屏模式启动。我们越来越接近目标了，但背景图像还没有完全填充屏幕。稍后我们将看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-3688
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏现在以横屏模式运行，您需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **右旋**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-3689
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-3690
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-3691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-3692
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，应该决定支持哪些设备和屏幕分辨率。支持的设备越多，您就需要处理不同的屏幕大小，这意味着您需要额外的工作来确保您创建的艺术资源在每个设备上都能正确显示。与像我们的生日追踪器这样的UIKit应用相比，游戏在这一领域需要更多的工作，因为如果只是简单地缩放，游戏艺术作品可能会看起来拉伸变形。为了避免这个问题，您需要为每个您想要支持的设备准备一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-3693
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-3694
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个图像文件命名系统，可以帮助您区分哪些图像适用于哪些设备。例如，假设您想在游戏中添加一个滑板车图像，并且您有一个100像素宽、100像素高（100×100）的滑板车图像文件。您会将该图像命名为*skater.png*。您还需要创建一个名为*[skater@2x.png](mailto:skater@2x.png)*的图像，尺寸为200×200像素，以及另一个名为*[skater@3x.png](mailto:skater@3x.png)*的图像，尺寸为300×300像素。这三个文件应该是相同的图像，只有大小不同。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件将自动被使用。如果游戏在iPhone 6 Plus上运行，则会自动使用带有*@3x*后缀的文件。在代码中，您只需引用文件名skater，只要您在项目中正确命名了图像，Xcode将显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-3695
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《学校滑板车手》，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-3696
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-3697
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被视为1x图像。您只需要为旧设备提供1x大小的图像，这些设备没有视网膜显示屏，例如iPhone
    3GS或第一代iPad mini。因此，我们所有的图像文件都会有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-3698
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件分别命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会发现Xcode把这两张图片分组在一起。如果你同时将多张图片拖入Xcode的资源目录，Xcode会根据它们的命名自动识别它们是同一张图片的不同尺寸，并将它们分组在一起。请参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-3699
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-3700
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图片在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-3701
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从背景图片的设置中继续之前，还有最后一部分准备工作需要处理。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图片并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板在设置游戏场景大小时的处理方式。游戏场景的大小将基于我们项目中包含的*GameScene.sks*场景编辑器文件中的设置进行调整。由于我们在这个项目中不会使用场景编辑器，因此我们需要添加代码，确保我们的场景尺寸正确。
- en: '![](Image00287.jpg)'
  id: totrans-3702
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-3703
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-3704
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-3705
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE159]'
  id: totrans-3706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-3707
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，以使它填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-3708
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图片应该会填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-3710
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏并学习了SpriteKit。你学习了如何在Xcode中创建游戏项目并导入资源，比如图片。你还学习了如何通过标准文件命名惯例支持各种设备屏幕分辨率，以及如何选择游戏中需要的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-3711
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作代码。我们将在[第15章](text00027.html#ch15)中，添加我们的英雄角色和她滑行的地面，让所有物体移动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-3712
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  id: totrans-3713
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，所有的图像文件都是*.png*格式的。*PNG*代表*便携式网络图形*，它是iOS应用程序中最常用的图像文件类型，因为它以最小的文件大小提供最佳的图像质量。你可以使用*.jpg*文件，但推荐使用*.png*文件。
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-3714
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-3715
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有的图像添加到项目中，让我们写一些代码来显示应用中的背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-3716
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建新项目时，一些有用的代码会自动添加到项目中。点击项目导航器中的*GameScene.swift*文件，你应该可以看到已有的一些代码。这些代码存在有两个原因。首先，它给你一个如何创建形状（旋转的方块）和如何执行动作（让方块旋转）的示例。其次，它让你能够立即运行一个新项目，确保所有内容都已正确设置。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-3717
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将删除大部分代码并添加我们自己的代码。去掉*GameScene.swift*中的所有内容，除了`didMove(to:)`函数的声明和`update(_:)`函数，代码应该变成这样：
- en: '*GameScene.swift*'
  id: totrans-3718
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE160]'
  id: totrans-3719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-3720
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏的大部分逻辑都将在GameScene类中实现。可以把场景看作你应用中的一个视图或屏幕。GameScene类将管理场景内发生的所有事情——精灵的显示方式，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能有多个独立的场景——例如标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-3721
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（只执行一次的操作），游戏循环或更新函数（在游戏过程中反复执行的操作），以及用户交互函数（只有在用户点击或滑动时才会执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-3722
  prefs: []
  type: TYPE_NORMAL
  zh: setup函数`didMove(to:)`在游戏开始时被调用。它非常适合用于设置场景的代码，例如添加初始精灵或设置玩家的分数和生命值的代码。它类似于你在[第10章](text00021.html#ch10)中用于设置AddBirthdayViewController中日期选择器的viewDidLoad()方法，并且只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-3723
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们需要设置场景的anchorPoint。将这一行代码添加到`didMove(to:)`方法中（灰色的行表示一些已有的代码，方便定位）：
- en: '[PRE161]'
  id: totrans-3724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '![](Image00276.jpg)'
  id: totrans-3725
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-3726
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张会放置在图钉的位置，并且如果纸张旋转，它将围绕图钉旋转。这正是`anchorPoint`属性在SpriteKit中与精灵和场景的工作原理。游戏模板中的GameScene的锚点位于场景的中央，但我们希望锚点位于场景的左下角，因此我们将其设置为CGPoint.zero，或者(0,
    0)。对于一些游戏，例如太空射击游戏，最好将锚点设置在场景的中央。但对于我们的游戏来说，地面位于屏幕底部，将锚点移到左下角会使工作更加方便。请参见[图14-5](text00026.html#ch14fig5)，了解各种锚点位置的示例。
- en: '![](Image00277.jpg)'
  id: totrans-3727
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-3728
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-3729
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在x位置为0时，它将位于屏幕的左边缘。当我们将精灵放置在y位置为0时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-3730
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-3731
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步一步构建每个代码文件。最终版本可以在* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获得。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-3732
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-3733
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。请参见[图14-6](text00026.html#ch14fig6)，了解使用不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-3734
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-3735
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-3736
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将它们的锚点放置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用精灵的中心点来定位它们。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-3737
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，将以下代码行添加到`didMove(to:)`函数中：
- en: '[PRE162]'
  id: totrans-3738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-3739
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步讲解我们刚刚添加的五行代码。➊行创建了一个名为`background`的精灵，使用的是* [background@2x.png](mailto:background@2x.png)
    *文件或* [background@3x.png](mailto:background@3x.png) *文件。这两个文件之前已经添加到资源目录中，Xcode会自动选择合适的文件。你只需要在代码中引用它为"background"或"background.png"。要了解Xcode如何选择正确的文件，请参见“[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”一节，位于[第213页](text00026.html#page_213)。请注意，变量名不需要与图像名匹配——你可以为变量名选择任何名称。但是，图像名称必须与项目中资源目录中添加的文件名匹配。`SKSpriteNode`是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个`SKSpriteNode`，就像这里一样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-3740
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们表示屏幕的中心位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，用于描述它在屏幕上的位置。frame具有x位置、y位置、宽度和高度（见[图
    14-7](text00026.html#ch14fig7)）。midX属性给我们提供了屏幕frame的中间x位置，midY则给我们提供了屏幕frame的中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-3741
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-3742
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-3743
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过创建一个使用xMid和yMid的CGPoint并将其赋值给精灵的position属性，从而将背景图像的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-3744
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。当处理屏幕坐标时，通常使用CGFloat数据类型，而不是Float或Double。一个CGPoint可以存储两个值，一个是*x*坐标，一个是*y*坐标，这使得它在处理2D游戏中的屏幕坐标时非常方便，因为游戏中的一切都是通过x和y坐标来定位的。
- en: '**NOTE**'
  id: totrans-3745
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-3746
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何内容都来自*Core Graphics框架*，这是一个用于图形的Apple框架。你会在Swift中经常看到这种命名方式——一个类或结构体的前两三个字母通常会告诉你该对象的用途或来源。例如，所有SpriteKit类，例如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-3747
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子节点*，意味着它与这个场景绑定在一起。例如，如果场景发生变化（变大、变小或消失），这个子节点精灵也会随之改变。在SpriteKit游戏中，场景始终是父对象，而每个精灵都是场景的子节点或另一个精灵的子节点。每当你添加一个精灵时，重要的是要考虑这个精灵的父节点应该是什么。例如，溜冰者精灵是场景的子节点，但如果我们想给溜冰者添加可更换的帽子，我们会使用一个帽子精灵，它是溜冰者精灵的子节点。这样，每当溜冰者跳跃时，帽子就会跟随溜冰者，而无需单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-3748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-3749
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多工作，因此通常最好决定哪种方向最适合你的游戏，并选择那一个。由于我们的游戏是一个横向滚动的动作游戏，因此横屏模式（设备横向放置，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-3750
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-3751
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏模式下的展示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-3752
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，你会注意到它可能默认以竖屏方向启动。让我们更改项目设置，使游戏仅以横屏方式运行。进入项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-3753
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-3754
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-3755
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-3756
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-3757
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中竖屏选项，保留两个横屏方向选项的勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-3758
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到屏幕上的项目和目标列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。列表将出现，图标变蓝，表示列表区域现在显示出来了。确保选择了**SchoolhouseSkateboarder**目标。然后找到**竖屏**复选框并取消选中。保留横屏方向选项的勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-3759
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们离目标更近了，但背景图像还没有完全填充屏幕。稍后我们将看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-3760
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在以横屏方向运行，你需要确保模拟器也设置为横屏方向。要旋转它，选择模拟器菜单中的**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-3761
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-3762
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-3763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-3764
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源在每个设备上都能正确显示。相比像我们的生日追踪器那样基于UIKit的应用，游戏通常在这方面需要更多的工作，因为如果你仅仅放大或缩小，游戏艺术作品会看起来拉伸变形。为避免这个问题，你需要为每个支持的设备准备一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-3765
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-3766
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图像文件的系统，帮助你区分哪些图像适用于哪些设备。例如，假设你想在游戏中添加一张滑板运动员的图像，而你有一张宽 100 像素，高
    100 像素（100×100）的图像文件。你可以将该图像命名为 *skater.png*。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，尺寸为 200×200 像素，以及另一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，尺寸为 300×300
    像素。这三个文件应该是同一张图像的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。若游戏在 iPhone 6
    Plus 上运行，则会自动使用带有 *@3x* 后缀的文件。在代码中，你只需引用该文件名为 skater，只要你在项目中正确命名了图像，Xcode 会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-3767
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-3768
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-3769
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像文件都有后缀，例如* @2x *或* @3x*。没有后缀的图像文件，如* skater.png*，被认为是 1x 图像。你只需要为较旧的设备（如
    iPhone 3GS 或第一代 iPad mini，它们的显示屏不支持 Retina 分辨率）提供 1x 尺寸的图像。因此，我们所有的图像文件都会带有* @2x
    *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-3770
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件分别命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图像组合在一起。如果你同时将图像拖入 Xcode 资源目录，Xcode 会自动识别它们是同一图像的不同尺寸，因为它们的命名方式，并将它们组合在一起。参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-3771
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-3772
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图像被组合在资源目录中。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-3773
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一点准备工作要做。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板在处理游戏场景大小时的方式所致。游戏场景的大小将基于我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码来确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-3774
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-3775
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-3776
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-3777
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE163]'
  id: totrans-3778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-3779
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了GameScene类的一个实例并将其显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，以使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-3780
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该会填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-3782
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了SpriteKit。你学习了如何在Xcode中创建一个游戏项目并导入资源，例如图像。你还学习了如何通过标准文件命名规范来支持不同设备的屏幕分辨率，并了解了如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-3783
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个带有所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并让玩家点击屏幕使她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-3784
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  id: totrans-3785
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**场景：显示背景图像**'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-3786
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图像添加到项目中，让我们编写一些代码在应用程序中显示背景图像。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-3787
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建一个新项目时，一些有用的代码会自动添加到你的项目中。点击项目导航器中的文件*GameScene.swift*，你应该会看到已经存在的一些代码。这些代码有两个目的。首先，它给你提供了如何创建一个形状（旋转的盒子）和如何执行一个动作（让盒子旋转）的示例。其次，它让你能够立刻运行一个新项目，并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-3788
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一步，我们将删除大部分代码并添加自己的代码。请删除*GameScene.swift*中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，最终它应该是这样的：
- en: '*GameScene.swift*'
  id: totrans-3789
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE164]'
  id: totrans-3790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-3791
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将在GameScene类中实现。可以把一个场景看作是你应用中的一个视图或屏幕。GameScene类将管理场景内发生的所有事情——精灵如何显示，玩家如何与游戏互动，以及如何进行计分。复杂的游戏可能有多个独立的场景——例如标题场景、菜单场景、游戏场景和设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-3792
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（只执行一次的操作），游戏循环或更新函数（在游戏中不断执行的操作），以及用户交互函数（只有当用户点击或滑动时才会执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-3793
  prefs: []
  type: TYPE_NORMAL
  zh: '`didMove(to:)`设置函数在你的游戏首次启动时调用。它非常适合用于设置场景的代码，例如添加初始精灵或设置玩家的分数和生命值的代码。它类似于你在[第10章](text00021.html#ch10)中用于设置日期选择器的`viewDidLoad()`方法，并且只会调用一次。'
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-3794
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，必须先设置场景的`anchorPoint`。将以下代码添加到`didMove(to:)`方法中（灰色的行表示已有的代码，供参考）：
- en: '[PRE165]'
  id: totrans-3795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '![](Image00276.jpg)'
  id: totrans-3796
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-3797
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉将一张纸固定在软木板上时，图钉就是锚点。纸张会被定位到图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是`anchorPoint`属性在SpriteKit中如何作用于精灵和场景的方式。游戏模板中的GameScene的锚点位于场景的中央，但我们希望将锚点设置在场景的左下角，因此我们将其设置为CGPoint.zero，即(0,
    0)。对于某些游戏，比如太空射击游戏，将锚点设置在场景的中心会更好。但对于我们的游戏来说，地面位于屏幕底部，将锚点移到左下角会更方便操作。有关各种锚点位置的示例，请参见[图14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-3798
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-3799
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-3800
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在x坐标为0的位置时，它将位于屏幕的左边缘。当我们将一个精灵放置在y坐标为0的位置时，它将位于屏幕的下边缘。
- en: '**NOTE**'
  id: totrans-3801
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-3802
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获得。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-3803
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-3804
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。有关不同锚点旋转精灵的示例，请参见[图14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-3805
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-3806
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-3807
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将它们的锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-3808
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，向`didMove(to:)`函数中添加以下代码：
- en: '[PRE166]'
  id: totrans-3809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-3810
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看刚刚添加的五行代码。➊ 这一行创建了一个名为 background 的精灵，使用的是* [background@2x.png](mailto:background@2x.png)*
    文件或* [background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已被添加到资源目录中，Xcode
    会自动选择正确的文件。你只需在代码中将其引用为 "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参见“[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”以及[第
    213 页](text00026.html#page_213)。请注意，变量名不必与图像名称匹配——你可以为变量名使用任何你喜欢的名称。然而，图像名称必须与项目中添加到资源目录的文件匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此，当我们在游戏中创建精灵时，我们会创建一个 SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-3811
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 和 ➌ 这两行代码创建了常量 xMid 和 yMid，它们将表示屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），代表整个屏幕。每个场景和精灵都有一个框架，用来描述它在屏幕上的位置。一个框架有一个
    x 坐标，一个 y 坐标，一个宽度和一个高度（见[图 14-7](text00026.html#ch14fig7)）。midX 属性给出屏幕框架的中间 x
    坐标，而 midY 给出屏幕框架的中间 y 坐标。
- en: '![](Image00279.jpg)'
  id: totrans-3812
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-3813
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-3814
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 这一行代码通过创建一个使用 xMid 和 yMid 的 CGPoint，并将其赋值给精灵的 position 属性，从而将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-3815
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 CGPoint 是一个结构体，包含两个 CGFloat 值，分别代表 x 和 y 坐标。在处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个 CGPoint 可以保存两个值，一个用于 *x*，另一个用于 *y*，这使得它在处理 2D 游戏中的屏幕坐标时非常方便，因为所有内容的定位都需要同时使用
    x 和 y 坐标。
- en: '**NOTE**'
  id: totrans-3816
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-3817
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的内容都来自* Core Graphics 框架*，这是 Apple 用于图形处理的一个框架。你会在 Swift 中经常看到这种命名方式——类或结构体的前两个或三个字母通常会告诉你该对象的用途或来源。例如，所有的
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-3818
  prefs: []
  type: TYPE_NORMAL
  zh: ➎处的代码通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子项*，意味着它附加在这个场景上。例如，如果场景变大、变小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都是作为场景的子对象或者作为另一个精灵的子对象添加的。每次添加精灵时，都需要考虑该精灵的父对象应该是什么。例如，滑板者精灵是场景的子对象，但如果我们想在滑板者上添加可更换的帽子，我们将使用一个帽子精灵作为滑板者精灵的子对象。这样，每当滑板者跳跃时，帽子就会保持在滑板者身上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-3819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏如何进行：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-3820
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持纵向和横向模式运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后只选择这一种。由于我们的游戏是一个横向滚动的动作游戏，因此横向模式（设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）是最合适的选择。
- en: '![](Image00280.jpg)'
  id: totrans-3821
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-3822
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在纵向与横向模式下的外观对比*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-3823
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试着使用iPhone 7模拟器运行项目，你会发现它可能默认进入纵向模式。让我们更改项目设置，使游戏仅在横向模式下运行。前往项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，并且旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-3824
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-3825
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-3826
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-3827
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-3828
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选“纵向”选项，保留两个“横向”方向选项被勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-3829
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此时，列表会显示出来，图标会变蓝，表示列表区域现在被显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**纵向**复选框并取消勾选。保留横向方向选项被勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-3830
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横向模式启动。我们已经接近完成，但背景图片还没有填满屏幕。接下来我们会看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-3831
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在以横向模式运行，你需要确保模拟器也设置为横向模式。要旋转它，选择**硬件** ▸ **向右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-3832
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-3833
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-3834
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-3835
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们应当决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理更多不同的屏幕尺寸，这意味着你需要做更多的工作来确保你创建的艺术资产能够在每个设备上正确显示。与像我们的生日追踪器这样的基于UIKit的应用程序相比，游戏在这方面通常需要更多的工作，因为如果你仅仅放大或缩小图像，游戏艺术作品可能会显得拉伸变形。为了避免这个问题，你必须为每个想要支持的设备准备一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-3836
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-3837
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个图像文件命名系统，帮助你分辨哪些图像是为哪些设备准备的。例如，假设你想在游戏中添加一张滑冰者的图像，并且你有一张宽100像素、高100像素（100×100）的滑冰者图像。你会将这张图像命名为*skater.png*。你还需要创建一张命名为*[skater@2x.png](mailto:skater@2x.png)*的200×200像素图像，另一个命名为*[skater@3x.png](mailto:skater@3x.png)*的300×300像素图像。这三张图像应该是同一图像的三个不同尺寸。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件会自动被使用。如果游戏在iPhone 6 Plus上运行，则会自动使用带有*@3x*后缀的文件。在你的代码中，你只需引用图像文件名为skater，Xcode会根据你在项目中正确命名的图像来显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-3838
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《滑板学校》游戏，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-3839
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-3840
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有后缀，例如* @2x *或* @3x*。没有后缀的图像，如*skater.png*，被视为1x图像。你只需要为具有非视网膜显示屏的旧设备（如iPhone
    3GS或第一代iPad mini）包含1x大小的图像。因此，我们所有的图像文件都会有*@2x*或*@3x*后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-3841
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图像分组在一起。如果你同时将图像拖放到Xcode资源目录中，Xcode会自动识别它们是同一图像的不同尺寸，因为它们的命名方式，并将它们分组在一起。请参见[图
    14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-3842
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-3843
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-3844
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开背景图片之前，还有最后一项准备工作需要处理。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图片没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码来确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-3845
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-3846
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-3847
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-3848
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE167]'
  id: totrans-3849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-3850
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-3851
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目，背景图片现在应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3852
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-3853
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作Schoolhouse Skateboarder游戏并了解了SpriteKit。你学习了如何在Xcode中创建一个游戏项目并将资源（如图片）导入项目。你还了解了通过标准文件命名实践支持各种设备屏幕分辨率，以及如何选择游戏中需要的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-3854
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了带有所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作代码。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-3855
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  id: totrans-3856
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将所有图片添加到项目中，让我们编写一些代码来在应用中显示背景图片。
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-3857
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Game模板创建一个新项目时，一些有用的代码会自动添加到项目中。点击项目导航器中的*GameScene.swift*文件，你应该会看到已经有一堆代码。这些代码存在有两个原因。首先，它给你展示了如何创建一个形状（旋转的盒子）以及如何执行一个动作（让盒子旋转）。其次，它让你能够立即运行新项目并确保一切设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-3858
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将删除大部分代码并添加我们自己的代码。请删除*GameScene.swift*文件中的所有内容，除了didMove(to:)函数和update(_:)函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-3859
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE168]'
  id: totrans-3860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-3861
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将会在 GameScene 类中实现。可以把场景看作是你应用中的一个视图或屏幕。GameScene 类将管理场景中的一切——如何显示精灵，玩家如何与游戏互动，以及如何进行计分。复杂的游戏可能会有多个独立的场景——例如标题场景、菜单场景、游戏场景和设置场景。而我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-3862
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（仅执行一次的操作）、游戏循环或更新函数（游戏过程中反复执行的操作），以及用户交互函数（只有在用户点击或滑动时才会发生的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-3863
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的游戏首次启动时，`didMove(to:)` 设置函数会被调用。这非常适合用于设置场景的代码，比如添加初始精灵或设置玩家的分数和生命值。这与[第10章](text00021.html#ch10)中你用于设置
    AddBirthdayViewController 中日期选择器的 viewDidLoad() 方法类似，并且它只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-3864
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们必须先设置场景的锚点。将以下代码行添加到 `didMove(to:)` 方法中（灰色的行表示一些已有的代码，仅供参考）：
- en: '[PRE169]'
  id: totrans-3865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '![](Image00276.jpg)'
  id: totrans-3866
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-3867
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉把一张纸钉到软木板上时，图钉就是锚点。纸张将会放置在你钉下图钉的位置，如果纸张旋转，它会围绕图钉旋转。这正是锚点属性在
    SpriteKit 中与精灵和场景的工作方式。Game 模板的 GameScene 将锚点设置在场景的中央，但我们希望将锚点放在场景的左下角，所以我们将其设置为
    CGPoint.zero，或（0，0）。对于一些游戏，如太空射击游戏，最好将锚点设置在场景的中央。但对于我们的游戏，场景底部是地面，将锚点移到左下角会让工作更方便。请参见[图
    14-5](text00026.html#ch14fig5)，了解各种锚点位置的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-3868
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-3869
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：从 (0, 0) 到 (1, 1) 的各种锚点位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-3870
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们把一个精灵放置在 x 位置为 0 时，它会位于屏幕的左边缘。当我们把精灵放置在 y 位置为 0 时，它会位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-3871
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-3872
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建每个项目的代码文件。最终版本可从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-3873
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-3874
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式以及它的旋转方式。参见[图 14-6](text00026.html#ch14fig6)，了解使用不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-3875
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-3876
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-3877
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-3878
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，请将以下代码行添加到didMove(to:)函数中：
- en: '[PRE170]'
  id: totrans-3879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-3880
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来逐行分析我们刚刚添加的五行代码。➊行创建了一个名为background的精灵，使用* [background@2x.png](mailto:background@2x.png)*文件或*
    [background@3x.png](mailto:background@3x.png)*文件。两个文件已经提前添加到资源目录中，Xcode会自动选择正确的文件。你只需在代码中引用它为“background”或“background.png”。要了解Xcode如何选择正确的文件，请参见[“为不同屏幕分辨率调整图像大小”](text00026.html#ch14lev1sec7)，见[第213页](text00026.html#page_213)。注意，变量名不必与图像名匹配——你可以为变量名使用任何名称。然而，图像名必须与您在项目中添加到资源目录的文件相匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-3881
  prefs: []
  type: TYPE_NORMAL
  zh: ➋和➌行创建了常量xMid和yMid，它们将表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述它在屏幕上的位置。一个frame有一个x位置、一个y位置、一个宽度和一个高度（参见[图
    14-7](text00026.html#ch14fig7)）。midX属性给我们屏幕frame的中间x位置，而midY给我们中间的y位置。
- en: '![](Image00279.jpg)'
  id: totrans-3882
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-3883
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-3884
  prefs: []
  type: TYPE_NORMAL
  zh: ➌行通过使用xMid和yMid创建一个CGPoint，将其赋值给精灵的position属性，从而将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-3885
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个单独的CGPoint可以存储两个值，一个表示*x*，一个表示*y*，这使得在2D游戏中处理屏幕坐标变得很方便，因为一切都是通过x和y位置来定位的。
- en: '**NOTE**'
  id: totrans-3886
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-3887
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自* Core Graphics框架*，这是一个用于图形处理的苹果框架。你会在Swift中经常看到这种命名系统——类或结构体的前两个或三个字母通常会告诉你该对象的用途或来源。例如，所有SpriteKit类，比如*SKSpriteNode*，都以*SK*开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-3888
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 这一行通过调用函数addChild(_:)将背景图片添加到场景中。这个精灵现在是场景的*子对象*，意味着它附加在这个场景上。例如，如果场景扩展、缩小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景总是父对象，每个精灵都作为该场景的子对象或者另一个精灵的子对象被添加。每当你添加一个精灵时，重要的是要考虑该精灵的父对象应该是什么。例如，滑板精灵是场景的子对象，但如果我们想为滑板精灵添加可互换的帽子，我们会使用一个帽子精灵，它是滑板精灵的子对象。这样，每当滑板精灵跳跃时，帽子会保持在滑板精灵上，我们就不必单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-3889
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-3890
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后只选择其中之一。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（设备横向放置，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-3891
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-3892
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-3893
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，你会注意到它可能默认使用竖屏方向。我们来更改项目设置，让游戏仅在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，正如你在[图
    14-9](text00026.html#ch14fig9)中看到的。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-3894
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-3895
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-3896
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-3897
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-3898
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选竖屏选项，保留横屏方向选项已勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-3899
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。列表将会出现，图标会变成蓝色，表示当前已显示列表区域。确保选择了**SchoolhouseSkateboarder**目标。然后找到**Portrait**复选框并取消勾选，保留横屏方向选项已勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-3900
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们离目标更近了，但背景图像还没有填满屏幕。稍后我们会看看如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-3901
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经在横屏方向运行，你需要确保模拟器也是在横屏方向。要旋转它，从模拟器的菜单中选择**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-3902
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-3903
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-3904
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-3905
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理不同的屏幕尺寸，这意味着你需要额外工作，以确保你创建的艺术资源能够在每个设备上正确显示。相比像我们生日跟踪器这样的基于UIKit的应用，游戏在这一方面通常需要更多的努力，因为如果只是简单地放大或缩小，游戏的艺术作品可能会看起来被拉伸。为避免这个问题，你需要为每个你想支持的设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-3906
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-3907
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个命名图片文件的系统，帮助你区分不同设备使用的图像。例如，假设你想在游戏中添加一个滑板运动员的图像，并且你有一个宽100像素、高100像素（100×100）的滑板运动员图像文件。你应该将该图像命名为*skater.png*。你还需要创建一个名为*[skater@2x.png](mailto:skater@2x.png)*的图像，大小为200×200像素，另一个名为*[skater@3x.png](mailto:skater@3x.png)*的图像，大小为300×300像素。这三种文件应为同一图像的不同尺寸。如果游戏在iPhone
    4上运行，由于便捷的*@2x*后缀，*@2x*文件会自动被使用。如果游戏在iPhone 6 Plus上运行，*@3x*文件会自动被使用。在你的代码中，你只需引用文件名skater，Xcode会根据你在项目中正确命名的图像自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-3908
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《滑板学校》，我们将支持从iPhone 4起的所有设备。这意味着我们需要支持以下四个屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-3909
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-3910
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，比如* @2x *或* @3x*。没有后缀的图像，如*skater.png*，被认为是1x图像。你只需要为具有非Retina显示屏的旧设备（如iPhone
    3GS或第一代iPad mini）包含1x尺寸的图像。因此，我们的所有图像文件都会有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-3911
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件分别命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会发现 Xcode 将这两张图片分组在一起。如果你同时将不同大小的图像拖入 Xcode 的资源目录，Xcode
    会根据图像的命名规则自动识别它们是同一张图像的不同大小，并将它们分组在一起。参见[图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-3912
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-3913
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-3914
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行背景图像的处理之前，还有最后一步准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为游戏模板在处理游戏场景的大小时的方式。游戏场景的大小将基于我们项目中包含的 *GameScene.sks*
    场景编辑器文件中的设置来决定。由于我们在这个项目中不会使用场景编辑器，因此我们需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-3915
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-3916
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-3917
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 `viewDidLoad()` 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-3918
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE171]'
  id: totrans-3919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-3920
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()` 方法中的代码创建了一个 `GameScene` 类的实例并将其显示出来。由于 `GameScene` 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在此处添加的代码决定了显示视图的大小（宽度和高度），并设置了新场景的大小，以确保它填满整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-3921
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3922
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你所学到的**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-3923
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了关于 SpriteKit 的知识。你学会了如何在 Xcode 中创建游戏项目并将资源（例如图像）导入项目。你还了解了如何通过标准的文件命名实践来支持各种设备屏幕分辨率，并学习了如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-3924
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个 SpriteKit 游戏项目，准备好了所需的资源，并解决了屏幕方向和分辨率的问题，接下来就该编程一些动作了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让所有东西都动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-3925
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  id: totrans-3926
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用游戏模板创建一个新项目时，一些有用的代码会自动添加到项目中。点击项目导航器中的 *GameScene.swift* 文件，你应该能看到已经有一堆代码在里面。这段代码存在有两个原因。首先，它给了你一个如何创建形状（旋转的方块）以及如何执行动作（使方块旋转）的示例。其次，它让你可以立即运行一个新项目，并确保所有设置正确。
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-3927
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将删除大部分现有代码并添加自己的代码。请删除 *GameScene.swift* 中的所有内容，除了 didMove(to:) 函数和 update(_:)
    函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-3928
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE172]'
  id: totrans-3929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-3930
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将会在 GameScene 类中。可以将场景看作是你应用中的一个视图或屏幕。GameScene 类将管理场景中发生的所有事情——如何显示精灵，玩家如何与游戏互动，以及如何进行计分。复杂的游戏可能会有许多独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-3931
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（仅执行一次的操作），游戏循环或更新函数（在游戏过程中反复执行的操作），以及用户交互函数（只有在用户点击或滑动时才会执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-3932
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数 didMove(to:) 会在你的游戏首次启动时调用。它非常适合用于设置场景的代码，比如添加初始精灵或设置玩家的分数和生命值。这类似于你在 [第10章](text00021.html#ch10)
    中用来设置 AddBirthdayViewController 中日期选择器的 viewDidLoad() 方法，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-3933
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图片添加到场景之前，我们必须设置场景的 anchorPoint。将这行代码添加到 didMove(to:) 方法中（灰色的行表示一些现有代码，仅用于放置）：
- en: '[PRE173]'
  id: totrans-3934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '![](Image00276.jpg)'
  id: totrans-3935
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-3936
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉把一张纸钉到软木板上时，图钉就是锚点。纸张会被定位到图钉所在的位置，如果纸张旋转，它会围绕图钉旋转。这正是锚点属性在
    SpriteKit 中与精灵和场景的工作方式。游戏模板中的 GameScene 的锚点位于场景的中心，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero，或 (0, 0)。对于某些游戏，比如太空射击游戏，将锚点放在场景的中心会更好。但对于我们的游戏来说，由于地面位于屏幕底部，将锚点移到左下角会更方便操作。有关不同锚点位置的示意图，请参见
    [图 14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-3937
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-3938
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点的不同位置，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-3939
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 坐标为 0 的位置时，它将位于屏幕的左边缘。而当我们将精灵放置在 y 坐标为 0 的位置时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-3940
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-3941
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步一步地为项目构建每个代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-3942
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-3943
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式和旋转方式。有关不同锚点旋转精灵的示例，请参见 [图 14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-3944
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-3945
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-3946
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-3947
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，向 `didMove(to:)` 函数中添加以下代码行：
- en: '[PRE174]'
  id: totrans-3948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-3949
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析刚才添加的五行代码。第 ➊ 行创建了一个名为 background 的精灵，使用 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。两个文件之前已添加到资源目录中，Xcode 会自动选择正确的文件。你只需在代码中将其引用为
    "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参阅 “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”
    在 [第 213 页](text00026.html#page_213)的内容。请注意，变量名不必与图像名匹配——你可以为变量名使用任何名称。但图像名必须与项目中资源目录中添加的文件名匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们会创建一个 SKSpriteNode，如同这里所做的。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-3950
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➋ 和 ➌ 行创建了常量 xMid 和 yMid，它们代表屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它在屏幕上的位置。框架有一个
    x 位置、一个 y 位置、一个宽度和一个高度（见[图 14-7](text00026.html#ch14fig7)）。midX 属性给出了屏幕框架的中间 x
    位置，而 midY 给出了中间 y 位置。
- en: '![](Image00279.jpg)'
  id: totrans-3951
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-3952
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-3953
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➍ 行通过创建一个使用 xMid 和 yMid 的 CGPoint 来设置背景图像的位置，使其位于屏幕的中央，并将其分配给精灵的位置属性。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-3954
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，表示 x 和 y 坐标。当你处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个单独的 CGPoint 可以保存两个值，一个是 *x* ，一个是 *y* ，这使得它在处理 2D 游戏中的屏幕坐标时非常方便，因为在这种游戏中，一切都通过
    x 和 y 位置来定位。
- en: '**NOTE**'
  id: totrans-3955
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-3956
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自* Core Graphics 框架*，这是 Apple 用于图形的框架。你会在 Swift 中经常看到这种命名系统——一个类或结构体的前两到三个字母通常告诉你该对象的用途或来源。例如，所有
    SpriteKit 类，例如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-3957
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➎ 行通过调用函数 addChild(_:) 将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它附属于这个场景。例如，如果场景扩展、收缩或消失，这个子精灵也会随着场景变化。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵作为该场景的子对象或另一个精灵的子对象被添加进去。每当你添加一个精灵时，必须考虑该精灵的父对象应该是什么。例如，滑雪者精灵是场景的子对象，但如果我们想在滑雪者上添加可更换的帽子，我们会使用帽子精灵，它是滑雪者精灵的子对象。这样，每当滑雪者跳跃时，帽子就会保持在滑雪者身上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-3958
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何玩：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-3959
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，并选择那个方向。由于我们的游戏是一个水平滚动的动作游戏，横屏模式（设备横着放置，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-3960
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-3961
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-3962
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，您会注意到它可能会默认为竖屏模式。让我们更改项目设置，以便游戏仅在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-3963
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-3964
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-3965
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，您可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-3966
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-3967
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选竖屏选项，保留横屏选项的勾选状态。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-3968
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的屏幕上看不到项目和目标列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。列表将会出现，图标会变为蓝色，表示列表区域现在已显示。确保选择了**SchoolhouseSkateboarder**目标。接下来，找到**竖屏**复选框并取消勾选。保持横屏选项勾选状态。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-3969
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，您会看到它以横屏模式启动。我们已经接近了，但背景图像还没有填满整个屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-3970
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏现在以横屏模式运行，您需要确保模拟器也处于横屏模式。要旋转模拟器，请从模拟器菜单中选择**硬件** ▸ **向右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-3971
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-3972
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-3973
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-3974
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，您需要处理的不同屏幕尺寸就越多，这意味着您需要额外的工作来确保您创建的艺术资源能够在每个设备上正确显示。与基于
    UIKit 的应用程序（如我们的生日跟踪器）相比，游戏在这一方面需要更多的努力，因为如果只是简单地缩放，游戏中的艺术作品会看起来被拉伸。为避免这个问题，您需要为每个要支持的设备准备一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-3975
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-3976
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一种命名图片文件的系统，帮助你区分不同设备的图片。例如，假设你想在游戏中添加一张滑板手的图片，你有一张宽 100 像素、高 100 像素的滑板手图片（100×100）。你将这张图片命名为
    *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)* 的图片，尺寸为 200×200
    像素，另外还需要创建一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为 300×300 像素。这三张图片应该是同一张图片的不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需引用图片文件名
    skater，只要你在项目中正确命名了图片，Xcode 会自动显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-3977
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《滑板少年》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-3978
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-3979
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有后缀，如* @2x *或* @3x*。没有后缀的图片，如* skater.png*，被视为 1x 图片。你只需要为老旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 尺寸的图片，这些设备使用的是非 Retina 屏幕。因此，我们所有的图片文件将都带有* @2x
    *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-3980
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图片归为一组。如果你同时将图片拖入 Xcode 资源目录，Xcode 会自动识别它们是同一张图片的不同尺寸，并将它们分组在一起，这是因为它们的命名方式。见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-3981
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-3982
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图片在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-3983
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行背景图片的处理之前，还有最后一项准备工作。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片并没有填满整个屏幕，如
    [图 14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板在处理游戏场景尺寸时的方式。游戏场景的大小将基于我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，所以我们需要添加代码以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-3984
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-3985
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-3986
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，并找到 viewDidLoad() 方法。添加以下几行代码以设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-3987
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE175]'
  id: totrans-3988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-3989
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()` 方法中的代码创建了一个 GameScene 类的实例并显示出来。由于 GameScene 是我们游戏的主场景，我们希望它始终充满整个屏幕。我们在这里添加的代码决定了显示视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-3990
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3991
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-3992
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 Schoolhouse Skateboarder 游戏，并学习了 SpriteKit。你学习了如何在 Xcode 中创建一个游戏项目并将资源（如图像）导入到项目中。你还学习了通过标准文件命名规范支持不同设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-3993
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在 [第15章](text00027.html#ch15)
    中，我们将添加我们的英雄角色和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-3994
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  id: totrans-3995
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将删除大部分代码并添加我们自己的代码。请删除 *GameScene.swift* 中的所有内容，除了 didMove(to:) 函数和 update(_:)
    函数的声明，使其看起来像这样：
- en: '*GameScene.swift*'
  id: totrans-3996
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE176]'
  id: totrans-3997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-3998
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏的大部分逻辑都将在 GameScene 类中处理。可以将一个场景视为应用中的一个视图或屏幕。GameScene 类将管理场景中发生的一切——精灵如何显示、玩家如何与游戏互动、得分如何计算。复杂的游戏可能有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-3999
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的内容）、游戏循环或更新函数（游戏过程中反复执行的内容）以及用户交互函数（只有在用户点击或滑动时才执行的内容）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-4000
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数 didMove(to:) 在游戏开始时被调用。它非常适合用于设置场景的代码，例如添加初始精灵或设置玩家的得分和生命值。它类似于你在 [第10章](text00021.html#ch10)
    中为 AddBirthdayViewController 中的日期选择器设置的 viewDidLoad() 方法，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-4001
  prefs: []
  type: TYPE_NORMAL
  zh: 在将背景图像添加到场景之前，我们必须设置场景的 anchorPoint。将以下代码添加到 didMove(to:) 方法中（灰色行表示一些现有的代码，以便放置）：
- en: '[PRE177]'
  id: totrans-4002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '![](Image00276.jpg)'
  id: totrans-4003
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-4004
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉把一张纸钉在软木板上时，图钉就是锚点。纸张将被放置在图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是
    SpriteKit 中 anchorPoint 属性在精灵和场景中的工作方式。游戏模板中的 GameScene 场景将锚点设置在场景的中间，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero 或 (0, 0)。对于一些游戏，例如太空射击游戏，将锚点放置在场景的中间会更好。但对于我们的游戏，地面位于屏幕底部，将锚点移到左下角会更容易处理。请参见
    [图 14-5](text00026.html#ch14fig5) 了解各种锚点的示例。
- en: '![](Image00277.jpg)'
  id: totrans-4005
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-4006
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：从 (0, 0) 到 (1, 1) 不同位置的锚点*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-4007
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 位置为 0 时，它会位于屏幕的左边缘。而当我们将精灵放置在 y 位置为 0 时，它会位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-4008
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-4009
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步一步地构建项目中的每个代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获得。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4010
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4011
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式和旋转方式。请参见 [图 14-6](text00026.html#ch14fig6) 中的例子，了解如何使用不同的锚点来旋转精灵。
- en: '![](Image00278.jpg)'
  id: totrans-4012
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4013
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4014
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点放置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用精灵的中心点来定位它们。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4015
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，请将以下代码行添加到 didMove(to:) 函数中：
- en: '[PRE178]'
  id: totrans-4016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4017
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步解析刚才添加的五行代码。第 ➊ 行创建了一个名为 background 的精灵，使用 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。两个文件都已提前添加到资源目录中，Xcode
    会自动选择正确的文件。你只需要在代码中引用它为 "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参见
    “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)” 章节中的内容，详见 [第 213 页](text00026.html#page_213)。注意，变量名不必与图像名称匹配——你可以为变量名选择任何名称。不过，图像名称必须与项目中资源目录中添加的文件名匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个 SKSpriteNode，就像这里一样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4018
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 和 ➌ 这两行创建了常量 xMid 和 yMid，它们将表示屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述了它们在屏幕上的位置。框架有一个
    x 坐标、一个 y 坐标、一个宽度和一个高度（参见 [图 14-7](text00026.html#ch14fig7) ）。midX 属性给出了屏幕框架的中间
    x 坐标，midY 给出了屏幕框架的中间 y 坐标。
- en: '![](Image00279.jpg)'
  id: totrans-4019
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4020
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4021
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ 这一行通过使用 xMid 和 yMid 创建一个 CGPoint，并将其赋值给精灵的 position 属性，将背景图像的位置设置为屏幕中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4022
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，用于保存两个 CGFloat 值，表示 x 和 y 坐标。当你处理屏幕坐标时，通常会使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个 CGPoint 可以保存两个值，一个代表 *x* ，一个代表 *y* ，这使得在 2D 游戏中处理屏幕坐标变得很方便，因为游戏中的一切位置都由
    x 和 y 坐标来确定。
- en: '**NOTE**'
  id: totrans-4023
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4024
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的内容都来自* Core Graphics 框架*，这是一个用于图形处理的苹果框架。你会在 Swift 中经常看到这种命名系统——类或结构体的前两三个字母通常能告诉你这个对象的用途或来源。例如，所有的
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4025
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 这一行通过调用函数 addChild(_:) 向场景中添加背景图像。这个精灵现在是场景的*子节点*，这意味着它与场景是绑定在一起的。例如，如果场景放大、缩小或消失，这个子精灵也会随之变化。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵都是场景的子节点，或者是另一个精灵的子节点。每次添加精灵时，考虑该精灵的父节点非常重要。例如，溜冰精灵是场景的子节点，但如果我们想给溜冰精灵添加可更换的帽子，我们就会使用一个帽子精灵，作为溜冰精灵的子节点。这样，每当溜冰精灵跳跃时，帽子就会跟随溜冰精灵，而我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4026
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4027
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，然后选择那个方向。由于我们的游戏是一个水平滚动的动作游戏，因此横屏方向（设备横放，如
    [图 14-8](text00026.html#ch14fig8) 所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-4028
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4029
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏与横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4030
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能默认是竖屏方向。我们来修改项目设置，使游戏仅在横屏模式下运行。打开项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4031
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4032
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4033
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4034
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4035
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中竖屏选项，保持选中两个横屏方向选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4036
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。该列表将出现，图标会变成蓝色，表示列表区域现在已经显示。确保**SchoolhouseSkateboarder**目标被选中。现在找到**竖屏**复选框并取消选中它。保持选中横屏方向选项。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4037
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经接近了，但背景图片还没有填满整个屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4038
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在已在横屏模式下运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4039
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4040
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4041
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4042
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理更多的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源在每个设备上正确显示。与像我们的生日跟踪器这类基于
    UIKit 的应用相比，游戏在这方面通常需要更多的工作，因为如果你只是简单地缩放，游戏的艺术资源看起来会被拉伸。为了避免这个问题，你必须为每个想要支持的设备使用不同的图片集。
- en: '![](Image00285.jpg)'
  id: totrans-4043
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4044
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一种命名图像文件的系统，帮助你识别哪些图片适用于哪些设备。例如，假设你想要在游戏中添加一张滑板手的图片，而你有一张 100 像素宽、100
    像素高（100×100）的滑板手图片。你会将这张图片命名为 *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图片，尺寸为 200×200 像素，再创建一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为 300×300
    像素。这三张文件应该是同一张图片的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件将自动被使用。在你的代码中，你只需引用该文件名为 skater ，只要你正确命名了项目中的图片，Xcode 会自动显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4045
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-4046
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4047
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，例如* @2x *或* @3x*。没有后缀的图片，例如* skater.png*，被视为 1x 图片。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 大小的图片，因为这些设备没有视网膜显示屏。因此，我们所有的图片文件都会有* @2x *或*
    @3x *的后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4048
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会发现 Xcode 将这两张图片分组在一起。如果你同时将图片拖入 Xcode 的资源目录，Xcode 会自动根据它们的命名方式识别出它们是同一张图片的不同尺寸，并将它们分组在一起。请参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4049
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4050
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图片被分组在资源目录中。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4051
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完背景图片后，我们还有最后一项准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片没有填满整个屏幕，如 [图
    14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板在处理游戏场景大小时的方式。游戏场景的大小将基于包含在我们项目中的
    *GameScene.sks* 场景编辑器文件中的设置。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-4052
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4053
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4054
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4055
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE179]'
  id: totrans-4056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4057
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()` 方法中的代码创建了一个 GameScene 类的实例并将其显示出来。由于 GameScene 是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了显示视图的大小（宽度和高度），并设置新场景的大小，使其填充整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4058
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该会填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4059
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4060
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《滑板学校》游戏，并学习了 SpriteKit。你学会了如何在 Xcode 中创建游戏项目并将资源（如图像）导入项目中。你还了解了如何通过标准的文件命名方法来支持不同设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4061
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个带有所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)，我们将添加我们的英雄和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-4062
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '*GameScene.swift*'
  id: totrans-4063
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameScene.swift*'
- en: '[PRE180]'
  id: totrans-4064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-4065
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑都会在 GameScene 类中。你可以把一个场景看作是你应用程序中的一个视图或屏幕。GameScene 类将管理场景中发生的所有事情——如何显示精灵、玩家如何与游戏互动以及如何进行得分。复杂的游戏可能会有多个独立的场景——例如，一个标题场景、一个菜单场景、一个游戏场景和一个设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-4066
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（只执行一次的操作）、游戏循环或更新函数（在游戏中反复执行的操作）以及用户交互函数（只有在用户点击或滑动时才会执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-4067
  prefs: []
  type: TYPE_NORMAL
  zh: setup 函数 didMove(to:) 会在游戏开始时被调用。它非常适合用来编写设置场景的代码，例如添加初始精灵或设置玩家的分数和生命值的代码。它类似于你在[第10章](text00021.html#ch10)中用来设置
    AddBirthdayViewController 中日期选择器的 viewDidLoad() 方法，并且它只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-4068
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们必须设置场景的 anchorPoint。将以下代码添加到 didMove(to:) 方法中（灰色行表示一些现有代码，用于位置参考）：
- en: '[PRE181]'
  id: totrans-4069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '![](Image00276.jpg)'
  id: totrans-4070
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-4071
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用图钉把一张纸钉在软木板上时，图钉就是锚点。纸张将被定位到图钉的位置，并且如果纸张旋转，它将围绕图钉旋转。这正是
    anchorPoint 属性在 SpriteKit 中与精灵和场景的工作原理。Game 模板的 GameScene 的锚点位于场景的中央，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero，或 (0, 0)。对于一些游戏，例如太空射击游戏，将锚点设置在场景的中央可能更合适。但对于我们的游戏，其中地面位于屏幕底部，将锚点移到左下角将使工作更加方便。有关各种锚点的说明，请参见[图
    14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-4072
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-4073
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点的不同位置，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-4074
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在 x 坐标为 0 的位置时，它会位于屏幕的左边缘。当我们将一个精灵放置在 y 坐标为 0 的位置时，它会位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-4075
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-4076
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个代码文件。最终版本可以在* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4077
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4078
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式以及旋转方式。有关不同锚点旋转精灵的示例，请参见[图 14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-4079
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4080
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4081
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用精灵的中心点来定位它们。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4082
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，将以下代码行添加到 didMove(to:) 函数中：
- en: '[PRE182]'
  id: totrans-4083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4084
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解释一下我们刚刚添加的五行代码。第 ➊ 行创建了一个名为 background 的精灵，使用的是 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已经添加到资产目录中，Xcode
    会自动选择合适的文件。你只需在代码中引用它，命名为 "background" 或 "background.png"。要了解 Xcode 如何选择合适的文件，请参见
    “[不同屏幕分辨率的图像大小调整](text00026.html#ch14lev1sec7)” 第 213 页的内容。请注意，变量名不必与图像名匹配——你可以随便选择变量名。然而，图像名必须与在项目的资产目录中添加的文件匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建一个精灵时，我们将创建一个 SKSpriteNode，就像这里一样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4085
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和第➌行创建了常量xMid和yMid，它们表示屏幕的中心位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述它们在屏幕上的位置。frame有x位置、y位置、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕frame的中间x位置，而midY给出了屏幕frame的中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-4086
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4087
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4088
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint，并将其分配给精灵的位置属性，从而将背景图像的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4089
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以存储两个值，一个表示*x*，另一个表示*y*，这使得在2D游戏中处理屏幕坐标变得方便，因为所有物体的位置都涉及到x和y坐标。
- en: '**NOTE**'
  id: totrans-4090
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4091
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自* Core Graphics框架*，这是苹果用于图形处理的框架。你会在Swift中经常看到这种命名系统——类或结构体的前两到三个字母通常会告诉你该对象的用途或来源。例如，所有的SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4092
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用addChild(_:)函数将背景图像添加到场景中。这个精灵现在是场景的*子对象*，这意味着它附加在这个场景上。例如，如果场景扩展、缩小或消失，子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都是作为该场景的子对象或另一个精灵的子对象添加的。每次添加精灵时，都需要考虑该精灵的父对象应该是什么。例如，滑冰者精灵是场景的子对象，但如果我们想在滑冰者身上添加可更换的帽子，我们会使用一个帽子精灵，它是滑冰者精灵的子对象。这样，当滑冰者跳跃时，帽子会保持在滑冰者头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4093
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4094
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时适应纵向和横向模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并只选择那种方向。由于我们的游戏是一个横向滚动的动作游戏，因此横向方向（设备侧放，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-4095
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4096
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在纵向和横向方向上的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4097
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，你会发现它可能默认是纵向模式。让我们更改项目设置，使游戏只能在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，正如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4098
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4099
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4100
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4101
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中纵向选项，保留两个横向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到屏幕上的项目和目标列表，点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。该列表将会显示，图标会变为蓝色，表示列表区域现在已显示。确保选中了**SchoolhouseSkateboarder**目标。接下来，找到**Portrait**复选框并取消选中。保留横屏选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4104
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们离目标更近了，但背景图像还没有完全填满屏幕。稍后我们会看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已在横屏模式下运行，你需要确保模拟器也处于横屏模式。要旋转它，从模拟器的菜单中选择**硬件** ▸ **右旋**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4106
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该先决定要支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理更多不同的屏幕尺寸，这意味着你需要做额外的工作，确保你创建的艺术资源能在每个设备上正确显示。相比于像我们的生日追踪器这种基于UIKit的应用，游戏通常在这方面需要更多的努力，因为如果你只是简单地缩放，游戏的艺术资源会看起来被拉伸。为了避免这个问题，你必须为每个你想要支持的设备准备一套不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-4110
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4111
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一套命名图像文件的系统，帮助你区分哪些图像适用于哪些设备。例如，假设你想为游戏添加一个滑板者的图像，而你有一张100像素宽、100像素高（100×100）的滑板者图像。你应该将这张图像命名为*skater.png*。你还需要创建一张命名为*[skater@2x.png](mailto:skater@2x.png)*的图像，尺寸为200×200像素，再创建一张命名为*[skater@3x.png](mailto:skater@3x.png)*的图像，尺寸为300×300像素。这三张图像应是同一张图像的不同尺寸。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件会自动被使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件会自动被使用。在代码中，你只需要引用文件名skater，Xcode会根据项目中正确命名的图像自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Schoolhouse Skateboarder，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-4113
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4114
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，比如* @2x *或* @3x*。没有后缀的图像，如*skater.png*，被认为是1x图像。你只需要为老设备提供1x大小的图像，这些设备没有视网膜显示屏，比如iPhone
    3GS或第一代iPad mini。因此，我们所有的图像文件都会有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图像归为一组。如果你同时将这些图像拖入Xcode的资源目录，Xcode会根据图像的命名自动识别它们是同一图像的不同尺寸，并将它们分组在一起。见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4116
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图像在资源目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从背景图像部分继续之前，还有最后一项准备工作要完成。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是由于游戏模板处理游戏场景大小的方式。游戏场景的大小将基于包含在我们项目中的*GameScene.sks*场景编辑文件中的设置来确定。我们在这个项目中不会使用场景编辑器，所以我们需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-4119
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4121
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4122
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE183]'
  id: totrans-4123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4124
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并将其显示出来。由于 GameScene 是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了显示视图的大小（宽度和高度），并设置了新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4125
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作了 Schoolhouse Skateboarder 游戏，并学习了 SpriteKit。你学会了如何在 Xcode 中创建游戏项目并将资源（例如图像）导入项目中。你还学习了如何通过标准的文件命名规范来支持不同设备的屏幕分辨率，并且了解了在游戏中需要哪些图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-4129
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '[PRE184]'
  id: totrans-4130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-4131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大部分逻辑将位于 GameScene 类中。可以将一个场景看作是应用程序中的一个视图或屏幕。GameScene 类将管理场景中发生的所有事情——例如，精灵应如何显示，玩家如何与游戏互动，以及如何进行得分。复杂的游戏可能会有多个独立的场景——例如，标题场景、菜单场景、游戏场景和设置场景。我们的游戏将只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-4132
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的操作），游戏循环或更新函数（游戏过程中反复执行的操作），以及用户交互函数（仅在用户点击或滑动时执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-4133
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数 didMove(to:) 在游戏首次启动时被调用。它非常适合执行场景的初始化代码，例如添加初始精灵或设置玩家的得分和生命值。它类似于你在[第10章](text00021.html#ch10)中用来设置
    AddBirthdayViewController 中日期选择器的 viewDidLoad() 方法，并且只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-4134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们必须设置场景的 anchorPoint。将以下代码添加到 didMove(to:) 方法中（灰色的代码行表示一些现有代码，用于放置位置）：
- en: '[PRE185]'
  id: totrans-4135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '![](Image00276.jpg)'
  id: totrans-4136
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-4137
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉把一张纸钉到软木板上时，图钉就是锚点。纸张将被定位在图钉所在的位置，并且如果纸张旋转，它会围绕图钉旋转。这正是
    SpriteKit 中锚点属性在精灵和场景中的工作方式。游戏模板中的 GameScene 的锚点位于场景的中心，但我们希望将锚点设置为场景的左下角，因此我们将其设置为
    CGPoint.zero，即 (0, 0)。对于一些游戏，例如太空射击游戏，将锚点放在场景的中心可能更好。但对于我们的游戏来说，地面位于屏幕的底部，将锚点移到左下角会让操作更方便。请参见[图
    14-5](text00026.html#ch14fig5)，了解不同锚点的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-4138
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-4139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点的不同位置，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-4140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在 x 坐标为 0 的位置时，它会位于屏幕的左边缘。当我们将一个精灵放置在 y 坐标为 0 的位置时，它会位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-4141
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-4142
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步地构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4143
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4144
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。请参见[图 14-6](text00026.html#ch14fig6)，了解如何使用不同的锚点旋转精灵。
- en: '![](Image00278.jpg)'
  id: totrans-4145
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4147
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点放在中心位置。我们不会更改任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，将以下代码行添加到 didMove(to:) 函数中：
- en: '[PRE186]'
  id: totrans-4149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析我们刚刚添加的五行代码。➊ 这一行创建了一个名为 background 的精灵，使用的是 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件早先已经添加到资源目录中，Xcode
    会自动选择合适的文件。你只需在代码中引用它为“background”或“background.png”。要了解 Xcode 如何选择合适的文件，请参见“[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”[第
    213 页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以为变量名选择任何你想要的名字。然而，图像名必须与项目中添加到资源目录中的文件名一致。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们实际上是在创建一个 SKSpriteNode，就像这里一样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4151
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋行和第➌行创建了常量 `xMid` 和 `yMid`，它们将代表屏幕的中间位置。`frame` 是 `GameScene` 的一个属性——它是一个
    `CGRect`（矩形），表示整个屏幕。每个场景和精灵都有一个 `frame`，描述它们在屏幕上的位置。一个 `frame` 有 x 位置、y 位置、宽度和高度（见
    [图14-7](text00026.html#ch14fig7)）。`midX` 属性给我们提供屏幕 `frame` 的中间 x 位置，`midY` 给我们提供中间
    y 位置。
- en: '![](Image00279.jpg)'
  id: totrans-4152
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7: 一个 `frame` 描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4154
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用 `xMid` 和 `yMid` 创建一个 `CGPoint`，并将其分配给精灵的 `position` 属性，从而将背景图像的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4155
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGPoint` 是一个结构体，包含两个 `CGFloat` 值，分别表示 x 和 y 坐标。当你处理屏幕坐标时，通常使用 `CGFloat` 数据类型，而不是
    `Float` 或 `Double`。一个 `CGPoint` 可以包含两个值，一个用于 *x* 坐标，另一个用于 *y* 坐标，这使得它在 2D 游戏中处理屏幕坐标时非常方便，游戏中的所有内容都使用
    x 和 y 坐标来定位。'
- en: '**NOTE**'
  id: totrans-4156
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4157
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的内容都来自* Core Graphics 框架*，这是 Apple 提供的一个图形框架。你会在 Swift 中经常见到这种命名方式——类或结构体的前两三个字母通常告诉你该对象的用途或来源。例如，所有的
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4158
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数 `addChild(_:)` 将背景图像添加到场景中。这个精灵现在是场景的 *子对象*，意味着它附加在这个场景上。例如，如果场景发生变化（增长、缩小或消失），这个子精灵也会随之变化。在
    SpriteKit 游戏中，场景总是父对象，每个精灵都作为场景的子对象或另一个精灵的子对象添加。每当你添加一个精灵时，重要的是要考虑这个精灵的父对象应该是什么。例如，滑冰精灵是场景的子对象，但如果我们想在滑冰精灵上加上可交换的帽子，我们会使用一个帽子精灵，作为滑冰精灵的子对象。这样，每当滑冰精灵跳跃时，帽子也会保持在滑冰精灵头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好选择最适合你游戏的方向，并选择其中一个。由于我们的游戏是一个水平滚动的动作游戏，横屏模式（即设备处于侧放状态，如
    [图14-8](text00026.html#ch14fig8) 所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-4161
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4162
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8: 我们的游戏在竖屏与横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用iPhone 7模拟器，您会注意到它可能会默认以纵向模式启动。让我们更改项目设置，使游戏仅在横屏模式下运行。进入项目导航器并点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4164
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目访问项目设置*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4166
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，您可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4167
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消勾选纵向选项，保留两个横屏选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在屏幕上看不到“项目”和“目标”列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。该列表将出现，图标会变成蓝色，表示列表区域现在已显示。确保选择了**SchoolhouseSkateboarder**目标。接下来找到**纵向**复选框并取消勾选，保留横屏选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4170
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，您将看到它以横屏模式启动。我们已经接近完成，但背景图像尚未填满屏幕。稍后我们将看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏现在以横屏模式运行，您需要确保模拟器也处于横屏模式。要旋转模拟器，请从模拟器菜单中选择**硬件** ▸ **右旋**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4172
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，应该决定支持哪些设备和屏幕分辨率。支持的设备越多，您需要处理的屏幕尺寸差异就越大，这意味着您需要额外的工作，确保您创建的艺术资源能够在每个设备上正确显示。相比于像我们的生日追踪器这样的基于UIKit的应用程序，游戏在这方面需要更多的努力，因为如果只是简单地缩放，游戏艺术图像会显得拉伸变形。为避免这个问题，您需要为每个要支持的设备使用不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-4176
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4177
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个命名系统，可以帮助你区分哪些图片是为哪些设备准备的。例如，假设你想在游戏中添加一个滑板运动员的图片，并且你有一个宽100像素、高100像素（100×100）的滑板运动员图片文件。你会将这个图片命名为*skater.png*。你还需要创建一个名为*[skater@2x.png](mailto:skater@2x.png)*的图片，大小为200×200像素，另一个名为*[skater@3x.png](mailto:skater@3x.png)*的图片，大小为300×300像素。这三张文件应该是同一张图片的不同尺寸。如果游戏运行在iPhone
    4上，带有*@2x*后缀的文件会自动被使用。如果游戏运行在iPhone 6 Plus上，带有*@3x*后缀的文件会自动被使用。在代码中，你只需要引用图片文件名为skater，Xcode会根据正确命名的图片自动显示合适的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从iPhone 4及以后型号的设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-4179
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4180
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，例如* @2x *或* @3x*。没有后缀的图片，比如*skater.png*，被认为是1x图片。你只需要为旧设备（如iPhone
    3GS或第一代iPad mini）包含1x大小的图片，这些设备没有视网膜显示屏。因此，我们所有的图片文件都会有* @2x *或* @3x *的后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图片分组在一起。如果你同时将图片拖动到Xcode的资源目录中，Xcode会根据图片的命名规则自动识别它们是同一张图片的不同尺寸，并将它们分组在一起。参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4182
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图片在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4184
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完背景图片后，我们还有最后一项准备工作。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图片没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板在设置游戏场景大小时的处理方式。游戏场景的大小将根据项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码，确保我们的场景大小合适。
- en: '![](Image00287.jpg)'
  id: totrans-4185
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4187
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行以设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4188
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE187]'
  id: totrans-4189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4190
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了显示的视图的大小（宽度和高度），并设置新场景的大小，以便它填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《学校滑板少年》游戏，并学习了SpriteKit。你学习了如何在Xcode中创建一个游戏项目，并将资源（如图像）导入到项目中。你还学习了如何通过标准的文件命名方法支持各种设备屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置好了带有所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切开始移动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-4195
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  id: totrans-4196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大多数逻辑将位于GameScene类中。可以把场景看作是你应用中的一个视图或屏幕。GameScene类将管理场景内发生的一切——如何显示精灵、玩家如何与游戏互动，以及如何进行计分。复杂的游戏可能有许多不同的场景——例如标题场景、菜单场景、游戏场景和设置场景。我们的游戏只有一个场景：游戏场景。
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-4197
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（只执行一次的操作）、游戏循环或更新函数（在游戏过程中反复执行的操作），以及用户交互函数（只有在用户点击或滑动时才会执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-4198
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数didMove(to:)在游戏首次启动时被调用。它非常适合用来设置场景的代码，比如添加初始精灵或设置玩家的分数和生命值。这与在[第10章](text00021.html#ch10)中用于设置AddBirthdayViewController中的日期选择器的viewDidLoad()方法类似，并且它只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-4199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们必须设置场景的anchorPoint。将这行代码添加到didMove(to:)方法中（灰色的代码行表示一些现有的代码，供放置参考）：
- en: '[PRE188]'
  id: totrans-4200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '![](Image00276.jpg)'
  id: totrans-4201
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-4202
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉把一张纸钉到软木板上时，图钉就是锚点。纸张会被定位在图钉所在的位置，如果纸张旋转，它会围绕图钉旋转。这正是`anchorPoint`属性在SpriteKit中与精灵和场景一起工作的方式。游戏模板中的GameScene的锚点位于场景的中央，但我们希望锚点位于场景的左下角，所以我们将其设置为CGPoint.zero，即(0,
    0)。对于某些游戏，比如太空射击游戏，最好将锚点放在场景的中间。但对于我们的游戏，由于地面位于屏幕底部，将锚点移到左下角会更方便操作。请参见[图14-5](text00026.html#ch14fig5)了解各种锚点位置的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-4203
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-4204
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的各种位置，范围从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-4205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在x坐标为0的位置时，它将位于屏幕的左边缘。而当我们将一个精灵放置在y坐标为0的位置时，它将位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-4206
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-4207
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个项目的代码文件。最终版本可以在* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4208
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4209
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置精灵的锚点，改变精灵的定位方式以及它如何旋转。请参见[图14-6](text00026.html#ch14fig6)了解不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-4210
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4211
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4212
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点放在中心位置。我们不会改变任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，将以下代码添加到didMove(to:)函数中：
- en: '[PRE189]'
  id: totrans-4214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析刚才添加的五行代码。在➊这一行创建了一个名为background的精灵，使用的是*背景@2x.png*文件或*背景@3x.png*文件。两者都已添加到资源目录中，Xcode会自动选择合适的文件。你只需在代码中引用它，名称为"background"或"background.png"。要了解Xcode如何选择正确的文件，请参见“[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”一节，在[第213页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以为变量名使用任何名称。但图像名称必须与项目中添加到资源目录的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4216
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，用来描述它在屏幕上的位置。frame包含x位置、y位置、宽度和高度（参见[图14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕frame的中间x位置，midY给出了中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-4217
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4219
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint并将其赋值给精灵的位置属性，从而将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4220
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以包含两个值，一个表示*x*，一个表示*y*，这在处理2D游戏中的屏幕坐标时非常方便，因为一切都通过x和y位置来定位。
- en: '**NOTE**'
  id: totrans-4221
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4222
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自* Core Graphics框架*，这是一个用于图形的Apple框架。你会注意到这种命名系统在Swift中非常常见——类或结构体的前两到三个字母通常会告诉你这个对象的用途或来源。例如，所有的SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4223
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用addChild(_:)函数将背景图像添加到场景中。这个精灵现在是场景的*子节点*，意味着它附属于这个场景。例如，如果场景发生变化（变大、变小或消失），这个子节点精灵也会受到影响。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为场景的子节点或另一个精灵的子节点被添加。每当你添加一个精灵时，重要的是要考虑这个精灵的父节点应该是什么。例如，滑冰精灵是场景的子节点，但如果我们想在滑冰精灵上添加可互换的帽子，我们会使用帽子精灵，这个帽子精灵是滑冰精灵的子节点。这样，每当滑冰精灵跳跃时，帽子会跟着滑冰精灵一起动，我们就不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4225
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个既能在竖屏模式又能在横屏模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择其中一种。由于我们的游戏是一个横向滚动的动作游戏，因此横屏模式（设备侧置，如[图14-8](text00026.html#ch14fig8)所示）是最合理的选择。
- en: '![](Image00280.jpg)'
  id: totrans-4226
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4227
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏模式下的展示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，你会注意到它可能默认是纵向方向。让我们更改项目设置，以便游戏仅在横向模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器顶部，旁边有一个蓝色图标，正如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4229
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4230
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4231
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一列项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4232
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4233
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中“纵向”选项，保留两个横向方向选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上没有看到项目和目标列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。该列表将显示，图标会变成蓝色，表示列表区域现在已显示。确保选择了**SchoolhouseSkateboarder**目标。现在找到**纵向**复选框并取消勾选，保持横向方向选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4235
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横向方向启动。我们已经接近了，但背景图片仍未填满整个屏幕。稍后我们将看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经以横向方向运行，你需要确保模拟器也处于横向方向。要旋转它，从模拟器菜单中选择**硬件** ▸ **右旋**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4237
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4238
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们需要决定支持哪些设备和屏幕分辨率。你支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要做额外的工作，以确保你创建的艺术资源能够在每个设备上正确显示。相比像我们生日追踪器这样的基于
    UIKit 的应用，游戏通常在这方面需要更多的工作，因为如果你仅仅通过缩放图像，游戏的艺术资源会看起来被拉伸。为了避免这个问题，你需要为每个你想支持的设备准备不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-4241
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4242
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 为图像文件命名提供了一个系统，帮助你区分不同设备使用的图像。例如，假设你想在游戏中添加一张滑冰者的图片，而你有一个宽 100 像素、高 100
    像素（100×100）的滑冰者图像文件。你会将该图像命名为*skater.png*。你还需要创建一个名为*[skater@2x.png](mailto:skater@2x.png)*的图像文件，尺寸为
    200×200 像素，另一个名为*[skater@3x.png](mailto:skater@3x.png)*的图像文件，尺寸为 300×300 像素。这三张图像应该是同一张图像的不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需引用图像文件名
    skater，只要你在项目中正确命名了这些图像，Xcode 会自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-4244
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4245
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有后缀，例如* @2x *或* @3x*。没有后缀的图像，如*skater.png*，被视为 1x 图像。你只需要为老旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 大小的图像，因为这些设备没有 Retina 屏幕。因此，我们所有的图像文件都会有* @2x
    *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名分别是*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会发现
    Xcode 将这两张图像分组在一起。如果你同时将图像拖入 Xcode 的资源目录，Xcode 会根据图像的命名自动识别它们是同一张图像的不同大小，并将它们分组在一起。参见[图
    14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4247
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4248
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4249
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从背景图像部分继续之前，还有最后一项准备工作要处理。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。在这个项目中，我们不会使用场景编辑器，因此我们需要添加代码来确保场景的大小设置正确。
- en: '![](Image00287.jpg)'
  id: totrans-4250
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4251
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像未能填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4252
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4253
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE190]'
  id: totrans-4254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4255
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4256
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该会填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了关于 SpriteKit 的知识。你了解了如何在 Xcode 中创建游戏项目并导入资源，例如图片。你还学习了如何通过标准的文件命名规范来支持不同设备的屏幕分辨率，并了解了在游戏中选择所需图片类型的方法。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个带有所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切开始移动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-4260
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  id: totrans-4261
  prefs: []
  type: TYPE_NORMAL
  zh: 场景类通常会有设置函数（一次性执行的操作）、游戏循环或更新函数（在游戏过程中反复执行的操作），以及用户交互函数（仅在用户点击或滑动时执行的操作）。
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-4262
  prefs: []
  type: TYPE_NORMAL
  zh: 设置函数 didMove(to:) 在游戏开始时调用。它非常适合用于设置场景的代码，比如添加初始精灵或设置玩家的分数和生命值。它类似于你在[第10章](text00021.html#ch10)中使用的用于设置
    AddBirthdayViewController 中日期选择器的 viewDidLoad() 方法，并且只会被调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-4263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们需要设置场景的 anchorPoint。将以下代码添加到 didMove(to:) 方法中（灰色行表示现有代码，用于放置）：
- en: '[PRE191]'
  id: totrans-4264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '![](Image00276.jpg)'
  id: totrans-4265
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-4266
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉把一张纸钉在软木板上时，图钉就是锚点。纸张会定位在图钉的位置，如果纸张旋转，它将围绕图钉旋转。这就是anchorPoint属性在SpriteKit中的工作方式。游戏模板中的GameScene将其锚点设置在场景的中央，但我们希望锚点位于场景的左下角，因此我们将其设置为CGPoint.zero，即(0,
    0)。对于某些游戏，例如太空射击游戏，将锚点设置在场景中央会更好。但对于我们的游戏，地面位于屏幕底部，将锚点移到左下角会更方便。有关各种锚点的示例，请参见[图14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-4267
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-4268
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点从(0, 0)到(1, 1)的不同位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-4269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x坐标为0的位置时，它将位于屏幕的左边缘。当我们将精灵放置在y坐标为0的位置时，它将位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-4270
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-4271
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步一步地构建每个项目的代码文件，最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获得。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4272
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4273
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，从而改变精灵的定位方式以及旋转方式。有关使用不同锚点旋转精灵的示例，请参见[图14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-4274
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4275
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4276
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用其中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图片，请将以下代码行添加到didMove(to:)函数中：
- en: '[PRE192]'
  id: totrans-4278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析我们刚才添加的五行代码。第➊行创建了一个名为background的精灵，使用的是* [background@2x.png](mailto:background@2x.png)*
    文件或* [background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已被添加到资源目录中，Xcode会自动选择合适的文件。你只需要在代码中引用它为“background”或“background.png”。要了解Xcode如何选择合适的文件，请参阅“[针对不同屏幕分辨率调整图片大小](text00026.html#ch14lev1sec7)”在[第213页](text00026.html#page_213)的内容。请注意，变量名不必与图像名匹配——你可以为变量名使用任何你想要的名称。然而，图像名必须与项目中资源目录里添加的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们会创建一个SKSpriteNode，就像这里一样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4280
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋行和第➌行创建了常量xMid和yMid，它们表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个描述其在屏幕上位置的frame。frame有x位置、y位置、宽度和高度（参见[图
    14-7](text00026.html#ch14fig7)）。midX属性给我们屏幕框架的中间x位置，midY给我们中间的y位置。
- en: '![](Image00279.jpg)'
  id: totrans-4281
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4282
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4283
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过创建一个CGPoint并使用xMid和yMid将其设置为背景图像的中心位置，并将其赋值给精灵的position属性。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4284
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，它包含两个CGFloat值，分别表示x和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以包含两个值，一个用于*x*，另一个用于*y*，这使得在2D游戏中处理屏幕坐标变得非常方便，因为所有的物体都使用x和y位置来定位。
- en: '**NOTE**'
  id: totrans-4285
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4286
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何内容都来自于* Core Graphics框架*，这是一个用于图形处理的苹果框架。你会在Swift中经常看到这种命名系统——类或结构体的前两到三个字母通常告诉你该对象的用途或来源。例如，所有SpriteKit类，比如*
    SKSpriteNode *，都以* SK *开头。 '
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4287
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图片添加到场景中。这个精灵现在是场景的*子节点*，这意味着它被附加到这个场景上。例如，如果场景发生增长、缩小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景总是父对象，每个精灵都是场景的子节点或其他精灵的子节点。每当你添加一个精灵时，重要的是要考虑这个精灵应该归属于哪个父节点。例如，滑冰精灵是场景的子节点，但如果我们想为滑冰者添加可更换的帽子，我们会使用一个帽子精灵，并将它设为滑冰精灵的子节点。这样，滑冰者跳跃时，帽子会跟着滑冰者移动，我们就不必单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4289
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持纵向和横向模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择其中一种。由于我们的游戏是一个横向滚动的动作游戏，横向模式（设备横放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-4290
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4291
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在纵向和横向模式下的外观对比* '
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能默认是竖屏方向。我们需要更改项目设置，让游戏只在横屏模式下运行。进入项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如你在[图14-9](text00026.html#ch14fig9)中看到的那样。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4293
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4294
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目条目在项目导航器中访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4295
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4296
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4297
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消勾选Portrait选项，保留两个横屏方向选项的勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标列表，点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此时列表会显示出来，图标会变成蓝色，表示列表区域已经显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**Portrait**复选框并取消勾选，保留横屏方向选项的勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4299
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经接近了，但背景图像还没有填满屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4300
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在已在横屏方向运行，你需要确保模拟器也处于横屏方向。要旋转它，从模拟器菜单中选择**Hardware** ▸ **Rotate Right**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4301
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4302
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4304
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你需要处理的不同屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。相比基于
    UIKit 的应用程序（如我们的生日追踪器），游戏通常在这方面需要更多的工作，因为如果只是简单地缩放，游戏的艺术图像会显得拉伸。为了避免这个问题，你必须为每个你想支持的设备准备一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-4305
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4306
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个命名图像文件的系统，可以帮助你区分哪些图像适用于哪些设备。例如，假设你想在游戏中添加一个滑板手的图像，并且你有一个宽 100 像素、高
    100 像素（100×100）的滑板手图像文件。你应该将这个图像命名为 *skater.png* 。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，大小为 200×200 像素，以及另一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，大小为 300×300
    像素。这三个文件应该是同一图像的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件将自动被使用。在你的代码中，你只需引用文件名 skater ，只要你在项目中正确命名了图像，Xcode 就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4307
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 及以上的设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-4308
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4309
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被视为 1x 图像。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 大小的图像，这些设备没有 Retina 显示屏。因此，我们所有的图像文件都会有 *@2x*
    或 *@3x* 后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*
    。如果你查看 *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图像分组在一起。如果你同时将不同尺寸的图像拖到 Xcode 的资源目录中，Xcode
    会根据文件命名自动识别它们是同一图像的不同尺寸，并将它们分组在一起。见[图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4311
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4312
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图像在资源目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4313
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一步准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为游戏模板在处理游戏场景大小时的方式。游戏场景的大小将根据我们项目中包含的 *GameScene.sks*
    场景编辑器文件中的设置来确定。由于我们在这个项目中不会使用场景编辑器，因此我们需要添加代码来确保场景的大小合适。
- en: '![](Image00287.jpg)'
  id: totrans-4314
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4315
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4316
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4317
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE193]'
  id: totrans-4318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4319
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了GameScene类的一个实例并将其显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置了新场景的大小，以便它填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4320
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《学园滑板》游戏，并学习了SpriteKit。你学习了如何在Xcode中创建一个游戏项目并导入资产，如图像。你还了解了如何通过标准的文件命名方法支持各种设备屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编程实现一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，使一切都开始移动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-4324
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  id: totrans-4325
  prefs: []
  type: TYPE_NORMAL
  zh: setup函数didMove(to:)在游戏首次启动时被调用。它非常适合设置场景的代码，比如添加初始精灵或设置玩家的分数和生命值的代码。它类似于你在[第10章](text00021.html#ch10)中用于设置AddBirthdayViewController中的日期选择器的viewDidLoad()方法，并且只会调用一次。
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-4326
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们必须先设置场景的anchorPoint。将这一行代码添加到didMove(to:)方法中（灰色的代码行表示一些现有代码，用于放置位置）：
- en: '[PRE194]'
  id: totrans-4327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '![](Image00276.jpg)'
  id: totrans-4328
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-4329
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的anchorPoint决定了精灵在场景中的位置。当你用图钉将一张纸钉在软木板上时，图钉就是anchorPoint。纸张将被定位在你放置图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是SpriteKit中anchorPoint属性与精灵和场景的作用方式。Game模板中的GameScene的anchorPoint位于场景的中央，但我们希望anchorPoint位于场景的左下角，因此我们将其设置为CGPoint.zero，或者(0,
    0)。对于某些游戏，比如太空射击游戏，将anchorPoint放在场景中央会更好。但对于我们的游戏，其中地面位于屏幕底部，将anchorPoint移至左下角将使得操作更加方便。请参见[图14-5](text00026.html#ch14fig5)了解各种anchorPoint的插图。
- en: '![](Image00277.jpg)'
  id: totrans-4330
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-4331
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：从(0, 0)到(1, 1)的各种anchorPoint位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-4332
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x坐标为0的位置时，它会位于屏幕的左边缘。而当我们将精灵放置在y坐标为0的位置时，它会位于屏幕的下边缘。
- en: '**NOTE**'
  id: totrans-4333
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-4334
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步一步地为项目构建每个代码文件，最终版本可以在* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获得。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4335
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4336
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。请参见[图14-6](text00026.html#ch14fig6)，其中展示了使用不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-4337
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4338
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4339
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载背景图像，在didMove(to:)函数中添加以下代码：
- en: '[PRE195]'
  id: totrans-4341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析刚才添加的五行代码。第➊行创建了一个名为background的精灵，使用的是*【background@2x.png】(mailto:background@2x.png)*文件或*【background@3x.png】(mailto:background@3x.png)*文件。两个文件早些时候已经被添加到资源目录中，Xcode会自动选择合适的文件。你只需在代码中引用它，写作“background”或“background.png”。要了解Xcode如何选择合适的文件，请参见《[针对不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)》，并参考[第213页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以为变量选择任何名称。但是，图像名必须与项目中添加到资源目录的文件名一致。SKSpriteNode是SpriteKit中的精灵类，所以当我们在游戏中创建精灵时，我们会创建一个SKSpriteNode，就像这里做的一样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4343
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们将表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它们在屏幕上的位置。框架有x坐标、y坐标、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给出屏幕框架的中间x坐标，midY给出屏幕框架的中间y坐标。
- en: '![](Image00279.jpg)'
  id: totrans-4344
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4345
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4346
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint，并将其分配给精灵的位置属性，从而将背景图像的位置设置为屏幕中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4347
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 和 y 坐标。在处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个 CGPoint 可以容纳两个值，一个用于*x*，另一个用于*y*，这使得在 2D 游戏中处理屏幕坐标非常方便，因为在 2D
    游戏中，所有物体的位置都使用 x 和 y 坐标来表示。
- en: '**NOTE**'
  id: totrans-4348
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4349
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的内容都来自于* Core Graphics framework*，这是一个用于图形处理的苹果框架。你会在 Swift 中经常看到这种命名方式——一个类或结构体的前两三个字母通常告诉你这个对象的用途或来源。例如，所有的
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4350
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 这一行通过调用 addChild(_:) 函数将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它附加在这个场景上。例如，如果场景发生变化，缩小或消失，这个子精灵也会相应变化。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵都是作为场景的子对象或另一个精灵的子对象添加的。每次添加精灵时，考虑它的父对象应该是什么非常重要。例如，滑板精灵是场景的子对象，但如果我们想在滑板车上添加可互换的帽子，我们会使用一个帽子精灵，它是滑板精灵的子对象。这样，每当滑板者跳跃时，帽子会保持在滑板者头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何进行游戏：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4352
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，并选择其中一个。由于我们的游戏是一个水平滚动的动作游戏，横屏方向（设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-4353
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4354
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏模式下的展示效果。*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行该项目，使用 iPhone 7 模拟器，你会注意到它可能默认使用竖屏方向。我们来更改项目设置，使游戏只在横屏下运行。前往项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4356
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4357
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4358
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4359
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4360
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选竖屏选项，同时保持两个横屏方向选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上没有看到项目和目标的列表，请点击窗口左上角的方形图标，如 [图 14-10](text00026.html#ch14fig10) 所示。列表会出现，图标会变成蓝色，表示列表区域现在已经显示。确保选中了
    **SchoolhouseSkateboarder** 目标。然后找到 **Portrait** 复选框并取消选中它。保持横屏方向的选项选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4362
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们离目标更近了，但背景图像还没有完全填充屏幕。稍后我们将看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4363
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在以横屏方向运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择 **Hardware** ▸ **Rotate Right**，如
    [图 14-11](text00026.html#ch14fig11) 所示。
- en: '![](Image00284.jpg)'
  id: totrans-4364
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4365
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4367
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你需要处理的屏幕大小就越多，这意味着你需要额外的工作来确保你创建的图形资源在每个设备上都能正确显示。游戏比基于
    UIKit 的应用（如我们的生日跟踪器）更需要在这方面付出努力，因为如果只是简单地缩放，游戏图像会显得拉伸变形。为避免这个问题，你需要为每个你想支持的设备准备一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-4368
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4369
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套图像文件命名系统，帮助你区分不同设备的图像。例如，假设你想为游戏添加一张滑冰者的图片，并且你有一张宽 100 像素、高 100 像素（100×100）的滑冰者图像文件。你会将该图像命名为
    *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)* 的图像文件，尺寸为 200×200
    像素，再创建另一张名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像文件，尺寸为 300×300 像素。这三张文件应该是同一图像的三种不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需要引用文件名
    skater，只要你在项目中正确命名了图像，Xcode 就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4370
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-4371
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4372
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，比如* skater.png*，被认为是 1x 图像。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini，具有非视网膜显示屏的设备）提供 1x 尺寸的图像。因此，我们所有的图像文件都会有 *@2x* 或 *@3x*
    后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资产目录，你会注意到 Xcode 将这两张图像组合在了一起。如果你同时将不同大小的图像拖入 Xcode 资产目录，Xcode
    会自动识别它们是同一图像的不同尺寸，并将它们组合在一起，这是因为它们的命名方式。请参见 [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4374
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4375
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资产目录中被组合在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4376
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作要做。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如 [图
    14-13](text00026.html#ch14fig13) 所示。这是因为 Game 模板在设置游戏场景大小时的处理方式。游戏场景的大小将根据包含在我们项目中的
    *GameScene.sks* 场景编辑器文件中的设置来确定。由于我们在这个项目中不会使用场景编辑器，因此需要添加代码，以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-4377
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4378
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填充整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4379
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件并找到 `viewDidLoad()` 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4380
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE196]'
  id: totrans-4381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4382
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()` 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主要场景，我们希望它始终填充整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，使其填充整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4383
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4385
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《学校滑板》游戏，并学习了 SpriteKit。你学习了如何在 Xcode 中创建游戏项目并导入资源，比如图像。你还学习了如何通过标准文件命名惯例来支持不同设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了SpriteKit游戏项目，并准备好所需的资源，解决了屏幕方向和分辨率的问题，接下来是编写一些动作程序。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切开始移动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-4387
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  id: totrans-4388
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将背景图像添加到场景之前，我们必须设置场景的anchorPoint。将这行代码添加到didMove(to:)方法中（灰色的行表示一些现有的代码，便于放置）：
- en: '[PRE197]'
  id: totrans-4389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '![](Image00276.jpg)'
  id: totrans-4390
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-4391
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张会根据你放置图钉的位置来定位，如果纸张旋转，它会围绕图钉旋转。这正是anchorPoint属性在SpriteKit中与精灵和场景的工作方式。Game模板的GameScene将其锚点设置在场景的中央，但我们希望锚点位于场景的左下角，因此我们将其设置为CGPoint.zero，即(0,
    0)。对于一些游戏，例如太空射击游戏，将锚点放在场景中心更为合适。但对于我们的游戏，地面位于屏幕底部，将锚点移动到左下角会让操作更方便。请参见[图14-5](text00026.html#ch14fig5)，了解不同锚点的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-4392
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-4393
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-4394
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在x位置为0时，它将位于屏幕的左边缘。当我们将一个精灵放置在y位置为0时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-4395
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-4396
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个项目的代码文件。最终版本可从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4397
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4398
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的定位方式以及旋转方式。请参见[图14-6](text00026.html#ch14fig6)，查看旋转精灵时使用不同锚点的示例。
- en: '![](Image00278.jpg)'
  id: totrans-4399
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4400
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4401
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点放在中心。我们不会改变任何精灵的锚点，因此我们将始终使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要加载我们的背景图像，请将以下代码行添加到didMove(to:)函数中：
- en: '[PRE198]'
  id: totrans-4403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4404
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析我们刚才添加的五行代码。第 ➊ 行创建了一个名为 background 的精灵，使用的是* [background@2x.png](mailto:background@2x.png)*
    文件或* [background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已经添加到资源目录中，Xcode
    会自动选择合适的文件。你只需在代码中将其引用为 "background" 或 "background.png" 。要了解 Xcode 如何选择合适的文件，请参见
    “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)” [第 213 页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以为变量名选择任何你喜欢的名字。但是，图像名必须与添加到项目资源目录中的文件名匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们实际上是在创建一个 SKSpriteNode ，就像我们在这里做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4405
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➋ 和 ➌ 行创建了常量 xMid 和 yMid，它们将表示屏幕的中心位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它在屏幕上的位置。一个框架有一个
    x 坐标，一个 y 坐标，一个宽度和一个高度（见 [图 14-7](text00026.html#ch14fig7) ）。midX 属性给我们提供了屏幕框架中
    x 坐标的中间位置，midY 给我们提供了 y 坐标的中间位置。
- en: '![](Image00279.jpg)'
  id: totrans-4406
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4407
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4408
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➍ 行通过使用 xMid 和 yMid 创建一个 CGPoint，并将其赋值给精灵的 position 属性，从而将背景图像的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4409
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，表示 x 和 y 坐标。在处理屏幕坐标时，通常使用 CGFloat 数据类型，而不是 Float
    或 Double。一个单独的 CGPoint 可以包含两个值，一个用于 *x* ，一个用于 *y* ，这使得它在处理 2D 游戏中的屏幕坐标时非常方便，因为所有的定位都是基于
    x 和 y 坐标。
- en: '**NOTE**'
  id: totrans-4410
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4411
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何内容都来自* Core Graphics framework*，这是一个用于图形处理的 Apple 框架。你会在 Swift
    中经常看到这种命名系统——一个类或结构体的前两到三个字母通常能告诉你该对象的用途或来源。例如，所有的 SpriteKit 类，如* SKSpriteNode
    *，都以* SK *开头。 '
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4412
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，这意味着它附加在这个场景上。例如，如果场景发生变化（如变大、缩小或消失），这个子精灵也会跟随变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都是作为该场景的子对象或另一个精灵的子对象添加的。每当你添加一个精灵时，重要的是要思考这个精灵的父对象应该是什么。例如，滑板精灵是场景的子对象，但如果我们想给滑板者加上可更换的帽子，我们会使用一个帽子精灵，它是滑板者精灵的子对象。这样，每当滑板者跳跃时，帽子会保持在滑板者头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4414
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个既能在竖屏又能在横屏模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（设备横着放，如[图
    14-8](text00026.html#ch14fig8)所示）是最合适的。
- en: '![](Image00280.jpg)'
  id: totrans-4415
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4416
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏与横屏模式下的表现*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用iPhone 7模拟器，你会发现它可能默认是竖屏模式。让我们更改项目设置，让游戏只在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如[图
    14-9](text00026.html#ch14fig9)中所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4418
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4419
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4420
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4421
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4422
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选纵向选项，保留横向选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到屏幕上的项目和目标列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。列表将会出现，图标会变成蓝色，表示列表区域现在已经显示。确保选中**SchoolhouseSkateboarder**目标。现在找到**纵向**复选框并取消勾选，保留横向模式选项已勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4424
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会发现它以横屏模式启动。我们越来越接近了，但背景图像仍然没有填满整个屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **旋转右侧**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4426
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4427
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4429
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，首先应该决定支持哪些设备和屏幕分辨率。支持的设备越多，就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。相比于像我们的生日追踪器这样基于
    UIKit 的应用程序，游戏在这方面通常需要更多的努力，因为如果只是简单地缩放，游戏艺术图像会显得拉伸变形。为避免这种问题，你需要为每个想要支持的设备准备不同的图像资源。
- en: '![](Image00285.jpg)'
  id: totrans-4430
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4431
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套图像文件命名系统，帮助你辨别每个图像适用于哪些设备。例如，假设你想要为游戏添加一张滑板选手的图像，并且你有一个宽 100 像素、高 100
    像素（100×100）的滑板选手图像文件。你会将该图像命名为 *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)*
    的 200×200 像素图像，以及一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的 300×300 像素图像。这三张文件应为同一图像的三种不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需要引用图像文件名
    skater，只要你在项目中正确命名了这些图像，Xcode 会自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4432
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-4433
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4434
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被认为是 1x 图像。你只需要为那些具有非
    Retina 显示屏的旧设备（例如 iPhone 3GS 或第一代 iPad mini）提供 1x 尺寸的图像。因此，我们所有的图像文件都会有* @2x *或*
    @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图像组合在一起。如果你同时将这些图像拖入 Xcode 资源目录，Xcode 会自动识别出它们是同一图像的不同尺寸，并将它们归类在一起。这是因为它们的命名规则。参见
    [图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4436
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4437
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：多个尺寸的图像被组合在资源目录中。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4438
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还有最后一点准备工作要做。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图片没有填满整个屏幕，如[图 14-13](text00026.html#ch14fig13)所示。这是因为Game模板处理游戏场景大小的方式。游戏场景的大小将根据包含在我们项目中的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在这个项目中不使用场景编辑器，因此需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-4439
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4440
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4441
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4442
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE199]'
  id: totrans-4443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4444
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4445
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图片现在应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4447
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《学校滑板手》游戏并了解了SpriteKit。你学习了如何在Xcode中创建一个游戏项目，并将资产（如图片）导入项目中。你还了解了如何通过标准文件命名惯例来支持不同设备的屏幕分辨率，并学习了如何选择游戏中所需的图像类型。最后，你创建并展示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个SpriteKit游戏项目，并准备好了所需资源，同时解决了屏幕方向和分辨率的问题，接下来是编写一些动作代码。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-4449
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '[PRE200]'
  id: totrans-4450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '![](Image00276.jpg)'
  id: totrans-4451
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-4452
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的位置。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张将放置在你放置图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是anchorPoint属性在SpriteKit中如何与精灵和场景配合使用的方式。游戏模板的GameScene将其锚点设置在场景的中央，但我们希望锚点位于场景的左下角，因此我们将其设置为CGPoint.zero，或者(0,
    0)。对于某些游戏，例如太空射击游戏，将锚点放在场景的中央会更好。但对于我们的游戏来说，地面位于屏幕底部，将锚点移至左下角将使操作更加简便。请参见[图14-5](text00026.html#ch14fig5)，了解不同锚点位置的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-4453
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-4454
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-4455
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将一个精灵放置在x坐标为0的位置时，它将位于屏幕的左边缘。当我们将一个精灵放置在y坐标为0的位置时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-4456
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-4457
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将按步骤逐步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获得。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4458
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4459
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。请参见[图14-6](text00026.html#ch14fig6)，了解如何通过不同的锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-4460
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4461
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4462
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4463
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要加载我们的背景图像，请将以下代码行添加到didMove(to:)函数中：
- en: '[PRE201]'
  id: totrans-4464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4465
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析刚才添加的五行代码。第➊行创建了一个名为background的精灵，使用* [background@2x.png](mailto:background@2x.png)*文件或*
    [background@3x.png](mailto:background@3x.png)*文件。这两个文件之前已添加到资源目录中，Xcode会自动选择正确的文件。你只需在代码中将其引用为“background”或“background.png”。要了解Xcode如何选择正确的文件，请参见“[为不同屏幕分辨率调整图片大小](text00026.html#ch14lev1sec7)”第[213页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以随意选择变量名。然而，图像名必须与项目中添加到资源目录的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4466
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述它在屏幕上的位置。一个frame有x坐标、y坐标、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给出屏幕frame的中间x坐标，midY则给出屏幕frame的中间y坐标。
- en: '![](Image00279.jpg)'
  id: totrans-4467
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4468
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4469
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过创建一个使用xMid和yMid的CGPoint，并将其赋值给精灵的position属性，将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4470
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，它包含两个CGFloat值，分别表示x和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个单独的CGPoint可以包含两个值，一个是*x*坐标，一个是*y*坐标，这使得在2D游戏中处理屏幕坐标变得更加方便，因为所有的物体都通过x和y坐标来定位。
- en: '**NOTE**'
  id: totrans-4471
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4472
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自于*Core Graphics框架*，这是Apple用于图形处理的框架。你会在Swift中经常看到这种命名方式——类或结构体的前两个或三个字母通常会告诉你该对象的用途或来源。例如，所有SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4473
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它与这个场景绑定在一起。例如，如果场景发生变化（如变大、变小或消失），这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，而每个精灵都是作为该场景的子对象或另一个精灵的子对象添加的。每次添加精灵时，重要的是要考虑该精灵的父对象应该是什么。例如，滑冰者精灵是场景的子对象，但如果我们想给滑冰者添加可更换的帽子，我们会使用一个作为滑冰者精灵子对象的帽子精灵。这样，每当滑冰者跳跃时，帽子会随滑冰者一起移动，而我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4475
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时适应竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择其中一种。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（设备横置，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-4476
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4477
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏与横屏模式下的表现*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4478
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，你会注意到它可能默认以竖屏模式启动。让我们修改项目设置，使游戏只能在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4479
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4480
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4481
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4482
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4483
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选Portrait选项，保持两个横屏方向选项已选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上没有看到项目和目标的列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。这个列表将会显示出来，图标会变成蓝色，表示列表区域现在已经显示。确保**SchoolhouseSkateboarder**目标已被选中。现在找到**Portrait**复选框并取消勾选。保持横屏方向选项已选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4485
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们越来越接近目标了，但背景图像还没有填充整个屏幕。稍后我们会看看如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4486
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在已经以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转模拟器，请从模拟器菜单中选择**Hardware** ▸ **Rotate Right**，如[图
    14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4487
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4488
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4490
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理不同的屏幕大小，这意味着你需要额外的工作，确保你创建的艺术资源能够在每个设备上正确显示。与像我们的生日追踪器这样的UIKit应用程序相比，游戏通常在这一领域需要更多的工作，因为如果你只是简单地放大或缩小，游戏艺术作品看起来会被拉伸。为了避免这个问题，你必须为每个你想支持的设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-4491
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4492
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个系统来命名图片文件，以帮助你区分不同设备的图片。例如，假设你想为游戏添加一个滑板车图像，并且你有一张宽100像素、高100像素的滑板车图片（100×100）。你会将这张图片命名为*skater.png*。你还需要创建一张名为*[skater@2x.png](mailto:skater@2x.png)*，尺寸为200×200像素的图片，以及一张名为*[skater@3x.png](mailto:skater@3x.png)*，尺寸为300×300像素的图片。这三张文件应该是同一张图片的三种不同尺寸。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件将自动被使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件将自动被使用。在你的代码中，你只需引用文件名skater，只要你在项目中正确命名了图片，Xcode会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4493
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Schoolhouse Skateboarder，我们将支持从iPhone 4及以后的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750，和1920×1080。
- en: '**NOTE**'
  id: totrans-4494
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4495
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，例如* @2x *或* @3x*。没有后缀的图片，如* skater.png*，被视为1x图片。你只需要为那些旧设备（如iPhone
    3GS或第一代iPad mini）提供1x尺寸的图片，这些设备没有视网膜显示屏。因此，我们的所有图片文件都会带有* @2x *或* @3x *的后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图片分组在一起。如果你同时将图片拖入Xcode资源目录，Xcode会根据文件名自动识别它们是同一张图片的不同尺寸，并将它们归为一组。参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4497
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4498
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图片在资源目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4499
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完背景图片后，我们还有最后一步准备工作。你可能注意到，当你在iPhone 7模拟器中运行游戏时，背景图片没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景尺寸的方式。游戏场景的尺寸将根据项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在这个项目中不使用场景编辑器，因此需要添加代码来确保场景的尺寸正确。
- en: '![](Image00287.jpg)'
  id: totrans-4500
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4501
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4502
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的尺寸：
- en: '*GameViewController.swift*'
  id: totrans-4503
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE202]'
  id: totrans-4504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4505
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并将其显示出来。由于 GameScene 是我们游戏的主要场景，我们希望它始终填充整个屏幕。我们在此处添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4506
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目，背景图像现在应该会填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4508
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《Schoolhouse Skateboarder》游戏并了解了 SpriteKit。你学会了如何在 Xcode 中创建一个游戏项目并导入资产，比如图片。你还了解了通过标准文件命名方式支持各种设备屏幕分辨率的做法，并学会了如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4509
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作程序。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并让玩家点击屏幕使她跳跃。
- en: '![](Image00288.jpg)![](Image00276.jpg)'
  id: totrans-4510
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00276.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-4511
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位方式。当你用图钉将一张纸钉在软木板上时，图钉就是锚点。纸张的位置将取决于图钉的位置，如果纸张旋转，它将围绕图钉旋转。这正是
    SpriteKit 中 anchorPoint 属性与精灵和场景的作用方式。Game 模板中的 GameScene 场景的锚点位于场景的中央，但我们希望将锚点设置在场景的左下角，因此我们将其设置为
    CGPoint.zero，即 (0, 0)。对于一些游戏，比如太空射击游戏，将锚点放在场景中央可能更好。但对于我们的游戏，地面位于屏幕底部，将锚点移到左下角会让操作更方便。有关各种锚点的说明，请参见[图
    14-5](text00026.html#ch14fig5)。
- en: '![](Image00277.jpg)'
  id: totrans-4512
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-4513
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点位置的各种设置，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-4514
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 位置为 0 时，它将位于屏幕的左边缘。当我们将精灵放置在 y 位置为 0 时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-4515
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-4516
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步一步地构建每个项目的代码文件，最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4517
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4518
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，从而改变该精灵的定位方式以及旋转方式。有关不同锚点下旋转精灵的示例，请参见[图 14-6](text00026.html#ch14fig6)。
- en: '![](Image00278.jpg)'
  id: totrans-4519
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4520
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它将如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4521
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点放在中心。我们不会更改任何精灵的锚点，因此我们将始终使用精灵的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4522
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要加载我们的背景图像，请在 didMove(to:) 函数中添加以下代码行：
- en: '[PRE203]'
  id: totrans-4523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4524
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析我们刚刚添加的五行代码。➊ 这一行创建了一个名为 background 的精灵，使用的是 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。这两个文件之前已经添加到资源目录中，Xcode
    会自动选择正确的文件。你只需在代码中引用它为 "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参见
    “[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)” 在 [第 213 页](text00026.html#page_213)。请注意，变量名不需要与图像名匹配——你可以随意选择变量名。然而，图像名必须与项目中添加到资源目录的文件名匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个 SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4525
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 和 ➌ 这两行代码创建了常量 xMid 和 yMid，它们表示屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它在屏幕上的位置。一个框架有
    x 坐标、y 坐标、宽度和高度（参见 [图 14-7](text00026.html#ch14fig7)）。midX 属性给我们屏幕框架的中间 x 坐标，而
    midY 给我们中间的 y 坐标。
- en: '![](Image00279.jpg)'
  id: totrans-4526
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4527
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4528
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ 这一行通过使用 xMid 和 yMid 创建一个 CGPoint，并将其赋值给精灵的 position 属性，从而将背景图像的位置设置为屏幕的中心。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4529
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 和 y 坐标。当处理屏幕坐标时，通常使用 CGFloat 数据类型，而不是 Float
    或 Double。一个 CGPoint 可以保存两个值，一个是 *x*，另一个是 *y*，这使得它在 2D 游戏中处理屏幕坐标时非常方便，因为所有的定位都使用
    x 和 y 坐标。
- en: '**NOTE**'
  id: totrans-4530
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4531
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的所有内容来自* Core Graphics 框架*，这是 Apple 用于图形的框架。你会在 Swift 中经常看到这种命名系统——类或结构体的前两到三个字母通常告诉你该对象的用途或来源。例如，所有
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4532
  prefs: []
  type: TYPE_NORMAL
  zh: 在➎行，通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它附加在这个场景上。例如，如果场景增长、缩小或消失，这个子精灵也会如此。在SpriteKit游戏中，场景始终是父对象，所有精灵都是作为该场景的子对象或另一个精灵的子对象添加的。每次添加精灵时，重要的是要考虑该精灵的父对象应该是什么。例如，滑板精灵是场景的子对象，但如果我们想在滑板上加一个可互换的帽子，我们会使用一个帽子精灵，它是滑板精灵的子对象。这样，每当滑板跳跃时，帽子就会留在滑板上，我们就不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4534
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持纵向和横向模式的游戏需要更多的工作，因此最好决定哪个方向最适合你的游戏，并仅选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，横屏方向（即设备横着放置，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-4535
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4536
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在纵向和横向方向上的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4537
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，你会发现它可能默认使用纵向方向。让我们更改项目设置，让游戏只在横屏模式下运行。前往项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4538
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4539
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4540
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4541
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4542
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选纵向选项，同时保持横向方向选项被勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4543
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在你的屏幕上看不到项目和目标的列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此列表将会显示，并且图标会变成蓝色，表示该列表区域现在已显示。确保选择了**SchoolhouseSkateboarder**目标。现在找到**Portrait**复选框并取消勾选，保持横屏方向选项被勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4544
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会发现它以横屏方向启动。我们离目标更近了，但背景图像还没有填满屏幕。稍后我们将看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4545
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏现在以横屏方向运行时，你需要确保模拟器也处于横屏方向。要旋转它，从模拟器的菜单中选择**硬件** ▸ **向右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4546
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4547
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4549
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们需要决定支持哪些设备和屏幕分辨率。你支持的设备越多，你需要处理的屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的图像资源在每个设备上都能正确显示。游戏在这方面通常比基于UIKit的应用程序（如我们的生日跟踪器）需要更多的工作，因为如果只是简单地缩放图像，游戏艺术作品会看起来被拉伸。为了避免这个问题，你需要为每个你想要支持的设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-4550
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4551
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个命名图片文件的系统，帮助你区分不同设备的图片。例如，假设你想在游戏中添加一个滑冰者的图像，并且你有一张滑冰者图片文件，宽100像素，高100像素（100×100）。你应该将这张图片命名为*skater.png*。你还需要创建一张名为*[skater@2x.png](mailto:skater@2x.png)*的图片，尺寸为200×200像素，另外还有一张名为*[skater@3x.png](mailto:skater@3x.png)*的图片，尺寸为300×300像素。这三张文件应该是相同的图片，只是尺寸不同。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件会自动被使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件会自动被使用。在你的代码中，你只需引用文件名skater，只要你在项目中正确命名了图片，Xcode会自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4552
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从iPhone 4及以上的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-4553
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4554
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，例如*@2x*或*@3x*。没有后缀的图片，如*skater.png*，被认为是1x图像。你只需要为旧设备（如iPhone
    3GS或第一代iPad mini）包含1x尺寸的图片，因为这些设备没有Retina显示屏。因此，我们所有的图片文件都会有*@2x*或*@3x*后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图片归为一组。如果你同时将图片拖放到Xcode的资源目录中，Xcode会根据文件命名自动识别它们是同一张图片的不同尺寸，并将它们分组在一起。参见[图
    14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4556
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4557
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图片在资源目录中分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4558
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还有最后一点准备工作。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图片并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板处理游戏场景大小的方式。游戏场景的大小将基于*GameScene.sks*场景编辑器文件中的设置，而该文件已包含在我们的项目中。由于我们在这个项目中不使用场景编辑器，所以需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-4559
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4560
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4561
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4562
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE204]'
  id: totrans-4563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4564
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了显示视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4565
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图片应该已经填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4567
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并了解了SpriteKit。你学习了如何在Xcode中创建游戏项目并导入资源，如图片。你还了解了通过标准文件命名实践支持不同设备的屏幕分辨率，以及如何选择游戏中需要的图片类型。最后，你创建并展示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4568
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了SpriteKit游戏项目并准备了所需的资源，解决了屏幕方向和分辨率的问题，是时候编写一些动作程序了。在[第15章](text00027.html#ch15)中，我们将添加我们的主角和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-4569
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  id: totrans-4570
  prefs: []
  type: TYPE_NORMAL
  zh: 设置场景的锚点决定了精灵在场景中的定位。当你用图钉将一张纸固定在软木板上时，图钉就是锚点。纸张将被定位在图钉的位置，如果纸张旋转，它会围绕图钉旋转。这正是锚点属性在SpriteKit中与精灵和场景的工作方式。游戏模板中的GameScene的锚点位于场景的中心，但我们希望锚点位于场景的左下角，因此我们将其设置为CGPoint.zero，或(0,
    0)。对于一些游戏，例如太空射击游戏，将锚点放在场景的中间会更好。但对于我们的游戏，地面位于屏幕底部，将锚点移到左下角会让操作更为方便。请参见[图14-5](text00026.html#ch14fig5)以查看不同锚点位置的示意图。
- en: '![](Image00277.jpg)'
  id: totrans-4571
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-4572
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点位置从(0, 0)到(1, 1)的不同位置*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-4573
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x位置为0时，它将位于屏幕的左边缘。当我们将精灵放置在y位置为0时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-4574
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-4575
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建每个项目的代码文件，最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获得。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4576
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4577
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置精灵的锚点，改变精灵的位置和旋转方式。请参见[图14-6](text00026.html#ch14fig6)查看使用不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-4578
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4579
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4580
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵的默认锚点通常位于中心。我们不会更改任何精灵的锚点，因此我们将始终使用其中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4581
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图片，向didMove(to:)函数中添加以下几行代码：
- en: '[PRE205]'
  id: totrans-4582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4583
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析我们刚才添加的五行代码。第➊行创建了一个名为background的精灵，使用* [background@2x.png](mailto:background@2x.png)*文件或*
    [background@3x.png](mailto:background@3x.png)*文件。之前这两个文件已添加到资源目录中，Xcode会自动选择正确的文件。你只需在代码中引用它为"background"或"background.png"即可。要了解Xcode如何选择正确的文件，请参见“[不同屏幕分辨率的图像尺寸调整](text00026.html#ch14lev1sec7)”
    [第213页](text00026.html#page_213)。请注意，变量名不必与图像名匹配——你可以随意命名变量名。但图像名必须与项目中已添加到资源目录中的文件匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4584
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋和➌的代码行中创建了常量xMid和yMid，它们表示屏幕的中心位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，用来描述它在屏幕上的位置。框架具有x位置、y位置、宽度和高度（参见[图14-7](text00026.html#ch14fig7)）。midX属性提供屏幕框架的中间x位置，midY提供中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-4585
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4586
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4587
  prefs: []
  type: TYPE_NORMAL
  zh: 在➍这一行代码中，通过使用xMid和yMid创建一个CGPoint并将其赋值给精灵的位置属性，将背景图像的位置设置为屏幕的中心。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4588
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，它包含两个CGFloat值，分别表示x坐标和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个单独的CGPoint可以保存两个值，一个用于*x*，一个用于*y*，这使得它在处理二维游戏中的屏幕坐标时非常方便，因为游戏中的一切都是基于x和y位置进行定位的。
- en: '**NOTE**'
  id: totrans-4589
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4590
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的都来自于* Core Graphics框架*，这是一个苹果公司用于图形处理的框架。你会在Swift中经常看到这种命名规则——类或结构体的前两三个字母通常能告诉你该对象的用途或它的来源。例如，所有SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4591
  prefs: []
  type: TYPE_NORMAL
  zh: 在➎这一行代码中，通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子节点*，意味着它附加在这个场景上。例如，如果场景变大、变小或消失，这个子精灵也会相应地变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都是作为该场景的子节点或作为其他精灵的子节点添加的。每当你添加一个精灵时，重要的是要考虑该精灵的父对象应该是什么。例如，滑冰者精灵是场景的子节点，但如果我们想给滑冰者加上可以互换的帽子，我们会使用一个帽子精灵，它是滑冰者精灵的子节点。这样，每当滑冰者跳跃时，帽子就会留在滑冰者身上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何游戏：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4593
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个既能在竖屏模式又能在横屏模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后只选择那种方向。由于我们的游戏是一个水平滚动的动作游戏，因此横屏方向（设备处于侧面，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-4594
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4595
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏模式下的外观对比*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4596
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，你会注意到它可能默认会进入竖屏模式。让我们更改项目设置，使游戏仅在横屏模式下运行。前往项目导航器，点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4597
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4598
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4599
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4600
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4601
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选Portrait选项，保持两个横屏方向选项被勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4602
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到屏幕上显示的项目和目标列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。列表将会显示出来，图标会变成蓝色，表示列表区域现在正在显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**Portrait**复选框并取消勾选。保持横屏方向选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4603
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们离目标越来越近了，但背景图片仍然没有填满整个屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4604
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **向右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4605
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4606
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：将模拟器方向旋转以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4608
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源在每个设备上能够正确显示。相比像我们的生日追踪器这样的基于UIKit的应用，游戏在这方面需要更多的努力，因为如果你只是简单地缩放图像，它可能会看起来拉伸。为避免这个问题，你需要为每个你想支持的设备使用一组不同的图片。
- en: '![](Image00285.jpg)'
  id: totrans-4609
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4610
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图像文件的系统，帮助你区分不同设备的图像。例如，假设你想要为游戏添加一张滑板者的图片，而你有一张宽 100 像素、高 100 像素的滑板者图像文件（100×100）。你应该将这张图片命名为
    *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)* 的图片，尺寸为 200×200
    像素，另外再创建一张名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为 300×300 像素。这三张文件应该是相同的图片，只是大小不同。如果游戏运行在
    iPhone 4 上，带有 *@2x* 后缀的文件会自动被使用。如果游戏运行在 iPhone 6 Plus 上，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需引用文件名
    skater ，只要你在项目中正确命名了图片，Xcode 就会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4611
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-4612
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4613
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被认为是 1x 图像。你只需要为那些较老的设备（如
    iPhone 3GS 或第一代 iPad mini，它们没有视网膜显示屏）提供 1x 大小的图像。因此，我们所有的图像文件都会有 *@2x* 或 *@3x*
    后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4614
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*
    。如果你查看 *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图片分组在一起。如果你同时将不同尺寸的图片拖入 Xcode 资源目录，Xcode
    会自动识别它们是同一张图片的不同尺寸，并将它们分组在一起，依据就是它们的命名方式。请参见 [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4615
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4616
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4617
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一步准备工作需要完成。你可能注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如 [图
    14-13](text00026.html#ch14fig13) 所示。这是因为 Game 模板处理游戏场景大小的方式。游戏场景的大小将基于包含在我们项目中的
    *GameScene.sks* 场景编辑器文件中的设置来确定。由于我们在这个项目中不会使用场景编辑器，所以我们需要添加代码来确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-4618
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4619
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4620
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，并找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4621
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE206]'
  id: totrans-4622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4623
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主要场景，我们希望它始终填充整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，以便它填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4624
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在，背景图像应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4626
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 Schoolhouse Skateboarder 游戏并学习了 SpriteKit。你学会了如何在 Xcode 中创建游戏项目并将资源（如图片）导入项目。你还了解了如何通过标准文件命名方法支持不同设备屏幕分辨率，以及如何选择游戏中需要的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4627
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个带有所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作代码。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00277.jpg)'
  id: totrans-4628
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00277.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-4629
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：锚点位置的不同，从 (0, 0) 到 (1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-4630
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 位置为 0 时，它将位于屏幕的左边缘。当我们将精灵放置在 y 位置为 0 时，它将位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-4631
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-4632
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步地构建每个代码文件。最终版本可以在* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *找到。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4633
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4634
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。请参见[图 14-6](text00026.html#ch14fig6)，它展示了如何通过不同的锚点旋转精灵。
- en: '![](Image00278.jpg)'
  id: totrans-4635
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4636
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4637
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会更改任何精灵的锚点，所以我们将始终使用精灵的中心点来定位它们。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4638
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，向 didMove(to:) 函数中添加以下代码：
- en: '[PRE207]'
  id: totrans-4639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4640
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析我们刚刚添加的五行代码。➊ 处的代码行创建了一个名为 background 的精灵，使用的是 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。两个文件都已添加到资源目录中，Xcode 会自动选择合适的文件。你只需要在代码中引用它，称之为
    "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，参见 “[为不同屏幕分辨率调整图片尺寸](text00026.html#ch14lev1sec7)”
    章节，位于 [第 213 页](text00026.html#page_213)。请注意，变量名不必与图片名匹配——你可以随意命名变量。但图片名必须与项目中资源目录中添加的文件名匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建一个精灵时，我们会创建一个 SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4641
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 和 ➌ 处的代码行创建了常量 xMid 和 yMid，它们将表示屏幕的中间位置。frame 是 GameScene 的一个属性——它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个描述其在屏幕上位置的
    frame。一个 frame 包含 x 坐标、y 坐标、宽度和高度（参见 [图 14-7](text00026.html#ch14fig7)）。midX 属性给我们提供了屏幕
    frame 的中间 x 坐标，而 midY 则提供了中间的 y 坐标。
- en: '![](Image00279.jpg)'
  id: totrans-4642
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4643
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个 frame 描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4644
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 处的代码行通过创建一个 CGPoint，使用 xMid 和 yMid，并将其赋值给精灵的 position 属性，从而将背景图像的位置设置为屏幕中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4645
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 和 y 坐标。当你处理屏幕坐标时，通常使用 CGFloat 数据类型，而不是
    Float 或 Double。一个 CGPoint 可以包含两个值，一个用于 *x*，一个用于 *y*，这使得在 2D 游戏中处理屏幕坐标非常方便，因为所有的位置都是通过
    x 和 y 坐标来确定的。
- en: '**NOTE**'
  id: totrans-4646
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4647
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自于* Core Graphics 框架*，这是苹果公司用于图形处理的框架。你会在 Swift 中经常看到这种命名方式——类或结构体的前两到三个字母通常会告诉你该对象的用途或来源。例如，所有的
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4648
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用`addChild(_:)`函数将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它与该场景相连。例如，如果场景发生增长、缩小或消失，这个子精灵也会发生相应的变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为该场景的子对象或另一个精灵的子对象添加。每当你添加一个精灵时，重要的是要考虑这个精灵的父对象应该是什么。例如，滑冰者精灵是场景的子对象，但如果我们想给滑冰者添加可以更换的帽子，我们就会使用一个作为滑冰者精灵子对象的帽子精灵。这样，无论滑冰者跳跃时，帽子都会保持在滑冰者头上，我们也就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4649
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4650
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个既能在竖屏又能在横屏模式下运行的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，然后选择那个方向。由于我们的游戏是一个水平滚动的动作游戏，因此横屏模式（设备侧放，如[图14-8](text00026.html#ch14fig8)所示）最为合理。
- en: '![](Image00280.jpg)'
  id: totrans-4651
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4652
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏与横屏方向下的表现*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4653
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行该项目，使用iPhone 7模拟器，你会注意到它可能默认显示为竖屏模式。让我们更改项目设置，使游戏仅在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，并且旁边有一个蓝色图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4654
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4655
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4656
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4657
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4658
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消勾选竖屏选项，保留横屏方向选项选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4659
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到项目和目标列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此列表将出现，并且图标会变为蓝色，表示列表区域已显示。确保选择了**SchoolhouseSkateboarder**目标。现在找到**竖屏**复选框并取消勾选。保持选中横屏方向选项。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4660
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经接近了，但背景图像还没有填充整个屏幕。我们稍后会看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4661
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已在横屏模式下运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **旋转右侧**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4662
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4663
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4665
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，应该先决定支持哪些设备和屏幕分辨率。你支持的设备越多，你需要处理的屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。游戏在这方面的工作量通常比基于UIKit的应用（如我们的生日追踪器）要大，因为如果你只是简单地放大或缩小，游戏的艺术资源会显得被拉伸。为了避免这个问题，你需要为每个你想支持的设备准备不同尺寸的图片。
- en: '![](Image00285.jpg)'
  id: totrans-4666
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4667
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一套命名图片文件的系统，帮助你辨别哪些图片是为哪些设备准备的。例如，假设你想为你的游戏添加一个滑冰者的图片，且你有一个100像素宽、100像素高的滑冰者图片文件（100×100）。你应该将该图片命名为*skater.png*。你还需要创建一个名为*[skater@2x.png](mailto:skater@2x.png)*的图片，尺寸为200×200像素，以及一个名为*[skater@3x.png](mailto:skater@3x.png)*的图片，尺寸为300×300像素。这三份文件应该是同一张图片的不同尺寸。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件会自动被使用。如果游戏在iPhone 6 Plus上运行，则会自动使用*@3x*文件。在你的代码中，你只需引用文件名skater，Xcode会根据项目中正确命名的图片显示相应的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4668
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《学校滑板少年》这款游戏，我们将支持从iPhone 4开始的设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-4669
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4670
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有后缀，比如* @2x *或* @3x*。没有后缀的图片，如*skater.png*，被视为1x图片。你只需要为老设备（如iPhone
    3GS或第一代iPad mini）包含1x大小的图片，因为这些设备没有视网膜显示屏。因此，我们所有的图片文件都会有* @2x *或* @3x *的后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4671
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会发现Xcode将这两张图片分组在一起。如果你同时将多张图片拖入Xcode资源目录，Xcode会根据图片的命名自动识别它们是同一张图片的不同尺寸并将其分组。请参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4672
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4673
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：不同尺寸的图片在资源目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4674
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作要完成。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板在处理游戏场景大小时的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑文件中的设置来确定。在本项目中我们不会使用场景编辑器，所以我们需要添加代码来确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-4675
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4676
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4677
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4678
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE208]'
  id: totrans-4679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4680
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并展示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4681
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4683
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了SpriteKit。你学习了如何在Xcode中创建一个游戏项目并导入资源，例如图片。你还学习了如何通过标准的文件命名规范支持各种设备的屏幕分辨率，并了解了如何选择游戏中所需的图像类型。最后，你创建并展示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4684
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个带有所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并让玩家点击屏幕使她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-4685
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  id: totrans-4686
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-5：锚点的不同位置，范围从(0, 0)到(1, 1)*'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-4687
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在x位置为0时，它将位于屏幕的左边缘。当我们将精灵放置在y位置为0时，它将位于屏幕的底部边缘。
- en: '**NOTE**'
  id: totrans-4688
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-4689
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步地构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *获取。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4690
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4691
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。请参见[图14-6](text00026.html#ch14fig6)，了解不同锚点下旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-4692
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4693
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4694
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用它们的中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4695
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图片，请将以下代码行添加到 didMove(to:) 函数中：
- en: '[PRE209]'
  id: totrans-4696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4697
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析刚才添加的五行代码。第 ➊ 行创建了一个名为 background 的精灵，使用* [background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。两个文件之前已经添加到资源目录中，Xcode
    会自动选择正确的文件。你只需在代码中引用它为 "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参见
    “[为不同屏幕分辨率调整图片大小](text00026.html#ch14lev1sec7)” 章节中的 [第 213 页](text00026.html#page_213)。请注意，变量名不需要与图片名匹配——你可以使用任何你想要的变量名。然而，图片名必须与项目中资源目录中添加的文件相匹配。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建一个精灵时，我们将创建一个 SKSpriteNode，就像这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4698
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➋ 和 ➌ 行创建了常量 xMid 和 yMid，它们表示屏幕的中间位置。frame 是 GameScene 的一个属性，它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述它在屏幕上的位置。一个框架具有
    x 位置、y 位置、宽度和高度（参见 [图 14-7](text00026.html#ch14fig7)）。midX 属性给出屏幕框架的中间 x 位置，而
    midY 给出中间的 y 位置。
- en: '![](Image00279.jpg)'
  id: totrans-4699
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4700
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4701
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➍ 行通过使用 xMid 和 yMid 创建一个 CGPoint，并将其赋值给精灵的位置属性，从而将背景图片的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4702
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 和 y 坐标。当你处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个 CGPoint 可以存储两个值，一个表示 *x* 坐标，一个表示 *y* 坐标，这使得在 2D 游戏中处理屏幕坐标时非常方便，因为一切都使用
    x 和 y 坐标来定位。
- en: '**NOTE**'
  id: totrans-4703
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4704
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的内容都来自* Core Graphics 框架*，这是 Apple 用于图形处理的框架。你会在 Swift 中经常看到这种命名方式——类或结构体的前两个或三个字母通常会告诉你这个对象的用途或来源。例如，所有
    SpriteKit 的类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4705
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 这一行通过调用addChild(_:)函数将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它附属于这个场景。例如，如果场景发生变化，无论是放大、缩小，还是消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为该场景的子对象或作为另一个精灵的子对象添加。每次添加精灵时，重要的是要考虑这个精灵的父对象应该是什么。例如，滑板精灵是场景的子对象，但如果我们想在滑板手上添加可替换的帽子，我们将使用一个帽子精灵，它是滑板手精灵的子对象。这样，当滑板手跳跃时，帽子会留在滑板手身上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4706
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏的玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4707
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个能够同时在竖屏和横屏模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，横屏方向（设备处于侧面，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-4708
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4709
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏方向下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4710
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行该项目，你会注意到它可能默认处于竖屏方向。让我们更改项目设置，以便游戏仅在横屏方向运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4711
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4712
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4713
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4714
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4715
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中“竖屏”选项，保留选中两个“横屏”方向选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4716
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上没有看到“项目和目标”列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此时列表将出现，图标会变为蓝色，表示该列表区域现在可见。确保选中了**SchoolhouseSkateboarder**目标。接下来，找到**竖屏**复选框并取消勾选。保留横屏方向选项的勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4717
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们越来越接近目标了，但背景图片仍然没有填满整个屏幕。稍后我们将看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4718
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏现在以横屏方向运行，你需要确保模拟器也处于横屏方向。要旋转它，请从模拟器菜单中选择**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4719
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4720
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**针对不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4722
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你需要处理的不同屏幕尺寸就越多，这意味着你需要做额外的工作，以确保你创建的艺术资源在每个设备上都能正确显示。相比于像我们的生日追踪器这样的基于
    UIKit 的应用，游戏在这方面通常需要更多的工作，因为如果你仅仅缩放图像，游戏艺术会看起来拉伸失真。为了避免这个问题，你需要为每个想要支持的设备使用不同尺寸的图像。
- en: '![](Image00285.jpg)'
  id: totrans-4723
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4724
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 提供了一个命名图像文件的系统，帮助你区分不同设备对应的图像。例如，假设你想在游戏中添加一个滑冰者的图像，而你有一个宽 100 像素、高 100
    像素（100×100）的滑冰者图像文件。你会将该图像命名为 *skater.png*。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，大小为 200×200 像素，以及另一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，大小为 300×300
    像素。这三个文件应该是同一张图像的不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6 Plus
    上运行，带有 *@3x* 后缀的文件将自动被使用。在你的代码中，你只需引用文件名 skater，Xcode 会根据你在项目中正确命名的图像文件自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4725
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《滑板学校》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-4726
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4727
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被认为是 1x 图像。你只需要为那些具有非视网膜显示屏的旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 尺寸的图像。因此，我们所有的图像文件都将带有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4728
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会发现 Xcode 将这两张图像分组在一起。如果你同时将多个图像拖入 Xcode 资源目录，Xcode 会自动识别它们是同一图像的不同尺寸，因为它们的命名方式，并将它们分组在一起。请参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4729
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4730
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：多个尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4731
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理背景图像之前，还有最后一步准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式所致。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。在本项目中我们不会使用场景编辑器，所以我们需要添加代码以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-4732
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4733
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4734
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4735
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE210]'
  id: totrans-4736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4737
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了显示视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4738
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该会填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4740
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作了《Schoolhouse Skateboarder》游戏，并学习了 SpriteKit。你学会了如何在 Xcode 中创建游戏项目并将资源（例如图像）导入项目中。你还学习了通过标准文件命名规范来支持各种设备的屏幕分辨率，以及如何选择游戏中所需的图像类型。最后，你创建并展示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4741
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个带有所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来是时候编写一些动作代码了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的主角和她滑行的地面，使一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-4742
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  id: totrans-4743
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，当我们将精灵放置在 x 位置为 0 时，它会位于屏幕的左边缘。当我们将精灵放置在 y 位置为 0 时，它会位于屏幕的底边缘。
- en: '**NOTE**'
  id: totrans-4744
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-4745
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将一步步构建每个代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4746
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4747
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变该精灵的位置和旋转方式。请参见[图 14-6](text00026.html#ch14fig6)，了解不同锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-4748
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4749
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它的旋转方式。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4750
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会更改任何精灵的锚点，因此我们将始终使用其中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4751
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，请将以下代码行添加到didMove(to:)函数中：
- en: '[PRE211]'
  id: totrans-4752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4753
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析刚刚添加的五行代码。第➊行创建了一个名为background的精灵，使用的是* [background@2x.png](mailto:background@2x.png)
    *文件或* [background@3x.png](mailto:background@3x.png) *文件。这两个文件之前已添加到资源目录中，Xcode会自动选择合适的文件。你只需要在代码中引用它为"background"或"background.png"。要了解Xcode如何选择正确的文件，请参见[“为不同屏幕分辨率调整图像大小”](text00026.html#ch14lev1sec7)
    ，详细内容见[第213页](text00026.html#page_213)。请注意，变量名不需要与图像名匹配——你可以为变量命名任意名称。但是，图像名必须与在项目的资源目录中添加的文件名一致。SKSpriteNode是SpriteKit中的精灵类，因此，当我们在游戏中创建精灵时，我们将创建一个SKSpriteNode，就像我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4754
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们将表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述它在屏幕上的位置。frame有一个x位置、一个y位置、一个宽度和一个高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕frame的中间x位置，而midY给出了中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-4755
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4756
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4757
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过创建一个使用xMid和yMid的CGPoint，并将其赋值给精灵的position属性，来将背景图像的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4758
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，表示x和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。单个CGPoint可以存储两个值，一个用于*x*，一个用于*y*，这使得在2D游戏中处理屏幕坐标变得非常方便，因为游戏中的所有内容都需要使用x和y位置来定位。
- en: '**NOTE**'
  id: totrans-4759
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4760
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自* Core Graphics框架*，这是Apple用于图形的框架。你会在Swift中经常看到这种命名系统——类或结构体的前两三个字母通常告诉你该对象的用途或来源。例如，所有SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4761
  prefs: []
  type: TYPE_NORMAL
  zh: ➎处的代码通过调用addChild(_:)函数将背景图片添加到场景中。这个精灵现在是场景的*子对象*，意味着它与场景绑定在一起。例如，如果场景发生变化（如增大、缩小或消失），这个子精灵也会发生变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为该场景的子对象或者作为另一个精灵的子对象添加。每当您添加一个精灵时，考虑它的父对象是什么非常重要。例如，滑板车精灵是场景的子对象，但如果我们想要在滑板车上添加可更换的帽子，我们会使用帽子精灵，它是滑板车精灵的子对象。这样，无论滑板车跳跃时，帽子都会保持在滑板车上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4762
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4763
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多工作，因此通常最好决定哪种方向最适合您的游戏，并选择其中一种。由于我们的游戏是一个横向滚动的动作游戏，因此横屏模式（设备侧置，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-4764
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4765
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：游戏在竖屏和横屏方向下的显示效果对比*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4766
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，您会注意到它可能默认以竖屏模式启动。让我们更改项目设置，以便游戏仅在横屏模式下运行。进入项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4767
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4768
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4769
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，您可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4770
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4771
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消勾选竖屏选项，保留两个横屏方向选项的勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4772
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在屏幕上看不到“项目和目标”列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此时列表会出现，图标会变成蓝色，表示列表区域已经显示。确保选中**SchoolhouseSkateboarder**目标。然后找到**竖屏**复选框并取消勾选。保留横屏方向选项的勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4773
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，您将看到它以横屏模式启动。我们越来越接近目标了，但背景图片还没有填满屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4774
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏现在以横屏模式运行，您需要确保模拟器也处于横屏模式。要旋转模拟器，请从模拟器的菜单中选择**硬件** ▸ **右旋**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4775
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4776
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4777
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4778
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你需要处理的屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。游戏比基于
    UIKit 的应用（如我们的《生日追踪器》）更需要在这方面付出努力，因为如果只是简单地缩放，游戏的艺术资源会显得拉伸变形。为了避免这个问题，你必须为每个要支持的设备使用不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-4779
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4780
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图像文件的规则，帮助你识别哪些图像是针对哪些设备的。例如，假设你想在游戏中添加一个滑板者的图像，而你有一个宽 100 像素、高 100
    像素（100×100）的滑板者图像文件。你会将该图像命名为 *skater.png*。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，尺寸为 200×200 像素，再创建一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，尺寸为 300×300
    像素。这三张文件应该是同一张图像的三种不同尺寸。如果游戏在 iPhone 4 上运行，系统会自动使用带有 *@2x* 后缀的文件。如果游戏在 iPhone
    6 Plus 上运行，系统会自动使用带有 *@3x* 后缀的文件。在代码中，你只需要引用图像文件名 skater ，只要你在项目中正确命名了图像，Xcode
    就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4781
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》游戏，我们将支持从 iPhone 4 及以后版本的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-4782
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4783
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被认为是 1x 图像。你只需要为那些没有视网膜显示屏的老设备（例如
    iPhone 3GS 或第一代 iPad mini）提供 1x 大小的图像。因此，我们所有的图像文件都会有* @2x *或* @3x *的后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会发现 Xcode 将这两张图像分组在一起。如果你同时将这些图像拖入 Xcode 资源目录，Xcode 会根据它们的命名自动识别这些是同一图像的不同尺寸，并将它们分组在一起。请参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4785
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4786
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资源目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4787
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还需要做最后一些准备工作。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图片并没有填满整个屏幕，如[图 14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景尺寸的方式所致。游戏场景的大小将基于我们项目中包含的*GameScene.sks*场景编辑器文件中的设置。由于我们在这个项目中不会使用场景编辑器，因此需要添加代码确保场景尺寸正确。
- en: '![](Image00287.jpg)'
  id: totrans-4788
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4789
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4790
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4791
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE212]'
  id: totrans-4792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4793
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了所显示视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4794
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图片应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4795
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4796
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《学校滑板游戏》并学习了SpriteKit。你了解了如何在Xcode中创建游戏项目并将资源（如图片）导入到项目中。你还学习了如何通过标准文件命名实践支持各种设备的屏幕分辨率，以及如何选择游戏中需要的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4797
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了SpriteKit游戏项目，准备好了所需的资源，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作程序。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切开始移动，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-4798
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '**NOTE**'
  id: totrans-4799
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  id: totrans-4800
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将逐步构建每个项目的代码文件。最终版本可以从* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *下载。*'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4801
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4802
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变精灵的位置和旋转方式。请参见[图 14-6](text00026.html#ch14fig6)，查看如何通过不同的锚点旋转精灵的示例。
- en: '![](Image00278.jpg)'
  id: totrans-4803
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4804
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4805
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将其锚点设置在中心。我们不会改变任何精灵的锚点，因此我们将始终使用其中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4806
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载背景图片，请在didMove(to:)函数中添加以下几行代码：
- en: '[PRE213]'
  id: totrans-4807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4808
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析刚才添加的五行代码。第 ➊ 行创建了一个名为 `background` 的精灵，使用 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。之前这两个文件已经添加到资源目录中，Xcode
    会自动选择合适的文件。你只需要在代码中引用它为 "background" 或 "background.png"。要了解 Xcode 如何选择正确的文件，请参见
    “[为不同屏幕分辨率调整图片大小](text00026.html#ch14lev1sec7)” 章节中的 [第 213 页](text00026.html#page_213)。请注意，变量名不需要与图片名称匹配——你可以自由选择变量名。然而，图片名称必须与在项目资源目录中添加的文件匹配。`SKSpriteNode`
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建一个精灵时，我们会创建一个 `SKSpriteNode`，就像在这里做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4809
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➋ 和 ➌ 行创建了常量 `xMid` 和 `yMid`，它们代表屏幕的中间位置。`frame` 是 `GameScene` 的一个属性——它是一个
    `CGRect`（矩形），表示整个屏幕。每个场景和精灵都有一个框架，用来描述它们在屏幕上的位置。一个框架有一个 x 位置、y 位置、宽度和高度（见 [图 14-7](text00026.html#ch14fig7)）。`midX`
    属性给出屏幕框架的中间 x 位置，而 `midY` 则给出中间的 y 位置。
- en: '![](Image00279.jpg)'
  id: totrans-4810
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4811
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4812
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➍ 行通过使用 `xMid` 和 `yMid` 创建一个 `CGPoint`，并将其赋值给精灵的位置属性，从而将我们的背景图片位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4813
  prefs: []
  type: TYPE_NORMAL
  zh: '`CGPoint` 是一个结构体，包含两个 `CGFloat` 值，分别表示 x 和 y 坐标。在处理屏幕坐标时，通常使用 `CGFloat` 作为数据类型，而不是
    `Float` 或 `Double`。一个 `CGPoint` 可以存储两个值，一个是 *x*，另一个是 *y*，这使得它在处理 2D 游戏中的屏幕坐标时非常方便，因为游戏中的所有元素都需要使用
    x 和 y 坐标来定位。'
- en: '**NOTE**'
  id: totrans-4814
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4815
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何内容都来自* Core Graphics 框架*，这是一个用于图形处理的 Apple 框架。你会在 Swift 中看到很多这种命名系统——类或结构体的前两个或前三个字母通常会告诉你该对象的用途或来源。例如，所有的
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4816
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图片添加到场景中。这个精灵现在是场景的*子对象*，意味着它被附加到这个场景中。例如，如果场景增长、缩小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都是作为该场景的子对象或另一个精灵的子对象添加的。每次添加精灵时，重要的是要考虑该精灵的父对象应该是什么。例如，滑冰精灵是场景的子对象，但如果我们想为滑冰者添加可更换的帽子，我们会使用一个帽子精灵，它是滑冰精灵的子对象。这样，每当滑冰者跳跃时，帽子会留在滑冰者身上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4817
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4818
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，然后只选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，横屏方向（设备侧放，如[图14-8](text00026.html#ch14fig8)所示）是最合适的。
- en: '![](Image00280.jpg)'
  id: totrans-4819
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4820
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏方向下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4821
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用iPhone 7模拟器，你会注意到它可能默认以竖屏方向显示。让我们更改项目设置，使游戏仅在横屏模式下运行。转到项目导航器，点击**SchoolhouseSkateboarder**项目——它在项目导航器的顶部，旁边有一个蓝色图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4822
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4823
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4824
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4825
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4826
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消勾选竖屏选项，保留勾选两个横屏方向选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4827
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到项目和目标列表，点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。列表会出现，并且图标会变蓝，表示列表区域现在已经显示。确保选择了**SchoolhouseSkateboarder**目标。接下来找到**竖屏**复选框并取消勾选，保留横屏方向选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4828
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们已经接近了，但背景图片还没有完全填满屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4829
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经在横屏模式下运行，你需要确保你的模拟器也处于横屏模式。要旋转它，选择模拟器菜单中的**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4830
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4831
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4832
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4833
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理的不同屏幕尺寸也越多，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。与像我们的《生日追踪器》这样的基于
    UIKit 的应用相比，游戏通常在这方面需要更多的努力，因为如果你只是将艺术作品缩放，图像会看起来被拉伸。为了避免这个问题，你需要为每个想要支持的设备使用不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-4834
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4835
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个图像文件命名系统，帮助你区分哪些图像适用于哪些设备。例如，假设你想向游戏中添加一张滑板运动员的图像，你有一张宽 100 像素、高 100
    像素的滑板运动员图像（100×100）。你将该图像命名为*skater.png*。你还需要创建一张名为*[skater@2x.png](mailto:skater@2x.png)*，大小为
    200×200 像素的图像，以及一张名为*[skater@3x.png](mailto:skater@3x.png)*，大小为 300×300 像素的图像。这三张文件应该是同一图像的三种不同大小。如果游戏在
    iPhone 4 上运行，带有*@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6 Plus 上运行，则会自动使用带有*@3x* 后缀的文件。在你的代码中，你只需引用文件名“skater”，只要你在项目中正确命名了这些图像，Xcode
    就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4836
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-4837
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4838
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被认为是一个 1x 图像。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini，它们没有视网膜显示屏）包含 1x 大小的图像。因此，我们所有的图像文件都会带有* @2x *或* @3x*
    后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4839
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件分别命名为*[background@2x.png](mailto:background@2x.png)* 和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*
    资源目录，你会发现 Xcode 将这两张图像分组在一起。如果你同时将图像拖入 Xcode 资源目录，Xcode 会根据它们的命名方式自动识别它们是同一图像的不同大小，并将它们分组在一起。请参见[图
    14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4840
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4841
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4842
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理背景图像之前，我们还有最后一件事需要处理。你可能注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图 14-13](text00026.html#ch14fig13)所示。这是因为
    Game 模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的 *GameScene.sks* 场景编辑器文件的设置来决定。我们在这个项目中不会使用场景编辑器，所以我们需要添加代码来确保场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-4843
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4844
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4845
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4846
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE214]'
  id: totrans-4847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4848
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并将其显示出来。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4849
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4850
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4851
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，你开始制作 Schoolhouse Skateboarder 游戏并学习了 SpriteKit。你学会了如何在 Xcode 中创建游戏项目并将资源（如图像）导入项目。你还了解了如何通过标准的文件命名规范来支持各种设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4852
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了 SpriteKit 游戏项目，准备好了所需的资源，并解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-4853
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '**ANCHOR POINTS FOR SPRITES**'
  id: totrans-4854
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵的锚点**'
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  id: totrans-4855
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以设置精灵的锚点，改变该精灵的位置和旋转方式。查看[图 14-6](text00026.html#ch14fig6)，了解如何通过不同的锚点旋转精灵。
- en: '![](Image00278.jpg)'
  id: totrans-4856
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00278.jpg)'
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  id: totrans-4857
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-6：精灵的锚点决定了它如何旋转。*'
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  id: totrans-4858
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵通常将锚点放在中心。我们不会更改任何精灵的锚点，因此我们将始终使用其中心点来定位精灵。
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4859
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要加载背景图像，请将以下代码行添加到 didMove(to:) 函数中：
- en: '[PRE215]'
  id: totrans-4860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4861
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析刚刚添加的五行代码。第➊行创建了一个名为background的精灵，使用的是* [background@2x.png](mailto:background@2x.png)
    *文件或* [background@3x.png](mailto:background@3x.png) *文件。两个文件都已经添加到资源目录中，Xcode会自动选择正确的文件。你只需在代码中引用它们，使用"background"或"background.png"即可。要了解Xcode如何选择正确的文件，请参阅《[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)》第213页。请注意，变量名不必与图像名匹配——你可以为变量名使用任何名称。然而，图像名必须与您在项目的资源目录中添加的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此，当我们在游戏中创建精灵时，我们将创建一个SKSpriteNode，就像我们在这里做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4862
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，用来描述它在屏幕上的位置。一个frame有x位置、y位置、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给我们屏幕frame的中间x位置，midY给我们屏幕frame的中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-4863
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4864
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4865
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint，并将其赋值给精灵的position属性，将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4866
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。当处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以存储两个值，一个是*x*，一个是*y*，这使得在2D游戏中处理屏幕坐标变得方便，因为在2D游戏中，所有的东西都使用x和y位置来定位。
- en: '**NOTE**'
  id: totrans-4867
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4868
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自* Core Graphics框架*，这是Apple用于图形处理的框架。你会经常看到这种命名系统出现在Swift中——一个类或结构体的前两个或三个字母通常能告诉你这个对象的用途或来源。例如，所有的SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4869
  prefs: []
  type: TYPE_NORMAL
  zh: ➎这一行通过调用addChild(_:)函数将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它附加在这个场景上。例如，如果场景发生变化、缩小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为子对象添加到该场景或另一个精灵上。每当您添加一个精灵时，重要的是要考虑这个精灵的父对象应该是什么。例如，滑板精灵是场景的子对象，但如果我们想给滑板手添加可更换的帽子，我们会使用一个帽子精灵，它是滑板精灵的子对象。这样，无论滑板手跳跃时，帽子都会保持在滑板手身上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何进行游戏：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4871
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可以同时在竖屏和横屏模式下运行的游戏需要更多工作，因此通常最好决定哪种方向最适合您的游戏，并选择其中一种。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（设备侧放，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-4872
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4873
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏模式下的显示效果对比*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4874
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，您会注意到它可能默认以竖屏模式启动。让我们更改项目设置，使游戏仅在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，并且旁边有一个蓝色图标，正如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4875
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4876
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：点击项目导航器中的项目条目，访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4877
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，您可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4878
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4879
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消勾选竖屏选项，保持勾选横屏方向选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4880
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到屏幕上的项目和目标列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此列表将出现，图标将变蓝，表示现在已显示列表区域。确保选择了**SchoolhouseSkateboarder**目标。接下来找到**竖屏**复选框并取消勾选，保持横屏方向选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4881
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，您将看到它以横屏模式启动。我们已经越来越接近了，但背景图像还没有填充整个屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4882
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏现在以横屏模式运行，您需要确保模拟器也处于横屏模式。要旋转模拟器，请从模拟器菜单中选择**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4883
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4884
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4885
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4886
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。相比基于UIKit的应用（如我们的生日跟踪器），游戏通常在这一方面需要更多的工作，因为如果你只是简单地放大或缩小，游戏艺术作品会显得拉伸变形。为了避免这个问题，你需要为每个支持的设备准备一组不同的图片。
- en: '![](Image00285.jpg)'
  id: totrans-4887
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4888
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一套命名图片文件的系统，帮助你区分哪些图片适用于哪些设备。例如，假设你想在游戏中添加一张滑板者的图片，而你有一张100像素宽、100像素高（100×100）的滑板者图片文件。你会将这张图片命名为*skater.png*。你还需要创建一张名为*[skater@2x.png](mailto:skater@2x.png)*的图片，尺寸为200×200像素，以及另一张名为*[skater@3x.png](mailto:skater@3x.png)*的图片，尺寸为300×300像素。这三张文件应该是同一张图片的三种不同尺寸。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件将自动被使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件将自动被使用。在代码中，你只需引用文件名skater，只要你在项目中正确命名了图片，Xcode就会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4889
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Schoolhouse Skateboarder，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-4890
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4891
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片文件都有一个后缀，比如*@2x*或*@3x*。没有后缀的图片，如*skater.png*，被认为是1x图片。你只需要为旧设备（例如iPhone
    3GS或第一代iPad mini，这些设备没有视网膜显示屏）包含1x尺寸的图片。因此，我们所有的图片文件都将带有*@2x*或*@3x*后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4892
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件分别命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图片分组在一起。如果你同时将图片拖入Xcode资源目录，Xcode会根据图片命名自动识别它们是同一张图片的不同尺寸，并将它们分组在一起。参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4893
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4894
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：多种尺寸的图片在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4895
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图像没有填充整个屏幕，如[图 14-13](text00026.html#ch14fig13)所示。这是因为Game模板处理游戏场景大小的方式。游戏场景的大小将根据包含在我们项目中的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在本项目中不使用场景编辑器，因此需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-4896
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4897
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填充整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4898
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4899
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE216]'
  id: totrans-4900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4901
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4902
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在，背景图像应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4903
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4904
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了关于SpriteKit的知识。你学会了如何在Xcode中创建游戏项目并导入资源，如图片。你还了解了通过标准文件命名方法支持各种设备屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4905
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个SpriteKit游戏项目，包含所需的资源，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作程序。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切开始移动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-4906
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  id: totrans-4907
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了加载我们的背景图像，将以下代码行添加到didMove(to:)函数中：
- en: '[PRE217]'
  id: totrans-4908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4909
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析刚刚添加的五行代码。第➊行创建了一个名为background的精灵，使用的是* [background@2x.png](mailto:background@2x.png)
    *文件或* [background@3x.png](mailto:background@3x.png) *文件。两个文件之前已添加到资产目录中，Xcode会自动选择正确的文件。你只需要在代码中引用它，使用"background"或"background.png"。要了解Xcode如何选择正确的文件，请参见
    “[不同屏幕分辨率下的图像尺寸调整](text00026.html#ch14lev1sec7)” 第213页（text00026.html#page_213）。请注意，变量名不需要与图像名匹配——你可以为变量名使用任何你想要的名称。然而，图像名必须与项目中资产目录中添加的文件名匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们会创建一个SKSpriteNode，就像我们在这里做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4910
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述了它在屏幕上的位置。一个frame有x位置、y位置、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给我们屏幕frame的中间x位置，midY给我们屏幕frame的中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-4911
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4912
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4913
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint，并将其分配给精灵的位置属性，将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4914
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以保存两个值，一个是*x*，一个是*y*，这使得它在处理2D游戏中的屏幕坐标时非常方便，因为一切位置都依赖于x和y坐标。
- en: '**NOTE**'
  id: totrans-4915
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4916
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自* Core Graphics框架*，这是一个用于图形处理的Apple框架。你会经常在Swift中看到这种命名系统——类或结构体的前两到三个字母通常会告诉你该对象的用途或来源。例如，所有SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4917
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_)将背景图片添加到场景中。这个精灵现在是场景的*子节点*，这意味着它附加在这个场景上。例如，如果场景扩展、缩小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，而每个精灵都作为该场景的子精灵或另一个精灵的子精灵添加。每当你添加一个精灵时，考虑清楚它的父节点应该是什么非常重要。例如，滑板者精灵是场景的子节点，但如果我们想为滑板者添加可更换的帽子，我们会使用一个帽子精灵，它是滑板者精灵的子节点。这样，每当滑板者跳跃时，帽子就会跟着滑板者，而我们就不必单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4918
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏的玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4919
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个既能在竖屏又能在横屏模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后只选择那个方向。由于我们的游戏是一个水平滚动的动作游戏，横屏模式（设备侧放，如[图14-8](text00026.html#ch14fig8)所示）最为合理。
- en: '![](Image00280.jpg)'
  id: totrans-4920
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4921
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4922
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，你会注意到它可能默认是竖屏模式。让我们更改项目设置，使得游戏只能在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色的图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4923
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4924
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4925
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到一份项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4926
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4927
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中“竖屏”选项，保留“横屏”方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4928
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在屏幕上看到项目和目标的列表，点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。这个列表将会出现，图标变蓝以表示该列表区域正在显示。确保**SchoolhouseSkateboarder**目标被选中。然后找到**竖屏**复选框并取消勾选。保持横屏方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4929
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们离目标更近了，但背景图片还没有填充整个屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4930
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经在横屏模式下运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **旋转右**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4931
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4932
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4933
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**不同屏幕分辨率的图片尺寸调整**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4934
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你需要处理的屏幕尺寸差异就越多，这意味着你需要额外的工作，确保你创建的艺术资源在每个设备上都能正确显示。与基于
    UIKit 的应用（如我们的生日追踪器）相比，游戏在这方面通常需要更多的工作，因为如果仅仅放大或缩小，游戏的艺术资源会看起来被拉伸。为了避免这个问题，你必须为每个想要支持的设备使用不同的图片资源。
- en: '![](Image00285.jpg)'
  id: totrans-4935
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4936
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 为图片文件命名提供了一种系统，帮助你区分哪些图片是针对哪些设备的。例如，假设你想为游戏添加一张滑板运动员的图片，且你有一张宽 100 像素、高
    100 像素（100×100）的滑板运动员图片，你会将该图片命名为 *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)*
    的 200×200 像素图片，以及另一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的 300×300 像素图片。这三张文件应该是同一张图片的三种不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需要引用文件名
    skater ，只要你在项目中正确命名了图片，Xcode 就会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4937
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-4938
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4939
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，如* @2x *或* @3x*。没有后缀的图片，如* skater.png*，被视为 1x 图片。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 大小的图片，这些设备没有视网膜显示屏。因此，我们所有的图片文件都会带有* @2x *或* @3x
    *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4940
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件分别命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图片归为一组。如果你同时将这些图片拖入 Xcode 资源目录，Xcode 会根据文件名自动识别它们是同一图片的不同尺寸，并将它们分组在一起。请参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4941
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4942
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图片在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4943
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从背景图像上移步之前，还有最后一项准备工作要处理。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将基于我们项目中包含的*GameScene.sks*场景编辑器文件中的设置。由于我们在这个项目中不会使用场景编辑器，所以我们需要添加代码来确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-4944
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4945
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4946
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航中的*GameViewController.swift*文件，并找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4947
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE218]'
  id: totrans-4948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4949
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示的视图的大小（宽度和高度），并设置了新场景的大小，以确保它填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4950
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4951
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的知识**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4952
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作“学校滑板”游戏，并学习了SpriteKit。你学习了如何在Xcode中创建一个游戏项目并将资源（例如图片）导入项目。你还了解了如何通过标准的文件命名方式支持各种设备的屏幕分辨率，以及如何选择在游戏中需要的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-4953
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，让一切开始动起来，并让玩家通过点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-4954
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '[PRE219]'
  id: totrans-4955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-4956
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析一下我们刚刚添加的五行代码。➊ 这一行创建了一个名为 background 的精灵，使用的是 *[background@2x.png](mailto:background@2x.png)*
    文件或 *[background@3x.png](mailto:background@3x.png)* 文件。两个文件之前已经添加到资源目录中，Xcode
    会自动选择合适的文件。你只需要在代码中引用它，命名为 "background" 或 "background.png"。要了解 Xcode 如何选择合适的文件，请参见
    “[针对不同屏幕分辨率调整图片大小](text00026.html#ch14lev1sec7)” ，位于 [第213页](text00026.html#page_213)。请注意，变量名不一定要与图像名称匹配——你可以为变量命名任何你想要的名字。然而，图像名称必须与您在项目中添加到资产目录的文件名一致。SKSpriteNode
    是 SpriteKit 中的精灵类，因此当我们在游戏中创建精灵时，我们将创建一个 SKSpriteNode，就像这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-4957
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 和 ➌ 这一行创建了常量 xMid 和 yMid，它们代表屏幕的中间位置。frame 是 GameScene 的一个属性，它是一个 CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述了它在屏幕上的位置。一个框架有
    x 坐标、y 坐标、宽度和高度（见 [图14-7](text00026.html#ch14fig7)）。midX 属性给我们提供了屏幕框架的中间 x 坐标，midY
    属性给我们提供了中间的 y 坐标。
- en: '![](Image00279.jpg)'
  id: totrans-4958
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-4959
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-4960
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ 这一行将背景图像的位置设置为屏幕的中心，通过使用 xMid 和 yMid 创建一个 CGPoint，并将其分配给精灵的位置属性。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-4961
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，它包含两个 CGFloat 值，分别表示 x 和 y 坐标。在处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个 CGPoint 可以存储两个值，一个用于 *x*，另一个用于 *y*，这使得它在处理 2D 游戏中的屏幕坐标时非常方便，因为在
    2D 游戏中，所有内容都是通过 x 和 y 的位置来确定的。
- en: '**NOTE**'
  id: totrans-4962
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-4963
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自于* Core Graphics 框架*，这是 Apple 用于图形处理的一个框架。你会注意到，这种命名系统在 Swift
    中很常见——类或结构体的前两个或三个字母通常会告诉你该对象的用途或它来自哪个地方。例如，所有 SpriteKit 的类，如 *SKSpriteNode*，都以
    *SK* 开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-4964
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 这一行通过调用函数 `addChild(_:)` 将背景图像添加到场景中。这个精灵现在是场景的*子对象*，这意味着它附加在该场景上。例如，如果场景发生增长、缩小或消失，这个子精灵也会相应地发生变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都作为该场景的子对象或作为另一个精灵的子对象添加。每当你添加一个精灵时，重要的是要思考该精灵的父对象应该是什么。例如，溜冰者精灵是场景的子对象，但如果我们想要给溜冰者添加可互换的帽子，我们会使用一个帽子精灵，该帽子精灵是溜冰者精灵的子对象。这样，当溜冰者跳跃时，帽子会跟着溜冰者一起动，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-4965
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏如何播放：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-4966
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，然后只选择那一个。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（即设备处于侧面，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-4967
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-4968
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏与横屏模式下的表现*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-4969
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，你会注意到它可能默认以竖屏模式启动。让我们修改项目设置，让游戏仅以横屏模式运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-4970
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-4971
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-4972
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-4973
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-4974
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中竖屏选项，同时保留两个横屏选项的勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-4975
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上没有看到项目和目标的列表，点击窗口左上角的方形图标，正如[图 14-10](text00026.html#ch14fig10)所示。这个列表会出现，并且图标会变成蓝色，表示该列表区域现在已显示。确保选择了**SchoolhouseSkateboarder**目标。现在找到**竖屏**复选框并取消勾选，保留横屏选项的勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-4976
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经越来越接近目标了，但背景图像还没有填满整个屏幕。稍后我们会看看如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-4977
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已以横屏模式运行，你还需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **右旋**，正如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-4978
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-4979
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-4980
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-4981
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，首先需要决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源在每个设备上都能正确显示。与我们的生日追踪器这样的UIKit应用程序相比，游戏通常在这一领域需要更多的努力，因为如果仅仅通过缩放来调整大小，游戏的艺术作品会显得拉伸变形。为了避免这个问题，你需要为每个要支持的设备使用一组不同的图片。
- en: '![](Image00285.jpg)'
  id: totrans-4982
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-4983
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一套命名图像文件的系统，帮助你区分不同设备使用的图像。例如，假设你想为你的游戏添加一张滑板手的图片，你有一张宽100像素、高100像素（100×100）的滑板手图像文件。你将把这张图片命名为*
    skater.png*。你还需要创建一张命名为*[skater@2x.png](mailto:skater@2x.png)*的图片，尺寸为200×200像素，再创建一张命名为*[skater@3x.png](mailto:skater@3x.png)*的图片，尺寸为300×300像素。这三张文件应该是同一张图片的三种不同尺寸。如果游戏在iPhone
    4上运行，带有* @2x*后缀的文件将会自动被使用。如果游戏在iPhone 6 Plus上运行，带有* @3x*后缀的文件将会自动被使用。在代码中，你只需要引用文件名skater，Xcode会根据你在项目中正确命名的图像来显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-4984
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750，以及1920×1080。
- en: '**NOTE**'
  id: totrans-4985
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-4986
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，例如* @2x *或* @3x*。没有后缀的图片，例如* skater.png*，被认为是1x图片。你只需要为较旧的设备（如iPhone
    3GS或第一代iPad mini）包含1x尺寸的图片，这些设备没有视网膜显示屏。因此，我们所有的图片文件都将带有* @2x *或* @3x *的后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-4987
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会发现Xcode将这两张图片分组在一起。如果你同时将多个尺寸的图片拖入Xcode的资源目录，Xcode会根据文件命名自动识别这些图片是同一张图片的不同尺寸，并将它们分组在一起。请参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-4988
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-4989
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图片在资源目录中被归为一组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-4990
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理背景图片之前，还有最后一项准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为 Game 模板在处理游戏场景尺寸时的方式。游戏场景的大小会根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来决定。我们在这个项目中不会使用场景编辑器，所以我们需要添加代码，确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-4991
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-4992
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-4993
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-4994
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE220]'
  id: totrans-4995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-4996
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了所显示视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-4997
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图片应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4998
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-4999
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《学校滑板英雄》游戏，并学习了SpriteKit。你学习了如何在Xcode中创建游戏项目并将资源（如图片）导入到项目中。你还了解了通过标准文件命名方式来支持各种设备屏幕分辨率，以及如何选择在游戏中需要使用的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5000
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置好了一个带有所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来该编写一些动作了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切开始运动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5001
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  id: totrans-5002
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析我们刚刚添加的五行代码。第➊行创建了一个名为background的精灵，使用的是* [background@2x.png](mailto:background@2x.png)
    *文件或* [background@3x.png](mailto:background@3x.png) *文件。这两个文件之前已经添加到资源目录中，Xcode会自动选择合适的文件。你只需要在代码中引用它为“background”或“background.png”。要了解Xcode如何选择合适的文件，请参见“[为不同屏幕分辨率调整图像大小](text00026.html#ch14lev1sec7)”在[第213页](text00026.html#page_213)。注意，变量名不需要与图像名称匹配——你可以随意为变量命名。然而，图像名称必须与您在项目的资源目录中添加的文件匹配。SKSpriteNode是SpriteKit中的精灵类，因此当我们在游戏中创建精灵时，我们会创建一个SKSpriteNode，正如我们在这里所做的那样。
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-5003
  prefs: []
  type: TYPE_NORMAL
  zh: 第➋和➌行创建了常量xMid和yMid，它们将表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个frame，描述它在屏幕上的位置。frame有一个x坐标、一个y坐标、一个宽度和一个高度（参见[图14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕frame的中间x位置，而midY给出了中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-5004
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-5005
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：frame描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-5006
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint，并将其分配给精灵的位置属性，从而将背景图像的位置设置为屏幕的中间。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-5007
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。当处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个单独的CGPoint可以包含两个值，一个用于*x*，一个用于*y*，这使得在二维游戏中处理屏幕坐标非常方便，因为游戏中的所有内容都需要使用x和y坐标进行定位。
- en: '**NOTE**'
  id: totrans-5008
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-5009
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自* Core Graphics框架*，这是一个用于图形处理的苹果框架。你会注意到这种命名系统在Swift中非常常见——类或结构体的前两个或三个字母通常告诉你该对象的用途或来源。例如，所有SpriteKit的类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-5010
  prefs: []
  type: TYPE_NORMAL
  zh: ➎处的代码通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子物体*，意味着它附加在该场景上。例如，如果场景变大、缩小或消失，这个子精灵也会一起改变。在SpriteKit游戏中，场景始终是父物体，每个精灵都作为场景的子物体或另一个精灵的子物体被添加。每次添加精灵时，都需要考虑这个精灵的父物体应该是什么。例如，滑板精灵是场景的子物体，但如果我们想要为滑板者添加可互换的帽子，我们将使用一个帽子精灵，该帽子精灵是滑板者精灵的子物体。这样，每当滑板者跳跃时，帽子会留在滑板者身上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-5011
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-5012
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时在竖屏和横屏模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并只选择这一种。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（即设备处于侧放状态，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-5013
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-5014
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏与横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-5015
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行该项目，你会注意到它可能默认处于竖屏方向。让我们更改项目设置，使得游戏仅在横屏模式下运行。转到项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-5016
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5017
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5018
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5019
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5020
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中Portrait选项，保留两个Landscape方向选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5021
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此列表将出现，图标会变为蓝色，表示列表区域现在已经显示。确保已选择**SchoolhouseSkateboarder**目标。现在找到**Portrait**复选框并取消选中它。保持横屏方向选项被勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5022
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经接近完成，但背景图像还没有填满整个屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5023
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏在横屏模式下运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**Hardware** ▸ **Rotate Right**，如[图
    14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5024
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5025
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5026
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**不同屏幕分辨率的图像尺寸设置**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5027
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你需要处理的屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的图像资源在每个设备上都能正确显示。游戏往往在这方面需要比基于
    UIKit 的应用程序（比如我们的生日追踪器）更多的工作，因为如果仅仅缩放图像，游戏的艺术作品会显得拉伸变形。为避免此问题，你需要为每个想要支持的设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-5028
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5029
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 提供了一种命名图像文件的系统，帮助你区分不同设备所使用的图像。例如，假设你想为游戏添加一张滑冰者的图像，并且你有一张宽 100 像素、高 100
    像素（100×100）的滑冰者图像文件，你应该将该图像命名为 *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)*、大小为
    200×200 像素的图像，以及另一张命名为 *[skater@3x.png](mailto:skater@3x.png)*、大小为 300×300 像素的图像。这三张文件应该是相同图像的三个不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需引用文件名
    skater，只要你正确命名了项目中的图像，Xcode 就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5030
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《滑板学校》，我们将支持从 iPhone 4 起的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5031
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5032
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被视为 1x 图像。你只需要为具有非
    Retina 显示屏的老旧设备（如 iPhone 3GS 或第一代 iPad mini）提供 1x 尺寸的图像。因此，我们所有的图像文件都会有* @2x *或*
    @3x *的后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5033
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图像分组在一起。如果你同时将图像拖入 Xcode 资源目录，Xcode 会根据它们的命名自动识别这些图像是同一张图像的不同尺寸，并将它们分组在一起。请参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5034
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5035
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5036
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还有最后一步准备工作需要完成。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图片并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板在处理游戏场景大小时的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在这个项目中不会使用场景编辑器，所以我们需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5037
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5038
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5039
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码以设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5040
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE221]'
  id: totrans-5041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5042
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置新场景的大小，以确保它填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5043
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图片应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5044
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5045
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作Schoolhouse Skateboarder游戏并学习了SpriteKit。你学习了如何在Xcode中创建一个游戏项目并将资源（如图片）导入项目。你还了解了通过标准的文件命名规则来支持各种设备屏幕分辨率，以及如何选择游戏中需要的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5046
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作程序了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切开始运动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5047
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  id: totrans-5048
  prefs: []
  type: TYPE_NORMAL
  zh: ➋和➌行创建了常量xMid和yMid，它们将表示屏幕的中间位置。frame是GameScene的一个属性——它是一个CGRect（矩形），表示整个屏幕。每个场景和精灵都有一个框架，描述了它在屏幕上的位置。框架有x位置、y位置、宽度和高度（见[图14-7](text00026.html#ch14fig7)）。midX属性给出了屏幕框架的中间x位置，midY给出了中间y位置。
- en: '![](Image00279.jpg)'
  id: totrans-5049
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-5050
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-5051
  prefs: []
  type: TYPE_NORMAL
  zh: ➍行通过使用xMid和yMid创建一个CGPoint，并将其赋值给精灵的position属性，设置了背景图片的位置，使其位于屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-5052
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 和 y 坐标。当你处理屏幕坐标时，通常会使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个单独的 CGPoint 可以保存两个值，一个用于 *x*，另一个用于 *y*，这使得它在 2D 游戏中处理屏幕坐标非常方便，因为在
    2D 游戏中，一切都通过 x 和 y 坐标来定位。
- en: '**NOTE**'
  id: totrans-5053
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-5054
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自* Core Graphics框架*，这是 Apple 用于图形处理的框架。你会经常在 Swift 中看到这种命名系统——类或结构体的前两个或三个字母通常会告诉你这个对象的用途或来源。例如，所有的
    SpriteKit 类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-5055
  prefs: []
  type: TYPE_NORMAL
  zh: 第 ➎ 行通过调用函数 addChild(_:) 将背景图像添加到场景中。这个精灵现在是场景的*子节点*，意味着它被附加到这个场景上。例如，如果场景变大、变小或消失，这个子精灵也会随之变化。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵都作为场景的子节点或另一个精灵的子节点添加。每当你添加一个精灵时，考虑它的父节点应该是什么是很重要的。例如，滑板精灵是场景的子节点，但如果我们想给滑板者添加可更换的帽子，我们会使用一个帽子精灵，作为滑板精灵的子节点。这样，每当滑板者跳跃时，帽子会保持在滑板者头上，而不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-5056
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-5057
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，并只选择那个方向。由于我们的游戏是一个水平滚动的动作游戏，横屏模式（设备横置，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-5058
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-5059
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-5060
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能默认处于竖屏模式。让我们更改项目设置，使游戏仅在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如[图
    14-9](text00026.html#ch14fig9)中所看到的。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-5061
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5062
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5063
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5064
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5065
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中竖屏选项，保留两个横屏方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5066
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标列表，点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。列表将会出现，图标也会变蓝，表示该列表区域现在已显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**纵向**复选框并取消选中它。保持横屏模式的选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5067
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经更近一步，但背景图像还没有填满整个屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5068
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经在横屏模式下运行，你需要确保你的模拟器也处于横屏模式。要旋转它，选择模拟器菜单中的**硬件** ▸ **右旋**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5069
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5070
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5071
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**不同屏幕分辨率的图像尺寸调整**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5072
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，应该先决定我们要支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要额外工作以确保你创建的艺术资源在每个设备上都能正确显示。游戏通常比基于UIKit的应用（如我们的生日追踪器）在这方面需要更多的工作，因为如果你只是简单地缩放，游戏的艺术图像会看起来被拉伸。为了避免这个问题，你必须为每个想要支持的设备使用不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-5073
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5074
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个系统来命名图像文件，帮助你区分哪些图像是为哪些设备准备的。例如，假设你想在游戏中添加一张滑板手的图片，而你有一张滑板手图像文件，大小为100像素宽和100像素高（100×100）。你应该将这个图像命名为*skater.png*。你还需要创建一张命名为*[skater@2x.png](mailto:skater@2x.png)*，大小为200×200像素的图像，另再创建一张命名为*[skater@3x.png](mailto:skater@3x.png)*，大小为300×300像素的图像。这三张文件应该是相同的图像，但大小不同。如果游戏在iPhone
    4上运行，带有*2x*后缀的文件将会自动被使用。如果游戏在iPhone 6 Plus上运行，带有*3x*后缀的文件将会自动被使用。在你的代码中，你只需引用图像文件名为skater，Xcode会根据你在项目中正确命名的图像来显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5075
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-5076
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5077
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，比如* @2x *或* @3x*。没有后缀的图片，例如* skater.png*，被认为是 1x 图片。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini，这些设备没有视网膜显示屏）包含 1x 尺寸的图片。因此，我们所有的图片文件都会带有 *@2x* 或 *@3x*
    后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5078
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会发现 Xcode 将这两张图片归为一组。如果你同时将这两张图片拖入 Xcode 资源目录，Xcode 会自动识别它们是同一张图片的不同尺寸，并将它们归为一组，这一切都源于它们的命名方式。请参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5079
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5080
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：多种尺寸的图片在资源目录中被归为一组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5081
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还有最后一步准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片并没有填满整个屏幕，如
    [图 14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板在处理游戏场景大小时的方式。游戏场景的大小将基于包含在我们项目中的
    *GameScene.sks* 场景编辑器文件的设置来决定。由于我们在这个项目中不会使用场景编辑器，所以我们需要添加代码以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5082
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5083
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5084
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5085
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE222]'
  id: totrans-5086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5087
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主场景，我们希望它始终填充整个屏幕。我们在这里添加的代码决定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5088
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目，背景图片应该现在能够填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5089
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5090
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作 Schoolhouse Skateboarder 游戏，并学习了 SpriteKit。你学习了如何在 Xcode 中创建一个游戏项目并将资源（如图片）导入到项目中。你还了解了通过标准的文件命名规范来支持不同设备的屏幕分辨率，并学习了如何选择游戏中需要使用的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5091
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来该编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将加入我们的主角和她滑行的地面，使一切动起来，并让玩家点击屏幕使她跳跃。
- en: '![](Image00288.jpg)![](Image00279.jpg)'
  id: totrans-5092
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00279.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-5093
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-5094
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行通过使用xMid和yMid创建一个CGPoint，并将其赋值给精灵的位置属性，从而将我们的背景图像位置设置到屏幕中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-5095
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，分别表示x和y坐标。在处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以存储两个值，一个表示*x*坐标，一个表示*y*坐标，这使得在2D游戏中处理屏幕坐标变得更加方便，因为所有物体的位置都需要同时使用x和y坐标来定位。
- en: '**NOTE**'
  id: totrans-5096
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-5097
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的名称都来自*Core Graphics框架*，这是Apple用于图形的框架。你会在Swift中经常看到这种命名方式——类或结构体的前两个或三个字母通常能告诉你该对象的用途或来源。例如，所有SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-5098
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它已附加到该场景中。例如，如果场景变大、变小或消失，这个子精灵也会跟着变化。在SpriteKit游戏中，场景始终是父对象，所有精灵都作为该场景的子对象或另一个精灵的子对象添加。每次添加精灵时，重要的是要考虑该精灵的父对象应该是什么。例如，滑冰者精灵是场景的子对象，但如果我们想为滑冰者添加可更换的帽子，我们将使用一个帽子精灵，它是滑冰者精灵的子对象。这样，每当滑冰者跳跃时，帽子就会跟随滑冰者一起移动，而不需要单独移动帽子。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-5099
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-5100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个能够在纵向和横向模式下运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择其中一种。由于我们的游戏是一个水平滚动的动作游戏，因此横向模式（设备横置，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-5101
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-5102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在纵向与横向模式下的展示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-5103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能默认是竖屏方向。我们来更改项目设置，使游戏仅以横屏方式运行。进入项目导航器，点击 **SchoolhouseSkateboarder**
    项目——它位于项目导航器的顶部，旁边有一个蓝色图标，正如你在[图14-9](text00026.html#ch14fig9)中看到的那样。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-5104
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5106
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标列表。
- en: '![](Image00283.jpg)'
  id: totrans-5107
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中竖屏选项，保持选中两个横屏方向选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。列表会出现，并且图标会变蓝，表示该区域正在显示。确保选中了
    **SchoolhouseSkateboarder** 目标。现在找到 **竖屏** 复选框并取消选中，保持横屏方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5110
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们已经接近完成，但背景图片还没有完全填充屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5111
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在已经以横屏方向运行，你需要确保模拟器也处于横屏方向。要旋转它，选择模拟器菜单中的 **硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5112
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：将模拟器方向旋转以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5115
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。与我们像生日追踪器这样的基于
    UIKit 的应用程序相比，游戏在这方面通常需要更多的努力，因为如果你只是简单地缩放图像，它可能会看起来被拉伸。为了避免这个问题，你必须为每个你想要支持的设备准备一组不同的图片。
- en: '![](Image00285.jpg)'
  id: totrans-5116
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5117
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个命名图片文件的系统，可以帮助你区分哪些图片适用于哪些设备。例如，假设你想在游戏中添加一张滑板车的图片，并且你有一张100像素宽，100像素高（100×100）的滑板车图片文件。你会将该图片命名为
    *skater.png*。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)* 的图片，大小为200×200像素，另一个名为
    *[skater@3x.png](mailto:skater@3x.png)* 的图片，大小为300×300像素。这三张文件应该是相同图片的不同大小版本。如果游戏在iPhone
    4上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在iPhone 6 Plus上运行，则会自动使用 *@3x* 后缀的文件。在你的代码中，你只需要引用图片为
    skater ，只要你正确命名了项目中的图片，Xcode会自动显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5119
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5120
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，比如* @2x *或* @3x*。没有后缀的图片，如* skater.png*，被认为是1x图片。你只需要为那些没有视网膜显示屏的旧设备（如iPhone
    3GS或第一代iPad mini）包含1x大小的图片。因此，我们所有的图片文件都会带有* @2x *或* @3x* 后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件分别命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资产目录，你会注意到Xcode将这两张图片分组在一起。如果你同时将多个图片拖入Xcode的资产目录，Xcode会根据它们的命名自动识别它们是同一图片的不同尺寸，并将它们分组在一起。参见
    [图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5122
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图片在资产目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理背景图片之前，还有最后一项准备工作需要完成。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图片没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将基于我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置。我们在这个项目中不会使用场景编辑器，所以我们需要添加代码以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5125
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5127
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，并找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5128
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE223]'
  id: totrans-5129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5130
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该会填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作“学校滑板游戏”，并学习了关于SpriteKit的知识。你学会了如何在Xcode中创建游戏项目并将资源（如图片）导入项目。你还学习了如何通过标准文件命名规范来支持不同设备屏幕分辨率，以及如何选择游戏中需要使用的图片类型。最后，你创建并展示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了一个SpriteKit游戏项目，包含了我们需要的资源，并解决了屏幕方向和分辨率的问题，接下来该编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将加入我们的英雄角色和她滑行的地面，使一切开始移动，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5135
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  id: totrans-5136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-7：一个框架描述了精灵的位置和大小。*'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-5137
  prefs: []
  type: TYPE_NORMAL
  zh: ④处的代码通过使用xMid和yMid创建一个CGPoint，并将其赋值给精灵的位置属性，从而将我们的背景图像的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-5138
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，表示x和y坐标。当你处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以包含两个值，一个是*x*，一个是*y*，这使得它在处理2D游戏中的屏幕坐标时非常方便，因为在2D游戏中，一切都通过x和y的位置来定位。
- en: '**NOTE**'
  id: totrans-5139
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-5140
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何内容都来自于* Core Graphics框架*，这是Apple用于图形处理的框架。你会在Swift中经常看到这种命名系统——类或结构体的前两三个字母通常会告诉你该对象的用途或来源。例如，所有的SpriteKit类，如*
    SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-5141
  prefs: []
  type: TYPE_NORMAL
  zh: ➎这一行通过调用addChild(_:)函数将背景图片添加到场景中。这个精灵现在是场景的*子对象*，意味着它附着在这个场景上。例如，如果场景发生缩放或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都是作为子对象添加到场景中，或者作为另一个精灵的子对象。每当你添加一个精灵时，重要的是要考虑该精灵的父对象应该是什么。例如，滑板精灵是场景的子对象，但如果我们想在滑板者上添加可更换的帽子，我们会使用一个帽子精灵，它是滑板者精灵的子对象。这样，每当滑板者跳跃时，帽子会保持在滑板者头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-5142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-5143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持纵向和横向模式的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，然后只选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，横向模式（设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-5144
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-5145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在纵向和横向模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-5146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能会默认进入纵向模式。让我们更改项目设置，使游戏仅在横向模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目—它位于项目导航器顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-5147
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5149
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5150
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5151
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选纵向选项，保留横向模式的两个选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到屏幕上的项目和目标列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此列表将出现，图标会变蓝，表示列表区域现在已显示。确保选择了**SchoolhouseSkateboarder**目标。现在找到**纵向**复选框并取消勾选。保留横向模式选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横向模式启动。我们越来越接近目标了，但背景图片还没有填满整个屏幕。我们稍后会看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5154
  prefs: []
  type: TYPE_NORMAL
  zh: 既然游戏现在在横向模式下运行，你需要确保模拟器也处于横向模式。要旋转它，请从模拟器菜单中选择**硬件** ▸ **向右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5155
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5158
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你就需要处理的屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的艺术作品能够在每个设备上正确显示。与基于UIKit的应用程序（如我们的生日跟踪器）相比，游戏在这方面通常需要更多的努力，因为如果仅仅将游戏艺术作品按比例放大或缩小，它看起来会被拉伸。为了避免这个问题，你将需要为每个你想要支持的设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-5159
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5160
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个命名图像文件的系统，帮助你区分哪些图像适用于哪些设备。例如，假设你想要为游戏添加一张滑板车图像，而你有一张宽100像素、高100像素（100×100）的滑板车图像。你将这张图像命名为
    *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)* 的图像，大小为200×200像素，以及另一张命名为
    *[skater@3x.png](mailto:skater@3x.png)* 的图像，大小为300×300像素。这三张图像应该是同一张图像的三种不同大小。如果游戏在iPhone
    4上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在iPhone 6 Plus上运行，带有 *@3x* 后缀的文件将自动被使用。在代码中，你只需引用文件名skater，且只要你在项目中正确命名了图像，Xcode会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Schoolhouse Skateboarder，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-5162
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5163
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被视为1x图像。你只需要为那些没有视网膜显示屏的旧设备（例如iPhone
    3GS或第一代iPad mini）包含1x大小的图像。因此，我们所有的图像文件都会有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到Xcode将这两张图像归在一起。如果你同时将图像拖入Xcode资源目录，Xcode会根据它们的命名自动识别它们是同一图像的不同大小，并将它们分组在一起。请参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5165
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图像会在资源目录中分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5167
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一点准备工作需要做。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板处理游戏场景大小的方式。游戏场景的大小将基于我们项目中包含的*GameScene.sks*场景编辑器文件中的设置。由于我们在这个项目中不会使用场景编辑器，所以需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5168
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5170
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件并找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5171
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE224]'
  id: totrans-5172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5173
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了GameScene类的一个实例并显示它。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5174
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作了《Schoolhouse Skateboarder》游戏，并学习了SpriteKit。你学会了如何在Xcode中创建游戏项目并将资源（如图像）导入项目。你还学习了通过标准的文件命名实践来支持各种设备的屏幕分辨率，并了解了在游戏中如何选择所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了SpriteKit游戏项目，并且拥有了所需的资源，解决了屏幕方向和分辨率的问题，接下来该编程一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的主角和她滑行的地面，使一切开始移动，并让玩家通过点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5178
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  id: totrans-5179
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 这一行通过使用xMid和yMid创建一个CGPoint，并将其赋值给精灵的位置属性，从而将背景图像的位置设置为屏幕的中央。
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-5180
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint是一个结构体，包含两个CGFloat值，表示x和y坐标。在处理屏幕坐标时，通常使用CGFloat作为数据类型，而不是Float或Double。一个CGPoint可以容纳两个值，一个表示*x*，一个表示*y*，这使得它在2D游戏中处理屏幕坐标非常方便，因为所有内容的位置都需要使用x和y坐标。
- en: '**NOTE**'
  id: totrans-5181
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-5182
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自* Core Graphics框架*，这是一个用于图形的苹果框架。您会在Swift中经常看到这种命名方式——类或结构的前两三个字母通常会告诉您该对象的用途或来源。例如，所有的SpriteKit类，如*SKSpriteNode*，都以*SK*开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-5183
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用函数addChild(_:)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，这意味着它附加在这个场景上。例如，如果场景发生扩展、收缩或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵都是作为该场景的子对象或作为另一个精灵的子对象添加的。每次添加一个精灵时，考虑它的父对象应该是什么是很重要的。例如，滑冰者精灵是场景的子对象，但如果我们想要为滑冰者添加可更换的帽子，我们会使用一个帽子精灵，该帽子精灵是滑冰者精灵的子对象。这样，每当滑冰者跳跃时，帽子会留在滑冰者头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-5184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-5185
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合您的游戏，然后只选择那个方向。由于我们的游戏是一个水平滚动的动作游戏，横屏方向（即设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-5186
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-5187
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏和横屏模式下的表现*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-5188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，您会注意到它可能默认使用竖屏方向。我们来修改项目设置，让游戏只在横屏下运行。进入项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器顶部，旁边有一个蓝色图标，正如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-5189
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5191
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，您可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5192
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中竖屏选项，保留横屏方向的两个选项已选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在屏幕上看不到项目和目标的列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。列表将会出现，图标会变成蓝色，表示现在显示的是列表区域。确保选择了**SchoolhouseSkateboarder**目标。然后找到**Portrait**复选框并取消选中。保留横屏方向选项已选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5195
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经接近完成，但背景图像还没有完全填满屏幕。稍后我们将看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏现在是横屏模式，你需要确保你的模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **旋转右侧**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5197
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5198
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5200
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源在每个设备上都能正确显示。相比基于UIKit的应用程序，如我们的生日追踪器，游戏在这方面通常需要更多的工作，因为如果你只是简单地放大或缩小图像，游戏的艺术作品可能会显得拉伸。为了避免这个问题，你需要为每个想要支持的设备使用一组不同的图片。
- en: '![](Image00285.jpg)'
  id: totrans-5201
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5202
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一套命名规则，帮助你识别不同设备对应的图像文件。例如，假设你想要在游戏中添加一张滑板运动员的图片，而你的滑板运动员图像文件是100像素宽，100像素高（100×100）。你会将该图像命名为*skater.png*。你还需要创建一个名为*[skater@2x.png](mailto:skater@2x.png)*的200×200像素图像，另一个名为*[skater@3x.png](mailto:skater@3x.png)*的300×300像素图像。这三张文件应该是三种不同尺寸的相同图像。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件将自动被使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件将自动被使用。在你的代码中，你只需要引用文件名skater，Xcode会根据你项目中的正确命名自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》游戏，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-5204
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5205
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，如* @2x *或* @3x*。没有后缀的图片，如*skater.png*，被视为1x图像。你只需要为没有视网膜显示屏的旧设备提供1x大小的图片，例如iPhone
    3GS或第一代iPad mini。因此，我们的所有图像文件都会带有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名分别为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图像归为一组。如果你同时将不同尺寸的图像拖入 Xcode 资源目录，Xcode
    会根据它们的命名自动识别它们是同一图像的不同尺寸，并将它们归为一组。见[图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5207
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5208
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12: 多种尺寸的图像在资源目录中被归为一组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从背景图像部分继续之前，还有最后一项准备工作需要处理。你可能注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为 Game 模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置来确定。由于我们在这个项目中不会使用场景编辑器，因此需要添加代码以确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5210
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5211
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13: 背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5212
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，并找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5213
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE225]'
  id: totrans-5214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5215
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了 GameScene 类的一个实例并显示它。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，以确保它填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5216
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。此时背景图像应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作了 Schoolhouse Skateboarder 游戏，并了解了 SpriteKit。你学习了如何在 Xcode 中创建游戏项目并导入资源，例如图像。你还了解了如何通过标准文件命名规则支持各种设备屏幕分辨率，以及如何选择在游戏中需要使用的图像类型。最后，你创建并展示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切开始移动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5220
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  id: totrans-5221
  prefs: []
  type: TYPE_NORMAL
  zh: CGPoint 是一个结构体，包含两个 CGFloat 值，分别表示 x 和 y 坐标。当你处理屏幕坐标时，通常使用 CGFloat 作为数据类型，而不是
    Float 或 Double。一个 CGPoint 可以存储两个值，一个是*x*，另一个是*y*，这使得它在处理 2D 游戏中的屏幕坐标时非常方便，因为游戏中的一切都需要使用
    x 和 y 坐标来定位。
- en: '**NOTE**'
  id: totrans-5222
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-5223
  prefs: []
  type: TYPE_NORMAL
  zh: '*以* CG *开头的任何东西都来自* Core Graphics 框架*，这是一个苹果用于图形处理的框架。你会在 Swift 中经常看到这种命名方式——一个类或结构体的前两个或三个字母通常会告诉你该对象的用途或来源。例如，所有
    SpriteKit 的类，如* SKSpriteNode *，都以* SK *开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-5224
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 这一行通过调用 addChild(_:) 函数将背景图像添加到场景中。这个精灵现在是场景的*子对象*，意味着它附着在这个场景上。例如，如果场景扩大、缩小或消失，这个子精灵也会随之变化。在
    SpriteKit 游戏中，场景始终是父对象，每个精灵都作为场景的子对象或其他精灵的子对象被添加。每当你添加一个精灵时，重要的是要思考这个精灵的父对象应该是什么。例如，滑板精灵是场景的子对象，但如果我们想给滑板精灵添加可更换的帽子，我们会使用一个帽子精灵作为滑板精灵的子对象。这样，每当滑板精灵跳跃时，帽子会始终留在滑板精灵头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-5225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**如何进行游戏：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-5226
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持纵向和横向模式的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，并选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，横向模式（设备侧置，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-5227
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-5228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在纵向和横向模式下的表现*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-5229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试着使用 iPhone 7 模拟器运行项目，你会注意到它可能默认进入纵向模式。让我们更改项目设置，使游戏仅在横向模式下运行。前往项目导航器，点击**SchoolhouseSkateboarder**项目—它位于项目导航器的顶部，旁边有一个蓝色图标，正如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-5230
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5232
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到一份项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5233
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5234
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中纵向选项，保持选中横向模式选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，点击窗口左上角的方形图标，如图 [14-10](text00026.html#ch14fig10) 所示。此列表将会出现，图标会变蓝，表示列表区域现在已显示。确保选择了
    **SchoolhouseSkateboarder** 目标。然后找到 **Portrait** 复选框并取消勾选，保持横屏方向选项被勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5236
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们已经越来越接近目标，但背景图像还没有完全填充屏幕。稍后我们将看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经以横屏模式运行，你需要确保模拟器也是横屏模式。要旋转模拟器，请从模拟器的菜单中选择 **硬件** ▸ **右旋**，如图 [14-11](text00026.html#ch14fig11)
    所示。
- en: '![](Image00284.jpg)'
  id: totrans-5238
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5239
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5241
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你就需要处理更多的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源在每个设备上都能正确显示。与基于
    UIKit 的应用（比如我们的生日追踪器）相比，游戏在这方面通常需要更多的工作，因为如果仅仅将艺术资源进行缩放，游戏的图像就会显得拉伸。为了避免这个问题，你必须为每个你想要支持的设备准备一套不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-5242
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5243
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个命名规则，用于帮助你识别哪些图像是为哪些设备准备的。例如，假设你想将一个滑板者的图像添加到游戏中，并且你有一个滑板者图像文件，大小是
    100 像素宽、100 像素高（100×100）。你会将这个图像命名为 *skater.png*。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，大小是 200×200 像素，再创建一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，大小为 300×300
    像素。这三个文件应该是同一张图像的不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6 Plus
    上运行，带有 *@3x* 后缀的文件将自动被使用。在代码中，你只需要引用文件名 skater ，只要你在项目中正确命名了图像，Xcode 就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder 游戏，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5245
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5246
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，例如*skater.png*，被认为是1x图像。你只需要为旧设备（如iPhone
    3GS或第一代iPad mini，它们没有视网膜显示屏）包含1x大小的图像。因此，我们所有的图像文件将会有* @2x *或* @3x*后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图像组合在了一起。如果你同时将不同尺寸的图像拖到Xcode的资源目录中，Xcode会自动识别它们是同一张图像的不同尺寸，并根据它们的命名将它们组合在一起。见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5248
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图像在资源目录中被组合在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5250
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从背景图像的部分继续进行之前，还有最后一点准备工作需要处理。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，正如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码，以确保我们的场景尺寸正确。
- en: '![](Image00287.jpg)'
  id: totrans-5251
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5252
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5253
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，并找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5254
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE226]'
  id: totrans-5255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5256
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了所显示视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5257
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你所学到的**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了SpriteKit。你学习了如何在Xcode中创建一个游戏项目并导入资源，比如图像。你还学习了如何通过标准的文件命名规则支持各种设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了SpriteKit游戏项目，并准备好了所需的资源，解决了屏幕方向和分辨率的问题，接下来是编程一些动作。在[第15章](text00027.html#ch15)中，我们将添加我们的主角和她滑行的地面，让一切开始运动，并让玩家点击屏幕使她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5261
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '**NOTE**'
  id: totrans-5262
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  id: totrans-5263
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何以* CG *开头的东西都来自* Core Graphics框架*，这是一个用于图形处理的苹果框架。你会在Swift中经常看到这种命名方式——类或结构体的前两三个字母通常告诉你这个对象的用途或它的来源。例如，所有的SpriteKit类，如*SKSpriteNode*，都以*SK*开头。*'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-5264
  prefs: []
  type: TYPE_NORMAL
  zh: ➎处的代码通过调用函数addChild(_)将背景图像添加到场景中。这个精灵现在是场景的*子对象*，这意味着它被附加到这个场景上。例如，如果场景变大、变小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景总是父对象，每个精灵都是该场景或另一个精灵的子对象。每次添加精灵时，重要的是要考虑该精灵的父对象应该是什么。例如，滑板者精灵是场景的子对象，但如果我们想给滑板者添加可替换的帽子，我们会使用一个帽子精灵，它是滑板者精灵的子对象。这样，每当滑板者跳跃时，帽子会留在滑板者头上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-5265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-5266
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可以在竖屏和横屏模式下运行的游戏需要更多工作，因此通常最好决定哪种方向最适合你的游戏，并选择那一个。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（即设备侧放，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-5267
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-5268
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏与横屏方向下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-5269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能默认使用竖屏方向。让我们更改项目设置，使游戏仅在横屏模式下运行。进入项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-5270
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5271
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5272
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5273
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5274
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中竖屏选项，保留选中两个横屏方向选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到项目和目标列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。该列表将会出现，并且图标会变蓝，表示列表区域已经显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**Portrait（竖屏）**复选框并取消勾选。保持横屏模式的选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5276
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，您会看到它以横屏模式启动。我们已经接近完成了，但背景图像还没有完全填满屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏正在横屏模式下运行，您需要确保模拟器也处于横屏模式。要旋转模拟器，请从模拟器菜单中选择**硬件** ▸ **旋转右侧**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5278
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5279
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：将模拟器方向旋转以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5281
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，您就需要处理更多不同的屏幕尺寸，这意味着您需要额外的工作来确保您创建的艺术资源能够在每个设备上正确显示。与像我们的生日追踪器这样的基于UIKit的应用程序相比，游戏通常在这方面需要更多的努力，因为如果您只是简单地放大或缩小，游戏艺术作品可能会看起来拉伸变形。为避免这个问题，您需要为每个想要支持的设备使用不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-5282
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5283
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个图像文件命名系统，帮助您区分不同设备的图像。例如，假设您想为游戏添加一个滑板手的图像，并且您有一个宽100像素，高100像素的滑板手图像文件（100×100）。您应该将该图像命名为*skater.png*。您还需要创建一个命名为*[skater@2x.png](mailto:skater@2x.png)*的图像，大小为200×200像素，另外还需要创建一个命名为*[skater@3x.png](mailto:skater@3x.png)*的图像，大小为300×300像素。这三个文件应该是同一图像的三个不同尺寸。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件将自动被使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件将自动被使用。在您的代码中，您只需引用图像文件名为skater，Xcode会根据您在项目中正确命名的图像来显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将从iPhone 4开始支持所有设备。这意味着我们需要支持以下四个屏幕分辨率：960×640，1136×640，1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-5285
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5286
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，比如* @2x *或* @3x*。没有后缀的图片，比如* skater.png*，被认为是1x图像。你只需要为旧设备（如iPhone
    3GS或第一代iPad mini）提供1x尺寸的图片，这些设备没有视网膜显示屏。因此，我们所有的图片文件都会带有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图片分组在一起。如果你同时将尺寸不同的图片拖入Xcode的资源目录，Xcode会自动识别它们是同一张图片的不同尺寸，并根据命名将它们分组。请参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5288
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5289
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图片在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5290
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还有最后一项准备工作。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图片并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板处理游戏场景尺寸的方式所致。游戏场景的大小将基于包含在我们项目中的*GameScene.sks*场景编辑器文件中的设置。由于我们在本项目中不会使用场景编辑器，因此我们需要添加代码来确保我们的场景尺寸正确。
- en: '![](Image00287.jpg)'
  id: totrans-5291
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5292
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5293
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，并找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5294
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE227]'
  id: totrans-5295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5296
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()`方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5297
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。此时背景图片应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了SpriteKit。你学习了如何在Xcode中创建一个游戏项目并导入资源文件，比如图片。你还学习了如何通过标准文件命名规范来支持不同设备的屏幕分辨率，以及如何选择在游戏中需要的图片类型。最后，你创建并展示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个SpriteKit游戏项目，包含所需的资源，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将加入我们的英雄角色和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5301
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  id: totrans-5302
  prefs: []
  type: TYPE_NORMAL
  zh: 第➎行通过调用addChild(_:)函数将背景图片添加到场景中。这个精灵现在是场景的*子对象*，意味着它被附加到这个场景上。例如，如果场景扩大、缩小或消失，这个子精灵也会随之变化。在SpriteKit游戏中，场景始终是父对象，每个精灵作为该场景的子对象或另一个精灵的子对象添加。每次添加精灵时，重要的是要考虑该精灵的父对象应该是谁。例如，滑冰者精灵是场景的子对象，但如果我们想给滑冰者添加可更换的帽子，我们会使用一个帽子精灵，它是滑冰者精灵的子对象。这样，每当滑冰者跳跃时，帽子就会保持在滑冰者身上，我们就不需要单独移动帽子了。
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-5303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏如何进行：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-5304
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个在竖屏和横屏模式下都能运行的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，并选择那个方向。由于我们的游戏是一个横向滚动的动作游戏，横屏方向（设备横置，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-5305
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-5306
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-5307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，你会注意到它可能默认使用竖屏模式。我们来更改项目设置，让游戏仅在横屏模式下运行。前往项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-5308
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5309
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5310
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5311
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5312
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中“竖屏”选项，保留两个“横屏”方向选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到项目和目标列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此时该列表将出现，并且图标会变为蓝色，表示该列表区域正在显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**竖屏**复选框并取消勾选，保留横屏方向选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5314
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，您会看到它以横屏模式启动。我们越来越接近目标了，但背景图像还没有填满屏幕。稍后我们将看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5315
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏现在以横屏模式运行，您需要确保模拟器也处于横屏模式。要旋转它，请从模拟器菜单中选择**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5316
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5317
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5319
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。您支持的设备越多，您需要处理的不同屏幕尺寸就越多，这意味着您需要额外的工作来确保您创建的艺术资源能够在每个设备上正确显示。与基于UIKit的应用程序（例如我们的生日追踪器）相比，游戏在这方面通常需要更多的工作，因为如果只进行缩放，游戏的艺术作品会看起来拉伸变形。为了避免这个问题，您需要为每个要支持的设备使用不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-5320
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5321
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个图像文件命名系统，可以帮助您区分哪些图像是为哪些设备准备的。例如，假设您想将一个滑板手的图像添加到游戏中，您有一个滑板手图像文件，大小为100像素宽、100像素高（100×100）。您将该图像命名为*skater.png*。您还需要创建一个命名为*[skater@2x.png](mailto:skater@2x.png)*的图像，大小为200×200像素，以及另一个命名为*[skater@3x.png](mailto:skater@3x.png)*的图像，大小为300×300像素。这三个文件应该是同一图像的三种不同尺寸。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件将自动使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件将自动使用。在您的代码中，您只需引用文件名skater，Xcode会根据项目中正确命名的图像自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5322
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Schoolhouse Skateboarder，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-5323
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5324
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被视为1x图像。您只需为旧设备（如iPhone
    3GS或第一代iPad mini，具有非视网膜显示屏的设备）包含1x大小的图像。因此，我们的所有图像文件将具有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图像分组在一起。如果你同时将图像拖入Xcode的资源目录，Xcode会自动识别它们是同一图像的不同尺寸，并根据它们的命名将它们分组在一起。参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5326
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5327
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5328
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作要做。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图像没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将基于包含在我们项目中的*GameScene.sks*场景编辑器文件中的设置。由于在这个项目中我们不会使用场景编辑器，因此我们需要添加代码以确保我们的场景尺寸正确。
- en: '![](Image00287.jpg)'
  id: totrans-5329
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5330
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5331
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5332
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE228]'
  id: totrans-5333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5334
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了所显示视图的大小（宽度和高度），并设置新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5335
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作“学校滑板车”游戏，并了解了SpriteKit。你学习了如何在Xcode中创建游戏项目并将资源（例如图像）导入项目。你还学习了通过标准文件命名规范来支持各种设备屏幕分辨率，并了解了如何选择游戏中需要的图像类型。最后，你创建并展示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切开始运动，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5339
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  id: totrans-5340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**游戏的玩法：屏幕方向**'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-5341
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个能够在竖屏和横屏模式下都能运行的游戏需要更多的工作，因此通常最好决定哪个方向最适合你的游戏，然后只选择这个方向。由于我们的游戏是一个水平滚动的动作游戏，横屏模式（设备横置，如[图
    14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-5342
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-5343
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：我们的游戏在竖屏与横屏方向下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-5344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用 iPhone 7 模拟器，你会注意到它可能默认显示为竖屏方向。我们来修改项目设置，让游戏只在横屏下运行。前往项目导航器并点击**SchoolhouseSkateboarder**项目——它位于项目导航器顶部，旁边有一个蓝色图标，如[图
    14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-5345
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5346
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5347
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5348
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5349
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选竖屏选项，保持两个横屏方向选项被勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此列表将会显示，图标变为蓝色，表示列表区域现在已经显示。确保选择了**SchoolhouseSkateboarder**目标。现在找到**Portrait（竖屏）**复选框并取消勾选。保持横屏方向的选项被勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5351
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们已经接近目标，但背景图片还没有完全填充屏幕。稍后我们会看看如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经在横屏方向下运行，你需要确保模拟器也处于横屏方向。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5353
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5354
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5356
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。与像我们的《生日追踪器》这样的基于
    UIKit 的应用相比，游戏在这一方面通常需要更多的工作，因为如果你只是简单地缩放游戏艺术资源，它们会显得拉伸变形。为避免这个问题，你需要为每个想要支持的设备准备一组不同的图片。
- en: '![](Image00285.jpg)'
  id: totrans-5357
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5358
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名规则，用于帮助你识别图片文件适用于哪些设备。例如，假设你想为你的游戏添加一张滑板车手的图片，且你有一张宽 100 像素、高 100
    像素的滑板车手图片（100×100）。你会将该图片命名为 *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图片，尺寸为 200×200 像素，另外再创建一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为
    300×300 像素。这三张文件应该是同一张图片的三种不同尺寸。如果游戏运行在 iPhone 4 上，带有 *@2x* 后缀的文件会自动被使用。如果游戏运行在
    iPhone 6 Plus 上，带有 *@3x* 后缀的文件会自动被使用。在代码中，你只需要引用文件名 skater，只要你在项目中正确命名了图片，Xcode
    会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5360
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5361
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都带有后缀，如* @2x *或* @3x*。没有后缀的图片，如* skater.png*，被视为 1x 图片。你只需要为那些拥有非视网膜显示屏的旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 大小的图片。因此，我们所有的图片文件都将带有 *@2x* 或 *@3x* 后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*
    。如果你查看 *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图片分组在一起。如果你同时将图片拖入 Xcode 资源目录，Xcode
    会根据图片命名自动识别它们是同一张图片的不同尺寸，并将它们归为一组。参见 [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5363
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5364
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图片被归类到资源目录中。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5365
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完背景图片之前，我们还有最后一点准备工作需要完成。你可能注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片没有填满整个屏幕，如 [图
    14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将基于 *GameScene.sks*
    场景编辑器文件中的设置，该文件已经包含在我们的项目中。我们不会在此项目中使用场景编辑器，因此我们需要添加代码以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5366
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5367
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5368
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，并找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5369
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE229]'
  id: totrans-5370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5371
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5372
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。此时背景图像应当填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5374
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并了解了SpriteKit。你学习了如何在Xcode中创建游戏项目并将资产（如图像）导入项目。你还了解了如何通过标准的文件命名惯例支持各种设备屏幕分辨率，以及如何选择游戏所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来就该编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，推动一切运动，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5376
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  id: totrans-5377
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同时支持竖屏和横屏模式的游戏需要更多的工作，因此通常最好决定哪种方向最适合你的游戏，然后只选择那种方向。由于我们的游戏是一个横向滚动的动作游戏，横屏模式（即设备侧放，如[图14-8](text00026.html#ch14fig8)所示）最为合适。
- en: '![](Image00280.jpg)'
  id: totrans-5378
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-5379
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏和横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-5380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行项目，使用iPhone 7模拟器，你会注意到它可能默认会进入竖屏模式。让我们修改项目设置，使得游戏仅在横屏下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色的图标，正如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-5381
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5382
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5383
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5384
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5385
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中竖屏选项，保留两个横屏选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。该列表将出现，并且图标会变蓝，表示现在显示了列表区域。确保选择了**SchoolhouseSkateboarder**目标。现在找到**竖屏**复选框并取消勾选，保留横屏方向选项的勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5387
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们越来越接近目标了，但背景图像还没有填满屏幕。稍后我们将看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经以横屏方向运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器菜单中选择 **硬件** ▸ **右旋**，如[图 14-11](text00026.html#ch14fig11)
    所示。
- en: '![](Image00284.jpg)'
  id: totrans-5389
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5390
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5392
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，处理不同屏幕尺寸的工作就越多，这意味着你需要额外工作，以确保你创建的艺术资源能够在每个设备上正确显示。游戏在这方面通常需要比基于
    UIKit 的应用程序（例如我们的生日追踪器）更多的努力，因为如果只是简单地缩放，游戏的艺术图像会看起来被拉伸。为了解决这个问题，你需要为每个想要支持的设备使用一套不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-5393
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5394
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个系统来命名图像文件，帮助你区分不同设备使用的图像。例如，假设你想为你的游戏添加一张滑板选手的图像，并且你有一张宽 100 像素，高 100
    像素（100×100）的滑板选手图像文件。你应该将这张图命名为 *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，尺寸为 200×200 像素，另外再创建一张名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，尺寸为 300×300
    像素。这三张文件应该是同一张图像的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将会自动使用。如果游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件将自动使用。在代码中，你只需引用文件名 skater，只要你在项目中正确命名了图像，Xcode 将会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5395
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5396
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5397
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像文件都有一个后缀，比如* @2x *或* @3x*。没有后缀的图像文件，比如* skater.png*，被认为是 1x 图像。你只需要为那些显示非视网膜显示屏的旧设备（例如
    iPhone 3GS 或第一代 iPad mini）包含 1x 大小的图像。因此，我们所有的图像文件将带有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到
    Xcode 将这两张图片分组在一起。如果你同时将这些不同尺寸的图片拖入 Xcode 资源目录，Xcode 会自动识别它们是同一张图片的不同尺寸，并将它们分组在一起，这主要是通过它们的命名来识别的。参见[图
    14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5399
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5400
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图片在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5401
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从背景图片部分继续之前，还有最后一点准备工作需要处理。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景尺寸的方式所导致的。游戏场景的尺寸将基于我们项目中包含的*GameScene.sks*场景编辑器文件中的设置。我们在这个项目中不会使用场景编辑器，因此需要添加代码，确保场景的尺寸合适。
- en: '![](Image00287.jpg)'
  id: totrans-5402
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5403
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5404
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码来设置场景的尺寸：
- en: '*GameViewController.swift*'
  id: totrans-5405
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE230]'
  id: totrans-5406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5407
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5408
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目，背景图片应该已经填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5410
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《滑板学校》游戏，并学习了SpriteKit。你了解了如何在 Xcode 中创建游戏项目并将资源（如图片）导入到项目中。你还了解了如何通过标准的文件命名规范支持各种设备屏幕分辨率，并且知道如何选择游戏中需要的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并且解决了屏幕方向和分辨率的问题，接下来就该编写一些动作了。在[第 15 章](text00027.html#ch15)中，我们将添加我们的主角和她滑行的地面，使所有内容动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00280.jpg)'
  id: totrans-5412
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00280.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-5413
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：游戏在竖屏和横屏下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-5414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试着运行项目，使用 iPhone 7 模拟器，你会注意到它可能默认处于竖屏模式。让我们更改项目设置，使游戏仅在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器顶部，旁边有一个蓝色图标，正如在[图14-9](text00026.html#ch14fig9)中所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-5415
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5416
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5417
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5418
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5419
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中竖屏选项，保持两个横屏方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在屏幕上看到项目和目标列表，请点击窗口左上角的方形图标，正如在[图14-10](text00026.html#ch14fig10)中所示。此列表将显示出来，图标会变成蓝色，表示列表区域现在已显示。确保选中**SchoolhouseSkateboarder**目标。然后找到**竖屏**复选框，取消选中它。保持横屏方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5421
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它在横屏模式下启动。我们越来越接近了，但背景图像还没有完全填充屏幕。稍后我们将看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经在横屏方向下运行，你需要确保模拟器也处于横屏模式。要旋转它，从模拟器的菜单中选择**硬件** ▸ **向右旋转**，正如在[图14-11](text00026.html#ch14fig11)中所示。
- en: '![](Image00284.jpg)'
  id: totrans-5423
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5424
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5426
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解代码之前，应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你需要处理的屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的艺术作品能够在每个设备上正确显示。与像我们的生日跟踪器这样的
    UIKit 应用程序相比，游戏通常在这方面需要更多的努力，因为如果你只是简单地缩放，游戏的艺术作品会显得拉伸变形。为避免这个问题，你必须为每个要支持的设备使用不同的图片集。
- en: '![](Image00285.jpg)'
  id: totrans-5427
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5428
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个命名图像文件的系统，帮助你识别哪些图像是为哪些设备准备的。例如，假设你想在游戏中添加一个滑板者的图像，并且你有一个宽度为100像素、高度为100像素（100×100）的滑板者图像文件。你应该将该图像命名为*skater.png*。你还需要创建一个命名为*[skater@2x.png](mailto:skater@2x.png)*的图像文件，它的大小为200×200像素，再创建一个命名为*[skater@3x.png](mailto:skater@3x.png)*的图像文件，它的大小为300×300像素。这三张文件应该是同一图像的不同大小。如果游戏在iPhone
    4上运行，带有@2x后缀的文件将自动被使用。如果游戏在iPhone 6 Plus上运行，带有@3x后缀的文件将自动被使用。在你的代码中，你只需要引用文件名为skater的文件，只要你正确命名了项目中的图像，Xcode将自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5429
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Schoolhouse Skateboarder，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-5430
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5431
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有后缀，如*@2x*或*@3x*。没有后缀的图像，如*skater.png*，被视为1x图像。你只需要为较旧的设备（如iPhone
    3GS或第一代iPad mini）包含1x大小的图像，这些设备使用的是非Retina显示屏。因此，我们所有的图像文件都会有*@2x*或*@3x*后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图像归为一组。如果你同时将不同大小的图像拖入Xcode资源目录，Xcode会自动根据图像的命名识别它们是同一图像的不同尺寸，并将它们分组在一起。参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5433
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5434
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5435
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作需要完成。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板在处理游戏场景的大小时的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在这个项目中不使用场景编辑器，因此需要添加代码来确保我们的场景正确地调整大小。
- en: '![](Image00287.jpg)'
  id: totrans-5436
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5437
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5438
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，并找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5439
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE231]'
  id: totrans-5440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5441
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5442
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5444
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《学校滑板手》游戏，并学习了SpriteKit。你学习了如何在Xcode中创建一个游戏项目并导入资源，比如图片。你还了解了如何通过标准的文件命名实践支持各种设备屏幕分辨率，并且如何选择在游戏中需要的图片类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个SpriteKit游戏项目，准备好了所需的资源，并解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切开始移动，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5446
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  id: totrans-5447
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-8：我们的游戏在竖屏与横屏模式下的显示效果*'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-5448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用iPhone 7模拟器运行项目，你会发现它可能默认使用竖屏模式。让我们更改项目设置，使游戏仅在横屏模式下运行。进入项目导航器，点击**SchoolhouseSkateboarder**项目——它位于项目导航器的顶部，旁边有一个蓝色图标，如[图14-9](text00026.html#ch14fig9)所示。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-5449
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5450
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5451
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5452
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5453
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消勾选竖屏选项，保留勾选两个横屏方向选项。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5454
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到项目和目标列表，点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。这个列表将会出现，并且图标会变成蓝色，表示该列表区域现在已显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**竖屏**复选框并取消勾选，保持横屏选项为勾选状态。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5455
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们离目标更近了，但背景图像还没有填满屏幕。稍后我们会看看如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5456
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经在横屏模式下运行，你需要确保模拟器也处于横屏模式。要旋转它，选择模拟器菜单中的**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5457
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5458
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5460
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你需要处理的屏幕尺寸就越多，这意味着你需要额外工作，确保你创建的艺术资源能够在每个设备上正确显示。游戏在这一领域的工作量通常比基于UIKit的应用程序（比如我们的生日追踪器）更多，因为如果你只是简单地缩放图像，游戏艺术图像会看起来被拉伸。为了避免这个问题，你必须为每个想要支持的设备使用不同的图片集。
- en: '![](Image00285.jpg)'
  id: totrans-5461
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5462
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个命名图片文件的系统，可以帮助你区分图片适用于哪些设备。例如，假设你想为游戏添加一张滑板图像，并且你有一张 100 像素宽、100 像素高的滑板图像文件（100×100）。你会将该图像命名为*skater.png*。你还需要创建一张名为
    *[skater@2x.png](mailto:skater@2x.png)* 的图像，大小为 200×200 像素，另一个名为 *[skater@3x.png](mailto:skater@3x.png)*
    的图像，大小为 300×300 像素。这三张文件应该是同一张图像的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有*@2x*后缀的文件将自动被使用。如果游戏在
    iPhone 6 Plus 上运行，带有*@3x*后缀的文件将自动被使用。在你的代码中，你只需要引用文件名 skater，Xcode 会根据你项目中正确命名的图像文件来显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5463
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《滑板学校》，我们将从 iPhone 4 开始支持。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750 和
    1920×1080。
- en: '**NOTE**'
  id: totrans-5464
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5465
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，比如* @2x *或* @3x*。没有后缀的图片，比如* skater.png*，被认为是 1x 图片。你只需要为那些没有视网膜显示屏的老设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 尺寸的图片。因此，我们所有的图片文件都会有* @2x *或* @3x *的后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5466
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件命名为*[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图片分组在一起。如果你同时将图片拖入 Xcode 资源目录，Xcode 会根据图片的命名自动识别它们是同一张图片的不同尺寸，并将它们分组在一起。见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5467
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5468
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图片在资源目录中分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5469
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一步准备工作要做。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如 [图
    14-13](text00026.html#ch14fig13) 所示。这是因为 Game 模板在处理游戏场景大小时的方式。游戏场景的大小将根据包含在项目中的
    *GameScene.sks* 场景编辑器文件的设置来决定。由于我们在这个项目中不会使用场景编辑器，所以需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5470
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5471
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5472
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，并找到 `viewDidLoad()` 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5473
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE232]'
  id: totrans-5474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5475
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()` 方法中的代码创建了一个 `GameScene` 类的实例并将其显示出来。由于 `GameScene` 是我们游戏的主场景，我们希望它始终填充整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置了新场景的大小，以便它填满整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5476
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的知识**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5478
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作了《Schoolhouse Skateboarder》游戏，并学习了 SpriteKit。你学会了如何在 Xcode 中创建游戏项目并将资源（如图像）导入项目。你还了解了通过标准文件命名规范来支持各种设备的屏幕分辨率，并学习了如何选择游戏中需要的图像类型。最后，你创建并展示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5479
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置好了一个带有所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来是时候编写一些动作了。在 [第 15 章](text00027.html#ch15)
    中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5480
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  id: totrans-5481
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 iPhone 7 模拟器运行项目，你会注意到它可能默认是竖屏模式。让我们更改项目设置，使得游戏只能以横屏模式运行。进入项目导航器，点击 **SchoolhouseSkateboarder**
    项目——它位于项目导航器的顶部，旁边有一个蓝色图标，就像你在 [图 14-9](text00026.html#ch14fig9) 中看到的那样。
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-5482
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5483
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5484
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 14-10](text00026.html#ch14fig10) 中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5485
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5486
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选竖屏选项，保留横屏方向选项的勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到“项目和目标”列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此时，列表将出现，并且该图标会变蓝，表示现在显示了列表区域。确保**SchoolhouseSkateboarder**目标被选中。然后找到**纵向**复选框，并取消勾选它。保留横屏模式的选项选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5488
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们越来越接近了，但背景图片还没有完全填充屏幕。稍后我们将看看如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已在横屏模式下运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5490
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5491
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5493
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，涉及到的不同屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。相比基于UIKit的应用（如我们的生日追踪器），游戏通常需要更多的工作，因为如果你只是简单地缩放图片，游戏中的艺术作品会显得拉伸。为了避免这个问题，你需要为每个你想支持的设备使用一组不同的图片。
- en: '![](Image00285.jpg)'
  id: totrans-5494
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5495
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一套命名图片文件的系统，帮助你识别哪些图片适用于哪些设备。例如，假设你想在游戏中添加一张滑板运动员的图片，而你有一张宽100像素、高100像素（100×100）的滑板运动员图片文件，你应该将这张图片命名为*skater.png*。你还需要创建一个命名为*[skater@2x.png](mailto:skater@2x.png)*的图片，大小为200×200像素，以及一个命名为*[skater@3x.png](mailto:skater@3x.png)*的图片，大小为300×300像素。这三张图片应该是同一张图片的三种不同尺寸。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件将自动被使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件将自动被使用。在你的代码中，你只需引用文件名skater，Xcode会根据项目中正确命名的图片自动显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5496
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从iPhone 4及之后的设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5497
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5498
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被视为 1x 图像。你只需要为老设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 大小的图像，因为它们没有视网膜显示屏。因此，我们所有的图像文件都会有 *@2x* 或 *@3x*
    后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图像归为一组。如果你同时将两张图像拖入 Xcode 资源目录，Xcode 会自动识别它们是同一张图像的不同尺寸，因为它们的命名方式，并将它们归在一起。参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5500
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5501
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图像在资源目录中被归为一组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5502
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像没有填满整个屏幕，如 [图 14-13](text00026.html#ch14fig13)
    所示。这是因为游戏模板在处理游戏场景的大小时的方式。游戏场景的大小将根据我们项目中包含的 *GameScene.sks* 场景编辑文件中的设置来确定。我们在这个项目中不会使用场景编辑器，因此需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5503
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5504
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5505
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，并找到 viewDidLoad() 方法。添加以下几行代码以设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5506
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE233]'
  id: totrans-5507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5508
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了 GameScene 类的一个实例并显示它。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，以确保它填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5509
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该已经填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5511
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 Schoolhouse Skateboarder 游戏，并学习了 SpriteKit。你学习了如何在 Xcode 中创建游戏项目并导入资源，如图像。你还了解了通过标准文件命名方式支持各种设备屏幕分辨率，并了解如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5512
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个带有所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编程一些动作。在[第 15 章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00281.jpg)![](Image00282.jpg)'
  id: totrans-5513
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00281.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5514
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5515
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5516
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5517
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中竖屏选项，保留两个横屏方向选项选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5518
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上没有看到项目和目标的列表，点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。这个列表会出现，并且图标会变蓝，表示列表区域现在正在显示。确保选中了**SchoolhouseSkateboarder**目标。接下来找到**Portrait**复选框，并取消选中它。保留横屏方向选项为选中状态。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5519
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们越来越接近目标，但背景图像仍未填满屏幕。稍后我们会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经以横屏方向运行，你还需要确保模拟器也处于横屏方向。要旋转它，选择模拟器菜单中的**Hardware** ▸ **Rotate Right**，如[图
    14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5521
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5522
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5524
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们需要决定支持哪些设备和屏幕分辨率。支持的设备越多，你需要处理的不同屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。游戏通常比像我们《生日追踪器》这样的
    UIKit 应用程序需要更多的努力，因为如果你只是简单地缩放图像，游戏的艺术作品看起来会被拉伸。为了避免这个问题，你必须为每个你想支持的设备准备一套不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-5525
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5526
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一套命名图像文件的系统，可以帮助你分辨哪些图像适用于哪些设备。例如，假设你想为游戏添加一张滑板者的图像，而你有一张宽100像素、高100像素的滑板者图像（100×100）。你将为这张图像命名为*skater.png*。你还需要创建一张名为*[skater@2x.png](mailto:skater@2x.png)*的图像，尺寸为200×200像素，再创建一张名为*[skater@3x.png](mailto:skater@3x.png)*的图像，尺寸为300×300像素。这三张图像应该是相同图像的三种不同尺寸。如果游戏在iPhone
    4上运行，带有* @2x*后缀的文件会自动被使用。如果游戏在iPhone 6 Plus上运行，带有* @3x*后缀的文件会自动被使用。在代码中，你只需要引用图像文件名为skater，Xcode会根据你在项目中正确命名的图像来显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5527
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Schoolhouse Skateboarder，我们将支持从iPhone 4及以后的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-5528
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5529
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有后缀，比如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被视为1x图像。你只需要为旧设备（如iPhone
    3GS或第一代iPad mini）包含1x尺寸的图像，因为它们没有视网膜显示屏。因此，我们所有的图像文件都会带有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会发现Xcode将这两张图像分组在一起。如果你同时将图像拖放到Xcode的资源目录中，Xcode会自动识别这些是同一图像的不同尺寸，并根据它们的命名将它们分组在一起。请参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5531
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5532
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：多个尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5533
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作需要完成。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在这个项目中不会使用场景编辑器，因此我们需要添加代码以确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5534
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5535
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5536
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5537
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE234]'
  id: totrans-5538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5539
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主要场景，因此我们希望它始终填充整个屏幕。我们在此添加的代码确定了显示视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5540
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你所学到的**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5542
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了SpriteKit。你学习了如何在Xcode中创建游戏项目并导入资源，如图片等。你还了解了通过标准的文件命名惯例来支持不同设备的屏幕分辨率，以及如何选择游戏中需要的图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5543
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个SpriteKit游戏项目，并准备了所需的资源，解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色以及她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00282.jpg)'
  id: totrans-5544
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00282.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5545
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-9：通过点击项目导航器中的项目条目访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5546
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5547
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5548
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消勾选纵向选项，保留两个横向方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在屏幕上看不到项目和目标的列表，请点击窗口左上角的方形图标，如[图 14-10](text00026.html#ch14fig10)所示。此时列表会出现，图标会变成蓝色，表示该列表区域正在显示。确保选择了**SchoolhouseSkateboarder**目标。现在找到**纵向**复选框并取消勾选。保留横向方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5550
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横向模式启动。我们离目标更近了，但背景图像还没有填满屏幕。我们稍后会看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5551
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经在横向模式下运行，你需要确保模拟器也处于横向模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **右旋转**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5552
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5553
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图片大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5555
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们应该决定要支持哪些设备和屏幕分辨率。你支持的设备越多，处理不同屏幕尺寸的工作就越多，这意味着你需要额外的工作，确保你创建的艺术资源能够在每个设备上正确显示。游戏通常比基于
    UIKit 的应用（如我们的生日跟踪器）需要更多的精力，因为如果你只是简单地放大或缩小，游戏的艺术作品看起来会被拉伸。为了避免这个问题，你必须为每个你想支持的设备准备一套不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-5556
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5557
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个命名图像文件的系统，可以帮助你判断哪些图像适用于哪些设备。例如，假设你想要为你的游戏添加一张滑冰者的图像，且你有一张宽度为 100 像素、高度为
    100 像素（100×100）的滑冰者图像文件。你会将该图像命名为 *skater.png* 。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像，尺寸为 200×200 像素，另一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，尺寸为 300×300
    像素。这三张文件应该是同一张图像的三个不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将会被自动使用。如果游戏在 iPhone
    6 Plus 上运行，则会自动使用带有 *@3x* 后缀的文件。在你的代码中，你只需引用文件名 skater ，只要你在项目中正确命名了图像，Xcode 会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5558
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5559
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5560
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被认为是 1x 图像。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 大小的图像，这些设备没有视网膜显示屏。因此，我们所有的图像文件都会有* @2x *或* @3x
    *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件分别命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*
    。如果你查看 *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图像分组在一起。如果你同时将不同尺寸的图像拖放到 Xcode 资源目录中，Xcode
    会自动识别它们是同一图像的不同尺寸，并将它们分组在一起，这是因为它们的命名方式。参见 [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5562
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5563
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5564
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作要做。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板在处理游戏场景大小时的方式。游戏场景的大小将根据*GameScene.sks*场景编辑器文件中的设置来决定，而这个文件已经包含在我们的项目中。由于我们在本项目中不会使用场景编辑器，所以我们需要添加代码来确保我们的场景尺寸正确。
- en: '![](Image00287.jpg)'
  id: totrans-5565
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5566
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5567
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5568
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE235]'
  id: totrans-5569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5570
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在此处添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5571
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5573
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《学校滑板手》游戏并学习了SpriteKit。你学习了如何在Xcode中创建游戏项目并将资源（如图像）导入项目中。你还学习了通过标准文件命名实践来支持各种设备屏幕分辨率，并了解如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5574
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5575
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  id: totrans-5576
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：通过点击项目导航器中的项目条目来访问项目设置。*'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5577
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-10](text00026.html#ch14fig10)中，你可以看到一个项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5578
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5579
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中“Portrait”选项，保留两个“Landscape”方向选项选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5580
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到项目和目标列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。列表将出现，并且图标将变为蓝色，表示该列表区域现在已经显示。确保选择了**SchoolhouseSkateboarder**目标。现在找到**Portrait**复选框并取消选中。保持Landscape方向选项选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5581
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，您将看到它以横屏模式启动。我们离目标更近了，但背景图像还没有填满屏幕。稍后我们将看到如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5582
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经在横屏模式下运行，您需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择 **硬件** ▸ **右旋**，如[图 14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5583
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5584
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5586
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，您需要处理的不同屏幕大小也就越多，这意味着您需要额外的工作来确保您创建的艺术资源能够在每个设备上正确显示。游戏在这方面通常比像我们的生日追踪器这样的
    UIKit 应用程序需要更多的工作，因为如果您只是简单地缩放游戏艺术，图像会显得被拉伸。为避免这种问题，您需要为每个想要支持的设备使用不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-5587
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5588
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个系统来命名图像文件，帮助您区分不同设备的图像。例如，假设您想在游戏中添加一个滑板者的图像，并且您有一个 100 像素宽、100 像素高（100×100）的滑板者图像文件。您应该将该图像命名为*
    skater.png*。您还需要创建一个命名为 *[skater@2x.png](mailto:skater@2x.png)* 的图像，大小为 200×200
    像素，另一个命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，大小为 300×300 像素。这三个文件应该是同一图像的三种不同大小。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件将自动被使用。在代码中，您只需引用图像文件名
    skater，只要您正确命名了项目中的图像，Xcode 会自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5589
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5590
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5591
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被视为 1x 图像。您只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini，它们没有视网膜显示屏）包含 1x 大小的图像。因此，我们所有的图像文件都会有* @2x *或* @3x
    *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5592
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图片组合在一起。如果你同时将图片拖入Xcode资源目录，Xcode会自动识别它们是同一张图片的不同尺寸，并根据命名方式将它们分组在一起。请参见[图
    14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5593
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5594
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图片在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5595
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还有最后一项准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片没有填满整个屏幕，正如在[图
    14-13](text00026.html#ch14fig13)中所示。这是因为游戏模板在处理游戏场景大小时的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在本项目中不会使用场景编辑器，因此我们需要添加代码以确保场景的大小正确设置。
- en: '![](Image00287.jpg)'
  id: totrans-5596
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5597
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5598
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5599
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE236]'
  id: totrans-5600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5601
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置新场景的大小，以便它填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5602
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图片应该已经填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5604
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了关于SpriteKit的内容。你学习了如何在Xcode中创建游戏项目并将资源（如图片）导入项目中。你还了解了通过标准的文件命名方法支持不同设备的屏幕分辨率，并学会了如何选择游戏中需要的图片类型。最后，你创建并展示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5605
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个SpriteKit游戏项目，并准备好了所需的资源，解决了屏幕方向和分辨率的问题，接下来是编写一些动作代码。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5606
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  id: totrans-5607
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 14-10](text00026.html#ch14fig10)中，你可以看到项目和目标的列表。
- en: '![](Image00283.jpg)'
  id: totrans-5608
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5609
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-10：取消选中“Portrait”选项，保留两个“Landscape”方向选项选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5610
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在屏幕上看到项目和目标列表，点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。列表会出现，图标会变蓝，以表示该区域现在正在显示。确保选中了**SchoolhouseSkateboarder**目标。现在找到**纵向**复选框并取消选中。保持横屏选项已勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5611
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们离目标更近了，但背景图像还没有填满屏幕。稍后我们会看看如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5612
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **右旋**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5613
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5614
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5615
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5616
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理更多的屏幕尺寸，这意味着你需要额外的工作来确保你创建的艺术资源能够在每个设备上正确显示。与像我们的《生日追踪器》这样的基于UIKit的应用程序相比，游戏在这方面需要更多的努力，因为如果你仅仅对艺术作品进行放大或缩小，它们会看起来被拉伸。为了避免这个问题，你必须为每个你想支持的设备准备不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-5617
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5618
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一套命名图像文件的系统，帮助你区分哪些图像是针对哪些设备的。例如，假设你想向游戏中添加一张滑板选手的图片，且你有一张宽100像素、高100像素（100×100）的滑板选手图片文件。你会将这个图像命名为*skater.png*。你还需要创建一个名为*[skater@2x.png](mailto:skater@2x.png)*的图像，尺寸为200×200像素，另一个名为*[skater@3x.png](mailto:skater@3x.png)*的图像，尺寸为300×300像素。这三个文件应该是同一张图像的三种不同尺寸。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件将会自动被使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件将会自动被使用。在你的代码中，你可以只引用文件名skater，Xcode会根据你在项目中正确命名的图像，自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5619
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Schoolhouse Skateboarder，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-5620
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5621
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被认为是1x图像。你只需要为旧设备（如iPhone
    3GS或第一代iPad mini）包含1x大小的图像，这些设备没有视网膜显示屏。因此，我们所有的图像文件都会带有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名为* [background@2x.png](mailto:background@2x.png)*和* [background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两个图像分组在一起。如果你同时将不同大小的图像拖放到Xcode资源目录中，Xcode会根据它们的命名自动识别它们是同一图像的不同尺寸，并将它们分组在一起。见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5623
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5624
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5625
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有一件事需要准备好。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板在处理游戏场景的尺寸时的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置进行设置。我们在这个项目中不会使用场景编辑器，因此需要添加代码来确保我们的场景尺寸正确。
- en: '![](Image00287.jpg)'
  id: totrans-5626
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5627
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5628
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，并找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5629
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE237]'
  id: totrans-5630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5631
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5632
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在，背景图像应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5634
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作Schoolhouse Skateboarder游戏，并学习了SpriteKit。你学会了如何在Xcode中创建游戏项目，并将资源（例如图像）导入到项目中。你还了解了如何通过标准文件命名方式支持不同设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5635
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作程序。在[第15章](text00027.html#ch15)中，我们将添加我们的主角和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00283.jpg)'
  id: totrans-5636
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00283.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5637
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消勾选Portrait选项，同时保留两个横屏方向选项勾选。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5638
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在屏幕上看到项目和目标列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此列表将显示出来，图标会变蓝，表示列表区域已显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**Portrait**复选框并取消勾选。保留横屏方向选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5639
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏方向启动。我们已经接近了，但背景图像还没有填满整个屏幕。稍后我们将看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5640
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏以横屏方向运行，你需要确保你的模拟器也处于横屏方向。要旋转模拟器，选择模拟器菜单中的**Hardware** ▸ **Rotate Right**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5641
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5642
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5643
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5644
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入编码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，你需要处理的不同屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的艺术资源能在每个设备上正确显示。与基于UIKit的应用程序（如我们的生日追踪器）相比，游戏在这方面通常需要更多的工作，因为如果只是简单地放大或缩小，游戏艺术作品会显得拉伸变形。为了避免这个问题，你需要为每个你想要支持的设备准备一套不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-5645
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5646
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图像文件的系统，帮助你区分不同设备的图像。例如，假设你想为你的游戏添加一个滑板选手的图像，你有一张 100 像素宽和 100 像素高的滑板选手图像（100×100）。你可以将这张图像命名为
    *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)* 的图像，大小为 200×200
    像素，以及一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，大小为 300×300 像素。这三张图像应该是同一图像的三种不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件将自动被使用。在你的代码中，你只需引用文件名
    skater，只要你在项目中正确命名了这些图像，Xcode 将显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5647
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持 iPhone 4 及以后的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640，1136×640，1334×750，和
    1920×1080。
- en: '**NOTE**'
  id: totrans-5648
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5649
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像文件都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被视为 1x 图像。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 尺寸的图像，因为它们没有 Retina 显示屏。因此，我们所有的图像文件都会有 *@2x*
    或 *@3x* 后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5650
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件分别命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资产目录，你会注意到 Xcode 将这两张图像归类在一起。如果你同时将尺寸不同的图像拖入 Xcode 资产目录，Xcode
    会根据图像的命名自动识别它们是同一图像的不同尺寸并将其归类在一起。参见[图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5651
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5652
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图像在资产目录中被归类在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5653
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完背景图像后，我们还有最后一项准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为游戏模板在处理游戏场景的大小时的方式所致。游戏场景的大小将基于我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置来确定。由于我们在这个项目中不会使用场景编辑器，因此我们需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5654
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5655
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5656
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件并找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5657
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE238]'
  id: totrans-5658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5659
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，以便它填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5660
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图片现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5662
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作**Schoolhouse Skateboarder**游戏，并了解了SpriteKit。你学会了如何在Xcode中创建游戏项目并将资源（如图像）导入项目。你还了解了如何通过标准文件命名规则来支持不同设备的屏幕分辨率，并学会了如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5663
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将加入我们的主角和她滑行的地面，让一切开始移动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5664
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  id: totrans-5665
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：取消选中Portrait选项，保留两个横屏方向选项被选中。*'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5666
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在屏幕上看到项目和目标的列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。这个列表将会出现，并且图标会变蓝，表示列表区域现在已显示。确保选择了**SchoolhouseSkateboarder**目标。然后找到**Portrait**复选框并取消选中它。保留横屏方向的选项勾选。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5667
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行游戏，你会看到它以横屏模式启动。我们已经接近完成，但背景图片还没有完全填满屏幕。稍后我们会看看如何修复这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5668
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**Hardware** ▸ **Rotate Right**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5669
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5670
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5672
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你就需要处理更多的屏幕大小，这意味着你需要做额外的工作来确保你创建的艺术资源在每个设备上都能正确显示。与像我们生日追踪器那样基于UIKit的应用程序相比，游戏通常需要在这方面付出更多的努力，因为如果你只是简单地放大或缩小，游戏的艺术作品会显得被拉伸。为避免这个问题，你需要为每个支持的设备使用一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-5673
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5674
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图像文件的系统，可以帮助你区分不同设备所使用的图像。例如，假设你想在游戏中加入一张滑板运动员的图片，并且你有一张宽 100 像素，高
    100 像素的滑板运动员图像（100×100）。你会将这张图片命名为 *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图片，尺寸为 200×200 像素，另外还需要一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为
    300×300 像素。这三张文件应为相同的图片，不同的尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone
    6 Plus 上运行，带有 *@3x* 后缀的文件将自动被使用。在你的代码中，你只需引用文件名 skater，Xcode 会根据你项目中正确命名的图片来显示合适的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5675
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5676
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5677
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被视为 1x 图像。你只需要为具有非
    Retina 显示屏的旧设备（例如 iPhone 3GS 或第一代 iPad mini）包含 1x 尺寸的图像。因此，我们所有的图像文件都会有* @2x *或*
    @3x* 后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5678
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件命名为*[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资产目录，你会注意到 Xcode 将这两张图片归为一组。如果你同时将不同尺寸的图像拖入 Xcode 资产目录，Xcode
    会根据文件命名自动识别这些图像是同一张图片的不同尺寸，并将它们分组在一起。见[图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5679
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5680
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资产目录中被归类在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5681
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从背景图片部分继续之前，还有最后一项准备工作需要处理。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在这个项目中不会使用场景编辑器，所以我们需要添加代码，确保场景的大小设置正确。
- en: '![](Image00287.jpg)'
  id: totrans-5682
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5683
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5684
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5685
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE239]'
  id: totrans-5686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5687
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，以便它能填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5688
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图片应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5690
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《学校滑板》游戏，并学习了 SpriteKit。你学会了如何在 Xcode 中创建一个游戏项目并将资源（如图像）导入项目中。你还了解了通过标准文件命名实践来支持不同设备屏幕分辨率的方法，并学习了如何选择在游戏中需要使用的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5691
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5692
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  id: totrans-5693
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在屏幕上看到“项目和目标”列表，请点击窗口左上角的方形图标，如[图14-10](text00026.html#ch14fig10)所示。此列表将会出现，并且图标会变为蓝色，表示列表区域现在正在显示。确保选择了**SchoolhouseSkateboarder**目标。现在找到**Portrait**复选框并取消选中它。保持横屏方向选项被选中。
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5694
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到它以横屏模式启动。我们离目标更近了，但背景图片还没有填满整个屏幕。稍后我们将看看如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5695
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在已经以横屏模式运行，你需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **旋转右侧**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5696
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5697
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5698
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5699
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你需要处理的不同屏幕尺寸就越多，这意味着你需要做额外的工作来确保你创建的艺术资源能在每个设备上正确显示。与像《生日追踪器》这样的
    UIKit 应用程序相比，游戏通常在这方面需要更多的努力，因为如果你只是简单地缩放，它们的艺术作品看起来会被拉伸。为避免这个问题，你必须为每个你想要支持的设备准备不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-5700
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5701
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个命名图片文件的系统，可以帮助你辨别哪些图片适用于哪些设备。例如，假设你想要为你的游戏添加一张滑板手的图片，并且你有一张 100 像素宽和
    100 像素高的滑板手图片（100×100）。你应该将这张图片命名为 *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图片，尺寸为 200×200 像素，以及一张名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为 300×300
    像素。这三张图片应该是同一张图片的不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6 Plus
    上运行，则会自动使用带有 *@3x* 后缀的文件。在你的代码中，你只需要引用文件名 skater，只要你在项目中正确命名了图片，Xcode 就会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5702
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5703
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5704
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，例如* @2x *或* @3x*。没有后缀的图片，例如* skater.png*，被视为 1x 图片。你只需要为旧设备提供
    1x 尺寸的图片，这些设备没有 Retina 显示屏，比如 iPhone 3GS 或第一代 iPad mini。因此，我们所有的图片文件都将具有* @2x
    *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5705
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资产目录，你会注意到 Xcode 将这两张图片分组在一起。如果你同时将不同尺寸的图片拖入 Xcode 资产目录，Xcode
    会自动根据它们的命名规则识别出它们是同一张图片的不同尺寸，并将它们分组在一起。请参见 [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5706
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5707
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图片在资产目录中分组显示。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5708
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还有最后一部分准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片并没有填满整个屏幕，如
    [图 14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板处理游戏场景尺寸的方式。游戏场景的大小将基于我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码来确保我们的场景尺寸正确。
- en: '![](Image00287.jpg)'
  id: totrans-5709
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5710
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填充整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5711
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航中的 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码行来设置场景的尺寸：
- en: '*GameViewController.swift*'
  id: totrans-5712
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE240]'
  id: totrans-5713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5714
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填充整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置了新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5715
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5716
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5717
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您开始制作《学校滑板手》游戏，并学习了SpriteKit。您学会了如何在Xcode中创建游戏项目并将资源（如图像）导入到项目中。您还了解了通过标准文件命名实践支持各种设备屏幕分辨率，并学会了如何选择游戏中需要的图像类型。最后，您创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5718
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作程序了。在[第15章](text00027.html#ch15)中，我们将加入我们的主角和她滑行的地面，使所有东西动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5719
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  id: totrans-5720
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，您将看到它以横屏模式启动。我们越来越接近目标了，但背景图像还没有填充整个屏幕。稍后我们将看到如何解决这个问题。
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5721
  prefs: []
  type: TYPE_NORMAL
  zh: 由于游戏现在以横屏模式运行，您需要确保模拟器也处于横屏模式。要旋转它，请从模拟器的菜单中选择**硬件** ▸ **右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5722
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5723
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5725
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究代码之前，我们应该决定支持哪些设备和屏幕分辨率。支持的设备越多，您就需要处理更多不同的屏幕尺寸，这意味着您需要额外的工作来确保您创建的艺术资源能够在每个设备上正确显示。与基于UIKit的应用程序（例如我们的生日追踪器）相比，游戏在这一方面通常需要更多的工作，因为如果只是简单地缩放，游戏艺术资源会显得拉伸。为避免这个问题，您必须为每个要支持的设备准备不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-5726
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5727
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个命名系统来帮助你识别哪些图像适用于哪些设备。例如，假设你想在游戏中添加一张滑板运动员的图像，你有一张 100 像素宽、100 像素高（100×100）的图像文件，你会将它命名为
    *skater.png*。你还需要创建一个命名为 *[skater@2x.png](mailto:skater@2x.png)* 的图像，它的尺寸是 200×200
    像素，另一个命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像，其尺寸是 300×300 像素。这三张文件应该是同一张图像的三种不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件将会被自动使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件将会自动使用。在你的代码中，你只需要引用文件名
    skater，只要你在项目中正确命名了图像，Xcode 就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5728
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持 iPhone 4 及以后的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5729
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5730
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有后缀，如* @2x *或* @3x*。没有后缀的图像，如* skater.png*，被认为是 1x 图像。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 大小的图像，这些设备没有 Retina 显示屏。因此，我们所有的图像文件都会有* @2x *或*
    @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5731
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资产目录，你会注意到 Xcode 将这两张图像分组在一起。如果你同时将图像拖入 Xcode 资产目录，Xcode 会自动识别它们是同一张图像的不同尺寸，因为它们的命名方式，并将它们分组在一起。见[图
    14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5732
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5733
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：多个尺寸的图像在资产目录中分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5734
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从背景图像上移步之前，还有最后一点准备工作要做。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为 Game 模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的
    *GameScene.sks* 场景编辑器文件的设置来确定。在这个项目中，我们不会使用场景编辑器，因此我们需要添加代码，以确保我们的场景大小设置正确。
- en: '![](Image00287.jpg)'
  id: totrans-5735
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5736
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5737
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5738
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE241]'
  id: totrans-5739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5740
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并将其显示出来。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了显示视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5741
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5742
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5743
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《Schoolhouse Skateboarder》游戏，并了解了 SpriteKit。你学习了如何在 Xcode 中创建游戏项目并将资产（如图像）导入项目。你还学习了如何通过标准文件命名方法来支持各种设备屏幕分辨率，并了解了如何选择游戏所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5744
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5745
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  id: totrans-5746
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已在横屏模式下运行，你需要确保你的模拟器也处于横屏模式。要旋转它，请从模拟器菜单中选择 **硬件** ▸ **向右旋转**，如[图14-11](text00026.html#ch14fig11)所示。
- en: '![](Image00284.jpg)'
  id: totrans-5747
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5748
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器的方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5750
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，你需要处理的屏幕尺寸就越多，这意味着你需要额外的工作来确保你创建的艺术资产能够在每个设备上正确显示。游戏通常比基于
    UIKit 的应用（如我们的生日追踪器）需要更多的工作，因为如果只是简单地放大或缩小，游戏的艺术作品会看起来被拉伸。为避免这个问题，你需要为每个想要支持的设备使用不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-5751
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5752
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图片文件的系统，帮助你识别图片对应的设备。例如，假设你想在游戏中加入一个滑冰者的图片，你有一张宽 100 像素、高 100 像素（100×100）的滑冰者图片文件，你应该命名为
    *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)* 的图片，尺寸为 200×200
    像素，以及一张命名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为 300×300 像素。这三张文件应为同一张图片的三种不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需引用文件名
    skater ，只要你在项目中正确命名了图片，Xcode 会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5753
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》，我们将支持从 iPhone 4 起的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5754
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5755
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有后缀，比如* @2x *或* @3x*。没有后缀的图片，例如* skater.png*，被视为 1x 图片。你只需要为较旧的设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 尺寸的图片，这些设备没有视网膜显示屏。因此，我们所有的图片文件都会带有 *@2x* 或 *@3x*
    后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5756
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 已经将这两张图片归为一组。如果你同时将图片拖入 Xcode 资源目录，Xcode 会自动识别它们是同一张图片的不同尺寸，并将它们分组在一起，这得益于它们的命名规则。请参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5757
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5758
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多个尺寸的图片在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5759
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还需要做最后一些准备工作。你可能已经注意到，当你在 iPhone 7 模拟器中运行游戏时，背景图片并没有填满整个屏幕，如 [图
    14-13](text00026.html#ch14fig13) 所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将基于我们项目中包含的 *GameScene.sks*
    场景编辑器文件中的设置。我们在这个项目中不使用场景编辑器，所以我们需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5760
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5761
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5762
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击 *GameViewController.swift* 文件，并找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5763
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE242]'
  id: totrans-5764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5765
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了GameScene类的一个实例并显示它。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5766
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。此时背景图像应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5767
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5768
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《滑板学校》游戏，并了解了SpriteKit。你学会了如何在Xcode中创建游戏项目并导入资源，如图像等。你还了解了如何通过标准的文件命名规范支持各种设备的屏幕分辨率，以及如何选择在游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5769
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作代码。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，让一切开始运动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00284.jpg)'
  id: totrans-5770
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00284.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5771
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5772
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像尺寸**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5773
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入编写代码之前，我们应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理不同屏幕尺寸的问题，这意味着你需要额外工作来确保你创建的艺术资源能够在每个设备上正确显示。与我们《生日追踪器》这类基于UIKit的应用相比，游戏通常需要在这一方面付出更多的努力，因为如果你仅仅通过缩放来调整图像，游戏中的艺术资源看起来会被拉伸。为了避免这个问题，你需要为每个你想要支持的设备准备一组不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-5774
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5775
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个图像文件命名系统，帮助你辨别哪些图像适用于哪些设备。例如，假设你想为游戏添加一个滑板手的图像，并且你有一个宽100像素，高100像素（100×100）的滑板手图像文件。你应该将该图像命名为*skater.png*。你还需要创建一个名为*[skater@2x.png](mailto:skater@2x.png)*的图像，尺寸为200×200像素，再创建一个名为*[skater@3x.png](mailto:skater@3x.png)*的图像，尺寸为300×300像素。这三种文件应该是同一图像的三种不同尺寸。如果游戏在iPhone
    4上运行，带有*@2x*后缀的文件将自动被使用。如果游戏在iPhone 6 Plus上运行，带有*@3x*后缀的文件将自动被使用。在代码中，你只需引用文件名skater，只要你在项目中正确命名了这些图像，Xcode将会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5776
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Schoolhouse Skateboarder，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-5777
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5778
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被视为1x图像。你只需要为旧设备（如iPhone
    3GS或第一代iPad mini）包含1x尺寸的图像，这些设备没有视网膜显示屏。因此，我们所有的图像文件都会有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5779
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资产目录，你会注意到Xcode将这两张图像分组在一起。如果你同时将不同尺寸的图片拖入Xcode的资产目录，Xcode会自动识别这些是同一张图片的不同尺寸，因为它们的命名方式，并将它们分组在一起。请参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5780
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5781
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图像在资产目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5782
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理背景图像之前，还有最后一项准备工作需要完成。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图像没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将根据项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在此项目中不会使用场景编辑器，因此我们需要添加代码，以确保场景的大小正确设置。
- en: '![](Image00287.jpg)'
  id: totrans-5783
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5784
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像未填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5785
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5786
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE243]'
  id: totrans-5787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5788
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了当前显示视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5789
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5790
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5791
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作Schoolhouse Skateboarder游戏，并学习了SpriteKit。你了解了如何在Xcode中创建游戏项目并将资产（如图像）导入到项目中。你还学会了通过标准文件命名规则支持不同设备的屏幕分辨率，并了解了如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5792
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个SpriteKit游戏项目，配置了所需的资源，并解决了屏幕方向和分辨率的问题，接下来就是编程实现一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，使一切开始动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5793
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  id: totrans-5794
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：旋转模拟器方向以匹配游戏*'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5795
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**不同屏幕分辨率的图片尺寸设置**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5796
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，应该先决定我们将支持哪些设备和屏幕分辨率。支持的设备越多，你就需要处理更多不同的屏幕尺寸，这意味着你需要额外的工作，确保你创建的图形资源能够在每个设备上正确显示。相比UIKit为基础的应用（如我们的生日追踪器），游戏在这方面通常需要更多的努力，因为如果你仅仅放大或缩小，游戏图形会看起来被拉伸。为了避免这个问题，你必须为每个想要支持的设备使用不同的图像集。
- en: '![](Image00285.jpg)'
  id: totrans-5797
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5798
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一套命名图片文件的规则，帮助你区分哪些图片是给哪个设备使用的。例如，假设你想为你的游戏添加一张滑板选手的图片，你有一张尺寸为100像素宽和100像素高（100×100）的滑板选手图片。你会把这张图片命名为*skater.png*。你还需要创建一张名为*[skater@2x.png](mailto:skater@2x.png)*的图片，尺寸为200×200像素，另外还需要创建一张名为*[skater@3x.png](mailto:skater@3x.png)*的图片，尺寸为300×300像素。这三张文件应该是同一张图片的三种不同尺寸。如果游戏运行在iPhone
    4上，带有*@2x*后缀的文件会自动被使用。如果游戏运行在iPhone 6 Plus上，则会自动使用*@3x*文件。在代码中，你只需要引用文件名skater，Xcode会根据你在项目中正确命名的图片，自动显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5799
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《滑板学校》，我们将从iPhone 4开始支持所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-5800
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5801
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，比如* @2x *或* @3x*。没有后缀的图片，比如* skater.png*，被视为1x图片。你只需要为那些非视网膜显示屏的旧设备（例如iPhone
    3GS或第一代iPad mini）提供1x尺寸的图片。因此，我们所有的图片文件都会有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5802
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图像归为一组。如果你同时将图像拖入 Xcode 的资源目录，Xcode 会根据图像的命名自动识别它们是同一图像的不同尺寸，并将它们归类在一起。见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5803
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5804
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资源目录中被归为一组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5805
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作需要处理。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如
    [图 14-13](text00026.html#ch14fig13) 所示。这是因为 Game 模板处理游戏场景大小的方式。游戏场景的大小将根据我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置来决定。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码来确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5806
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5807
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5808
  prefs: []
  type: TYPE_NORMAL
  zh: 单击项目导航器中的 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5809
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE244]'
  id: totrans-5810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5811
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在此处添加的代码决定了显示视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5812
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。此时背景图像应该会填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5813
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5814
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《滑板学校》游戏，并学习了 SpriteKit。你了解了如何在 Xcode 中创建一个游戏项目并将资源（如图像）导入项目。你还学习了如何通过标准的文件命名规则支持各种设备屏幕分辨率，以及如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5815
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置好了 SpriteKit 游戏项目，准备好了所需的资源，并解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在 [第 15 章](text00027.html#ch15)
    中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5816
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  id: totrans-5817
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**为不同屏幕分辨率调整图像大小**'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5818
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，应该决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理更多的屏幕尺寸，这意味着你需要额外的工作，确保你创建的艺术资源能够在每个设备上正确显示。与我们基于
    UIKit 的应用程序（如生日追踪器）相比，游戏在这方面通常需要更多的努力，因为如果你只是简单地缩放图像，它们会显得被拉伸。为了解决这个问题，你必须为每个想要支持的设备准备一套不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-5819
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5820
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一个命名规则，帮助你识别哪些图像适用于哪些设备。例如，假设你想为游戏添加一张滑板图片，且这张图片的文件是 100 像素宽，100 像素高（100×100）。你会将这张图片命名为
    *skater.png*。你还需要创建一张名为 *[skater@2x.png](mailto:skater@2x.png)* 的图片，尺寸为 200×200
    像素，再创建一张名为 *[skater@3x.png](mailto:skater@3x.png)* 的图片，尺寸为 300×300 像素。这三张文件应当是同一张图片的三种不同尺寸。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件将自动被使用。在你的代码中，你只需要引用该文件名为
    skater，只要你在项目中正确命名了图片，Xcode 会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5821
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《滑板学校》，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5822
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5823
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有一个后缀，比如* @2x *或* @3x*。没有后缀的图片，例如* skater.png*，被视为 1x 图像。你只需要为旧设备（如
    iPhone 3GS 或第一代 iPad mini）包含 1x 尺寸的图片，因为这些设备没有视网膜显示屏。因此，我们所有的图片文件都会有* @2x *或*
    @3x* 后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5824
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件名为*[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图片归为一组。如果你同时将图片拖入 Xcode 资源目录，Xcode 会自动识别它们是同一张图片的不同尺寸，并将它们分组，因为它们的命名方式。参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5825
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5826
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：多尺寸的图像在资源目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5827
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理背景图片之前，还有一项准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图片并没有填满整个屏幕，如[图
    14-13](text00026.html#ch14fig13)所示。这是因为游戏模板在处理游戏场景尺寸时的方式导致的。游戏场景的尺寸将根据我们项目中包含的*GameScene.sks*场景编辑文件中的设置来确定。由于我们在本项目中不会使用场景编辑器，因此需要添加代码，以确保我们的场景能够正确地设置尺寸。
- en: '![](Image00287.jpg)'
  id: totrans-5828
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5829
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5830
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5831
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE245]'
  id: totrans-5832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5833
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5834
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图片应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5835
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5836
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了 SpriteKit。你学会了如何在 Xcode 中创建一个游戏项目，并将资源（如图片）导入到项目中。你还学习了如何通过标准的文件命名方法来支持不同设备的屏幕分辨率，并了解了在游戏中选择需要哪些图片类型。最后，你创建并显示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5837
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，让一切开始动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5838
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  id: totrans-5839
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，我们应该先决定支持哪些设备和屏幕分辨率。你支持的设备越多，就需要处理更多不同的屏幕尺寸，这意味着你需要额外工作，以确保你创建的艺术资源能够在每个设备上正确显示。相比于基于
    UIKit 的应用程序（例如我们的生日追踪器应用），游戏在这方面需要更多的工作，因为如果你仅仅通过缩放来调整图像，游戏中的艺术作品会看起来被拉伸。为了避免这个问题，你需要为每个想要支持的设备准备一套不同的图像。
- en: '![](Image00285.jpg)'
  id: totrans-5840
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5841
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套图像文件命名规则，帮助你区分不同设备的图像。例如，假设你想为游戏添加一张滑板少年（skater）的图像，并且你有一张 100 像素宽、100
    像素高（100×100）的滑板少年图像文件。你会将该图像命名为 *skater.png* 。你还需要创建一个名为 *[skater@2x.png](mailto:skater@2x.png)*
    的图像文件，尺寸为 200×200 像素，另一个名为 *[skater@3x.png](mailto:skater@3x.png)* 的图像文件，尺寸为 300×300
    像素。这三张文件应该是同一图像的三种不同尺寸。如果游戏在 iPhone 4 上运行，带有 *@2x* 后缀的文件将自动被使用。如果游戏在 iPhone 6
    Plus 上运行，带有 *@3x* 后缀的文件将自动被使用。在你的代码中，你只需引用文件名 skater ，只要你在项目中正确命名了这些图像，Xcode 就会显示正确的图像。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5842
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder 游戏，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5843
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5844
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，例如* skater.png*，被认为是1x图像。你只需要为老旧设备（如
    iPhone 3GS 或第一代 iPad mini）提供 1x 大小的图像，这些设备没有视网膜显示屏。因此，我们所有的图像文件都会有* @2x *或* @3x
    *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5845
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件分别命名为 *[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*
    。如果你查看 *Assets.xcassets* 资源目录，你会注意到 Xcode 将这两张图像分组在一起。如果你同时将这些图像拖入 Xcode 资源目录，Xcode
    会根据它们的命名自动识别它们是相同图像的不同大小，并将它们分组在一起。请参见 [图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5846
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5847
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种大小的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5848
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，如 [图14-13](text00026.html#ch14fig13)
    所示。这是因为游戏模板在处理游戏场景的大小时的方式。游戏场景的大小将基于我们项目中包含的 *GameScene.sks* 场景编辑器文件中的设置来设定。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5849
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5850
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5851
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5852
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE246]'
  id: totrans-5853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5854
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填充整个屏幕。我们在这里添加的代码确定了要显示的视图的大小（宽度和高度），并设置了新场景的大小，以便它填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5855
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图片现在应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5856
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5857
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《学校滑板手》游戏并学习了SpriteKit。你学会了如何在Xcode中创建一个游戏项目并导入资源，例如图片。你还了解了如何通过标准的文件命名惯例支持各种设备的屏幕分辨率，以及如何选择在游戏中需要使用的图片类型。最后，你创建并展示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5858
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了需要的资源，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的主角和她滑行的地面，让一切开始移动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00285.jpg)'
  id: totrans-5859
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00285.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5860
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode有一个命名图像文件的系统，帮助你辨别哪些图像适用于哪些设备。例如，假设你想在游戏中添加一个滑板车手的图片，并且你有一个100×100像素的滑板车手图像文件。你应该将这个图像命名为*skater.png*。你还需要创建一个名为*[skater@2x.png](mailto:skater@2x.png)*的图像，尺寸为200×200像素，以及一个名为*[skater@3x.png](mailto:skater@3x.png)*的图像，尺寸为300×300像素。这三张图像应该是相同图像的不同尺寸。如果游戏在iPhone
    4上运行，系统会自动使用带有@2x后缀的文件。如果游戏在iPhone 6 Plus上运行，系统会自动使用带有@3x后缀的文件。在代码中，你只需引用图像文件名skater，Xcode会根据你在项目中正确命名的图像显示对应的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5861
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《学校滑板手》，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5862
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5863
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像文件都有一个后缀，例如* @2x *或* @3x*。没有后缀的图像，如*skater.png*，被视为1x图像。你只需要为旧设备（如iPhone
    3GS或第一代iPad mini）包含1x大小的图像，这些设备没有视网膜显示屏。因此，我们所有的图像文件都会带有* @2x *或* @3x *后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5864
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名是*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图片放在了一起。如果你同时将不同尺寸的图片拖入Xcode资源目录，Xcode会根据图片命名规则自动识别它们是同一张图片的不同尺寸，并将它们归为一组。参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5865
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5866
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图像在资源目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5867
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作要完成。你可能注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板处理游戏场景大小的方式。游戏场景的大小将基于项目中包含的*GameScene.sks*场景编辑器文件中的设置。由于在本项目中我们不会使用场景编辑器，因此需要添加代码以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5868
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5869
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像未填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5870
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5871
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE247]'
  id: totrans-5872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5873
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了GameScene类的实例并显示它。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，以便它填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5874
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该已经填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5875
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5876
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作了Schoolhouse Skateboarder游戏，并了解了SpriteKit。你学习了如何在Xcode中创建一个游戏项目，并将图像等资源导入到项目中。你还了解了如何通过标准的文件命名实践支持各种设备屏幕分辨率，以及如何选择游戏中需要使用的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5877
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，让一切开始移动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5878
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  id: totrans-5879
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 有一套命名图像文件的系统，帮助你区分不同设备使用的图像。例如，假设你想为你的游戏添加一张滑冰者的图片，你有一张宽 100 像素、高 100
    像素的滑冰者图片（100×100）。你可以将这张图片命名为 *skater.png*。你还需要创建一张命名为 *[skater@2x.png](mailto:skater@2x.png)*，尺寸为
    200×200 像素的图片，以及一张命名为 *[skater@3x.png](mailto:skater@3x.png)*，尺寸为 300×300 像素的图片。这三张文件应该是同一张图片的不同大小版本。如果游戏在
    iPhone 4 上运行，带有 *@2x* 后缀的文件会自动被使用。如果游戏在 iPhone 6 Plus 上运行，带有 *@3x* 后缀的文件会自动被使用。在你的代码中，你只需要引用文件名
    skater ，只要你在项目中正确命名了图像，Xcode 会显示正确的图片。
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5880
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Schoolhouse Skateboarder，我们将支持从 iPhone 4 开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750
    和 1920×1080。
- en: '**NOTE**'
  id: totrans-5881
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5882
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都有一个后缀，比如* @2x *或* @3x*。没有后缀的图像，比如* skater.png*，被视为 1x 图像。你只需要为老旧设备提供
    1x 尺寸的图像，这些设备没有视网膜显示屏，比如 iPhone 3GS 或第一代 iPad mini。因此，我们所有的图像文件都将有 *@2x* 或 *@3x*
    后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5883
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件命名为*[background@2x.png](mailto:background@2x.png)* 和 *[background@3x.png](mailto:background@3x.png)*。如果你查看
    *Assets.xcassets* 资源目录，你会发现 Xcode 将这两张图片分组在一起。如果你同时将图像拖入 Xcode 资源目录，Xcode 会根据它们的命名自动识别出它们是同一图像的不同大小，并将它们分组在一起。参见
    [图 14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5884
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5885
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-12：具有多种尺寸的图像在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5886
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作需要完成。你可能已经注意到，当你使用 iPhone 7 模拟器运行游戏时，背景图像并没有填满整个屏幕，正如在
    [图 14-13](text00026.html#ch14fig13) 中所示。这是因为 Game 模板处理游戏场景大小的方式。游戏场景的大小将基于我们项目中包含的
    *GameScene.sks* 场景编辑器文件中的设置。我们在这个项目中不使用场景编辑器，因此需要添加代码来确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5887
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5888
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5889
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5890
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE248]'
  id: totrans-5891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5892
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在此处添加的代码决定了显示视图的大小（宽度和高度），并设置新场景的大小，以便它填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5893
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5894
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5895
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏并学习了SpriteKit。你了解了如何在Xcode中创建一个游戏项目并导入资源，如图像。你还了解了如何通过标准的文件命名惯例支持各种设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5896
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将加入我们的英雄角色和她滑行的地面，进行动画处理，并让玩家点击屏幕使她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5897
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  id: totrans-5898
  prefs: []
  type: TYPE_NORMAL
  zh: 对于《Schoolhouse Skateboarder》游戏，我们将支持从iPhone 4开始的所有设备。这意味着我们需要支持以下四种屏幕分辨率：960×640、1136×640、1334×750和1920×1080。
- en: '**NOTE**'
  id: totrans-5899
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5900
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图像都带有后缀，例如* @2x *或* @3x*。没有后缀的图像，例如*skater.png*，被视为1x图像。你只需要为老旧设备（如iPhone
    3GS或第一代iPad mini）提供1x图像，因为它们没有视网膜显示屏。因此，我们所有的图像文件都将带有* @2x *或* @3x*后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5901
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图像分组在一起。如果你同时将多张图像拖入Xcode资源目录，Xcode会根据图像的命名自动识别它们是相同图像的不同尺寸，并将它们分组在一起。请参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5902
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5903
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图像在资源目录中被分组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5904
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一件准备工作。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板在处理游戏场景的大小时的方式。游戏场景的大小将根据包含在我们项目中的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在这个项目中不使用场景编辑器，因此需要添加代码来确保场景的大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5905
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5906
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5907
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，并找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5908
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE249]'
  id: totrans-5909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5910
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了显示的视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5911
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在，背景图像应该会填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5912
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5913
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《学校滑板游戏》并学习了SpriteKit。你学会了如何在Xcode中创建一个游戏项目，并将资源（如图片）导入项目中。你还了解了如何通过标准的文件命名规范支持不同设备的屏幕分辨率，并学会了如何选择游戏中需要的图片类型。最后，你创建并展示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5914
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作代码。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，让所有东西动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5915
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '**NOTE**'
  id: totrans-5916
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  id: totrans-5917
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们使用的所有图片都有后缀，例如* @2x *或* @3x*。没有后缀的图片，如*skater.png*，被视为1x图片。你只需要为那些非视网膜显示屏的旧设备（如iPhone
    3GS或第一代iPad mini）包含1x尺寸的图片。因此，我们所有的图片文件都会有* @2x *或* @3x *的后缀。*'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5918
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图像文件名分别为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资产目录，你会发现Xcode将这两张图像归为一组。如果你同时将不同尺寸的图像拖入Xcode的资产目录，Xcode会根据它们的命名方式自动识别它们是同一图像的不同尺寸，并将它们归为一组。参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5919
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5920
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多个尺寸的图像在资产目录中被归为一组。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5921
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行之前，我们还有最后一项准备工作要处理。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板在处理游戏场景大小时的方式。游戏场景的大小将根据我们项目中包含的*GameScene.sks*场景编辑器文件中的设置来确定。由于我们在本项目中不使用场景编辑器，所以我们需要添加代码以确保场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5922
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5923
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5924
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，并找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5925
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE250]'
  id: totrans-5926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5927
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在此处添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5928
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该会填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5929
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5930
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作Schoolhouse Skateboarder游戏，并学习了SpriteKit。你学会了如何在Xcode中创建游戏项目并导入资源，如图像。你还了解了通过标准文件命名实践支持不同设备的屏幕分辨率，并学会了如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5931
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作程序。在[第15章](text00027.html#ch15)中，我们将加入我们的英雄角色和她滑行的地面，让一切开始移动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5932
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  id: totrans-5933
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的背景图片文件分别命名为*[background@2x.png](mailto:background@2x.png)*和*[background@3x.png](mailto:background@3x.png)*。如果你查看*Assets.xcassets*资源目录，你会注意到Xcode将这两张图片分组在一起。如果你同时将大小不同的图片拖入Xcode资源目录，Xcode会自动识别它们是同一张图片的不同尺寸，并根据命名规则将它们分组在一起。参见[图14-12](text00026.html#ch14fig12)。
- en: '![](Image00286.jpg)'
  id: totrans-5934
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5935
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图片在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5936
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图片之前，我们还有最后一点准备工作。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图片没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将基于我们项目中包含的*GameScene.sks*场景编辑文件中的设置。我们在这个项目中不会使用场景编辑器，因此我们需要添加代码，确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5937
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5938
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图片没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5939
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下代码行来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5940
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE251]'
  id: totrans-5941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5942
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并将其显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在此处添加的代码决定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5943
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在，背景图片应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5944
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5945
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《Schoolhouse Skateboarder》游戏，并了解了SpriteKit。你学习了如何在Xcode中创建游戏项目并导入资源，如图片。你还了解了通过标准的文件命名惯例来支持各种设备的屏幕分辨率，以及如何选择游戏中需要的图片类型。最后，你创建并展示了一个背景图片精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5946
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了一个SpriteKit游戏项目，并准备了所需的资源，解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让所有元素动起来，并让玩家点击屏幕使她跳跃。
- en: '![](Image00288.jpg)![](Image00286.jpg)'
  id: totrans-5947
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00286.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5948
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：具有多种尺寸的图片在资源目录中被分组在一起。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5949
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作需要完成。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将根据包含在我们项目中的*GameScene.sks*场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，所以我们需要添加代码来确保我们的场景大小合适。
- en: '![](Image00287.jpg)'
  id: totrans-5950
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5951
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5952
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目导航器中点击*GameViewController.swift*文件，并找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5953
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE252]'
  id: totrans-5954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5955
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了GameScene类的一个实例并将其显示出来。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5956
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。现在背景图像应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5957
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5958
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《学校滑板侠》游戏并了解了SpriteKit。你学会了如何在Xcode中创建一个游戏项目并将资源（如图像）导入到项目中。你还了解了如何通过标准的文件命名方法支持各种设备的屏幕分辨率，以及如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5959
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了SpriteKit游戏项目，准备好了所需的资源，并解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切开始移动，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5960
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  id: totrans-5961
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：多尺寸的图像在资源目录中分组显示。*'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5962
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理背景图像之前，我们还有最后一项准备工作需要完成。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填满整个屏幕，如[图14-13](text00026.html#ch14fig13)所示。这是因为游戏模板处理游戏场景大小的方式。游戏场景的大小将根据包含在我们项目中的*GameScene.sks*场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，所以我们需要添加代码来确保我们的场景大小合适。
- en: '![](Image00287.jpg)'
  id: totrans-5963
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5964
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5965
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5966
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE253]'
  id: totrans-5967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5968
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填充整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置了新场景的大小，以确保它填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5969
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5970
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5971
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《滑板学校》游戏，并学习了SpriteKit。你学习了如何在Xcode中创建游戏项目并导入资源，比如图像。你还了解了如何通过标准的文件命名实践支持不同设备的屏幕分辨率，并学习了如何选择游戏中需要的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5972
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色和她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5973
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  id: totrans-5974
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理背景图像之前，还有最后一件准备工作要做。你可能已经注意到，当你使用iPhone 7模拟器运行游戏时，背景图像并没有填充整个屏幕，正如[图14-13](text00026.html#ch14fig13)所示。这是因为Game模板处理游戏场景大小的方式。游戏场景的大小将根据包含在我们项目中的*GameScene.sks*场景编辑器文件中的设置来确定。我们在这个项目中不会使用场景编辑器，因此需要添加代码以确保我们的场景大小正确。
- en: '![](Image00287.jpg)'
  id: totrans-5975
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5976
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：背景图像没有填充整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5977
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到viewDidLoad()方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5978
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE254]'
  id: totrans-5979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5980
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad()方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填充整个屏幕。我们在这里添加的代码确定了显示视图的大小（宽度和高度），并设置了新场景的大小，以确保它填充整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5981
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填充整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5983
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 Schoolhouse Skateboarder 游戏并学习了 SpriteKit。你学习了如何在 Xcode 中创建一个游戏项目并导入资源，比如图像。你还学习了如何通过标准的文件命名规则来支持不同设备的屏幕分辨率，以及如何选择游戏中需要使用的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5984
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个带有所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作。在 [第 15 章](text00027.html#ch15)
    中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00287.jpg)'
  id: totrans-5985
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00287.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5986
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5987
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码行以设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5988
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE255]'
  id: totrans-5989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-5990
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，以便它填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-5991
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕了。
- en: '**WHAT YOU LEARNED**'
  id: totrans-5992
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-5993
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作 Schoolhouse Skateboarder 游戏并学习了 SpriteKit。你学习了如何在 Xcode 中创建一个游戏项目并导入资源，比如图像。你还学习了如何通过标准的文件命名规则来支持不同设备的屏幕分辨率，以及如何选择游戏中需要使用的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-5994
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个带有所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，接下来是编写一些动作。在 [第 15 章](text00027.html#ch15)
    中，我们将添加我们的英雄和她滑行的地面，让一切动起来，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-5995
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  id: totrans-5996
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-13：背景图像没有填满整个屏幕。*'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-5997
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的 *GameViewController.swift* 文件，找到 viewDidLoad() 方法。添加以下代码行以设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-5998
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE256]'
  id: totrans-5999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-6000
  prefs: []
  type: TYPE_NORMAL
  zh: viewDidLoad() 方法中的代码创建了一个 GameScene 类的实例并显示它。由于 GameScene 是我们游戏的主场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，以便它填满整个视图。
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-6001
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6002
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-6003
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《学堂滑板女孩》游戏，并学习了SpriteKit。你学习了如何在Xcode中创建游戏项目并导入资源，如图像。你还学习了通过标准的文件命名规则来支持各种设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并展示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-6004
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切开始移动，并让玩家通过点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-6005
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  id: totrans-6006
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目导航器中的*GameViewController.swift*文件，找到`viewDidLoad()`方法。添加以下几行代码来设置场景的大小：
- en: '*GameViewController.swift*'
  id: totrans-6007
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE257]'
  id: totrans-6008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-6009
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()`方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-6010
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6011
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-6012
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《学堂滑板女孩》游戏，并学习了SpriteKit。你学习了如何在Xcode中创建游戏项目并导入资源，如图像。你还学习了通过标准的文件命名规则来支持各种设备的屏幕分辨率，以及如何选择游戏中需要的图像类型。最后，你创建并展示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-6013
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置好了一个包含所需资源的SpriteKit游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作代码了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，让一切开始移动，并让玩家通过点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-6014
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '*GameViewController.swift*'
  id: totrans-6015
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewController.swift*'
- en: '[PRE258]'
  id: totrans-6016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-6017
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()`方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码决定了正在显示的视图的大小（宽度和高度），并设置新场景的大小，使其填满整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-6018
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6019
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-6020
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《学校滑板游戏》，并学习了SpriteKit。你学会了如何在Xcode中创建一个游戏项目，并将资源（如图像）导入项目中。你还了解了通过标准的文件命名规则支持各种设备屏幕分辨率，以及如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-6021
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了SpriteKit游戏项目并准备好了所需的资源，同时解决了屏幕方向和分辨率的问题，接下来就是编程一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色以及她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-6022
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '[PRE259]'
  id: totrans-6023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-6024
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()`方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，以便它填满整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-6025
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6026
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-6027
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《学校滑板游戏》，并学习了SpriteKit。你学会了如何在Xcode中创建一个游戏项目，并将资源（如图像）导入项目中。你还了解了通过标准的文件命名规则支持各种设备屏幕分辨率，以及如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-6028
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了SpriteKit游戏项目并准备好了所需的资源，同时解决了屏幕方向和分辨率的问题，接下来就是编程一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄角色以及她滑行的地面，让一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-6029
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  id: totrans-6030
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad()`方法中的代码创建了一个GameScene类的实例并显示它。由于GameScene是我们游戏的主要场景，我们希望它始终填满整个屏幕。我们在这里添加的代码确定了正在显示的视图的大小（宽度和高度），并设置了新场景的大小，以便它填满整个视图。'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-6031
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6032
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-6033
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始制作《学校滑板游戏》，并学习了SpriteKit。你学会了如何在Xcode中创建一个游戏项目，并将资源（如图像）导入项目中。你还了解了通过标准的文件命名规则支持各种设备屏幕分辨率，以及如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-6034
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-6035
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Run the project again. The background image should fill the entire screen now.
  id: totrans-6036
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。背景图像现在应该填满整个屏幕。
- en: '**WHAT YOU LEARNED**'
  id: totrans-6037
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-6038
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了 SpriteKit。你学习了如何在 Xcode 中创建游戏项目并将资源（如图像）导入项目。你还了解了通过标准文件命名方法支持各种设备的屏幕分辨率，以及如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-6039
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-6040
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: '**WHAT YOU LEARNED**'
  id: totrans-6041
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-6042
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了 SpriteKit。你学习了如何在 Xcode 中创建游戏项目并将资源（如图像）导入项目。你还了解了通过标准文件命名方法支持各种设备的屏幕分辨率，以及如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-6043
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-6044
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  id: totrans-6045
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你开始制作《Schoolhouse Skateboarder》游戏，并学习了 SpriteKit。你学习了如何在 Xcode 中创建游戏项目并将资源（如图像）导入项目。你还了解了通过标准文件命名方法支持各种设备的屏幕分辨率，以及如何选择游戏中所需的图像类型。最后，你创建并显示了一个背景图像精灵。
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-6046
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个包含所需资源的 SpriteKit 游戏项目，并解决了屏幕方向和分辨率的问题，是时候编写一些动作了。在[第15章](text00027.html#ch15)中，我们将添加我们的英雄和她滑行的地面，使一切动起来，并让玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)'
  id: totrans-6047
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)'
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  id: totrans-6048
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一个SpriteKit游戏项目，准备好了所需的资源，并解决了屏幕方向和分辨率的问题，是时候编写一些动作程序了。在[第15章](text00027.html#ch15)中，我们将加入我们的英雄角色和她滑行的地面，让一切开始移动，并允许玩家点击屏幕让她跳跃。
- en: '![](Image00288.jpg)![](Image00288.jpg)'
  id: totrans-6049
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00288.jpg)![](Image00288.jpg)'
