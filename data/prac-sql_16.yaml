- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Working with JSON Data
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 操作 JSON 数据
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: '*JavaScript Object Notation (JSON)* is a widely used text format for storing
    data in a platform-independent way so it can be shared between computer systems.
    In this chapter, you’ll learn the structure of JSON as well as how to store and
    query JSON data types in PostgreSQL. After we explore PostgreSQL’s JSON query
    operators, we’ll analyze a month’s worth of data about earthquakes.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript 对象表示法 (JSON)* 是一种广泛使用的文本格式，用于以平台无关的方式存储数据，以便在计算机系统之间共享。在本章中，你将学习
    JSON 的结构，以及如何在 PostgreSQL 中存储和查询 JSON 数据类型。在我们探讨 PostgreSQL 的 JSON 查询操作符后，我们将分析一个月的地震数据。'
- en: The American National Standards Institute (ANSI) SQL standard added syntax definitions
    for JSON and specified functions for creating and accessing JSON objects in 2016\.
    Major database systems have added JSON support in recent years as well, although
    implementations vary. PostgreSQL, for example, supports some of the ANSI standard
    while implementing a number of nonstandard operators. I’ll note which aspects
    of PostgreSQL’s JSON support are part of standard SQL as we work through exercises.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 美国国家标准协会（ANSI）SQL 标准在 2016 年增加了 JSON 的语法定义，并指定了用于创建和访问 JSON 对象的函数。近年来，主要的数据库系统也增加了对
    JSON 的支持，尽管实现方式有所不同。例如，PostgreSQL 支持部分 ANSI 标准，同时实现了一些非标准操作符。在我们进行练习时，我会指出 PostgreSQL
    对 JSON 的支持哪些是标准 SQL 的一部分。
- en: Understanding JSON Structure
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 JSON 结构
- en: 'JSON data primarily comprises two structures: an *object*, which is an unordered
    set of name/value pairs, and an *array*, which is an ordered collection of values.
    If you’ve used programming languages such as JavaScript, Python, or C#, these
    aspects of JSON should look familiar.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 数据主要由两种结构组成：*对象*，它是一个无序的键值对集合；和*数组*，它是一个有序的值集合。如果你使用过 JavaScript、Python
    或 C# 等编程语言，这些 JSON 的特性应该很熟悉。
- en: 'Inside an object, we use name/value pairs as a structure for storing and referencing
    individual data items. The object in its entirety is enclosed within curly brackets,
    and each name, more often referred to as a *key*, is enclosed in double quotes,
    followed by a colon and its corresponding value. The object can encapsulate multiple
    key/value pairs, separated by commas. Here’s an example using movie information:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个对象内部，我们使用键值对作为存储和引用单个数据项的结构。整个对象被花括号包围，每个名称（通常称为*键*）都用双引号括起来，后跟冒号及其对应的值。该对象可以包含多个键值对，键值对之间用逗号分隔。以下是一个使用电影信息的示例：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The keys are `title` and `year`, and their values are `"The Incredibles"` and
    `2004`. If the value is a string, it goes in double quotes. If it’s a number,
    a Boolean value, or a `null`, we omit the quotes. If you’re familiar with the
    Python language, you’ll recognize this structure as a *dictionary*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 键是 `title` 和 `year`，它们的值分别是 `"The Incredibles"` 和 `2004`。如果值是字符串，它放在双引号中。如果是数字、布尔值或
    `null`，我们则省略引号。如果你熟悉 Python 语言，你会把这种结构认作是*字典*。
- en: 'An array is an ordered list of values enclosed in square brackets. We separate
    each value in the array with a comma. For example, we might list movie genres
    like so:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个有序的值列表，用方括号括起来。我们用逗号分隔数组中的每个值。例如，我们可能会这样列出电影类型：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Arrays are common in programming languages, and we’ve used them already in SQL
    queries. In Python, this structure is called a *list*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在编程语言中是常见的，我们已经在 SQL 查询中使用过它们。在 Python 中，这种结构被称为*列表*。
- en: We can create many permutations of these structures, including nesting objects
    and arrays inside each other. For example, we can create an array of objects or
    use an array as the value of a key. We can add or omit key/value pairs or create
    additional arrays of objects without violating a preset schema. This flexibility—in
    contrast to the strict definition of a SQL table—is both part of the appeal of
    using JSON as a data store as well as one of the biggest difficulties in working
    with JSON data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建这些结构的多种排列方式，包括将对象和数组相互嵌套。例如，我们可以创建一个对象数组，或使用数组作为键的值。我们可以添加或省略键值对，或创建额外的对象数组，而不会违反预设的模式。这种灵活性——与
    SQL 表的严格定义相比——是使用 JSON 作为数据存储的吸引力之一，也是处理 JSON 数据的最大难点之一。
- en: As an example, [Listing 16-1](#listing16-1) shows information about two of my
    favorite films stored as JSON. The outermost structure is an array with two elements—one
    object for each film. We know the outermost structure is an array because the
    entire JSON begins and ends with square brackets.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，[示例16-1](#listing16-1)展示了以JSON存储的我最喜欢的两部电影的信息。最外层结构是一个包含两个元素的数组——每个电影一个对象。我们知道最外层结构是一个数组，因为整个JSON以方括号开头和结尾。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 16-1: JSON with information about two films'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-1：包含两部电影信息的JSON
- en: Inside the outermost array, each film object is surrounded by curly brackets.
    The open brace at 1 starts the object for the first film *The Incredibles*. For
    both films, we store the `title` and `year` as key/value pairs, and they have
    string and integer values, respectively. The third key, `rating` 2, has a JSON
    object for its value. That object contains a single key/value pair showing the
    film’s rating from the Motion Picture Association of America.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在最外层数组内，每个电影对象都被花括号包围。位于1的打开花括号开始了第一部电影*超人总动员*的对象。对于两部电影，我们将`title`和`year`作为键/值对存储，它们分别具有字符串和整数值。第三个键`rating`
    2，其值是一个JSON对象。该对象包含一个键/值对，显示了该电影来自美国电影协会的评分。
- en: 'Here we can see the flexibility JSON affords us as a storage medium. First,
    if we later wanted to add another country’s rating for the film, we could easily
    add a second key/value pair to the `rating` value object. Second, we’re not required
    to include `rating`—or any key/value pair—in every film object. In fact, I omitted
    a `rating` for *Cinema Paradiso*. If a particular piece of data isn’t available,
    in this case a rating, some systems that generate JSON might simply exclude that
    pair. Other systems might include `rating` but with a `null` value. Both are valid,
    and that flexibility is one of JSON’s advantages: its data definition, or *schema*,
    can flex as needed.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到JSON作为存储介质所赋予我们的灵活性。首先，如果以后想为电影添加另一个国家的评分，我们可以轻松地向`rating`值对象中添加第二个键/值对。其次，我们并不要求在每个电影对象中都包括`rating`—或任何键/值对。事实上，我在*天堂电影院*中省略了`rating`。如果某个特定的数据不可用（例如评分），一些生成JSON的系统可能会简单地省略该对。其他系统可能会包括`rating`，但其值为`null`。这两种做法都是有效的，而这种灵活性正是JSON的优势之一：它的数据定义或*模式*可以根据需要进行调整。
- en: The final two key/value pairs show other ways to structure JSON. For `characters`
    3, the value is an array of objects, with each object surrounded by curly brackets
    and separated by a comma. The value for `genre` 4 is an array of strings.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两个键/值对展示了JSON的其他结构方式。对于`characters` 3，值是一个对象数组，每个对象都被花括号包围，并且用逗号分隔。`genre`
    4的值是一个字符串数组。
- en: Considering When to Use JSON with SQL
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑何时在SQL中使用JSON
- en: There are advantages to using *NoSQL* or *document* databases that store data
    in JSON or other text-based data formats, as opposed to the relational tables
    SQL uses. Document databases are flexible in terms of data definitions. You can
    redefine a data structure on the fly if needed. Document databases are often also
    used for high-volume applications because they can be scaled by adding servers.
    On the flip side, you may give up SQL advantages such as easily added constraints
    that enforce data integrity and support for transactions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*NoSQL*或*文档*数据库（将数据存储在JSON或其他基于文本的数据格式中）相较于使用SQL的关系表有其优势。文档数据库在数据定义方面具有灵活性。如果需要，您可以随时重新定义数据结构。文档数据库通常也用于高流量应用，因为可以通过增加服务器来扩展它们。但另一方面，您可能会放弃SQL的某些优势，例如能够轻松添加约束以确保数据完整性以及对事务的支持。
- en: The arrival of JSON support in SQL has made it possible to enjoy the best of
    both worlds by adding JSON data as columns in relational tables. The decision
    to use a SQL or NoSQL database should be multifaceted. PostgreSQL performs favorably
    relative to NoSQL in terms of speed, but we must also consider the kinds and volume
    of data being stored, the applications being served, and more.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: SQL对JSON的支持使得通过在关系表中添加JSON数据作为列，享受两者的优势成为可能。决定使用SQL还是NoSQL数据库应该是多方面的。相较于NoSQL，PostgreSQL在速度上表现优异，但我们还必须考虑存储的数据种类和数量、所服务的应用程序等因素。
- en: 'That said, some cases where you might want to take advantage of JSON in SQL
    include the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，一些可能希望在SQL中利用JSON的情况包括以下几种：
- en: When users or applications need to arbitrarily create key/value pairs. For example,
    if tagging a collection of medical research papers, one user might want to add
    a key to track chemical names, and another user might want a key to track food
    names.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户或应用程序需要任意创建键/值对时。例如，在标记一组医学研究论文时，一个用户可能想添加一个用于跟踪化学名称的键，而另一个用户可能想要一个用于跟踪食物名称的键。
- en: When storing related data in a JSON column instead of a separate table. An employees
    table could have the usual columns for name and contact information plus a JSON
    column with a flexible collection of key/value pairs that might hold additional
    attributes that don’t apply to every employee, such as company awards or performance
    metrics.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当将相关数据存储在 JSON 列中而不是单独的表中时。例如，员工表可能包含通常的姓名和联系信息列，再加上一列 JSON 数据，存储灵活的键/值对集合，其中可能包含不适用于每个员工的额外属性，如公司奖励或绩效指标。
- en: When saving time by analyzing JSON data fetched from other systems without first
    parsing it into a set of tables.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过分析从其他系统获取的 JSON 数据来节省时间，而无需首先将其解析为一组表格时。
- en: Keep in mind that using JSON in PostgreSQL or other SQL databases can also present
    challenges. Constraints that are trivial to set up on regular SQL tables can be
    more difficult to set and enforce on JSON data. JSON data can consume more space
    as key names get repeated in text along with the quotes, commas, and braces that
    define its structure. Finally, the flexibility of JSON can create issues for the
    code that interacts with it—whether SQL or another language—if keys unexpectedly
    disappear or the data type of a value changes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在 PostgreSQL 或其他 SQL 数据库中使用 JSON 也可能带来一些挑战。对于常规 SQL 表格中容易设置的约束，JSON 数据中的约束可能更难设置和强制执行。随着键名在文本中反复出现，以及定义结构的引号、逗号和大括号，JSON
    数据可能会占用更多的空间。最后，JSON 的灵活性可能会对与其交互的代码（无论是 SQL 还是其他语言）造成问题，如果键名意外消失或某个值的数据类型发生变化。
- en: Keeping all this in mind, let’s review PostgreSQL’s two JSON data types and
    load some JSON into a table.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些内容后，让我们来回顾一下 PostgreSQL 的两种 JSON 数据类型，并将一些 JSON 数据加载到表中。
- en: Using json and jsonb Data Types
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 json 和 jsonb 数据类型
- en: PostgreSQL provides two data types for storing JSON. Both allow insertion of
    valid JSON only—text that includes required elements of the JSON specification,
    such as open and closing curly brackets around an object, commas separating objects,
    and proper quoting of keys. If you try to insert invalid JSON, the database will
    generate an error.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 提供了两种数据类型来存储 JSON。这两种类型只允许插入有效的 JSON——即符合 JSON 规范的文本，包括环绕对象的大括号、分隔对象的逗号以及键的正确引用。如果你尝试插入无效的
    JSON，数据库将生成错误。
- en: The main difference between the two is that one stores JSON as text and the
    other as binary data. The binary implementation is newer to PostgreSQL and generally
    preferred because it’s faster at querying and has indexing capabilities.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的主要区别在于，一种将 JSON 存储为文本，另一种将其存储为二进制数据。二进制实现是 PostgreSQL 新增的功能，通常更受偏好，因为它在查询时更快并且支持索引功能。
- en: 'The two types are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型如下：
- en: '****json****'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '****json****'
- en: Stores JSON as text, keeping white space and maintaining the order of keys.
    If a single JSON object contains a particular key more than once (which is valid),
    the `json` type will preserve each of the repeated key/value pairs. Finally, each
    time a database function processes `json`-stored text, it must parse the object
    to interpret its structure. This can make reads from the database slower than
    with the `jsonb` type. Indexing is not supported. Typically, the `json` type is
    useful when an application has duplicate keys or needs to preserve the order of
    keys.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以文本形式存储 JSON，保留空白并保持键的顺序。如果一个 JSON 对象包含某个特定的键多次（这是有效的），`json` 类型将保留每个重复的键/值对。最后，每次数据库函数处理存储在
    `json` 中的文本时，都必须解析该对象以解释其结构。这可能使得从数据库读取数据的速度比 `jsonb` 类型慢。索引不受支持。通常，当应用程序具有重复键或需要保留键的顺序时，`json`
    类型更为有用。
- en: '****jsonb****'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '****jsonb****'
- en: Stores JSON in a binary format, removing white space and not maintaining the
    order of keys. If a single JSON object contains a particular key more than once,
    the `jsonb` type will preserve only the last of the key/value pairs. The binary
    format adds some overhead to writing data to the table, but processing is faster.
    Indexing is supported.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以二进制格式存储 JSON，去除空白并不保留键的顺序。如果一个 JSON 对象包含某个特定的键多次，`jsonb` 类型将只保留最后一个键/值对。二进制格式会增加写入数据到表格的开销，但处理速度更快。支持索引。
- en: Neither `json` nor `jsonb` is part of the ANSI SQL standard, which doesn’t specify
    a JSON data type and leaves it to database makers to decide how to implement support.
    The PostgreSQL documentation at [https://www.postgresql.org/docs/current/datatype-json.html](https://www.postgresql.org/docs/current/datatype-json.html)
    recommends using `jsonb` unless there’s a need to preserve the order of key/value
    pairs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`和`jsonb`都不是ANSI SQL标准的一部分，ANSI SQL标准并未指定JSON数据类型，如何实现支持则留给数据库厂商决定。PostgreSQL文档中[https://www.postgresql.org/docs/current/datatype-json.html](https://www.postgresql.org/docs/current/datatype-json.html)推荐使用`jsonb`，除非有必要保持键/值对的顺序。'
- en: We’ll use `jsonb` exclusively in the remainder of the chapter, both because
    of speed considerations but also because many of PostgreSQL’s JSON functions work
    the same way with both `json` and `jsonb`—and there are more functions available
    for `jsonb`. We’ll continue by adding the films JSON from [Listing 16-1](#listing16-1)
    to a table and exploring JSON query syntax.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章余下部分，我们将专门使用`jsonb`，不仅因为它的速度考虑，还因为PostgreSQL的许多JSON函数在`json`和`jsonb`上都能以相同的方式工作——并且`jsonb`有更多可用的函数。接下来，我们将把[Listing
    16-1](#listing16-1)中的电影JSON数据添加到表中，并探索JSON查询语法。
- en: Importing and Indexing JSON Data
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入并为JSON数据建立索引
- en: 'The file *films.json* in the Chapter 16 folder of the book’s resources at [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/)
    contains a modified form of the JSON in [Listing 16-1](#listing16-1). View the
    file with a text editor, and you’ll see each film’s JSON object is placed on a
    single line, with no line breaks between elements. I’ve also removed the outermost
    square brackets and the comma separating the two film objects. Each remains a
    valid JSON object:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍资源中第16章文件夹里的*films.json*文件位于[https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/)，包含了[Listing
    16-1](#listing16-1)中JSON的修改版。用文本编辑器查看该文件，你会看到每个电影的JSON对象被放置在一行上，元素之间没有换行。我还去除了最外层的方括号以及分隔两个电影对象的逗号。每个对象仍然是有效的JSON对象：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I set up the file this way so that PostgreSQL’s `COPY` command will interpret
    each film’s JSON object as a separate row on import, the same way it does when
    importing a CSV file. The code in [Listing 16-2](#listing16-2) makes a simple
    `films` table with a surrogate primary key and a `jsonb` column called `film`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我这样设置文件是为了让PostgreSQL的`COPY`命令在导入时将每个电影的JSON对象解释为一行，就像导入CSV文件时那样。[Listing 16-2](#listing16-2)中的代码创建了一个简单的`films`表，具有替代主键和名为`film`的`jsonb`列。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 16-2: Creating a table to hold JSON data and adding an index'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 16-2：创建用于存储JSON数据的表并添加索引
- en: Note that the `COPY` statement ends with the `FROM` clause 1 instead of continuing
    to include a `WITH` statement as in previous examples. The reason we no longer
    need the `WITH` statement, which we’ve used to specify options for file headers
    and CSV formatting, is that this file has no header and isn’t delimited. We just
    want the database to read each line and process it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`COPY`语句以`FROM`子句1结尾，而不是像之前的示例那样继续包含`WITH`语句。我们不再需要`WITH`语句（之前我们用它来指定文件头和CSV格式选项），因为这个文件没有头部，并且没有分隔符。我们只希望数据库读取每一行并处理它。
- en: After import, we add an index 2 to the `jsonb` column using the GIN index type.
    We discussed the generalized inverted index (GIN) with full-text search in Chapter
    14. GIN’s implementation of indexing the location of words or key values within
    text is particularly suited to JSON data. Note that because index entries point
    to rows in a table, `jsonb` column indexing works best when each row contains
    a relatively small chunk of JSON—as opposed to a table with one row that has a
    single, enormous JSON value and repeated keys.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 导入后，我们使用GIN索引类型为`jsonb`列添加索引2。我们在第14章中讨论了用于全文搜索的广义倒排索引（GIN）。GIN在文本中索引单词或键值的位置的实现，特别适用于JSON数据。请注意，因为索引条目指向表中的行，所以`jsonb`列的索引在每行包含相对较小的JSON片段时效果最佳——而不是一个表中有一行包含一个巨大JSON值且重复的键。
- en: Execute the commands to create and fill the table and add the index. Run `SELECT
    * FROM films;` and you should see two rows containing the autogenerated `id` and
    the JSON object text. Now you’re ready to explore querying the data using with
    PostgreSQL’s JSON operators.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令来创建并填充表格，添加索引。运行`SELECT * FROM films;`，你应该能看到两行，分别包含自动生成的`id`和JSON对象文本。现在你准备好使用PostgreSQL的JSON操作符来查询数据了。
- en: Using json and jsonb Extraction Operators
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用json和jsonb提取操作符
- en: To retrieve values from our stored JSON, we can use PostgreSQL-specific *extraction
    operators*, which return either a JSON object, an element of an array, or an element
    that exists at a path in the JSON structure we specify. [Table 16-1](#table16-1)
    shows the operators and their functions, which can vary based on the data type
    of the input. Each works with `json` and `jsonb` data types.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从存储的JSON中提取值，我们可以使用PostgreSQL特定的*提取运算符*，这些运算符返回一个JSON对象、数组的元素，或我们指定路径中存在的元素。[表16-1](#table16-1)展示了这些运算符及其功能，具体功能会根据输入的数据类型有所不同。每个运算符都可以与`json`和`jsonb`数据类型一起使用。
- en: 'Table 16-1: `json` and `jsonb` Extraction Operators'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表16-1：`json`和`jsonb`提取运算符
- en: '| **Operator, syntax** | **Function** | **Returns** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **运算符，语法** | **功能** | **返回类型** |'
- en: '| --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `json` `->` `text` `jsonb` `->` `text` | Extracts a key value, specified
    as text | `json` or `jsonb` (matching the input) |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `json` `->` `text` `jsonb` `->` `text` | 提取键值，作为文本指定 | `json`或`jsonb`（与输入类型匹配）
    |'
- en: '| `json` `->>` `text` `jsonb` `->>` `text` | Extracts a key value, specified
    as text | `text` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `json` `->>` `text` `jsonb` `->>` `text` | 提取键值，作为文本指定 | `text` |'
- en: '| `json` `->` `integer` `jsonb` `->` `integer` | Extracts an array element,
    specified as an integer denoting its array position | `json` or `jsonb` (matching
    the input) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `json` `->` `integer` `jsonb` `->` `integer` | 提取数组元素，指定一个整数表示其在数组中的位置 |
    `json`或`jsonb`（与输入类型匹配） |'
- en: '| `json` `->>` `integer` `jsonb` `->>` `integer` | Extracts an array element,
    specified as an integer denoting its array position | `text` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `json` `->>` `integer` `jsonb` `->>` `integer` | 提取数组元素，指定一个整数表示其在数组中的位置
    | `text` |'
- en: '| `json` `#>` `text array` `jsonb` `#>` `text array` | Extracts a JSON object
    at a specified path | `json` or `jsonb` (matching the input) |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `json` `#>` `text array` `jsonb` `#>` `text array` | 提取指定路径处的JSON对象 | `json`或`jsonb`（与输入类型匹配）
    |'
- en: '| `json` `#>>` `text array` `jsonb` `#>>` `text array` | Extracts a JSON object
    at a specified path | `text` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `json` `#>>` `text array` `jsonb` `#>>` `text array` | 提取指定路径处的JSON对象 | `text`
    |'
- en: Let’s try the operators with our films JSON to learn more about how they vary
    in function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用这些运算符与我们的电影JSON，进一步了解它们在功能上的差异。
- en: Key Value Extraction
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键值提取
- en: In [Listing 16-3](#listing16-3) we use the `->` and `->>` operators followed
    by text naming the key value to retrieve. In that context, with text input, these
    are called *field extraction operators* because they extract a field, or key value,
    from the JSON. The difference between the two is that `->` returns the key value
    as JSON in the same type as stored, and `->>` returns the key value as text.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表16-3](#listing16-3)中，我们使用`->`和`->>`运算符，后面跟上文本来指定要提取的键值。在这种情况下，这些运算符被称为*字段提取运算符*，因为它们从JSON中提取一个字段或键值。两者的区别在于，`->`将键值作为JSON以与存储时相同的类型返回，而`->>`将键值作为文本返回。
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 16-3: Retrieving a JSON key value with field extraction operators'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16-3：使用字段提取运算符提取JSON键值
- en: 'In the `SELECT` list, we specify our JSON column name followed by the operator
    and the key name in single quotes. In the first example, the syntax `->` `''title''`
    1 returns the value of the `title` key as JSON in the same data type as stored,
    `jsonb`. Run the first query, and you should see the output like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SELECT`列表中，我们指定我们的JSON列名，后面跟上运算符和用单引号括起来的键名。在第一个示例中，语法`->` `'title'` 1返回`title`键的值，数据类型与存储时相同，都是`jsonb`。运行第一个查询，你应该看到如下输出：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In pgAdmin, the data type listed in the `title` column header should indicate
    `jsonb`, and the film titles remain quoted, as they are in the JSON object.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在pgAdmin中，`title`列头中列出的数据类型应指示为`jsonb`，并且电影标题保持用引号括起来，就像它们在JSON对象中一样。
- en: 'Changing the field extraction operator to `->>` 2 returns the film titles as
    text instead:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将字段提取运算符更改为`->>` 2时，将电影标题作为文本返回：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we’ll return an array. In our films JSON, the value of the key `genre`
    is an array of values. Using the field extraction operator `->` 3 returns the
    array as `jsonb`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将返回一个数组。在我们的电影JSON中，`genre`键的值是一个值的数组。使用字段提取运算符`->` 3可以将数组作为`jsonb`返回：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we used `->>` here, we’d return the arrays as text. Let’s look at how to
    extract elements from an array.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里使用`->>`，我们将返回数组的文本表示。接下来，我们来看一下如何从数组中提取元素。
- en: Array Element Extraction
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组元素提取
- en: To retrieve a specific value from an array, we follow the `->` and `->>` operators
    with an integer specifying the value’s position, or *index*, in the array. We
    call these *element extraction operators* because they retrieve an element from
    a JSON array. As with field extraction, `->` returns the value as JSON in the
    same type as stored, and `->>` returns it as text.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数组中检索特定值，我们使用`->`和`->>`操作符，后跟指定值在数组中的位置或*索引*。我们称这些为*元素提取操作符*，因为它们从JSON数组中提取元素。与字段提取一样，`->`返回与存储类型相同的JSON值，而`->>`则返回文本格式的值。
- en: '[Listing 16-4](#listing16-4) shows four examples using the array values of
    `"genre"`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 16-4](#listing16-4)显示了四个使用`"genre"`数组值的示例。'
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 16-4: Retrieving a JSON array value with element extraction operators'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 16-4: 使用元素提取操作符获取JSON数组值'
- en: We must first retrieve the array value from the key as JSON and then retrieve
    the desired element from the array. In the first example, we specify the JSON
    column `film`, followed by the field extraction operator `->` and the `genre`
    key name in single quotes. This returns the `genre` value as `jsonb`. We follow
    the key name with `->` and the integer `0` 1 to get the first element.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须先从键中提取数组值作为JSON，然后从数组中提取所需的元素。在第一个示例中，我们指定JSON列`film`，接着使用字段提取操作符`->`和单引号括起来的`genre`键名。这将返回`genre`值，类型为`jsonb`。然后我们跟随键名使用`->`和整数`0`
    1来获取第一个元素。
- en: Why not use `1` for the first value in the array? In many languages, including
    Python and JavaScript, index values start at zero, and that’s also true when accessing
    JSON arrays with SQL.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不使用`1`来表示数组中的第一个值呢？在许多语言中，包括Python和JavaScript，索引值从零开始，在使用SQL访问JSON数组时也遵循这一规则。
- en: 'Run the first query, and your results should look like this, showing the first
    element in each film’s `genre` array, returned as `jsonb`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行第一个查询时，结果应该像这样，显示每部电影的`genre`数组中的第一个元素，返回类型为`jsonb`：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also access the last element of the array, even if we aren’t sure of
    its index, because the number of genres per film can vary. We count backward from
    the end of the list using a negative index number. Supplying `-1` 2 tells `->`
    to get the first element from the end of the list:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以访问数组的最后一个元素，即使我们不确定它的索引，因为每部电影的类型数量可能会不同。我们使用负数索引从列表的末尾倒数。提供`-1` 2会告诉`->`从列表末尾获取第一个元素：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can count back further if we want—an index of `-2` will get the next-to-last
    element.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要，还可以继续往回数——`-2`的索引将获取倒数第二个元素。
- en: 'Note that PostgreSQL won’t return an error if there’s no element at the supplied
    index position; it will simply return a `NULL` for that row. For example, if we
    supply `2` 3 for the index, we see results for one of our films and a `NULL` for
    the other:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果在指定的索引位置没有元素，PostgreSQL不会返回错误，它只会返回该行的`NULL`。例如，如果我们为索引提供`2` 3，则会看到一部电影的结果，另一部电影则显示`NULL`：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We get a `NULL` back for *Cinema Paradiso* because it has only two elements
    in its `genre` value array, and index `2` (since we count up starting with zero)
    represents the third element. Later in the chapter, we’ll learn how to count array
    lengths.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*Cinema Paradiso*，我们得到`NULL`，因为它的`genre`值数组只有两个元素，索引`2`（从零开始计数）表示第三个元素。稍后我们将在本章中学习如何计算数组长度。
- en: 'Finally, changing the element extraction operator to `->>` 4 returns the desired
    element as a `text` data type rather than JSON:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将元素提取操作符改为`->>` 4可以返回所需的元素，数据类型为`text`，而非JSON：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the same pattern as we saw when extracting key values: `->` returns
    a JSON data type, and `->>` returns text.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在提取键值时看到的模式相同：`->`返回JSON数据类型，`->>`返回文本。
- en: Path Extraction
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径提取
- en: Both `#>` and `#>>` are *path extraction operators* that return an object located
    at a JSON path. A path is a series of keys or array indices that lead to the location
    of a value. In our example JSON, it might be just the `title` key if we want the
    name of the film. Or it could be more complex, such as the `characters` key followed
    by an index value of `1`, then the `actor` key; this would provide the path to
    the name of the actor at index `1`. The `#>` path extraction operator returns
    a JSON data type matching the stored data, and `#>>` returns text.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`#>`和`#>>`都是*路径提取操作符*，用于返回位于JSON路径中的对象。路径是由一系列键或数组索引组成，用于定位值的位置。在我们的示例JSON中，如果我们想要电影的名称，路径可能仅是`title`键。或者，路径可能更复杂，例如`characters`键，后跟索引值`1`，再后面是`actor`键；这样可以提供指向索引`1`处演员姓名的路径。`#>`路径提取操作符返回与存储数据匹配的JSON数据类型，而`#>>`返回文本。'
- en: 'Consider the MPAA rating for the film *The Incredibles*, which appears in our
    JSON like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑电影 *超人总动员* 的 MPAA 评级，在我们的 JSON 中显示如下：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The structure is a key named `rating` with an object for its value; inside that
    object is a key/value pair with `MPAA` as the key name. Thus, the path to the
    film’s MPAA rating begins with the `rating` key and ends with the `MPAA` key.
    To denote the path’s elements, we use the PostgreSQL string syntax for arrays,
    creating a comma-separated list inside curly brackets and single quotes. We then
    feed that string to the path extraction operators. [Listing 16-5](#listing16-5)
    shows three examples of setting paths.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构是一个名为 `rating` 的键，其值是一个对象；在该对象内有一个键/值对，`MPAA` 为键名。因此，电影的 MPAA 评级的路径从 `rating`
    键开始，到 `MPAA` 键结束。为了表示路径的元素，我们使用 PostgreSQL 数组的字符串语法，创建一个以逗号分隔的列表，放在花括号和单引号中。然后，我们将该字符串传递给路径提取操作符。[列表
    16-5](#listing16-5) 展示了设置路径的三个示例。
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 16-5: Retrieving a JSON key value with path extraction operators'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 16-5: 使用路径提取操作符获取 JSON 键值'
- en: 'To get each film’s MPAA rating, we specify the path in an array: `{rating,
    MPAA}` 1 with each item separated by commas. Run the query, and you should see
    these results:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取每部电影的 MPAA 评级，我们在数组中指定路径：`{rating, MPAA}` 1，每个项由逗号分隔。运行查询后，你应该看到以下结果：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The query returns the PG rating for *The Incredibles* and a `NULL` for *Cinema
    Paradiso* because, in our data, the latter film has no MPAA rating present.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回 *超人总动员* 的 PG 评级和 *天堂电影院* 的 `NULL`，因为在我们的数据中，后者没有 MPAA 评级。
- en: 'The second example works with the array of `characters`, which in our JSON
    looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例适用于 `characters` 数组，在我们的 JSON 中看起来是这样的：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `characters` array shown is for the second movie, but both films have a
    similar structure. Array objects each represent a character and the name and the
    actor who played them. To locate the name of the first character in the array,
    we specify a path 2 that starts at the `characters` key, continues to the first
    element of the array using the index `0`, and ends at the `name` key. The query
    results should look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的 `characters` 数组是第二部电影的内容，但两部电影的结构相似。数组对象分别表示一个角色，以及扮演该角色的演员的名字。为了查找数组中第一个角色的名字，我们指定一个路径
    2，从 `characters` 键开始，使用索引 `0` 访问数组的第一个元素，并以 `name` 键结束。查询结果应该像这样：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `#>` operator returns results as a JSON data type, in our case `jsonb`.
    If we want the results as text, we use `#>>` 3 with the same path.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`#>` 操作符将结果返回为 JSON 数据类型，在我们的例子中是 `jsonb`。如果我们希望以文本格式返回结果，我们使用 `#>>` 3，路径相同。'
- en: Containment and Existence
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包含性和存在性
- en: 'The final collection of operators we’ll explore performs two kinds of evaluations.
    The first concerns *containment* and checks whether a specified JSON value contains
    a second specified JSON value. The second tests for *existence*: whether a string
    of text within a JSON object exists as a top-level key (or as an element of an
    array nested inside a deeper object). Both kinds of operators return a Boolean
    value, which means we can use them in a `WHERE` clause to filter query results.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨的最后一组操作符执行两种类型的评估。第一种涉及 *包含性*，检查指定的 JSON 值是否包含第二个指定的 JSON 值。第二种检查 *存在性*：测试
    JSON 对象中的文本字符串是否作为顶级键（或作为嵌套在更深层对象中的数组元素）存在。这两种操作符都返回布尔值，这意味着我们可以在 `WHERE` 子句中使用它们来筛选查询结果。
- en: This set of operators works only with the `jsonb` data type—another good reason
    to favor `jsonb` over `json`—and can make use of our GIN index for efficient searching.
    [Table 16-2](#table16-2) lists the operators with their syntax and function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这组操作符仅适用于 `jsonb` 数据类型——这也是我们偏好 `jsonb` 而非 `json` 的另一个好理由——并且可以利用我们的 GIN 索引进行高效搜索。[表
    16-2](#table16-2) 列出了这些操作符的语法和功能。
- en: 'Table 16-2: `jsonb` Containment and Existence Operators'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '表 16-2: `jsonb` 包含和存在操作符'
- en: '| **Operator, syntax** | **Function** | **Returns** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **操作符，语法** | **功能** | **返回值** |'
- en: '| --- | --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `jsonb` `@>` `jsonb` | Tests whether the first JSON value contains the second
    JSON value | `boolean` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `jsonb` `@>` `jsonb` | 测试第一个 JSON 值是否包含第二个 JSON 值 | `boolean` |'
- en: '| `jsonb` `<@` `jsonb` | Tests whether the second JSON value contains the first
    JSON value | `boolean` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `jsonb` `<@` `jsonb` | 测试第二个 JSON 值是否包含第一个 JSON 值 | `boolean` |'
- en: '| `jsonb` `?` `text` | Tests whether the text exists as a top-level (not nested)
    key or an array value | `boolean` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `jsonb` `?` `text` | 测试文本是否作为顶级（非嵌套）键或数组值存在 | `boolean` |'
- en: '| `jsonb` `?&#124;` `text array` | Tests whether any of the text elements in
    the array exist as a top-level (not nested) key or as an array value | `boolean`
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `jsonb` `?&#124;` `text array` | 测试数组中的任何文本元素是否存在为顶层（非嵌套）键或数组值 | `boolean`
    |'
- en: '| `jsonb` `?&` `text array` | Tests whether all of the text elements in the
    array exist as a top-level (not nested) key or as an array value | `boolean` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `jsonb` `?&` `text array` | 测试数组中的所有文本元素是否存在为顶层（非嵌套）键或数组值 | `boolean` |'
- en: Using Containment Operators
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用包含操作符
- en: In [Listing 16-6](#listing16-6), we use `@>` to evaluate whether one JSON value
    contains a second JSON value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 16-6](#listing16-6)中，我们使用 `@>` 来评估一个 JSON 值是否包含第二个 JSON 值。
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 16-6: Demonstrating the `@>` containment operator'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-6：演示 `@>` 包含操作符
- en: 'In our `SELECT` list, we check whether the JSON stored in the `film` column
    in each row contains the key/value pair for *The Incredibles*. We use the `@>`
    containment operator 1 in an expression that generates a column with the Boolean
    result `true` if `film` contains `"title": "The Incredibles"`. We give the name
    of our JSON column, `film`, then the `@>` operator, and then a string (cast to
    `jsonb`) specifying the key/value pair. In our `SELECT` list, we also return the
    text of the film title as a column. Running the query should produce these results:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的 `SELECT` 列表中，我们检查每一行中存储在 `film` 列中的 JSON 是否包含 *超人总动员* 的键值对。我们在表达式中使用了
    `@>` 包含操作符 1，如果 `film` 包含 `"title": "The Incredibles"`，则生成一个布尔结果 `true` 的列。我们给出了我们的
    JSON 列 `film`，然后是 `@>` 操作符，再是一个字符串（强制转换为 `jsonb`），指定键值对。在我们的 `SELECT` 列表中，我们还将电影标题的文本作为一列返回。运行查询应该得到如下结果：'
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As expected, the expression evaluates to `true` for *The Incredibles* and `false`
    for *Cinema Paradiso*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，表达式对 *超人总动员* 评估为 `true`，对 *天堂电影院* 评估为 `false`。
- en: Because the expression evaluates to a Boolean result, we can use it in a query’s
    `WHERE` 2 clause, as shown in [Listing 16-7](#listing16-7).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为该表达式评估为布尔结果，所以我们可以将其用于查询的 `WHERE` 2 子句，如[列表 16-7](#listing16-7)所示。
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 16-7: Using a containment operator in a `WHERE` clause'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-7：在 `WHERE` 子句中使用包含操作符
- en: 'Here we again check that the JSON in the `film` column contains the key/value
    pair for the title of *The Incredibles*. By placing the evaluation in a `WHERE`
    clause, the query should return just the row where the expression returns `true`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们再次检查 `film` 列中的 JSON 是否包含 *超人总动员* 的标题键值对。通过将评估放在 `WHERE` 子句中，查询应该只返回表达式返回
    `true` 的那一行：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, in [Listing 16-8](#listing16-8), we flip the order of evaluation to
    check whether the key/value pair specified is contained within the `film` column.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在[列表 16-8](#listing16-8)中，我们翻转了评估顺序，以检查指定的键值对是否包含在 `film` 列中。
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 16-8: Demonstrating the `<@` containment operator'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-8：演示 `<@` 包含操作符
- en: Here we use the `<@` operator 3 instead of `@>` to flip the order of evaluation.
    This expression also evaluates to `true`, returning the same result as the previous
    query.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `<@` 操作符 3 替代 `@>` 来翻转评估顺序。这个表达式也会评估为 `true`，返回与之前查询相同的结果。
- en: Using Existence Operators
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用存在性操作符
- en: Next, in [Listing 16-9](#listing16-9), we explore three existence operators.
    These check whether the text we supply exists as a top-level key or as an element
    of an array. All return a Boolean value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在[列表 16-9](#listing16-9)中，我们探讨了三个存在性操作符。它们检查我们提供的文本是否存在为顶层键或数组元素。所有操作符都返回布尔值。
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 16-9: Demonstrating existence operators'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-9：演示存在性操作符
- en: The `?` operator checks for the existence of a single key or array element.
    In the first query’s `WHERE` clause, we give the `film` column, the `?` operator
    1, and then the string `rating`. This syntax says, “In each row, does `rating`
    exist as a key in the JSON in the `film` column?” When we run the query, the results
    show the one film that has a `rating` key, *The Incredibles*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`?` 操作符检查单个键或数组元素的存在。在第一个查询的 `WHERE` 子句中，我们给出了 `film` 列、`?` 操作符 1，然后是字符串 `rating`。这个语法表示：“在每一行中，`rating`
    是否存在为 `film` 列中的 JSON 键？”当我们运行查询时，结果显示了唯一拥有 `rating` 键的电影 *超人总动员*。'
- en: The `?|` and `?&` operators act as `or` and `and`. For example, using `?|` 2
    tests whether either `rating` or `genre` exist as top-level keys. Running that
    second query returns both films, because both have at least one of those keys.
    Using `?&` 3, however, tests whether both `rating` and `genre` exist as keys,
    and that’s true for only *The Incredibles*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`?|` 和 `?&` 操作符分别作为 `or` 和 `and` 使用。例如，使用 `?|` 2 会测试是否存在`rating`或`genre`作为顶级键。运行第二个查询返回两个影片，因为它们至少有其中一个键。然而，使用
    `?&` 3 会测试是否同时存在`rating`和`genre`键，这对*超人总动员*来说是成立的。'
- en: All these operators provide options for fine-tuning your exploration of your
    JSON data. Now, let’s use some of them on a larger dataset.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作符提供了细致调整JSON数据探索的选项。现在，让我们在一个更大的数据集上使用其中的一些操作符。
- en: Analyzing Earthquake Data
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析地震数据
- en: In this section, we’ll analyze a collection of JSON data about earthquakes compiled
    by the US Geological Survey, an agency of the US Department of the Interior that
    monitors natural phenomenon including volcanoes, landslides, and water quality.
    The USGS uses a network of seismographs that record the earth’s vibrations, compiling
    data on each seismic event’s location and intensity. Minor earthquakes occur around
    the world many times a day; the big ones are less frequent but potentially devastating.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析由美国地质调查局（US Geological Survey）编制的地震JSON数据。美国地质调查局是美国内政部的一个机构，监测包括火山、滑坡和水质在内的自然现象。美国地质调查局利用一网络的地震仪来记录地球的震动，编制每个地震事件的地点和强度数据。小型地震在全球每天发生多次；而大型地震则较为少见，但可能会造成灾难性后果。
- en: For our exercise, I fetched a month’s worth of JSON-formatted earthquake data
    from a USGS *application programming interface*, better known as an API. An *API*
    is a resource for transmitting data and commands between computers, and JSON is
    often used for APIs. You’ll find the data in the file *earthquakes.json* in the
    folder for this chapter included in the book’s resources.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的练习，我从美国地质调查局（USGS）的*应用程序编程接口*（API）中提取了一个月的JSON格式地震数据。*API*是计算机之间传输数据和命令的资源，而JSON常用于API中。你可以在本书资源的本章文件夹中找到名为*earthquakes.json*的文件。
- en: Exploring and Loading the Earthquake Data
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索并加载地震数据
- en: '[Listing 16-10](#listing16-10) shows the data structure for each earthquake
    record in the file, along with a selection of its key/value pairs (your *Chapter_16.sql*
    file has the nonsnipped version).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单16-10](#listing16-10)显示了文件中每个地震记录的数据结构，以及它的部分键值对（你的*Chapter_16.sql*文件有未截断的版本）。'
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 16-10: JSON with data on one earthquake'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 清单16-10：包含一个地震数据的JSON
- en: 'This data is in *GeoJSON* format, a JSON-based specification for spatial data.
    GeoJSON will include one or more `Feature` objects, denoted by inclusion of the
    key/value pair `"type": "Feature"` 1. Each `Feature` describes a single spatial
    object and contains both descriptive attributes (such as event time or related
    codes) under `properties` 2 plus a `geometry` 3 key that includes the coordinates
    of the spatial object. In our data, each `geometry` is a Point, a simple feature
    with the coordinates of one earthquake’s longitude, latitude, and depth in kilometers.
    We discussed Points and simple features in Chapter 15 when working with PostGIS;
    GeoJSON incorporates it and other spatial simple features. You can read more about
    the GeoJSON specification at [https://geojson.org/](https://geojson.org/) and
    see definitions of the keys in the USGS documentation at [https://earthquake.usgs.gov/data/comcat/data-eventterms.php/](https://earthquake.usgs.gov/data/comcat/data-eventterms.php/).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '这些数据采用*GeoJSON*格式，这是一个基于JSON的空间数据规范。GeoJSON将包含一个或多个`Feature`对象，通过包含键值对`"type":
    "Feature"`来表示1。每个`Feature`描述一个空间对象，并在`properties`下包含描述性属性（例如事件时间或相关代码）2，以及包含空间对象坐标的`geometry`
    3键。在我们的数据中，每个`geometry`都是一个点（Point），这是一个简单的特征，包含一个地震的经度、纬度和深度（单位：千米）坐标。我们在第15章使用PostGIS时讨论了点和简单特征；GeoJSON将其与其他空间简单特征结合使用。你可以在[https://geojson.org/](https://geojson.org/)阅读更多关于GeoJSON规范的内容，并在USGS文档中查看键的定义，网址为[https://earthquake.usgs.gov/data/comcat/data-eventterms.php/](https://earthquake.usgs.gov/data/comcat/data-eventterms.php/)。'
- en: Let’s load our data into a table called `earthquakes` using the code in [Listing
    16-11](#listing16-11).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用[清单16-11](#listing16-11)中的代码，将数据加载到名为`earthquakes`的表中。
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 16-11: Creating and loading an earthquakes table'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 清单16-11：创建并加载地震数据表
- en: As with our `films` table, we use `COPY` to copy the data into a single `jsonb`
    column 1 and add a GIN index 2. Running `SELECT * FROM earthquakes;` should return
    12,899 rows. Now let’s see what we can learn from the data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的`films`表类似，我们使用`COPY`将数据复制到一个单独的`jsonb`列中，并添加一个GIN索引。运行`SELECT * FROM earthquakes;`应返回12,899行数据。现在让我们看看我们可以从数据中学到什么。
- en: Working with Earthquake Times
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理地震时间
- en: The `time` key/value pair represents the moment the earthquake occurred. In
    [Listing 16-12](#listing16-12), we retrieve the value of `time` using a path extraction
    operator.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`键/值对表示地震发生的时刻。在[列表16-12](#listing16-12)中，我们使用路径提取运算符检索`time`的值。'
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 16-12: Retrieving the earthquake time'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-12：检索地震时间
- en: 'In the `SELECT` list, we give the `earthquake` column followed by a `#>>` path
    extraction operator and the path 1 to the time value denoted as an array. The
    `#>>` operator will return our value as text. Running the query should return
    five rows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SELECT`列表中，我们给出`earthquake`列，后跟`#>>`路径提取运算符和路径1，用来获取数组中表示时间值的`#>>`运算符将我们的值作为文本返回。运行查询应返回五行：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If those values don’t look like times to you, that’s not surprising. By default,
    the USGS represents time as milliseconds since the Unix epoch at 00:00 UTC on
    January 1, 1970\. That’s a variant of the standard epoch time we covered in Chapter
    12, which measures seconds since the epoch. We can convert this USGS `time` value
    to something understandable using `to_timestamp()` and a little math, as shown
    in [Listing 16-13](#listing16-13).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些值看起来不像时间，这并不奇怪。默认情况下，USGS将时间表示为从1970年1月1日00:00 UTC起的毫秒数。这是我们在第12章介绍的标准时代的一个变体，该时代以秒计量。我们可以使用`to_timestamp()`和一点数学来将USGS的`time`值转换为可理解的形式，如[列表16-13](#listing16-13)所示。
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 16-13: Converting the `time` value to a timestamp'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16-13：将`time`值转换为时间戳
- en: Inside the parentheses of the `to_timestamp()` 1 function, we repeat the code
    to extract the `time` value. The `to_timestamp()` function requires a number representing
    seconds, but the extracted value is text and in milliseconds, so we also cast
    the extracted text to `bigint` and divide by 1,000 2 to convert it to seconds.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`to_timestamp()`函数的括号内，我们重复代码以提取`time`值。`to_timestamp()`函数需要表示秒数的数字，但提取的值是文本且以毫秒为单位，因此我们还将提取的文本转换为`bigint`并除以1000以将其转换为秒。
- en: 'On my machine, the query generates the following results showing the extracted
    `time` value and its converted timestamp (your values will vary depending on your
    PostgreSQL server’s time zone, so `time_formatted` will show when the earthquake
    occurred in your server’s time zone time):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，查询生成以下结果，显示提取的`time`值及其转换后的时间戳（根据您的PostgreSQL服务器时区设置不同，您的值将有所不同，因此`time_formatted`将显示地震发生时的服务器时区时间）。
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that we have an understandable timestamp, let’s find the oldest and newest
    earthquake times using the `min()` and `max()` aggregate functions in [Listing
    16-14](#listing16-14).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可理解的时间戳，让我们使用`min()`和`max()`聚合函数在[列表16-14](#listing16-14)中找到最旧和最新的地震时间。
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 16-14: Finding the minimum and maximum earthquake times'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16-14：查找最小和最大的地震时间
- en: 'We place `to_timestamp()` and our milliseconds-to-seconds conversion inside
    both the `min()` 1 and `max()` 3 functions in our `SELECT` list. This time, we
    add the keywords `AT TIME ZONE ''UTC''` 2 after both functions; regardless of
    our server time zone settings, the results will display the timestamps in UTC,
    as USGS records them. Your results should look like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`SELECT`列表中的`min()`和`max()`函数内部放置`to_timestamp()`和我们的毫秒转秒转换。这一次，在两个函数之后添加关键字`AT
    TIME ZONE 'UTC'`，无论我们的服务器时区设置如何，结果都将以UTC显示，正如USGS记录的那样。您的结果应该如下所示：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This collection of earthquakes spans a month—from early morning January 1, 2021,
    through the end of day on January 31\. That’s helpful context as we continue to
    dig for usable information.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这组地震跨越了一个月——从2021年1月1日凌晨到1月31日结束。这是我们继续挖掘可用信息时的有用背景。
- en: Finding the Largest and Most-Reported Earthquakes
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找最大和最多报告的地震
- en: Next, we’ll look at two data points that measure an earthquake’s size and the
    degree to which citizens reported feeling it and apply JSON extraction techniques
    to simple sorting of results.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看两个数据点，即地震的大小和市民报告感觉程度，并应用JSON提取技术对结果进行简单排序。
- en: Extracting by Magnitude
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按震级提取
- en: 'The USGS reports each earthquake’s magnitude in the `mag` key, beneath `properties`.
    Magnitude, according to the USGS, is a number representing the size of an earthquake
    at its source. Its scale is logarithmic: a magnitude 4 earthquake has seismic
    waves whose amplitude is about 10 times bigger than a quake with a magnitude of
    3\. With that context, let’s find the five largest earthquakes in our data using
    the code in [Listing 16-15](#listing16-15).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 美国地质调查局（USGS）报告每个地震的震级，位于`mag`键下，位于`properties`之下。根据USGS的定义，震级是表示地震源大小的一个数字。它的尺度是对数的：一个震级为4的地震，其地震波的振幅约是震级为3的地震的10倍。了解了这一背景后，我们来使用[清单16-15](#listing16-15)中的代码，查找我们数据中五个最大的地震。
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 16-15: Finding the five earthquakes with the largest magnitude'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 清单16-15：查找五个震级最大的地震
- en: 'We again use path extraction operators to retrieve our desired elements, including
    values for `place` 1 and `mag`. To show the largest five in our results, we add
    an `ORDER BY` clause 2 with `mag`. We cast the value to numeric 3 here and in
    the `SELECT` because we want to display and sort the value as a number rather
    than as text. We also add the `DESC NULLS LAST` keywords, which sorts the results
    in descending order and places `NULL` values (of which there are two) last. Your
    results should look like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用路径提取操作符来获取我们所需的元素，包括`place` 1和`mag`的值。为了在结果中显示最大的五个，我们在`ORDER BY`子句 2中添加了`mag`。我们在此处和`SELECT`中将值强制转换为数值类型
    3，因为我们希望将其作为数字而不是文本进行显示和排序。我们还添加了`DESC NULLS LAST`关键字，这样可以将结果按降序排列，并将`NULL`值（有两个）放在最后。你的结果应该如下所示：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The largest, of magnitude 7, was located beneath the ocean southeast of the
    small city of Pondaguitan in the Philippines. The second was in the Antarctic
    near the South Shetland Islands.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的一次震级为7，发生在菲律宾小城市Pondaguitan东南的海洋下。第二次地震发生在南极的南设得兰群岛附近。
- en: Extracting by Citizen Reports
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于市民报告的提取
- en: The USGS operates a Did You Feel It? website at [https://earthquake.usgs.gov/data/dyfi/](https://earthquake.usgs.gov/data/dyfi/)
    where people can report their earthquake experiences. Our JSON includes the number
    of reports for each earthquake under the key `felt`, beneath `properties`. Let’s
    see which earthquakes in our data generated the most reports using the code in
    [Listing 16-16](#listing16-16).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 美国地质调查局（USGS）运营着一个“你感觉到地震了吗？”网站，地址是[https://earthquake.usgs.gov/data/dyfi/](https://earthquake.usgs.gov/data/dyfi/)，人们可以在此报告他们的地震体验。我们的JSON数据中包含每个地震的报告数量，这些数据位于`felt`键下，位于`properties`之下。我们将使用[清单16-16](#listing16-16)中的代码来查看我们的数据中哪些地震产生了最多的报告。
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 16-16: Finding earthquakes with the most Did You Feel It? reports'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 清单16-16：查找拥有最多“你感觉到地震了吗？”报告的地震
- en: 'Structurally, this query is similar to [Listing 16-15](#listing16-15) that
    found the largest quakes. We add a path extraction operator for the `felt` 1 key,
    casting the returned text value to an `integer` type. We cast to `integer` so
    the extracted text is treated as a number for sorting and display. Finally, we
    place the extraction code in `ORDER BY` 2, using `NULLS LAST` because there are
    many earthquakes with no reports and we want those to appear last in the list.
    You should see these results:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结构上，这个查询类似于[清单16-15](#listing16-15)，用于查找最大规模的地震。我们为`felt`键添加了路径提取操作符，将返回的文本值强制转换为`integer`类型。我们将其强制转换为`integer`，是因为提取的文本将作为数字进行排序和显示。最后，我们将提取代码放在`ORDER
    BY` 2中，使用`NULLS LAST`，因为有许多地震没有报告，我们希望这些地震出现在列表的最后。你应该看到以下结果：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The top five are in California, which makes sense. Did You Feel It? is a US
    government-run system, so we’d expect more US reports—particularly in earthquake-prone
    California. Also, some of the largest quakes in our data occurred beneath oceans
    or in remote regions. The quake with more than 19,900 reports was moderate, but
    its nearness to cities meant more chance for people to notice it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 排名前五的地震都发生在加利福尼亚，这很有道理。“你感觉到地震了吗？”是美国政府运营的系统，因此我们会预期更多的美国报告，尤其是在易发生地震的加利福尼亚。此外，我们数据中一些最大的地震发生在海洋下或偏远地区。那次拥有超过19,900份报告的地震震级适中，但由于它靠近城市，人们更容易注意到它。
- en: Converting Earthquake JSON to Spatial Data
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将地震JSON转换为空间数据
- en: Our JSON data has longitude and latitude values for each earthquake, meaning
    we can perform spatial analysis using the GIS techniques discussed in Chapter
    15. For example, we’ll use a PostGIS distance function to locate earthquakes that
    occurred within 50 miles from a city. First, though, we must convert the coordinates
    stored in JSON to a PostGIS data type.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 JSON 数据包含了每次地震的经度和纬度值，这意味着我们可以使用第 15 章讨论的 GIS 技术进行空间分析。例如，我们将使用 PostGIS
    距离函数来定位发生在距离某城市 50 英里以内的地震。但是，首先我们必须将存储在 JSON 中的坐标转换为 PostGIS 数据类型。
- en: 'The longitude and latitude values are found in the array of the `coordinates`
    key, under `geometry`. Here’s an example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 经度和纬度值位于 `geometry` 下的 `coordinates` 键的数组中。以下是一个例子：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first coordinate, at position `0` in the array, represents longitude; the
    second, at position `1`, is latitude. The third value denotes depth in kilometers,
    which we won’t use. To extract these elements as text, we make use of a `#>>`
    path operator, as in [Listing 16-17](#listing16-17).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的第一个坐标（位置 `0`）表示经度；第二个坐标（位置 `1`）表示纬度。第三个值表示深度（单位为千米），我们暂时不使用。要将这些元素提取为文本，我们使用
    `#>>` 路径操作符，如 [列表 16-17](#listing16-17) 所示。
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 16-17: Extracting the earthquake’s location data'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-17：提取地震的位置信息
- en: 'The query should return five rows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 查询应返回五行数据：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A quick visual compare of our result to the JSON `longitude` and `latitude`
    values tells us we’ve extracted the values properly. Next, we’ll use a PostGIS
    function to convert those values to a Point in the `geography` data type.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过快速对比我们的结果与 JSON 中的 `longitude` 和 `latitude` 值，我们可以确认提取的值是正确的。接下来，我们将使用 PostGIS
    函数将这些值转换为 `geography` 数据类型中的点。
- en: '[Listing 16-18](#listing16-18) generates a Point of type `geography` for each
    earthquake, which we can use as input for PostGIS spatial functions.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 16-18](#listing16-18) 为每次地震生成一个 `geography` 类型的点，我们可以将其用作 PostGIS 空间函数的输入。'
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 16-18: Converting JSON location data to PostGIS geography'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-18：将 JSON 位置信息转换为 PostGIS 地理数据
- en: 'Inside `ST_MakePoint()`1, we place our code to extract longitude and latitude,
    casting both values to type `numeric` as required by the function. We nest that
    function inside `ST_SetSRID()` to set a spatial reference system identifier (SRID)
    for the resulting Point. In Chapter 15, you learned that the SRID specifies a
    coordinate grid for plotting spatial objects. The SRID value `4326` 2 denotes
    the commonly used WGS 84 coordinate system. Finally, we cast the entire output
    to the `geography` type. The first several rows should look like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ST_MakePoint()` 内，我们放入提取经度和纬度的代码，将这两个值强制转换为 `numeric` 类型，以符合该函数的要求。我们将该函数嵌套在
    `ST_SetSRID()` 中，以设置结果点的空间参考系统标识符（SRID）。在第 15 章中，你学到 SRID 用于指定绘制空间对象的坐标网格。SRID
    值 `4326` 表示常用的 WGS 84 坐标系统。最后，我们将整个输出转换为 `geography` 类型。前几行数据应该如下所示：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can’t interpret those strings of digits and letters directly, but we can
    use pgAdmin’s Geometry Viewer to see the Points plotted on a map. With your query
    results visible in the pgAdmin Data Output pane, click the eye icon in the `earthquake_point`
    result header. You should see the earthquakes plotted on a map that uses OpenStreetMap
    as the base layer, as in [Figure 16-1](#figure16-1).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法直接解释那些由数字和字母组成的字符串，但可以使用 pgAdmin 的几何图形查看器来查看地图上的地震点。在 pgAdmin 数据输出窗格中显示查询结果后，点击
    `earthquake_point` 结果头部的眼睛图标。你应该能看到在地图上绘制的地震位置，地图使用 OpenStreetMap 作为底图，如 [图 16-1](#figure16-1)
    所示。
- en: Even with only a month of data, it’s easy to see the abundance of earthquakes
    concentrated around the edges of the Pacific Ocean, in the so-called Ring of Fire
    where tectonic plates meet and volcanos are more active.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 即使只有一个月的数据，也很容易看出地震集中在太平洋边缘的环太平洋地震带（即“火环”）区域，这里是构造板块碰撞和火山活动较为活跃的地方。
- en: '![f16001](Images/f16001.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![f16001](Images/f16001.png)'
- en: 'Figure 16-1: Viewing earthquake locations in pgAdmin'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16-1：在 pgAdmin 中查看地震位置
- en: Finding Earthquakes Within a Distance
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找指定距离内的地震
- en: Next, let’s narrow our study to earthquakes that occurred near Tulsa, Oklahoma—a
    part of the country that has seen increased seismic activity since 2009 as a result
    of oil and gas processing, according to the USGS.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将研究范围缩小到发生在俄克拉荷马州塔尔萨附近的地震——根据美国地质调查局（USGS）的数据，这个地区自 2009 年以来，由于石油和天然气加工活动，地震活动有所增加。
- en: To perform more complex GIS tasks like this, it’s easier if we permanently convert
    the JSON coordinates to a column of PostGIS type `geography` in the `earthquakes`
    table. That allows us to avoid the clutter of adding conversion code in each query.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行像这样的复杂GIS任务，如果我们将JSON坐标永久转换为`earthquakes`表中的`geography`类型列，事情会更容易。这样可以避免在每个查询中添加转换代码的混乱。
- en: '[Listing 16-19](#listing16-19) adds a column called `earthquake_point` to the
    `earthquakes` table and fills the new column with the JSON coordinates converted
    to type `geography`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例16-19](#listing16-19)向`earthquakes`表中添加了一个名为`earthquake_point`的列，并将JSON坐标转换为`geography`类型填充到新列中。'
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 16-19: Converting JSON coordinates to a PostGIS geometry column'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-19：将JSON坐标转换为PostGIS几何列
- en: We use `ALTER TABLE` 1 to add a column `earthquake_point` of type `geography`,
    specifying that the column will hold Points with an SRID of `4326`. Next, we `UPDATE`
    2 the table, setting the `earthquake_point` column using the same syntax as in
    [Listing 16-18](#listing16-18), and add a spatial index using GIST 3 to the new
    column.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ALTER TABLE` 1来添加一个类型为`geography`的列`earthquake_point`，并指定该列将包含具有SRID `4326`的点。接下来，我们使用2中的`UPDATE`语句更新表格，使用与[示例16-18](#listing16-18)中相同的语法设置`earthquake_point`列，并对新列添加空间索引，使用GIST
    3。
- en: That done, we can use [Listing 16-20](#listing16-20) to find earthquakes within
    50 miles of Tulsa.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以使用[示例16-20](#listing16-20)来查找位于塔尔萨50英里范围内的地震。
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 16-20: Finding earthquakes within 50 miles of downtown Tulsa, Oklahoma'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 示例16-20：查找位于塔尔萨市中心50英里范围内的地震
- en: 'In the `WHERE` clause 1, we employ the `ST_DWithin()` function, which returns
    a Boolean value of `true` if one spatial object is within a specified distance
    of another object. Here, we want to evaluate each earthquake Point to check whether
    it’s within 50 miles of downtown Tulsa. We designate the city’s coordinates in
    `ST_GeogFromText()` 2 and supply the value of 50 miles using its meters equivalent,
    `80468`, as meters is the required input. The query should return 19 rows (I’ve
    omitted the `earthquake_point` column and truncated the results for brevity):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WHERE`子句1中，我们使用了`ST_DWithin()`函数，该函数如果一个空间对象在另一个对象的指定距离内，则返回布尔值`true`。在这里，我们想要评估每个地震点，以检查它是否位于塔尔萨市中心50英里范围内。我们在`ST_GeogFromText()`
    2中指定了该城市的坐标，并使用其米制等价值`80468`作为输入值，因为米是必需的输入单位。查询应该返回19行（我省略了`earthquake_point`列并截断了结果以便简洁）：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: View the earthquake locations by clicking the eye icon atop the `earthquake_point`
    column in the results in pgAdmin. You should see 19 dots around the city, as in
    [Figure 16-2](#figure16-2) (and you can adjust the underlying map style by clicking
    the layer icon at top right).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在pgAdmin中点击`earthquake_point`列上方的眼睛图标来查看地震位置。你应该会看到塔尔萨市周围的19个点，如[图16-2](#figure16-2)所示（你还可以通过点击右上角的图层图标来调整底图样式）。
- en: Achieving these results required some coding gymnastics that would have been
    unnecessary if the data had arrived in a shapefile or in a typical SQL table.
    Nevertheless, it’s possible to extract meaningful insights from JSON data using
    PostgreSQL’s support for the format. In the last part of the chapter, we’ll cover
    useful PostgreSQL functions for generating and manipulating JSON.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这些结果，需要进行一些编码技巧，如果数据是以Shapefile或典型的SQL表格形式到达，原本是无需做这些的。然而，借助PostgreSQL对JSON格式的支持，依然可以从JSON数据中提取有意义的见解。在本章的最后部分，我们将介绍一些有用的PostgreSQL函数，用于生成和操作JSON。
- en: '![f16002](Images/f16002.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![f16002](Images/f16002.png)'
- en: 'Figure 16-2: Viewing earthquakes near Tulsa, Oklahoma, in pgAdmin'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-2：在pgAdmin中查看塔尔萨附近的地震
- en: Generating and Manipulating JSON
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成和操作JSON
- en: We can use PostgreSQL functions to create JSON from existing rows in a SQL table
    or to modify JSON stored in a table to add, subtract, or change keys and values.
    The PostgreSQL documentation at [https://www.postgresql.org/docs/current/functions-json.html](https://www.postgresql.org/docs/current/functions-json.html)
    lists several dozen JSON-related functions—we’ll work through a few you might
    find handy.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用PostgreSQL函数从SQL表中的现有行创建JSON，或修改存储在表中的JSON，以添加、删除或更改键和值。PostgreSQL文档中列出了几打与JSON相关的函数，网址为[https://www.postgresql.org/docs/current/functions-json.html](https://www.postgresql.org/docs/current/functions-json.html)—我们将学习其中一些你可能会用到的函数。
- en: Turning Query Results into JSON
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将查询结果转换为JSON
- en: Because JSON is primarily a format for sharing data, it’s useful to be able
    to quickly convert the results of a SQL query into JSON for delivery to another
    computer system. [Listing 16-21](#listing16-21) uses the PostgreSQL-specific `to_json()`
    function to turn rows from the `employees` table you made in Chapter 7 into JSON.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JSON 主要是一种用于共享数据的格式，因此能够快速将 SQL 查询的结果转换为 JSON，以便传递给其他计算机系统是非常有用的。[清单 16-21](#listing16-21)使用
    PostgreSQL 特定的 `to_json()` 函数，将你在第 7 章中创建的 `employees` 表的行转换为 JSON 格式。
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 16-21: Turning query results into JSON with `to_json()`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 16-21：使用 `to_json()` 将查询结果转换为 JSON
- en: 'The `to_json()` function does what it says: transforms a supplied SQL value
    to JSON. To convert all values in each row of the `employees` table, we use `to_json()`
    in a `SELECT` 1 and supply the table name as the function’s argument; that returns
    each row as a JSON object with column names as keys:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_json()` 函数执行它所描述的操作：将提供的 SQL 值转换为 JSON。为了将 `employees` 表中每一行的所有值转换为 JSON，我们在
    `SELECT` 语句中使用 `to_json()` 并将表名作为该函数的参数；这样会将每一行作为一个 JSON 对象返回，列名作为键：'
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We can modify our query a few ways to limit which columns to include in the
    results. In [Listing 16-22](#listing16-22), we use a `row()` constructor as the
    argument for `to_json()`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式修改查询，以限制要包含在结果中的列。在[清单 16-22](#listing16-22)中，我们使用 `row()` 构造函数作为
    `to_json()` 的参数。
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 16-22: Specifying columns to convert to JSON'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 16-22：指定要转换为 JSON 的列
- en: 'A `row()` constructor (which is ANSI SQL compliant) builds a row value from
    the arguments passed to it. In this case, we supply the column names `emp_id`
    and `last_name` 1 and place `row()` inside `to_json()`. This syntax returns just
    those columns in the JSON result:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`row()` 构造函数（符合 ANSI SQL 标准）根据传递给它的参数构建一个行值。在此例中，我们提供了列名 `emp_id` 和 `last_name`
    1，并将 `row()` 放在 `to_json()` 内部。此语法将只返回 JSON 结果中的这些列：'
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Notice, however, that the keys are named `f1` and `f2` instead of their source
    column names. That’s a side effect of `row()`, which doesn’t preserve column names
    when it builds the row record. We can set the names of the keys, which is often
    done to keep the names short and reduce JSON file size, improving transfer speeds.
    [Listing 16-23](#listing16-23) shows how via a subquery.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，键名是 `f1` 和 `f2`，而不是它们的源列名。这是 `row()` 的副作用，`row()` 在构建行记录时不会保留列名。我们可以设置键名，通常这样做是为了简化名称并减少
    JSON 文件的大小，从而提高传输速度。[清单 16-23](#listing16-23)展示了通过子查询来实现这一点。
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 16-23: Generating key names with a subquery'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 16-23：通过子查询生成键名
- en: We write a subquery 1 that grabs the columns we want and alias the result as
    `employees`. In the process, we alias a column name 2 to shorten its appearance
    as a key in the JSON.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写一个子查询 1 来获取我们需要的列，并将结果别名为 `employees`。在此过程中，我们将列名 2 别名为一个简短的名称，以便在 JSON
    中作为键使用。
- en: 'The results should look like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应如下所示：
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Finally, [Listing 16-24](#listing16-24) shows how to compile all the rows of
    JSON into a single array of objects. You may want to do this if you’re providing
    this data to another application that will iterate over the array of objects to
    perform a task, such as a calculation, or to render data on a device.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[清单 16-24](#listing16-24)展示了如何将所有 JSON 行编译成一个包含对象的数组。如果你需要将这些数据提供给其他应用程序，供其迭代处理对象数组以执行任务（如计算）或在设备上呈现数据时，可能会需要这样做。
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Listing 16-24: Aggregating the rows and converting to JSON'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 16-24：聚合行并转换为 JSON
- en: 'We wrap `to_json()` in the PostgreSQL-specific `json_agg()` 1 function, which
    aggregates values, including `NULL`, into a JSON array. Its output should look
    like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `to_json()` 包裹在 PostgreSQL 特定的 `json_agg()` 1 函数中，该函数将包括 `NULL` 在内的值聚合成一个
    JSON 数组。其输出应如下所示：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: These are simple examples, but you can build more complex JSON structures using
    subqueries to generate nested objects. We’ll consider one way to do that as part
    of our “Try It Yourself” exercises at the end of the chapter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是简单的示例，但你可以使用子查询构建更复杂的 JSON 结构，从而生成嵌套对象。我们将在本章结尾的“动手实践”练习中考虑一种实现方法。
- en: Adding, Updating, and Deleting Keys and Values
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加、更新和删除键值对
- en: We can add to, update, and delete from JSON with a combination of concatenation
    and PostgreSQL-specific functions. Let’s work through some examples.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过连接和 PostgreSQL 特定的函数来添加、更新和删除 JSON 中的内容。让我们通过一些示例来进行操作。
- en: Adding or Updating a Top-Level Key/Value Pair
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加或更新顶级键值对
- en: 'In [Listing 16-25](#listing16-25), we return to our `films` table and add a
    top-level key/value pair `"studio": "Pixar"` to the film *The Incredibles* using
    two different techniques:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '在[清单 16-25](#listing16-25)中，我们回到`films`表，并使用两种不同的技术为电影*The Incredibles*添加顶级键/值对`"studio":
    "Pixar"`：'
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 16-25: Adding a top-level key/value pair via concatenation'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 16-25：通过拼接添加顶级键/值对
- en: Both examples use `UPDATE` statements to set new values for the `jsonb` column
    `film`. In the first, we use the PostgreSQL concatenation operator `||` 1 to combine
    the existing film JSON with the new key value/pair that we cast to `jsonb`. In
    the second, we use concatenation again but with `jsonb_build_object()`. This function
    takes a series of key and value names as arguments and returns a `jsonb` object,
    letting us concatenate several key/value pairs at a time if we wanted.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 两个示例都使用`UPDATE`语句来为`jsonb`列`film`设置新值。在第一个示例中，我们使用 PostgreSQL 的拼接运算符`||` 1将现有的电影
    JSON与我们转换为`jsonb`的新键值对拼接在一起。在第二个示例中，我们再次使用拼接，但这次使用`jsonb_build_object()`。这个函数接受一系列的键和值作为参数，并返回一个`jsonb`对象，这样我们如果需要的话，可以一次性拼接多个键/值对。
- en: Both statements will insert the new key/value pair if the key doesn’t exist
    in the JSON being concatenated; it will overwrite a key that’s present. There’s
    no functional difference between the two statements, so feel free to use whichever
    you prefer. Note that this behavior is specific to `jsonb`, which doesn’t allow
    duplicate key names.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键在正在拼接的 JSON 中不存在，两条语句都会插入新的键/值对；如果键已经存在，它会覆盖该键。两者之间没有功能上的差异，所以你可以根据个人喜好选择使用其中任何一种。请注意，这种行为是`jsonb`特有的，它不允许重复的键名。
- en: 'If you `SELECT * FROM films;` and double-click the updated data in the `film`
    column, you should see the new key/value pair:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行`SELECT * FROM films;`并双击`film`列中的更新数据，你应该能看到新的键/值对：
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Updating a Value at a Path
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在路径上更新值
- en: 'Currently we have two entries for the `genre` key for *Cinema Paradiso*:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，*Cinema Paradiso*的`genre`键有两个条目：
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: To add a third entry to the array, we use the function `jsonb_set()`, which
    allows us to specify a value to update at a specific JSON path. In [Listing 16-26](#listing16-26),
    we use the `UPDATE` statement and `jsonb_set()` to add the genre `World War II`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要向数组中添加第三个条目，我们使用`jsonb_set()`函数，该函数允许我们在特定的 JSON 路径上指定要更新的值。在[清单 16-26](#listing16-26)中，我们使用`UPDATE`语句和`jsonb_set()`来添加`World
    War II`这一类别。
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Listing 16-26: Adding an array value at a path with `jsonb_set()`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 16-26：使用`jsonb_set()`在路径上添加数组值
- en: In `UPDATE`, we `SET` the value of `film` to the result of `jsonb_set()` and
    use `WHERE` to limit the update to just the row with *Cinema Paradiso*. The function’s
    first argument 1 is the target JSON we want to modify, here `film`. The second
    argument is the path 2 to the array value—the `genre` key. Third, we give the
    new value for `genre`, which we specify as the current value of `genre` concatenated
    with an array 3 with one value, `"World War II"`. That concatenation will produce
    an array with three elements. The final argument is an optional Boolean value
    4 that dictates whether `jsonb_set()` should create the value if it’s not already
    present. It’s redundant here since `genre` already exists; I’ve shown it for reference.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UPDATE`中，我们将`film`的值设置为`jsonb_set()`的结果，并使用`WHERE`限制更新只作用于*Cinema Paradiso*这一行。该函数的第一个参数1是我们想要修改的目标
    JSON，这里是`film`。第二个参数是指向数组值的路径2——`genre`键。第三个参数是我们为`genre`指定的新值，这个新值是当前的`genre`值与一个包含单一值`"World
    War II"`的数组3拼接起来的。这个拼接会生成一个包含三个元素的数组。最后一个参数是一个可选的布尔值4，决定`jsonb_set()`在值不存在时是否创建该值。由于`genre`已经存在，所以这里是多余的；我展示它是为了参考。
- en: 'Run the query and then perform a quick `SELECT` to check the updated JSON.
    You should see the `genre` array including three values: `["romance", "drama",
    "World War II"]`.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 执行查询后，再快速执行一次`SELECT`以检查更新后的 JSON。你应该能看到`genre`数组包含三个值：`["romance", "drama",
    "World War II"]`。
- en: Deleting a Value
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除值
- en: We can remove keys and values from a JSON object by pairing two operators. [Listing
    16-27](#listing16-27) shows two `UPDATE` examples.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过配对两个运算符来从 JSON 对象中删除键和值。[清单 16-27](#listing16-27)展示了两个`UPDATE`示例。
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 16-27: Deleting values from JSON'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 16-27：从 JSON 中删除值
- en: The minus sign 1 acts as a *deletion operator*, removing the key `studio` and
    its value, which we added earlier for *The Incredibles*. Supplying a text string
    after the minus sign indicates we want to remove a key and its value; supplying
    an integer will remove the element at that index.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 减号1作为*删除操作符*，删除了我们之前为*《超人总动员》*添加的`studio`键及其值。在减号后提供一个文本字符串表示我们要删除一个键及其值；提供一个整数则表示删除该索引处的元素。
- en: The `#-` 2 sign is a *path deletion operator* that removes the JSON element
    that exists at a path we specify. The syntax is similar to that of the path extraction
    operators `#>` and `#>>`. Here, we use `{genre, 2}` to indicate the third element
    of the array for `genre` (remember, JSON array indexes begin counting at zero).
    This will remove the value `World War II` that we added earlier to *Cinema Paradiso*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`#-` 2符号是一个*路径删除操作符*，它会删除我们指定路径上的 JSON 元素。语法与路径提取操作符`#>`和`#>>`相似。在这里，我们使用`{genre,
    2}`来表示 `genre` 数组中的第三个元素（记住，JSON 数组的索引从零开始）。这将删除我们之前添加到*《天堂电影院》*中的`World War II`。'
- en: Run both statements and then use `SELECT` to view the altered film JSON. You
    should see both elements removed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这两个语句后，使用`SELECT`查看修改后的电影 JSON。你应该看到这两个元素已被删除。
- en: Using JSON Processing Functions
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSON 处理函数
- en: To finish our JSON studies, we’ll review a selection of PostgreSQL-specific
    functions for processing JSON data, including expanding array values into table
    rows and formatting output. You can find a complete listing of functions in the
    PostgreSQL documentation at [https://www.postgresql.org/docs/current/functions-json.html](https://www.postgresql.org/docs/current/functions-json.html).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的 JSON 学习，我们将回顾一些专门用于处理 JSON 数据的 PostgreSQL 函数，包括将数组值展开为表格行和格式化输出。你可以在
    PostgreSQL 文档中找到完整的函数列表，网址是[https://www.postgresql.org/docs/current/functions-json.html](https://www.postgresql.org/docs/current/functions-json.html)。
- en: Finding the Length of an Array
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找数组的长度
- en: Counting the number of items in an array is a routine programming and analysis
    task. We might, for example, want to know how many actors are stored for each
    film in our JSON. To do this, we can use the `jsonb_array_length()` function in
    [Listing 16-28](#listing16-28).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 计算数组中元素的数量是一个常见的编程和分析任务。例如，我们可能想知道每部电影的演员在 JSON 中存储了多少。为此，我们可以使用`jsonb_array_length()`函数，在[清单
    16-28](#listing16-28)中查看。
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Listing 16-28: Finding the length of an array'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 16-28：查找数组的长度
- en: 'As its only argument, the function 1 takes an expression that extracts the
    value of the `character` key from `film`. Running the query should produce these
    results:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 作为唯一参数，函数1接受一个表达式，该表达式提取`film`中`character`键的值。运行查询应生成以下结果：
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The output correctly shows that we have three characters for *The Incredibles*
    and two for *Cinema Paradiso*. Note there’s a similar `json_array_length()` function
    for the `json` type.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 输出正确显示了*《超人总动员》*有三个角色，*《天堂电影院》*有两个角色。注意，对于 `json` 类型有一个类似的`json_array_length()`函数。
- en: Returning Array Elements as Rows
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回数组元素作为行
- en: The `jsonb_array_elements()` and `jsonb_array_elements_text()` functions convert
    array elements into rows, with one row per element. This is a useful tool for
    data processing. To convert JSON into structured SQL data, for example, we could
    use this function to generate the rows to `INSERT` into a table or to generate
    rows that we can aggregate by grouping and counting.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsonb_array_elements()`和`jsonb_array_elements_text()`函数将数组元素转换为行，每个元素一行。这是数据处理的一个有用工具。例如，要将
    JSON 转换为结构化的 SQL 数据，我们可以使用该函数生成可以插入表格的行，或者生成可以通过分组和计数来聚合的行。'
- en: '[Listing 16-29](#listing16-29) uses both functions to turn the `genre` key’s
    array values into rows. Each function takes a `jsonb` array as an argument. The
    difference between the two is that `jsonb_array_elements()` returns the array
    elements as rows of `jsonb` values, while `jsonb_array_elements_text()` returns
    elements as, you guessed it, `text`.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-29](#listing16-29)使用这两个函数将`genre`键的数组值转换为行。每个函数都接受一个`jsonb`数组作为参数。它们之间的区别在于，`jsonb_array_elements()`将数组元素作为`jsonb`值的行返回，而`jsonb_array_elements_text()`则将元素返回为`text`。'
- en: '[PRE60]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Listing 16-29: Returning array elements as rows'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 16-29：返回数组元素作为行
- en: 'Running the code should produce these results:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码应生成以下结果：
- en: '[PRE61]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: On an array with a simple list of values, that works nicely, but if an array
    contains a collection of JSON objects with their own key/value pairs, like `character`
    in our `film` JSON, we need additional processing to unpack the values first.
    [Listing 16-30](#listing16-30) walks through the process.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个包含简单值列表的数组，处理起来非常简单，但如果数组包含包含自己键值对的 JSON 对象集合，比如我们 `film` JSON 中的 `character`，我们就需要额外的处理步骤，先将值解包。[列表
    16-30](#listing16-30) 详细说明了这一过程。
- en: '[PRE62]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Listing 16-30: Returning key values from each item in an array'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-30：从数组中的每个项返回键值
- en: 'We use `jsonb_array_elements()` to return the elements of the `characters`
    1 array, which should return each JSON object in the array as a row:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `jsonb_array_elements()` 来返回 `characters` 1 数组的元素，这应该会将数组中的每个 JSON 对象作为一行返回：
- en: '[PRE63]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To convert the `name` and `actor` values to columns, we employ a common table
    expression (CTE) as covered in Chapter 13. Our CTE 2 uses `jsonb_array_elements()`
    to generate a simple temporary `characters` table with two columns: the film’s
    `id` and the unpacked array values in a column called `json`. We follow with a
    `SELECT` statement 3 that queries the temporary table, extracting the values of
    `name` and `actor` from the `json` column:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 `name` 和 `actor` 的值转化为列，我们使用了一个常见的表表达式（CTE），如第 13 章所述。我们的 CTE 2 使用 `jsonb_array_elements()`
    来生成一个临时的 `characters` 表，包含两列：电影的 `id` 和解包后的数组值，存储在名为 `json` 的列中。接下来是一个 `SELECT`
    语句 3，它查询该临时表，从 `json` 列中提取 `name` 和 `actor` 的值：
- en: '[PRE64]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Those values are neatly parsed into a standard SQL structure and suitable for
    further analysis using standard SQL.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值被整齐地解析为标准 SQL 结构，适合进一步使用标准 SQL 进行分析。
- en: Wrapping Up
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: JSON is such a ubiquitous format that it’s likely you’ll encounter it often
    in your journey analyzing data. You’ve learned that PostgreSQL easily handles
    loading, indexing, and parsing JSON, but JSON sometimes requires extra steps to
    process that aren’t needed with data handled via standard SQL conventions. As
    with many areas of coding, your decision on whether to make use of JSON will depend
    on your specific circumstances. Now, you’re equipped to understand the context.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是一种非常普及的格式，分析数据的过程中你很可能会经常遇到它。你已经了解到 PostgreSQL 能轻松处理 JSON 的加载、索引和解析，但
    JSON 有时需要额外的处理步骤，这些步骤在使用标准 SQL 约定处理数据时并不需要。和许多编码领域一样，是否使用 JSON 取决于你的具体情况。现在，你已经掌握了理解上下文所需的知识。
- en: JSON itself is a standard, but the data types and the majority of functions
    and syntax in this chapter were PostgreSQL-specific. That’s because the ANSI SQL
    standard leaves it to database vendors to decide how to implement most JSON support.
    If your work involves using Microsoft SQL Server, MySQL, SQLite, or another system,
    consult their documentation. You’ll find many similarities in capabilities even
    if the function names differ.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 本身是一个标准，但本章中的数据类型以及大部分函数和语法是 PostgreSQL 特有的。这是因为 ANSI SQL 标准将大多数 JSON 支持的实现留给了数据库供应商。如果你的工作涉及使用
    Microsoft SQL Server、MySQL、SQLite 或其他系统，请查阅它们的文档。即使函数名称不同，你会发现它们在能力上有很多相似之处。
