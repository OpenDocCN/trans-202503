- en: '![](../images/pg46.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg46.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-09.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-09.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BINARY
    OPERATORS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">二元运算符</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: 'In this chapter, you’ll implement five new operators: addition, subtraction,
    multiplication, division, and the remainder operator. These are all *binary operators*,
    which take two operands. This chapter won’t require any new compiler stages; you’ll
    just extend each of the stages you’ve already written. In the parsing stage, you’ll
    see why recursive descent parsing doesn’t work well for binary expressions. Instead,
    you’ll use a different technique, *precedence climbing*, which will be easier
    to build on in later chapters. Precedence climbing is the last major parsing technique
    you’ll need. Once it’s in place, you’ll be able to add new syntax with relatively
    little effort for the rest of the book. In the assembly generation stage, you’ll
    introduce several assembly instructions that perform binary operations. As usual,
    we’ll start with the lexer.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将实现五种新运算符：加法、减法、乘法、除法和取余运算符。这些都是 *二元运算符*，它们需要两个操作数。本章不需要任何新的编译器阶段；你只需要扩展你已经编写的每个阶段。在解析阶段，你将看到递归下降解析法在处理二元表达式时的局限性。相反，你将使用一种不同的技术，*优先级爬升*，这种技术在后续章节中更容易扩展。优先级爬升是你需要的最后一种主要解析技术。一旦它就位，你将能够以相对较少的工作量为本书的剩余部分添加新的语法。在汇编生成阶段，你将引入几个执行二元运算的汇编指令。和往常一样，我们从词法分析器开始。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>'
- en: 'The lexer needs to recognize four new tokens:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 词法分析器需要识别四个新令牌：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">+</samp> A plus sign, the operator
    for addition
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">+</samp> 加号，加法运算符
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">*</samp> An asterisk, the operator
    for multiplication
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">*</samp> 星号，乘法运算符
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/</samp> A forward slash, the division
    operator
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">/</samp> 斜杠，除法运算符
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%</samp> A percent sign, the remainder
    operator
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%</samp> 百分号，取余运算符
- en: This list doesn’t include the <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    token, because you added it in the last chapter. The lexing stage doesn’t distinguish
    between negation and subtraction; it should produce the same token either way.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表没有包括 <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> 令牌，因为你在上一章已经添加了它。词法分析阶段不会区分取反和减法；无论哪种情况，它都会生成相同的令牌。
- en: You should lex these tokens in the same way as the single-character tokens in
    the previous chapters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该以与前几章中的单字符令牌相同的方式进行词法分析。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解析器</samp>
- en: 'Now you’re going to add another kind of expression to the AST: binary operations.
    [Listing 3-1](chapter3.xhtml#list3-1) shows the updated AST definition.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将向抽象语法树（AST）中添加另一种表达式：二元运算。 [列表 3-1](chapter3.xhtml#list3-1) 显示了更新后的 AST
    定义。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-1: The abstract syntax
    tree with binary operations</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-1：包含二元运算的抽象语法树</samp>
- en: Note that the parser, unlike the lexer, distinguishes between negation and subtraction.
    A <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> token is parsed as either
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp>,
    depending on where it appears in an expression.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，解析器与词法分析器不同，它区分取反和减法。<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    令牌根据它在表达式中的位置，可能被解析为 <samp class="SANS_TheSansMonoCd_W5Regular_11">取反</samp> 或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">减法</samp>。
- en: Also note that the structure of the AST determines the order of evaluation of
    nested expressions. Let’s look at a couple of examples to see how the AST’s structure
    controls the order of operations. The AST in [Figure 3-1](#fig3-1) represents
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3)</samp>, which evaluates
    to 7.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 同样需要注意的是，AST 的结构决定了嵌套表达式的计算顺序。让我们看几个例子，看看 AST 的结构如何控制运算顺序。图 [3-1](#fig3-1) 中的
    AST 表示表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3)</samp>，其结果为 7。
- en: '![](../images/fig3-1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: The AST for 1 +
    (2 * 3) [Description](description-10.xhtml)</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-1：表达式 1 + (2 * 3) 的 AST
    [描述](description-10.xhtml)</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> operation has two
    operands: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">(2
    * 3)</samp>. To evaluate this expression, you calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * 3</samp> first, then add <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    to the result. The AST in [Figure 3-2](#fig3-2), on the other hand, represents
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2) * 3</samp>, which evaluates to
    9.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> 操作有两个操作数：<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3)</samp>。为了评估这个表达式，你首先计算
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp>，然后将 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    加到结果中。另一方面，图 [3-2](#fig3-2) 中的 AST 表示的是表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2)
    * 3</samp>，其结果为 9。
- en: '![](../images/fig3-2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig3-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The AST for (1
    + 2) * 3 [Description](description-11.xhtml)</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-2：表达式 (1 + 2) * 3 的 AST
    [描述](description-11.xhtml)</samp>
- en: In this case, you evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    first, then multiply by <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.
    As a general rule, before evaluating an AST node you need to evaluate both of
    its children. This pattern, where you process a node’s children before the node
    itself, is called *postorder traversal*. Note that any tree data structure can
    be traversed in postorder, not just ASTs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你首先计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>，然后再乘以 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>。一般来说，在评估
    AST 节点之前，你需要先评估它的两个子节点。这个先处理节点的子节点再处理节点本身的模式，称为 *后序遍历*。请注意，任何树形数据结构都可以通过后序遍历进行遍历，不仅仅是
    AST。
- en: Your compiler traverses the AST to generate code, not to evaluate expressions,
    but the idea is the same. When you convert the AST for a binary expression to
    TACKY, you first generate instructions to calculate both operands, then generate
    instructions for the operation itself. (You also used postorder traversal to process
    unary operations in [Chapter 2](chapter2.xhtml).)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你的编译器遍历 AST 生成代码，而不是评估表达式，但原理是一样的。当你将二元表达式的 AST 转换为 TACKY 时，你首先生成计算两个操作数的指令，然后生成操作本身的指令。（在[第
    2 章](chapter2.xhtml)中，你也使用了后序遍历来处理一元操作。）
- en: It’s crucial for your parser to group nested expressions correctly. If you try
    to parse <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3)</samp> but end up with the
    AST from [Figure 3-2](#fig3-2), you’ll ultimately compile the program incorrectly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的解析器来说，正确地分组嵌套表达式至关重要。如果你试图解析 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(2
    * 3)</samp>，但最终得到图 [3-2](#fig3-2) 的 AST，你最终会错误地编译程序。
- en: 'The examples we just looked at used parentheses to explicitly group nested
    expressions. Some expressions, like <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * 3</samp>, don’t parenthesize every nested expression. In those cases, we group
    expressions based on the *precedence* and *associativity* of the operators. Operators
    with higher precedence are evaluated first; since <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    has higher precedence than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>,
    you’d parse <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp> as <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(2
    * 3)</samp>. Associativity tells you how to handle operators at the same precedence
    level. If an operation is *left-associative*, you apply the operator on the left
    first, and if it’s *right-associative*, you apply the operator on the right first.
    For example, since addition and subtraction are left-associative, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    - 3</samp> would be parsed as <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2)
    - 3</samp>. All the new operators in this chapter are left-associative, and there
    are two precedence levels: <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>
    have higher precedence, while <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> have lower precedence.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的例子使用了括号来显式地分组嵌套表达式。有些表达式，比如 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * 3</samp>，并没有为每个嵌套表达式加上括号。在这些情况下，我们会根据运算符的*优先级*和*结合性*来分组表达式。优先级较高的运算符先被求值；由于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> 的优先级高于 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>，因此你会把
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp> 解析为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(2
    * 3)</samp>。结合性告诉你如何处理优先级相同的运算符。如果一个操作是*左结合*的，你会先应用左边的运算符；如果是*右结合*的，你会先应用右边的运算符。例如，由于加法和减法是左结合的，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2 - 3</samp> 会被解析为 <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2)
    - 3</samp>。本章中的所有新运算符都是左结合的，并且有两个优先级级别：<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>
    的优先级较高，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    的优先级较低。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Trouble with
    Recursive Descent Parsing</samp>
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">递归下降解析的难题</samp>
- en: It’s surprisingly tricky to write a recursive descent parser that correctly
    handles operator precedence and associativity. To see why, let’s try adding a
    production rule for binary expressions to the formal grammar. This new rule is
    bolded in the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    in [Listing 3-2](chapter3.xhtml#list3-2).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个正确处理运算符优先级和结合性的递归下降解析器出乎意料地棘手。为了理解原因，先让我们尝试向正式文法中添加一个用于二元表达式的生成规则。这个新规则在[Listing
    3-2](chapter3.xhtml#list3-2)中以粗体标出，定义在<exp>中。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-2: A simple grammar
    rule that doesn’t work for recursive descent parsers</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-2：一个不适用于递归下降解析器的简单语法规则</samp>
- en: A binary expression consists of an expression, then a binary operator, then
    another expression, so <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp> <binop>
    <exp></samp> is the obvious way to define it in the formal grammar. But there
    are a couple of reasons a recursive descent parser can’t use this production rule.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个二元表达式由一个表达式、一个二元操作符和另一个表达式组成，因此<samp class="SANS_TheSansMonoCd_W5Regular_11"><exp>
    <binop> <exp></samp>是定义它的正式语法中的显然方式。但有几个原因使得递归下降解析器不能使用这个产生式规则。
- en: 'First, [Listing 3-2](chapter3.xhtml#list3-2) is *ambiguous*: it allows you
    to parse certain inputs in more than one way. For example, according to this grammar,
    [Figures 3-1](#fig3-1) and [3-2](#fig3-2) are equally valid parses of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * 3</samp>. We need to know the relative precedence of <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> to decide which parse
    to use, but the grammar doesn’t capture that information.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，[列表 3-2](chapter3.xhtml#list3-2)是*模糊的*：它允许你以多种方式解析某些输入。例如，根据这个语法，[图 3-1](#fig3-1)和[图
    3-2](#fig3-2)都是<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp>的有效解析。我们需要知道<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp>的相对优先级，以决定使用哪种解析，但语法并没有包含这些信息。
- en: 'Second, the new production rule is *left-recursive*: the leftmost symbol in
    this production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    is, itself, <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>. You can’t
    apply a left-recursive rule in a recursive descent parser; if you try, you end
    up with unbounded recursion. Imagine trying to implement this production rule
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>. The first symbol
    in this rule is <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>, so
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> would have to process
    that symbol by calling itself recursively. But <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    wouldn’t consume any tokens before the recursive call. It would call itself with
    exactly the same input, so it would never terminate.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，新的产生式规则是*左递归的*：该产生式规则中最左边的符号对于<exp>本身也是<exp>。你不能在递归下降解析器中应用左递归规则；如果尝试这样做，你会遇到无限递归的情况。试想一下，在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>中实现这个产生式规则的情况。该规则中的第一个符号是<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>，因此<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>必须通过递归调用自己来处理该符号。但<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>在递归调用之前不会消费任何标记。它会用完全相同的输入递归调用自己，因此永远不会终止。
- en: We can solve these problems in a couple of ways. If we want a pure recursive
    descent parser, we can refactor the grammar to remove the ambiguity and left recursion.
    Since that approach has some drawbacks, we’ll use precedence climbing, an alternative
    to recursive descent parsing. However, it’s helpful to take a look at the pure
    recursive descent solution first.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式解决这些问题。如果我们想要一个纯粹的递归下降解析器，我们可以重构语法，去除模糊性和左递归。由于这种方法有一些缺点，我们将使用优先级提升，它是递归下降解析的替代方法。然而，首先了解纯递归下降的解决方案是有帮助的。
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Adequate Solution:
    Refactoring the Grammar</samp>'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">充分的解决方案：重构语法</samp>
- en: If we refactor the grammar, we’ll end up with one grammar rule for each precedence
    level, like in [Listing 3-3](chapter3.xhtml#list3-3).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重构语法，我们将得到每个优先级层次的一个语法规则，像在[列表 3-3](chapter3.xhtml#list3-3)中一样。
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-3: A recursive descent–friendly
    grammar for binary operations</samp>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-3：适用于二元操作的递归下降友好型语法</samp>
- en: Using the grammar in [Listing 3-3](chapter3.xhtml#list3-3), there’s only one
    way to parse <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp>, and there’s no left
    recursion. The braces indicate repetition, so a single <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>,
    for example, can contain any number of <samp class="SANS_TheSansMonoCd_W5Regular_11"><term></samp>s.
    It might be a <samp class="SANS_TheSansMonoCd_W5Regular_11"><term></samp>, or
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><term></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><term></samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11"><term>
    - <term></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><term></samp>,
    and so on. The parser then groups that long string of terms into a left-associative
    tree to construct an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    AST node. (Note that we can’t use a rule like <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp>
    ::=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><term> "+" <exp></samp>
    because it results in a right-associative tree. The grammar in [Listing 3-3](chapter3.xhtml#list3-3),
    on the other hand, doesn’t specify the associativity, which allows the parser
    to build either a left-associative or a right-associative tree.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[列表3-3](chapter3.xhtml#list3-3)中的语法，解析<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * 3</samp>只有一种方式，并且没有左递归。大括号表示重复，因此一个单独的<samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>可以包含任意数量的<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><term></samp>。它可能是一个<samp class="SANS_TheSansMonoCd_W5Regular_11"><term></samp>，或者是<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><term></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><term></samp>，或者是<samp class="SANS_TheSansMonoCd_W5Regular_11"><term>
    - <term></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><term></samp>，等等。然后，解析器将这些长串的术语分组成一个左关联的树形结构，以构建一个<exp>
    AST节点。（请注意，我们不能使用像<samp class="SANS_TheSansMonoCd_W5Regular_11"><exp> ::=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><term> "+" <exp></samp>这样的规则，因为它会导致右关联树。而[列表3-3](chapter3.xhtml#list3-3)中的语法则没有指定关联性，允许解析器构建左关联树或右关联树。）
- en: This approach works, but it gets increasingly unwieldy as you add more precedence
    levels. We have three precedence levels now, if you count <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>;
    we’ll add four more when we introduce logical and relational operators in [Chapter
    4](chapter4.xhtml). If we went with this approach, we’d need to add a new symbol
    to the grammar—and a corresponding function to our parser—for each precedence
    level we add. That’s a lot of boilerplate, since the functions to parse the expressions
    at different precedence levels would be almost identical.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是有效的，但随着你添加更多的优先级级别，它会变得越来越笨重。现在我们有三个优先级级别，如果算上<samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>，我们将在[第4章](chapter4.xhtml)引入逻辑和关系运算符时再增加四个。如果我们采用这种方法，每增加一个优先级级别，我们就需要为语法添加一个新的符号，并为我们的解析器添加一个相应的函数。这会产生大量的样板代码，因为不同优先级级别的表达式解析函数几乎是相同的。
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Better Solution:
    Precedence Climbing</samp>'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">更好的解决方案：优先级提升</samp>
- en: 'Precedence climbing is a simpler way to parse binary expressions. It can handle
    production rules like <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp> <binop>
    <exp></samp> while respecting the precedence of each binary operator. In precedence
    climbing, every operator has a numeric precedence level, and <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    takes a minimum precedence level as an argument. This lets you specify the appropriate
    precedence level for whatever subexpression you’re parsing. For example, suppose
    you just saw a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> token, and
    now you want to parse what comes next as the right-hand side of an addition expression:
    you’d specify that it should include only operations that have higher precedence
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>. This solution makes
    it easy to add new operators; you have to assign each new operator a numeric precedence
    level, but you don’t need to make any other changes to your parsing code.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级上升是一种更简单的方式来解析二元表达式。它可以处理像 <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp>
    <binop> <exp></samp> 这样的产生式规则，同时尊重每个二元操作符的优先级。在优先级上升中，每个操作符都有一个数字优先级等级，而 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> 函数接受一个最小优先级等级作为参数。这使得你可以为正在解析的任何子表达式指定适当的优先级等级。例如，假设你刚刚遇到一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> 标记，现在你希望将接下来的部分解析为加法表达式的右侧：你需要指定它应该仅包括优先级高于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> 的操作。这个解决方案使得添加新操作符变得容易；你只需要为每个新操作符分配一个数字优先级等级，但不需要对解析代码进行其他修改。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Mixing Precedence Climbing
    with Recursive Descent</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">将优先级上升与递归下降结合</samp>'
- en: 'We can use precedence climbing to parse binary expressions and still use recursive
    descent to parse other language constructs. Remember that a recursive descent
    parser uses a different function to parse each symbol. That makes it easy to parse
    different symbols with different techniques: we use precedence climbing in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> function and recursive
    descent in the functions that parse all the other symbols. The <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    function will remove tokens from the input stream and return an AST node, just
    like the recursive descent–based parsing functions, but it will use a different
    strategy to get that result.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用优先级上升来解析二元表达式，同时仍然使用递归下降来解析其他语言结构。记住，递归下降解析器使用不同的函数来解析每个符号。这使得我们可以用不同的技术解析不同的符号：我们在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> 函数中使用优先级上升，在解析其他所有符号的函数中使用递归下降。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> 函数将从输入流中移除标记并返回一个 AST
    节点，就像基于递归下降的解析函数一样，但它将使用不同的策略来获得这个结果。
- en: Since we already use recursive descent to parse unary and parenthesized expressions,
    let’s represent those with a separate symbol from binary operations. [Listing
    3-4](chapter3.xhtml#list3-4) shows the resulting grammar, with changes from [Chapter
    2](chapter2.xhtml) bolded.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经使用递归下降来解析一元和带括号的表达式，因此我们用一个与二元操作不同的符号来表示它们。[列表 3-4](chapter3.xhtml#list3-4)展示了结果语法，并且与[第
    2 章](chapter2.xhtml)的变化部分已加粗显示。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-4: The final grammar
    to handle binary operations</samp>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-4：处理二元操作的最终语法</samp>
- en: The symbol we called <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    in [Listing 2-6](chapter2.xhtml#list2-6) is now called <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>;
    it represents a constant, a unary expression, or a parenthesized expression. (We’ll
    keep the name *factor* from [Listing 3-3](chapter3.xhtml#list3-3) because this
    symbol can appear as a factor in a multiplication expression.) We parse a <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp> with the usual recursive
    descent approach. It has almost exactly the same definition that <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    did in [Chapter 2](chapter2.xhtml), except that we now allow binary expressions
    as well as factors inside parentheses. This means <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2)</samp>
    is a factor, because <samp class="SANS_TheSansMonoCd_W5Regular_11">"(" <exp> ")"</samp>
    is a production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>.
    However, <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> is not, because <samp class="SANS_TheSansMonoCd_W5Regular_11"><unop>
    <exp></samp> is not a production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>.
    An <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp> is either a binary
    operation, defined in the obvious way, or a factor. Because the rules for <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>
    refer to each other, the functions to parse those symbols are mutually recursive.
    Those functions both yield <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    AST nodes; <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp> are distinct symbols in the
    grammar, but not different types in the AST.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 2-6](chapter2.xhtml#list2-6)中我们称之为<samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>的符号现在称为<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>；它表示一个常量、一个一元表达式或一个括号表达式。（我们将保留[列表
    3-3](chapter3.xhtml#list3-3)中的名称*factor*，因为这个符号可以出现在乘法表达式中作为因子。）我们用常规的递归下降方法来解析一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>。它的定义几乎与[第二章](chapter2.xhtml)中<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>的定义完全相同，唯一的不同是我们现在允许括号内有二元表达式和因子。这意味着<samp
    class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2)</samp> 是一个因子，因为<samp class="SANS_TheSansMonoCd_W5Regular_11">"("
    <exp> ")"</samp>是<samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>的一个生成规则。然而，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> 不是一个因子，因为<samp class="SANS_TheSansMonoCd_W5Regular_11"><unop>
    <exp></samp> 不是<samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>的生成规则。一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp> 要么是一个按显式方式定义的二元操作，要么是一个因子。因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>的规则相互引用，解析这些符号的函数是相互递归的。这些函数都返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST节点；<samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>是语法中的不同符号，但在AST中并不是不同的类型。
- en: The pseudocode to parse factors is shown in [Listing 3-5](chapter3.xhtml#list3-5).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 解析因子的伪代码如[列表 3-5](chapter3.xhtml#list3-5)所示。
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-5: Parsing a factor</samp>'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-5：解析一个因子</samp>
- en: This looks a lot like the previous chapter’s expression parsing code (shown
    in [Listing 2-7](chapter2.xhtml#list2-7)). The only difference is that we call
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp> where we expect
    a <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp> ❶ and <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    where we expect an <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    ❷; before, we called <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    in both places.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来和上一章的表达式解析代码非常相似（如[列表 2-7](chapter2.xhtml#list2-7)所示）。唯一的不同是，当我们期望一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>时，我们调用<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>
    ❶，而当我们期望一个<samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>时，我们调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> ❷；以前我们在两个地方都调用了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Making Operators Left-Associative</samp>
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">使运算符具有左关联性</samp>
- en: Next, let’s write the new version of <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>.
    We’ll start with a simple version of the function that handles only the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    operators, which are at the same precedence level. This simplified <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    needs to group expressions in a left-associative way, but it doesn’t need to handle
    multiple precedence levels yet.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写新版的<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>。我们将从一个简单版本的函数开始，该函数仅处理相同优先级的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>运算符。这个简化版的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>需要以左结合的方式分组表达式，但目前还不需要处理多个优先级。
- en: In this simple case, we’ll encounter inputs like <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor4</samp>.
    These should always be parsed in a left-associative way to produce expressions
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">((</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">) -</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor4</samp>. As a result,
    the right operand of every expression, including subexpressions, will be a single
    factor. For example, the right operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp>, and
    the right operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">((</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)
    -</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp>.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的情况下，我们会遇到像<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor4</samp>
    这样的输入。这些表达式应该始终以左结合的方式解析，得到像<samp class="SANS_TheSansMonoCd_W5Regular_11">((</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)
    -</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor4</samp> 这样的表达式。结果，每个表达式的右操作数，包括子表达式，都会是一个单一的因子。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>的右操作数是<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp>，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">((</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">) -</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>的右操作数是<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp>。
- en: Since the right operand of an expression is always a single factor, we can parse
    these expressions with the pseudocode in [Listing 3-6](chapter3.xhtml#list3-6).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表达式的右操作数始终是一个单一的因子，我们可以使用[列表 3-6](chapter3.xhtml#list3-6)中的伪代码来解析这些表达式。
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-6: Parsing left-associative
    expressions without considering precedence level</samp>'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 3-6：解析不考虑优先级的左结合表达式</samp>
- en: We start by parsing a single factor ❶, which is either the whole expression
    or the left operand of a larger expression. Next, we check whether the following
    token is a binary operator ❷. If it is, we consume it from the input and convert
    it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">binary_operator</samp> AST
    node. Then, we construct a binary expression ❹ where the left operand is everything
    we’ve parsed so far and the right operand is the next factor, which we get by
    calling <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp> ❸. We
    repeat this process until we see a token other than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> after a factor; this
    means there are no binary expressions left to construct, so we’re done.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从解析一个单一的因子 ❶ 开始，它可以是整个表达式或更大表达式的左操作数。接下来，我们检查接下来的符号是否是二元运算符 ❷。如果是，我们从输入中读取它并将其转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">binary_operator</samp> AST 节点。然后，我们构造一个二元表达式
    ❹，其中左操作数是到目前为止我们解析的内容，右操作数是下一个因子，我们通过调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>
    ❸ 来获取。我们重复这个过程，直到遇到一个不再是 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> 的符号；这意味着没有剩余的二元表达式可以构造，我们就完成了。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dealing with Precedence</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">处理优先级</samp>'
- en: Now let’s extend [Listing 3-6](chapter3.xhtml#list3-6) to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>.
    These operators are also left-associative, but they’re at a higher precedence
    level than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们扩展 [示例 3-6](chapter3.xhtml#list3-6) 来处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>。这些运算符也是左结合的，但它们的优先级比
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    要高。
- en: Once we add these operators, the right operand of every expression can be either
    a single factor or a subexpression involving only the new higher-precedence operators.
    For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> would be parsed as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3))</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. The right operand of the
    whole expression is a single factor, <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>.
    The right operand of the inner subexpression, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(2
    * 3)</samp>, is a product, <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp>.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了这些运算符，每个表达式的右操作数可以是单一的因子，或者是仅包含新高优先级运算符的子表达式。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * 3</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>
    将被解析为 <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3))</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>。整个表达式的右操作数是一个单一的因子，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp>。内层子表达式的右操作数，<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(2
    * 3)</samp>，是一个乘积，<samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp>。
- en: In other words, if the outermost expression is a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> operation, its right
    operand contains only factors and <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>
    operations. But if the outermost expression is itself a <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>
    operation, its right operand must be single factor.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果最外层的表达式是 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-</samp> 操作，它的右操作数只包含因子和 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>
    操作。但如果最外层的表达式本身是 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>
    操作，它的右操作数必须是单一因子。
- en: 'To generalize: when we parse an expression of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">e1
    <op> e2</samp>, all the operators in <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>
    should have higher precedence than <samp class="SANS_TheSansMonoCd_W5Regular_11"><op></samp>.
    We can achieve this by tweaking the code from [Listing 3-6](chapter3.xhtml#list3-6),
    which gives us [Listing 3-7](chapter3.xhtml#list3-7).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一般化来说：当我们解析形式为 <samp class="SANS_TheSansMonoCd_W5Regular_11">e1 <op> e2</samp>
    的表达式时，<samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp> 中的所有运算符应具有高于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><op></samp> 的优先级。我们可以通过调整 [列表 3-6](chapter3.xhtml#list3-6)
    中的代码来实现这一点，得到 [列表 3-7](chapter3.xhtml#list3-7)。
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-7: Parsing left-associative
    expressions with precedence climbing</samp>'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-7：使用优先级爬升解析左结合表达式</samp>
- en: This pseudocode is our entire precedence climbing algorithm. The <samp class="SANS_TheSansMonoCd_W5Regular_11">min_prec</samp>
    argument lets us state that all operators in the subexpression we’re currently
    parsing need to exceed some precedence level. For example, we could include only
    operators that have higher precedence than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>.
    We enforce this by comparing the precedence of the current operator to <samp class="SANS_TheSansMonoCd_W5Regular_11">min_prec</samp>
    at each iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop; we exclude the operator and anything that follows it from the current expression
    if its precedence is too low. Then, when we parse the right-hand side of an operation,
    we set the minimum precedence higher than the precedence of the current operator.
    This guarantees that higher-precedence operators will be evaluated first. Since
    operators at the same precedence level as the current operator won’t be included
    in the right-hand expression, the resulting AST will be left-associative.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个伪代码是我们整个优先级爬升算法的实现。<samp class="SANS_TheSansMonoCd_W5Regular_11">min_prec</samp>
    参数让我们能够声明当前解析的子表达式中的所有运算符都需要超过某个优先级水平。例如，我们可以只包含优先级高于 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    的运算符。我们通过在每次 <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环的迭代中将当前运算符的优先级与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">min_prec</samp> 进行比较来强制执行这一点；如果运算符的优先级过低，我们将排除该运算符及其后续部分。然后，当我们解析操作的右侧时，我们将最小优先级设置为高于当前运算符的优先级。这保证了优先级更高的运算符会优先计算。由于与当前运算符具有相同优先级的运算符不会被包含在右侧表达式中，因此生成的抽象语法树（AST）将是左结合的。
- en: When you call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    from any other function (including from <samp class="SANS_TheSansMonoCd_W5Regular_11">parse
    _factor</samp>, to handle parenthesized expressions), start with a minimum precedence
    of zero so the result includes operators at every precedence level.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从其他函数调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>（包括从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>，用于处理带括号的表达式）时，从最小优先级为零开始，这样结果将包括所有优先级水平的运算符。
- en: The code in [Listing 3-7](chapter3.xhtml#list3-7) requires us to assign every
    binary operator a precedence value. [Table 3-1](chapter3.xhtml#tab3-1) shows the
    values I’ve assigned.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-7](chapter3.xhtml#list3-7) 中的代码要求我们为每个二元运算符分配一个优先级值。[表 3-1](chapter3.xhtml#tab3-1)
    显示了我分配的值。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp> <samp class="SANS_Futura_Std_Book_11">Precedence
    Values of Binary Operators</samp>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-1：</samp> <samp class="SANS_Futura_Std_Book_11">二元运算符的优先级值</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp>
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">操作符</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">优先级</samp>
    |'
- en: '| --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
- en: The exact precedence values don’t matter, as long as higher-precedence operators
    have higher values. The numbers in [Table 3-1](chapter3.xhtml#tab3-1) give us
    plenty of room to add lower-precedence operators later on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 精确的优先级值并不重要，只要高优先级操作符的值大于低优先级操作符的值即可。[表 3-1](chapter3.xhtml#tab3-1)中的数字为我们提供了足够的空间，以便后续添加低优先级操作符。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Precedence Climbing
    in Action</samp>
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">优先级爬升示例</samp>
- en: 'Let’s walk through an example where we parse the following expression:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来解析以下表达式：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code snippets trace the execution of the precedence climbing
    code from [Listing 3-7](chapter3.xhtml#list3-7) as it parses this expression.
    We start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">parse _exp</samp>
    on the whole expression with <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    as the minimum precedence argument:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段追踪了[示例 3-7](chapter3.xhtml#list3-7)中的优先级爬升代码在解析该表达式时的执行过程。我们从调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse _exp</samp> 开始，传入 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    作为最小优先级参数：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, inside <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>,
    we parse the first factor:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> 内部，我们解析第一个因子：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This first call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>
    parses the token <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, returning
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(1)</samp>. Next, we peek
    at the token that follows, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>.
    This token is a binary operator with a precedence greater than zero, so we enter
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp> 解析令牌
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(1)</samp>。接下来，我们查看后续的令牌
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>。该令牌是一个二元操作符，优先级大于零，因此我们进入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环。
- en: 'The first iteration of the loop looks like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的第一次迭代如下所示：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Inside the loop, <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_binop</samp>
    consumes <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> from
    the input and converts it to an AST node, <samp class="SANS_TheSansMonoCd_W5Regular_11">Multiply</samp>,
    which leaves <samp class="SANS_TheSansMonoCd_W5Regular_11">2 - 3 * (4</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>.
    Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> recursively
    to get the right-hand side of this product. Since the precedence of <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    is 50, the second argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">51</samp>. In the recursive call,
    we again get the next factor (<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>)
    and the token that follows it (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>).
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> token is a binary operator,
    but its precedence is only 45; it doesn’t meet the minimum precedence of 51, so
    we don’t enter the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop. Instead, we return <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(2)</samp>.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_binop</samp>从输入中消费<samp
    class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp>并将其转换为AST节点<samp class="SANS_TheSansMonoCd_W5Regular_11">Multiply</samp>，这时剩下的表达式为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2 - 3 * (4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>。接下来，我们递归调用<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>以获取该乘积的右侧部分。由于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp>的优先级为50，传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>的第二个参数为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">51</samp>。在递归调用中，我们再次得到下一个因子(<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>)和紧随其后的令牌(<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-</samp>)。<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>令牌是一个二元运算符，但它的优先级仅为45；它未达到51的最小优先级，因此我们不会进入<samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环。相反，我们返回<samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(2)</samp>。
- en: 'Back in the outer call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>,
    we construct a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> AST
    node for <samp class="SANS_TheSansMonoCd_W5Regular_11">1 * 2</samp> from the values
    we’ve parsed so far. Then, we check the next token to see whether we have more
    subexpressions to process. The next token is <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>;
    we peeked at it, but didn’t remove it from the input, inside the recursive call
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>. Because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-</samp> is a binary operator, and it
    exceeds our minimum precedence of zero, we jump back to the beginning of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to parse the next subexpression:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 回到外层调用的<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>中，我们为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1 * 2</samp>构造一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    AST节点，基于我们迄今解析的值。然后，我们检查下一个令牌，看看是否还有子表达式需要处理。下一个令牌是<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>；我们已经查看了它，但并没有从输入中移除它，而是在递归调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>时。由于<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>是一个二元运算符，并且它的优先级超过了我们的最小优先级0，我们跳回到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环的开始，以解析下一个子表达式：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second time through the loop, we consume <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    from the input and make a recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>.
    This time, because the precedence of <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>
    is 45, the second argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">46</samp>.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次进入循环时，我们从输入中消费<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>并递归调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>。这次，由于<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>的优先级为45，传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>的第二个参数为<samp class="SANS_TheSansMonoCd_W5Regular_11">46</samp>。
- en: Following our usual routine, we get the next factor (<samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>)
    and the next token (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>). Since
    the precedence of <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> exceeds
    the minimum precedence, we need to parse another subexpression. We consume <samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp>, leaving <samp class="SANS_TheSansMonoCd_W5Regular_11">(4</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>,
    then make yet another recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们通常的流程，我们获取下一个因子（<samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>）和下一个标记（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*</samp>）。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    的优先级超过最小优先级，我们需要解析另一个子表达式。我们消耗了 <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>，剩下
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>，然后再次递归调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>。
- en: In this call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>,
    we start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>
    as usual. This call consumes the rest of our input and returns the AST node for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>. To handle that parenthesized
    expression, <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>
    needs to recursively call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    with the minimum precedence reset to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    but we won’t step through that here. At this point, there are no tokens left in
    our expression. Let’s assume this is a valid C program and the next token is a
    semicolon (<samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>). Since the
    next token isn’t a binary operator, we exit the loop and return the expression
    we got from <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次对 <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> 的调用中，我们像往常一样首先调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>。这个调用消耗了剩余的输入，并返回了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> 的 AST 节点。为了处理那个带括号的表达式，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp> 需要递归调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>，并将最小优先级重置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，但我们这里不详细讲解。此时，我们的表达式中已经没有剩余的标记。假设这是一个有效的
    C 程序，下一个标记是分号（<samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>）。由于下一个标记不是二元操作符，我们退出循环，并返回从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp> 得到的表达式。
- en: At the next level up, we construct the AST node for <samp class="SANS_TheSansMonoCd_W5Regular_11">3
    * (4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>
    from the subexpressions we’ve processed in this call. Once again, we peek at the
    next token, see that it isn’t a binary operator, and return.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高一级，我们根据此次调用中处理过的子表达式构建 <samp class="SANS_TheSansMonoCd_W5Regular_11">3 *
    (4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>
    的抽象语法树（AST）节点。再次地，我们查看下一个标记，发现它不是二元操作符，然后返回。
- en: Finally, back in the original call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>,
    we construct the final expression from the left operand that we constructed in
    the first loop iteration (<samp class="SANS_TheSansMonoCd_W5Regular_11">1 * 2</samp>),
    the current value of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>), and the right operand
    that was just returned from the recursive call (<samp class="SANS_TheSansMonoCd_W5Regular_11">3
    * (4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>).
    For the last time, we check the next token, see that it isn’t a binary operator,
    and return.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，回到原始的对 <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> 的调用，我们从第一次循环迭代中构建的左操作数（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">1 * 2</samp>）、当前的 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp>（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-</samp>）以及刚从递归调用中返回的右操作数（<samp class="SANS_TheSansMonoCd_W5Regular_11">3
    * (4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>）构建最终的表达式。最后，我们检查下一个标记，发现它不是二元操作符，然后返回。
- en: Now that you’ve seen how to parse binary expressions with precedence climbing,
    you’re ready to extend your parser. Remember to use precedence climbing to parse
    binary expressions and recursive descent to parse all the other symbols in the
    grammar, including factors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何使用优先级递增法解析二元表达式，你可以开始扩展你的解析器了。记住，使用优先级递增法解析二元表达式，并使用递归下降法解析语法中的其他符号，包括因子。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">TACKY 生成</samp>'
- en: Next, let’s update the stage that converts the AST to TACKY. We’ll start by
    adding binary operations to TACKY. [Listing 3-8](chapter3.xhtml#list3-8) defines
    the updated TACKY IR, with this chapter’s additions bolded.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更新将抽象语法树（AST）转换为 TACKY 的阶段。我们将从向 TACKY 添加二元操作开始。[清单 3-8](chapter3.xhtml#list3-8)
    定义了更新后的 TACKY 中间表示（IR），本章新增的内容已加粗。
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-8: Adding binary
    operations to TACKY</samp>'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 3-8：向 TACKY 添加二元操作</samp>
- en: We’ve added the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    instruction to represent binary operations, and we’ve defined all the possible
    operators. Like unary operations, binary operations in TACKY operate on constants
    and variables, not nested subexpressions. As [Listing 3-9](chapter3.xhtml#list3-9)
    illustrates, we can turn a binary expression into a sequence of TACKY instructions
    in basically the same way we handled unary expressions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> 指令来表示二元操作，并且我们定义了所有可能的运算符。像一元操作一样，TACKY
    中的二元操作是作用于常量和变量，而不是嵌套子表达式。如[清单 3-9](chapter3.xhtml#list3-9)所示，我们可以通过与处理一元表达式基本相同的方式，将二元表达式转化为一系列
    TACKY 指令。
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-9: Converting a binary
    expression to TACKY</samp>'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 3-9：将二元表达式转换为 TACKY</samp>
- en: We emit the TACKY instructions to evaluate each operand, then emit the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instruction that uses those
    source values. The only difference from how we handled unary expressions is that
    we’re processing two operands instead of one.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成 TACKY 指令来求值每个操作数，然后生成使用这些源值的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    指令。与处理一元表达式时的唯一不同之处在于，我们现在处理的是两个操作数，而不是一个。
- en: 'Before we move on to assembly generation, I want to make a slightly tangential
    point. The TACKY we emit in [Listing 3-9](chapter3.xhtml#list3-9) evaluates a
    binary expression’s first operand before the second, but it’s just as correct
    to evaluate the second operand before the first. According to the C standard,
    subexpressions of the same operation are usually *unsequenced*; that is, they
    can be evaluated in any order. If two subexpressions would be unsequenced, but
    either or both of them is a function call, they’re *indeterminately sequenced*,
    meaning that either one can execute first, but they can’t interleave. In many
    cases, unsequenced and indeterminately sequenced evaluations can lead to unpredictable
    results. Consider the following program, which includes two indeterminately sequenced
    calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行汇编生成之前，我想稍微提一下一个相关的点。在[清单 3-9](chapter3.xhtml#list3-9)中，我们生成的 TACKY 会先计算二元表达式的第一个操作数，再计算第二个操作数，但其实也可以先计算第二个操作数再计算第一个。根据
    C 标准，同一操作的子表达式通常是*无序的*；也就是说，它们可以按任意顺序进行求值。如果两个子表达式是无序的，但其中一个或两个是函数调用，那么它们是*不确定顺序的*，意味着它们可以按任意顺序执行，但不能交错执行。在许多情况下，无序和不确定顺序的求值会导致不可预测的结果。考虑以下程序，其中包含两个不确定顺序的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> 调用：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You could compile this program with a C standard–compliant compiler, run it,
    and get either of these outputs:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用符合 C 标准的编译器编译这个程序，运行它，并得到以下任一输出：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are a few exceptions where we must evaluate the first operand first:
    the logical <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operators, which we’ll cover
    in [Chapter 4](chapter4.xhtml); the conditional <samp class="SANS_TheSansMonoCd_W5Regular_11">?:</samp>
    operator, which we’ll cover in [Chapter 6](chapter6.xhtml); and the comma operator,
    which we won’t implement. For a more in-depth discussion of the order in which
    expressions are evaluated, see the “Order of Evaluation” page on cppreference.com,
    the C/C++ reference wiki (*[https://<wbr>en<wbr>.cppreference<wbr>.com<wbr>/w<wbr>/c<wbr>/language<wbr>/eval<wbr>_order](https://en.cppreference.com/w/c/language/eval_order)*).
    If you’re curious about where all this is laid out in the C standard itself, see
    section 5.1.2.3 (which covers the general rules for evaluation order and defines
    the terms *unsequenced* and *indeterminately sequenced*) and section 6.5, paragraphs
    1–3 (which address the evaluation order for expression operands in particular).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些特殊情况下，我们必须先评估第一个操作数：逻辑运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>，我们将在[第4章](chapter4.xhtml)中讲解；条件运算符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?:</samp>，我们将在[第6章](chapter6.xhtml)中讲解；以及逗号运算符，我们不会实现。关于表达式求值顺序的更深入讨论，请参阅cppreference.com网站上的“Order
    of Evaluation”页面，这是C/C++的参考维基 (*[https://<wbr>en<wbr>.cppreference<wbr>.com<wbr>/w<wbr>/c<wbr>/language<wbr>/eval<wbr>_order](https://en.cppreference.com/w/c/language/eval_order)*)。如果你对C标准中相关内容感兴趣，请参阅第5.1.2.3节（该节涵盖了求值顺序的一般规则，并定义了*未排序*和*不确定排序*的术语）以及第6.5节的第1到第3段（特别讲解了表达式操作数的求值顺序）。
- en: 'Unsequenced operations are one example of a broader pattern: there are a lot
    of circumstances where the C standard doesn’t specify exactly how programs should
    behave. We’ll see more examples of this throughout the book. By leaving some details
    about program behavior unspecified, the C standard puts a lot of power in the
    hands of compiler writers, allowing them to write sophisticated compiler optimizations.
    But there’s an obvious trade-off: it’s easy for programmers to write code that
    might not behave the way they expect.  ### <samp class="SANS_Futura_Std_Bold_B_11">Assembly
    Generation</samp>'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 未排序的操作是一个更广泛模式的例子：有很多情况下C标准没有明确规定程序应该如何行为。我们将在本书中看到更多的例子。通过对程序行为的某些细节不做具体规定，C标准将很多权力交给了编译器开发者，允许他们编写复杂的编译器优化。但这也有明显的权衡：程序员很容易写出可能与预期行为不符的代码。###
    <samp class="SANS_Futura_Std_Bold_B_11">汇编生成</samp>
- en: The next step is converting TACKY into assembly. We’ll need several new assembly
    instructions to handle addition, subtraction, multiplication, division, and the
    remainder operation. Let’s talk through how to use these instructions; then we’ll
    make the necessary updates to each pass in the assembly generation stage.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将TACKY转换为汇编代码。我们需要几个新的汇编指令来处理加法、减法、乘法、除法和余数运算。我们先讨论如何使用这些指令；然后我们将在汇编生成阶段对每一轮进行必要的更新。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Doing Arithmetic
    in Assembly</samp>
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在汇编中进行算术运算</samp>
- en: 'The instructions for addition, subtraction, and multiplication all take the
    form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">src</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp>,
    where:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 加法、减法和乘法的指令格式都是 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">src</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp>，其中：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">op</samp> is an instruction.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">op</samp> 是一条指令。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">src</samp> is an immediate
    value, register, or memory address.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">src</samp> 是立即数、寄存器或内存地址。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">dst</samp> is a register
    or memory address.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">dst</samp> 是寄存器或内存地址。
- en: Each of these instructions applies <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">src</samp>, storing the result
    in <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp>. The instructions
    for addition, subtraction, and multiplication are <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>,
    respectively. As usual, these instructions take an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    suffix if their operands are 32 bits and a <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    suffix if their operands are 64 bits. [Table 3-2](chapter3.xhtml#tab3-2) shows
    an example of each instruction.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每条指令将 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp> 应用到 <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">src</samp>
    上，并将结果存储到 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp> 中。加法、减法和乘法的指令分别是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>。像往常一样，如果操作数是 32 位，则这些指令会带有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> 后缀；如果操作数是 64 位，则会带有 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">q</samp> 后缀。[表 3-2](chapter3.xhtml#tab3-2)
    展示了每条指令的示例。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp> <samp class="SANS_Futura_Std_Book_11">Assembly
    Instructions for Addition, Subtraction, and Multiplication</samp>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-2：</samp> <samp class="SANS_Futura_Std_Book_11">加法、减法和乘法的汇编指令</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Meaning</samp>
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">含义</samp>
    |'
- en: '| --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">addl $2, %eax</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">eax = eax + 2</samp> |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">addl $2, %eax</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">eax = eax + 2</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">subl $2, %eax</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">eax = eax - 2</samp> |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">subl $2, %eax</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">eax = eax - 2</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">imull {@}$2, %eax</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">eax = eax * 2</samp> |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">imull {@}$2, %eax</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">eax = eax * 2</samp> |'
- en: Note that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp>
    is the *first* operand in the corresponding mathematical expression, so <samp
    class="SANS_TheSansMonoCd_W5Regular_11">subl a, b</samp> computes <samp class="SANS_TheSansMonoCd_W5Regular_11">b
    - a</samp>, not <samp class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp>.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp> 是对应数学表达式中的*第一个*操作数，因此
    <samp class="SANS_TheSansMonoCd_W5Regular_11">subl a, b</samp> 计算的是 <samp class="SANS_TheSansMonoCd_W5Regular_11">b
    - a</samp>，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp>。
- en: These instructions are pretty easy to use and understand. If we lived in a perfect
    world, we could perform division in exactly the same way. But we don’t, so we’re
    stuck with the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令非常容易使用和理解。如果我们生活在一个完美的世界里，我们就能以完全相同的方式执行除法操作。但事实并非如此，因此我们只能使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    指令。
- en: 'We use <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> to implement
    the division and remainder operations. Even though you need two numbers to perform
    division, it takes a single operand: the divisor. (In <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    / b</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is the dividend
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is the divisor.) This
    operand can’t be an immediate value. In its 32-bit form, <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    gets the other value it needs, the dividend, from the EDX and EAX registers, which
    it treats as a single 64-bit value. It gets the most significant 32 bits from
    EDX and the least significant 32 bits from EAX. Unlike the other arithmetic instructions,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> produces two results:
    the quotient and the remainder. It stores the quotient in EAX and the remainder
    in EDX. (The 64-bit version of <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>,
    written as <samp class="SANS_TheSansMonoCd_W5Regular_11">idivq</samp>, uses RDX
    and RAX as the dividend instead of EDX and EAX.)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>来实现除法和余数操作。尽管除法操作需要两个数字，但它只需要一个操作数：除数。（在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a / b</samp>中，<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>是被除数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>是除数。）这个操作数不能是立即数。在其32位形式中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>从EDX和EAX寄存器中获取它需要的另一个值——被除数，并将其视为一个64位的值。它从EDX获取最重要的32位，从EAX获取最不重要的32位。与其他算术指令不同，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>会产生两个结果：商和余数。它将商存储在EAX中，将余数存储在EDX中。（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>的64位版本，写作<samp class="SANS_TheSansMonoCd_W5Regular_11">idivq</samp>，使用RDX和RAX作为被除数，而不是EDX和EAX。）
- en: To calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b</samp> with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>, we need to take <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>—which will be either a 32-bit
    immediate value or a 32-bit value stored in memory—and turn it into a 64-bit value
    spanning both EDX and EAX. Whenever we need to convert a signed integer to a wider
    format, we use an operation called *sign extension*. This operation fills the
    upper 32 bits of the new 64-bit value with the sign bit of the original 32-bit
    value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用<samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>计算<samp class="SANS_TheSansMonoCd_W5Regular_11">a
    / b</samp>，我们需要将<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>——它可以是一个32位的立即数或者一个存储在内存中的32位值——转化为一个跨越EDX和EAX的64位值。每当我们需要将一个有符号整数转换为更宽的格式时，我们会使用一个叫做*符号扩展*的操作。这个操作将新64位值的高32位用原32位值的符号位填充。
- en: Sign extending a positive number just pads the upper 32 bits (4 bytes) with
    zeros. Sign extending the binary representation of 3, for example, turns
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展正数的符号时，只需要用零填充高32位（4个字节）。例如，将3的二进制表示进行符号扩展后变为：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'into:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 变为：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Both representations have the value 3; the second one just has more leading
    zeros. To sign extend a negative number, we fill the upper 4 bytes with ones.
    This transforms the binary representation of –3, for example, from
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 两种表示方式的值都是3；第二种只是有更多的前导零。为了扩展负数的符号，我们用1填充高4个字节。例如，将负数-3的二进制表示从
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'into:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 变为：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Thanks to the magic of two’s complement, the value of both of these binary numbers
    is –3\. (If you’re not clear on how this works, check out [Chapter 2](chapter2.xhtml)’s
    “Additional Resources” section on [page 45](chapter2.xhtml#pg_45).)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了二进制补码的神奇，这两个二进制数的值都是-3。（如果你不清楚如何操作，查看[第2章](chapter2.xhtml)中“附加资源”部分，详见[第45页](chapter2.xhtml#pg_45)。）
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp> instruction does
    exactly what we want: it sign extends the value from EAX into EDX. If the number
    in EAX is positive, this instruction sets EDX to all zeros. If EAX is negative,
    it sets EDX to all ones. Putting it all together, as an example, the following
    assembly computes both <samp class="SANS_TheSansMonoCd_W5Regular_11">9 / 2</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">9 % 2</samp>:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>指令正是我们想要的：它将EAX中的值符号扩展到EDX。如果EAX中的数是正数，这条指令将EDX置为全零。如果EAX是负数，它将EDX置为全1。综合来看，作为一个例子，以下汇编代码计算了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">9 / 2</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">9
    % 2</samp>：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This stores the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">9 /
    2</samp>, the quotient, in EAX. It stores the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">9
    % 2</samp>, the remainder, in EDX.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 <samp class="SANS_TheSansMonoCd_W5Regular_11">9 / 2</samp> 的结果，即商，存储在 EAX
    中。它将把 <samp class="SANS_TheSansMonoCd_W5Regular_11">9 % 2</samp> 的结果，即余数，存储在 EDX
    中。
- en: 'We’ve covered all the new instructions we’ll need in this chapter: <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>.
    Next, we’ll add these instructions to the assembly AST and update the conversion
    from TACKY to assembly.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了本章需要的所有新指令：<samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>。接下来，我们将把这些指令添加到汇编
    AST 中，并更新从 TACKY 到汇编的转换。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Binary
    Operations to Assembly</samp>
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将二元运算转换为汇编</samp>
- en: '[Listing 3-10](chapter3.xhtml#list3-10) defines the updated assembly AST, with
    this chapter’s additions bolded.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-10](chapter3.xhtml#list3-10) 定义了更新后的汇编 AST，本章新增的部分以粗体显示。'
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-10: The assembly
    AST with binary operators</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-10：带有二元运算符的汇编 AST</samp>
- en: Since the addition, subtraction, and multiplication instructions take the same
    form, we’ll represent all of them using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">instruction</samp>
    node. We’ll also add constructors for the new <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp> instructions. Finally,
    we’ll add the EDX and R11 registers to the AST definition; we need EDX for division
    and R11 for the instruction fix-up pass.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加法、减法和乘法指令形式相同，我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    构造器表示它们，适用于 <samp class="SANS_TheSansMonoCd_W5Regular_11">instruction</samp> 节点。我们还将为新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>
    指令添加构造器。最后，我们将把 EDX 和 R11 寄存器添加到 AST 定义中；我们需要 EDX 用于除法，R11 用于指令修正过程。
- en: Now we need to convert the new binary operations from TACKY to assembly. For
    addition, subtraction, and multiplication, we convert a single TACKY instruction
    into two assembly instructions. That is, we convert
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将新的二元操作从 TACKY 转换为汇编。对于加法、减法和乘法，我们将单个 TACKY 指令转换为两个汇编指令。也就是说，我们进行转换
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'to:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Division is a little more complicated; we move the first operand into EAX, sign
    extend it with <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>, issue
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction, and
    then move the result from EAX to the destination. So, we convert
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除法稍微复杂一些；我们将第一个操作数移入 EAX，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>
    扩展其符号，发出 <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> 指令，然后将结果从 EAX
    移动到目标位置。所以，我们进行转换
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'to:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The remainder operation looks exactly the same, except that we ultimately want
    to retrieve the remainder from EDX instead of retrieving the quotient from EAX.
    We therefore convert
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 余数操作完全相同，唯一不同的是，我们最终希望从 EDX 中获取余数，而不是从 EAX 中获取商。因此，我们进行转换
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'to:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction can’t
    operate on immediate values, so the assembly instructions for division and remainder
    won’t be valid if <samp class="SANS_TheSansMonoCd_W5Regular_11">src2</samp> is
    a constant. That’s okay; we’ll fix this problem during the instruction fix-up
    pass. [Tables 3-3](chapter3.xhtml#tab3-3) through [3-6](chapter3.xhtml#tab3-6)
    summarize the conversion from TACKY to assembly, with new and changed constructs
    bolded.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> 指令不能作用于立即数，因此如果 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">src2</samp> 是常数，那么除法和余数的汇编指令将无效。没关系；我们将在指令修正过程中解决这个问题。[表
    3-3](chapter3.xhtml#tab3-3) 到 [3-6](chapter3.xhtml#tab3-6) 总结了从 TACKY 到汇编的转换，其中新增和更改的构造以粗体显示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-3：</samp> <samp class="SANS_Futura_Std_Book_11">将顶层
    TACKY 构造转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 顶层构造</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编顶层构造</samp>
    |'
- en: '| --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-4:</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 指令转换为汇编语言</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp>
    |'
- en: '| --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov(val, Reg(AX)) Ret</samp> |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov(val, Reg(AX)) Ret</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator, src,
    dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst) Unary(unary_operator,
    dst)</samp> |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator, src,
    dst)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst) Unary(unary_operator,
    dst)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Divide, src1, src2, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(src1, Reg(AX)) Cdq'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Divide, src1, src2, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(src1, Reg(AX)) Cdq'
- en: Idiv(src2)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Idiv(src2)
- en: Mov(Reg(AX), dst)</samp> |
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Mov(Reg(AX), dst)</samp> |
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Remainder, src1, src2,
    dst)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(src1, Reg(AX))
    Cdq'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Remainder, src1, src2,
    dst)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(src1, Reg(AX))
    Cdq'
- en: Idiv(src2)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Idiv(src2)
- en: Mov(Reg(DX), dst)</samp> |
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Mov(Reg(DX), dst)</samp> |
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(binary_operator, src1,
    src2, dst)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(src1, dst)
    Binary(binary_operator, src2, dst)</samp> |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(binary_operator, src1,
    src2, dst)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(src1, dst)
    Binary(binary_operator, src2, dst)</samp> |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-5:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Arithmetic Operators to Assembly</samp>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-5:</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 算术运算符转换为汇编语言</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operator</samp> |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 运算符</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编运算符</samp>
    |'
- en: '| --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Complement</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Complement</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Neg</samp>
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Neg</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Add</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Add</samp>
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Add</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Add</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Subtract</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Sub</samp>
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Subtract</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Sub</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Multiply</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mult</samp>
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Multiply</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mult</samp>
    |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-6:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-6:</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 操作数转换为汇编语言</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operand</samp> |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 操作数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作数</samp>
    |'
- en: '| --- | --- |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(int)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(int)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Var(identifier)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Pseudo(identifier)</samp> |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Var(identifier)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Pseudo(identifier)</samp> |'
- en: 'Note that [Table 3-4](chapter3.xhtml#tab3-4) includes three rows for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> TACKY instruction: one for
    division, one for the remainder operation, and one for everything else.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[表 3-4](chapter3.xhtml#tab3-4) 包含了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    TACKY 指令的三行：一行用于除法，一行用于余数操作，另一行用于其他所有操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters</samp>
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">替换伪寄存器</samp>
- en: Update this pass to replace pseudoregisters in the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp> instructions. You
    should treat them like the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> instructions. When
    you see a pseudoregister in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp> instruction, replace
    it with the corresponding stack address. If the pseudoregister hasn’t been assigned
    to a stack address yet, assign it to the next available 4-byte address.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 更新此过程，以替换新 <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp> 指令中的伪寄存器。你应该像处理现有的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> 指令一样处理它们。当你在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp>
    指令中看到伪寄存器时，用相应的堆栈地址替换它。如果该伪寄存器尚未分配到堆栈地址，则将其分配到下一个可用的 4 字节地址。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up the idiv,
    add, sub, and imul Instructions</samp>
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">修复 idiv、add、sub 和
    imul 指令</samp>
- en: In the last compiler pass before emitting the final program, we rewrite any
    invalid instructions that we produced in earlier stages. We need to add a few
    more rewrite rules here. First, we need to fix <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    instructions that take constant operands. Whenever <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    needs to operate on a constant, we copy that constant into our scratch register
    first. For instance, we rewrite
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成最终程序的最后一次编译过程中，我们重写之前阶段产生的任何无效指令。我们需要在这里添加一些更多的重写规则。首先，我们需要修复那些采用常量操作数的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> 指令。每当 <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>
    需要操作一个常量时，我们首先将该常量复制到我们的临时寄存器中。例如，我们重写
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'as:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>
    instructions, like <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, can’t
    use memory addresses as both the source and destination operands. We rewrite them
    in the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, so
    that
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>
    指令，像 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 一样，不能同时使用内存地址作为源操作数和目标操作数。我们像重写
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 一样重写它们，因此
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'becomes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 变为：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp> instruction can’t
    use a memory address as its destination, regardless of its source operand. To
    fix an instruction’s destination operand, we use the R11 register instead of R10\.
    So, to fix <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>, we load
    the destination into R11, multiply it by the source operand, and then store the
    result back to the destination address. In other words, the instruction
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp> 指令不能使用内存地址作为目标，无论它的源操作数是什么。为了修复指令的目标操作数，我们使用
    R11 寄存器代替 R10。因此，为了修复 <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>，我们将目标加载到
    R11 中，将其与源操作数相乘，然后将结果存回目标地址。换句话说，指令
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'becomes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 变为：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using different registers to fix source and destination operands will become
    helpful in [Part II](part2.xhtml), when we’ll sometimes rewrite the source and
    destination of the same instruction. We’ll need two registers so that the fix-up
    instructions for the different operands don’t clobber each other.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的寄存器来修正源操作数和目标操作数，将在[第二部分](part2.xhtml)中变得非常有用，因为我们有时会重写同一条指令的源和目标。我们需要两个寄存器，以便不同操作数的修正指令不会互相覆盖。
- en: Once you’ve updated the assembly generation, pseudoregister replacement, and
    instruction fix-up compiler passes, your compiler should be able to generate complete,
    correct assembly programs that perform basic arithmetic. All that’s left is emitting
    those assembly programs in the right format.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更新了汇编生成、伪寄存器替换和指令修正编译过程，你的编译器应该能够生成完整且正确的汇编程序来执行基本的算术运算。剩下的就是以正确的格式输出这些汇编程序。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">代码生成</samp>
- en: The last step is extending the code emission stage to handle our new assembly
    instructions. [Tables 3-7](chapter3.xhtml#tab3-7) through [3-10](chapter3.xhtml#tab3-10)
    show how to print out each construct, with new constructs bolded.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是扩展代码生成阶段，以处理我们的新汇编指令。[表3-7](chapter3.xhtml#tab3-7)到[表3-10](chapter3.xhtml#tab3-10)展示了如何打印出每个构造，其中新的构造已加粗显示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-7:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-7:</samp> <samp class="SANS_Futura_Std_Book_11">顶层汇编构造格式化</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编顶层构造</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    |'
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-8:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-8:</samp> <samp class="SANS_Futura_Std_Book_11">汇编指令格式化</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst)</samp> |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst)</samp> |'
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp> |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp> |'
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator, operand)</samp>
    |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator, operand)</samp>
    |'
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(binary_operator, src,
    dst)</samp> |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(binary_operator, src,
    dst)</samp> |'
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Idiv(operand)</samp> |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Idiv(operand)</samp> |'
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cdq</samp> |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cdq</samp> |'
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '|'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack(int)</samp> |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack(int)</samp> |'
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-9:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Names for Assembly Operators</samp>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-9:</samp> <samp class="SANS_Futura_Std_Book_11">汇编运算符的指令名称</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp> |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编运算符</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">指令名称</samp>
    |'
- en: '| --- | --- |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Neg</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">negl</samp>
    |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Neg</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">negl</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">notl</samp>
    |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">notl</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Add</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">addl</samp>
    |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Add</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">addl</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Sub</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">subl</samp>
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Sub</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">subl</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mult</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">imull</samp>
    |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mult</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">imull</samp>
    |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-10:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-10：</samp> <samp class="SANS_Futura_Std_Book_11">汇编操作数格式化</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(AX)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp>
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(AX)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(DX)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%edx</samp>
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(DX)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%edx</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R10)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r10d</samp>
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R10)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%r10d</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R11)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r11d</samp>
    |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R11)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r11d</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(int)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(%rbp)</samp> |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(int)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">(%rbp)</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp> |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp> |'
- en: The new instructions operate on 32-bit values, so they get <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    suffixes (except <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>, which
    doesn’t follow the usual naming conventions). Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">subl</samp>
    instruction we use to subtract integers and the <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp>
    instruction we use to allocate space on the stack are 32-bit and 64-bit versions
    of the same instruction.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 新指令操作32位值，因此它们带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> 后缀（除了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>，它不遵循常规命名规则）。请注意，我们用来减去整数的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">subl</samp> 指令和用来在栈上分配空间的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">subq</samp> 指令是同一指令的32位和64位版本。
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Bitwise Operators</samp>'
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">额外加分：位运算符</samp>
- en: Now that you’ve learned how to compile binary operators, you can implement the
    bitwise binary operators on your own. These include bitwise AND (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>),
    OR (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>), XOR (<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>),
    left shift (<samp class="SANS_TheSansMonoCd_W5Regular_11"><<</samp>), and right
    shift (<samp class="SANS_TheSansMonoCd_W5Regular_11">>></samp>). Your compiler
    can handle these much like the operators you just added. You’ll need to look up
    the relative precedence of these operators, and you’ll need to check the documentation
    for the x64 instruction set to see how to use the relevant assembly instructions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经学会了如何编译二进制运算符，你可以自己实现位运算二进制运算符。这些包括位与（<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>）、位或（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">|</samp>）、位异或（<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>）、左移（<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><<</samp>）和右移（<samp class="SANS_TheSansMonoCd_W5Regular_11">>></samp>）。你的编译器可以像处理你刚刚添加的运算符一样处理这些运算符。你需要查阅这些运算符的相对优先级，并查看x64指令集的文档，了解如何使用相关的汇编指令。
- en: 'Bitwise operations are optional; later test cases don’t rely on them. If you
    do implement bitwise operations, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--bitwise</samp>
    flag to include the test cases for this feature:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算是可选的；后续的测试用例不依赖于它们。如果你实现了位运算符，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">--bitwise</samp>
    标志来包含此功能的测试用例：
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Include this flag when you run the test script in later chapters too, to include
    any test cases for those chapters that use bitwise operators.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节运行测试脚本时，也要包含此标志，以便包含任何使用位运算符的章节的测试用例。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: 'In this chapter, you implemented several binary arithmetic operations in your
    compiler. You used a new technique, precedence climbing, to parse expressions
    that recursive descent parsers don’t handle well. In the next chapter, you’ll
    implement even more unary and binary operations: the logical operators <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>,
    and relational operators like <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>.
    Some of these operators don’t correspond closely to assembly instructions, so
    we’ll break them down into lower-level instructions in TACKY. We’ll also introduce
    conditional assembly instructions, which will be particularly important when we
    implement control-flow statements like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements and loops later on.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你在编译器中实现了多个二元算术操作。你使用了一种新技术——优先级递增，来解析递归下降解析器处理不佳的表达式。在下一章中，你将实现更多的单目和二元操作符：逻辑运算符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>，以及像 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>
    这样的关系运算符。部分运算符与汇编指令的对应关系较弱，因此我们将在 TACKY 中将它们分解为更低级的指令。我们还将介绍条件汇编指令，这在稍后实现如 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句和循环等控制流语句时，尤为重要。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">附加资源</samp>'
- en: 'These blog posts helped me understand precedence climbing and how it relates
    to similar algorithms that solve the same problem; you might find them helpful
    too:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这些博客文章帮助我理解了优先级递增以及它如何与解决同一问题的类似算法相关；你可能也会觉得它们有帮助：
- en: “Parsing Expressions by Precedence Climbing” by Eli Bendersky is a solid overview
    of the precedence climbing algorithm (*[https://<wbr>eli<wbr>.thegreenplace<wbr>.net<wbr>/2012<wbr>/08<wbr>/02<wbr>/parsing<wbr>-expressions<wbr>-by<wbr>-precedence<wbr>-climbing](https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing)*).
    The precedence climbing code in [Listing 3-7](chapter3.xhtml#list3-7) is loosely
    adapted from this blog post; it also inspired the presentation of the example
    in “Precedence Climbing in Action” on [page 55](#pg_55).
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eli Bendersky 的《通过优先级递增解析表达式》是对优先级递增算法的详细概述 (*[https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing](https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing)*)。[列表
    3-7](chapter3.xhtml#list3-7) 中的优先级递增代码在很大程度上改编自这篇博客文章；它还启发了《优先级递增实战》一文中的示例展示，[在第
    55 页](#pg_55)。
- en: “Some Problems of Recursive Descent Parsers,” also by Eli Bendersky, talks about
    how to handle binary expressions with a pure recursive descent parser (*[https://<wbr>eli<wbr>.thegreenplace<wbr>.net<wbr>/2009<wbr>/03<wbr>/14<wbr>/some<wbr>-problems<wbr>-of<wbr>-recursive<wbr>-descent<wbr>-parsers](https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers)*).
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《递归下降解析器的一些问题》，同样由 Eli Bendersky 撰写，讨论了如何使用纯递归下降解析器处理二元表达式 (*[https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers](https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers)*)。
- en: Andy Chu has written two useful blog posts on precedence climbing. The first,
    “Pratt Parsing and Precedence Climbing Are the Same Algorithm,” explores the fundamental
    similarities between precedence climbing and the Pratt Parsing algorithm (*[https://<wbr>www<wbr>.oilshell<wbr>.org<wbr>/blog<wbr>/2016<wbr>/11<wbr>/01<wbr>.html](https://www.oilshell.org/blog/2016/11/01.html)*).
    The second, “Precedence Climbing Is Widely Used,” discusses their differences
    (*[https://<wbr>www<wbr>.oilshell<wbr>.org<wbr>/blog<wbr>/2017<wbr>/03<wbr>/30<wbr>.html](https://www.oilshell.org/blog/2017/03/30.html)*).
    These posts clarify some of the confusing terminology around different parsing
    algorithms.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Andy Chu 写了两篇关于优先级递增的有用博客文章。第一篇《Pratt 解析与优先级递增是相同的算法》探讨了优先级递增和 Pratt 解析算法的基本相似性
    (*[https://www.oilshell.org/blog/2016/11/01.html](https://www.oilshell.org/blog/2016/11/01.html)*)。第二篇《优先级递增被广泛应用》讨论了它们之间的区别
    (*[https://www.oilshell.org/blog/2017/03/30.html](https://www.oilshell.org/blog/2017/03/30.html)*)。这些文章澄清了不同解析算法中一些令人困惑的术语。
