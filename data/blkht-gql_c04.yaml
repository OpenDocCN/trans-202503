- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Reconnaissance
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 侦察
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: All security tests start with a *reconnaissance phase*. In this phase, we attempt
    to collect as much information as possible about our target. This information
    will prepare us to make informed decisions about how to attack the application
    and increase our chances of success.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的安全测试都从*侦察阶段*开始。在这个阶段，我们尽可能多地收集目标的信息。这些信息将帮助我们做出有根据的决策，选择攻击应用程序的方式，从而提高成功的机会。
- en: You might be asking yourself, what is there to know about GraphQL, seeing as
    it’s just an API layer? You’ll learn that we can gather a lot of information,
    through experimentation and the use of specialized tooling, about the application
    running behind a GraphQL API, as well as the GraphQL implementation itself. While
    the GraphQL query structure is consistent across all GraphQL implementations,
    irrespective of the programming language they are written in, you will likely
    see differences in the available operations, fields, arguments, directives, security
    controls, responses to specially crafted queries, and so on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，GraphQL只是一个API层，究竟有什么需要了解的呢？你将会了解到，通过实验和使用专门的工具，我们可以收集大量关于GraphQL API背后运行的应用程序的信息，甚至是GraphQL实现本身。尽管GraphQL查询结构在所有GraphQL实现中都是一致的，无论它们是用什么编程语言编写的，但你可能会看到在可用操作、字段、参数、指令、安全控制、对特殊构造查询的响应等方面的差异。
- en: 'Here are a few key questions we should strive to answer during our reconnaissance
    phase: Does the web server even have a GraphQL API? On which endpoint is GraphQL
    configured to receive queries? What language is the GraphQL implementation written
    in? What implementation of GraphQL is running on the target server? Is the implementation
    known to be vulnerable to certain attacks? What types of defenses exist for the
    specific GraphQL implementation? What are some of the out-of-the-box default configuration
    settings of this implementation? Does the GraphQL server have any additional security
    protection layers in place? Being able to answer these questions will allow us
    to plan a more focused attack against our target server and uncover gaps in its
    defense.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在侦察阶段应努力回答的一些关键问题：Web服务器是否有GraphQL API？GraphQL配置在哪个端点接收查询？GraphQL实现是用什么语言编写的？目标服务器上运行的是哪种GraphQL实现？该实现是否已知存在某些漏洞？此GraphQL实现有哪些防御机制？该实现的默认配置设置有哪些？GraphQL服务器是否有额外的安全防护层？能够回答这些问题将帮助我们制定更有针对性的攻击计划，发现防御中的漏洞。
- en: Detecting GraphQL
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测GraphQL
- en: To detect GraphQL in a penetration test, it’s important to first familiarize
    yourself with the GraphQL server implementations that exist in the wild today.
    GraphQL has many implementations written in a variety of programming languages,
    each of which could have different default configurations or known weaknesses.
    [Table 4-1](#table4-1) lists several GraphQL implementations and the languages
    in which they are written.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试中检测GraphQL时，首先熟悉当前流行的GraphQL服务器实现非常重要。GraphQL有许多用不同编程语言编写的实现，每种实现可能有不同的默认配置或已知的弱点。[表4-1](#table4-1)列出了几种GraphQL实现及其所用的编程语言。
- en: 'Table 4-1: GraphQL Server Implementations and Their Programming Languages'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1：GraphQL服务器实现及其编程语言
- en: '| **Server implementation** | **Language** |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| **服务器实现** | **语言** |'
- en: '| --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Apollo | TypeScript |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| Apollo | TypeScript |'
- en: '| Graphene | Python |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| Graphene | Python |'
- en: '| Yoga | TypeScript |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| Yoga | TypeScript |'
- en: '| Ariadne | Python |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| Ariadne | Python |'
- en: '| graphql-ruby | Ruby |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| graphql-ruby | Ruby |'
- en: '| graphql-php | PHP |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| graphql-php | PHP |'
- en: '| graphql-go | Go |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| graphql-go | Go |'
- en: '| graphql-java | Java |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| graphql-java | Java |'
- en: '| Sangria | Scala |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| Sangria | Scala |'
- en: '| Juniper | Rust |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Juniper | Rust |'
- en: '| HyperGraphQL | Java |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| HyperGraphQL | Java |'
- en: '| Strawberry | Python |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| Strawberry | Python |'
- en: '| Tartiflette | Python |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| Tartiflette | Python |'
- en: These are some of the most popular implementations in use today, as well as
    more niche implementations, such as Sangria for Scala, Juniper for Rust, and HyperGraphQL
    for Java. Later in this chapter, we will discuss how to distinguish between them
    during a penetration test.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是目前使用的一些最流行的实现方式，还有一些较为小众的实现，例如Scala的Sangria、Rust的Juniper和Java的HyperGraphQL。本章稍后我们将讨论如何在渗透测试中区分它们。
- en: 'Detection of GraphQL APIs can be done in several ways: either manually, which
    is typically harder to scale if you have more than a few hosts on a network, or
    automatically, using various web scanners. The advantage of using web-scanning
    tools is that they are scalable. They are threaded, and often have the ability
    to read external files as program input, such as text files with a list of hostnames
    to scan. These tools already have the logic to detect web interfaces built into
    them, and using scripting languages (such as Bash or Python), you can programmatically
    run them against hundreds of IP addresses or subdomains. In this chapter, we will
    use popular scanners such as Nmap, as well as GraphQL-oriented scanning tools,
    such as Graphw00f, for reconnaissance.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API 的检测可以通过多种方式进行：可以手动进行，如果网络上有多个主机，通常手动方式很难扩展；也可以自动进行，使用各种 Web 扫描工具。使用
    Web 扫描工具的优势在于它们具有可扩展性。它们是多线程的，且通常能够读取外部文件作为程序输入，例如包含要扫描的主机名列表的文本文件。这些工具已经内置了检测
    Web 界面的逻辑，并且通过使用脚本语言（如 Bash 或 Python），你可以程序化地将它们运行在数百个 IP 地址或子域上。在本章中，我们将使用流行的扫描工具，如
    Nmap，以及 GraphQL 定向的扫描工具，如 Graphw00f，用于侦察。
- en: Common Endpoints
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见端点
- en: In Chapter 1, we highlighted some of the differences between REST and GraphQL
    APIs. One of these differences, relevant to the reconnaissance phase, is that
    a GraphQL API endpoint is typically static, and most commonly */graphql*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们强调了 REST 和 GraphQL API 之间的一些区别。其中一个与侦察阶段相关的区别是，GraphQL API 端点通常是静态的，最常见的是
    */graphql*。
- en: 'However, although */graphql* is often the default GraphQL endpoint, the GraphQL
    implementation can be reconfigured to use a completely different path. In those
    cases, what can we do to detect it? One way is to manually attempt a few common
    alternative paths to the GraphQL API, such as versioned endpoints:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然 */graphql* 通常是默认的 GraphQL 端点，但 GraphQL 实现可以重新配置为使用完全不同的路径。在这种情况下，我们该如何检测它呢？一种方法是手动尝试几个常见的替代
    GraphQL API 路径，例如版本化端点：
- en: '*/v1/graphql*'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/v1/graphql*'
- en: '*/v2/graphql*'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/v2/graphql*'
- en: '*/v3/graphql*'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/v3/graphql*'
- en: You’ll typically see these versioned API endpoints when the application needs
    to support multiple versions of its API, either for backward compatibility or
    for the introduction of a new feature in a way that doesn’t conflict with the
    stable API version that customers might still be using.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序需要支持多个版本的 API 时，通常会看到这些版本化的 API 端点，无论是为了向后兼容，还是为了引入新特性，并且不与客户仍在使用的稳定 API
    版本发生冲突。
- en: 'Another way to find a GraphQL implementation is through IDEs, such as GraphQL
    Playground or GraphiQL Explorer, which we used in Chapter 1 to experiment with
    GraphQL queries. When either of these interfaces is enabled, it often uses an
    additional, dedicated endpoint. This means GraphQL can potentially exist under
    the following endpoints as well:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种找到 GraphQL 实现的方法是通过 IDE，如 GraphQL Playground 或 GraphiQL Explorer，我们在第一章中用它们来实验
    GraphQL 查询。当启用这些界面时，它通常会使用一个额外的专用端点。这意味着 GraphQL 可能也存在于以下端点下：
- en: '*/graphiql*'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/graphiql*'
- en: '*/playground*'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*/playground*'
- en: If these endpoints happen to also be versioned, they may have a version number
    prepended to their path, such as */v1/graphiql*, */v2/graphiql*, */v1/playground*,
    */v2/playground*, and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些端点恰好也进行了版本控制，它们的路径可能会添加版本号前缀，例如 */v1/graphiql*、*/v2/graphiql*、*/v1/playground*、*/v2/playground*
    等等。
- en: '[Listing 4-1](#listing4-1) shows how Graphene, a Python-based implementation
    of GraphQL, can expose two endpoints, one for GraphQL, and the other for GraphiQL
    Explorer, which is built into Graphene:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-1](#listing4-1) 显示了如何通过 Graphene（一种基于 Python 的 GraphQL 实现）暴露两个端点，一个用于
    GraphQL，另一个用于 GraphiQL Explorer，GraphiQL Explorer 是内嵌在 Graphene 中的。'
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 4-1: Graphene’s endpoint definition'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-1：Graphene 的端点定义
- en: Graphene defines the */graphql* endpoint as its main GraphQL query endpoint.
    It then defines */graphiql* as a second endpoint that GraphiQL Explorer will query
    against. Lastly, it enables the GraphiQL Explorer interface. The GraphQL server
    will render the IDE to the client when it browses to the */graphiql* endpoint.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Graphene 将 */graphql* 端点定义为其主要的 GraphQL 查询端点。然后，它将 */graphiql* 定义为 GraphiQL
    Explorer 查询的第二个端点。最后，它启用了 GraphiQL Explorer 界面。当客户端浏览到 */graphiql* 端点时，GraphQL
    服务器将呈现 IDE 界面。
- en: Keep in mind that each endpoint could have different security settings. One
    could be stricter than the other, for example. When you find two endpoints serving
    GraphQL queries on the same target host, you will want to test them separately.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每个端点可能有不同的安全设置。例如，一个端点可能比另一个更严格。当你发现同一目标主机上有两个端点提供 GraphQL 查询时，你需要分别测试它们。
- en: The most important takeaway here is that, while the GraphQL endpoint is typically
    located at a predictable path, the developer can still customize it to fit their
    needs, perhaps in an attempt to hide it from curious eyes or to simply conform
    to internal application deployment standards.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的要点是，尽管 GraphQL 端点通常位于可预测的路径上，但开发者仍然可以根据需求自定义它，可能是为了隐藏它免受好奇眼睛的窥探，或者仅仅是为了符合内部应用程序部署标准。
- en: Common Responses
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见响应
- en: Now that you have an idea of the endpoints from which GraphQL typically receives
    queries, the next step is to learn how GraphQL APIs respond to packets. GraphQL
    is fairly easy to identify on a network. This is particularly helpful whenever
    you are performing a zero-knowledge penetration test or bug bounty hunt.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对 GraphQL 通常接收查询的端点有了了解，下一步是学习 GraphQL API 如何响应数据包。GraphQL 在网络中相当容易识别。这在你执行零知识渗透测试或漏洞赏金猎杀时特别有用。
- en: 'The GraphQL specification describes how a query response structure should be
    formatted. This allows API consumers to expect a predetermined format when they
    parse the GraphQL response. The following excerpt from the GraphQL specification
    describes how the response to a query should look:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 规范描述了查询响应结构应如何格式化。这使得 API 使用者在解析 GraphQL 响应时，能够预期到一个预定的格式。以下是来自 GraphQL
    规范的摘录，描述了查询响应应该是什么样的：
- en: If the operation is a query, the result of the operation is the result of executing
    the operation’s top-level selection set with the query root operation type.
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果操作是查询，则操作的结果是执行操作的顶级选择集与查询根操作类型的结果。
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An initial value may be provided when executing a query operation:'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 执行查询操作时，可以提供一个初始值：
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ExecuteQuery(``query``,` `schema``,` `variableValues``,` `initialValue``)`'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ExecuteQuery(``query``,` `schema``,` `variableValues``,` `initialValue``)`'
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let `queryType` be the root `Query` type in the schema.
  id: totrans-52
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 `queryType` 成为架构中的根 `Query` 类型。
- en: 'Assert: `queryType` is an `Object` type.'
  id: totrans-53
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言：`queryType` 是一个 `Object` 类型。
- en: Let `selectionSet` be the top-level selection set in the query.
  id: totrans-54
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 `selectionSet` 成为查询中的顶级选择集。
- en: Let `data` be the result of running `ExecuteSelectionSet(selectionSet, queryType,
    initialValue, variableValues)` normally (allowing parallelization).
  id: totrans-55
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 `data` 成为正常运行 `ExecuteSelectionSet(selectionSet, queryType, initialValue,
    variableValues)` 的结果（允许并行化）。
- en: Let `errors` be any field errors produced while executing the selection set.
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 `errors` 成为执行选择集时产生的任何字段错误。
- en: Return an unordered map containing data and errors.
  id: totrans-57
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个包含数据和错误的无序映射。
- en: In practice, this means a GraphQL API will return a `data` JSON field when there
    is a result to return to a client’s query. It will also return an `errors` JSON
    field whenever errors occur during the execution of a client query.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着当 GraphQL API 有结果返回客户端查询时，它将返回一个 `data` JSON 字段。同时，当执行客户端查询时发生错误，它也会返回一个
    `errors` JSON 字段。
- en: 'Knowing these two pieces of information ahead of time is valuable. To put it
    simply, we now have two conditions that a response must meet before we can say
    that it came from a GraphQL API:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 提前知道这两条信息非常有价值。简单来说，我们现在有两个条件，响应必须满足这两个条件，才能确定它来自一个 GraphQL API：
- en: A valid query response should *always* have the `data` field populated with
    query response information.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个有效的查询响应应该 *始终* 填充 `data` 字段，包含查询响应信息。
- en: An invalid query response should *always* have the `errors` field populated
    with information about what went wrong.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个无效的查询响应应该 *始终* 填充 `errors` 字段，包含有关出错原因的信息。
- en: Now we can leverage these as part of scanning and detection logic to automate
    the discovery of GraphQL servers on a network. All we need to do is send a valid
    or malformed query and observe the response we receive.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将这些信息作为扫描和检测逻辑的一部分，自动发现网络上的 GraphQL 服务器。我们需要做的就是发送一个有效或格式错误的查询，并观察我们收到的响应。
- en: 'Let’s run a simple GraphQL query using the HTTP POST method against the DVGA
    to see these response structures in action. Open the Altair GraphQL client and
    ensure that the address bar has the *http://localhost:5013/graphql* address set;
    then run the following query by entering it in Altair’s left pane:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 HTTP POST 方法对 DVGA 执行一个简单的 GraphQL 查询，看看这些响应结构如何运作。打开 Altair GraphQL 客户端，确保地址栏设置了
    *http://localhost:5013/graphql* 地址；然后在 Altair 的左侧面板中输入以下查询并运行：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, click the play button to send the query to the GraphQL server. This should
    return the `id` field of the `pastes` object. You should be able to see a response
    similar to the following output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击播放按钮将查询发送到 GraphQL 服务器。这应该返回 `pastes` 对象的 `id` 字段。你应该能够看到类似于以下输出的响应：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, GraphQL returns the query response as part of the `data` JSON
    field, exactly as described in the GraphQL specification. We get the `pastes`
    object and the `id` field we specified in the query. Don’t worry if you see a
    different `id` string returned in your lab than the one shown here; this is expected.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，GraphQL 将查询响应作为 `data` JSON 字段的一部分返回，正如 GraphQL 规范中描述的那样。我们得到了查询中指定的 `pastes`
    对象和 `id` 字段。如果你在实验中看到返回的 `id` 字符串与此处显示的不同，不用担心；这是预期的结果。
- en: 'Now, let’s run another query to explore what happens when an invalid query
    is sent to GraphQL. This will demonstrate that the `errors` JSON field is returned
    by the GraphQL server when it encounters issues during query execution. The following
    query is malformed, and GraphQL won’t be able to process it. Run it in Altair
    and observe the response:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行另一个查询，探索当发送无效查询到 GraphQL 时会发生什么。这将展示当 GraphQL 在查询执行过程中遇到问题时，`errors`
    JSON 字段会被 GraphQL 服务器返回。以下查询是格式错误的，GraphQL 无法处理它。请在 Altair 中运行该查询并观察响应：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that we specify a top-level field with the name of `badfield`. Because
    this field does not exist, the GraphQL server can’t fulfill the query. The GraphQL
    response can be seen here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们指定了一个名为 `badfield` 的顶级字段。由于该字段不存在，GraphQL 服务器无法完成查询。GraphQL 响应如下所示：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the GraphQL server isn’t able to process our query successfully.
    It returns a response containing the `errors` JSON field. The `message` JSON field
    indicates to us that the server couldn’t query the field named `badfield`, because
    it does not exist in the GraphQL schema.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，GraphQL 服务器无法成功处理我们的查询。它返回一个包含 `errors` JSON 字段的响应。`message` JSON 字段告诉我们服务器无法查询名为
    `badfield` 的字段，因为该字段在 GraphQL 模式中不存在。
- en: Nmap Scans
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Nmap 扫描
- en: Imagine that you need to conduct a penetration test against a network containing
    thousands of hosts; it would be fairly difficult to manually go through each host
    to find ones that are potentially serving interesting content, such as an API
    or a vulnerable commercial application. In these cases, penetration testers often
    use web application scanners or custom scripts to automatically grab information
    from the hosts. For example, information such as the `<title>` HyperText Markup
    Language (HTML) tag, the entire `<body>` tag, and even the `server` HTTP response
    header could all hint at specific applications that the remote server is running.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要对包含数千个主机的网络进行渗透测试；手动浏览每个主机，找出可能提供有趣内容的主机，如 API 或易受攻击的商业应用程序，会非常困难。在这种情况下，渗透测试人员通常使用
    Web 应用扫描器或自定义脚本来自动从主机获取信息。例如，像 `<title>` 超文本标记语言（HTML）标签、整个 `<body>` 标签，甚至 `server`
    HTTP 响应头等信息，都可能暗示远程服务器正在运行的特定应用程序。
- en: It’s important to note that web applications may not always have a user interface,
    meaning they may not serve any HTML content related to the application or even
    expose HTTP headers by which we can detect them. They will often act as standalone
    API servers that expose data only through designated APIs. So, how can we detect
    GraphQL in those cases? Luckily, GraphQL APIs often return predictable responses
    under certain conditions, such as the HTTP method in use or the payload sent to
    the server. [Listing 4-2](#listing4-2) shows a common GraphQL response returned
    when a client makes a GET request.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，网络应用程序不一定总是具有用户界面，这意味着它们可能不会提供与应用程序相关的任何 HTML 内容，甚至不会暴露 HTTP 头部信息供我们检测。它们通常作为独立的
    API 服务器，仅通过指定的 API 提供数据。那么，在这种情况下，我们如何检测 GraphQL 呢？幸运的是，在某些条件下，如使用的 HTTP 方法或发送到服务器的有效负载，GraphQL
    API 通常会返回可预测的响应。[清单 4-2](#listing4-2) 显示了当客户端发出 GET 请求时，GraphQL 返回的常见响应。
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 4-2: A GraphQL response to an HTTP GET request'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-2：HTTP GET 请求的 GraphQL 响应
- en: 'The string `Must provide query string` is often used in GraphQL implementations,
    such as Python- and Node.js-based ones. (Keep in mind that GET-based queries are
    often not supported by GraphQL servers. Rest assured: we have many other ways
    of detecting GraphQL should we run into such a situation.)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 `Must provide query string` 在 GraphQL 实现中经常使用，例如基于 Python 和 Node.js 的实现。（请记住，基于
    GET 的查询通常不被 GraphQL 服务器支持。请放心：如果我们遇到这种情况，我们还有很多其他方法来检测 GraphQL。）
- en: With this information, we now have the ability to automate a scan and pick up
    any other GraphQL servers that may exist on a network. [Listing 4-3](#listing4-3)
    shows how to do this with Nmap, using the *http-grep* NSE script, which uses pattern
    matching to look for keywords in a given web page.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们现在可以自动化扫描并发现网络中可能存在的其他 GraphQL 服务器。[列表 4-3](#listing4-3) 展示了如何使用 Nmap
    配合 *http-grep* NSE 脚本来做到这一点，该脚本通过模式匹配在给定网页中查找关键词。
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 4-3: A GraphQL response to word-matching using Nmap’s *http-grep*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-3：使用 Nmap 的 *http-grep* 进行单词匹配的 GraphQL 响应
- en: At ❶ we specify a script argument to *http-grep* called `match` with a value
    of `Must` `provide` `query` `string` (the message we received in our GraphQL response).
    At ❷ we define another argument, called `http-grep.url`, with a value of `/graphql`,
    which instructs Nmap to search a specific page within the web application. Under
    the hood, Nmap will make an HTTP GET request to `localhost` and use the argument
    string value we defined as the pattern for its search within the text it extracts
    from the web server’s response. In its output, Nmap shows that a pattern was found
    on the web page and indicates the string for which it found a match.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❶ 处，我们为 *http-grep* 指定了一个名为 `match` 的脚本参数，值为 `Must` `provide` `query` `string`（我们从
    GraphQL 响应中收到的消息）。在 ❷ 处，我们定义了另一个参数，名为 `http-grep.url`，值为 `/graphql`，指示 Nmap 在
    Web 应用程序中搜索特定页面。底层，Nmap 将向 `localhost` 发出一个 HTTP GET 请求，并使用我们定义的参数字符串值作为搜索模式，在从
    Web 服务器响应中提取的文本中进行查找。在其输出中，Nmap 显示在网页上找到了一个模式，并指示它找到匹配的字符串。
- en: You may have noticed that we’re passing a specific port to Nmap (`-p`)—namely,
    port `5013`. Like any web server, GraphQL servers could run on any port, but a
    few are quite common, such as 80–89, 443, 4000–4005, 8443, 8000, and 8080\. We
    recommend scanning both common and uncommon port ranges when possible.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们向 Nmap 传递了一个特定的端口（`-p`）——即端口 `5013`。像任何 Web 服务器一样，GraphQL 服务器可以运行在任何端口上，但一些端口是相当常见的，比如
    80–89、443、4000–4005、8443、8000 和 8080。我们建议尽可能扫描常见和不常见的端口范围。
- en: The __typename Field
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: __typename 字段
- en: So far, we’ve known exactly which fields to ask for in our queries, such as
    `pastes` with a selection set of `id`, as we requested earlier. You might be wondering,
    what if we don’t know what fields exist on the GraphQL API? How can we go about
    identifying GraphQL without this information? Luckily, there is a quick way to
    query GraphQL and return a valid response without knowing anything about the application’s
    schema.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准确知道在查询中要请求哪些字段，比如之前请求的 `pastes`，其选择集为 `id`。你可能会想，如果我们不知道 GraphQL
    API 上有哪些字段呢？如果没有这些信息，我们如何识别 GraphQL？幸运的是，有一种快速的方法可以查询 GraphQL 并返回有效的响应，而无需了解应用程序的模式。
- en: '*Meta-fields* are built-in fields that GraphQL APIs expose to clients. One
    example is `__schema` (part of introspection in GraphQL). Another example of a
    meta-field is `__typename`. When used, it returns the name of the object type
    being queried. [Listing 4-4](#listing4-4) shows a query that uses this meta-field.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*元字段* 是 GraphQL API 向客户端暴露的内置字段。一个例子是 `__schema`（GraphQL 中的自省的一部分）。另一个元字段的例子是
    `__typename`。当使用时，它返回正在查询的对象类型的名称。[列表 4-4](#listing4-4) 显示了一个使用此元字段的查询。'
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 4-4: A GraphQL query with the `__typename` meta-field'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-4：带有 `__typename` 元字段的 GraphQL 查询
- en: 'When you run this query with Altair, the response will be the name of the `pastes`
    object type:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Altair 运行这个查询时，返回的结果将是 `pastes` 对象类型的名称：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, GraphQL tells us that the `pastes` object’s type name is `PasteObject`.
    The real hack here is that the `__typename` meta-field can be used against the
    query root type as well, as shown in [Listing 4-5](#listing4-5).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，GraphQL 告诉我们 `pastes` 对象的类型名称是 `PasteObject`。这里的真正技巧是，`__typename` 元字段也可以用于查询根类型，如
    [列表 4-5](#listing4-5) 所示。
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 4-5: A GraphQL meta-field used with the query root type'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-5：与查询根类型一起使用的 GraphQL 元字段
- en: This query uses `__typename` to describe the query root type and will work against
    pretty much any GraphQL implementation, since `__typename` is part of the official
    specification.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询使用 `__typename` 来描述查询根类型，并且几乎适用于任何 GraphQL 实现，因为 `__typename` 是官方规范的一部分。
- en: 'When you’re attempting to query GraphQL from the command line, GraphQL servers
    expect a certain request structure. For HTTP GET-based queries, a request should
    have the following HTTP query parameters:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试从命令行查询 GraphQL 时，GraphQL 服务器期望某种请求结构。对于 HTTP GET 类型的查询，请求应包含以下 HTTP 查询参数：
- en: '`query` for the GraphQL query (mandatory parameter).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`query` 用于 GraphQL 查询（必选参数）。'
- en: '`operationName` for the operation name, used when multiple queries are sent
    in a single document. This parameter tells the GraphQL server which specific operation
    to run when more than one is present (optional parameter).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operationName` 用于操作名称，当多个查询被发送到单个文档时使用。该参数告诉 GraphQL 服务器在有多个操作时执行哪个特定操作（可选参数）。'
- en: '`variables` for query variables (optional parameter).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variables` 用于查询变量（可选参数）。'
- en: For HTTP POST-based queries, the same parameters should be passed in the HTTP
    body in JSON.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 HTTP POST 类型的查询，相同的参数应通过 HTTP 请求体以 JSON 格式传递。
- en: When GraphQL servers accept queries using GET, you can pass the `query` parameter
    along with the GraphQL query (in this case, the query `{__typename}`) by using
    shorthand syntax. With this in mind, we can automate the detection of GraphQL
    by using Nmap fairly easily. [Listing 4-6](#listing4-6) shows how to run a `__typename`
    query with Nmap.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GraphQL 服务器使用 GET 接受查询时，可以通过简写语法传递 `query` 参数和 GraphQL 查询（在此案例中是查询 `{__typename}`）。考虑到这一点，我们可以使用
    Nmap 很容易地自动化 GraphQL 检测。[Listing 4-6](#listing4-6) 显示了如何使用 Nmap 运行 `__typename`
    查询。
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 4-6: Detecting GraphQL by using GET-based queries with Nmap'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-6：使用基于 GET 的查询通过 Nmap 检测 GraphQL
- en: In this example, the Nmap script *http-grep* uses the GET method under the hood
    to do its work.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，Nmap 脚本 *http-grep* 在后台使用 GET 方法执行其工作。
- en: If you have more than a handful of hosts to scan, you may want to leverage Nmap’s
    `-iL` flag to point to a file that contains a list of hostnames, as shown in [Listing
    4-7](#listing4-7).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个主机需要扫描，您可能希望利用 Nmap 的 `-iL` 标志指向一个包含主机名列表的文件，如 [Listing 4-7](#listing4-7)
    所示。
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 4-7: Scanning multiple targets defined in a file with Nmap'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-7：使用 Nmap 扫描文件中定义的多个目标
- en: The *hosts.txt* file in this example would contain IP addresses or Domain Name
    System (DNS) hostnames listed on separate lines.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的 *hosts.txt* 文件将包含单独列出的 IP 地址或域名系统（DNS）主机名。
- en: If the GraphQL server does not support GET-based queries, we can use cURL and
    the `__typename` field to make a POST request to detect GraphQL, as shown in [Listing
    4-8](#listing4-8).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 GraphQL 服务器不支持基于 GET 的查询，我们可以使用 cURL 和 `__typename` 字段通过 POST 请求来检测 GraphQL，如
    [Listing 4-8](#listing4-8) 所示。
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 4-8: Sending a POST-based query using cURL'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-8：使用 cURL 发送基于 POST 的查询
- en: To use this detection method against a list of hosts, you can use Bash scripting,
    as shown in [Listing 4-9](#listing4-9).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要在主机列表上使用此检测方法，可以使用 Bash 脚本，如 [Listing 4-9](#listing4-9) 所示。
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 4-9: A Bash script to automate a POST-based GraphQL detection using
    cURL'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-9：使用 cURL 自动化基于 POST 的 GraphQL 检测的 Bash 脚本
- en: The *hosts.txt* file in this example would contain a list of full target URLs
    on separate lines (including their protocol schemes, domains, ports, and endpoints).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的 *hosts.txt* 文件将包含每行一个的完整目标 URL 列表（包括它们的协议方案、域名、端口和端点）。
- en: Graphw00f
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Graphw00f
- en: In Chapter 2, we briefly discussed Graphw00f, a GraphQL tool based on Python
    for detecting GraphQL and performing implementation-level fingerprinting. In this
    section, we will use it to detect DVGA in our lab, walking you through how it
    does its detection magic.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们简要讨论了 Graphw00f，这是一种基于 Python 的 GraphQL 工具，用于检测 GraphQL 并执行实现级指纹识别。在本节中，我们将使用它来在实验室中检测
    DVGA，并带您了解它如何实现检测。
- en: We mentioned earlier in this chapter that GraphQL servers are found at the endpoint
    */graphql* by default. When this is not the case, we might need an automated way
    to iterate through known endpoints in order to figure out where queries are served
    from. Graphw00f allows you to specify a custom list of endpoints when running
    a scan. If you don’t provide a list, Graphw00f will use its hardcoded list of
    common endpoints whenever it is tasked with detecting GraphQL, as shown in [Listing
    4-10](#listing4-10).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章早些时候提到，默认情况下，GraphQL 服务器位于 */graphql* 端点。当情况不是这样时，我们可能需要一种自动化方式来遍历已知端点，以便找出查询从何处提供。Graphw00f
    允许你在扫描时指定自定义的端点列表。如果你没有提供列表，Graphw00f 会在检测 GraphQL 时使用其硬编码的常见端点列表，如 [列表 4-10](#listing4-10)
    所示。
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 4-10: A list of common GraphQL endpoints in Graphw00f’s source code'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-10：Graphw00f 源代码中的常见 GraphQL 端点列表
- en: To see Graphw00f in action, open your terminal and execute the command in [Listing
    4-11](#listing4-11). We use command line parameters `-t` (target) and `-d` (detection).
    The `-t` flag in this case will be the remote URL *http://localhost:5013*, and
    the `-d` flag will turn on detection mode, which indicates to Graphw00f that it
    should run a GraphQL detection check against the target URL. If you have questions
    about Graphw00f’s arguments, use the `-h` flag to read more about its options.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Graphw00f 的实际操作，打开终端并执行 [列表 4-11](#listing4-11) 中的命令。我们使用命令行参数 `-t`（目标）和
    `-d`（检测）。在这种情况下，`-t` 标志表示远程 URL *http://localhost:5013*，而 `-d` 标志会开启检测模式，指示 Graphw00f
    对目标 URL 执行 GraphQL 检测。如果你对 Graphw00f 的参数有疑问，可以使用 `-h` 标志查看更多选项。
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 4-11: A GraphQL detection with Graphw00f'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-11：使用 Graphw00f 检测 GraphQL
- en: Run in detect mode, Graphw00f iterates through various web paths. It checks
    for the existence of GraphQL in the main web root folder and the */graphql* folder.
    Then it signals to us that it found GraphQL under */graphql* based on the HTTP
    response heuristics we discussed earlier.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测模式下运行时，Graphw00f 会遍历各种网页路径。它检查主网页根文件夹和*/graphql*文件夹中是否存在 GraphQL。然后，根据我们之前讨论的
    HTTP 响应启发式，它会向我们发出信号，表示在*/graphql*文件夹下找到了 GraphQL。
- en: To use your own list of endpoints, you can pass the `-w` (wordlist) flag and
    point it at a file containing your endpoints, as shown in [Listing 4-12](#listing4-12).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用你自己的端点列表，你可以传递 `-w`（词汇表）标志，并将其指向一个包含你端点的文件，如 [列表 4-12](#listing4-12) 所示。
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 4-12: Using a custom endpoint list with Graphw00f'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-12：使用自定义端点列表与 Graphw00f
- en: Detecting GraphiQL Explorer and GraphQL Playground
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测 GraphiQL Explorer 和 GraphQL Playground
- en: The GraphiQL Explorer and GraphQL Playground IDEs are built using the JavaScript
    library React. Yet when performing reconnaissance, we will often rely on tools
    that are incapable of rendering web pages containing JavaScript, such as command
    line HTTP clients like cURL or web application scanners like Nikto. In the process,
    we might miss interesting web interfaces.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: GraphiQL Explorer 和 GraphQL Playground IDE 是使用 JavaScript 库 React 构建的。然而，在执行侦察时，我们通常依赖于无法渲染包含
    JavaScript 的网页的工具，如命令行 HTTP 客户端（如 cURL）或网络应用扫描器（如 Nikto）。在这个过程中，我们可能会错过一些有趣的网页界面。
- en: In general, you’ll find it beneficial to look for any signs of web interfaces
    available on the network, such as administration, debugging, or configuration
    panels, all of which are great candidates to hack. These panels tend to be data
    rich and often become a way to pivot to other networks or to escalate privileges.
    They also tend to be far less hardened than publicly facing applications. Companies
    assume that the external space (the internet) is riskier than the internal space
    (the corporate network). As such, they often have guidelines for securing publicly
    facing servers and applications via aggressive patching policies, configuration
    reviews, and frequent vulnerability scanning. Unfortunately, internal applications
    rarely get the same treatment, which often makes them an easier target for hackers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会发现寻找网络上可用的任何网页界面的迹象是有益的，比如管理、调试或配置面板，所有这些都是黑客攻击的理想目标。这些面板往往数据丰富，且常常成为转向其他网络或提升权限的途径。它们也通常不像公开面对外部的应用程序那样经过加固。公司通常认为外部空间（互联网）的风险高于内部空间（公司网络）。因此，他们通常会通过积极的补丁策略、配置审查和频繁的漏洞扫描来保护公开面对外部的服务器和应用程序。不幸的是，内部应用程序很少得到相同的保护，这使得它们成为黑客攻击的更容易目标。
- en: An interesting and often overlooked technique to scan for graphical web interfaces
    is through the use of tools such as headless browsers. *Headless browsers* are
    fully functional command line web browsers that the user can program for a variety
    of purposes, such as retrieving page contents, submitting forms, or simulating
    real user behavior on a web page. For example, the headless browsers Selenium
    and PhantomJS can be handy when you need to render web pages containing JavaScript
    code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描图形网页界面的一个有趣且常被忽视的技巧是使用诸如无头浏览器之类的工具。*无头浏览器*是功能完整的命令行网页浏览器，用户可以对其进行编程以执行各种任务，例如获取页面内容、提交表单或模拟网页上的真实用户行为。例如，当您需要渲染包含JavaScript代码的网页时，无头浏览器Selenium和PhantomJS非常有用。
- en: 'One security tool in particular has incorporated a headless browser to solve
    this gap: *EyeWitness*. This web scanner is capable of taking screenshots of web
    pages by leveraging the Selenium headless browser driver engine behind the scenes.
    EyeWitness then generates a nice report, along with a screen capture of the page.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特别的安全工具已经结合了无头浏览器来解决这一空白：*EyeWitness*。这个网页扫描器通过利用背后的Selenium无头浏览器驱动引擎，能够拍摄网页的截图。然后，EyeWitness生成一个漂亮的报告，并附上页面的屏幕截图。
- en: Scanning for Graphical Interfaces with EyeWitness
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用EyeWitness扫描图形界面
- en: Since the two GraphQL IDEs use JavaScript code, we need a capable scanner to
    help us identify them when we perform network-wide scans. Let’s use EyeWitness
    to identify these graphical interfaces.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个GraphQL IDE使用JavaScript代码，我们需要一个强大的扫描工具来帮助我们在执行全网扫描时识别它们。我们可以使用EyeWitness来识别这些图形界面。
- en: EyeWitness offers many options for customizing its scanner behavior, and you
    can see them by running the tool with the `-h` option. To detect GraphQL IDE panels,
    we’ll use the `--web` option, which will attempt a screen capture of the scanned
    site with the headless browser engine, together with the `--single` option, which
    is suitable when you need to scan only a single target URL. We will then use the
    `-d` flag to indicate to EyeWitness the folder in which it should dump the report
    (in this case, the *dvga-report* folder). [Listing 4-13](#listing4-13) puts everything
    together.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: EyeWitness提供了许多选项来定制其扫描行为，您可以通过使用`-h`选项运行工具来查看这些选项。为了检测GraphQL IDE面板，我们将使用`--web`选项，它将尝试使用无头浏览器引擎捕获扫描站点的屏幕截图，同时结合`--single`选项，当您只需要扫描单个目标URL时，这个选项非常适用。然后，我们将使用`-d`标志告诉EyeWitness报告应存储在哪个文件夹中（在本例中为*dvga-report*文件夹）。[列表4-13](#listing4-13)将所有步骤结合在一起。
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 4-13: The runtime output of EyeWitness'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-13：EyeWitness的运行时输出
- en: In the output, EyeWitness indicates that it saved the collected web page source
    files in the *dvga-report* folder and asks us whether to open the report. Press
    Y and ENTER to open a web browser displaying the HTML report, including the screenshot
    it took during the scan. [Figure 4-1](#figure4-1) shows the report.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，EyeWitness表示它已将收集到的网页源文件保存在*dvga-report*文件夹中，并询问我们是否要打开报告。按Y和ENTER键以打开一个网页浏览器，显示包含扫描期间拍摄的截图的HTML报告。[图4-1](#figure4-1)展示了报告。
- en: '![](image_fi/502840c04/f04001.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c04/f04001.png)'
- en: 'Figure 4-1: An HTML report produced by EyeWitness'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1：EyeWitness生成的HTML报告
- en: 'Additionally, the *dvga-report* will contain several folders, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*dvga-report*将包含几个文件夹，如下所示：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The *report.html* file includes information about the target, such as the HTTP
    response headers it sent back to the client, a screen capture of the application
    running on the target, and a link to the web page’s source code. While you can
    visually identify the GraphiQL IDE by using the screen capture taken by EyeWitness,
    you can also confirm your finding by searching the *source* folder, where the
    source code files reside. Run the command shown in [Listing 4-14](#listing4-14)
    to search for any GraphiQL Explorer or GraphQL Playground strings within the source
    code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*report.html*文件包含有关目标的信息，例如它返回给客户端的HTTP响应头，目标上运行的应用程序的屏幕截图，以及指向网页源代码的链接。虽然您可以通过EyeWitness拍摄的屏幕截图来直观地识别GraphiQL
    IDE，但您也可以通过搜索*source*文件夹中的源代码文件来确认您的发现。运行[列表4-14](#listing4-14)中的命令，搜索源代码中是否有GraphiQL
    Explorer或GraphQL Playground的字符串。'
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 4-14: Keyword matches in the web page source code'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-14：网页源代码中的关键字匹配
- en: Let’s break down the command to explain what’s happening here. We run a case-insensitive
    search using `grep` by passing it the `i` flag to find any instances of the words
    *graphql* or *graphql-playground* in the *source* folder. Using the `-H` flag,
    we tell `grep` to print the names of files containing any pattern matches. The
    `-n` flag indicates the line number at which the match is located (in this case,
    18). The `-o` flag prints only the parts of matching lines that yielded positive
    results. As you can see, the search found multiple instances of the string *graphiql*
    at line number 18.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个命令，解释一下这里发生了什么。我们通过传递 `i` 标志运行一个不区分大小写的 `grep` 搜索，以查找 *source* 文件夹中任何包含
    *graphql* 或 *graphql-playground* 的实例。使用 `-H` 标志，我们告诉 `grep` 打印包含任何匹配模式的文件名。`-n`
    标志表示匹配所在的行号（在此例中为 18）。`-o` 标志只打印匹配行中产生正面结果的部分。如你所见，搜索在第 18 行找到了多个 *graphiql* 字符串实例。
- en: EyeWitness can run the same type of scan against a list of URLs, as opposed
    to a single URL, using the `-f` (file) flag. When you use this flag, EyeWitness
    will expect a text file containing a list of target URLs to scan. [Listing 4-15](#listing4-15)
    shows how to write a single URL (*http://localhost:5013/graphiql*) to a text file
    (*urls.txt*) and pass it on to EyeWitness as its custom URL list.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: EyeWitness 可以针对一组 URL 运行与单个 URL 相同类型的扫描，方法是使用 `-f`（文件）标志。当使用这个标志时，EyeWitness
    会期望一个包含目标 URL 列表的文本文件进行扫描。[Listing 4-15](#listing4-15) 展示了如何将单个 URL (*http://localhost:5013/graphiql*)
    写入文本文件 (*urls.txt*)，并将其作为自定义 URL 列表传递给 EyeWitness。
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 4-15: Scanning multiple URLs with EyeWitness'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-15：使用 EyeWitness 扫描多个 URL
- en: EyeWitness iterates over the URLs specified in the file, scans them, and saves
    its output into the *dvga-report* folder for further inspection.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: EyeWitness 会遍历文件中指定的 URL，扫描它们，并将其输出保存在 *dvga-report* 文件夹中，供进一步检查。
- en: In this example, we used a file that contains only a single URL. Often, you
    may want to search for any additional web paths beyond the */graphql* endpoint
    to check whether GraphQL lives in an alternative location, particularly one that’s
    obscure. You could create a list of URLs to use with EyeWitness in multiple ways.
    The first option is to use the list of common GraphQL endpoints mentioned in “Common
    Endpoints” on page 73.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了一个只包含单个 URL 的文件。通常，你可能想要搜索除 */graphql* 端点之外的任何其他网页路径，以检查 GraphQL
    是否位于一个替代的位置，尤其是那些不太显眼的地方。你可以通过多种方式创建一个 URL 列表，并与 EyeWitness 一起使用。第一个选项是使用在第 73
    页 “常见端点” 中提到的常见 GraphQL 端点列表。
- en: Alternatively, use one of Kali’s built-in directory wordlists, located at */usr/share/wordlists*.
    One such example is the *dirbuster* wordlist. EyeWitness needs full URLs, and
    this wordlist contains only web paths, so we’d first need to format it using a
    Bash script, as shown in [Listing 4-16](#listing4-16).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用 Kali 自带的目录词表，位于 */usr/share/wordlists*。其中一个例子是 *dirbuster* 词表。EyeWitness
    需要完整的 URL，而这个词表只包含网页路径，因此我们首先需要使用 Bash 脚本对其进行格式化，如 [Listing 4-16](#listing4-16)
    所示。
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 4-16: Using Bash and a directory wordlist to build a list of URLs'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-16：使用 Bash 和目录词表构建 URL 列表
- en: This Bash `for` loop ensures that the directories in the wordlist *directory-list-2.3-small.txt*
    are appended to our target host (*http://localhost:5013*) so EyeWitness can use
    them in its scan. All that’s left is to run EyeWitness with our new wordlist file,
    *urls.txt*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Bash `for` 循环确保了词表 *directory-list-2.3-small.txt* 中的目录被附加到我们的目标主机 (*http://localhost:5013*)，以便
    EyeWitness 在扫描中使用它们。剩下的就是用我们新的词表文件 *urls.txt* 运行 EyeWitness。
- en: Attempting a Query Using Graphical Clients
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用图形化客户端尝试查询
- en: Finding instances of GraphiQL Explorer or GraphQL Playground in a penetration
    test doesn’t guarantee that the GraphQL API itself will allow you to make unauthorized
    queries. Because both GraphiQL Explorer and GraphQL Playground are simply frontend
    interfaces to a GraphQL API, they are effectively HTTP clients that interact with
    a GraphQL server.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试中发现 GraphiQL Explorer 或 GraphQL Playground 并不意味着 GraphQL API 本身允许你进行未经授权的查询。因为
    GraphiQL Explorer 和 GraphQL Playground 只是 GraphQL API 的前端界面，它们实际上是与 GraphQL 服务器交互的
    HTTP 客户端。
- en: In some cases, these graphical interfaces might fail to query the API for multiple
    reasons. An authentication or authorization layer might be implemented in the
    GraphQL API that prevents unauthorized queries. The API might also restrict queries
    based on client properties, such as geographical location or an IP address–based
    allow list. Client-side mitigations could also prevent clients from running queries
    through GraphiQL Explorer or GraphQL Playground.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这些图形化界面可能由于多种原因无法查询 API。GraphQL API 中可能会实现身份验证或授权层，阻止未授权的查询。API 还可能会基于客户端属性（如地理位置或基于
    IP 地址的允许列表）限制查询。客户端的某些防护措施也可能会阻止客户端通过 GraphiQL Explorer 或 GraphQL Playground 运行查询。
- en: To confirm that we can use the interface to query the GraphQL server, we will
    need to send some form of an unauthenticated GraphQL query. The query must be
    one that will work on any GraphQL API. Think of this query as a way to confirm
    that the remote GraphQL API is accepting unauthenticated queries from clients.
    We might call it a *canary* *GraphQL query*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认我们能够使用接口查询 GraphQL 服务器，我们需要发送某种形式的未经认证的 GraphQL 查询。该查询必须是能够在任何 GraphQL API
    上工作的查询。可以将这个查询视为确认远程 GraphQL API 是否接受来自客户端的未经认证的查询。我们可以称之为 *金丝雀* *GraphQL 查询*。
- en: Open the Firefox web browser in your lab machine and navigate to ***http://localhost:5013/***
    to access the DVGA. You should see the DVGA’s main page. Next, browse to the GraphiQL
    Explorer panel we discovered earlier at *http://localhost:5013/graphiql*. You
    will notice that we get an immediate error, indicating that our access was rejected,
    with the message `400` `Bad` `Request:` `GraphiQL` `Access` `Rejected`, as shown
    in [Figure 4-2](#figure4-2).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的实验室机器上打开 Firefox 浏览器并访问 ***http://localhost:5013/*** 以访问 DVGA。你应该能看到 DVGA
    的主页。接下来，浏览到我们之前发现的 GraphiQL Explorer 面板，地址是 *http://localhost:5013/graphiql*。你会注意到我们立即收到一个错误，表示我们的访问被拒绝，错误信息为
    `400` `Bad` `Request:` `GraphiQL` `Access` `Rejected`，如 [图 4-2](#figure4-2) 所示。
- en: '![](image_fi/502840c04/f04002.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c04/f04002.png)'
- en: 'Figure 4-2: The GraphiQL Explorer rejecting client access'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2：GraphiQL Explorer 拒绝客户端访问
- en: As hackers, it’s important to look at how things work under the hood. Click
    the **Docs** button located at the top right of the window. You should see an
    error message, `No Schema Available`. This error means that GraphiQL Explorer
    wasn’t able to retrieve schema information from the API. Because GraphiQL Explorer
    automatically sends an introspection query to the GraphQL API to populate the
    documentation section with schema information on every page load, it relies on
    this documentation being available.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 作为黑客，查看事物在后台是如何运作的非常重要。点击窗口右上角的 **Docs** 按钮。你应该看到一个错误信息，`No Schema Available`。这个错误意味着
    GraphiQL Explorer 无法从 API 获取到 schema 信息。因为 GraphiQL Explorer 会在每次页面加载时自动向 GraphQL
    API 发送 introspection 查询，以便用 schema 信息填充文档部分，它依赖于这些文档的可用性。
- en: You can see this behavior by using the Developer Tools in Firefox. Press SHIFT-F9
    or right-click anywhere in the web page and select **Inspect Element** to open
    the Developer Tools console. Click the **Network** tab; then reload the page by
    pressing F5.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 Firefox 的开发者工具来查看这一行为。按下 SHIFT-F9 或右键点击网页上的任意位置，选择 **检查元素** 来打开开发者工具控制台。点击
    **Network** 选项卡；然后按 F5 重新加载页面。
- en: You should be able to see a POST request sent to the */graphiql* endpoint. [Figure
    4-3](#figure4-3) shows this introspection query.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到一条发送到 */graphiql* 端点的 POST 请求。[图 4-3](#figure4-3) 显示了这个 introspection
    查询。
- en: '![](image_fi/502840c04/f04003.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c04/f04003.png)'
- en: 'Figure 4-3: A GraphiQL Explorer introspection query shown in Firefox Developer
    Tools'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-3：Firefox 开发者工具中显示的 GraphiQL Explorer introspection 查询
- en: If the introspection query was successfully sent, what could possibly be rejecting
    our access to GraphiQL Explorer? Let’s continue to explore the Developer Tools
    in Firefox for clues. Click the **Storage** tab, shown in [Figure 4-4](#figure4-4).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 introspection 查询成功发送，是什么原因拒绝了我们对 GraphiQL Explorer 的访问呢？让我们继续在 Firefox 开发者工具中寻找线索。点击
    **Storage** 选项卡，如 [图 4-4](#figure4-4) 所示。
- en: '![](image_fi/502840c04/f04004.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c04/f04004.png)'
- en: 'Figure 4-4: The Developer Tools Storage tab in Firefox'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-4：Firefox 开发者工具中的 Storage 选项卡
- en: The Storage tab gives us a view of the HTTP cookies that were set up by the
    application, as well as access to the browser’s local and session storage. On
    the left pane, click the **Cookies** drop-down menu and select **http://localhost:5013**
    to see the specific cookies for the domain, as shown in [Figure 4-5](#figure4-5).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 存储选项卡向我们展示了由应用程序设置的 HTTP cookies，并允许我们访问浏览器的本地存储和会话存储。在左侧窗格中，点击 **Cookies**
    下拉菜单，选择 **http://localhost:5013** 以查看该域的具体 cookies，如 [图 4-5](#figure4-5) 所示。
- en: '![](image_fi/502840c04/f04005.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c04/f04005.png)'
- en: 'Figure 4-5: HTTP cookies'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5：HTTP Cookies
- en: 'You’ll notice that, in the right pane, we have two keys set in our HTTP cookies:
    `env` and `session`. The `env` key in particular is interesting, because it appears
    to have the string `graphiql:disable` set as its value. As hackers, this should
    ring a bell or two. Is it possible that this cookie value is responsible for GraphiQL
    Explorer’s denying access? We can find out by tampering with its value.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在右侧窗格中，我们的 HTTP cookies 中设置了两个键：`env` 和 `session`。特别是 `env` 键很有趣，因为它似乎将字符串
    `graphiql:disable` 设置为其值。作为黑客，这应该引起你的警觉。这个 cookie 值是否可能是导致 GraphiQL Explorer 拒绝访问的原因？我们可以通过篡改其值来验证这一点。
- en: Double-click the text `graphiql:disable`, which will allow you to modify it;
    then simply remove `disable` and replace it with `enable`. Next, refresh the web
    page. You’ll notice that we no longer see the rejection message in GraphiQL Explorer.
    To confirm that tampering with the cookie actually works, attempt to run a GraphQL
    query. You should be able to get a response from the GraphQL API! This is an example
    of a weak client-side security control that can easily be circumvented.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 双击文本 `graphiql:disable`，这样你就可以修改它；然后只需删除 `disable` 并将其替换为 `enable`。接下来，刷新网页。你会注意到，我们不再在
    GraphiQL Explorer 中看到拒绝信息。为了确认篡改 cookie 是否有效，尝试运行一个 GraphQL 查询。你应该能够从 GraphQL
    API 获得响应！这是一个弱客户端安全控制的例子，容易被绕过。
- en: Developers often create web applications with the mindset that clients are to
    be trusted, but not everyone will play by the rules. Threat actors who are interested
    in finding loopholes will tamper with applications and attempt to defeat any countermeasures
    in place. It’s important to remember that anything an attacker can directly control
    can potentially be circumvented. Yet controls implemented on the client are not
    a rare thing to see; you may find applications implementing input validation or
    file upload validation only on the client side. These can often be bypassed. In
    Chapter 7, you’ll learn more about defeating GraphQL authorization and authentication
    mechanisms.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通常以客户端值得信任为前提来创建 Web 应用程序，但并非每个人都会遵守规则。那些试图寻找漏洞的攻击者会篡改应用程序并尝试绕过任何防护措施。重要的是要记住，攻击者能够直接控制的任何东西都有可能被绕过。然而，在客户端实施的控制措施并不少见；你可能会发现应用程序仅在客户端实现了输入验证或文件上传验证。这些措施往往可以被绕过。在第
    7 章中，你将学习如何击败 GraphQL 的授权和认证机制。
- en: Querying GraphQL by Using Introspection
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自省查询 GraphQL
- en: Introspection is one of GraphQL’s key features, as it provides information about
    the various types and fields the GraphQL schema supports. A self-documenting API
    is very useful for anyone who needs to consume it, such as third-party businesses
    or other clients.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 自省是 GraphQL 的关键功能之一，它提供了有关 GraphQL 架构所支持的各种类型和字段的信息。自文档化的 API 对于任何需要使用它的人来说都非常有用，比如第三方企业或其他客户端。
- en: As hackers, one of the first things we want to test when we run into a GraphQL
    application is whether its introspection mechanism is enabled. Many GraphQL implementations
    enable introspection by default. Some implementations might have an option to
    disable introspection, but others might not. For example, the Python GraphQL implementation
    Graphene does not provide the option to disable introspection. To do so, the consumer
    would have to dig into the code and identify ways to prevent introspection queries
    from being processed. On the other hand, the GraphQL PHP implementation graphql-php
    enables introspection by default but also documents how to completely disable
    this feature. [Table 4-2](#table4-2) shows the state of introspection in some
    of the popular GraphQL server implementations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 作为黑客，当我们遇到一个GraphQL应用时，我们最想测试的事情之一就是它的自省机制是否启用。许多GraphQL实现默认启用自省。有些实现可能提供禁用自省的选项，但其他实现则可能没有。例如，Python的GraphQL实现Graphene没有提供禁用自省的选项。要禁用自省，消费者必须深入代码，找到阻止自省查询被处理的方法。另一方面，GraphQL的PHP实现graphql-php默认启用自省，但也记录了如何完全禁用此功能。[表格
    4-2](#table4-2)展示了部分流行的GraphQL服务器实现中自省的状态。
- en: 'Table 4-2: The State of Introspection in GraphQL Implementations'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 4-2：GraphQL 实现中自省的状态
- en: '| **Language** | **Implementation** | **Introspection configuration** | **Disable
    introspection option** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **语言** | **实现** | **自省配置** | **禁用自省选项** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Python | Graphene | Enabled by default | Not available |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| Python | Graphene | 默认启用 | 不可用 |'
- en: '| Python | Ariadne | Enabled by default | Available |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| Python | Ariadne | 默认启用 | 可用 |'
- en: '| PHP | graphql-php | Enabled by default | Available |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| PHP | graphql-php | 默认启用 | 可用 |'
- en: '| Go | graphql-go | Enabled by default | Not available |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| Go | graphql-go | 默认启用 | 不可用 |'
- en: '| Ruby | graphql-ruby | Enabled by default | Available |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| Ruby | graphql-ruby | 默认启用 | 可用 |'
- en: '| Java | graphql-java | Enabled by default | Not available |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| Java | graphql-java | 默认启用 | 不可用 |'
- en: Any default setting that directly impacts security is always good news for hackers.
    Application maintainers rarely change these default settings. (Some maintainers
    may not even be aware of them.) In [Table 4-2](#table4-2), you can see that in
    some cases—such as in graphql-go, graphql-java, and Graphene—introspection can
    be disabled only if the application maintainers code the solution into the GraphQL
    API themselves; there is no official, vendor-vetted solution to disable it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 任何直接影响安全的默认设置对黑客来说都是好消息。应用程序维护者很少会更改这些默认设置。（有些维护者甚至可能不知道这些设置。）在[表格 4-2](#table4-2)中，你可以看到，在一些情况下——如graphql-go、graphql-java和Graphene——自省只能在应用程序维护者自己将解决方案编码到GraphQL
    API中时禁用；没有官方的、经过厂商验证的解决方案来禁用它。
- en: While opinions on this matter vary, especially in security circles, introspection
    in GraphQL is widely considered a feature and not a vulnerability. Companies that
    adopt GraphQL may choose to keep it enabled, while others may disable it to avoid
    disclosing information that could be leveraged in attacks. If no external consumers
    integrate with a GraphQL API, it’s possible that developers could disable introspection
    altogether without impacting normal application flows.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对此问题的看法各异，尤其是在安全圈中，但在GraphQL中，自省通常被认为是一项功能，而不是一个漏洞。采用GraphQL的公司可能会选择保持其启用，而其他公司则可能会禁用它，以避免泄露可能被用来进行攻击的信息。如果没有外部消费者与GraphQL
    API集成，开发人员可能会选择完全禁用自省，而不影响正常的应用程序流程。
- en: Depending on your target, the response to an introspection query could be fairly
    large. Also, if you’re attacking a target with a mature security program, these
    queries may be monitored for any attempts from untrusted clients, such as those
    in new geographical locations or with new IP addresses.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的目标，自省查询的响应可能会相当大。此外，如果你正在攻击一个具有成熟安全程序的目标，这些查询可能会被监控，防止来自不可信客户端的任何尝试，例如来自新地理位置或新IP地址的请求。
- en: To experiment with the introspection query by using our vulnerable server, open
    the Altair client in your lab and ensure that the address bar is set to *http://localhost:5013/graphql*.
    Next, enter the introspection query shown in [Listing 4-17](#listing4-17) and
    execute it in Altair.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过使用我们的漏洞服务器实验自省查询，请在你的实验室中打开Altair客户端，并确保地址栏设置为*http://localhost:5013/graphql*。接下来，输入在[列表
    4-17](#listing4-17)中显示的自省查询，并在Altair中执行它。
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 4-17: An introspection query in its simplest form'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-17：最简单形式的自省查询
- en: 'This query uses the meta-field `__schema`, which is the type name of the GraphQL
    schema introspection system. It then requests the `name` of all `types` available
    in the GraphQL server. The following output shows the server’s response to the
    query:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询使用了元字段`__schema`，这是GraphQL模式反射系统的类型名称。然后它请求所有在GraphQL服务器中可用的`types`的`name`。以下输出显示了服务器对该查询的响应：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While we receive a valid response, this query in its current form gives us only
    a partial view of the features available through the API. The response is missing
    key information, such as query and mutation names, information about which queries
    allow arguments to be passed by clients, the data types of arguments (such as
    scalar types like `String` [PRE24]
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们收到了有效的响应，但当前形式的查询仅提供了API功能的部分视图。响应中缺少关键信息，例如查询和变更的名称、允许客户端传递参数的查询信息、参数的数据类型（例如标量类型如`String`
    [PRE24]）。
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
