- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: '**NETWORK PROTOCOL STRUCTURES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络协议结构**'
- en: The old adage “There is nothing new under the sun” holds true when it comes
    to the way protocols are structured. Binary and text protocols follow common patterns
    and structures and, once understood, can easily be applied to any new protocol.
    This chapter details some of these structures and formalizes the way I’ll represent
    them throughout the rest of this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “天下没有新事物”这一古老的格言在协议结构的方式上得到了验证。二进制和文本协议遵循常见的模式和结构，一旦理解了这些结构，它们就能轻松应用到任何新的协议中。本章详细介绍了这些结构，并对我在本书其余部分中如何表示它们进行了形式化描述。
- en: In this chapter, I discuss many of the common types of protocol structures.
    Each is described in detail along with how it is represented in binary- or text-based
    protocols. By the end of the chapter, you should be able to easily identify these
    common types in any unknown protocol you analyze.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了许多常见的协议结构类型。每种类型都进行了详细描述，并说明了它如何在二进制或文本协议中表示。到本章结束时，你应该能够轻松识别你分析中的任何未知协议中的这些常见类型。
- en: Once you understand how protocols are structured, you’ll also see patterns of
    exploitable behavior—ways of attacking the network protocol itself. [Chapter 10](../Text/ch10.xhtml#ch10)
    will provide more detail on finding network protocol issues, but for now we’ll
    just concern ourselves with structure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了协议的结构，你还会发现一些可利用的行为模式——即攻击网络协议本身的方式。[第 10 章](../Text/ch10.xhtml#ch10)将详细介绍如何找到网络协议的问题，但现在我们只关心结构本身。
- en: '**Binary Protocol Structures**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**二进制协议结构**'
- en: Binary protocols work at the binary level; the smallest unit of data is a single
    binary digit. Dealing with single bits is difficult, so we’ll use 8-bit units
    called *octets*, commonly called *bytes*. The octet is the de facto unit of network
    protocols. Although octets can be broken down into individual bits (for example,
    to represent a set of flags), we’ll treat all network data in 8-bit units, as
    shown in [Figure 3-1](../Text/ch03.xhtml#ch3fig1).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制协议在二进制级别工作；数据的最小单位是一个二进制位。处理单个比特很困难，因此我们将使用 8 位单位，称为*字节*（octets），通常称为*字节*。字节是网络协议的事实单位。尽管字节可以被拆分成单个比特（例如，表示一组标志），但我们会将所有网络数据视为
    8 位单位，如[图 3-1](../Text/ch03.xhtml#ch3fig1)所示。
- en: '![image](../Images/f03-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-01.jpg)'
- en: '*Figure 3-1: Binary data description formats*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：二进制数据描述格式*'
- en: When showing individual bits, I’ll use the *bit format*, which shows bit 7,
    the *most significant bit (MSB)*, on the left. Bit 0, or the *least significant
    bit (LSB)*, is on the right. (Some architectures, such as PowerPC, define the
    bit numbering in the opposite direction.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示单独的位时，我会使用*位格式*，该格式将第 7 位，即*最重要位 (MSB)*，放在左侧，第 0 位或*最不重要位 (LSB)*，放在右侧。（一些架构，例如
    PowerPC，定义位编号的方向正好相反。）
- en: '***Numeric Data***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数值数据***'
- en: Data values representing numbers are usually at the core of a binary protocol.
    These values can be integers or decimal values. Numbers can be used to represent
    the length of data, to identify tag values, or simply to represent a number.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表示数字的数据值通常是二进制协议的核心。这些值可以是整数或十进制值。数字可以用来表示数据的长度、标识标签值，或者简单地表示一个数字。
- en: In binary, numeric values can be represented in a few different ways, and a
    protocol’s method of choice depends on the value it’s representing. The following
    sections describe some of the more common formats.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制中，数值可以通过几种不同的方式表示，协议选择的方式取决于它所表示的值。以下部分描述了一些更常见的格式。
- en: '**Unsigned Integers**'
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**无符号整数**'
- en: Unsigned integers are the most obvious representation of a binary number. Each
    bit has a specific value based on its position, and these values are added together
    to represent the integer. [Table 3-1](../Text/ch03.xhtml#ch3tab1) shows the decimal
    and hexadecimal values for an 8-bit integer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号整数是二进制数字最明显的表示方式。每一位都有一个基于其位置的特定值，这些值相加后便代表了整数。[表 3-1](../Text/ch03.xhtml#ch3tab1)展示了一个
    8 位整数的十进制和十六进制值。
- en: '**Table 3-1:** Decimal Bit Values'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：十进制位值**'
- en: '| **Bit** | **Decimal value** | **Hex value** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **十进制值** | **十六进制值** |'
- en: '| --- | --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 1 | 0x01 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0x01 |'
- en: '| 1 | 2 | 0x02 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 0x02 |'
- en: '| 2 | 4 | 0x04 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 4 | 0x04 |'
- en: '| 3 | 8 | 0x08 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 8 | 0x08 |'
- en: '| 4 | 16 | 0x10 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 16 | 0x10 |'
- en: '| 5 | 32 | 0x20 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 32 | 0x20 |'
- en: '| 6 | 64 | 0x40 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 64 | 0x40 |'
- en: '| 7 | 128 | 0x80 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 128 | 0x80 |'
- en: '**Signed Integers**'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**有符号整数**'
- en: Not all integer values are positive. In some scenarios, negative integers are
    required—for example, to represent the difference between two integers, you need
    to take into account that the difference could be negative—and only signed integers
    can hold negative values. While encoding an unsigned integer seems obvious, the
    CPU can only work with the same set of bits. Therefore, the CPU requires a way
    of interpreting the unsigned integer value as signed; the most common signed interpretation
    is two’s complement. The term *two’s complement* refers to the way in which the
    signed integer is represented within a native integer value in the CPU.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有整数值都是正数。在某些场景中，需要使用负整数——例如，为了表示两个整数之间的差异，需要考虑差值可能是负数——而只有有符号整数才能表示负值。虽然对无符号整数进行编码看起来很直观，但CPU只能处理相同的一组位。因此，CPU需要一种将无符号整数值解释为有符号整数的方式；最常见的有符号解释方式是二进制补码。术语*二进制补码*指的是有符号整数在CPU的本地整数值中表示的方式。
- en: Conversion between unsigned and signed values in two’s complement is done by
    taking the bitwise NOT (where a 0 bit is converted to a 1 and 1 is converted to
    a 0) of the integer and adding 1\. For example, [Figure 3-2](../Text/ch03.xhtml#ch3fig2)
    shows the 8-bit integer 123 converted to its two’s complement representation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制补码表示中，无符号值和有符号值的转换是通过对整数执行按位取反操作（将0位转换为1，将1位转换为0），然后再加上1来完成的。例如，[图3-2](../Text/ch03.xhtml#ch3fig2)展示了8位整数123转换为二进制补码表示的过程。
- en: '![image](../Images/f03-02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-02.jpg)'
- en: '*Figure 3-2: The two’s complement representation of 123*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-2：123的二进制补码表示*'
- en: The two’s complement representation has one dangerous security consequence.
    For example, an 8-bit signed integer has the range –128 to 127, so the magnitude
    of the minimum is larger than the maximum. If the minimum value is negated, the
    result is itself; in other words, –(–128) is –128\. This can cause calculations
    to be incorrect in parsed formats, leading to security vulnerabilities. We’ll
    go into more detail in [Chapter 10](../Text/ch10.xhtml#ch10).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制补码表示有一个危险的安全后果。例如，8位有符号整数的范围是-128到127，因此最小值的绝对值大于最大值。如果最小值被取反，结果将是它本身；换句话说，–(–128)就是–128。这可能导致在解析格式时计算错误，从而引发安全漏洞。我们将在[第10章](../Text/ch10.xhtml#ch10)中详细讨论这一点。
- en: '**Variable-Length Integers**'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**可变长度整数**'
- en: Efficient transfer of network data has historically been very important. Even
    though today’s high-speed networks might make efficiency concerns unnecessary,
    there are still advantages to reducing a protocol’s bandwidth. It can be beneficial
    to use variable-length integers when the most common integer values being represented
    are within a very limited range.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 网络数据的高效传输在历史上一直非常重要。尽管今天的高速网络可能使得效率问题变得不那么重要，但减少协议带宽仍然有其优势。当所表示的最常见整数值位于一个非常有限的范围内时，使用可变长度整数是有益的。
- en: 'For example, consider length fields: when sending blocks of data between 0
    and 127 bytes in size, you could use a 7-bit variable integer representation.
    [Figure 3-3](../Text/ch03.xhtml#ch3fig3) shows a few different encodings for 32-bit
    words. At most, five octets are required to represent the entire range. But if
    your protocol tends to assign values between 0 and 127, it will only use one octet,
    which saves a considerable amount of space.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑长度字段：当发送大小在0到127字节之间的数据块时，可以使用7位的可变整数表示。[图3-3](../Text/ch03.xhtml#ch3fig3)展示了32位字的几种不同编码方式。最多需要五个字节来表示整个范围。但如果你的协议倾向于分配0到127之间的值，它只需要使用一个字节，这样就节省了相当多的空间。
- en: '![image](../Images/f03-03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-03.jpg)'
- en: '*Figure 3-3: Example 7-bit integer encoding*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-3：7位整数编码示例*'
- en: That said, if you parse more than five octets (or even 32 bits), the resulting
    integer from the parsing operation will depend on the parsing program. Some programs
    (including those developed in C) will simply drop any bits beyond a given range,
    whereas other development environments will generate an overflow error. If not
    handled correctly, this integer overflow might lead to vulnerabilities, such as
    buffer overflows, which could cause a smaller than expected memory buffer to be
    allocated, in turn resulting in memory corruption.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果你解析超过五个字节（甚至是32位），从解析操作得到的整数将取决于解析程序。有些程序（包括那些用C语言开发的程序）会直接丢弃超出给定范围的位，而其他开发环境则会生成溢出错误。如果处理不当，这种整数溢出可能导致漏洞，例如缓冲区溢出，进而可能导致分配的内存缓冲区比预期的要小，从而导致内存损坏。
- en: '**Floating-Point Data**'
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**浮点数据**'
- en: Sometimes, integers aren’t enough to represent the range of decimal values needed
    for a protocol. For example, a protocol for a multiplayer computer game might
    require sending the coordinates of players or objects in the game’s virtual world.
    If this world is large, it would be easy to run up against the limited range of
    a 32- or even 64-bit fixed-point value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，整数无法表示协议所需的十进制值范围。例如，一个多人计算机游戏的协议可能需要传输玩家或游戏虚拟世界中物体的坐标。如果这个虚拟世界很大，使用32位或甚至64位定点值的有限范围就会导致问题。
- en: 'The format of floating-point integers used most often is the *IEEE format*
    specified in IEEE Standard for Floating-Point Arithmetic (IEEE 754). Although
    the standard specifies a number of different binary and even decimal formats for
    floating-point values, you’re likely to encounter only two: a single-precision
    binary representation, which is a 32-bit value; and a double-precision, 64-bit
    value. Each format specifies the position and bit size of the significand and
    exponent. A sign bit is also specified, indicating whether the value is positive
    or negative. [Figure 3-4](../Text/ch03.xhtml#ch3fig4) shows the general layout
    of an IEEE floating-point value, and [Table 3-2](../Text/ch03.xhtml#ch3tab2) lists
    the common exponent and significand sizes.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的浮点整数格式是*IEEE格式*，它在IEEE浮点算术标准（IEEE 754）中有所规定。尽管该标准规定了多种不同的二进制格式，甚至包括十进制格式，但你很可能只会遇到两种：单精度二进制表示，即32位值；以及双精度64位值。每种格式都指定了尾数和指数的位置及其位大小。还指定了符号位，用于表示值是正数还是负数。[图3-4](../Text/ch03.xhtml#ch3fig4)展示了IEEE浮点数值的一般布局，[表3-2](../Text/ch03.xhtml#ch3tab2)列出了常见的指数和尾数大小。
- en: '![image](../Images/f03-04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-04.jpg)'
- en: '*Figure 3-4: Floating-point representation*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-4：浮点数表示*'
- en: '**Table 3-2:** Common Float Point Sizes and Ranges'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-2：** 常见浮点数大小和范围'
- en: '| **Bit size** | **Exponent bits** | **Significand bits** | **Value range**
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **位大小** | **指数位** | **尾数位** | **值范围** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 32 | 8 | 23 | +/– 3.402823 × 10^(38) |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 8 | 23 | +/– 3.402823 × 10^(38) |'
- en: '| 64 | 11 | 52 | +/– 1.79769313486232 × 10^(308) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 11 | 52 | +/– 1.79769313486232 × 10^(308) |'
- en: '***Booleans***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***布尔值***'
- en: Because Booleans are very important to computers, it’s no surprise to see them
    reflected in a protocol. Each protocol determines how to represent whether a Boolean
    value is true or false, but there are some common conventions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于布尔值对计算机非常重要，因此在协议中看到它们的反映并不奇怪。每个协议都会确定如何表示布尔值是真还是假，但也有一些常见的约定。
- en: The basic way to represent a Boolean is with a single-bit value. A 0 bit means
    false and a 1 means true. This is certainly space efficient but not necessarily
    the simplest way to interface with an underlying application. It’s more common
    to use a single byte for a Boolean value because it’s far easier to manipulate.
    It’s also common to use zero to represent false and non-zero to represent true.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表示布尔值的基本方式是使用单个位的值。0位表示假，1位表示真。这种方式确实节省空间，但不一定是与底层应用接口的最简单方式。通常会使用单字节来表示布尔值，因为这样更容易处理。也常常使用0来表示假，非0值来表示真。
- en: '***Bit Flags***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***位标志***'
- en: Bit flags are one way to represent specific Boolean states in a protocol. For
    example, in TCP a set of bit flags is used to determine the current state of a
    connection. When making a connection, the client sends a packet with the synchronize
    flag (SYN) set to indicate that the connections should synchronize their timers.
    The server can then respond with an acknowledgment (ACK) flag to indicate it has
    received the client request as well as the SYN flag to establish the synchronization
    with the client. If this handshake used single enumerated values, this dual state
    would be impossible without a distinct SYN/ACK state.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 位标志是一种在协议中表示特定布尔状态的方式。例如，在TCP中，一组位标志用于确定连接的当前状态。在建立连接时，客户端发送一个带有同步标志（SYN）的数据包，表示连接应该同步它们的定时器。服务器随后可以通过一个确认标志（ACK）来响应，表示已接收到客户端的请求，同时发送SYN标志以建立与客户端的同步。如果这个握手使用单一的枚举值，这种双重状态就无法实现，因为缺少一个独立的SYN/ACK状态。
- en: '***Binary Endian***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***二进制字节序***'
- en: The endianness of data is a very important part of interpreting binary protocols
    correctly. It comes into play whenever a multi-octet value, such as a 32-bit word,
    is transferred. The endian is an artifact of how computers store data in memory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的字节序是正确解读二进制协议时非常重要的一部分。每当一个多字节的值（如32位字）被传输时，字节序就会发挥作用。字节序是计算机如何在内存中存储数据的一个副产品。
- en: Because octets are transmitted sequentially on the network, it’s possible to
    send the most significant octet of a value as the first part of the transmission,
    as well as the reverse—send the least significant octet first. The order in which
    octets are sent determines the endianness of the data. Failure to correctly handle
    the endian format can lead to subtle bugs in the parsing of protocols.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于八位字节是按顺序在网络上传输的，因此可以将值的最重要的八位字节作为传输的第一部分发送，也可以反过来——先发送最不重要的八位字节。八位字节的传输顺序决定了数据的字节序。未正确处理字节序格式可能会导致协议解析中的微妙bug。
- en: 'Modern platforms use two main endian formats: big and little. *Big endian*
    stores the most significant byte at the lowest address, whereas *little endian*
    stores the least significant byte in that location. [Figure 3-5](../Text/ch03.xhtml#ch3fig5)
    shows how the 32-bit integer 0x01020304 is stored in both forms.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现代平台使用两种主要的字节序格式：大端和小端。*大端字节序*将最重要的字节存储在最低地址处，而*小端字节序*将最不重要的字节存储在该位置。[图3-5](../Text/ch03.xhtml#ch3fig5)展示了32位整数0x01020304在这两种格式中的存储方式。
- en: '![image](../Images/f03-05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-05.jpg)'
- en: '*Figure 3-5: Big and little endian word representation*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-5：大端和小端字的表示方式*'
- en: The endianness of a value is commonly referred to as either *network order*
    or *host order*. Because the Internet RFCs invariably use big endian as the preferred
    type for all network protocols they specify (unless there are legacy reasons for
    doing otherwise), big endian is referred as network order. But your computer could
    be either big or little endian. Processor architectures such as x86 use little
    endian; others such as SPARC use big endian.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值的字节序通常被称为*网络顺序*或*主机顺序*。由于互联网RFC标准通常使用大端字节序作为所有网络协议的首选类型（除非出于历史原因另有规定），大端字节序被称为网络顺序。但你的计算机可能是大端字节序或小端字节序。像x86这样的处理器架构使用小端字节序；而像SPARC这样的架构使用大端字节序。
- en: '**NOTE**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some processor architectures, including SPARC, ARM, and MIPS, may have onboard
    logic that specifies the endianness at runtime, usually by toggling a processor
    control flag. When developing network software, make no assumptions about the
    endianness of the platform you might be running on. The networking API used to
    build an application will typically contain convenience functions for converting
    to and from these orders. Other platforms, such as PDP-11, use a *middle endian*
    format where 16-bit words are swapped; however, you’re unlikely to ever encounter
    one in everyday life, so don’t dwell on it.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些处理器架构，包括SPARC、ARM和MIPS，可能具有指定字节序的内建逻辑，通常通过切换处理器控制标志来实现。开发网络软件时，不要对可能运行的平台的字节序做出假设。用于构建应用程序的网络API通常会包含方便的函数，用于在这些字节序之间进行转换。其他平台，如PDP-11，使用*中端字节序*格式，其中16位字被交换；然而，在日常生活中你不太可能遇到这种格式，所以不必太在意它。*'
- en: '***Text and Human-Readable Data***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文本与人类可读数据***'
- en: Along with numeric data, strings are the value type you’ll most commonly encounter,
    whether they’re being used for passing authentication credentials or resource
    paths. When inspecting a protocol designed to send only English characters, the
    text will probably be encoded using ASCII. The original ASCII standard defined
    a 7-bit character set from 0 to 0x7F, which includes most of the characters needed
    to represent the English language (shown in [Figure 3-6](../Text/ch03.xhtml#ch3fig6)).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与数字数据一起，字符串是你最常遇到的值类型，无论它们是用于传递身份验证凭证还是资源路径。在检查一个仅设计用于传输英文字符的协议时，文本可能会使用ASCII编码。原始的ASCII标准定义了一个从0到0x7F的7位字符集，包含了表示英文所需的大部分字符（如[图3-6](../Text/ch03.xhtml#ch3fig6)所示）。
- en: '![image](../Images/f03-06.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-06.jpg)'
- en: '*Figure 3-6: A 7-bit ASCII table*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-6：一个7位ASCII表*'
- en: 'The ASCII standard was originally developed for text terminals (physical devices
    with a moving printing head). Control characters were used to send messages to
    the terminal to move the printing head or to synchronize serial communications
    between the computer and the terminal. The ASCII character set contains two types
    of characters: *control* and *printable*. Most of the control characters are relics
    of those devices and are virtually unused. But some still provide information
    on modern computers, such as CR and LF, which are used to end lines of text.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII标准最初是为文本终端（带有打印头的物理设备）开发的。控制字符用于向终端发送消息，以移动打印头或同步计算机与终端之间的串行通信。ASCII字符集包含两种类型的字符：*控制字符*和*可打印字符*。大多数控制字符是这些设备的遗留物，几乎没有使用。但有些字符在现代计算机中仍然提供信息，例如CR和LF，它们用于结束文本行。
- en: The printable characters are the ones you can see. This set of characters consists
    of many familiar symbols and alphanumeric characters; however, they won’t be of
    much use if you want to represent international characters, of which there are
    thousands. It’s unachievable to represent even a fraction of the possible characters
    in all the world’s languages in a 7-bit number.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可打印字符是你可以看到的字符。这些字符包括许多熟悉的符号和字母数字字符；然而，如果你想表示国际字符（其中有成千上万种字符），这些字符集就不太有用了。用7位数字表示全世界所有语言的字符，甚至其中的一部分，几乎是不可能的。
- en: 'Three strategies are commonly employed to counter this limitation: code pages,
    multibyte character sets, and Unicode. A protocol will either require that you
    use one of these three ways to represent text, or it will offer an option that
    an application can select.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这个限制，通常使用三种策略：代码页、多字节字符集和Unicode。一个协议要么要求你使用这三种方式之一来表示文本，要么提供一个选项，供应用程序选择。
- en: '**Code Pages**'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符集**'
- en: The simplest way to extend the ASCII character set is by recognizing that if
    all your data is stored in octets, 128 unused values (from 128 to 255) can be
    repurposed for storing extra characters. Although 256 values are not enough to
    store all the characters in every available language, you have many different
    ways to use the unused range. Which characters are mapped to which values is typically
    codified in specifications called *code pages* or *character encodings*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展ASCII字符集的最简单方法是通过认识到，如果你所有的数据都存储在字节中，那么128个未使用的值（从128到255）可以被重新用于存储额外的字符。虽然256个值不足以存储所有语言中的字符，但你可以通过多种方式使用这些未使用的范围。哪些字符映射到哪些值通常在名为*代码页*或*字符编码*的规范中进行编码。
- en: '**Multibyte Character Sets**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**多字节字符集**'
- en: In languages such as Chinese, Japanese, and Korean (collectively referred to
    as CJK), you simply can’t come close to representing the entire written language
    with 256 characters, even if you use all available space. The solution is to use
    multibyte character sets combined with ASCII to encode these languages. Common
    encodings are Shift-JIS for Japanese and GB2312 for simplified Chinese.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在中文、日文和韩文等语言中（统称为CJK），即使你使用所有可用的空间，也根本无法用256个字符表示整个书面语言。解决方案是将多字节字符集与ASCII结合使用来编码这些语言。常见的编码有日语的Shift-JIS和简体中文的GB2312。
- en: '*Multibyte character sets* allow you to use two or more octets in sequence
    to encode a desired character, although you’ll rarely see them in use. In fact,
    if you’re not working with CJK, you probably won’t see them at all. (For the sake
    of brevity, I won’t discuss multibyte character sets any further; plenty of online
    resources will aid you in decoding them if required.)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*多字节字符集*允许你使用两个或更多的字节序列来编码所需的字符，尽管你很少会看到它们的使用。事实上，如果你不处理CJK（中文、日文、韩文），你可能根本不会遇到它们。（为了简洁起见，我不会进一步讨论多字节字符集；如果需要解码，网上有很多资源可以帮助你。）'
- en: '**Unicode**'
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Unicode**'
- en: The Unicode standard, first standardized in 1991, aims to represent all languages
    within a unified character set. You might think of Unicode as another multibyte
    character set. But rather than focusing on a specific language, such as Shift-JIS
    does with Japanese, it tries to encode all written languages, including some archaic
    and constructed ones, into a single universal character set.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode标准最早在1991年被标准化，旨在通过一个统一的字符集表示所有语言。你可以把Unicode看作另一种多字节字符集。但与专注于特定语言的字符集（如Shift-JIS用于日语）不同，Unicode尝试将所有书面语言（包括一些古老和人工构造的语言）编码到一个通用字符集中。
- en: 'Unicode defines two related concepts: *character mapping* and *character encoding*.
    Character mappings include mappings between a numeric value and a character, as
    well as many other rules and regulations on how characters are used or combined.
    Character encodings define the way these numeric values are encoded in the underlying
    file or network protocol. For analysis purposes, it’s far more important to know
    how these numeric values are encoded.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 定义了两个相关的概念：*字符映射* 和 *字符编码*。字符映射包括数字值与字符之间的映射，以及许多关于字符如何使用或组合的规则和规范。字符编码定义了这些数字值在底层文件或网络协议中的编码方式。为了分析目的，更重要的是了解这些数字值是如何编码的。
- en: Each character in Unicode is assigned a *code point* that represents a unique
    character. Code points are commonly written in the format *U+ABCD*, where *ABCD*
    is the code point’s hexadecimal value. For the sake of compatibility, the first
    128 code points match what is specified in ASCII, and the second 128 code points
    are taken from ISO/IEC 8859-1\. The resulting value is encoded using a specific
    scheme, sometimes referred to as *Universal Character Set (UCS)* or *Unicode Transformation
    Format (UTF)* encodings. (Subtle differences exist between UCS and UTF formats,
    but for the sake of identification and manipulation, these differences are unimportant.)
    [Figure 3-7](../Text/ch03.xhtml#ch3fig7) shows a simple example of some different
    Unicode formats.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Unicode 字符都有一个 *代码点*，它表示一个唯一的字符。代码点通常以 *U+ABCD* 的格式书写，其中 *ABCD* 是代码点的十六进制值。为了兼容性，前
    128 个代码点与 ASCII 中指定的内容匹配，接下来的 128 个代码点来自 ISO/IEC 8859-1。所得的值使用特定的方案进行编码，有时称为 *通用字符集
    (UCS)* 或 *Unicode 转换格式 (UTF)* 编码。 (UCS 和 UTF 格式之间存在细微差异，但为了标识和操作，这些差异并不重要。) [图
    3-7](../Text/ch03.xhtml#ch3fig7) 显示了几种不同的 Unicode 格式的简单示例。
- en: '![image](../Images/f03-07.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-07.jpg)'
- en: '*Figure 3-7: The string `"Hello"` in different Unicode encodings*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-7：字符串 `"Hello"` 在不同 Unicode 编码中的表示*'
- en: Three common Unicode encodings in use are UTF-16, UTF-32, and UTF-8.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 三种常见的 Unicode 编码格式是 UTF-16、UTF-32 和 UTF-8。
- en: '**UCS-2/UTF-16**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**UCS-2/UTF-16**'
- en: UCS-2/UTF-16 is the native format on modern Microsoft Windows platforms, as
    well as the Java and .NET virtual machines when they are running code. It encodes
    code points in sequences of 16-bit integers and has little and big endian variants.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: UCS-2/UTF-16 是现代 Microsoft Windows 平台的本地格式，也是 Java 和 .NET 虚拟机运行代码时使用的格式。它以 16
    位整数序列对代码点进行编码，并且有小端和大端变种。
- en: '**UCS-4/UTF-32**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**UCS-4/UTF-32**'
- en: UCS-4/UTF-32 is a common format used in Unix applications because it’s the default
    wide-character format in many C/C++ compilers. It encodes code points in sequences
    of 32-bit integers and has different endian variants.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: UCS-4/UTF-32 是 Unix 应用程序中常用的一种格式，因为它是许多 C/C++ 编译器中的默认宽字符格式。它以 32 位整数序列对代码点进行编码，并且有不同的字节序变种。
- en: '**UTF-8**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**UTF-8**'
- en: UTF-8 is probably the most common format on Unix. It is also the default input
    and output format for varying platforms and technologies, such as XML. Rather
    than having a fixed integer size for code points, it encodes them using a simple
    variable length value. [Table 3-3](../Text/ch03.xhtml#ch3tab3) shows how code
    points are encoded in UTF-8.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 可能是 Unix 上最常见的格式。它也是许多平台和技术的默认输入输出格式，如 XML。与为代码点设定固定整数大小不同，它使用简单的可变长度值进行编码。[表
    3-3](../Text/ch03.xhtml#ch3tab3) 显示了代码点在 UTF-8 中的编码方式。
- en: '**Table 3-3:** Encoding Rules for Unicode Code Points in UTF-8'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-3：** UTF-8 中的 Unicode 代码点编码规则'
- en: '| **Bits of code point** | **First code point (U+)** | **Last code point (U+)**
    | **Byte 1** | **Byte 2** | **Byte 3** | **Byte 4** |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **代码点位数** | **第一个代码点 (U+)** | **最后一个代码点 (U+)** | **字节 1** | **字节 2** | **字节
    3** | **字节 4** |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0–7 | 0000 | 007F | 0xxxxxxx |  |  |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 0–7 | 0000 | 007F | 0xxxxxxx |  |  |  |'
- en: '| 8–11 | 0080 | 07FF | 110xxxxx | 10xxxxxx |  |  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 8–11 | 0080 | 07FF | 110xxxxx | 10xxxxxx |  |  |'
- en: '| 12–16 | 0800 | FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 12–16 | 0800 | FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |  |'
- en: '| 17–21 | 10000 | 1FFFFF | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 17–21 | 10000 | 1FFFFF | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |'
- en: '| 22–26 | 200000 | 3FFFFFF | 111110xx | 10xxxxxx | 10xxxxxx | 10xxxxxx |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 22–26 | 200000 | 3FFFFFF | 111110xx | 10xxxxxx | 10xxxxxx | 10xxxxxx |'
- en: '| 26–31 | 4000000 | 7FFFFFFF | 1111110x | 10xxxxxx | 10xxxxxx | 10xxxxxx |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 26–31 | 4000000 | 7FFFFFFF | 1111110x | 10xxxxxx | 10xxxxxx | 10xxxxxx |'
- en: UTF-8 has many advantages. For one, its encoding definition ensures that the
    ASCII character set, code points U+0000 through U+007F, are encoded using single
    bytes. This scheme makes this format not only ASCII compatible but also space
    efficient. In addition, UTF-8 is compatible with C/C++ programs that rely on NUL-terminated
    strings.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8有许多优点。首先，它的编码定义确保了ASCII字符集（码点U+0000到U+007F）使用单字节进行编码。这种方案使得该格式不仅与ASCII兼容，而且还非常节省空间。此外，UTF-8还与依赖NUL终止字符串的C/C++程序兼容。
- en: For all of its benefits, UTF-8 does come at a cost, because languages like Chinese
    and Japanese consume more space than they do in UTF-16\. [Figure 3-8](../Text/ch03.xhtml#ch3fig8)
    shows such a disadvantageous encoding of Chinese characters. But notice that the
    UTF-8 in this example is still more space efficient than the UTF-32 for the same
    characters.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管UTF-8有很多优点，但它也有一定的成本，因为像中文和日文这样的语言在UTF-8中占用的空间比在UTF-16中要大。[图3-8](../Text/ch03.xhtml#ch3fig8)展示了中文字符的一种不太优的编码方式。但请注意，这个例子中的UTF-8编码仍然比UTF-32编码在相同字符上的空间效率要高。
- en: '![image](../Images/f03-08.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-08.jpg)'
- en: '*Figure 3-8: The string* "兔子" *in different Unicode encodings*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-8: 字符串* "兔子" *在不同Unicode编码下的表现*'
- en: '**NOTE**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Incorrect or naive character encoding can be a source of subtle security issues,
    ranging from bypassing filtering mechanisms (say in a requested resource path)
    to causing buffer overflows. We’ll investigate some of the vulnerabilities associated
    with character encoding in [Chapter 10](../Text/ch10.xhtml#ch10).*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*不正确或天真的字符编码可能是微妙的安全问题的源头，这些问题包括绕过过滤机制（例如在请求的资源路径中）或导致缓冲区溢出。我们将在[第10章](../Text/ch10.xhtml#ch10)中调查与字符编码相关的一些漏洞。*'
- en: '***Variable Binary Length Data***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***变长二进制数据***'
- en: 'If the protocol developer knows in advance exactly what data must be transmitted,
    they can ensure that all values within the protocol are of a fixed length. In
    reality this is quite rare, although even simple authentication credentials would
    benefit from the ability to specify variable username and password string lengths.
    Protocols use several strategies to produce variable-length data values: I discuss
    the most common—terminated data, length-prefixed data, implicit-length data, and
    padded data—in the following sections.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果协议开发人员事先确切知道必须传输哪些数据，他们可以确保协议中的所有值都是固定长度的。实际上，这种情况很少见，尽管即便是简单的认证凭证也可以从能够指定可变用户名和密码字符串长度的功能中受益。协议使用几种策略来生成变长数据值：我将在接下来的章节中讨论最常见的几种——终止数据、长度前缀数据、隐式长度数据和填充数据。
- en: '**Terminated Data**'
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**终止数据**'
- en: You saw an example of variable-length data when variable-length integers were
    discussed earlier in this chapter. The variable-length integer value was terminated
    when the octet’s MSB was 0\. We can extend the concept of terminating values further
    to elements like strings or data arrays.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之前讨论变长整数时，你已经看到了一个变长数据的示例。当时，变长整数值通过八位字节的最高有效位（MSB）为0来终止。我们可以进一步扩展终止值的概念，应用到字符串或数据数组等元素上。
- en: A terminated data value has a terminal symbol defined that tells the data parser
    that the end of the data value has been reached. The terminal symbol is used because
    it’s unlikely to be present in typical data, ensuring that the value isn’t terminated
    prematurely. With string data, the terminating value can be a NUL value (represented
    by 0) or one of the other control characters in the ASCII set.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 终止数据值具有一个终止符号，该符号告诉数据解析器数据值已经结束。使用终止符号的原因是它通常不会出现在典型的数据中，从而确保数据值不会被提前终止。对于字符串数据，终止值可以是一个NUL值（由0表示），也可以是ASCII字符集中的其他控制字符之一。
- en: If the terminal symbol chosen occurs during normal data transfer, you need to
    use a mechanism to escape these symbols. With strings, it’s common to see the
    terminating character either prefixed with a backslash (`\`) or repeated twice
    to prevent it from being identified as the terminal symbol. This approach is especially
    useful when a protocol doesn’t know ahead of time how long a value is—for example,
    if it’s generated dynamically. [Figure 3-9](../Text/ch03.xhtml#ch3fig9) shows
    an example of a string terminated by a NUL value.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所选的终止符号在正常数据传输过程中出现，你需要使用一种机制来转义这些符号。对于字符串，常见的做法是将终止字符前加反斜杠（`\`）或重复两次，以防止它被识别为终止符号。当协议无法事先知道数据值的长度时，这种方法尤其有用——例如，如果数据是动态生成的。[图3-9](../Text/ch03.xhtml#ch3fig9)展示了一个由NUL值终止的字符串示例。
- en: '![image](../Images/f03-09.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-09.jpg)'
- en: '*Figure 3-9: `"Hello"` as a NUL-terminated string*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-9: `"Hello"` 作为NUL终止字符串*'
- en: Bounded data is often terminated by a symbol that matches the first character
    in the variable-length sequence. For example, when using string data, you might
    find a *quoted string* sandwiched between quotation marks. The initial double
    quote tells the parser to look for the matching character to end the data. [Figure
    3-10](../Text/ch03.xhtml#ch3fig10) shows a string bounded by a pair of double
    quotes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有界数据通常通过一个符号来结束，该符号与可变长度序列中的第一个字符相匹配。例如，当使用字符串数据时，你可能会看到一个*带引号的字符串*夹在引号之间。初始的双引号告诉解析器查找匹配的字符以结束数据。[图
    3-10](../Text/ch03.xhtml#ch3fig10)显示了一个由一对双引号界定的字符串。
- en: '![image](../Images/f03-10.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-10.jpg)'
- en: '*Figure 3-10: `"Hello"` as a double-quoted bounded string*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-10: `"Hello"` 作为一个由双引号界定的字符串*'
- en: '**Length-Prefixed Data**'
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**长度前缀数据**'
- en: If a data value is known in advance, it’s possible to insert its length into
    the protocol directly. The protocol’s parser can read this value and then read
    the appropriate number of units (say characters or octets) to extract the original
    value. This is a very common way to specify variable-length data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据值事先已知，可以将其长度直接插入到协议中。协议的解析器可以读取这个值，然后读取适当数量的单元（例如字符或字节）来提取原始值。这是一种非常常见的指定可变长度数据的方法。
- en: The actual size of the *length prefix* is usually not that important, although
    it should be reasonably representative of the types of data being transmitted.
    Most protocols won’t need to specify the full range of a 32-bit integer; however,
    you’ll often see that size used as a length field, if only because it fits well
    with most processor architectures and platforms. For example, [Figure 3-11](../Text/ch03.xhtml#ch3fig11)
    shows a string with an 8-bit length prefix.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*长度前缀*的实际大小通常不是很重要，尽管它应该合理地代表所传输数据的类型。大多数协议不需要指定32位整数的完整范围；然而，你常常会看到这个大小被用作长度字段，部分原因是它与大多数处理器架构和平台非常匹配。例如，[图
    3-11](../Text/ch03.xhtml#ch3fig11)显示了一个带有8位长度前缀的字符串。'
- en: '![image](../Images/f03-11.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-11.jpg)'
- en: '*Figure 3-11: `"Hello"` as a length-prefixed string*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-11: `"Hello"` 作为一个长度前缀字符串*'
- en: '**Implicit-Length Data**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**隐式长度数据**'
- en: Sometimes the length of the data value is implicit in the values around it.
    For example, think of a protocol that is sending data back to a client using a
    connection-oriented protocol such as TCP. Rather than specifying the size of the
    data up front, the server could close the TCP connection, thus implicitly signifying
    the end of the data. This is how data is returned in an HTTP version 1.0 response.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有时数据值的长度是由其周围的值隐式表示的。例如，考虑一个协议，它使用面向连接的协议（如TCP）将数据发送回客户端。服务器可以关闭TCP连接，从而隐式地表示数据的结束，而无需事先指定数据的大小。这就是HTTP
    1.0响应中数据返回的方式。
- en: Another example would be a higher-level protocol or structure that has already
    specified the length of a set of values. The parser might extract that higher-level
    structure first and then read the values contained within it. The protocol could
    use the fact that this structure has a finite length associated with it to implicitly
    calculate the length of a value in a similar fashion to close the connection (without
    closing it, of course). For example, [Figure 3-12](../Text/ch03.xhtml#ch3fig12)
    shows a trivial example where a 7-bit variable integer and string are contained
    within a single block. (Of course, in practice, this can be considerably more
    complex.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是一个更高级的协议或结构，已经指定了一组值的长度。解析器可能首先提取该高级结构，然后读取其中包含的值。协议可以利用这个结构有一个有限长度的事实，类似于关闭连接的方式来隐式计算一个值的长度（当然，是不关闭连接的）。例如，[图
    3-12](../Text/ch03.xhtml#ch3fig12)显示了一个简单的示例，其中一个7位可变整数和字符串包含在一个单独的块中。（当然，在实际应用中，这可能要复杂得多。）
- en: '![image](../Images/f03-12.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-12.jpg)'
- en: '*Figure 3-12: `"Hello"` as an implicit-length string*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-12: `"Hello"` 作为一个隐式长度字符串*'
- en: '**Padded Data**'
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**填充数据**'
- en: Padded data is used when there is a maximum upper bound on the length of a value,
    such as a 32-octet limit. For the sake of simplicity, rather than prefixing the
    value with a length or having an explicit terminating value, the protocol could
    instead send the entire fixed-length string but terminate the value by padding
    the unused data with a known value. [Figure 3-13](../Text/ch03.xhtml#ch3fig13)
    shows an example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 填充数据用于当值的长度有最大上限时，例如32字节的限制。为了简化，协议可以不使用长度前缀或明确的终止值，而是发送整个固定长度的字符串，并通过用已知值填充未使用的数据来终止值。[图
    3-13](../Text/ch03.xhtml#ch3fig13)显示了一个示例。
- en: '![image](../Images/f03-13.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-13.jpg)'
- en: '*Figure 3-13: `"Hello"` as a `''$''` padded string*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-13：“`Hello`”作为一个用 `''$''` 填充的字符串*'
- en: '**Dates and Times**'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**日期和时间**'
- en: It can be very important for a protocol to get the correct date and time. Both
    can be used as metadata, such as file modification timestamps in a network file
    protocol, as well as to determine the expiration of authentication credentials.
    Failure to correctly implement the timestamp might cause serious security issues.
    The method of date and time representation depends on usage requirements, the
    platform the applications are running on, and the protocol’s space requirements.
    I discuss two common representations, POSIX/Unix Time and Windows FILETIME, in
    the following sections.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个协议来说，获取正确的日期和时间可能非常重要。两者都可以作为元数据使用，例如网络文件协议中的文件修改时间戳，也可以用于确定身份验证凭证的过期时间。如果时间戳未正确实现，可能会导致严重的安全问题。日期和时间的表示方法取决于使用需求、应用程序运行的平台以及协议的空间需求。接下来的章节将讨论两种常见的表示方式：POSIX/Unix
    时间和 Windows FILETIME。
- en: '***POSIX/Unix Time***'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***POSIX/Unix 时间***'
- en: Currently, POSIX/Unix time is stored as a 32-bit signed integer value representing
    the number of seconds that have elapsed since the Unix epoch, which is usually
    specified as 00:00:00 (UTC), 1 January 1970\. Although this isn’t a high-definition
    timer, it’s sufficient for most scenarios. As a 32-bit integer, this value is
    limited to 03:14:07 (UTC) 19 January 2038, at which point the representation will
    overflow. Some modern operating systems now use a 64-bit representation to address
    this problem.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，POSIX/Unix 时间存储为一个 32 位带符号整数值，表示自 Unix 纪元以来经过的秒数，Unix 纪元通常指定为 1970 年 1 月
    1 日 00:00:00（UTC）。尽管这不是一个高精度的定时器，但它足以满足大多数场景。作为一个 32 位整数，这个值的最大表示时间为 2038 年 1
    月 19 日 03:14:07（UTC），此时表示将发生溢出。一些现代操作系统现在使用 64 位表示法来解决这个问题。
- en: '***Windows FILETIME***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Windows FILETIME***'
- en: The Windows FILETIME is the date and time format used by Microsoft Windows for
    its filesystem timestamps. As the only format on Windows with simple binary representation,
    it also appears in a few different protocols.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Windows FILETIME 是微软 Windows 用于其文件系统时间戳的日期和时间格式。作为 Windows 上唯一具有简单二进制表示形式的格式，它也出现在一些不同的协议中。
- en: The FILETIME format is a 64-bit unsigned integer. One unit of the integer represents
    a 100 ns interval. The epoch of the format is 00:00:00 (UTC), 1 January 1601\.
    This gives the FILETIME format a larger range than the POSIX/Unix time format.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: FILETIME 格式是一个 64 位无符号整数。该整数的一个单位表示 100 纳秒的时间间隔。该格式的起始时间为 1601 年 1 月 1 日 00:00:00（UTC）。这使得
    FILETIME 格式的时间范围比 POSIX/Unix 时间格式更大。
- en: '**Tag, Length, Value Pattern**'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**标签、长度、值模式**'
- en: It’s easy to imagine how one might send unimportant data using simple protocols,
    but sending more complex and important data takes some explaining. For example,
    a protocol that can send different types of structures must have a way to represent
    the bounds of a structure and its type.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下如何使用简单的协议发送不重要的数据是很容易的，但发送更复杂和重要的数据则需要一些解释。例如，能够发送不同类型结构的协议必须有一种方式来表示结构的边界和类型。
- en: One way to represent data is with a *Tag, Length, Value (TLV) pattern*. The
    Tag value represents the type of data being sent by the protocol, which is commonly
    a numeric value (usually an enumerated list of possible values). But the Tag can
    be anything that provides the data structures with a unique pattern. The Length
    and Value are variable-length values. The order in which the values appear isn’t
    important; in fact, the Tag might be part of the Value. [Figure 3-14](../Text/ch03.xhtml#ch3fig14)
    show a couple of ways these values could be arranged.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 表示数据的一种方式是使用 *标签、长度、值（TLV）模式*。标签值表示协议发送的数据类型，通常是一个数字值（通常是一个枚举值列表）。但标签可以是任何为数据结构提供唯一模式的内容。长度和值是可变长度的值。这些值出现的顺序不重要；事实上，标签可能是值的一部分。[图
    3-14](../Text/ch03.xhtml#ch3fig14) 显示了这些值可能的几种排列方式。
- en: The Tag value sent can be used to determine how to further process the data.
    For example, given two types of Tags, one that indicates the authentication credentials
    to the application and another that represents a message being transmitted to
    the parser, we must be able to distinguish between the two types of data. One
    big advantage to this pattern is that it allows us to extend a protocol without
    breaking applications that have not been updated to support the updated protocol.
    Because each structure is sent with an associated Tag and Length, a protocol parser
    could ignore the structures that it doesn’t understand.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 发送的标签值可以用来确定如何进一步处理数据。例如，给定两种标签类型，一种表示发送给应用程序的身份验证凭证，另一种表示传输到解析器的消息，我们必须能够区分这两种数据类型。这种模式的一个大优点是，它允许我们扩展协议，而不会破坏那些尚未更新以支持更新协议的应用程序。由于每个结构都与一个标签和长度相关联，协议解析器可以忽略它不理解的结构。
- en: '![image](../Images/f03-14.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-14.jpg)'
- en: '*Figure 3-14: Possible TLV arrangements*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-14：可能的TLV排列*'
- en: '**Multiplexing and Fragmentation**'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**多路复用与分片**'
- en: 'Often in computer communication, multiple tasks must happen at once. For example,
    consider the Microsoft *Remote Desktop Protocol (RDP)*: a user could be moving
    the mouse cursor, typing on the keyboard, and transferring files to a remote computer
    while changes in the display and audio are being transmitted back to the user
    (see [Figure 3-15](../Text/ch03.xhtml#ch3fig15)).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机通信中，通常需要同时执行多个任务。例如，考虑微软的*远程桌面协议（RDP）*：用户可能在移动鼠标光标、键盘输入以及将文件传输到远程计算机的同时，显示和音频的变化也会回传给用户（见[图3-15](../Text/ch03.xhtml#ch3fig15)）。
- en: '![image](../Images/f03-15.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-15.jpg)'
- en: '*Figure 3-15: Data needs for Remote Desktop Protocol*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-15：远程桌面协议的数据需求*'
- en: This complex data transfer would not result in a very rich experience if display
    updates had to wait for a 10-minute audio file to finish before updating the display.
    Of course, a workaround would be opening multiple connections to the remote computer,
    but those would use more resources. Instead, many protocols use *multiplexing*,
    which allows multiple connections to share the same underlying network connection.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果显示更新必须等待一个10分钟的音频文件完成后才能更新显示，那么这种复杂的数据传输将无法带来丰富的体验。当然，解决方法是打开多个与远程计算机的连接，但这样会消耗更多资源。相反，许多协议使用*多路复用*，它允许多个连接共享相同的底层网络连接。
- en: Multiplexing (shown in [Figure 3-16](../Text/ch03.xhtml#ch3fig16)) defines an
    internal *channel* mechanism that allows a single connection to host multiple
    types of traffic by fragmenting large transmissions into smaller chunks. Multiplexing
    then combines these chunks into a single connection. When analyzing a protocol,
    you may need to demultiplex these channels to get the original data back out.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 多路复用（见[图3-16](../Text/ch03.xhtml#ch3fig16)）定义了一种内部的*通道*机制，允许通过将大规模传输拆分为更小的块，从而使单一连接能够承载多种类型的流量。然后，多路复用将这些数据块合并成一个单一的连接。在分析协议时，你可能需要将这些通道解复用，以便恢复原始数据。
- en: '![image](../Images/f03-16.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-16.jpg)'
- en: '*Figure 3-16: Multiplexed RDP data*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-16：多路复用的RDP数据*'
- en: 'Unfortunately, some network protocols restrict the type of data that can be
    transmitted and how large each packet of data can be—a problem commonly encountered
    when layering protocols. For example, Ethernet defines the maximum size of traffic
    frames as 1500 octets, and running IP on top of that causes problems because the
    maximum size of IP packets can be 65536 bytes. *Fragmentation* is designed to
    solve this problem: it uses a mechanism that allows the network stack to convert
    large packets into smaller fragments when the application or OS knows that the
    entire packet cannot be handled by the next layer.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，一些网络协议限制了可以传输的数据类型以及每个数据包的最大大小——这是在协议层次化时常见的问题。例如，以太网定义了流量帧的最大大小为1500个字节，而在其上运行IP时会产生问题，因为IP数据包的最大大小可以达到65536字节。*分片*是为了解决这个问题而设计的：它使用一种机制，使得网络栈能够在应用程序或操作系统知道整个数据包无法由下一层处理时，将大数据包转化为更小的片段。
- en: '**Network Address Information**'
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络地址信息**'
- en: The representation of network address information in a protocol usually follows
    a fairly standard format. Because we’re almost certainly dealing with TCP or UDP
    protocols, the most common binary representation is the IP address as either a
    4- or 16-octet value (for IPv4 or IPv6) along with a 2-octet port. By convention,
    these values are typically stored as big endian integer values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 协议中网络地址信息的表示通常遵循一个相当标准的格式。因为我们几乎肯定在处理 TCP 或 UDP 协议，所以最常见的二进制表示是将 IP 地址表示为一个
    4 字节或 16 字节的值（对于 IPv4 或 IPv6），并附带一个 2 字节的端口。根据惯例，这些值通常作为大端整数值存储。
- en: You might also see hostnames sent instead of raw addresses. Because hostnames
    are just strings, they follow the patterns used for sending variable-length strings,
    which was discussed earlier in “[Variable Binary Length Data](../Text/ch03.xhtml#ch00lev1sec62)”
    on [page 47](../Text/ch03.xhtml#page_47). [Figure 3-17](../Text/ch03.xhtml#ch3fig17)
    shows how some of these formats might appear.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能看到主机名被发送，而不是原始地址。因为主机名仅仅是字符串，它们遵循用于发送变长字符串的模式，这在前面“[变长二进制数据](../Text/ch03.xhtml#ch00lev1sec62)”一节的[第
    47 页](../Text/ch03.xhtml#page_47)中讨论过。[图 3-17](../Text/ch03.xhtml#ch3fig17)展示了这些格式可能出现的样子。
- en: '![image](../Images/f03-17.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-17.jpg)'
- en: '*Figure 3-17: Network information in binary*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-17：网络信息的二进制表示*'
- en: '**Structured Binary Formats**'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结构化二进制格式**'
- en: Although custom network protocols have a habit of reinventing the wheel, sometimes
    it makes more sense to repurpose existing designs when describing a new protocol.
    For example, one common format encountered in binary protocols is *Abstract Syntax
    Notation 1 (ASN.1)*. ASN.1 is the basis for protocols such as the Simple Network
    Management Protocol (SNMP), and it is the encoding mechanism for all manner of
    cryptographic values, such as X.509 certificates.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自定义网络协议往往喜欢重新发明轮子，但有时在描述新协议时，重新利用现有设计会更有意义。例如，在二进制协议中常见的一种格式是*抽象语法表示法 1 (ASN.1)*。ASN.1
    是诸如简单网络管理协议 (SNMP) 等协议的基础，它也是所有种类的加密值的编码机制，如 X.509 证书。
- en: ASN.1 is standardized by the ISO, IEC, and ITU in the X.680 series. It defines
    an abstract syntax to represent structured data. Data is represented in the protocol
    depending on the encoding rules, and numerous encodings exist. But you’re most
    likely to encounter the *Distinguished Encoding Rules (DER)*, which is designed
    to represent ASN.1 structures in a way that cannot be misinterpreted—a useful
    property for cryptographic protocols. The DER representation is a good example
    of a TLV protocol.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ASN.1 由 ISO、IEC 和 ITU 在 X.680 系列中标准化。它定义了一种抽象语法来表示结构化数据。数据在协议中根据编码规则进行表示，并且存在多种编码方式。但你最有可能遇到的是*区分编码规则
    (DER)*，它被设计为以一种不会被误解的方式表示 ASN.1 结构——这是加密协议中非常有用的特性。DER 表示法是 TLV 协议的一个很好的例子。
- en: Rather than going into great detail about ASN.1 (which would take up a fair
    amount of this book), I give you [Listing 3-1](../Text/ch03.xhtml#ch3list1), which
    shows the ASN.1 for X.509 certificates.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是详细讲解 ASN.1（这会占用本书相当多的篇幅），我给你提供了[列表 3-1](../Text/ch03.xhtml#ch3list1)，它展示了
    X.509 证书的 ASN.1 表示。
- en: '[PRE0]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 3-1: ASN.1 representation for X.509 certificates*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-1：X.509 证书的 ASN.1 表示*'
- en: This abstract definition of an X.509 certificate can be represented in any of
    ASN.1’s encoding formats. [Listing 3-2](../Text/ch03.xhtml#ch3list2) shows a snippet
    of the DER encoded form dumped as text using the OpenSSL utility.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: X.509 证书的这个抽象定义可以用 ASN.1 的任何编码格式表示。[列表 3-2](../Text/ch03.xhtml#ch3list2)展示了通过
    OpenSSL 工具转储的 DER 编码形式的文本片段。
- en: '[PRE1]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 3-2: A small sample of X.509 certificate*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-2：X.509 证书的小样本*'
- en: '**Text Protocol Structures**'
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**文本协议结构**'
- en: Text protocols are a good choice when the main purpose is to transfer text,
    which is why mail transfer protocols, instant messaging, and news aggregation
    protocols are usually text based. Text protocols must have structures similar
    to binary protocols. The reason is that, although their main content differs,
    both share the goal of transferring data from one place to another.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当主要目的是传输文本时，文本协议是一个不错的选择，这也是邮件传输协议、即时消息和新闻聚合协议通常采用文本基础的原因。文本协议必须具有类似于二进制协议的结构。原因是，尽管它们的主要内容不同，但两者的目标都是将数据从一个地方传输到另一个地方。
- en: The following section details some common text protocol structures that you’ll
    likely encounter in the real world.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节详细介绍了一些你在现实世界中可能遇到的常见文本协议结构。
- en: '***Numeric Data***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数字数据***'
- en: Over the millennia, science and written languages have invented ways to represent
    numeric values in textual format. Of course, computer protocols don’t need to
    be human readable, but why go out of your way just to prevent a protocol from
    being readable (unless your goal is deliberate obfuscation).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 几千年来，科学和书面语言发明了在文本格式中表示数值的方法。当然，计算机协议不需要人类可读，但为什么要特意让协议不可读呢（除非你的目标是故意混淆）。
- en: '**Integers**'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**整数**'
- en: It’s easy to represent integer values using the current character set’s representation
    of the characters 0 through 9 (or A through F if hexadecimal). In this simple
    representation, size limitations are no concern, and if a number needs to be larger
    than a binary word size, you can add digits. Of course, you’d better hope that
    the protocol parser can handle the extra digits or security issues will inevitably
    occur.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用当前字符集表示字符0到9（如果是十六进制则是A到F）来表示整数值是很容易的。在这种简单的表示法中，大小限制不是问题，如果一个数字需要大于二进制字长，可以添加更多的数字。当然，你最好希望协议解析器能够处理额外的数字，否则安全问题将不可避免地发生。
- en: To make a signed number, you add the minus (`–`) character to the front of the
    number; the plus (`+`) symbol for positive numbers is implied.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示一个带符号的数字，你只需在数字前加上减号（`–`）；正数使用加号（`+`）符号则是隐含的。
- en: '**Decimal Numbers**'
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**十进制数字**'
- en: Decimal numbers are usually defined using human-readable forms. For example,
    you might write a number as 1.234, using the dot character to separate the integer
    and fractional components of the number; however, you’ll still need to consider
    the requirement of parsing a value afterward.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制数字通常以人类可读的形式定义。例如，你可能会将一个数字写成1.234，用点号将整数部分和小数部分分开；然而，你仍然需要考虑之后解析值的要求。
- en: Binary representations, such as floating point, can’t represent all decimal
    values precisely with finite precision (just as decimals can’t represent numbers
    like 1/3). This fact can make some values difficult to represent in text format
    and can cause security issues, especially when values are compared to one another.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制表示法，如浮点数，无法用有限精度精确表示所有十进制值（就像十进制无法表示像1/3这样的数）。这个事实可能导致一些值在文本格式中难以表示，并可能引发安全问题，尤其是在进行值比较时。
- en: '***Text Booleans***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文本布尔值***'
- en: Booleans are easy to represent in text protocols. Usually, they’re represented
    using the words *true* or *false*. But just to be difficult, some protocols might
    require that words be capitalized exactly to be valid. And sometimes integer values
    will be used instead of words, such as 0 for false and 1 for true, but not very
    often.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值在文本协议中容易表示。通常，它们用*true*或*false*这两个词表示。但为了增加难度，一些协议可能要求这些词必须完全大写才能有效。有时，整数值会被用来代替词语，比如0代表假，1代表真，但这种情况并不常见。
- en: '***Dates and Times***'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***日期和时间***'
- en: 'At a simple level, it’s easy to encode dates and times: just represent them
    as they would be written in a human-readable language. As long as all applications
    agree on the representation, that should suffice.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的层面上，编码日期和时间很容易：只需像人类语言中那样表示它们即可。只要所有应用程序在表示上达成一致，这就足够了。
- en: Unfortunately, not everyone can agree on a standard format, so typically many
    competing date representations are in use. This can be a particularly acute issue
    in applications such as mail clients, which need to process all manner of international
    date formats.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并不是每个人都能就标准格式达成一致，因此通常会使用许多竞争性的日期表示方式。这在一些应用程序中可能会成为一个特别严重的问题，尤其是邮件客户端，它们需要处理各种国际日期格式。
- en: '***Variable-Length Data***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可变长度数据***'
- en: All but the most trivial protocols must have a way to separate important text
    fields so they can be easily interpreted. When a text field is separated out of
    the original protocol, it’s commonly referred to as a *token*. Some protocols
    specify a fixed length for tokens, but it’s far more common to require some type
    of variable-length data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最简单的协议外，几乎所有协议都必须有一种方法来分隔重要的文本字段，以便它们可以被轻松解释。当一个文本字段从原始协议中分离出来时，通常称之为*标记*。一些协议指定了标记的固定长度，但更常见的是要求某种类型的可变长度数据。
- en: '**Delimited Text**'
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定界文本**'
- en: Separating tokens with delimiting characters is a very common way to separate
    tokens and fields that’s simple to understand and easy to construct and parse.
    Any character can be used as the delimiter (depending on the type of data being
    transferred), but whitespace is encountered most in human-readable formats. That
    said, the delimiter doesn’t have to be whitespace. For example, the Financial
    Information Exchange (FIX) protocol delimits tokens using the ASCII Start of Header
    (SOH) character with a value of 1.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分隔符字符分隔标记是分隔标记和字段的一种非常常见的方式，这种方式简单易懂，且容易构建和解析。任何字符都可以作为分隔符（具体取决于传输的数据类型），但在可读性较强的格式中，空白字符最为常见。不过，分隔符不一定非得是空白字符。例如，金融信息交换（FIX）协议使用ASCII头部起始（SOH）字符（值为1）来分隔标记。
- en: '**Terminated Text**'
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**终止文本**'
- en: Protocols that specify a way to separate individual tokens must also have a
    way to define an End of Command condition. If a protocol is broken into separate
    lines, the lines must be terminated in some way. Most well-known, text-based Internet
    protocols are *line oriented*, such as HTTP and IRC; lines typically delimit entire
    structures, such as the end of a command.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 指定分隔单独标记方式的协议还必须有定义“命令结束”条件的方法。如果协议被分成单独的行，这些行必须以某种方式结束。大多数知名的基于文本的互联网协议是*按行处理的*，如HTTP和IRC；这些行通常用来区分完整的结构，如命令的结束。
- en: What constitutes the end-of-line character? That depends on whom you ask. OS
    developers usually define the end-of-line character as either the ASCII *Line
    Feed (LF)*, which has the value 10; the *Carriage Return (CR)* with the value
    13; or the combination CR LF. Protocols such as HTTP and Simple Mail Transfer
    Protocol (SMTP) specify CR LF as the official end-of-line combination. However,
    so many incorrect implementations occur that most parsers will also accept a bare
    LF as the end-of-line indication.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 什么构成了行尾字符？这取决于你问的是谁。操作系统开发者通常将行尾字符定义为ASCII *换行符（LF）*，其值为10；或*回车符（CR）*，其值为13；或者是CR
    LF的组合。像HTTP和简单邮件传输协议（SMTP）这样的协议将CR LF指定为官方的行尾组合。然而，许多错误的实现会发生，因此大多数解析器也会接受单独的LF作为行尾指示符。
- en: '***Structured Text Formats***'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结构化文本格式***'
- en: As with structured binary formats such ASN.1, there is normally no reason to
    reinvent the wheel when you want to represent structured data in a text protocol.
    You might think of structured text formats as delimited text on steroids, and
    as such, rules must be in place for how values are represented and hierarchies
    constructed. With this in mind, I’ll describe three formats in common use within
    real-world text protocols.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与结构化二进制格式（如ASN.1）一样，当你想在文本协议中表示结构化数据时，通常没有必要重新发明轮子。你可以将结构化文本格式看作是加速版的分隔文本，因此，必须有规则来规定值的表示方式和层级的构建方式。考虑到这一点，我将描述三种在实际文本协议中常用的格式。
- en: '**Multipurpose Internet Mail Extensions**'
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**多用途互联网邮件扩展**'
- en: Originally developed for sending multipart email messages, *Multipurpose Internet
    Mail Extensions (MIME)* found its way into a number of protocols, such as HTTP.
    The specification in RFCs 2045, 2046 and 2047, along with numerous other related
    RFCs, defines a way of encoding multiple discrete attachments in a single MIME-encoded
    message.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最初为了发送多部分电子邮件而开发的*多用途互联网邮件扩展（MIME）*已经进入了多个协议中，如HTTP。RFC 2045、2046和2047中的规范，以及其他众多相关RFC，定义了一种编码多个独立附件到一个MIME编码消息中的方式。
- en: MIME messages separate the body parts by defining a common separator line prefixed
    with two dashes (--). The message is terminated by following this separator with
    the same two dashes. [Listing 3-3](../Text/ch03.xhtml#ch3list3) shows an example
    of a text message combined with a binary version of the same message.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: MIME消息通过定义一个以两个短横线（--）为前缀的公共分隔符行来分隔消息体部分。消息通过在分隔符后跟随相同的两个短横线来结束。[列表3-3](../Text/ch03.xhtml#ch3list3)展示了一个结合了二进制版本的相同消息的文本消息示例。
- en: '[PRE2]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 3-3: A simple MIME message*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表3-3：一个简单的MIME消息*'
- en: One of the most common uses of MIME is for Content-Type values, which are usually
    referred to as *MIME types.* A MIME type is widely used when serving HTTP content
    and in operating systems to map an application to a particular content type. Each
    type consists of the form of the data it represents, such as *text* or *application*,
    in the format of the data. In this case, `plain` is unencoded text and `octet-stream`
    is a series of bytes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: MIME 最常见的用途之一是用于 Content-Type 值，这通常被称为 *MIME 类型*。MIME 类型广泛应用于 HTTP 内容的服务以及操作系统中将应用程序与特定内容类型映射的场合。每种类型由数据所表示的形式组成，例如
    *text* 或 *application*，以及数据的格式。在这种情况下，`plain` 是未编码的文本，而 `octet-stream` 是一系列字节。
- en: '**JavaScript Object Notation**'
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**JavaScript 对象表示法**'
- en: '*JavaScript Object Notation (JSON)* was designed as a simple representation
    for a structure based on the object format provided by the JavaScript programming
    language. It was originally used to transfer data between a web page in a browser
    and a backend service, such as in Asynchronous JavaScript and XML (AJAX). Currently,
    it’s commonly used for web service data transfer and all manner of other protocols.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript 对象表示法 (JSON)* 设计为一种简单的表示方式，用于描述基于 JavaScript 编程语言提供的对象格式的结构。它最初用于在浏览器中的网页和后端服务之间传输数据，比如在异步
    JavaScript 和 XML（AJAX）中。目前，它广泛应用于 Web 服务的数据传输以及各种其他协议。'
- en: 'The JSON format is simple: a JSON object is enclosed using the braces ({})
    ASCII characters. Within these braces are zero or more member entries, each consisting
    of a key and a value. For example, [Listing 3-4](../Text/ch03.xhtml#ch3list4)
    shows a simple JSON object consisting of an integer index value, "Hello world!"
    as a string, and an array of strings.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 格式很简单：一个 JSON 对象使用大括号 ({}) ASCII 字符包围。在这些大括号中可以包含零个或多个成员条目，每个条目由一个键和值组成。例如，[列表
    3-4](../Text/ch03.xhtml#ch3list4) 显示了一个简单的 JSON 对象，其中包括一个整数索引值、"Hello world!"
    作为字符串，以及一个字符串数组。
- en: '[PRE3]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 3-4: A simple JSON object*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-4：一个简单的 JSON 对象*'
- en: The JSON format was designed for JavaScript processing, and it can be parsed
    using the `"eval"` function. Unfortunately, using this function comes with a significant
    security risk; namely, it’s possible to insert arbitrary script code during object
    creation. Although most modern applications use a parsing library that doesn’t
    need a connection to JavaScript, it’s worth ensuring that arbitrary JavaScript
    code is not executed in the context of the application. The reason is that it
    could lead to potential security issues, such as *cross-site scripting (XSS)*,
    a vulnerability where attacker-controlled JavaScript can be executed in the context
    of another web page, allowing the attacker to access the page’s secure resources.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 格式是为 JavaScript 处理设计的，可以使用 `"eval"` 函数进行解析。不幸的是，使用这个函数存在显著的安全风险；即在对象创建过程中可能插入任意脚本代码。尽管大多数现代应用程序使用不需要与
    JavaScript 连接的解析库，但仍值得确保在应用程序上下文中不会执行任意 JavaScript 代码。原因是这可能导致潜在的安全问题，如 *跨站脚本攻击
    (XSS)*，这是一种攻击者控制的 JavaScript 可以在另一个网页的上下文中执行的漏洞，从而使攻击者能够访问该页面的安全资源。
- en: '**Extensible Markup Language**'
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**可扩展标记语言**'
- en: '*Extensible Markup Language (XML)* is a markup language for describing a structured
    document format. Developed by the W3C, it’s derived from Standard Generalized
    Markup Language (SGML). It has many similarities to HTML, but it aims to be stricter
    in its definition in order to simplify parsers and create fewer security issues.^([1](../Text/footnote.xhtml#ch03nt01))'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*可扩展标记语言 (XML)* 是一种用于描述结构化文档格式的标记语言。它由 W3C 开发，源自标准化通用标记语言 (SGML)。它与 HTML 有许多相似之处，但它旨在通过更严格的定义来简化解析器并减少安全问题。^([1](../Text/footnote.xhtml#ch03nt01))'
- en: At a basic level, XML consists of elements, attributes, and text. *Elements*
    are the main structural values. They have a name and can contain child elements
    or text content. Only one root element is allowed in a single document. *Attributes*
    are additional name-value pairs that can be assigned to an element. They take
    the form of `name`="Value". Text content is just that, text. Text is a child of
    an element or the value component of an attribute.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从基本层面来看，XML 由元素、属性和文本组成。*元素* 是主要的结构值。它们有一个名称，并可以包含子元素或文本内容。在单个文档中只允许有一个根元素。*属性*
    是可以分配给元素的附加名称-值对。它们的形式是 `name`="Value"。文本内容仅仅是文本。文本是元素的子项或属性的值组件。
- en: '[Listing 3-5](../Text/ch03.xhtml#ch3list5) shows a very simple XML document
    with elements, attributes, and text values.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-5](../Text/ch03.xhtml#ch3list5) 显示了一个非常简单的 XML 文档，包含元素、属性和文本值。'
- en: '[PRE4]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 3-5: A simple XML document*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-5：一个简单的 XML 文档*'
- en: All XML data is text; no type information is provided for in the XML specification,
    so the parser must know what the values represent. Certain specifications, such
    as XML Schema, aim to remedy this type information deficiency but they are not
    required in order to process XML content. The XML specification defines a list
    of well-formed criteria that can be used to determine whether an XML document
    meets a minimal level of structure.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 XML 数据都是文本；在 XML 规范中没有提供类型信息，因此解析器必须知道这些值表示什么。某些规范，如 XML Schema，旨在弥补这种类型信息的缺失，但它们并非处理
    XML 内容的必要条件。XML 规范定义了一些结构良好的标准，可以用来确定一个 XML 文档是否符合最基本的结构要求。
- en: XML is used in many different places to define the way information is transmitted
    in a protocol, such as in Rich Site Summary (RSS). It can also be part of a protocol,
    as in Extensible Messaging and Presence Protocol (XMPP).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: XML 在许多不同的地方用于定义信息在协议中的传输方式，比如在丰富网站摘要（RSS）中。它也可以是协议的一部分，比如在可扩展消息和存在协议（XMPP）中。
- en: '**Encoding Binary Data**'
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编码二进制数据**'
- en: In the early history of computer communication, 8-bit bytes were not the norm.
    Because most communication was text based and focused on English-speaking countries,
    it made economic sense to send only 7 bits per byte as required by the ASCII standard.
    This allowed other bits to provide control for serial link protocols or to improve
    performance. This history is reflected heavily in some early network protocols,
    such as the SMTP or Network News Transfer Protocol (NNTP), which assume 7-bit
    communication channels.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机通信的早期历史中，8 位字节并不是常态。由于大多数通信都是基于文本的，且集中在英语国家，因此按照 ASCII 标准每个字节只发送 7 位是有经济意义的。这允许其他位提供串行链路协议的控制或提高性能。这一历史在一些早期的网络协议中得到了充分体现，比如
    SMTP 或网络新闻传输协议（NNTP），这些协议假定使用 7 位通信通道。
- en: But a 7-bit limitation presents a problem if you want to send that amusing picture
    to your friend via email or you want to write your mail in a non-English character
    set. To overcome this limitation, developers devised a number of ways to encode
    binary data as text, each with varying degrees of efficiency or complexity.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，7 位限制带来了一个问题，如果你想通过电子邮件发送那张有趣的图片，或者你想用非英语字符集写邮件。为了克服这个限制，开发人员设计了多种方法将二进制数据编码为文本，每种方法的效率或复杂性有所不同。
- en: As it turns out, the ability to convert binary content into text still has its
    advantages. For example, if you wanted to send binary data in a structured text
    format, such as JSON or XML, you might need to ensure that delimiters were appropriately
    escaped. Instead, you can choose an existing encoding format, such as Base64,
    to send the binary data and it will be easily understood on both sides.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，将二进制内容转换为文本的能力仍然有其优势。例如，如果你想以结构化的文本格式（如 JSON 或 XML）发送二进制数据，你可能需要确保分隔符得到适当转义。相反，你可以选择一个现有的编码格式，如
    Base64，来发送二进制数据，它将被双方轻松理解。
- en: Let’s look at some of the more common binary-to-text encoding schemes you’re
    likely to encounter when inspecting a text protocol.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下在检查文本协议时，你可能会遇到的一些常见的二进制到文本的编码方案。
- en: '***Hex Encoding***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***十六进制编码***'
- en: One of the most naive encoding techniques for binary data is *hex encoding*.
    In hex encoding, each octet is split into two 4-bit values that are converted
    to two text characters denoting the hexadecimal representation. The result is
    a simple representation of the binary in text form, as shown in [Figure 3-18](../Text/ch03.xhtml#ch3fig18).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一种最简单的二进制数据编码技术是*十六进制编码*。在十六进制编码中，每个字节被分割成两个 4 位的值，转换成两个文本字符表示十六进制表示。结果是一个简单的二进制文本表示，如[图
    3-18](../Text/ch03.xhtml#ch3fig18)所示。
- en: '![image](../Images/f03-18.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-18.jpg)'
- en: '*Figure 3-18: Example hex encoding of binary data*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-18：二进制数据的示例十六进制编码*'
- en: Although simple, hex encoding is not space efficient because all binary data
    automatically becomes 100 percent larger than it was originally. But one advantage
    is that encoding and decoding operations are fast and simple and little can go
    wrong, which is definitely beneficial from a security perspective.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管简单，十六进制编码并不高效，因为所有二进制数据都会自动变大 100%，比原始数据大一倍。但它的一个优点是编码和解码操作快速且简单，出错的几率小，这对于安全性是非常有利的。
- en: HTTP specifies a similar encoding for URLs and some text protocols called *percent
    encoding*. Rather than all data being encoded, only nonprintable data is converted
    to hex, and values are signified by prefixing the value with a % character. If
    percent encoding was used to encode the value in [Figure 3-18](../Text/ch03.xhtml#ch3fig18),
    you would get %06%E3%58.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 为 URL 和一些文本协议指定了类似的编码方式，称为 *百分号编码*。与所有数据都被编码不同，只有不可打印的数据会被转换为十六进制，值通过在前面加上一个
    % 字符来表示。如果使用百分号编码对[图 3-18](../Text/ch03.xhtml#ch3fig18)中的值进行编码，结果将是 %06%E3%58。
- en: '***Base64***'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Base64***'
- en: To counter the obvious inefficiencies in hex encoding, we can use Base64, an
    encoding scheme originally developed as part of the MIME specifications. The *64*
    in the name refers to the number of characters used to encode the data.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服十六进制编码中的明显低效，我们可以使用 Base64，这是一种最初作为 MIME 规范的一部分开发的编码方案。名字中的*64*指的是用于编码数据的字符数量。
- en: The input binary is separated into individual 6-bit values, enough to represent
    0 through 63\. This value is then used to look up a corresponding character in
    an encoding table, as shown in [Figure 3-19](../Text/ch03.xhtml#ch3fig19).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的二进制数据被分成单独的 6 位值，足以表示从 0 到 63。然后使用这个值查找编码表中的对应字符，如[图 3-19](../Text/ch03.xhtml#ch3fig19)所示。
- en: '![image](../Images/f03-19.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-19.jpg)'
- en: '*Figure 3-19: Base64 encoding table*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-19：Base64 编码表*'
- en: 'But there’s a problem with this approach: when 8 bits are divided by 6, 2 bits
    remain. To counter this problem, the input is taken in units of three octets,
    because dividing 24 bits by 6 bits produces 4 values. Thus, Base64 encodes 3 bytes
    into 4, representing an increase of only 33 percent, which is significantly better
    than the increase produced by hex encoding. [Figure 3-20](../Text/ch03.xhtml#ch3fig20)
    shows an example of encoding a three-octet sequence into Base64.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方法存在一个问题：当 8 位被 6 位除时，剩下 2 位。为了解决这个问题，输入数据以三个八位字节为单位处理，因为将 24 位除以 6 位会产生
    4 个值。因此，Base64 将 3 个字节编码为 4 个字符，表示增加仅为 33%，比十六进制编码的增加量要好得多。[图 3-20](../Text/ch03.xhtml#ch3fig20)
    显示了将三个八位字节序列编码为 Base64 的示例。
- en: But yet another issue is apparent with this strategy. What if you have only
    one or two octets to encode? Would that not cause the encoding to fail? Base64
    gets around this issue by defining a placeholder character, the equal sign (=).
    If in the encoding process, no valid bits are available to use, the encoder will
    encode that value as the placeholder. [Figure 3-21](../Text/ch03.xhtml#ch3fig21)
    shows an example of only one octet being encoded. Note that it generates two placeholder
    characters. If two octets were encoded, Base64 would generate only one.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这种策略还存在另一个问题。如果你只有一个或两个八位字节需要编码呢？这难道不会导致编码失败吗？Base64 通过定义一个占位符字符——等号（=）来解决这个问题。如果在编码过程中没有有效的位可以使用，编码器将把该值编码为占位符。[图
    3-21](../Text/ch03.xhtml#ch3fig21) 显示了只编码一个八位字节的示例。请注意，它生成了两个占位符字符。如果编码了两个八位字节，Base64
    将仅生成一个占位符字符。
- en: '![image](../Images/f03-20.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-20.jpg)'
- en: '*Figure 3-20: Base64 encoding 3 bytes as 4 characters*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-20：Base64 编码 3 个字节为 4 个字符*'
- en: '![image](../Images/f03-21.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f03-21.jpg)'
- en: '*Figure 3-21: Base64 encoding 1 byte as 3 characters*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-21：Base64 编码 1 个字节为 3 个字符*'
- en: To convert Base64 data back into binary, you simply follow the steps in reverse.
    But what happens when a non-Base64 character is encountered during the decoding?
    Well that’s up to the application to decide. We can only hope that it makes a
    secure decision.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Base64 数据转换回二进制，只需按照步骤反向操作。但是，当在解码过程中遇到非 Base64 字符时，会发生什么呢？这就取决于应用程序如何决定了。我们只能希望它做出安全的决策。
- en: '**Final Words**'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, I defined many ways to represent data values in binary and
    text protocols and discussed how to represent numeric data, such as integers,
    in binary. Understanding how octets are transmitted in a protocol is crucial to
    successfully decoding values. At the same time, it’s also important to identify
    the many ways that variable-length data values can be represented because they
    are perhaps the most important structure you will encounter within a network protocol.
    As you analyze more network protocols, you’ll see the same structures used repeatedly.
    Being able to quickly identify the structures is key to easily processing unknown
    protocols.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我定义了多种表示数据值的方式，包括二进制和文本协议，并讨论了如何在二进制中表示数值数据，比如整数。理解八位字节如何在协议中传输，对于成功解码值至关重要。同时，识别可变长度数据值的多种表示方式也非常重要，因为它们可能是你在网络协议中遇到的最关键结构。当你分析更多的网络协议时，你会看到相同的结构被反复使用。能够快速识别这些结构是轻松处理未知协议的关键。
- en: In [Chapter 4](../Text/ch04.xhtml#ch04), we’ll look at a few real-world protocols
    and dissect them to see how they match up with the descriptions presented in this
    chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](../Text/ch04.xhtml#ch04)中，我们将查看一些现实世界中的协议，并对它们进行剖析，看看它们如何与本章中呈现的描述相匹配。
