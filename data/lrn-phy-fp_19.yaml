- en: '17'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '17'
- en: SATELLITE, PROJECTILE, AND PROTON MOTION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 卫星、抛体和质子运动
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common.jpg)'
- en: This chapter discusses three extended examples that use the ideas and code from
    [Chapter 16](ch16.xhtml) to express and solve Newtonian mechanics problems that
    involve one object. The examples are satellite motion, projectile motion with
    air resistance, and a proton in a uniform magnetic field. We’ll show how to make
    plots and animations for each of these examples. Note that we will not begin a
    new module in this chapter; instead, we’ll add to the `Mechanics3D` module we
    started in the last chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了三个扩展示例，这些示例使用了来自[第16章](ch16.xhtml)的思想和代码，表达并解决涉及一个物体的牛顿力学问题。示例包括卫星运动、带空气阻力的抛体运动，以及在均匀磁场中的质子运动。我们将展示如何为每个示例制作图表和动画。请注意，本章不会开始一个新的模块；相反，我们将继续扩展上一章中开始的`Mechanics3D`模块。
- en: Satellite Motion
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卫星运动
- en: 'As an initial example of satellite motion, consider the following: Earth orbits
    the sun because of the attractive force of gravity between them. Strictly speaking,
    Earth and the sun each orbit a point located between the two bodies. This point,
    called the *center of mass*, is much closer to the more massive sun than it is
    to the less massive Earth, so it’s a decent approximation to say that Earth orbits
    the sun. In [Chapter 19](ch19.xhtml), we’ll treat universal gravity as a two-body
    force: both the sun and Earth will accelerate in response to it, and both bodies
    will orbit about the center of mass. In this chapter, however, we’re interested
    in the motion of a single object, say Earth, and we’ll treat the force of gravity
    on Earth by the sun as a one-body force. This means we’ll regard the sun as merely
    a piece of furniture whose role is to produce a force of gravity on Earth, but
    it will not partake in the full dance by feeling a force and exhibiting changed
    motion as a result.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为卫星运动的初步示例，考虑以下情况：地球绕太阳公转是由于它们之间的引力。严格来说，地球和太阳各自绕着一个位于两者之间的点公转。这个点叫做*质心*，它距离质量较大的太阳要比质量较小的地球近得多，因此将地球绕太阳公转是一个不错的近似。在[第19章](ch19.xhtml)中，我们将把万有引力视为一个二体力：太阳和地球都会因此加速，两个天体都会绕着质心公转。然而，在本章中，我们只关注单一物体的运动，比如地球，我们将把太阳对地球的引力视为单体力。这意味着我们将把太阳视为一个“家具”，它的作用只是对地球施加引力，但不会参与到完整的运动中，也不会因感受到力而发生运动变化。
- en: For the satellite motion in this chapter, we’ll only pay attention to the satellite.
    The larger planet or star around which the satellite orbits is imagined to be
    fixed in place; its only job is creating a force of gravity on the satellite.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的卫星运动中，我们只关注卫星。围绕卫星轨道运动的较大行星或恒星被假设为固定不动；它唯一的作用是对卫星施加引力。
- en: Halley’s comet orbits the sun, making one orbit every 75 years or so. The orbit
    is quite elliptical, with the comet traveling quickly when it’s close to the sun
    and slowly when it’s far away. In 1986, Halley’s comet was close to the sun, and
    consequently close enough to Earth to be seen without a telescope. It is expected
    again in our neighborhood in 2061.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 哈雷彗星绕太阳公转，每75年左右公转一圈。它的轨道相当椭圆，彗星在靠近太阳时运动较快，而在远离太阳时运动较慢。在1986年，哈雷彗星靠近太阳，因此也足够接近地球，肉眼可见。预计它将在2061年再次经过我们的邻近区域。
- en: 'Let’s animate the orbit of Halley’s comet around the sun. In [Chapter 16](ch16.xhtml),
    we described how to produce an animation. We need five pieces of information for
    the `simulateGloss` or `simulateVis` function: a time-scale factor, an animation
    rate, an initial state, a display function, and a state-update function. We’ll
    describe these now, starting with the pieces of information that have the most
    physical content.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为哈雷彗星绕太阳的轨道制作动画。在[第16章](ch16.xhtml)中，我们描述了如何制作动画。我们需要五个信息来调用`simulateGloss`或`simulateVis`函数：一个时间尺度因子、一个动画速率、一个初始状态、一个显示函数和一个状态更新函数。我们将从最具物理意义的信息开始描述。
- en: State-Update Function
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 状态更新函数
- en: The state-update function `halleyUpdate` can be written using `updatePS`, shown
    in [Figure 16-3](ch16.xhtml#ch16fig3) and defined in [Chapter 16](ch16.xhtml),
    which requires a numerical method and a list of one-body forces. The function
    `halleyUpdate`, and all of the code in this chapter and the next that is not part
    of a stand-alone program, is part of the `Mechanics3D` module we began in [Chapter
    16](ch16.xhtml) and should be in the same source code file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 状态更新函数`halleyUpdate`可以使用`updatePS`编写，如[图16-3](ch16.xhtml#ch16fig3)所示，并在[第16章](ch16.xhtml)中定义，该函数需要一个数值方法和一体力列表。函数`halleyUpdate`及本章和下一章中所有不是独立程序的代码，都属于我们在[第16章](ch16.xhtml)中开始的`Mechanics3D`模块，应该放在同一个源代码文件中。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For our numerical method, we’ll choose the Euler-Cromer method. Recall that
    for animation, we won’t choose the time step of the numerical method directly
    but rather through the time-scale factor and animation rate we choose later. The
    time step `dt` appears as an input to `halleyUpdate`, and we pass `dt` along to
    `eulerCromerPS` to form the numerical method. The list of one-body forces contains
    only the sun’s force of gravity.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的数值方法，我们将选择欧拉-克罗默方法。回想一下，对于动画，我们不会直接选择数值方法的时间步长，而是通过稍后选择的时间尺度因子和动画速率来确定。时间步长`dt`作为输入传递给`halleyUpdate`，然后我们将`dt`传递给`eulerCromerPS`来构成数值方法。一体力的列表仅包含太阳的引力。
- en: Initial State
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始状态
- en: 'The initial state `halleyInitial` determines whether we get a circular orbit,
    an elliptical orbit, or a satellite moving so fast that it escapes the gravitational
    pull of the sun. The mass of Halley’s comet is 2.2 × 10^(14) kg. The net charge
    of the comet is zero, and we start our clock at zero as well. It’s the initial
    position and velocity that will determine the subsequent orbit. I’ve chosen the
    initial position to be on the positive x-axis at the closest distance that the
    comet comes to the sun, which is 8.766 × 10^(10) m. When Halley’s comet is closest
    to the sun, it’s moving the fastest it will move in the course of its orbit, 54,569
    m/s, in a direction perpendicular to the line connecting the comet with the sun.
    We call this direction the y-direction. Placing all of this information into the
    `ParticleState` data type, we arrive at the following expression for the initial
    state `halleyInitial`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 初始状态`halleyInitial`决定了我们是得到一个圆形轨道、椭圆轨道，还是一个速度快到能够逃脱太阳引力的卫星。哈雷彗星的质量为2.2 × 10^(14)千克。彗星的净电荷为零，我们的时钟也从零开始。正是初始位置和速度决定了后续的轨道。我选择将初始位置设置在x轴正方向上，距离太阳最近的距离为8.766
    × 10^(10)米。当哈雷彗星最接近太阳时，它的速度是轨道中最快的，速度为54,569米/秒，方向垂直于彗星和太阳之间的连线。我们称这个方向为y方向。将所有这些信息放入`ParticleState`数据类型，我们得到了初始状态`halleyInitial`的以下表达式：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Time-Scale Factor
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 时间尺度因子
- en: '[Listing 17-1](ch17.xhtml#ch17list1) shows the time-scale factor, animation
    rate, and display function and gives a stand-alone program for a 2D animation
    of satellite motion using `gloss`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表17-1](ch17.xhtml#ch17list1)显示了时间尺度因子、动画速率和显示函数，并提供了一个独立的程序，用于使用`gloss`进行哈雷彗星绕太阳运动的2D动画。'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 17-1: Stand-alone program for a 2D animation of Halley’s comet in
    orbit around the sun*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表17-1：用于展示哈雷彗星绕太阳轨道运动的2D动画的独立程序*'
- en: We begin by turning on warnings. Then we import the functions we need from the
    `SimpleVec` module of [Chapter 10](ch10.xhtml), the `Mechanics3D` module we began
    in [Chapter 16](ch16.xhtml) and continue to add to in this chapter and the next,
    and the `Graphics.Gloss` module. The pictures `diskComet` and `diskSun` are markers
    for Halley’s comet and the sun, respectively. The display function `halleyPicture`
    is one of the five ingredients needed for an animation, and it uses the comet’s
    state to translate the comet marker to the appropriate position. The sun is displayed
    at the origin and does not move. In the `main` function, we choose a time-scale
    factor of `365.25 * 24 * 60 * 60` so that one year of physical time is one second
    of animation time. Since the period of Halley’s comet is about 75 years, it will
    take about a minute and 15 seconds for the animation to show a complete orbit.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先打开警告。然后，我们从[第10章](ch10.xhtml)的`SimpleVec`模块、我们在[第16章](ch16.xhtml)开始并在本章及下一章继续扩展的`Mechanics3D`模块，以及`Graphics.Gloss`模块中导入所需的功能。图片`diskComet`和`diskSun`分别是哈雷彗星和太阳的标记。显示函数`halleyPicture`是动画所需的五个要素之一，它利用彗星的状态将彗星标记移到适当的位置。太阳显示在原点且不会移动。在`main`函数中，我们选择了`365.25
    * 24 * 60 * 60`作为时间缩放因子，这样一年的物理时间就对应一秒的动画时间。由于哈雷彗星的周期约为75年，因此动画显示一个完整轨道大约需要1分15秒。
- en: Animation Rate
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动画速率
- en: For animations in general, I recommend starting with an animation rate of about
    20 frames/second. For Halley’s comet, that gives a time step of 1/20 of a year,
    much smaller than 75 years, which appears to be the important time scale of the
    situation. If you use 20 frames/second instead of the 400 frames/second shown
    in [Listing 17-1](ch17.xhtml#ch17list1), you’ll notice that the orbit has some
    funny properties. Halley’s comet just wanders off the screen and doesn’t come
    back to go around the sun, at least not in anything close to 75 seconds. The trouble
    is that the comet moves very quickly when it is close to the sun, and relatively
    slowly when it is far away.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一般的动画，我建议开始时使用每秒约20帧的动画速率。对于哈雷彗星，这样的时间步长是1/20年，比75年的时间尺度小得多，后者似乎是该情形下的重要时间尺度。如果你使用每秒20帧，而不是[清单17-1](ch17.xhtml#ch17list1)中所示的每秒400帧，你会注意到轨道出现一些奇怪的现象。哈雷彗星会偏离屏幕，并且不会再回到屏幕上绕太阳运行，至少在接近75秒内不会发生这种情况。问题在于，彗星在接近太阳时移动非常快，而在远离太阳时则相对较慢。
- en: An accurate calculation requires a relatively small time step when the comet
    is close to the sun, moving rapidly, and changing direction quickly. The time
    step for the rest of the orbit could be substantially larger without doing any
    damage. There are some numerical methods that use a variable time step, but they
    are beyond the scope of this book. We need to increase the animation rate or decrease
    the time-scale factor in order to use a time step small enough to maintain accuracy
    during the short period of closest approach. Trying out different animation rates
    suggests that 400 frames/second is probably sufficient to give reasonably accurate
    results.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当彗星接近太阳时，准确的计算需要相对较小的时间步长，因为此时彗星移动迅速且方向变化很快。其余轨道部分的时间步长可以大大增大，而不会造成损害。有一些数值方法使用可变时间步长，但这些超出了本书的范围。我们需要增加动画速率或减小时间缩放因子，以便在最接近太阳的短暂时间内使用足够小的时间步长来保持准确性。通过尝试不同的动画速率，表明每秒400帧可能足以给出合理准确的结果。
- en: Display Function
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示功能
- en: '[Figure 17-1](ch17.xhtml#ch17fig1) shows one frame of the animation of Halley’s
    comet around the sun. In this snapshot, the sun is shown in gray at the right
    of the figure, while Halley’s comet moves to the left, away from the sun. The
    animation we are writing produces a yellow sun and and a red comet.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17-1](ch17.xhtml#ch17fig1)显示了哈雷彗星绕太阳运动的动画帧。在这个快照中，太阳以灰色显示在图的右侧，而哈雷彗星向左移动，远离太阳。我们编写的动画呈现出一个黄色的太阳和一个红色的彗星。'
- en: '![Image](Images/311fig01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/311fig01.jpg)'
- en: '*Figure 17-1: Halley’s comet moving away from the sun*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-1：哈雷彗星远离太阳*'
- en: The display function `halleyPicture` needs to describe how to produce a picture
    from a state. The main thing we want to show is the position of the comet. The
    comet moves in the *z* = 0 plane, so we just need to deal with the x- and y-components
    of position in this function. The `halleyPicture` function in [Listing 17-1](ch17.xhtml#ch17list1)
    uses pattern matching on the input to assign the local variable `r` to the position
    of the current state of the comet. Position is the only state variable that the
    display function cares about; velocity or mass play no role in determining how
    the picture looks. We use the `xComp` and `yComp` functions from the `SimpleVec`
    module of [Chapter 10](ch10.xhtml) to extract the x- and y-components of the position.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 显示函数 `halleyPicture` 需要描述如何从状态生成一张图片。我们主要想展示的是彗星的位置。彗星在 *z* = 0 平面内运动，因此我们只需要处理该函数中的位置的
    x 和 y 分量。[Listing 17-1](ch17.xhtml#ch17list1) 中的 `halleyPicture` 函数通过模式匹配输入，将局部变量
    `r` 赋值为当前彗星状态的位置。位置是显示函数关心的唯一状态变量；速度或质量在决定图片的外观时不起作用。我们使用 [Chapter 10](ch10.xhtml)
    中 `SimpleVec` 模块的 `xComp` 和 `yComp` 函数提取位置的 x 和 y 分量。
- en: The `where` keyword is similar to the `let` keyword, allowing the code writer
    to define local variables and functions; however, `where` and its local names
    come after the body of the principal function rather than before it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`where` 关键字与 `let` 关键字类似，允许代码编写者定义局部变量和函数；然而，`where` 及其局部名称出现在主要函数体之后，而不是之前。'
- en: The `realToFrac` function converts real numbers with type `R` into real numbers
    with type `Float` because `gloss`’s `translate` function requires `Float`s as
    input. The final picture produced contains a yellow disk to represent the sun
    and a red disk, translated to the appropriate place, to represent the comet. The
    `pictures` function in `gloss` produces a single picture from a list of pictures.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`realToFrac` 函数将类型为 `R` 的实数转换为类型为 `Float` 的实数，因为 `gloss` 的 `translate` 函数需要以
    `Float` 类型作为输入。最终生成的图像包含一个黄色圆盘表示太阳，一个红色圆盘，经过平移到合适位置，用来表示彗星。`gloss` 中的 `pictures`
    函数从一个图片列表生成一个单独的图片。'
- en: Spatial scaling needs to take place in the display function. Physical sizes
    are expressed in meters, while `gloss` sizes are expressed in pixels. Thus, we
    need to specify how this conversion is to be done. One natural scaling strategy
    is to show everything to scale, using a single overall scaling factor to convert
    meters to pixels. The `scale` function in `gloss` is excellent for this purpose
    because it can take as input a picture with all lengths in meters and produce
    another picture scaled by the number of pixels per meter that we want. But in
    the Halley animation, if we try to show everything to scale, using accurate values
    in meters for the two radii and the position of the comet and one overall scaling
    factor from meters to pixels, we will not be able to see the comet or the sun
    because the distance over which the comet roams is so vast.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 空间缩放需要在显示函数中进行。物理尺寸以米为单位表示，而 `gloss` 的尺寸则以像素为单位表示。因此，我们需要指定如何进行这种转换。一种自然的缩放策略是按比例显示所有内容，使用一个整体缩放因子将米转换为像素。`gloss`
    中的 `scale` 函数非常适合这个目的，因为它可以接受一个所有长度以米为单位的图片，并生成一个按每米多少像素缩放后的新图片。但在哈雷彗星动画中，如果我们尝试按比例显示所有内容，使用两个半径和彗星位置的准确米值，以及一个米到像素的整体缩放因子，我们将无法看到彗星或太阳，因为彗星的运动范围过于广阔。
- en: 'Since we can’t show the sizes of the sun and comet to scale, the yellow and
    red disks act only as markers for the location of the sun and comet; the sizes
    of these disks are not to scale with the orbital motion or with each other. It
    is easiest to specify the radii of the sun and comet in pixels rather than in
    meters, which would need to be scaled to pixels and scaled by a different factor
    than the comet position. The pictures `diskComet` and `diskSun` specify the radii
    for these two disks to be 10 pixels and 20 pixels, respectively. We won’t scale
    these radii any more. These two pictures make use of the `disk` function, which
    we defined in [Chapter 13](ch13.xhtml) and repeat here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法按比例显示太阳和彗星的大小，黄色和红色圆盘仅作为太阳和彗星位置的标记；这些圆盘的大小与轨道运动或彼此之间的比例无关。指定太阳和彗星的半径时，使用像素比使用米更容易，因为米需要缩放到像素，并且按与彗星位置不同的因子进行缩放。图片
    `diskComet` 和 `diskSun` 指定了这两个圆盘的半径分别为 10 像素和 20 像素。我们不会再对这些半径进行缩放。这两张图片使用了我们在
    [Chapter 13](ch13.xhtml) 中定义的 `disk` 函数，以下是重复部分：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another reason I’d rather specify the radii in pixels is that spatial scaling
    is often determined by trial and error, reducing or expanding the size of an animation
    that’s working. If this trial-and-error scaling is done on the entire picture,
    involving both the orbit size and the radii, it’s easy to shrink the radii too
    much so that the disks can’t be seen, or to expand the radii too much so that
    they fill the entire screen. In either of these cases, it’s sometimes difficult
    to know what the problem is.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我更倾向于在像素中指定半径的另一个原因是，空间缩放通常是通过试错法确定的，缩小或放大一个有效的动画。如果这个试错缩放作用于整个图像，包括轨道大小和半径，就很容易把半径缩小得太多，以至于圆盘看不见，或者把半径放大得太多，导致它们填满整个屏幕。在这两种情况下，有时很难知道问题出在哪里。
- en: In the Halley animation, there is only one thing that needs to be scaled, and
    that’s the position of the comet. We use a factor of 10^(–10) pixels/meter to
    scale the x- and y-components of the position.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在哈雷动画中，只有一件事需要缩放，那就是彗星的位置。我们使用10^(-10)像素/米的缩放因子来缩放位置的x和y分量。
- en: Projectile Motion with Air Resistance
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有空气阻力的抛物线运动
- en: 'For our next example, let’s look at a batted baseball. This is an example of
    projectile motion with air resistance. We’ll consider two forces that act on the
    baseball: Earth’s surface gravity and air resistance. We’ll use a 145-g baseball
    with a diameter of 74 mm and a drag coefficient of 0.3\. The list `baseballForces`
    contains the two one-body forces that act on the baseball. The list `baseballForces`,
    and all of the code in this chapter and the next that is not part of a stand-alone
    program, is part of the `Mechanics3D` module.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，让我们来看一个击打的棒球。这是一个带有空气阻力的抛物线运动示例。我们将考虑作用在棒球上的两个力：地球表面的重力和空气阻力。我们使用一个145克重、直径为74毫米、阻力系数为0.3的棒球。列表`baseballForces`包含作用在棒球上的两个单一力。列表`baseballForces`以及本章和下一章中不属于独立程序的所有代码，都是`Mechanics3D`模块的一部分。
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first force is Earth surface gravity and the second force is air resistance.
    We define a local variable `area` to hold the cross-sectional area of the baseball.
    The number 0.074 is the diameter of the ball in meters, 0.3 is the drag coefficient,
    and 1.225 is the density of air in kg/m³.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个力是地球表面的重力，第二个力是空气阻力。我们定义了一个局部变量`area`来保存棒球的横截面积。数字0.074是球的直径（单位：米），0.3是阻力系数，1.225是空气的密度（单位：kg/m³）。
- en: For situations that take place on or near Earth’s surface, I like to use a coordinate
    system in which *x* and *y* are the horizontal coordinates and *z* is the vertical
    coordinate, with positive *z* pointing away from Earth’s center. Projectile motion
    with air resistance takes place in a plane. It would be reasonable to choose the
    xz-plane or the yz-plane for this motion. We’ll choose the yz-plane because the
    default coordinate system for the `simulateVis` function, should we choose to
    use it, has *y* to the right and *z* up the screen.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于发生在地球表面或附近的情况，我喜欢使用一个坐标系统，其中*x*和*y*是水平坐标，*z*是垂直坐标，正*z*指向远离地球中心的方向。带有空气阻力的抛物线运动发生在一个平面内。选择xz平面或yz平面来进行这种运动是合理的。我们选择yz平面，因为`simulateVis`函数的默认坐标系统（如果我们选择使用它）中，*y*是右侧，*z*是向上。
- en: Calculating a Trajectory
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算轨迹
- en: The function `baseballTrajectory`, defined below, produces a list of (y, z)
    pairs, where *y* and *z* are the horizontal and vertical components of position,
    respectively. We give this function a time step, an initial speed, and an angle
    in degrees. The angle is the angle above the horizontal at which the ball leaves
    the bat.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面定义的函数`baseballTrajectory`会生成一个(y, z)坐标对的列表，其中*y*和*z*分别是位置的水平分量和垂直分量。我们为这个函数提供一个时间步长、初速度和角度（单位：度）。这个角度是球离开球棒时与水平面的夹角。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ve defined several local variables to hold the angle in radians, the horizontal
    and vertical components of initial velocity, and the initial state of the ball.
    We use `statesPS` to make an infinite list of states, using the Euler-Cromer method
    with the given step size, the list of forces (`baseballForces`), and the initial
    state. The function `zGE0`, defined below, truncates the infinite list to a finite
    list consisting only of states with a vertical position greater than or equal
    to zero. The function `trajectory`, also defined below, transforms a list of states
    into a list of (y, z) pairs suitable for plotting.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了几个局部变量来保存角度（弧度制）、初速度的水平和垂直分量以及球的初始状态。我们使用`statesPS`来生成一个无限状态列表，使用欧拉-克罗梅方法，给定的步长、力的列表（`baseballForces`）和初始状态。下面定义的函数`zGE0`会将这个无限列表截断为一个有限列表，仅包含垂直位置大于或等于零的状态。下面定义的函数`trajectory`将状态列表转化为适合绘制图形的(y,
    z)对列表。
- en: The infinite list produced by `statesPS` is truncated to a finite list with
    the function `zGE0`, which takes elements of the infinite list with a vertical
    position component greater than or equal to zero. As soon as it finds a vertical
    component less than zero, it stops checking list items and returns the finite
    list.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`statesPS`生成的无限列表通过函数`zGE0`被截断为一个有限列表，该函数从无限列表中选择垂直位置分量大于或等于零的元素。当找到一个垂直分量小于零的元素时，它停止检查列表项并返回有限列表。'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By returning a finite list of states, we are one step closer to plotting the
    trajectory since we can’t plot an infinite list.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过返回一个有限的状态列表，我们更接近于绘制轨迹图，因为我们无法绘制一个无限的列表。
- en: The `trajectory` function returns the horizontal and vertical components of
    position for each state in the input list. This would be a natural thing to plot,
    so we are again one step closer to plotting the trajectory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`trajectory`函数返回输入列表中每个状态的水平和垂直位置分量。这将是一个自然的绘图目标，因此我们又更接近于绘制轨迹。'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finding the Angle for Maximum Range
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 寻找最大射程的角度
- en: Let’s go a little further with our baseball analysis. The function `baseballRange`
    computes the horizontal range of the ball for a given initial speed and angle.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续深入分析棒球。`baseballRange`函数计算给定初速度和角度下球的水平射程。
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To accomplish this, we use the `baseballTrajectory` function from earlier, take
    the last pair with a nonnegative vertical position component, and return the horizontal
    position component of that pair.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，我们使用之前的`baseballTrajectory`函数，取最后一个垂直位置分量为非负值的(y, z)对，并返回该对的水平位置分量。
- en: Now let’s make a graph of baseball range as a function of the angle at which
    the ball is hit. In the absence of air resistance, the maximum range is achieved
    at an angle of 45^∘. Perhaps the presence of air resistance, which we are including,
    will produce different results. The function `baseballRangeGraph` in [Listing
    17-2](ch17.xhtml#ch17list2) makes such a graph for a baseball batted at 45 m/s
    (101 mph).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们绘制击打角度与棒球射程的关系图。在没有空气阻力的情况下，最大射程发生在45^∘的角度下。也许我们考虑的空气阻力会带来不同的结果。`baseballRangeGraph`函数在[清单
    17-2](ch17.xhtml#ch17list2)中绘制了一个以45 m/s（101 mph）速度击打的棒球射程图。
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 17-2: Code to produce the graph “Range for baseball hit at 45 m/s”*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-2：生成“45 m/s击打棒球射程”图的代码*'
- en: '[Figure 17-2](ch17.xhtml#ch17fig2) shows the horizontal range of a batted baseball
    as a function of the angle at which it leaves the bat. We assume an initial speed
    of 45 m/s (101 mph) at every angle. Notice that the longest range occurs at an
    angle less than 45^∘ above the horizontal.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 17-2](ch17.xhtml#ch17fig2)展示了击打棒球的水平射程与击球角度之间的关系。我们假设每个角度下的初始速度为45 m/s（101
    mph）。注意，最大射程发生在一个小于45^∘的角度上。'
- en: '![Image](Images/315fig01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/315fig01.jpg)'
- en: '*Figure 17-2: Range for a batted baseball. Because of air resistance, the longest
    range does not occur at an angle of 45^∘ leaving the bat.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-2：击打棒球的射程。由于空气阻力，最大射程并不出现在45^∘的角度下。*'
- en: We can search for the angle that produces the longest range. The value `bestAngle`
    looks through all of the angles from 30^∘ to 60^∘ in 1^∘ steps to find the angle
    that produces the longest range.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以寻找能够产生最大射程的角度。`bestAngle`值会遍历从30^∘到60^∘的所有角度，步长为1^∘，以找出产生最大射程的角度。
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To find the longest range, we want to compare `baseballRange 0.01 45` `thetaDeg`,
    the range for an initial speed of 45 m/s at an angle of `thetaDeg`, for different
    values of the angle. But we want the `bestAngle` function to return the angle
    at which we achieve the longest range, so we cannot merely ask for the maximum
    of `baseballRange 0.01 45 thetaDeg` because that would return only the range and
    not the angle that achieved that range.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到最大的射程，我们想要比较`baseballRange 0.01 45` `thetaDeg`，即在不同角度下，以45米每秒的初速度投掷的射程。但我们希望`bestAngle`函数返回的是实现最大射程的角度，因此我们不能仅仅要求获取`baseballRange
    0.01 45 thetaDeg`的最大值，因为那只会返回射程，而不会返回实现该射程的角度。
- en: 'We can get what we want, the longest range and the angle at which it is achieved,
    by comparing pairs and asking for the maximum pair. The `maximum` function uses
    dictionary order when comparing pairs, so the maximum pair is the one with the
    largest first element. If there is a tie in comparing first elements, the function
    compares second elements to break the tie. By choosing the first element of the
    pair to be the range, the comparison will be done on the range, and by choosing
    the second element of the pair to be the angle, the function will return the angle
    as well. Here is the value of `bestAngle` reported by GHCi:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过比较一对对的数值并要求返回最大的一对，来获得我们想要的结果，即最大射程和实现该射程的角度。`maximum`函数在比较一对对时使用字典顺序，因此最大的一对是第一个元素最大的。如果第一个元素相等，函数会比较第二个元素以打破平局。通过将一对的第一个元素选择为射程，比较会根据射程进行，而将第二个元素选择为角度，函数也会返回角度。以下是GHCi报告的`bestAngle`的值：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We see that, to within an accuracy of 1^∘, the angle that produces the longest
    range is 41^∘ above the horizontal.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，在1^∘的精度范围内，产生最大射程的角度是41^∘，即高于水平面。
- en: 2D Animation
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2D 动画
- en: Let’s turn now to making an animation of the motion of the baseball. The motion
    takes place in a plane, so we’ll use the two-dimensional `gloss` package. We’ll
    make a stand-alone program to do the animation, and then we’ll show how the program
    can take arguments that specify the initial speed and angle.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向制作棒球运动的动画。运动发生在一个平面内，因此我们将使用二维的`gloss`包。我们将制作一个独立的程序来实现动画，然后展示如何让程序接受指定初速度和角度的命令行参数。
- en: Main Program
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主程序
- en: '[Listing 17-3](ch17.xhtml#ch17list3) gives a stand-alone program for a 2D animation
    of projectile motion using `gloss`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-3](ch17.xhtml#ch17list3)给出了一个使用`gloss`进行二维投射物运动动画的独立程序。'
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 17-3: Stand-alone program for a 2D animation of projectile motion.
    Initial speed and angle can be specified on the command line when the program
    is run.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-3：独立程序，用于二维投射物运动的动画。初速度和角度可以在运行程序时通过命令行指定。*'
- en: As usual, the first line asks for warnings and the next several lines import
    functions and types we want to use in the program.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，第一行要求显示警告，接下来的几行导入我们在程序中需要使用的函数和类型。
- en: 'A new feature of this program is that we pass information to the program using
    command line arguments. A *command line argument* is a piece of information given
    after the name of the program you execute on the command line. For example, for
    a stand-alone program called *GlossProjectile*, obtained by compiling a source
    code file called *GlossProjectile.hs*, we might run the program by entering the
    following instruction at the command line:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的一个新特性是我们通过命令行参数向程序传递信息。*命令行参数*是在你执行程序时，程序名后面给定的一段信息。例如，对于一个叫做*GlossProjectile*的独立程序，它是通过编译名为*GlossProjectile.hs*的源代码文件得到的，我们可以通过在命令行输入以下指令来运行该程序：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We give the name of the executable program we want to run (preceded by a dot-slash
    to indicate its location in the current directory) followed by some command line
    arguments that allow us to pass information to the program. We want to pass the
    initial speed and angle in degrees.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给出要运行的可执行程序的名称（前面加上点斜杠以指示其在当前目录中的位置），然后跟上一些命令行参数，允许我们将信息传递给程序。我们希望传递初速度和角度（单位为度）。
- en: How does the program receive and use this information? The standard module `System.Environment`,
    which is included when you initially install the GHC compiler, provides a function
    `getArgs` that returns the command line arguments as a list of strings. For example,
    the `getArgs` function, if used in the program *GlossProjectile* executed with
    the command just shown, would return the list `["30","40"]`. We can then use these
    strings to determine what the program does. The function `getArgs` is simple and
    sufficient for our purposes, but if you find yourself getting more serious about
    using command line arguments in your Haskell programs, you may want to look at
    the standard module `System.Console.GetOpt`, also included with the GHC compiler,
    as it provides functions to handle command line arguments in a more sophisticated
    way.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 程序如何接收和使用这些信息？标准模块`System.Environment`（在你最初安装GHC编译器时会包含）提供了一个函数`getArgs`，它将命令行参数作为字符串列表返回。例如，在执行命令如上所示的程序*GlossProjectile*时，`getArgs`函数将返回列表`["30","40"]`。然后，我们可以使用这些字符串来确定程序的行为。`getArgs`函数简单且足够满足我们的需求，但如果你在Haskell程序中更加认真地使用命令行参数，可能会想查看标准模块`System.Console.GetOpt`，它同样包含在GHC编译器中，提供了更为复杂的命令行参数处理功能。
- en: 'Knowing that we will have access to a list of strings containing the command
    line arguments, we write a function that does the work our `main` function did
    in previous animations, namely calling `simulateGloss`, but takes a list of strings
    as input. The function `mainWithArgs` in [Listing 17-3](ch17.xhtml#ch17list3)
    does exactly that. As before, `simulateGloss` requires five pieces of information:
    a time-scale factor, an animation rate, an initial state, a display function,
    and a state-update function.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 知道我们将访问包含命令行参数的字符串列表后，我们编写了一个函数来完成我们在之前的动画中`main`函数的工作，即调用`simulateGloss`，但它接受一个字符串列表作为输入。[清单
    17-3](ch17.xhtml#ch17list3)中的`mainWithArgs`函数正是执行了这个操作。如同以前一样，`simulateGloss`需要五个信息：一个时间尺度因子、一个动画速率、一个初始状态、一个显示函数和一个状态更新函数。
- en: We chose a time-scale factor of 3 (so the animation takes place more rapidly
    than the physical evolution) and an animation rate of 20 frames per second. We
    named the list of strings from the command line `args` in `mainWithArgs` and fed
    it to the function `projectileInitial`, which creates the initial state based
    on these strings. We will write the function `projectileInitial` shortly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了一个时间尺度因子为3（这样动画的速度比物理演化更快），动画速率为每秒20帧。我们将来自命令行的字符串列表命名为`args`，并将其传递给函数`projectileInitial`，该函数根据这些字符串创建初始状态。我们稍后会编写`projectileInitial`函数。
- en: The display function `projectilePicture` in [Listing 17-3](ch17.xhtml#ch17list3)
    describes the picture we want to produce for a given particle state. In this display
    function, we create a picture and then scale the entire picture by a factor of
    0.2 pixels/meter. The `scale 0.2 0.2` function shrinks the picture by a factor
    of five in both the horizontal and vertical dimensions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-3](ch17.xhtml#ch17list3)中的显示函数`projectilePicture`描述了我们希望为给定粒子状态生成的图像。在这个显示函数中，我们创建了一张图像，然后通过0.2像素/米的比例缩放整个图像。`scale
    0.2 0.2`函数将图像在水平和垂直方向上都缩小了五倍。'
- en: The `main` program uses the function `getArgs` to get any command line arguments
    specified when the program is run. The function `getArgs` is not a pure function;
    it is an *effectful* function. An effect is a computation that is not purely functional
    (that is, it depends on or changes the world in some way). Computations that depend
    on program input, randomness, or the current time are effects. Sending information
    to a display or writing to the hard drive are also effects. An effect produced
    by a function is sometimes called a side effect, presumably to distinguish it
    from the main purpose of a function, which is to produce an output. A pure function
    is one that involves no effects; its output depends only on its inputs and unchanging
    global values. An effectful function is one whose output depends on something
    other than its inputs (such as user input, command line arguments, or randomness)
    or that has a side effect in addition to its output. In Haskell, an effectful
    function must have a type that involves the `IO` type constructor.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`程序使用`getArgs`函数来获取程序运行时指定的任何命令行参数。`getArgs`函数不是一个纯函数；它是一个*有副作用*的函数。副作用是指那些不完全符合纯函数计算的操作（即它依赖或以某种方式改变了外部环境）。依赖程序输入、随机性或当前时间的计算都是副作用。向显示器发送信息或写入硬盘也是副作用。一个函数产生的副作用有时被称为副作用，目的是与函数的主要功能区分开来，后者是产生输出。纯函数是指没有副作用的函数；它的输出只依赖于输入和不变的全局值。有副作用的函数是指其输出不仅依赖于输入（例如用户输入、命令行参数或随机性），或者它在输出之外还有副作用。在Haskell中，一个有副作用的函数必须具有涉及`IO`类型构造子的类型。'
- en: To see this, let’s load the module `System.Environment` prefixed by a plus sign
    so that the `Mechanics3D` module will not be unloaded, which is the default behavior.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这一点，我们加载模块`System.Environment`，并在其前面加上加号，以便`Mechanics3D`模块不会被卸载，这是默认行为。
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The fact that `getArgs` is an effectful function is indicated by the `IO` type
    constructor. While a pure function’s output can depend only on its inputs and
    unchanging global values, the output of `getArgs` depends on command line arguments,
    which are not function inputs or global values. For this reason, `getArgs` must
    have type `IO [String]` rather than `[String]`. The `IO` tag on data means that
    the data may have been acquired through some effect. The absence of an `IO` tag
    on data is a promise that the data has not been acquired through any effect.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`getArgs`是一个有副作用的函数，这一点通过`IO`类型构造子来表明。虽然纯函数的输出只能依赖于输入和不变的全局值，但`getArgs`的输出依赖于命令行参数，而这些参数既不是函数输入，也不是全局值。因此，`getArgs`的类型必须是`IO
    [String]`，而不是`[String]`。数据上的`IO`标签意味着这些数据可能是通过某种副作用获得的。数据上没有`IO`标签则意味着这些数据不是通过任何副作用获得的。'
- en: The `IO` type constructor that labels an effectful function is one example of
    a collection of type constructors known as *monads*. The idea of a monad has been
    around in the mathematics of category theory for several decades; its use in functional
    programming is more recent, where it represents a computational abstraction. Haskell
    has a type class `Monad` for type constructors, such as `IO`, that can implement
    certain functions. Since the `IO` type constructor is an instance of type class
    `Monad`, it is also referred to as the `IO` monad. It is not the intent of this
    book to say much about monads. Monads are an interesting abstraction, but I don’t
    think physics has a strong need for them. The books *Real World Haskell* [**[2](bib.xhtml#bib2)**]
    and *Learn You a Haskell for Great Good* [**[1](bib.xhtml#bib1)**] have nice discussions
    of monads. Stephen Diehl’s “What I Wish I Knew When Learning Haskell” at [http://dev.stephendiehl.com/hask](http://dev.stephendiehl.com/hask)
    also has a nice discussion of monads.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 标记有副作用函数的`IO`类型构造子是称为*单子*（monads）的一组类型构造子的一个例子。单子的概念在范畴理论的数学中已经存在了几十年；它在函数式编程中的应用较为近期，在那里它代表了一种计算抽象。Haskell有一个类型类`Monad`，用于支持能够实现特定功能的类型构造子，如`IO`。由于`IO`类型构造子是类型类`Monad`的一个实例，因此它也被称为`IO`单子。本书的目的不是深入探讨单子。单子是一个有趣的抽象，但我认为物理学并不强烈需要它们。*Real
    World Haskell* [**[2](bib.xhtml#bib2)**]和*Learn You a Haskell for Great Good*
    [**[1](bib.xhtml#bib1)**]对单子有很好的讨论。Stephen Diehl的《What I Wish I Knew When Learning
    Haskell》可在[http://dev.stephendiehl.com/hask](http://dev.stephendiehl.com/hask)上找到，也有对单子的很好的讨论。
- en: The operator `>>=`, called “bind,” is the most important of the monad functions.
    In the context of the `IO` monad we have here, it provides a way to use information
    arising from an effectful function. To understand its use, let’s take a look at
    its type.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符`>>=`，称为“bind”，是单子函数中最重要的一个。在我们这里的`IO`单子上下文中，它提供了一种使用由有副作用的函数产生的信息的方法。为了理解它的使用，我们来看一下它的类型。
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The type variables `a` and `b` stand for types, while the type variable `m`
    stands for a type constructor. The type class `Monad` has type constructors as
    instances. Haskell’s notion of *kind*, introduced in [Chapter 9](ch09.xhtml),
    helps to classify the possibilities of what a type variable can stand for.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类型变量`a`和`b`代表类型，而类型变量`m`代表类型构造器。类型类`Monad`有类型构造器作为其实例。Haskell中的*kind*概念，在[第9章](ch09.xhtml)中介绍，有助于分类类型变量所能代表的可能性。
- en: 'For our purpose, the type variable `m` can be replaced with `IO`, which is
    an instance of type class `Monad`. Specializing the bind operator to the `IO`
    type constructor, bind has the following type:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，类型变量`m`可以替换为`IO`，它是类型类`Monad`的一个实例。将bind运算符专门化为`IO`类型构造器后，bind具有以下类型：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We see that bind takes two things: a value with type `a` “tagged” by the `IO`
    type constructor and an effectful function whose input has type `a`, which produces
    a value of type `b` “tagged” by the `IO` type constructor. We can think of this
    `IO` type constructor as a tag on the value that indicates its origin and/or effect.
    The bind operator allows an `IO`-tagged value to be used as a regular value in
    a function that promises to return an `IO`-tagged result. Since `IO` acts as a
    tag for effects, it is important that the `IO` tag is not removable once applied.
    However, if a function returns a tagged output, the bind operator provides a way
    for a tagged input to be temporarily untagged and used, knowing that the function
    will retag the output.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到bind接收两个参数：一个类型为`a`的值，由`IO`类型构造器“标记”，以及一个输入类型为`a`、输出类型为`b`的有副作用的函数，输出结果由`IO`类型构造器“标记”。我们可以将这个`IO`类型构造器视为一个标签，用来指示值的来源和/或副作用。bind运算符允许一个`IO`标记的值作为普通值在承诺返回`IO`标记结果的函数中使用。由于`IO`充当副作用的标签，重要的是一旦应用，就不能移除`IO`标签。然而，如果一个函数返回一个带标签的输出，bind运算符提供了一种方法，使带标签的输入可以临时去标签并使用，同时知道该函数会重新给输出加标签。
- en: 'We are using the bind operator (`>>=`) in a setting where type variable `a`
    is `[String]` and type variable `b` is unit, so the concrete type of bind in our
    program is the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个类型变量`a`为`[String]`，类型变量`b`为unit的设置中使用了bind运算符，因此我们程序中bind的具体类型如下：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The bind operator is just what we need to connect the output of `getArgs` with
    the input of `mainWithArgs`. In fact, the `main` program does nothing other than
    pass the output of `getArgs` to the function `mainWithArgs`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: bind运算符正是我们所需要的，它将`getArgs`的输出与`mainWithArgs`的输入连接起来。实际上，`main`程序只做了一件事：将`getArgs`的输出传递给函数`mainWithArgs`。
- en: State-Update Function and Initial State
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 状态更新函数和初始状态
- en: The state-update function `projectileUpdate` is written using `updatePS`, just
    as in satellite motion.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 状态更新函数`projectileUpdate`是使用`updatePS`编写的，就像在卫星运动中一样。
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Again, for our numerical method, we chose the Euler-Cromer method. We used the
    same list of one-body forces, `baseballForces`, that we used to make the graph
    shown earlier.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于我们的数值方法，我们选择了欧拉-克罗默方法。我们使用了同样的单体力列表`baseballForces`，它之前用于绘制图表。
- en: 'Knowing that we want to pass the initial speed and angle to our program as
    command line arguments, and that these will be available as a list of strings,
    we’ll write the function `projectileInitial` to take a list of strings, which
    will come from the command line when we run the program, and use these strings
    to determine the initial velocity. We want the list of strings to have two elements:
    the first string gives the initial speed and the second gives the initial angle
    in degrees.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 知道我们想将初始速度和角度作为命令行参数传递给程序，并且这些参数将作为字符串列表提供，我们将编写函数`projectileInitial`，接受一个来自命令行的字符串列表，并使用这些字符串来确定初始速度。我们希望这个字符串列表有两个元素：第一个字符串表示初始速度，第二个表示初始角度（以度为单位）。
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We use pattern matching on the input to give a helpful error message if exactly
    two arguments are not provided. The first line responds to the empty list, the
    case in which no command line arguments are given. The second line responds to
    the case in which only one command line argument is given. The third line responds
    to the case in which three or more command line arguments are given. Finally,
    the fourth line treats the case of exactly two command line arguments, which is
    what we want.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对输入进行模式匹配，以便在没有提供两个参数时给出有帮助的错误信息。第一行响应空列表的情况，即没有给定任何命令行参数的情况。第二行响应只有一个命令行参数的情况。第三行响应给定三个或更多命令行参数的情况。最后，第四行处理正好提供两个命令行参数的情况，这就是我们所需要的。
- en: 'We use the `read` function to convert the strings to real numbers. The `read`
    function takes a string as input and produces an output that is one of many types.
    We need to give a type annotation to specify what type we want the string converted
    to. Here is an example of what `read` does:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`read`函数将字符串转换为实数。`read`函数接受一个字符串作为输入，并生成一个输出，这个输出可以是多种类型之一。我们需要提供类型注解来指定我们希望将字符串转换为什么类型。以下是`read`函数的示例：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 3D Animation
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3D 动画
- en: Several of the items needed to create a 3D animation are the same as those needed
    for a 2D animation, but one is different. To compare the process of making a 3D
    animation with that of making a 2D animation, let’s animate the projectile motion
    using our 3D animation tools. [Listing 17-4](ch17.xhtml#ch17list4) gives a stand-alone
    program for a 3D animation of projectile motion using `not-gloss`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 创建3D动画所需的几个项目与创建2D动画所需的相同，但有一个不同。为了比较制作3D动画和制作2D动画的过程，让我们使用3D动画工具来演示弹道运动。[清单17-4](ch17.xhtml#ch17list4)提供了一个独立的程序，用于使用`not-gloss`进行弹道运动的3D动画。
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 17-4: Stand-alone program for a 3D animation of projectile motion*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单17-4：一个独立程序用于3D动画的弹道运动*'
- en: The `main` function is exactly the same as in the 2D animation. The `main` `WithArgs`
    function uses `simulateVis` instead of `simulateGloss`, but it uses the same time-scale
    factor, animation rate, initial-state function, and state-update function we used
    for the 2D animation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数与2D动画中的完全相同。`main`的`WithArgs`函数使用`simulateVis`代替`simulateGloss`，但是它使用了与2D动画相同的时间尺度因子、动画速率、初始状态函数和状态更新函数。'
- en: The only new piece we need is a display function, `projectileVisObject`. In
    this display function, the state is named `st`, and we define a local variable
    `r` for the position of the object. We use a solid red sphere with radius 0.1
    to represent the projectile. The `not-gloss` package does not measure distances
    in pixels; instead, a length of 1 is initially about 20 percent of the height
    of the screen. You can then zoom in or out by pressing E or Q, or by using the
    mouse. Before we translate the red sphere to its appropriate position, we need
    to scale the position `r` from meters to `Vis` units, and we need to convert the
    position to `Vis`’s vector type. We multiply the position by a factor of 0.01
    `Vis` units per meter so the range of the animation is not too big and not too
    small. We use the `v3FromVec` function, defined in [Chapter 16](ch16.xhtml), to
    convert to `Vis`’s vector type before using the `Trans` function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一需要的新组件是一个显示函数，`projectileVisObject`。在这个显示函数中，状态被命名为`st`，我们定义了一个局部变量`r`表示物体的位置。我们使用一个半径为0.1的实心红色球体来表示弹道物体。`not-gloss`包并不以像素为单位来测量距离；相反，初始时长度1大约是屏幕高度的20%。然后，你可以通过按E或Q键，或者使用鼠标来放大或缩小。在我们将红色球体移到适当的位置之前，我们需要将位置`r`从米转换为`Vis`单位，并且需要将位置转换为`Vis`的向量类型。我们将位置乘以一个因子0.01，将每米转换为`Vis`单位，这样动画的范围既不太大也不太小。在使用`Trans`函数之前，我们使用在[第16章](ch16.xhtml)中定义的`v3FromVec`函数将位置转换为`Vis`的向量类型。
- en: Having seen an example of projectile motion with air resistance, the technique
    of using command line arguments to pass information into a program, and a comparison
    of 2D and 3D animation, let’s turn to an example that really requires 3D animation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到带空气阻力的弹道运动示例、使用命令行参数将信息传递到程序中的技术以及2D与3D动画的比较之后，接下来我们将看一个真正需要3D动画的示例。
- en: Proton in a Magnetic Field
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 磁场中的质子
- en: Magnetic fields are used in particle accelerators to get protons or electrons
    to move in a circular ring to bring them to high speed and slam them into each
    other. This lets experimentalists look at the particles created in such high-energy
    collisions and learn things about the nature of particles and their interactions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 磁场被用于粒子加速器中，使质子或电子沿圆环轨道运动，以加速它们并使它们相互碰撞。这让实验人员能够观察到在这些高能碰撞中产生的粒子，并了解粒子及其相互作用的性质。
- en: A charged particle in a uniform magnetic field will move in a circle or a helix.
    This is not obvious, but it is a consequence of the Lorentz force law, given as
    Equation 16.8 for uniform fields. Luckily for us, a helix is a nice motion for
    showing off our 3D animation tools.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 处于均匀磁场中的带电粒子将沿着圆形或螺旋形轨迹运动。这一点并不显而易见，但它是洛伦兹力定律的结果，均匀磁场下可用公式 16.8 表示。幸运的是，螺旋运动对于展示我们的三维动画工具来说是一个很好的运动方式。
- en: According to the Lorentz force law, the magnetic force on a particle is proportional
    to the cross product **v**(*t*) ×**B**, which means that the force is perpendicular
    to both the particle’s velocity and the magnetic field. Since the magnetic force
    is always perpendicular to the velocity of the particle, it can’t make the particle
    speed up or slow down; it can only make the particle turn (change direction).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据洛伦兹力定律，粒子所受的磁力与**v**(*t*) × **B**的叉乘成正比，这意味着力垂直于粒子的速度和磁场。由于磁力始终垂直于粒子的速度，它无法使粒子加速或减速；它只能使粒子转弯（改变方向）。
- en: To produce an animation of this, we’ll need a state-update function, an initial
    state, and a display function. Here is a state-update function for a particle
    in a uniform magnetic field of strength 3 × 10^(–8) Tesla.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作这个动画，我们需要一个状态更新函数、一个初始状态和一个显示函数。这里是一个粒子在强度为 3 × 10^(-8) 特斯拉的均匀磁场中的状态更新函数。
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We’re using fourth-order Runge-Kutta as our numerical method because it produces
    good results with a fairly large step size, while Euler-Cromer requires a rather
    small step size to produce good results. There’s no way to know this in advance.
    It’s always a good idea to check that results are stable with changes in step
    size. The list of forces has only one item, the Lorentz force of a uniform magnetic
    field. The `zeroV` is for zero electric field.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用四阶龙格-库塔方法作为数值计算方法，因为它在步长较大的情况下能产生良好的结果，而欧拉-克罗默方法则需要较小的步长才能得到好的结果。这个在事前是无法知道的。检查结果在步长变化时是否稳定总是一个好主意。力的列表只有一个项，即均匀磁场的洛伦兹力。`zeroV`表示零电场。
- en: 'Here is the initial state of the proton on which the magnetic field acts:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是磁场作用下质子的初始状态：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By giving the proton an initial component of velocity in both the y- and z-directions,
    we’ll get a helix for the motion. If either of these components is set to 0, a
    different kind of motion will ensue. Play around and see what happens.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给质子在 y 和 z 方向上赋予初始速度分量，我们会得到螺旋运动。如果其中一个分量设置为 0，运动方式将不同。你可以尝试一下，看看会发生什么。
- en: 'Here is the display function for the proton in the magnetic field:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是显示质子在磁场中的函数：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A red ball is used to mark the location of the proton.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 红色小球用于标记质子的位置。
- en: '[Listing 17-5](ch17.xhtml#ch17list5) shows a stand-alone Haskell program to
    animate a proton in a magnetic field. The time-scale factor is set to one, so
    this is a real-time animation. Note that the magnetic field is very small in this
    example and that a larger magnetic field would cause the proton to complete a
    turn of the helix in much less time. The animation rate is set to 60 frames/second.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-5](ch17.xhtml#ch17list5)展示了一个独立的 Haskell 程序，用于在磁场中动画展示质子。时间尺度因子设置为 1，因此这是一个实时动画。请注意，在这个示例中，磁场非常小，而较大的磁场将使质子在更短的时间内完成螺旋转弯。动画帧率设置为每秒
    60 帧。'
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 17-5: Stand-alone Haskell program for 3D animation of a proton in
    a uniform magnetic field*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 17-5：用于在均匀磁场中显示质子三维动画的独立 Haskell 程序*'
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we used the ideas and code from [Chapter 16](ch16.xhtml) to
    study three examples of the motion of a single particle in three dimensions subject
    to different forces. We gave examples of 2D or 3D animation for satellite motion,
    projectile motion with air resistance, and a particle in a magnetic field. In
    the next chapter, we’ll show how the ideas and code from [Chapter 16](ch16.xhtml)
    can be used or modified slightly to treat single-particle mechanics problems with
    the theory of relativity instead of Newton’s second law.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了[第16章](ch16.xhtml)中的思想和代码，研究了受不同力作用的三维空间中单个粒子的运动。我们展示了卫星运动、带空气阻力的抛体运动以及在磁场中的粒子运动的2D或3D动画示例。在下一章，我们将展示如何使用或稍微修改[第16章](ch16.xhtml)中的思想和代码，用相对论理论代替牛顿第二定律，来处理单粒子力学问题。
- en: Exercises
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Exercise 17.1.** Modify the `halleyPicture` function in [Listing 17-1](ch17.xhtml#ch17list1)
    to include x- and y-axes in the animation. You will be able to see that the comet’s
    aphelion (point of greatest distance from the sun) is not quite aligned with the
    x-axis. This is an indication of inaccuracy in the numerical method, which can
    be reduced by decreasing the time-scale factor and reducing the time step of the
    numerical method.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 17.1.** 修改[清单 17-1](ch17.xhtml#ch17list1)中的`halleyPicture`函数，在动画中加入x轴和y轴。你将能够看到彗星的远日点（离太阳最远的点）并未与x轴完全对齐。这表明数值方法存在不准确性，减少时间尺度因子和减小时间步长可以降低这种不准确性。'
- en: '**Exercise 17.2.** Let’s treat Earth as being fixed at the origin of our coordinate
    system. Consider the gravitational force on a satellite of mass *m*, initial position
    **r**[0], and initial velocity **v**[0]. Since the motion of the satellite will
    take place in a plane, we can use vectors that lie in the xy-plane. Plot trajectories
    of orbits resulting from various initial conditions. Choose some values for initial
    conditions that give nearly circular orbits and some others that give elliptical
    orbits. You will find that the Euler method produces orbits that don’t close on
    themselves. Make one plot comparing the Euler and Euler-Cromer methods for one
    orbit that you like (elliptical or circular). Indicate the step size you used
    for the Euler and Euler-Cromer methods as well as your choice of initial conditions.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 17.2.** 假设地球位于我们坐标系统的原点。考虑一颗质量为*m*的卫星，其初始位置为**r**[0]，初始速度为**v**[0]。由于卫星的运动发生在一个平面内，我们可以使用位于xy平面内的向量。绘制不同初始条件下轨道的轨迹。选择一些初始条件，使其得到近乎圆形的轨道，也选择其他一些初始条件，使其得到椭圆形轨道。你会发现欧拉方法产生的轨道并不会闭合。绘制一张比较欧拉方法和欧拉-克罗梅尔方法的图表，选择你喜欢的一条轨道（圆形或椭圆形）。标明你在欧拉方法和欧拉-克罗梅尔方法中使用的步长以及你的初始条件选择。'
- en: '**Exercise 17.3.** The Lorentz force law, Equation 16.8, describes the force
    exerted on a particle with charge *q* and velocity **v**(*t*) by an electric field
    **E** and a magnetic field **B**. Consider a uniform magnetic field in the z-direction.
    You may already know that a charged particle with initial velocity in the x-direction
    will go in circles in this magnetic field. Choose some values for the strength
    of the magnetic field, the charge of the particle, the mass of the particle, and
    the initial velocity. Confirm, using the Euler-Cromer method, that the particle
    does indeed go in circles. Plot *y* versus *x* for different time steps. Even
    the Euler-Cromer method will not produce circles that close on themselves if the
    time step is too big. One of your time steps should be small enough that the orbit
    appears to close.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 17.3.** 洛伦兹力定律，方程16.8，描述了电场**E**和磁场**B**对一个带电粒子（电荷为*q*，速度为**v**(*t*)）施加的力。考虑一个方向为z的均匀磁场。你可能已经知道，带电粒子如果初始速度沿x方向，在这个磁场中会沿圆形轨道运动。选择一些磁场强度、粒子电荷、粒子质量和初始速度的值。使用欧拉-克罗梅尔方法确认粒子确实沿圆形轨道运动。绘制不同时间步长下的*y*与*x*的关系图。如果时间步长过大，即使是欧拉-克罗梅尔方法也无法产生闭合的圆形轨道。你应该选择一个足够小的时间步长，使得轨道看起来会闭合。'
- en: '**Exercise 17.4.** Return to the satellite orbiting Earth. Write a Haskell
    program to animate your satellite’s motion around Earth. Show that by using different
    initial conditions, you can achieve circular orbits and elliptical orbits.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 17.4.** 回到绕地球运行的卫星。编写一个Haskell程序，动画展示卫星绕地球的运动。通过使用不同的初始条件，展示你可以得到圆形轨道和椭圆形轨道。'
- en: '**Exercise 17.5.** Suppose the wind is blowing horizontally at 10 m/s and you
    launch a Ping-Pong ball straight up into the air with an initial speed of 5 m/s.
    How far from the launch point will it hit the ground? You can come up with pretty
    good estimates for the density of air and the mass and cross-sectional area of
    the ball, but an estimate for the drag coefficient is more of a guess. Try the
    calculation for drag coefficients of 0.5, 1.0, and 2.0 to see how they compare.
    Repeat the calculation for a golf ball launched upward with the same speed.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 17.5.** 假设风速为10 m/s，并且你将一个乒乓球以5 m/s的初速度直接向上发射。它会距离发射点多远落地？你可以估算空气的密度、球的质量和横截面积，但对于阻力系数的估计则更像是猜测。尝试计算阻力系数为0.5、1.0和2.0时的结果，并比较它们的差异。用相同速度发射一个高尔夫球，并重复计算。'
- en: '**Exercise 17.6.** Make the necessary modifications to the code presented in
    this chapter so that the initial position of the baseball is 1 meter above the
    ground. Make a plot of the trajectory for a line drive with a speed of 40 m/s
    at an angle 5^∘ above horizontal.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 17.6.** 对本章中展示的代码进行必要的修改，使得棒球的初始位置为离地面1米。绘制一条40 m/s速度、角度为5^∘的平飞轨迹图。'
- en: '**Exercise 17.7.** Investigate the effect of a 30-mph crosswind on a batted
    baseball. Assuming the wind is perpendicular to the plane in which the ball would
    otherwise travel, how far does the wind displace the ball from the place where
    it would land without the wind? Choose some reasonable values for initial speed
    and angle of the ball.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 17.7.** 调查30英里每小时横风对击打棒球的影响。假设风是垂直于球原本会行进的平面，风将球从原本着陆的地方移动多远？选择一些合理的初速度和角度值。'
- en: '**Exercise 17.8.** Given an initial speed and a drag coefficient, the optimal
    angle is the angle that produces the longest range for the baseball. Make a graph
    of the optimal angle as a function of drag coefficient for an initial speed of
    45 m/s.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 17.8.** 给定初速度和阻力系数，最优角度是能够使棒球达到最远距离的角度。绘制初速度为45 m/s时，最优角度随阻力系数变化的图像。'
- en: '**Exercise 17.9.** If you can produce uniform electric and magnetic fields,
    you can make a device called a *velocity selector*. The purpose of a velocity
    selector is to allow charged particles that are traveling at a specific velocity
    to proceed in a straight line, while similar particles traveling faster or slower
    get deflected. From a beam of charged particles moving with a range of speeds,
    the velocity selector can produce a beam of particles that all have very close
    to the same speed. In this way, the experimentalist has access to a beam of charged
    particles with a known velocity that can be used for some experiment.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 17.9.** 如果你能产生均匀的电场和磁场，你可以制造一个叫做*速度选择器*的装置。速度选择器的目的是允许以特定速度运动的带电粒子沿直线前进，而其他速度较快或较慢的粒子则会偏转。从一束具有不同速度的带电粒子中，速度选择器可以产生一束速度几乎相同的粒子。通过这种方式，实验者可以获得具有已知速度的带电粒子束，用于某些实验。'
- en: Let’s model a velocity selector using a uniform electric field of 300 N/C in
    the positive z-direction and a uniform magnetic field of 0.3 T in the positive
    x-direction. We’re interested in the motion of a singly ionized particle with
    mass 1.00 × 10^(–22) kg. (Singly ionized means that one electron has been removed
    so the particle has the charge of a proton.) We’ll give this particle an initial
    velocity in the positive y-direction. If the particle is moving too fast, it will
    deflect one way; if it’s moving too slowly, it will deflect another way.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个均匀的电场（强度为300 N/C，方向沿正z轴）和一个均匀的磁场（强度为0.3 T，方向沿正x轴）来模拟速度选择器。我们关注的是质量为1.00
    × 10^(–22) kg的单次电离粒子的运动。（单次电离意味着去掉了一个电子，粒子带有一个质子的电荷。）我们将赋予该粒子一个沿正y轴方向的初速度。如果粒子运动得太快，它会偏转一个方向；如果运动得太慢，它会偏转另一个方向。
- en: Using the `Vis` module, make a stand-alone program that takes the initial speed
    of the particle as input (similar to how our projectile motion program took initial
    speed and angle as input) and produces an animation for the particle in the velocity
    selector. To judge whether and how much the particle is deflecting, include a
    coordinate system in your picture (similar to the coordinate system we displayed
    in [Chapter 13](ch13.xhtml)), so you can tell when the particle departs from the
    y-axis. Use a time-scale factor of 5 × 10^(–4) and an animation rate of 60 frames/second.
    Run this program with different initial speeds between 0 and 5,000 m/s.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Vis`模块，制作一个独立的程序，输入粒子的初速度（类似于我们投射物运动程序输入初速度和角度的方式），并为速度选择器中的粒子制作动画。为了判断粒子是否偏转以及偏转的程度，在图像中加入坐标系（类似于我们在[第13章](ch13.xhtml)中展示的坐标系），这样你就能知道粒子何时偏离y轴。使用时间尺度因子5
    × 10^(–4)和动画速率60帧/秒。使用不同初速度（介于0和5000 m/s之间）运行该程序。
- en: (a) Confirm that the particle deflects one way for slow speeds.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 确认粒子在低速时会朝一个方向偏转。
- en: (b) Confirm that the particle deflects another way for fast speeds.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 确认粒子在高速时会朝另一个方向偏转。
- en: (c) Extend your program to include a circular aperture at *y* = 1 m that allows
    particles to pass through. Start with an aperture radius of 4 cm.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: (c) 扩展你的程序，加入一个位于*y* = 1 m的圆形孔径，允许粒子通过。首先设定孔径半径为4厘米。
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Particles outside this radius will be blocked by a wall and not allowed to
    pass through. Modify your state-update function to include a wall force that blocks
    particles outside the aperture radius when they get to *y* = 1 m. You can use
    the following wall force:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 位于该半径外的粒子将会被墙壁阻挡，无法通过。修改你的状态更新函数，加入一个墙壁力，当粒子到达*y* = 1 m时，阻挡半径外的粒子通过。你可以使用以下墙壁力：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This wall force applies a dissipative force that will slow the particle to a
    crawl in just a few time steps if its y-value is between 100 cm and 110 cm and
    it is outside the aperture radius. You could think of the wall as 10 cm of lead,
    but the real reason for the 10 cm is to catch particles that are moving very quickly;
    the wall thickness could be reduced if the time step was reduced. (You may notice
    that particles crawl along the wall at a slow speed or move through the 10 cm–long
    aperture “tube” because the electric field still acts on them.) Modify your display
    function to include a circle for the aperture. Find the range of velocities allowed
    through the 4-cm aperture. What range of velocities are allowed through a 1 cm–radius
    aperture? How about a 1 mm–radius aperture?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个墙壁力施加一种耗散性力，如果粒子的y值在100厘米到110厘米之间且位于孔径半径外，它将在很短的时间步内将粒子减速至几乎停下。你可以把墙壁看作是10厘米的铅墙，但实际原因是为了捕捉那些快速移动的粒子；如果减少时间步长，墙壁的厚度可以减小。（你可能会注意到粒子沿墙壁缓慢移动，或者穿过这个10厘米长的孔径“管道”，因为电场仍然对其起作用。）修改你的显示函数，加入一个圆形代表孔径。找出通过4厘米孔径的速度范围。1厘米半径的孔径允许通过的速度范围是多少？那1毫米半径的孔径呢？
- en: Try to guess how the target velocity (velocity of particle when undeflected)
    is related to the numeric values of electric and magnetic fields.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试猜测目标速度（未偏转时的粒子速度）与电场和磁场的数值之间的关系。
- en: '**Exercise 17.10.** Use the `Vis` module to animate the motion of Halley’s
    comet. Instead of Euler-Cromer, use fourth-order Runge-Kutta because the `Vis`
    module can’t achieve an animation rate of 400 frames/second (although it won’t
    tell you this and it will do the best it can). Try animation rates of 20 frames/second
    (too small, the orbits spiral inward toward the sun), 60 frames/second (pretty
    good), and 400 frames/second (really good, even though 400 frames/second is not
    being achieved). You may want to use the following function as the last transformation
    of your picture before handing it off to `simulateVis`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 17.10.** 使用`Vis`模块动画化哈雷彗星的运动。改用四阶Runge-Kutta法代替欧拉-克罗默法，因为`Vis`模块无法达到每秒400帧的动画速率（尽管它不会告诉你这一点，但会尽力做到最好）。尝试使用20帧/秒（太低，轨道会螺旋向太阳靠近）、60帧/秒（相当好）和400帧/秒（非常好，尽管400帧/秒实际上未能达到）。你可能需要使用以下函数作为图像的最后变换，然后将其交给`simulateVis`：'
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The function `zOut` orients the display so that the xy-plane is more or less
    the plane of the screen, and *z* points out from the screen. The default orientation
    has *x* pointing out of the screen, *y* to the right, and *z* up the screen.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`zOut`调整显示方向，使得xy平面大致与屏幕平面平行，并且*z*轴从屏幕中指向外面。默认方向是*x*轴从屏幕外指向，*y*轴指向右侧，*z*轴指向屏幕上方。
- en: '**Exercise 17.11.** Use `gnuplot` to make plots of the Halley’s comet orbit
    using different numerical methods. Use Euler, Euler-Cromer, and fourth-order Runge-Kutta,
    each with time steps of 1/20 year, 1/60 year, and 1/400 year. The results should
    look [Figure 17-3](ch17.xhtml#ch17fig3), where the left column is Euler, the middle
    column is Euler-Cromer, and the right column is fourth-order Runge-Kutta. The
    top row uses a time step of 1/20 year, the middle row 1/60 year, and the bottom
    row 1/400 year.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 17.11.** 使用`gnuplot`绘制哈雷彗星轨道，采用不同的数值方法。使用欧拉法、欧拉-克罗默法和四阶龙格-库塔法，每种方法的时间步长分别为1/20年、1/60年和1/400年。结果应类似于[图17-3](ch17.xhtml#ch17fig3)，其中左列为欧拉法，中列为欧拉-克罗默法，右列为四阶龙格-库塔法。第一行使用1/20年的时间步长，中间一行使用1/60年的时间步长，底行使用1/400年的时间步长。'
- en: '![Image](Images/326fig01.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/326fig01.jpg)'
- en: '*Figure 17-3: Halley’s comet orbit using Euler, Euler-Cromer, and fourth-order
    Runge-Kutta, with time steps of 1/20 year, 1/60 year, and 1/400 year, respectively.*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-3：哈雷彗星轨道，使用欧拉法、欧拉-克罗默法和四阶龙格-库塔法，时间步长分别为1/20年、1/60年和1/400年。*'
- en: When calculating orbits, we can take advantage of energy conservation to check
    the numerical accuracy of the integration scheme. The particle state structure
    has the position of the comet, from which we can find the potential energy, and
    the velocity, from which we can compute the kinetic energy. Write a function
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算轨道时，我们可以利用能量守恒来检查积分方案的数值精度。粒子状态结构包含彗星的位置，从中我们可以找到势能，以及速度，从而计算出动能。编写一个函数
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: that computes the total energy of Halley’s comet in a given `ParticleState`.
    We know that the total energy of Halley’s comet is conserved, so any change in
    the energy we calculate is due to inaccuracies in the numerical method we are
    using. We can use the fractional change in energy over a period of one orbit as
    a measure of how good our numerical method is.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 计算给定`ParticleState`下哈雷彗星的总能量。我们知道哈雷彗星的总能量是守恒的，因此我们计算出的能量变化是由于我们使用的数值方法的不准确性。我们可以通过计算一个轨道周期内的能量变化率来衡量我们的数值方法的准确性。
- en: 'For numerical methods that are reasonably good, such as the three in the lower-right
    corner of [Figure 17-3](ch17.xhtml#ch17fig3), we can use the following predicate
    with `takeWhile` to truncate the list of states after one orbit has occurred:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于合理的数值方法，例如[图17-3](ch17.xhtml#ch17fig3)右下角的三种方法，我们可以使用以下谓词与`takeWhile`结合，在一个轨道周期结束后截断状态列表：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This predicate works by accepting the first 50 years of orbit data (recall the
    period is about 75 years), at which point the y-component of position is negative,
    and continuing to accept data until the y-component becomes positive, which indicates
    the beginning of the second orbit.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 该谓词通过接受前50年的轨道数据（记住周期大约是75年），此时位置的y分量为负数，并继续接收数据，直到y分量变为正数，这表示第二个轨道的开始。
- en: Calculate the fractional change in energy over a period of one orbit for (a)
    the Euler-Cromer method with step size 1/400 year (you should get about one percent),
    (b) the fourth-order Runge-Kutta method with step size 1/60 year, and (c) the
    fourth-order Runge-Kutta method with step size 1/400 year. For an extra challenge,
    label each `gnuplot` graph with the fractional change in energy over a single
    orbit.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一个轨道周期内能量的变化率：（a）使用步长为1/400年的欧拉-克罗默方法（你应该得到大约1%的变化率），（b）使用步长为1/60年的四阶龙格-库塔方法，（c）使用步长为1/400年的四阶龙格-库塔方法。作为额外挑战，使用`gnuplot`标记每个图形，表示单个轨道周期内的能量变化率。
