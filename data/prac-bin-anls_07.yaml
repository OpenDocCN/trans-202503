- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: BASIC BINARY ANALYSIS IN LINUX
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中进行基础二进制分析
- en: Even in the most complex binary analysis, you can accomplish surprisingly advanced
    feats by combining a set of basic tools in the right way. This can save you hours
    of work implementing equivalent functionality on your own. In this chapter, you’ll
    learn the fundamental tools you’ll need to perform binary analysis on Linux.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在最复杂的二进制分析中，你也可以通过以正确的方式结合一组基本工具来完成令人惊讶的高级任务。这可以节省你自己实现等效功能的数小时工作。在本章中，你将学习在
    Linux 上进行二进制分析所需的基本工具。
- en: Instead of simply showing you a list of tools and explaining what they do, I’ll
    use a *Capture the Flag (CTF)* challenge to illustrate how they work. In computer
    security and hacking, CTF challenges are often played as contests, where the goal
    is typically to analyze or exploit a given binary (or a running process or server)
    until you manage to capture a flag hidden in the binary. The flag is usually a
    hexadecimal string, which you can use to prove that you completed the challenge
    as well as unlock new challenges.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会仅仅列出工具并解释它们的作用，而是通过一个 *Capture the Flag (CTF)* 挑战来演示它们是如何工作的。在计算机安全和黑客攻击中，CTF
    挑战通常作为竞赛进行，目标通常是分析或利用给定的二进制文件（或正在运行的进程或服务器），直到你成功捕获隐藏在二进制中的旗标。旗标通常是一个十六进制字符串，你可以用它来证明你完成了挑战，并解锁新的挑战。
- en: In this CTF, you start with a mysterious file called *payload*, which you can
    find on the VM in the directory for this chapter. The goal is to figure out how
    to extract the hidden flag from *payload*. In the process of analyzing *payload*
    and looking for the flag, you’ll learn to use a wide range of basic binary analysis
    tools that are available on virtually any Linux-based system (most of them as
    part of GNU `coreutils` or `binutils`). I encourage you to follow along.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 CTF 中，你从一个神秘的文件 *payload* 开始，它位于本章的虚拟机目录中。目标是找出如何从 *payload* 中提取隐藏的旗标。在分析
    *payload* 并寻找旗标的过程中，你将学习使用一系列可以在几乎所有基于 Linux 的系统上找到的基础二进制分析工具（大多数工具是 GNU `coreutils`
    或 `binutils` 的一部分）。我鼓励你跟随并实践。
- en: Most of the tools you’ll see have a number of useful options, but there are
    far too many to cover exhaustively in this chapter. Thus, it’s a good idea to
    check out the man page for every tool using the command `man` *tool* on the VM.
    At the end of the chapter, you’ll use the recovered flag to unlock a new challenge,
    which you can complete on your own!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到的大多数工具都有许多有用的选项，但在本章中无法全面覆盖所有选项。因此，建议你在虚拟机上使用命令 `man` *tool* 查看每个工具的手册页。本章结束时，你将使用恢复的旗标来解锁新的挑战，之后你可以独立完成它！
- en: 5.1 Resolving Identity Crises Using file
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1 使用 file 解决身份危机
- en: Because you received absolutely no hints about the contents of *payload*, you
    have no idea what to do with this file. When this happens (for instance, in reverse
    engineering or forensics scenarios), a good first step is to figure out what you
    can about the file type and its contents. The `file` utility was designed for
    this purpose; it takes a number of files as input and then tells you what type
    each file is. You may remember it from [Chapter 2](ch02.xhtml#ch02), where I used
    `file` to find out the type of an ELF file.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你没有任何关于 *payload* 内容的提示，所以你完全不知道该如何处理这个文件。当发生这种情况时（例如，在逆向工程或取证场景中），一个好的第一步是弄清楚关于文件类型和内容的所有信息。`file`
    工具就是为此设计的；它接受多个文件作为输入，然后告诉你每个文件的类型。你可能还记得在[第二章](ch02.xhtml#ch02)中，我使用 `file` 来确定
    ELF 文件的类型。
- en: 'The nice thing about `file` is that it isn’t fooled by extensions. Instead,
    it searches for other telltale patterns in the file, such as magic bytes like
    the `0x7f ELF` sequence at the start of ELF files, to find out the file type.
    This is perfect here because the *payload* file doesn’t have an extension. Here’s
    what `file` tells you about *payload*:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`file` 的优点在于它不会被文件扩展名所迷惑。相反，它会在文件中搜索其他特征模式，例如 ELF 文件开头的 `0x7f ELF` 魔法字节序列，从而判断文件类型。这在这里非常适用，因为
    *payload* 文件没有扩展名。以下是 `file` 告诉你关于 *payload* 的信息：'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, *payload* contains ASCII text. To examine the text in detail,
    you can use the `head` utility, which dumps the first few lines (10 by default)
    of a text file to `stdout`. There’s also an analogous utility called `tail`, which
    shows you the last few lines of a file. Here’s what the `head` utility’s output
    shows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，*payload* 包含 ASCII 文本。要详细检查文本，你可以使用 `head` 工具，它会将文本文件的前几行（默认 10 行）输出到
    `stdout`。还有一个类似的工具叫做 `tail`，它显示文件的最后几行。以下是 `head` 工具输出的内容：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That definitely doesn’t look human-readable. Taking a closer look at the alphabet
    used in the file, you can see that it consists of only alphanumeric characters
    and the characters + and /, organized in neat rows. When you see a file that looks
    like this, it’s usually safe to assume that it’s a *Base64* file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不像是人类可读的内容。仔细观察文件中使用的字母表，你会发现它只由字母数字字符和字符 + 与 / 组成，并且按整齐的行排列。当你看到这样的文件时，通常可以安全地假设它是一个*Base64*文件。
- en: Base64 is a widely used method of encoding binary data as ASCII text. Among
    other things, it’s commonly used in email and on the web to ensure that binary
    data transmitted over a network isn’t accidentally malformed by services that
    can handle only text. Conveniently, Linux systems come with a tool called `base64`
    (typically as part of GNU `coreutils`) that can encode and decode Base64\. By
    default, `base64` will encode any files or `stdin` input given to it. But you
    can use the `-d` flag to tell `base64` to decode instead. Let’s decode *payload*
    to see what you get!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Base64是一种广泛使用的将二进制数据编码为ASCII文本的方法。除其他外，它常用于电子邮件和网络上，以确保通过网络传输的二进制数据不会因只能处理文本的服务而被意外损坏。方便的是，Linux系统自带了一个名为`base64`的工具（通常是GNU
    `coreutils`的一部分），可以进行Base64编码和解码。默认情况下，`base64`会编码任何传递给它的文件或`stdin`输入。但你可以使用`-d`标志告诉`base64`进行解码。让我们解码*payload*看看会得到什么！
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command decodes *payload* and then stores the decoded contents in a new
    file called `decoded_payload`. Now that you’ve decoded *payload*, let’s use `file`
    again to check the type of the decoded file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令解码*payload*，然后将解码后的内容存储在一个名为`decoded_payload`的新文件中。现在你已经解码了*payload*，让我们再次使用`file`来检查解码后的文件类型。
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now you’re getting somewhere! It turns out that behind the layer of Base64
    encoding, the mysterious file is actually just a compressed archive that uses
    `gzip` as the outer compression layer. This is an opportunity to introduce another
    handy feature of `file`: the ability to peek inside zipped files. You can pass
    the `-z` option to `file` to see what’s inside the archive without extracting
    it. Here’s what you should see:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了进展！事实证明，在Base64编码层背后，神秘的文件实际上只是一个压缩归档文件，使用`gzip`作为外部压缩层。这是介绍`file`的另一个实用功能的好机会：能够窥视压缩文件内部。你可以通过为`file`传递`-z`选项，查看归档中的内容而无需解压。你应该会看到如下内容：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see that you’re dealing with multiple layers that you need to extract,
    because the outer layer is a `gzip` compression layer and inside that is a `tar`
    archive, which typically contains a bundle of files. To reveal the files stored
    inside, you use `tar` to unzip and extract `decoded_payload`, like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到你正在处理多个需要提取的层，因为最外层是一个`gzip`压缩层，而里面是一个`tar`归档文件，通常包含一组文件。为了查看存储在其中的文件，你可以使用`tar`解压并提取`decoded_payload`，像这样：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As shown in the `tar` log, there are two files extracted from the archive:
    *ctf* and *67b8601*. Let’s use `file` again to see what kinds of files you’re
    dealing with.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如`tar`日志所示，从归档中提取了两个文件：*ctf*和*67b8601*。让我们再次使用`file`，看看你正在处理哪些类型的文件。
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first file, *ctf*, is a dynamically linked 64-bit stripped ELF executable.
    The second file, called *67b8601*, is a bitmap (BMP) file of 512 × 512 pixels.
    Again, you can see this using `file` as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个文件，*ctf*，是一个动态链接的 64 位精简 ELF 可执行文件。第二个文件，名为*67b8601*，是一个 512 × 512 像素的位图（BMP）文件。你可以通过如下命令使用`file`看到这一点：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This BMP file depicts a black square, as you can see in [Figure 5-1a](ch05.xhtml#ch05fig1).
    If you look carefully, you should see some irregularly colored pixels at the bottom
    of the figure. [Figure 5-1b](ch05.xhtml#ch05fig1) shows an enlarged snippet of
    these pixels.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个BMP文件展示了一个黑色方块，正如你在[图5-1a](ch05.xhtml#ch05fig1)中看到的那样。如果你仔细观察，你应该能看到图底部有一些颜色不规则的像素。[图5-1b](ch05.xhtml#ch05fig1)显示了这些像素的放大片段。
- en: Before exploring what this all means, let’s first take a closer look at *ctf*,
    the ELF file you just extracted.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索这些含义之前，让我们先仔细看一下你刚刚提取的*ctf* ELF文件。
- en: '![image](Images/f092-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f092-01.jpg)'
- en: '*Figure 5-1: The extracted BMP file, 67b8601*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：提取的 BMP 文件，67b8601*'
- en: 5.2 Using ldd to Explore Dependencies
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2 使用 ldd 探索依赖关系
- en: Although it’s not wise to run unknown binaries, since you’re working in a VM,
    let’s try running the extracted *ctf* binary. When you try to run the file, you
    don’t get far.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管运行未知的二进制文件并不明智，但由于你在虚拟机中工作，我们还是尝试运行提取的*ctf*二进制文件。当你尝试运行该文件时，你并没有走得太远。
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before any of the application code is even executed, the dynamic linker complains
    about a missing library called *lib5ae9b7f.so*. That doesn’t sound like a library
    you normally find on any system. Before searching for this library, it makes sense
    to check whether *ctf* has any more unresolved dependencies.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序代码执行之前，动态链接器就抱怨缺少一个名为 *lib5ae9b7f.so* 的库。这听起来不像是你在任何系统上通常会找到的库。在搜索这个库之前，先检查一下
    *ctf* 是否还有其他未解决的依赖项是有意义的。
- en: 'Linux systems come with a program called `ldd`, which you can use to find out
    on which shared objects a binary depends and where (if anywhere) these dependencies
    are on your system. You can even use `ldd` along with the `-v` flag to find out
    which library versions the binary expects, which can be useful for debugging.
    As mentioned in the `ldd man` page, `ldd` may run the binary to figure out the
    dependencies, so it’s not safe to use on untrusted binaries unless you’re running
    it in a VM or another isolated environment. Here’s the `ldd` output for the *ctf*
    binary:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 系统带有一个名为 `ldd` 的程序，你可以用它来查找一个二进制文件依赖的共享对象，以及这些依赖项在你的系统上的位置（如果有的话）。你甚至可以使用
    `ldd` 配合 `-v` 参数来查看二进制文件期望的库版本，这在调试时非常有用。正如 `ldd man` 页面中提到的那样，`ldd` 可能会运行该二进制文件来确定其依赖项，因此在运行不信任的二进制文件时不安全，除非你在虚拟机或其他隔离环境中运行它。以下是
    *ctf* 二进制文件的 `ldd` 输出：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Luckily, there are no unresolved dependencies besides the missing library identified
    earlier, *lib5ae9b7f.so*. Now you can focus on figuring out what this mysterious
    library is and how you can obtain it in order to capture the flag!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，除了之前识别出的缺失库 *lib5ae9b7f.so* 之外，没有其他未解决的依赖项。现在你可以专注于弄清楚这个神秘的库是什么，以及如何获取它来捕获旗帜！
- en: Because it’s obvious from the library name that you won’t find it in any standard
    repository, it must reside somewhere in the files you’ve been given so far. Recall
    from [Chapter 2](ch02.xhtml#ch02) that all ELF binaries and libraries begin with
    the magic sequence `0x7f ELF`. This is a handy string to look for in search of
    your missing library; as long as the library is not encrypted, you should be able
    to find the ELF header this way. Let’s try a simple `grep` for the string `'ELF'`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因为从库名来看，很明显你不会在任何标准仓库中找到它，所以它一定存在于你目前为止得到的文件中。回想一下[第 2 章](ch02.xhtml#ch02)，所有
    ELF 二进制文件和库都以魔术序列 `0x7f ELF` 开头。这个字符串对于寻找丢失的库非常有用；只要库没有加密，你应该能够通过这种方式找到 ELF 头。我们来尝试一下简单的
    `grep` 查找字符串 `'ELF'`。
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As expected, the string `'ELF'` appears in *ctf*, which is not surprising because
    you already know it’s an ELF binary. But you can see that this string is also
    in *67b8601*, which at first glance appeared to be an innocent bitmap file. Could
    there be a shared library hidden within the bitmap’s pixel data? It would certainly
    explain those strangely colored pixels you saw in [Figure 5-1b](ch05.xhtml#ch05fig1)!
    Let’s examine the contents of *67b8601* in more detail to find out.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，字符串 `'ELF'` 出现在 *ctf* 中，这并不奇怪，因为你已经知道它是一个 ELF 二进制文件。但你可以看到这个字符串也出现在
    *67b8601* 中，乍一看，这似乎是一个无害的位图文件。难道位图的像素数据中隐藏了一个共享库？这倒可以解释你在[图 5-1b](ch05.xhtml#ch05fig1)中看到的那些奇怪颜色的像素！让我们更详细地检查
    *67b8601* 的内容，看看能否找到答案。
- en: Quickly Looking Up ASCII Codes
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查找 ASCII 代码
- en: 'When interpreting raw bytes as ASCII, you’ll often need a table that maps byte
    values in various representations to ASCII symbols. You can use a special man
    page called `man ascii` for quick access to such a table. Here’s an excerpt of
    the table from `man ascii`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在将原始字节解释为 ASCII 时，你通常需要一个表格，将不同表示形式的字节值映射到 ASCII 符号。你可以使用一个名为 `man ascii` 的特殊手册页来快速访问此类表格。以下是从
    `man ascii` 提取的表格片段：
- en: '| `Oct` | `Dec` | `Hex` | `Char` | `Oct` | `Dec` | `Hex` | `Char` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `Oct` | `Dec` | `Hex` | `字符` | `Oct` | `Dec` | `Hex` | `字符` |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| `000` | `0` | `00` | `NUL ''\0'' (null character)` | `100` | `64` | `40`
    | `@` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `000` | `0` | `00` | `NUL ''\0'' (空字符)` | `100` | `64` | `40` | `@` |'
- en: '| `001` | `1` | `01` | `SOH (start of heading)` | `101` | `65` | `41` | `A`
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `001` | `1` | `01` | `SOH (标题开始)` | `101` | `65` | `41` | `A` |'
- en: '| `002` | `2` | `02` | `STX (start of text)` | `102` | `66` | `42` | `B` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `002` | `2` | `02` | `STX (文本开始)` | `102` | `66` | `42` | `B` |'
- en: '| `003` | `3` | `03` | `ETX (end of text)` | `103` | `67` | `43` | `C` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `003` | `3` | `03` | `ETX (文本结束)` | `103` | `67` | `43` | `C` |'
- en: '| `004` | `4` | `04` | `EOT (end of transmission)` | `104` | `68` | `44` |
    `D` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `004` | `4` | `04` | `EOT (传输结束)` | `104` | `68` | `44` | `D` |'
- en: '| `005` | `5` | `05` | `ENQ (enquiry)` | `105` | `69` | `45` | `E` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `005` | `5` | `05` | `ENQ (查询)` | `105` | `69` | `45` | `E` |'
- en: '| `006` | `6` | `06` | `ACK (acknowledge)` | `106` | `70` | `46` | `F` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `006` | `6` | `06` | `ACK (acknowledge)` | `106` | `70` | `46` | `F` |'
- en: '| `007` | `7` | `07` | `BEL ''\a'' (bell)` | `107` | `71` | `47` | `G` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `007` | `7` | `07` | `BEL ''\a'' (bell)` | `107` | `71` | `47` | `G` |'
- en: '| `...` |  |  |  |  |  |  |  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `...` |  |  |  |  |  |  |  |'
- en: As you can see, this is an easy way to look up the mappings from octal, decimal,
    and hexadecimal encodings to ASCII characters. This is much faster than googling
    for an ASCII table!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一种快速查找从八进制、十进制和十六进制编码到 ASCII 字符映射的方法。比起在 Google 上查找 ASCII 表，这要快得多！
- en: 5.3 Viewing File Contents with xxd
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3 使用 xxd 查看文件内容
- en: To discover exactly what’s in a file without being able to rely on any standard
    assumptions about the file contents, you’ll have to analyze it at the byte level.
    To do this, you can use any numeric system to display bits and bytes on the screen.
    For instance, you could use the binary system, displaying all the ones and zeros
    individually. But because that makes for some tedious analysis, it’s better to
    use the *hexadecimal system*. In the hexadecimal system (also known as *base 16*,
    or *hex* for short), digits range from 0 to 9 (with the usual meaning) and then
    from *a* to *f* (where *a* represents the value 10 and *f* represents 15). In
    addition, because a byte has 256 = 16 × 16 possible values, it fits exactly in
    two hexadecimal digits, making this a convenient encoding for compactly displaying
    bytes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要发现文件中究竟包含什么内容，而又不能依赖于关于文件内容的任何标准假设，你必须在字节级别进行分析。为此，你可以使用任何数字系统来显示屏幕上的位和字节。例如，你可以使用二进制系统，逐个显示所有的
    1 和 0。但由于这种方法分析起来非常繁琐，最好使用*十六进制系统*。在十六进制系统中（也称为*基数 16*，简称*hex*），数字从 0 到 9（含普通意义）开始，接着是
    *a* 到 *f*（其中 *a* 表示值 10，*f* 表示值 15）。此外，由于一个字节有 256 = 16 × 16 种可能的值，它正好可以用两位十六进制数字表示，这使得它成为一个方便的编码方式，用于紧凑地显示字节。
- en: To display the bytes of a file in hexadecimal representation, you use a *hex-dumping*
    program. A *hex editor* is a program that can also edit the bytes in the file.
    I’ll get back to hex editing in [Chapter 7](ch07.xhtml#ch07), but for now let’s
    use a simple hex-dumping program called `xxd`, which is installed on most Linux
    systems by default.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要以十六进制表示文件的字节，你可以使用*十六进制转储*程序。*十六进制编辑器*是一个也可以编辑文件字节的程序。我将在[第 7 章](ch07.xhtml#ch07)中详细讲解十六进制编辑，但现在我们先使用一个简单的十六进制转储程序叫做`xxd`，它默认安装在大多数
    Linux 系统中。
- en: 'Here are the first 15 lines of output from `xxd` for the bitmap file you’re
    analyzing:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你正在分析的位图文件通过`xxd`命令输出的前 15 行内容：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the first output column shows the offset into the file in hexadecimal
    format. The next eight columns show hexadecimal representations of the bytes in
    the file, and on the rightmost side of the output, you can see an ASCII representation
    of the same bytes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第一列输出显示了文件的偏移量，以十六进制格式表示。接下来的八列显示文件中字节的十六进制表示，在输出的最右侧，你可以看到相同字节的 ASCII
    表示。
- en: You can change the number of bytes displayed per line using the `xxd` program’s
    `-c` option. For instance, `xxd -c 32` will display 32 bytes per line. You can
    also use `-b` to display binary instead of hexadecimal, and you can use `-i` to
    output a C-style array containing the bytes, which you can directly include in
    your C or C++ source. To output only some of the bytes, you can use the `-s` (seek)
    option to specify a file offset at which to start, and you can use the `-l` (length)
    option to specify the number of bytes to dump.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `xxd` 程序的 `-c` 选项来更改每行显示的字节数。例如，`xxd -c 32` 会每行显示 32 个字节。你还可以使用 `-b` 选项显示二进制而不是十六进制，并且可以使用
    `-i` 选项输出一个包含字节的 C 风格数组，你可以直接将其包含在 C 或 C++ 源代码中。要仅输出文件中的部分字节，你可以使用 `-s`（寻址）选项指定开始的位置，并可以使用
    `-l`（长度）选项指定要转储的字节数。
- en: In the `xxd` output for the bitmap file, the ELF magic bytes appear at offset
    `0x34` ➊, which corresponds to 52 in the decimal system. This tells you where
    in the file the suspected ELF library begins. Unfortunately, finding out where
    it ends is not so trivial because there are no magic bytes delimiting the end
    of an ELF file. Thus, before you try to extract the complete ELF file, begin by
    extracting only the ELF header instead. This is easier since you know that 64-bit
    ELF headers contain exactly 64 bytes. You can then examine the ELF header to figure
    out how large the complete file is.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在位图文件的 `xxd` 输出中，ELF 魔术字节出现在偏移 `0x34` ➊ 处，对应十进制的 52。这告诉你文件中可能的 ELF 库开始的位置。不幸的是，确定它结束的位置并不那么简单，因为
    ELF 文件的末尾没有魔术字节作为分界。因此，在尝试提取完整的 ELF 文件之前，先提取 ELF 头部会更容易，因为你知道 64 位 ELF 头部正好包含
    64 个字节。然后，你可以检查 ELF 头部，以确定完整文件的大小。
- en: To extract the header, you use `dd` to copy 64 bytes from the bitmap file, starting
    at offset 52, into a new output file called *elf_header*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取头部，你可以使用 `dd` 从位图文件的偏移 52 处开始，复制 64 字节到一个名为 *elf_header* 的新输出文件中。
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using `dd` is incidental here, so I won’t explain it in detail. However, `dd`
    is an extremely versatile^([1](footnote.xhtml#ch05fn_1)) tool, so it’s worth reading
    its man page if you aren’t already familiar with it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dd` 在这里只是偶然的，因此我不会详细解释。不过，`dd` 是一个非常多功能的^([1](footnote.xhtml#ch05fn_1))
    工具，如果你不熟悉它，值得阅读它的手册页。
- en: Let’s use `xxd` again to see whether it worked.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用 `xxd` 来查看它是否有效。
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That looks like an ELF header! You can clearly see the magic bytes at the start
    ➊, and you can also see that the `e_ident` array and other fields look reasonable
    (refer to [Chapter 2](ch02.xhtml#ch02) for a description of these fields).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像是 ELF 头部！你可以清楚地看到起始处的魔术字节 ➊，并且还可以看到 `e_ident` 数组和其他字段看起来合理（有关这些字段的描述，请参考[第2章](ch02.xhtml#ch02)）。
- en: 5.4 Parsing the Extracted ELF with readelf
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4 使用 readelf 解析提取的 ELF
- en: To view the details of the ELF header you just extracted, it would be great
    if you could use `readelf`, like you did in [Chapter 2](ch02.xhtml#ch02). But
    will `readelf` work on a broken ELF file that contains nothing but a header? Let’s
    find out in [Listing 5-1](ch05.xhtml#ch05list1)!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你刚提取的 ELF 头部的详细信息，最好使用 `readelf`，就像你在[第2章](ch02.xhtml#ch02)中做的那样。但如果 ELF
    文件损坏，仅包含一个头部，`readelf` 还能工作吗？让我们在[清单 5-1](ch05.xhtml#ch05list1)中找出答案！
- en: '*Listing 5-1: The* readelf *output for the extracted ELF header*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-1：提取的 ELF 头部的* readelf *输出*'
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-h` option ➊ tells `readelf` to print only the executable header. It still
    complains that the offsets to the section header table and program header table
    point outside the file, but that’s okay. What matters is that you now have a convenient
    representation of the extracted ELF header.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`-h` 选项 ➊ 告诉 `readelf` 仅打印可执行头部。它仍然抱怨节区头表和程序头表的偏移量指向文件之外，但这没关系。关键是，你现在可以方便地查看提取的
    ELF 头部。'
- en: 'Now, how can you figure out the size of the complete ELF using nothing but
    the executable header? In [Figure 2-1](ch02.xhtml#ch02fig1) of [Chapter 2](ch02.xhtml#ch02),
    you learned that the last part of an ELF file is typically the section header
    table and that the offset to the section header table is given in the executable
    header ➋. The executable header also tells you the size of each section header
    ➌ and the number of section headers in the table ➍. This means you can calculate
    the size of the complete ELF library hidden in your bitmap file as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何仅凭可执行头部来计算完整 ELF 的大小呢？在[第2章](ch02.xhtml#ch02)的[图 2-1](ch02.xhtml#ch02fig1)中，你已经学到
    ELF 文件的最后部分通常是节区头表，而节区头表的偏移量是在可执行头部中给出的 ➋。可执行头部还告诉你每个节区头的大小 ➌ 和节区头表中的节区头数量 ➍。这意味着你可以通过以下方式计算出隐藏在位图文件中的完整
    ELF 库的大小：
- en: '![image](Images/f096-01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f096-01.jpg)'
- en: In this equation, *size* is the size of the complete library, *e*_*shoff* is
    the offset to the section header table, *e*_*shnum* is the number of section headers
    in the table, and *e*_*shentsize* is the size of each section header.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程式中，*size* 是完整库的大小，*e*_*shoff* 是节区头表的偏移量，*e*_*shnum* 是节区头表中的节区头数量，*e*_*shentsize*
    是每个节区头的大小。
- en: 'Now that you know that the size of the library should be 10,296 bytes, you
    can use `dd` to extract it completely, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道库的大小应该是 10,296 字节，你可以使用 `dd` 完整提取它，方法如下：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `dd` command calls the extracted file *lib5ae9b7f.so* ➊ because that’s the
    name of the missing library the *ctf* binary expects. After running this command,
    you should now have a fully functioning ELF shared object. Let’s use `readelf`
    to see whether all went well, as shown in [Listing 5-2](ch05.xhtml#ch05list2).
    To keep the output brief, let’s only print the executable header (`-h`) and symbol
    tables (`-s`). The latter should give you an idea of the functionality that the
    library provides.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd`命令调用提取的文件*lib5ae9b7f.so* ➊，因为这是*ctf*二进制文件期望的缺失库的名称。运行此命令后，你现在应该拥有一个完全功能的ELF共享对象。让我们使用`readelf`来查看是否一切顺利，如[清单
    5-2](ch05.xhtml#ch05list2)所示。为了简洁起见，我们只打印可执行文件头（`-h`）和符号表（`-s`）。后者应能帮助你了解库所提供的功能。'
- en: '*Listing 5-2: The* readelf *output for the extracted library,* lib5ae9b7f.so'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-2：提取的库的*readelf*输出，*lib5ae9b7f.so*'
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As hoped, the complete library seems to have been extracted correctly. Although
    it’s stripped, the dynamic symbol table does reveal some interesting exported
    functions (➊ through ➎). However, there seems to be some gibberish around the
    names, making them difficult to read. Let’s see if that can be fixed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如期望的那样，完整的库似乎已经被正确提取。尽管它被剥离了，但动态符号表确实显示了一些有趣的导出函数（➊到➎）。然而，函数名周围似乎有一些乱码，导致它们难以阅读。让我们看看是否可以解决这个问题。
- en: 5.5 Parsing Symbols with nm
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5 使用nm解析符号
- en: C++ allows functions to be *overloaded*, which means there may be multiple functions
    with the same name, as long as they have different signatures. Unfortunately for
    the linker, it doesn’t know anything about C++. For example, if there are multiple
    functions with the name `foo`, the linker has no idea how to resolve references
    to `foo`; it simply doesn’t know which version of `foo` to use. To eliminate duplicate
    names, C++ compilers emit *mangled* function names. A mangled name is essentially
    a combination of the original function name and an encoding of the function parameters.
    This way, each version of the function gets a unique name, and the linker has
    no problems disambiguating the overloaded functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许函数*重载*，这意味着可能有多个同名函数，只要它们具有不同的签名。对于链接器来说，这却是个问题，因为它对C++一无所知。例如，如果有多个名为`foo`的函数，链接器不知道如何解决对`foo`的引用；它根本不知道使用哪个版本的`foo`。为了消除重复的名称，C++编译器会生成*破坏*的函数名。破坏的函数名本质上是原始函数名和函数参数的编码组合。这样，每个版本的函数都会有一个唯一的名称，链接器就能够轻松区分重载的函数。
- en: For binary analysts, mangled function names are a mixed blessing. On the one
    hand, mangled names are more difficult to read, as you saw in the `readelf` output
    for *lib5ae9b7f.so* ([Listing 5-2](ch05.xhtml#ch05list2)), which is programmed
    in C++. On the other hand, mangled function names essentially provide free type
    information by revealing the expected parameters of the function, and this information
    can be useful when reverse engineering a binary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二进制分析师来说，名称被“破坏”（mangled）的函数名是一种复杂的祝福。一方面，破坏后的函数名更难以阅读，正如你在`readelf`输出中看到的*lib5ae9b7f.so*（见[清单
    5-2](ch05.xhtml#ch05list2)）所示，它是用C++编写的。另一方面，破坏后的函数名实际上通过揭示函数的预期参数提供了免费的类型信息，这在逆向工程二进制文件时非常有用。
- en: Fortunately, the benefits of mangled names outweigh the downsides because mangled
    names are relatively easy to *demangle*. There are several standard tools you
    can use to demangle mangled names. One of the best known is `nm`, which lists
    symbols in a given binary, object file, or shared object. When given a binary,
    `nm` by default attempts to parse the static symbol table.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，破坏后的函数名带来的好处大于缺点，因为它们相对容易被*还原*。有几个标准工具可以用来还原破坏的函数名。其中最著名的工具之一是`nm`，它可以列出给定二进制文件、目标文件或共享对象的符号。当给定一个二进制文件时，`nm`默认尝试解析静态符号表。
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unfortunately, as this example shows, you can’t use `nm`’s default configuration
    on *lib5ae9b7f.so* because it has been stripped. You have to explicitly ask `nm`
    to parse the dynamic symbol table instead, using the `-D` switch, as shown in
    [Listing 5-3](ch05.xhtml#ch05list3). In this listing, “`...`” indicates that I’ve
    truncated a line and continued it on the next line (mangled names can be quite
    long).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，正如这个例子所示，你不能在*lib5ae9b7f.so*上使用`nm`的默认配置，因为它已经被剥离。你必须显式地要求`nm`解析动态符号表，使用`-D`开关，如[清单
    5-3](ch05.xhtml#ch05list3)所示。在这个清单中，"`...`"表示我已经截断了一行并将其继续到下一行（破坏的函数名可能非常长）。
- en: '*Listing 5-3: The* nm *output for* lib5ae9b7f.so'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：*nm*输出，*lib5ae9b7f.so*'
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This looks better; this time you see some symbols. But the symbol names are
    still mangled. To demangle them, you have to pass the `--demangle` switch to `nm`,
    as shown in [Listing 5-4](ch05.xhtml#ch05list4).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这样看起来好多了，这次你看到了一些符号。但符号名称仍然是混淆的。要去混淆它们，你需要将 `--demangle` 选项传递给 `nm`，如 [清单 5-4](ch05.xhtml#ch05list4)
    所示。
- en: '*Listing 5-4: Demangled* nm *output for* lib5ae9b7f.so'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-4：* lib5ae9b7f.so 的 *nm* 输出（已去除混淆）'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, the function names appear human-readable. You can see five interesting
    functions, which appear to be cryptographic functions implementing the well-known
    RC4 encryption algorithm.^([2](footnote.xhtml#ch05fn_2)) There’s a function called
    `rc4_init`, which takes as input a data structure of type `rc4_state_t`, as well
    as an unsigned character string and an integer ➎. The first parameter is presumably
    a data structure where the cryptographic state is kept, while the next two are
    probably a string representing a key and an integer specifying the length of the
    key, respectively. You can also see several encryption and decryption functions,
    each of which takes a pointer to the cryptographic state, as well as parameters
    specifying strings (both C and C++ strings) to encrypt or decrypt (➊ through ➍).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，函数名称变得易于阅读。你可以看到五个有趣的函数，它们似乎是实现了著名的 RC4 加密算法的加密函数。^([2](footnote.xhtml#ch05fn_2))
    有一个名为 `rc4_init` 的函数，它接受一个类型为 `rc4_state_t` 的数据结构作为输入，以及一个无符号字符字符串和一个整数 ➎。第一个参数可能是一个存储加密状态的数据结构，而接下来的两个参数分别可能是表示密钥的字符串和指定密钥长度的整数。你还可以看到几个加密和解密函数，每个函数都接受指向加密状态的指针，并且有参数指定要加密或解密的字符串（包括
    C 和 C++ 字符串）（➊ 到 ➍）。
- en: 'As an alternative way of demangling function names, you can use a specialized
    utility called `c++filt`, which takes a mangled name as the input and outputs
    the demangled equivalent. The advantage of `c++filt` is that it supports several
    mangling formats and automatically detects the correct mangling format for the
    given input. Here’s an example using `c++filt` to demangle the function name `_Z8rc4_initP11rc4_state_tPhi`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为去混淆函数名称的另一种方法，你可以使用名为 `c++filt` 的专用工具，它接受混淆过的名称作为输入并输出去混淆后的等效名称。`c++filt`
    的优势在于它支持多种混淆格式，并自动检测给定输入的正确混淆格式。以下是使用 `c++filt` 去混淆函数名称 `_Z8rc4_initP11rc4_state_tPhi`
    的示例：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At this point, let’s briefly recap the progress so far. You extracted the mysterious
    payload and found a binary called *ctf* that depends on a file called *lib5ae9b7f.so*.
    You found *lib5ae9b7f.so* hidden in a bitmap file and successfully extracted it.
    You also have a rough idea of what it does: it’s a cryptographic library. Now
    let’s try running *ctf* again, this time with no missing dependencies.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要回顾一下迄今为止的进展。你提取了神秘的有效负载，并找到了一个名为 *ctf* 的二进制文件，它依赖于一个名为 *lib5ae9b7f.so*
    的文件。你找到了隐藏在位图文件中的 *lib5ae9b7f.so* 并成功提取出来。你也大致了解了它的功能：它是一个加密库。现在，让我们再次尝试运行 *ctf*，这次不再缺少任何依赖项。
- en: When you run a binary, the linker resolves the binary’s dependencies by searching
    a number of standard directories for shared libraries, such as */lib*. Because
    you extracted *lib5ae9b7f.so* to a nonstandard directory, you need to tell the
    linker to search that directory too by setting an environment variable called
    `LD_LIBRARY_PATH`. Let’s set this variable to contain the current working directory
    and then try launching *ctf* again.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行一个二进制文件时，链接器通过搜索多个标准目录中的共享库来解析二进制文件的依赖项，例如 */lib*。由于你将 *lib5ae9b7f.so* 提取到了一个非标准目录，你需要告诉链接器也去该目录搜索，通过设置一个名为
    `LD_LIBRARY_PATH` 的环境变量。让我们将该变量设置为当前工作目录，然后再次尝试启动 *ctf*。
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Success! The *ctf* binary still doesn’t appear to do anything useful, but it
    runs without complaining about any missing libraries. The exit status of *ctf*
    contained in the `$?` variable is 1, indicating an error. Now that you have all
    the required dependencies, you can continue your investigation and see whether
    you can coax *ctf* into getting past the error so that you can reach the flag
    you’re trying to capture.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！*ctf* 二进制文件看起来仍然没有做任何有用的事情，但它能够运行，并且没有抱怨缺少任何库文件。*ctf* 的退出状态（保存在 `$?` 变量中）是
    1，表示发生了错误。现在你已经拥有了所有必需的依赖项，可以继续调查并看看你是否能够让 *ctf* 克服错误，从而达到你要捕捉的标志。
- en: 5.6 Looking for Hints with strings
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6 使用 strings 寻找线索
- en: To figure out what a binary does and what kinds of inputs it expects, you can
    check whether the binary contains any helpful strings that can reveal its purpose.
    For instance, if you see strings containing parts of HTTP requests or URLs, you
    can safely guess that the binary is doing something web related. When you’re dealing
    with malware such as a bot, you might be able to find strings containing the commands
    that the bot accepts, if they’re not obfuscated. You might even find strings left
    over from debugging that the programmer forgot to remove, which has been known
    to happen in real-world malware!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弄清楚一个二进制文件的功能以及它期望的输入类型，你可以检查该二进制文件是否包含任何有助于揭示其目的的字符串。例如，如果你看到包含HTTP请求或URL的字符串，你可以安全地猜测该二进制文件正在执行与Web相关的操作。当你处理恶意软件（如bot）时，如果这些字符串没有被混淆，你可能会找到包含bot接受的命令的字符串。你甚至可能会发现一些调试时留下的字符串，程序员忘记删除这些字符串，这种情况在实际的恶意软件中也曾发生过！
- en: You can use a utility called `strings` to check for strings in a binary (or
    any other file) on Linux. The `strings` utility takes one or more files as input
    and then prints any printable character strings found in those files. Note that
    `strings` doesn’t check whether the found strings were really intended to be human
    readable, so when used on binary files, the `strings` output may include some
    bogus strings as a result of binary sequences that just happen to be printable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个名为`strings`的工具来检查Linux上二进制文件（或其他任何文件）中的字符串。`strings`工具接受一个或多个文件作为输入，然后打印出这些文件中找到的所有可打印字符字符串。请注意，`strings`并不会检查所找到的字符串是否真的被设计为可读的，所以当它用于二进制文件时，`strings`的输出可能会包含一些虚假的字符串，这些字符串可能是二进制序列偶然变得可打印的结果。
- en: You can tweak the behavior of `strings` using options. For example, you can
    use the `-d` switch with `strings` to print only strings found in data sections
    in a binary instead of printing all sections. By default, `strings` prints only
    strings of four characters or more, but you can specify another minimum string
    length using the `-n` option. For our purposes, the default options will suffice;
    let’s see what you can find in the *ctf* binary using `strings`, as shown in [Listing
    5-5](ch05.xhtml#ch05list5).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用选项来调整`strings`的行为。例如，你可以使用`-d`选项与`strings`一起使用，以仅打印出在二进制文件的数据部分中找到的字符串，而不是打印所有部分。默认情况下，`strings`只打印四个字符或更多的字符串，但你可以使用`-n`选项指定其他最小字符串长度。就我们的目的而言，默认选项就足够了；让我们看看你能在*ctf*二进制文件中使用`strings`找到什么，如[列表
    5-5](ch05.xhtml#ch05list5)所示。
- en: '*Listing 5-5: Character strings found in the* ctf *binary*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：在* ctf *二进制文件中找到的字符字符串*'
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, you can see some strings that you’ll encounter in most ELF files. For
    example, there’s the name of the program interpreter ➊, as found in the `.interp`
    section, and some symbolic names found in `.dynstr` ➋. At the end of the `strings`
    output, you can see all the section names as found in the `.shstrtab` section
    ➐. But none of these strings is very interesting for the purposes here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到一些在大多数ELF文件中都会遇到的字符串。例如，程序解释器的名称➊，可以在`.interp`部分找到，以及一些在`.dynstr`部分找到的符号名称➋。在`strings`的输出末尾，你可以看到所有在`.shstrtab`部分找到的节名称➐。但这些字符串在此并没有什么特别有趣的地方。
- en: Fortunately, there are also some more useful strings. For example, there is
    what appears to be a debug message, which suggests that the program expects a
    command line option ➌. There are also checks of some sort, presumably performed
    on an input string ➍. You don’t yet know what the value of the command line option
    should be, but you could try some of the other interesting-looking strings, such
    as `show_me_the_flag` ➎, that might work. There’s also a mysterious string ➏ that
    contains a message whose purpose is unclear. You don’t know what the message means
    at this point, but you do know from your investigation of *lib5ae9b7f.so* that
    the binary uses RC4 encryption. Perhaps the message is used as an encryption key?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，还有一些更有用的字符串。例如，似乎有一条调试信息，暗示程序期望一个命令行选项➌。还有一些检查，可能是针对输入字符串执行的检查➍。你现在还不知道命令行选项的值应该是什么，但你可以尝试一些其他看起来有趣的字符串，例如`show_me_the_flag`➎，它可能有效。还有一个神秘的字符串➏，它包含一条含义不明的消息。你现在不知道这条消息的意思，但你从对*lib5ae9b7f.so*的调查中知道，二进制文件使用了RC4加密。也许这条消息是用作加密密钥？
- en: 'Now that you know that the binary expects a command line option, let’s see
    whether adding an arbitrary option gets you any closer to revealing the flag.
    For lack of a better guess, let’s simply use the string `foobar`, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了二进制文件期望一个命令行选项，让我们看看添加一个任意选项是否能让你更接近揭示旗标。为了没有更好的猜测，我们就简单地使用字符串`foobar`，如下所示：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The binary now does something new. It tells you that it’s checking the input
    string you gave it. But the check doesn’t succeed because the binary still exits
    with an error code after the check. Let’s take a gamble and try one of the other
    interesting-looking strings that you found, such as the string `show_me_the_flag`,
    which looks promising.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该二进制文件现在做了一些新事情。它告诉你它正在检查你给定的输入字符串。但检查并没有成功，因为检查后，二进制文件仍然以错误代码退出。我们来冒险尝试一下你找到的其他一些看起来有趣的字符串，比如
    `show_me_the_flag`，它看起来很有潜力。
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That did it! The check now appears to succeed. Unfortunately, the exit status
    is still 1, so there must be something else missing. To make things worse, the
    `strings` results don’t provide any more hints. Let’s take a more detailed look
    at *ctf* ’s behavior to determine what to do next, starting with the system and
    library calls *ctf* makes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！检查现在似乎已经成功。不幸的是，退出状态仍然是 1，所以肯定还有其他东西缺失。更糟糕的是，`strings` 的结果没有提供更多的线索。我们来更详细地查看
    *ctf* 的行为，确定接下来该做什么，从 *ctf* 发出的系统和库调用开始。
- en: 5.7 Tracing System Calls and Library Calls with strace and ltrace
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7 使用 strace 和 ltrace 跟踪系统调用和库调用
- en: To make forward progress, let’s investigate the reason that *ctf* exits with
    an error code by looking at *ctf* ’s behavior just before it exits. There are
    many ways that you could do this, but one way is to use two tools called `strace`
    and `ltrace`. These tools show the system calls and library calls, respectively,
    executed by a binary. Knowing the system and library calls that a binary makes
    can often give you a good high-level idea of what the program is doing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了取得进展，我们来调查一下 *ctf* 为什么会退出并返回错误代码，看看 *ctf* 在退出前的行为。你可以通过很多方式来做这件事，其中一种方法是使用两个工具，分别是
    `strace` 和 `ltrace`。这些工具分别显示了二进制文件执行的系统调用和库调用。知道一个二进制文件所做的系统和库调用通常可以给你一个关于程序在做什么的高层次理解。
- en: Let’s start by using `strace` to investigate *ctf* ’s system call behavior.
    In some cases, you may want to attach `strace` to a running process. To do this,
    you need to use the `-p` *pid* option, where *pid* is the process ID of the process
    you want to attach to. However, in this case, it suffices to run *ctf* with `strace`
    from the start. [Listing 5-6](ch05.xhtml#ch05list6) shows the `strace` output
    for the *ctf* binary (some parts are truncated with “`...`”).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用 `strace` 来调查 *ctf* 的系统调用行为。在某些情况下，你可能希望将 `strace` 附加到一个正在运行的进程。为此，你需要使用
    `-p` *pid* 选项，其中 *pid* 是你想附加的进程的进程 ID。然而，在这种情况下，从一开始就用 `strace` 运行 *ctf* 就足够了。[列
    5-6](ch05.xhtml#ch05list6) 显示了 *ctf* 二进制文件的 `strace` 输出（有些部分被“`...`”截断）。
- en: '*Listing 5-6: System calls executed by the* ctf *binary*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*列 5-6：* ctf *二进制文件执行的系统调用*'
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When tracing a program from the start, `strace` includes all the system calls
    used by the program interpreter to set up the process, making the output quite
    verbose. The first system call in the output is `execve`, which is called by your
    shell to launch the program ➊. After that, the program interpreter takes over
    and starts setting up the execution environment. This involves setting up memory
    regions and setting the correct memory access permissions using `mprotect`. Additionally,
    you can see the system calls used to look up and load the required dynamic libraries.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当从程序开始追踪时，`strace` 包含了程序解释器用来设置进程的所有系统调用，这使得输出非常冗长。输出中的第一个系统调用是 `execve`，它是由你的
    shell 调用来启动程序 ➊。之后，程序解释器接管并开始设置执行环境。这涉及到设置内存区域并使用 `mprotect` 设置正确的内存访问权限。此外，你还可以看到用于查找和加载所需动态库的系统调用。
- en: Recall that in [Section 5.5](ch05.xhtml#ch05_5), you set the `LD_LIBRARY_PATH`
    environment variable to tell the dynamic linker to add your current working directory
    to its search path. This is why you can see the dynamic linker searching for the
    *lib5ae9b7f.so* library in a number of standard subfolders in your current working
    directory, until it finally finds the library in the root of your working directory
    ➋. When the library is found, the dynamic linker reads it and maps it into memory
    ➌. The setup process is repeated for other required libraries, such as *libstdc++.so.6*
    ➍, and it accounts for the vast majority of the `strace` output.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在[第 5.5 节](ch05.xhtml#ch05_5)中，你设置了 `LD_LIBRARY_PATH` 环境变量，以告诉动态链接器将当前工作目录添加到其搜索路径中。这就是为什么你可以看到动态链接器在当前工作目录中的多个标准子文件夹中搜索
    *lib5ae9b7f.so* 库，直到它最终在工作目录的根目录中找到该库 ➋。当找到库时，动态链接器读取它并将其映射到内存中 ➌。对于其他所需的库，如 *libstdc++.so.6*
    ➍，会重复此设置过程，这也占据了 `strace` 输出的绝大多数内容。
- en: It isn’t until the last three system calls that you finally see application-specific
    behavior. The first system call used by *ctf* itself is `write`, which is used
    to print `checking 'show_me_the_flag'` to the screen ➎. You see another `write`
    call to print the string `ok` ➏, and finally, there’s a call to `exit_group`,
    which leads to the exit with status code 1 ➐.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最后三个系统调用，你才看到特定应用程序的行为。*ctf* 使用的第一个系统调用是 `write`，它用于打印 `checking 'show_me_the_flag'`
    到屏幕 ➎。接着，你看到另一个 `write` 调用，打印字符串 `ok` ➏，最后是调用 `exit_group`，导致程序以状态码 1 退出 ➐。
- en: That’s all interesting, but how does it help you figure out how to extract the
    flag from *ctf* ? The answer is that it doesn’t! In this case, `strace` didn’t
    reveal anything helpful, but I still wanted to show you how it works because it
    can be useful for understanding a program’s behavior. For instance, observing
    the system calls executed by a program is useful not only for binary analysis
    but also for debugging.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都很有趣，但它们怎么帮助你找出如何从 *ctf* 中提取标志呢？答案是：它们没有帮助！在这个案例中，`strace` 并没有揭示任何有用的信息，但我仍然想给你展示它是如何工作的，因为它可以帮助理解程序的行为。例如，观察程序执行的系统调用，不仅对二进制分析有帮助，也对调试有用。
- en: Looking at *ctf* ’s system call behavior didn’t help much, so let’s try library
    calls. To view the library calls executed by *ctf*, you use `ltrace`. Because
    `ltrace` is a close relative of `strace`, it takes many of the same command line
    options, including `-p` to attach to an existing process. Here, let’s use the
    `-i` option to print the instruction pointer at every library call (this will
    be useful later). We’ll use `-C` to automatically demangle C++ function names.
    Let’s run *ctf* with `ltrace` from the start, as shown in [Listing 5-7](ch05.xhtml#ch05list7).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 *ctf* 的系统调用行为没有太大帮助，因此我们来尝试一下库调用。要查看 *ctf* 执行的库调用，可以使用 `ltrace`。因为 `ltrace`
    与 `strace` 很相似，所以它支持许多相同的命令行选项，包括 `-p` 用于附加到现有进程。这里，我们使用 `-i` 选项，在每个库调用时打印指令指针（稍后会用到）。我们还将使用
    `-C` 自动解混淆 C++ 函数名。让我们从头开始运行 *ctf*，并使用 `ltrace`，如 [Listing 5-7](ch05.xhtml#ch05list7)
    所示。
- en: '*Listing 5-7: Library calls made by the* ctf *binary*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-7：* ctf *二进制文件的库调用*'
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, this output from `ltrace` is a lot more readable than the `strace`
    output because it isn’t polluted by all the process setup code. The first library
    call is `__libc_start_main` ➊, which is called from the `_start` function to transfer
    control to the program’s `main` function. Once `main` is started, its first library
    call prints the now familiar `checking ...` string to the screen ➋. The actual
    check turns out to be a string comparison, which is implemented using `strcmp`,
    and verifies that the argument given to *ctf* is equal to `show_me_the_flag` ➌.
    If this is the case, `ok` is printed to the screen ➍.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`ltrace` 的输出比 `strace` 更加易读，因为它没有被所有的进程设置代码污染。第一个库调用是 `__libc_start_main`
    ➊，它从 `_start` 函数中调用，用于将控制权转移到程序的 `main` 函数。一旦 `main` 开始执行，它的第一个库调用打印出现在熟悉的 `checking
    ...` 字符串到屏幕 ➋。实际的检查是一个字符串比较，使用 `strcmp` 实现，验证传给 *ctf* 的参数是否等于 `show_me_the_flag`
    ➌。如果是这样，`ok` 会被打印到屏幕上 ➍。
- en: 'So far, this is mostly behavior you’ve seen before. But now you see something
    new: the RC4 cryptography is initialized through a call to `rc4_init`, which is
    located in the library you extracted earlier ➎. After that, you see an `assign`
    to a C++ string, presumably initializing it with an encrypted message ➏. This
    message is then decrypted with a call to `rc4_decrypt` ➐, and the decrypted message
    is assigned to a new C++ string ➑.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这些大多是你之前见过的行为。但现在你看到了一些新内容：RC4 加密算法通过调用 `rc4_init` 初始化，该函数位于你之前提取的库中 ➎。之后，你看到一个
    `assign` 操作给一个 C++ 字符串赋值，假设它用加密消息进行了初始化 ➏。然后，使用 `rc4_decrypt` 调用解密该消息 ➐，并将解密后的消息赋值给一个新的
    C++ 字符串 ➑。
- en: 'Finally, there’s a call to `getenv`, which is a standard library function used
    to look up environment variables ➒. You can see that *ctf* expects an environment
    variable called `GUESSME`! The name of this variable may well be the string that
    was decrypted earlier. Let’s see whether *ctf* ’s behavior changes when you set
    a dummy value for the `GUESSME` environment variable as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用了 `getenv`，这是一个标准库函数，用于查找环境变量 ➒。你可以看到 *ctf* 期望有一个名为 `GUESSME` 的环境变量！这个变量的名字很可能就是之前解密出来的字符串。让我们看看当你为
    `GUESSME` 环境变量设置一个虚拟值时，*ctf* 的行为是否会发生变化，如下所示：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Setting `GUESSME` results in an additional line of output that says `guess again!`.
    It seems that *ctf* expects `GUESSME` to be set to another specific value. Perhaps
    another `ltrace` run, as shown in [Listing 5-8](ch05.xhtml#ch05list8), will reveal
    what the expected value is.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`GUESSME`会导致输出一行额外的信息，显示`guess again!`。看起来*ctf*期望`GUESSME`被设置为另一个特定值。也许再执行一次`ltrace`，如[列表
    5-8](ch05.xhtml#ch05list8)所示，将揭示出期望的值是什么。
- en: '*Listing 5-8: Library calls made by the* ctf *binary after setting the* GUESSME
    *environment variable*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-8：* ctf *二进制文件在设置* GUESSME *环境变量后的库函数调用*'
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After the call to `getenv`, *ctf* goes on to assign ➊ and decrypt ➋ another
    C++ string. Unfortunately, between the decryption and the moment that `guess again`
    is printed to the screen ➌, you don’t see any hints regarding the expected value
    of `GUESSME`. This tells you that the comparison of `GUESSME` to its expected
    value is implemented without the use of any library functions. You’ll need to
    take another approach.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`getenv`之后，*ctf*继续执行分配 ➊ 并解密 ➋ 另一个C++字符串。不幸的是，在解密和`guess again`被打印到屏幕 ➌ 之间，你并没有看到任何关于`GUESSME`期望值的线索。这告诉你，`GUESSME`与其期望值的比较是没有使用任何库函数来实现的。你需要采取另一种方法。
- en: 5.8 Examining Instruction-Level Behavior Using objdump
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8 使用objdump检查指令级行为
- en: Because you know that the value of the `GUESSME` environment variable is checked
    without using any well-known library functions, a logical next step is to use
    `objdump` to examine *ctf* at the instruction level to find out what’s going on.^([3](footnote.xhtml#ch05fn_3))
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你知道`GUESSME`环境变量的值是在没有使用任何知名库函数的情况下进行检查的，接下来的合乎逻辑的步骤是使用`objdump`检查*ctf*的指令级别，看看发生了什么。^([3](footnote.xhtml#ch05fn_3))
- en: From the `ltrace` output in [Listing 5-8](ch05.xhtml#ch05list8), you know that
    the `guess again` string is printed to the screen by a call to `puts` at address
    `0x400dd7`. Let’s focus the `objdump` investigation around this address. It will
    also help to know the address of the string to find the first instruction that
    loads it. To find this address, you can look at the `.rodata` section of the *ctf*
    binary using `objdump -s` to print the full section contents, as shown in [Listing
    5-9](ch05.xhtml#ch05list9).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从[列表 5-8](ch05.xhtml#ch05list8)中的`ltrace`输出，你知道`guess again`字符串是通过在地址`0x400dd7`调用`puts`打印到屏幕上的。让我们集中在这个地址周围进行`objdump`调查。知道字符串的地址也会有所帮助，这样可以找到加载它的第一条指令。要找到这个地址，你可以使用`objdump
    -s`查看*ctf*二进制文件的`.rodata`部分，正如[列表 5-9](ch05.xhtml#ch05list9)所示。
- en: '*Listing 5-9: The contents of* ctf*’s* .rodata *section as shown by* objdump'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-9：* ctf *的* .rodata *部分内容，使用* objdump *显示*'
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using `objdump` to examine *ctf* ’s `.rodata` section, you can see the `guess
    again` string at address `0x4011af` ➊. Now let’s take a look at [Listing 5-10](ch05.xhtml#ch05list10),
    which shows the instructions around the `puts` call, to find out what input *ctf*
    expects for the `GUESSME` environment variable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`objdump`检查*ctf*的`.rodata`部分时，你可以看到`guess again`字符串位于地址`0x4011af` ➊。现在让我们来看一下[列表
    5-10](ch05.xhtml#ch05list10)，它展示了`puts`调用附近的指令，以找出*ctf*期望的`GUESSME`环境变量输入是什么。
- en: '*Listing 5-10: Instructions checking the value of* GUESSME'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-10：检查* GUESSME *值的指令*'
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `guess again` string is loaded by the instruction at `0x400dcd` ➍ and is
    then printed using `puts` ➎. This is the failure case; let’s work our way backward
    from here.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`guess again`字符串是通过地址`0x400dcd` ➍的指令加载的，然后使用`puts` ➎打印出来。这是失败的情况；让我们从这里开始倒推。'
- en: The failure case is reached from a loop that starts at address `0x400dc0`. In
    each iteration of the loop, it loads a byte from an array (probably a string)
    into `edx` ➊. The `rbx` register points to the base of this array, while `rax`
    indexes it. If the loaded byte turns out to be `NULL`, then the `je` instruction
    at `0x400dc6` jumps to the failure case ➋. This comparison to `NULL` is a check
    for the end of the string. If the end of the string is reached here, then it’s
    too short to be a match. If the byte is not `NULL`, the `je` falls through to
    the next instruction, at address `0x400dc8`, which compares the byte in `edx`
    against a byte in another string, based at `rcx` and indexed by `rax` ➌.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 失败案例是从一个起始地址为`0x400dc0`的循环中达到的。在每次循环迭代中，它从一个数组（可能是字符串）中加载一个字节到`edx`寄存器 ➊。`rbx`寄存器指向该数组的起始位置，而`rax`则用于索引数组。如果加载的字节是`NULL`，那么位于`0x400dc6`的`je`指令将跳转到失败案例
    ➋。这个与`NULL`的比较是为了检查字符串的结尾。如果这里到达了字符串的结尾，那么它就太短，无法匹配。如果字节不是`NULL`，则`je`指令将跳过，进入下一条指令，位于地址`0x400dc8`，该指令将`edx`中的字节与另一个字符串中的字节进行比较，这个字符串基于`rcx`并由`rax`进行索引
    ➌。
- en: If the two compared bytes match up, then the program jumps to address `0x400de0`,
    where it increases the string index ➏, and checks whether the string index is
    equal to `0x15`, the length of the string ➐. If it is, then the string comparison
    is complete; if not, the program jumps into another iteration of the loop ➑.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个比较的字节匹配，程序将跳转到地址`0x400de0`，在这里它增加字符串索引➏，并检查字符串索引是否等于`0x15`，即字符串的长度➐。如果相等，字符串比较完成；如果不相等，程序将跳转到循环的另一次迭代➑。
- en: From this analysis, you now know that the string based at the `rcx` register
    is used as a ground truth. The program compares the environment string taken from
    the `GUESSME` variable against this ground truth. This means that if you can dump
    the ground truth string, you can find the expected value for `GUESSME`! Because
    the string is decrypted at runtime and isn’t available statically, you’ll need
    to use dynamic analysis to recover it instead of using `objdump`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从这次分析中，你现在知道基于`rcx`寄存器的字符串被用作基准真值。程序将从`GUESSME`变量中获取的环境字符串与这个基准真值进行比较。这意味着，如果你能够转储这个基准真值字符串，就能找到`GUESSME`的预期值！因为字符串是在运行时解密的，静态时不可用，你需要使用动态分析来恢复它，而不是使用`objdump`。
- en: 5.9 Dumping a Dynamic String Buffer Using gdb
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.9 使用gdb转储动态字符串缓冲区
- en: Probably the most used dynamic analysis tool on GNU/Linux is `gdb`, or the GNU
    Debugger. As the name suggests, `gdb` is mainly for debugging, but it can be used
    for a variety of dynamic analysis purposes. In fact, it’s an extremely versatile
    tool, and there’s no way to cover all of its functionality in this chapter. However,
    I’ll go over some of the most-used features of `gdb` you can use to recover the
    expected value of `GUESSME`. The best place to look up information on `gdb` is
    not the man page but *[http://www.gnu.org/software/gdb/documentation/](http://www.gnu.org/software/gdb/documentation/)*,
    where you’ll find an extensive manual covering all the supported `gdb` commands.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在GNU/Linux上，最常用的动态分析工具可能是`gdb`，即GNU调试器。顾名思义，`gdb`主要用于调试，但它也可以用于各种动态分析目的。实际上，它是一个功能非常强大的工具，在这一章中无法覆盖它的所有功能。不过，我将介绍一些最常用的`gdb`功能，帮助你恢复`GUESSME`的预期值。查找`gdb`信息的最佳地点不是手册页，而是*[http://www.gnu.org/software/gdb/documentation/](http://www.gnu.org/software/gdb/documentation/)*，在那里你可以找到一份详尽的手册，涵盖了所有支持的`gdb`命令。
- en: 'Like `strace` and `ltrace`, `gdb` has the ability to attach to a running process.
    However, because *ctf* is not a long-running process, you can simply run it with
    `gdb` from the start. Because `gdb` is an interactive tool, when you start a binary
    under `gdb`, it’s not immediately executed. After printing a startup message with
    some usage instructions, `gdb` pauses and waits for a command. You can tell that
    `gdb` is waiting for a command by the command prompt: `(gdb)`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 像`strace`和`ltrace`一样，`gdb`也具有附加到正在运行的进程的能力。然而，由于*ctf*不是一个长期运行的进程，你可以直接从一开始就用`gdb`运行它。因为`gdb`是一个交互式工具，当你在`gdb`下启动一个二进制文件时，它不会立即执行。在打印启动信息和一些使用说明后，`gdb`会暂停并等待命令。你可以通过命令提示符`(gdb)`知道`gdb`正在等待命令。
- en: '[Listing 5-11](ch05.xhtml#ch05list11) shows the sequence of `gdb` commands
    needed to find the expected value of the `GUESSME` environment variable. I’ll
    explain each of these commands as I discuss the listing.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-11](ch05.xhtml#ch05list11)展示了查找`GUESSME`环境变量预期值所需的`gdb`命令序列。我将在讨论该列表时逐一解释这些命令。'
- en: '*Listing 5-11: Finding the expected value of* GUESSME *using* gdb'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-11：使用* gdb *查找* GUESSME *的预期值*'
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: One of the most basic functions of any debugger is setting a *breakpoint*, which
    is simply an address or a function name at which the debugger will “break” execution.
    Whenever the debugger reaches a breakpoint, it pauses execution and returns control
    to the user, waiting for a command. To dump the “magic” string against which the
    `GUESSME` environment variable is compared, you set a breakpoint at address `0x400dc8`
    ➊ where the comparison happens. In `gdb`, the command for setting a breakpoint
    at an address is `b` **address* (`b` is a short version of the command `break`).
    If symbols are available (they aren’t in this case), you can set a breakpoint
    at the entry point of a function using the function’s name. For instance, to set
    a breakpoint at the start of `main`, you would use the command `b main`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器最基本的功能之一是设置*断点*，它就是一个地址或函数名，调试器将在该位置“中断”执行。每当调试器达到断点时，它会暂停执行并将控制权交还给用户，等待命令。为了转储与`GUESSME`环境变量进行比较的“魔法”字符串，你需要在地址`0x400dc8`
    ➊（比较发生的地方）设置断点。在`gdb`中，设置断点的命令是`b` **address**（`b`是命令`break`的简写）。如果符号可用（在此情况下不可用），你可以使用函数名在函数入口处设置断点。例如，要在`main`的起始位置设置断点，可以使用命令`b
    main`。
- en: After setting the breakpoint, you need to do one more thing before you can start
    the execution of *ctf* . You still need to set a value for the `GUESSME` environment
    variable to prevent *ctf* from exiting prematurely. In `gdb`, you can set the
    `GUESSME` environment variable using the command `set env GUESSME=foobar` ➋. Now,
    you can begin the execution of *ctf* by issuing the command `run show_me_the_flag`
    ➌. As you can see, you can pass arguments to the `run` command, which it then
    automatically passes on to the binary you’re analyzing (in this case, *ctf* ).
    Now, *ctf* begins executing normally, and it should continue doing so until it
    hits your breakpoint.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完断点后，在开始执行*ctf*之前，你还需要做一件事。你仍然需要为`GUESSME`环境变量设置一个值，以防止*ctf*提前退出。在`gdb`中，你可以使用命令`set
    env GUESSME=foobar` ➋来设置`GUESSME`环境变量。现在，你可以通过发出命令`run show_me_the_flag` ➌来开始执行*ctf*。如你所见，你可以将参数传递给`run`命令，它会自动将这些参数传递给你正在分析的二进制文件（在此情况下是*ctf*）。现在，*ctf*开始正常执行，应该会一直执行直到遇到你的断点。
- en: When *ctf* hits the breakpoint, `gdb` halts the execution of *ctf* and returns
    control to you, informing you that a breakpoint was hit ➍. At this point, you
    can use the `display/i $pc` command to display the instruction at the current
    program counter (`$pc`), just to make sure you’re at the expected instruction
    ➎. As expected, `gdb` informs you that the next instruction to be executed is
    `cmp (%rcx,%rax,1),%dl`, which is indeed the comparison instruction you’re interested
    in (in AT&T format).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当*ctf*遇到断点时，`gdb`会暂停*ctf*的执行并将控制权交还给你，通知你断点已被触发 ➍。此时，你可以使用命令`display/i $pc`来显示当前程序计数器（`$pc`）处的指令，以确保你在预期的指令处
    ➎。正如预期的那样，`gdb`通知你接下来要执行的指令是`cmp (%rcx,%rax,1),%dl`，这确实是你感兴趣的比较指令（以AT&T格式显示）。
- en: Now that you’ve reached the point in *ctf* ’s execution where `GUESSME` is compared
    against the expected string, you need to find out the base address of the string
    so that you can dump it. To view the base address contained in the `rcx` register,
    use the command `info registers rcx`➏. You can also view the contents of `rax`,
    just to ensure that the loop counter is zero, as expected ➐. It’s also possible
    to use the command `info registers` without specifying any register name. In that
    case, `gdb` will show the contents of all general-purpose registers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经到达了*ctf*执行过程中的那个时刻，`GUESSME`与预期字符串进行比较，你需要找到该字符串的基地址，以便将其转储。要查看`rcx`寄存器中包含的基地址，可以使用命令`info
    registers rcx`➏。你还可以查看`rax`的内容，确保循环计数器为零，符合预期 ➐。也可以使用命令`info registers`而不指定任何寄存器名称，在这种情况下，`gdb`会显示所有通用寄存器的内容。
- en: You now know the base address of the string you want to dump; it starts at address
    `0x615050`. The only thing left to do is to dump the string at that address. The
    command to dump memory in `gdb` is `x`, which is capable of dumping memory in
    many granularities and encodings. For instance, `x/d` dumps a single byte in decimal
    representation, `x/x` dumps a byte in hexadecimal representation, and `x/4xw`
    dumps four hexadecimal words (which are 4-byte integers). In this case, the most
    useful version of the command is `x/s`, which dumps a C-style string, continuing
    until it encounters a `NULL` byte. When you issue the command `x/s 0x615050` to
    dump the string you’re interested in ➑, you can see that the expected value of
    `GUESSME` is `Crackers Don't Matter`. Let’s exit `gdb` using the `quit` command
    ➒ to try it!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道了你想要转储的字符串的基址；它从地址 `0x615050` 开始。接下来要做的就是在该地址处转储字符串。在 `gdb` 中转储内存的命令是 `x`，它能够以多种粒度和编码方式转储内存。例如，`x/d`
    以十进制表示转储一个字节，`x/x` 以十六进制表示转储一个字节，`x/4xw` 转储四个十六进制字（即 4 字节整数）。在这种情况下，最有用的命令是 `x/s`，它会转储一个
    C 风格的字符串，直到遇到 `NULL` 字节为止。当你执行命令 `x/s 0x615050` 来转储你感兴趣的字符串时 ➑，你可以看到预期的值 `GUESSME`
    是 `Crackers Don't Matter`。接下来，让我们使用 `quit` 命令 ➒ 退出 `gdb` 来尝试它！
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As this listing shows, you’ve finally completed all the necessary steps to
    coax *ctf* into giving you the secret flag! On the VM in the directory for this
    chapter, you’ll find a program called *oracle*. Go ahead and feed the flag to
    *oracle*, like this: `./oracle 84b34c124b2ba5ca224af8e33b077e9e`. You’ve now unlocked
    the next challenge, which you can complete on your own using your new skills.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如此列表所示，你终于完成了所有必要的步骤，成功地让 *ctf* 给你提供了秘密旗帜！在本章的虚拟机目录中，你会找到一个名为 *oracle* 的程序。现在，按照下面的方式将旗帜传递给
    *oracle*：`./oracle 84b34c124b2ba5ca224af8e33b077e9e`。你现在已经解锁了下一个挑战，接下来可以凭借你新学到的技能自己完成它。
- en: 5.10 Summary
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.10 小结
- en: In this chapter, I introduced you to all the essential Linux binary analysis
    tools you need to be an effective binary analyst. While most of these tools are
    simple enough, you can combine them to implement powerful binary analyses in no
    time! In the next chapter, you’ll explore some of the major disassembly tools
    and other, more advanced analysis techniques.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我向你介绍了所有成为有效二进制分析师所需的基本 Linux 二进制分析工具。尽管这些工具大多数都很简单，但你可以将它们组合起来，迅速实施强大的二进制分析！在下一章中，你将探索一些主要的反汇编工具以及其他更高级的分析技巧。
- en: Exercise
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 1\. A New CTF Challenge
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 新的 CTF 挑战
- en: Complete the new CTF challenge unlocked by the *oracle* program! You can complete
    the entire challenge using only the tools discussed in this chapter and what you
    learned in [Chapter 2](ch02.xhtml#ch02). After completing the challenge, don’t
    forget to give the flag you found to the oracle to unlock the next challenge.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 完成由 *oracle* 程序解锁的新的 CTF 挑战！你可以仅使用本章讨论的工具和在[第 2 章](ch02.xhtml#ch02)中学到的内容来完成整个挑战。完成挑战后，别忘了将你找到的旗帜交给
    oracle 以解锁下一个挑战。
