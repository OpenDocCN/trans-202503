- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: KEYED HASHING
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 带密钥的哈希
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: The hash functions discussed in [Chapter 6](ch06.xhtml#ch6) take a message and
    return its hash value—typically a short string of 256 or 512 bits. Anyone can
    compute the hash value of a message and verify that a particular message hashes
    to a particular value because there’s no secret value involved, but sometimes
    you don’t want to let just anyone do that. That’s where *keyed* hash functions
    come in, or hashing with secret keys.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第六章](ch06.xhtml#ch6) 中讨论的哈希函数接受一条消息并返回其哈希值——通常是一个 256 位或 512 位的短字符串。任何人都可以计算一条消息的哈希值，并验证特定消息是否哈希到特定值，因为其中没有涉及秘密值，但有时你不希望随便让任何人做这个操作。这就是
    *带密钥* 的哈希函数的作用，或者说是使用秘密密钥的哈希。'
- en: 'Keyed hashing forms the basis of two types of important cryptographic algorithms:
    *message authentication codes (MACs)*, which authenticate a message and protect
    its integrity, and *pseudorandom functions (PRFs)*, which produce random-looking
    hash-sized values. We’ll look at how and why MACs and PRFs are similar in the
    first section of this chapter; then we’ll review how real MACs and PRFs work.
    Some MACs and PRFs are based on hash functions, some are based on block ciphers,
    and still others are original designs. Finally, we’ll review examples of attacks
    on otherwise secure MACs.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 带密钥的哈希形式是两种重要加密算法的基础：*消息认证码（MAC）*，它用于认证消息并保护其完整性，以及 *伪随机函数（PRF）*，它生成随机看似的哈希大小值。在本章的第一节中，我们将探讨为什么
    MAC 和 PRF 是相似的；然后我们将回顾实际的 MAC 和 PRF 如何工作。一些 MAC 和 PRF 基于哈希函数，一些基于块加密算法，其他的则是原创设计。最后，我们将回顾一些攻击示例，这些攻击对其他安全的
    MAC 进行攻击。
- en: Message Authentication Codes (MACs)
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息认证码（MAC）
- en: A MAC protects a message’s integrity and authenticity by creating a value *T*
    = **MAC**(*K*, *M*), called the authentication tag of the message, *M* (often
    confusingly called the MAC of *M*). Just as you can decrypt a message if you know
    a cipher’s key, you can validate that a message has not been modified if you know
    a MAC’s key.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: MAC 通过生成一个值 *T* = **MAC**(*K*, *M*) 来保护消息 *M* 的完整性和真实性，这个值被称为消息的认证标签 *T*（通常令人困惑地称为
    *M* 的 MAC）。就像你知道加密算法的密钥可以解密消息一样，如果你知道 MAC 的密钥，你也可以验证消息是否被篡改。
- en: For example, say Alex and Bill share a key, *K*, and Alex sends a message, *M*,
    to Bill along with its authentication tag, *T* = **MAC**(*K*, *M*). Upon receiving
    the message and its authentication tag, Bill recomputes **MAC**(*K*, *M*) and
    checks that it is equal to the authentication tag received. Because only Alex
    could have computed this value, Bill knows that the message wasn’t corrupted in
    transit (confirming integrity), whether accidentally or maliciously, and that
    Alex sent that message (confirming authenticity).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设 Alex 和 Bill 共享一个密钥 *K*，并且 Alex 向 Bill 发送消息 *M* 及其认证标签 *T* = **MAC**(*K*,
    *M*)。收到消息和认证标签后，Bill 重新计算 **MAC**(*K*, *M*) 并检查它是否等于收到的认证标签。因为只有 Alex 能够计算出这个值，Bill
    知道消息在传输过程中没有被篡改（确认完整性），无论是意外的还是恶意的，并且消息是由 Alex 发送的（确认真实性）。
- en: '*MACs in Secure Communication*'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*MAC 在安全通信中的应用*'
- en: Secure communication systems often combine a cipher and a MAC to protect a message’s
    confidentiality, integrity, and authenticity. For example, the protocols in Internet
    Protocol Security (IPSec), Secure Shell (SSH), and Transport Layer Security (TLS)
    generate a MAC for each network packet transmitted.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 安全通信系统通常结合使用加密算法和 MAC 来保护消息的机密性、完整性和真实性。例如，互联网协议安全（IPSec）、安全外壳协议（SSH）和传输层安全（TLS）中的协议都会为每个传输的网络数据包生成一个
    MAC。
- en: Not all communication systems use MACs. Sometimes an authentication tag can
    add unacceptable overhead to each packet, typically in the range of 64 to 128
    bits. For example, the 3G and 4G mobile telephony standards encrypt packets encoding
    voice calls but they don’t authenticate them. An attacker can modify the encrypted
    audio signal and the recipient wouldn’t notice. Thus, if an attacker damages an
    encrypted voice packet, it will decrypt to noise, which would sound like static.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有通信系统都使用 MAC。有时候，认证标签会给每个数据包增加不可接受的开销，通常在 64 到 128 位之间。例如，3G 和 4G 移动电话标准对编码语音通话的数据包进行加密，但并不进行认证。攻击者可以修改加密的音频信号，接收者却无法察觉。因此，如果攻击者破坏了加密的语音数据包，它将解密为噪声，听起来像是静电噪音。
- en: '*Forgery and Chosen-Message Attacks*'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*伪造和选择消息攻击*'
- en: What does it mean for a MAC to be secure? First of all, as with a cipher, the
    secret key should remain secret. If a MAC is secure, an attacker shouldn’t be
    able to create a tag of some message if they don’t know the key. Such a made-up
    message/tag pair is called a *forgery*, and recovering a key is just a specific
    case of a more general class of attacks called *forgery attacks*. The security
    notion that posits that forgeries should be impossible to find is called *unforgeability*.
    Obviously, it should be impossible to recover the secret key from a list of tags;
    otherwise, attackers could forge tags using the key.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MAC（消息认证码）来说，什么才算安全呢？首先，与加密算法一样，秘密密钥应该保持机密。如果一个MAC是安全的，攻击者在不知道密钥的情况下，不能创建某个消息的标签。这样伪造的消息/标签对被称为*伪造*，而恢复密钥只是一个更广泛的攻击类别——*伪造攻击*——的特定案例。提出“伪造应该无法找到”的安全概念称为*不可伪造性*。显然，从标签列表中恢复秘密密钥应该是不可能的；否则，攻击者可以使用密钥伪造标签。
- en: What can an attacker do to break a MAC? In other words, what’s the attack model?
    The most basic model is the *known-message attack*, which passively collects messages
    and their associated tags (for example, by eavesdropping on a network). But real
    attackers often launch more powerful attacks because they can often choose the
    messages to be authenticated, and therefore get the MAC of the message they want.
    The standard model is therefore that of *chosen-message* *attacks*, wherein attackers
    get tags for messages of their choice.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以做什么来破坏MAC呢？换句话说，攻击模型是什么？最基本的模型是*已知消息攻击*，即被动收集消息及其关联的标签（例如，通过窃听网络）。但真正的攻击者通常会发起更强大的攻击，因为他们通常可以选择要认证的消息，从而获得他们想要的消息的MAC。因此，标准模型是*选择消息攻击*，即攻击者获得他们选择的消息的标签。
- en: '*Replay Attacks*'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*重放攻击*'
- en: MACs aren’t safe from attacks involving *replays* of tags. For example, if you
    were to eavesdrop on Alex and Bill’s communications, you could capture a message
    and its tag sent by Alex to Bill, and later send them again to Bill pretending
    to be Alex. To prevent such *replay attacks*, protocols include a message number
    in each message. This number is incremented for each new message and authenticated
    along with the message. The receiving party gets messages numbered 1, 2, 3, 4,
    and so on. Thus, if an attacker tries to send message number 1 again, the receiver
    will notice that this message is out of order and that it’s a potential replay
    of the earlier message number 1.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MAC并不安全于涉及标签*重放*的攻击。例如，如果你窃听了Alex和Bill的通信，你可以捕获Alex发送给Bill的消息及其标签，并在稍后再次将这些信息发送给Bill，假装是Alex。为了防止这种*重放攻击*，协议会在每个消息中包含一个消息编号。每个新消息的编号都会递增，并与消息一起进行认证。接收方会收到编号为1、2、3、4等的消息。因此，如果攻击者试图再次发送编号为1的消息，接收方会注意到该消息的顺序不对，并且这可能是之前编号为1的消息的重放。
- en: Pseudorandom Functions (PRFs)
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伪随机函数（PRF）
- en: A PRF is a function that uses a secret key to return **PRF**(*K*, *M*), such
    that the output looks random. Because the key is secret, the output values are
    unpredictable to an attacker.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: PRF（伪随机函数）是一种使用秘密密钥返回**PRF**(*K*, *M*)的函数，其输出看起来是随机的。因为密钥是保密的，攻击者无法预测输出值。
- en: Unlike MACs, PRFs are not meant to be used on their own but as part of a cryptographic
    algorithm or protocol. For example, PRFs can be used to create block ciphers within
    the Feistel construction discussed in [“How to Construct Block Ciphers”](ch04.xhtml#lev1sec28)
    on page 55\. Key derivation schemes use PRFs to generate cryptographic keys from
    a master key or a password, and identification schemes use PRFs to generate a
    response from a random challenge. (Basically, a server sends a random challenge
    message, *M*, and the client returns **PRF**(*K*, *M*) in its response to prove
    that it knows *K*.) The 4G telephony standard uses a PRF to authenticate a SIM
    card and its service provider, and a similar PRF also serves to generate the encryption
    key and MAC key to be used during a phone call. The TLS protocol uses a PRF to
    generate key material from a master secret as well as session-specific random
    values. There’s even a PRF in the noncryptographic `hash()` function built into
    the Python language to compare objects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与MAC不同，PRF并不打算单独使用，而是作为密码学算法或协议的一部分。例如，PRF可以用于创建在第55页[“如何构建分组密码”](ch04.xhtml#lev1sec28)中讨论的Feistel结构中的分组密码。密钥衍生方案使用PRF从主密钥或密码中生成加密密钥，身份验证方案使用PRF从随机挑战中生成响应。（基本上，服务器发送一个随机挑战消息，*M*，客户端在响应中返回**PRF**(*K*,
    *M*)以证明它知道*K*。）4G电话标准使用PRF来验证SIM卡及其服务提供商，类似的PRF还用于生成电话通话期间使用的加密密钥和MAC密钥。TLS协议使用PRF从主密钥以及会话特定的随机值中生成密钥材料。甚至Python语言内置的非加密`hash()`函数中也有一个PRF，用于比较对象。
- en: '*PRF Security*'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*伪随机函数（PRF）安全性*'
- en: In order to be secure, a pseudorandom function should have no pattern that sets
    its outputs apart from truly random values. An attacker who doesn’t know the key,
    *K*, shouldn’t be able to distinguish the outputs of **PRF**(*K*, *M*) from random
    values. Viewed differently, an attacker shouldn’t have any means of knowing whether
    they’re talking to a PRF algorithm or to a random function. The erudite phrase
    for that security notion is *indistinguishability from a* *random* *function*.
    (To learn more about the theoretical foundations of PRFs, see Volume 1, Section
    3.6 of Goldreich’s *Foundations of Cryptography*.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保安全性，伪随机函数的输出应该没有任何模式，不能与真正的随机值区分开来。一个不知道密钥的攻击者，*K*，不应该能够区分**PRF**(*K*, *M*)的输出与随机值的区别。从另一个角度来看，攻击者应该无法知道他们是在与一个PRF算法进行交互，还是在与一个随机函数交互。这个安全性概念的学术术语是*与*
    *随机* *函数不可区分性*。（要了解更多关于PRF的理论基础，请参见Goldreich的《*密码学基础*》第一卷第3.6节。）
- en: '*Why PRFs Are Stronger Than MACs*'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*为什么PRF比MAC更强*'
- en: PRFs and MACs are both keyed hashes, but PRFs are fundamentally stronger than
    MACs, largely because MACs have weaker security requirements. Whereas a MAC is
    considered secure if tags can’t be forged—that is, if the MAC’s outputs can’t
    be guessed—a PRF is only secure if its outputs are indistinguishable random strings,
    which is a stronger requirement. If a PRF’s outputs can’t be distinguished from
    random strings, the implication is that their values can’t be guessed; in other
    words, any secure PRF is also a secure MAC.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PRF和MAC都是基于密钥的哈希，但PRF在本质上比MAC更强，主要是因为MAC的安全要求较弱。MAC被认为是安全的，如果标签无法伪造——也就是说，MAC的输出不能被猜测——而PRF只有在其输出是不可区分的随机字符串时才被认为是安全的，这是一项更强的要求。如果PRF的输出不能与随机字符串区分开来，那么意味着它们的值无法被猜测；换句话说，任何安全的PRF也是一个安全的MAC。
- en: 'The converse is not true, however: a secure MAC isn’t necessarily a secure
    PRF. For example, say you start with a secure PRF, **PRF1**, and you want to build
    a second PRF, **PRF2**, from it, like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，反过来并不成立：一个安全的MAC不一定是一个安全的PRF。例如，假设你从一个安全的PRF，**PRF1**，开始，并且你想从它构建一个第二个PRF，**PRF2**，像这样：
- en: '**PRF2**(*K*, *M*) = **PRF1**(*K*, *M*) || 0'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**PRF2**(*K*, *M*) = **PRF1**(*K*, *M*) || 0'
- en: Because **PRF2**’s output is defined as **PRF1**’s output followed by one 0
    bit, it doesn’t look as random as a true random string, and you can distinguish
    its outputs by that last 0 bit. Hence, **PRF2** is not a secure PRF. However,
    because **PRF1** is secure, **PRF2** would still make a secure MAC. Why? Because
    if you were able to forge a tag, *T* = **PRF2**(*K*, *M*), for some *M*, then
    you’d also be able to forge a tag for **PRF1**, which we know to be impossible
    in the first place because PRF1 is a secure MAC. Thus, PRF2 is a keyed hash that’s
    a secure MAC but not a secure PRF.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因为**PRF2**的输出定义为**PRF1**的输出后跟一个0位，它看起来不像一个真正的随机字符串，你可以通过那个最后的0位来区分它的输出。因此，**PRF2**不是一个安全的PRF。然而，由于**PRF1**是安全的，**PRF2**仍然可以作为一个安全的MAC。为什么？因为如果你能够伪造一个标签，*T*
    = **PRF2**(*K*, *M*)，对于某个*M*，那么你也能够伪造一个**PRF1**的标签，而我们知道，伪造**PRF1**的标签本来就是不可能的，因为**PRF1**是一个安全的MAC。因此，**PRF2**是一个带密钥的哈希，它是一个安全的MAC，但不是一个安全的PRF。
- en: 'But don’t worry: you won’t find such MAC constructions in real applications.
    In fact, many of the MACs deployed or standardized are also secure PRFs and are
    often used as either. For example, TLS uses the algorithm HMAC-SHA-256 both as
    a MAC and as a PRF.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但别担心：你在实际应用中不会遇到这种MAC构造。事实上，许多已经部署或标准化的MAC也是安全的PRF，且经常同时作为两者使用。例如，TLS使用HMAC-SHA-256算法既作为MAC，也作为PRF。
- en: Creating Keyed Hashes from Unkeyed Hashes
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从无密钥哈希创建带密钥哈希
- en: Throughout the history of cryptography, MACs and PRFs have rarely been designed
    from scratch but rather have been built from existing algorithms, usually hash
    functions of block ciphers. One seemingly obvious way to produce a keyed hash
    function would be to feed an (unkeyed) hash function a key and a message, but
    that’s easier said than done, as I discuss next.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学的历史中，MAC和PRF很少是从头开始设计的，而是基于现有算法，通常是基于哈希函数或块加密算法构建的。一种看似显而易见的方式是给（无密钥的）哈希函数输入一个密钥和一个消息，但这并非易事，正如我接下来要讨论的那样。
- en: '*The Secret-Prefix Construction*'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*秘密前缀构造*'
- en: The first technique we’ll examine, called the *secret-prefix construction*,
    turns a normal hash function into a keyed hash one by prepending the key to the
    message and returning **Hash**(*K* || *M*). Although this approach is not always
    wrong, it can be insecure when the hash function is vulnerable to length-extension
    attacks (as discussed in [“The Length-Extension Attack”](ch06.xhtml#lev2sec83)
    on page 125) and when the hash supports keys of different lengths.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要审视的第一个技术，称为*秘密前缀构造*，通过将密钥加到消息前面并返回**Hash**(*K* || *M*), 将一个普通的哈希函数转变为带密钥的哈希函数。尽管这种方法并不总是错误，但当哈希函数易受长度扩展攻击（如在[《长度扩展攻击》](ch06.xhtml#lev2sec83)第125页中讨论的那样）和哈希函数支持不同长度的密钥时，它可能会不安全。
- en: Insecurity Against Length-Extension Attacks
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对长度扩展攻击的脆弱性
- en: Recall from [Chapter 6](ch06.xhtml#ch6) that hash functions of the SHA-2 family
    allow attackers to compute the hash of a partially unknown message when given
    a hash of a shorter version of that message. In formal terms, the *length-extension*
    attack allows attackers to compute **Hash**(*K* || *M*[1] || *M*[2]) given only
    **Hash**(*K* || *M*[1]) and neither *M*[1] nor *K*. These functions allow attackers
    to forge valid MAC tags for free because they’re not supposed to be able to guess
    the MAC of *M*[1] || *M*[2] given only the MAC of *M*[1]. This fact makes the
    secret-prefix construction as insecure as a MAC and PRF when, for example, it’s
    used with SHA-256 or SHA-512\. It is a weakness of Merkle–Damgård to allow length-extension
    attacks, and none of the SHA-3 finalists do. The ability to thwart length-extension
    attacks was mandatory for SHA-3 submissions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第6章](ch06.xhtml#ch6)，SHA-2家族的哈希函数允许攻击者在给定较短版本消息的哈希值时，计算出部分未知消息的哈希值。从形式上讲，*长度扩展*攻击允许攻击者计算出**Hash**(*K*
    || *M*[1] || *M*[2])，只需知道**Hash**(*K* || *M*[1])，而无需知道*M*[1]或*K*。这些函数允许攻击者免费伪造有效的MAC标签，因为他们本不应该能够仅凭*M*[1]的MAC来猜测*M*[1]
    || *M*[2]的MAC。这一事实使得秘密前缀构造在使用SHA-256或SHA-512时与MAC和PRF一样不安全。Merke–Damgård的弱点就是允许长度扩展攻击，而SHA-3的所有最终候选算法都不存在这个问题。抵御长度扩展攻击的能力是SHA-3提交的强制要求。
- en: Insecurity with Different Key Lengths
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不同密钥长度带来的脆弱性
- en: The secret-prefix construction is also insecure when it allows the use of keys
    of different lengths. For example, if the key *K* is the 24-bit hexa­decimal string
    123abc and *M* is def00, then **Hash**() will process the value *K* || *M* = 123abcdef00\.
    If *K* is instead the 16-bit string 123a and *M* is bcdef000, then **Hash**()
    will process *K* || *M* = 123abcdef00, too. Therefore, the result of the secret-prefix
    construction **Hash**(*K* || *M*) will be the same for both keys.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当秘密前缀构造允许使用不同长度的密钥时，它也不安全。例如，如果密钥*K*是24位的十六进制字符串123abc，*M*是def00，那么**Hash**()将处理值*K*
    || *M* = 123abcdef00。如果*K*是16位字符串123a，*M*是bcdef000，那么**Hash**()将处理*K* || *M* =
    123abcdef00。因此，秘密前缀构造**Hash**(*K* || *M*)的结果对于这两个密钥是相同的。
- en: This problem is independent of the underlying hash and can be fixed by hashing
    the key’s length along with the key and the message, for example, by encoding
    the key’s bit length as a 16-bit integer, *L*, and then hashing **Hash**(*L* ||
    *K* || *M*). But you shouldn’t have to do this. Modern hash functions such as
    BLAKE2 and SHA-3 include a keyed mode that avoids those pitfalls and yields a
    secure PRF, and thus a secure MAC as well.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题与底层哈希函数无关，可以通过将密钥的长度与密钥和消息一起哈希来解决，例如通过将密钥的比特长度编码为16位整数*L*，然后哈希**Hash**(*L*
    || *K* || *M*)。但你不应该需要这样做。现代哈希函数，如BLAKE2和SHA-3，包含一种键控模式，可以避免这些问题，并产生一个安全的伪随机函数（PRF），因此也可以得到一个安全的MAC。
- en: '*The Secret-Suffix Construction*'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*秘密后缀构造*'
- en: 'Instead of hashing the key before the message as in the secret-prefix construction,
    we can hash it *after*. And that’s exactly how the *secret-suffix construction*
    works: by building a PRF from a hash function as **Hash**(*M* || *K*).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与秘密前缀构造中在消息之前对密钥进行哈希不同，我们可以在消息之后对密钥进行哈希。这正是*秘密后缀构造*的工作原理：通过将哈希函数构建成一个伪随机函数（PRF），例如**Hash**(*M*
    || *K*)。
- en: Putting the key at the end makes quite a difference. For one thing, the length-extension
    attack that works against secret-prefix MACs won’t work against the secret suffix.
    Applying length extension to a secret-suffix MAC, you’d get **Hash**(*M*[1] ||
    *K* || *M*[2]) from **Hash**(*M*[1] || *K*), but that wouldn’t be a valid attack
    because **Hash**(*M*[1] || *K* || *M*[2]) isn’t a valid secret-suffix MAC; the
    key needs to be at the end.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将密钥放在最后会带来很大不同。首先，针对秘密前缀MAC的长度扩展攻击无法作用于秘密后缀构造。对秘密后缀MAC应用长度扩展时，你会得到**Hash**(*M*[1]
    || *K* || *M*[2])，而不是**Hash**(*M*[1] || *K*)，但这并不是一个有效的攻击，因为**Hash**(*M*[1] ||
    *K* || *M*[2])并不是一个有效的秘密后缀MAC；密钥需要位于最后。
- en: However, the secret-suffix construction is weaker against another type of attack.
    Say you’ve got a collision for the hash **Hash**(*M*[1]) = **Hash**(*M*[2]), where
    *M*[1] and *M*[2] are two distinct messages, possibly of different sizes. In the
    case of a hash function such as SHA-256, this implies that **Hash**(*M*[1] ||
    *K*) and **Hash**(*M*[2] || *K*) will be equal too, because internally *K* will
    be processed based on the data hashed previously, namely **Hash**(*M*[1]), equal
    to **Hash**(*M*[2]). Hence, you’d get the same hash value whether you hash *K*
    after *M*[1] or after *M*[2], regardless of the value of *K*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，秘密后缀构造在面对另一种攻击时较弱。假设你得到了哈希碰撞**Hash**(*M*[1]) = **Hash**(*M*[2])，其中*M*[1]和*M*[2]是两个不同的消息，可能大小不同。以SHA-256这样的哈希函数为例，这意味着**Hash**(*M*[1]
    || *K*)和**Hash**(*M*[2] || *K*)也会相等，因为内部会根据之前哈希的内容处理*K*，即**Hash**(*M*[1])，其值等于**Hash**(*M*[2])。因此，无论*K*的值如何，你都会得到相同的哈希值，无论是将*K*放在*M*[1]后面，还是放在*M*[2]后面。
- en: 'To exploit this property, an attacker would:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这一特性，攻击者会：
- en: Find two colliding messages, *M*[1] and *M*[2]
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到两个碰撞消息，*M*[1]和*M*[2]。
- en: Request the MAC tag of *M*[1] **Hash**(*M*[1] || *K*)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求*M*[1]的MAC标签**Hash**(*M*[1] || *K*)
- en: Guess that **Hash**(*M*[2] || *K*) is the same, thereby forging a valid tag
    and breaking the MAC’s security
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设**Hash**(*M*[2] || *K*)与**Hash**(*M*)相同，从而伪造一个有效标签并破坏MAC的安全性。
- en: '*The HMAC Construction*'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*HMAC构造*'
- en: The hash-based MAC (HMAC) construction allows us to build a MAC from a hash
    function, which is more secure than either secret prefix or secret suffix. HMAC
    yields a secure PRF as long as the underlying hash is collision resistant, but
    even if that’s not the case, HMAC will still yield a secure PRF if the hash’s
    compression function is a PRF. The secure communication protocols IPSec, SSH,
    and TLS have all used HMAC. (You’ll find HMAC specifications in NIST’s FIPS 198-1
    standard and in RFC 2104.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 基于哈希的 MAC（HMAC）构造使我们能够从哈希函数构建一个 MAC，这比单纯的秘密前缀或秘密后缀更安全。只要底层的哈希是抗碰撞的，HMAC 就能产生一个安全的伪随机函数（PRF），即使哈希函数不是抗碰撞的，只要哈希的压缩函数是一个
    PRF，HMAC 仍然会产生一个安全的 PRF。安全通信协议如 IPSec、SSH 和 TLS 都使用了 HMAC。（你可以在 NIST 的 FIPS 198-1
    标准和 RFC 2104 中找到 HMAC 的规格。）
- en: 'HMAC uses a hash function, **Hash**, to compute a MAC tag, as shown in [Figure
    7-1](ch07.xhtml#ch7fig1) and according to the following expression:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: HMAC 使用哈希函数 **哈希** 来计算一个 MAC 标签，如 [图 7-1](ch07.xhtml#ch7fig1) 所示，并根据以下表达式计算：
- en: '**Hash**((*K* ⊕ *opad*) **Hash**((*K* ⊕ *ipad*) *M*))'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希**((*K* ⊕ *opad*) **哈希**((*K* ⊕ *ipad*) *M*))'
- en: The term *opad* (outer padding) is a string (*5c5c5c … 5c*) that is as long
    as **Hash**’s block size. The key, *K*, is usually shorter than one block that
    is filled with 00 bytes and XORed with *opad*. For example, if *K* is the 1-byte
    string *00*, then *K* ⊕ *opad* = *opad*. (The same is true if *K* is the all-zero
    string of any length up to a block’s length.) *K* ⊕ *opad* is the first block
    processed by the outer call to **Hash**—namely, the leftmost **Hash** in the preceding
    equation, or the bottom hash in [Figure 7-1](ch07.xhtml#ch7fig1).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*opad*（外填充）是一个字符串（*5c5c5c … 5c*），它的长度与 **哈希** 的块大小相同。密钥 *K* 通常比一个块短，且用 00 字节填充，并与
    *opad* 做异或运算。例如，如果 *K* 是 1 字节的字符串 *00*，则 *K* ⊕ *opad* = *opad*。（如果 *K* 是任意长度的全零字符串，且长度不超过一个块的大小，结果也一样。）*K*
    ⊕ *opad* 是由外层调用 **哈希** 处理的第一个块——即方程中最左边的 **哈希**，或者 [图 7-1](ch07.xhtml#ch7fig1)
    中的底部哈希。'
- en: The term *ipad* (inner padding) is a string (*363636* … *36*) that is as long
    as the **Hash**’s block size and that is also completed with 00 bytes. The resulting
    block is the first block processed by the inner call to **Hash**—namely, the rightmost
    **Hash** in the equation, or the top hash in [Figure 7-1](ch07.xhtml#ch7fig1).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*ipad*（内填充）是一个字符串（*363636* … *36*），它的长度与 **哈希** 的块大小相同，并且也是以 00 字节填充的。生成的块是由内层调用
    **哈希** 处理的第一个块——即方程中最右边的 **哈希**，或者 [图 7-1](ch07.xhtml#ch7fig1) 中的顶部哈希。'
- en: '![image](../images/f07-01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f07-01.jpg)'
- en: '*Figure 7-1: The HMAC hash-based MAC construction*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：基于 HMAC 的哈希 MAC 构造*'
- en: '**NOTE**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The envelope method is an even more secure construction than secret prefix
    and secret suffix. It’s expressed as **Hash***(K || M || K), *something called
    a *sandwich MAC*, but it’s theoretically less secure than HMAC.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*信封方法比秘密前缀和秘密后缀更加安全。它表示为 **哈希***(K || M || K)，一种被称为 *三明治 MAC* 的构造，但它理论上比 HMAC
    安全性低。*'
- en: If SHA-256 is the hash function used as **Hash**, then we call the HMAC instance
    HMAC-SHA-256\. More generally, we call HMAC-*Hash* an HMAC instance using the
    hash function *Hash*. That means if someone asks you to use HMAC, you should always
    ask, “Which hash function?”
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 SHA-256 作为 **哈希** 函数，则我们称这个 HMAC 实例为 HMAC-SHA-256。更一般地，我们称使用哈希函数 *哈希* 的
    HMAC 实例为 HMAC-*哈希*。这意味着，如果有人让你使用 HMAC，你应该总是问：“使用哪种哈希函数？”
- en: '*A Generic Attack Against Hash-Based MACs*'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*针对基于哈希的 MAC 的通用攻击*'
- en: There is one attack that works against all MACs based on an iterated hash function.
    Recall the attack in [“The Secret-Suffix Construction”](ch07.xhtml#lev2sec91)
    on page 131 where we used a hash collision to get a collision of MACs. You can
    use the same strategy to attack a secret-prefix MAC or HMAC, though the consequences
    are less devastating.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 针对所有基于迭代哈希函数的 MAC 存在一种攻击。回想一下在 [“秘密后缀构造”](ch07.xhtml#lev2sec91)（第 131 页）中我们利用哈希碰撞来获取
    MAC 的碰撞。你可以使用相同的策略来攻击秘密前缀 MAC 或 HMAC，尽管后果不如前者那样严重。
- en: To illustrate the attack, consider the secret-prefix MAC **Hash**(*K* || *M*),
    as shown in [Figure 7-2](ch07.xhtml#ch7fig2). If the digest is *n* bits, you can
    find two messages, *M*[1] and *M*[2], such that **Hash**(*K* || *M*[1]) = **Hash**(*K*
    || *M*[2]), by requesting approximately 2^(*n*)^(/2) MAC tags to the system holding
    the key. (Recall the birthday attack from [Chapter 6](ch06.xhtml#ch6).) If the
    hash lends itself to length extension, as SHA-256 does, you can then use *M*[1]
    and *M*[2] to forge MACs by choosing some arbitrary data, *M*[3], and then querying
    the MAC oracle for **Hash**(*K* || *M*[1] || *M*[3]), which is the MAC of message
    *M*[1] || *M*[3]. As it turns out, this is also the MAC of message *M*[2] || *M*[3],
    because the hash’s internal state of *M*[1] and *M*[3] and *M*[2] and *M*[3] is
    the same, and you’ve successfully forged a MAC tag. (The effort becomes infeasible
    as *n* grows beyond, say, 128 bits.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一攻击，考虑带有秘密前缀的MAC **Hash**(*K* || *M*)，如[图7-2](ch07.xhtml#ch7fig2)所示。如果摘要长度为*n*位，你可以找到两个消息，*M*[1]和*M*[2]，使得**Hash**(*K*
    || *M*[1]) = **Hash**(*K* || *M*[2])，通过向系统请求大约2^(*n*)^(/2)个MAC标签。 （回顾[第6章](ch06.xhtml#ch6)中的生日攻击。）如果哈希函数容易受到长度扩展攻击（如SHA-256），你可以使用*M*[1]和*M*[2]来伪造MAC，通过选择任意数据*M*[3]，然后查询MAC
    oracle以获取**Hash**(*K* || *M*[1] || *M*[3]），即消息*M*[1] || *M*[3]的MAC。事实证明，这也是消息*M*[2]
    || *M*[3]的MAC，因为哈希的内部状态在*M*[1]和*M*[3]以及*M*[2]和*M*[3]之间是相同的，你成功伪造了一个MAC标签。（随着*n*值的增加，比如超过128位，攻击的工作量变得不可行。）
- en: '![image](../images/f07-02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f07-02.jpg)'
- en: '*Figure 7-2: The principle of the generic forgery attack on hash-based MACs*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：基于哈希的MAC的通用伪造攻击原理*'
- en: 'This attack will work even if the hash function is not vulnerable to length
    extension, and it will work for HMAC, too. The cost of the attack depends on both
    the size of the chaining value and the MAC’s length: if a MAC’s chaining value
    is 512 bits and its tags are 128 bits, a 2^(64) computation would find a MAC collision
    but probably not a collision in the internal state, since finding such a collision
    would require 2^(512/2) = 2^(256) operations on average.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 即使哈希函数本身不容易受到长度扩展攻击，这个攻击依然有效，并且同样适用于HMAC。攻击的成本取决于链值的大小和MAC长度：如果一个MAC的链值为512位，标签为128位，那么进行2^(64)次计算将找到一个MAC碰撞，但可能找不到内部状态的碰撞，因为找到这样的碰撞需要进行2^(512/2)
    = 2^(256)次操作。
- en: 'Creating Keyed Hashes from Block Ciphers: CMAC'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从块密码创建带密钥的哈希：CMAC
- en: Recall from [Chapter 6](ch06.xhtml#ch6) that the compression functions in many
    hash functions are built on block ciphers. For example, HMAC-SHA-256 PRF is a
    series of calls to SHA-256’s compression function, which itself is a block cipher
    that repeats a sequence of rounds. In other words, HMAC-SHA-256 is a block cipher
    inside a compression function inside a hash inside the HMAC construction. So why
    not use a block cipher directly rather than build such a layered construction?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[第6章](ch06.xhtml#ch6)，许多哈希函数中的压缩函数是基于块密码构建的。例如，HMAC-SHA-256 PRF是对SHA-256的压缩函数的多次调用，而SHA-256本身就是一个块密码，重复进行一系列的轮次。换句话说，HMAC-SHA-256是在哈希内部的压缩函数中的块密码，位于HMAC构造之中。那么，为什么不直接使用块密码，而是要构建这样的分层构造呢？
- en: '*CMAC* (which stands for *cipher-based MAC*) is such a construction: it creates
    a MAC given only a block cipher, such as AES. Though less popular than HMAC, CMAC
    is deployed in many systems, including the Internet Key Exchange (IKE) protocol,
    which is part of the IPSec suite. IKE, for example, generates key material using
    a construction called AES-CMAC-PRF-128 as a core algorithm (or CMAC based on AES
    with 128-bit output). CMAC is specified in RFC 4493.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*CMAC*（即*基于密码的消息认证码*）是一种构造方法：它仅使用块密码（如AES）来创建消息认证码（MAC）。尽管CMAC不如HMAC流行，但它已经在许多系统中得到部署，包括Internet密钥交换（IKE）协议，这是IPSec套件的一部分。例如，IKE使用名为AES-CMAC-PRF-128的构造来生成密钥材料，作为核心算法（或者基于AES的128位输出的CMAC）。CMAC在RFC
    4493中有详细规定。'
- en: '*Breaking CBC-MAC*'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*破解CBC-MAC*'
- en: CMAC was designed in 2005 as an improved version of *CBC-MAC*, a simpler block
    cipher–based MAC derived from the cipher block chaining (CBC) block cipher mode
    of operation (see [“Modes of Operation”](ch04.xhtml#lev1sec31) on page 65).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: CMAC是在2005年作为*CBC-MAC*的改进版设计的，CBC-MAC是一种基于块密码的简单消息认证码，源自密码块链接（CBC）块密码的操作模式（见[“操作模式”](ch04.xhtml#lev1sec31)第65页）。
- en: 'CBC-MAC, the ancestor of CMAC, is simple: to compute the tag of a message,
    *M*, given a block cipher, **E**, you encrypt *M* in CBC mode with an all-zero
    initial value (IV) and discard all but the last ciphertext block. That is, you
    compute *C*[1] = **E**(*K*, *M*[1]), *C*[2] = **E**(*K*, *M*[2] ⊕ *C*[1]), *C*[3]
    = **E**(*K*, *M*[3] ⊕ *C*[2]), and so on for each of *M*’s blocks and keep only
    the last *C*[*i*], your CBC-MAC tag for *M*—simple, and simple to attack.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: CBC-MAC，CMAC 的前身，简单：要计算一个消息 *M* 的标签，给定一个块密码 **E**，你可以使用全零的初始值（IV）在 CBC 模式下加密
    *M*，并丢弃除最后一个密文块以外的所有块。也就是说，你计算 *C*[1] = **E**(*K*, *M*[1])，*C*[2] = **E**(*K*,
    *M*[2] ⊕ *C*[1])，*C*[3] = **E**(*K*, *M*[3] ⊕ *C*[2])，以此类推，对每个 *M* 的块进行计算，并只保留最后一个
    *C*[*i*]，即你为 *M* 计算的 CBC-MAC 标签——简单，并且容易被攻击。
- en: To understand why CBC-MAC is insecure, consider the CBC-MAC tag, *T*[1] = **E**(*K*,
    *M*[1]), of a single-block message, *M*[1], and the tag, *T*[2] = **E**(*K*, *M*[2]),
    of another single-block message, *M*[2]. Given these two pairs, (*M*[1], *T*[1])
    and (*M*[2], *T*[2]), you can deduce that *T*[2] is also the tag of the two-block
    message *M*[1] || (*M*[2] ⊕ *T*[1]). Indeed, if you apply CBC-MAC to *M*[1] ||
    (*M*[2] ⊕ *T*[1]) and compute *C*[1] = **E**(*K*, *M*[1]) = *T*[1] followed by
    *C*[2] = **E**(*K*, (*M*[2] ⊕ *T*[1]) ⊕ *T*[1]) = **E**(*K*, *M*[2]) = *T*[2],
    you can create a third message/tag pair from two message/tag pairs without knowing
    the key. That is, you can forge CBC-MAC tags, thereby breaking CBC-MAC’s security.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么 CBC-MAC 不安全，考虑单块消息 *M*[1] 的 CBC-MAC 标签 *T*[1] = **E**(*K*, *M*[1]) 和另一单块消息
    *M*[2] 的标签 *T*[2] = **E**(*K*, *M*[2])。给定这两个对（*M*[1], *T*[1]）和（*M*[2], *T*[2]），你可以推断出
    *T*[2] 也是由两块消息 *M*[1] || (*M*[2] ⊕ *T*[1]) 组成的消息的标签。实际上，如果你对 *M*[1] || (*M*[2]
    ⊕ *T*[1]) 应用 CBC-MAC 并计算 *C*[1] = **E**(*K*, *M*[1]) = *T*[1]，然后计算 *C*[2] = **E**(*K*,
    (*M*[2] ⊕ *T*[1]) ⊕ *T*[1]) = **E**(*K*, *M*[2]) = *T*[2]，你就可以在不知道密钥的情况下通过两个消息/标签对创建一个第三个消息/标签对。也就是说，你可以伪造
    CBC-MAC 标签，从而破坏 CBC-MAC 的安全性。
- en: '*Fixing CBC-MAC*'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*修复 CBC-MAC*'
- en: CMAC fixes CBC-MAC by processing the last block using a different key from the
    preceding blocks. To do this, CMAC first derives two keys, *K*[1] and *K*[2],
    from the main key, *K*, such that *K*, *K*[1], and *K*[2] will be distinct. In
    CMAC, the last block is processed using either *K*[1] or *K*[2], while the preceding
    blocks use *K*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CMAC 通过使用与前面的块不同的密钥处理最后一个块，从而修复了 CBC-MAC。为此，CMAC 首先从主密钥 *K* 中派生出两个密钥 *K*[1]
    和 *K*[2]，使得 *K*、*K*[1] 和 *K*[2] 互不相同。在 CMAC 中，最后一个块使用 *K*[1] 或 *K*[2] 处理，而前面的块则使用
    *K*。
- en: To determine *K*[1] and *K*[2], CMAC first computes a temporary value, *L* =
    **E**(0, *K*), where 0 acts as the key of the block cipher and *K* acts as the
    plaintext block. Then CMAC sets the value of *K*[1] equal to (*L* << 1) if *L*’s
    most significant bit (MSB) is 0, or equal to (*L* << 1) ⊕ 87 if *L*’s MSB is 1\.
    (The number 87 is carefully chosen for its mathematical properties when data blocks
    are 128 bits; a value other than 87 is needed when blocks aren’t 128 bits.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定 *K*[1] 和 *K*[2]，CMAC 首先计算一个临时值，*L* = **E**(0, *K*)，其中 0 作为块密码的密钥，*K* 作为明文块。然后，CMAC
    设置 *K*[1] 的值为 (*L* << 1)，如果 *L* 的最高有效位（MSB）为 0；或者设置为 (*L* << 1) ⊕ 87，如果 *L* 的
    MSB 为 1。（数字 87 是根据其数学性质精心选择的，当数据块为 128 位时是合适的；如果块不是 128 位，则需要选择其他值。）
- en: The value of *K*[2] is set equal to (*K*[1] << 1) if *K*[1]’s MSB is 0, or *K*[2]
    = (*K*[1] << 1) ⊕ 87 otherwise.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*K*[2] 的值设置为 (*K*[1] << 1)，如果 *K*[1] 的 MSB 为 0；否则，*K*[2] = (*K*[1] << 1) ⊕
    87。'
- en: Given *K*[1] and *K*[2], CMAC works like CBC-MAC, except for the last block.
    If the final message chunk *M*[*n*] is exactly the size of a block, CMAC returns
    the value **E**(*K*, *M*[*N*] ⊕ *C*[*n*] [− 1] ⊕ *K*[1]) as a tag, as shown in
    [Figure 7-3](ch07.xhtml#ch7fig3). But if *M*[*N*] has fewer bits than a block,
    CMAC pads it with a 1 bit and zeros, and returns the value **E**(*K*, *M*[*n*]
    ⊕ *C*[*n* − 1] ⊕ *K*[2]) as a tag, as shown in [Figure 7-4](ch07.xhtml#ch7fig4).
    Notice that the first case uses only *K*[1] and the second only *K*[2], but both
    use only the main key *K* to process the message chunks that precede the final
    one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 *K*[1] 和 *K*[2]，CMAC 的工作方式类似于 CBC-MAC，除了最后一个块。如果最终消息块 *M*[*n*] 恰好是一个块的大小，CMAC
    返回值 **E**(*K*, *M*[*N*] ⊕ *C*[*n*] [− 1] ⊕ *K*[1]) 作为标签，如 [图 7-3](ch07.xhtml#ch7fig3)
    所示。但如果 *M*[*N*] 的位数少于一个块，CMAC 会用 1 位和零进行填充，并返回值 **E**(*K*, *M*[*n*] ⊕ *C*[*n*
    − 1] ⊕ *K*[2]) 作为标签，如 [图 7-4](ch07.xhtml#ch7fig4) 所示。请注意，第一个情况仅使用 *K*[1]，第二个情况仅使用
    *K*[2]，但两者都只使用主密钥 *K* 来处理前面的消息块。
- en: '![image](../images/f07-03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f07-03.jpg)'
- en: '*Figure 7-3: The CMAC block cipher–based MAC construction when the message
    is a sequence of integral blocks*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：当消息是整数块序列时，基于 CMAC 块密码的 MAC 构造*'
- en: '![image](../images/f07-04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f07-04.jpg)'
- en: '*Figure 7-4: The CMAC block cipher–based MAC construction when the last block
    of the message has to be padded with a 1 bit and zeros to fill a block*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-4：当消息的最后一个块需要填充1位和零以填满一个块时，基于CMAC分组密码的MAC构造*'
- en: 'Note that unlike the CBC encryption mode, CMAC does not take an IV as a parameter
    and is deterministic: CMAC will always return the same tag for a given message,
    *M*, because the computation of **CMAC**(*M*) is not randomized—and that’s fine,
    because unlike encryption, MAC computation doesn’t have to be randomized to be
    secure, which eliminates the burden of having to choose random IV.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与CBC加密模式不同，CMAC不需要将IV作为参数，并且是确定性的：CMAC对于给定的消息*M*始终返回相同的标签，因为**CMAC**(*M*)的计算是非随机的——这是可以接受的，因为与加密不同，MAC计算不需要随机化才能保证安全，这也消除了选择随机IV的负担。
- en: Dedicated MAC Designs
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 专用MAC设计
- en: You’ve seen how to recycle hash functions and block ciphers to build PRFs that
    are secure as long as their underlying hash or cipher is secure. Schemes such
    as HMAC and CMAC simply combine available hash functions or block ciphers to yield
    a secure PRF or MAC. Reusing available algorithms is convenient, but is it the
    most efficient approach?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到如何通过回收哈希函数和分组密码来构建安全的伪随机函数（PRF），只要它们底层的哈希函数或密码是安全的。像HMAC和CMAC这样的方案仅仅是将现有的哈希函数或分组密码组合在一起，以得到一个安全的PRF或MAC。重复使用现有的算法是方便的，但这是否是最有效的方式？
- en: Intuitively, PRFs and MACs should require less work than unkeyed hash functions
    in order to be secure—their use of a secret key prevents attackers from playing
    with the algorithm because they don’t have the key. Also, PRFs and MACs only expose
    a short tag to attackers, unlike block ciphers, which expose a ciphertext that
    is as long as the message. Hence, PRFs and MACs should not need the whole power
    of hash functions or block ciphers, which is the point of *dedicated design*—that
    is, algorithms created solely to serve as PRFs and/or MACs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地看，PRF和MAC的安全性应当比无密钥的哈希函数所需的工作量少——它们使用一个秘密密钥，防止攻击者篡改算法，因为他们没有密钥。而且，PRF和MAC只向攻击者暴露一个短标签，不像分组密码那样暴露与消息一样长的密文。因此，PRF和MAC不需要哈希函数或分组密码的全部计算能力，这正是*专用设计*的意义——即，专门为了作为PRF和/或MAC而设计的算法。
- en: 'The sections that follow focus on two such algorithms that are widely used:
    Poly1305 and SipHash. I’ll explain their design principles and why they are likely
    secure.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将集中讨论两种广泛使用的算法：Poly1305和SipHash。我将解释它们的设计原则以及为什么它们可能是安全的。
- en: '*Poly1305*'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Poly1305*'
- en: The Poly1305 algorithm (pronounced *poly*-*thirteen*-*o-five*) was designed
    in 2005 by Daniel J. Bernstein (creator of the Salsa20 stream cipher discussed
    in [Chapter 5](ch05.xhtml#ch5) and the ChaCha cipher that inspired the BLAKE and
    BLAKE2 hash functions discussed in [Chapter 6](ch06.xhtml#ch6)). Poly1305 is optimized
    to be super fast on modern CPUs, and as I write this, it is used by Google to
    secure HTTPS (HTTP over TLS) connections and by OpenSSH, among many other applications.
    Unlike Salsa20, the design of Poly1305 is built on techniques dating back to the
    1970s—namely, universal hash functions and the Wegman–Carter construction.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Poly1305算法（发音为*poly*-*thirteen*-*o-five*）由丹尼尔·J·伯恩斯坦（Daniel J. Bernstein）于2005年设计（他是[第5章](ch05.xhtml#ch5)中讨论的Salsa20流密码的创造者，也是启发了[第6章](ch06.xhtml#ch6)中讨论的BLAKE和BLAKE2哈希函数的ChaCha密码的发明者）。Poly1305经过优化，能够在现代CPU上运行得非常快速，而在我写这篇文章时，它已经被Google用来保护HTTPS（基于TLS的HTTP）连接，并且被OpenSSH等许多应用程序所使用。与Salsa20不同，Poly1305的设计基于20世纪70年代的技术——即，通用哈希函数和Wegman-Carter构造。
- en: Universal Hash Functions
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通用哈希函数
- en: The Poly1305 MAC uses a *universal hash function* internally that is much weaker
    than a cryptographic hash function, but also much faster. Universal hash functions
    don’t have to be collision resistant, for example. That means less work is required
    to achieve their security goals.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Poly1305 MAC在内部使用*通用哈希函数*，其强度远低于加密哈希函数，但也要快得多。通用哈希函数不必具备抗碰撞性，例如，这意味着为了实现其安全目标，需要做的工作较少。
- en: 'Like a PRF, a universal hash is parameterized by a secret key: given a message,
    *M*, and key, *K*, we write **UH**(*K*, *M*), which is the computation of the
    output of a universal hash function, denoted **UH**. A universal hash function
    has only one security requirement: for any two messages, *M*[1] and *M*[2], the
    probability that **UH**(*K*, *M*[1]) = **UH**(*K*, *M*[2]) must be negligible
    for a random key, *K*. Unlike a PRF, a universal hash doesn’t need to be pseudorandom;
    there simply should be no pair (*M*[1], *M*[2]) that gives the same hash for many
    different keys. Because their security requirements are easier to satisfy, fewer
    operations are required and therefore universal hash functions are considerably
    faster than PRFs.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于伪随机函数（PRF），通用哈希由一个秘密密钥参数化：给定一条消息 *M* 和密钥 *K*，我们写作**UH**(*K*, *M*)，这是通用哈希函数的输出计算，记作**UH**。通用哈希函数只有一个安全性要求：对于任意两条消息
    *M*[1] 和 *M*[2]，**UH**(*K*, *M*[1]) = **UH**(*K*, *M*[2]) 的概率对于一个随机密钥 *K* 必须是微不足道的。与伪随机函数（PRF）不同，通用哈希不需要是伪随机的；它只是要求不存在一对(*M*[1]，*M*[2])能为许多不同的密钥计算出相同的哈希。由于它们的安全性要求更容易满足，因此所需的操作较少，因此通用哈希函数比伪随机函数（PRF）快得多。
- en: 'You can use a universal hash as a MAC to authenticate no more than one message,
    however. For example, consider the universal hash used in Poly1305, called a *polynomial-evaluation*
    hash. (See the seminal 1974 article “Codes Which Detect Deception” by Gilbert,
    MacWilliams, and Sloane for more on this notion.) This kind of polynomial-evaluation
    hash is parameterized by a prime number, *p*, and takes as input a key consisting
    of two numbers, *R* and *K*, in the range [1, *p*] and a message, *M*, consisting
    of *n* blocks (*M*[1], *M*[2], … , *M*[*n*]). The output of the universal hash
    is then computed as the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用通用哈希作为MAC来验证至多一条消息。例如，考虑在Poly1305中使用的通用哈希，它被称为*多项式评估*哈希。（有关这种概念的更多信息，请参见Gilbert、MacWilliams和Sloane在1974年发表的开创性文章《检测欺骗的编码》。）这种多项式评估哈希由一个质数*p*参数化，并以一个由两个数字
    *R* 和 *K* 组成的密钥作为输入，范围在[1, *p*]之间，以及一条由*n*个块组成的消息 *M*（*M*[1]，*M*[2]，…，*M*[*n*]）。然后，通用哈希的输出计算如下：
- en: '**UH**(*R*, *K*, *M*) = *R* + *M*[1]*K* + *M*[3]*K*² + *M*[3]*K*³ + … + *M[n]K^n*
    mod *p*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**UH**(*R*, *K*, *M*) = *R* + *M*[1]*K* + *M*[3]*K*² + *M*[3]*K*³ + … + *M[n]K^n*
    mod *p*'
- en: The plus sign (+) denotes the addition of positive integers, *K*^(*i*) is the
    number *K* raised to the power *i*, and “mod *p*” denotes the reduction modulo
    *p* of the result (that is, the remainder of the division of the result by *p*;
    for example, 12 mod 10 = 2, 10 mod 10 = 0, 8 mod 10 = 8, and so on).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 加号（+）表示正整数的加法，*K*^(*i*)是数字*K*的*i*次方，而“mod *p*”表示结果的模*p*运算（即结果除以*p*的余数；例如，12
    mod 10 = 2，10 mod 10 = 0，8 mod 10 = 8，等等）。
- en: Because we want the hash to be as fast as possible, universal hash-based MACs
    often work with message blocks of 128 bits and with a prime number, *p*, that
    is slightly larger than 2^(128), such as 2^(128) + 51\. The 128-bit width allows
    for very fast implementations by efficiently using the 32- and 64-bit arithmetic
    units of common CPUs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望哈希尽可能快，基于通用哈希的MAC通常使用128位的消息块，并且使用稍大于2^(128)的质数 *p*，例如2^(128) + 51。128位宽度通过有效利用常见CPU的32位和64位算术单元，能够实现非常快速的运算。
- en: Potential Vulnerabilities
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 潜在的漏洞
- en: 'Universal hashes have one weakness: because a universal hash is only able to
    securely authenticate one message, an attacker could break the preceding polynomial-evaluation
    MAC by requesting the tags of only two messages. Specifically, they could request
    the tags for a message where *M*[1] = *M*[2] = … = 0 (that is, whose tag is **UH**(*R*,
    *K*, 0) = *R*) and then use the tags to find the secret value *R*. Alternatively,
    they could request the tags for a message where *M*[1] = 1 and where *M*[2] =
    *M*[3] = … = 0 (that is, whose tag is *T* = *R* + *K*), which would allow them
    to find *K* by subtracting *R* from *T*. Now the attacker knows the whole key
    (*R*, *K*) and they can forge MACs for any message.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通用哈希有一个弱点：因为通用哈希只能安全地验证一条消息，攻击者可以通过请求仅两条消息的标签来破坏前面的多项式评估MAC。具体来说，他们可以请求一条消息的标签，其中
    *M*[1] = *M*[2] = … = 0（即，其标签为**UH**(*R*, *K*, 0) = *R*），然后利用这些标签找出秘密值 *R*。或者，他们可以请求一条消息的标签，其中
    *M*[1] = 1 且 *M*[2] = *M*[3] = … = 0（即，其标签为*T* = *R* + *K*），这将使他们能够通过从*T*中减去 *R*
    来找出 *K*。现在攻击者知道了整个密钥（*R*，*K*），他们可以伪造任何消息的MAC。
- en: Fortunately, there’s a way to go from single-message security to multi-message
    security.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种方法可以将单消息安全性扩展到多消息安全性。
- en: Wegman–Carter MACs
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Wegman-Carter MACs
- en: The trick to authenticating multiple messages using a universal hash function
    arrived thanks to IBM researchers Wegman and Carter and their 1981 paper “New
    Hash Functions and Their Use in Authentication and Set Equality.” The so-called
    Wegman–Carter construction builds a MAC from a universal hash function and a PRF,
    using two keys, *K*[1] and *K*[2], and it returns
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 利用通用哈希函数进行多条消息认证的诀窍来源于 IBM 研究员 Wegman 和 Carter 以及他们 1981 年发表的论文《新哈希函数及其在认证和集合等值中的应用》。所谓的
    Wegman–Carter 构造通过使用两个密钥 *K*[1] 和 *K*[2]，并结合一个通用哈希函数和一个 PRF，构建一个 MAC，返回结果如下：
- en: '**MAC**(*K*[1], *K*[2], *N*, *M*) = **UH**(*K*[1], *M*) + **PRF**(*K*[2], *N*)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**MAC**(*K*[1], *K*[2], *N*, *M*) = **UH**(*K*[1], *M*) + **PRF**(*K*[2], *N*)'
- en: where *N* is a nonce that should be unique for each key, *K*[2], and where **PRF**’s
    output is as large as that of the universal hash function **UH**. By adding these
    two values, **PRF**’s strong pseudorandom output masks the cryptographic weakness
    of **UH**. You can see this as the encryption of the universal hash’s result,
    where the PRF acts as a stream cipher and prevents the preceding attack by making
    it possible to authenticate multiple messages with the same key, *K*[1].
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *N* 是一个唯一数，应对每个密钥 *K*[2] 唯一，并且 **PRF** 的输出与通用哈希函数 **UH** 的输出一样大。通过将这两个值相加，**PRF**
    的强伪随机输出掩盖了 **UH** 的密码学弱点。你可以将其视为对通用哈希结果的加密，其中 PRF 充当流密码，防止了之前的攻击，使得使用相同的密钥 *K*[1]
    对多条消息进行认证成为可能。
- en: 'To recap, the Wegman–Carter construction **UH**(*K*[1], *M*) + **PRF**(*K*[2],
    *N*) gives a secure MAC if we assume the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，Wegman–Carter 构造 **UH**(*K*[1], *M*) + **PRF**(*K*[2], *N*) 提供一个安全的 MAC，前提是我们假设以下条件：
- en: '**UH** is a secure universal hash.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UH** 是一个安全的通用哈希函数。'
- en: '**PRF** is a secure PRF.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PRF** 是一个安全的 PRF。'
- en: Each nonce *N* is used only once for each key *K*[2].
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个唯一数 *N* 只在每个密钥 *K*[2] 中使用一次。
- en: The output values of **UH** and **PRF** are long enough to ensure high enough
    security.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UH** 和 **PRF** 的输出值足够长，确保提供足够的安全性。'
- en: Now let’s see how Poly1305 leverages the Wegman–Carter construction to build
    a secure and fast MAC.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 Poly1305 如何利用 Wegman–Carter 构造来构建一个安全且快速的 MAC。
- en: Poly1305-AES
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Poly1305-AES
- en: Poly1305 was initially proposed as Poly1305-AES, combining the Poly1305 universal
    hash with the AES block cipher. Poly1305-AES is much faster than HMAC-based MACs,
    or even than CMACs, since it only computes one block of AES and processes the
    message in parallel through a series of simple arithmetic operations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Poly1305 最初被提出为 Poly1305-AES，将 Poly1305 通用哈希与 AES 块密码结合在一起。Poly1305-AES 比基于
    HMAC 的 MAC 或者 CMAC 更加快速，因为它仅计算一个 AES 块，并通过一系列简单的算术运算并行处理消息。
- en: 'Given a 128-bit *K*[1], *K*[2], and *N*, and message, *M*, Poly1305-AES returns
    the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 128 位的 *K*[1]、*K*[2] 和 *N*，以及消息 *M*，Poly1305-AES 返回以下内容：
- en: '**Poly 1305**(*K*[1], *M*) + **AES**(*K*[2], *N*) mod 2^(128)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**Poly 1305**(*K*[1], *M*) + **AES**(*K*[2], *N*) mod 2^(128)'
- en: 'The mod 2^(128) reduction ensures that the result fits in 128 bits. The message
    *M* is parsed as a sequence of 128-bit blocks (*M*[1], *M*[2], … , *M*[*n*]),
    and a 129th bit is appended to each block’s most significant bit to make all blocks
    129 bits long. (If the last block is smaller than 16 bytes, it’s padded with a
    1 bit followed by 0 bits before the final 129th bit.) Next, Poly1305 evaluates
    the polynomial to compute the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 2^(128) 的模减法确保结果适合 128 位。消息 *M* 被解析为一系列 128 位的块 (*M*[1]，*M*[2]，…，*M*[*n*])，并且在每个块的最高有效位添加了第
    129 位，使所有块的长度为 129 位。（如果最后一个块小于 16 字节，则在最终的第 129 位之前会用一个 1 位和若干个 0 位进行填充。）接下来，Poly1305
    评估多项式来计算以下内容：
- en: '**Poly 1305**(*K*[1], *M*) = *M*[1]*K*[1]^(*i*) + *M*[2]*K*[1]^(*n* − 1) +
    … +*M[n]K*[1] mod 2^(130) − 5'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**Poly 1305**(*K*[1], *M*) = *M*[1]*K*[1]^(*i*) + *M*[2]*K*[1]^(*n* − 1) +
    … +*M[n]K*[1] mod 2^(130) − 5'
- en: The result of this expression is an integer that is at most 129-bits long. When
    added to the 128-bit value **AES**(*K*[2], *N*), the result is reduced modulo
    2^(128) to produce a 128-bit MAC.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式的结果是一个最大长度为 129 位的整数。当与 128 位的 **AES**(*K*[2], *N*) 值相加时，结果会通过模 2^(128)
    操作来减少，从而生成一个 128 位的 MAC。
- en: '**NOTE**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*AES isn’t a PRF; instead, it’s a pseudorandom permutation (PRP). However,
    that doesn’t matter much here because the Wegman–Carter construction works with
    a PRP as well as with a PRF. This is because if you’re given a function that is
    either a PRF of a PRP, it’s hard to determine whether it’s a PRF of a PRP just
    by looking at the function’s output values.*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*AES 并不是一个 PRF；它是一个伪随机置换（PRP）。然而，这里并不重要，因为 Wegman–Carter 构造既适用于 PRP 也适用于 PRF。因为如果你给定一个函数，无论它是
    PRF 还是 PRP，仅凭观察函数的输出值是难以确定它是 PRF 还是 PRP。*'
- en: The security analysis of Poly1305-AES (see “The Poly1305-AES Message-Authentication
    Code” at *[http://cr.yp.to/mac/poly1305-20050329.pdf](http://cr.yp.to/mac/poly1305-20050329.pdf)*)
    shows that Poly1305-AES is 128-bit secure as long as AES is a secure block cipher—and,
    of course, as long as everything is implemented correctly, as with any cryptographic
    algorithm.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Poly1305-AES的安全性分析（参见* [http://cr.yp.to/mac/poly1305-20050329.pdf](http://cr.yp.to/mac/poly1305-20050329.pdf)
    *中的“Poly1305-AES消息认证码”）表明，只要AES是一个安全的分组密码，并且所有内容都被正确实现，Poly1305-AES是128位安全的——这与任何密码学算法一样。
- en: The Poly1305 universal hash can be combined with algorithms other than AES.
    For example, Poly1305 was used with the stream cipher ChaCha (see RFC 7539, “ChaCha20
    and Poly1305 for IETF Protocols”). There’s no doubt that Poly1305 will keep being
    used wherever a fast MAC is needed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Poly1305通用哈希可以与AES以外的其他算法结合使用。例如，Poly1305曾与流密码ChaCha一起使用（请参见RFC 7539，“ChaCha20和Poly1305用于IETF协议”）。毫无疑问，Poly1305将在需要快速MAC的地方继续使用。
- en: '*SipHash*'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*SipHash*'
- en: Although Poly1305 is fast and secure, it has several downsides. For one, its
    polynomial evaluation is difficult to implement efficiently, especially in the
    hands of many who are unfamiliar with the associated mathematical notions. (See
    examples at *[https://github.com/floodyberry/poly1305-donna/](https://github.com/floodyberry/poly1305-donna/)*).
    Second, on its own, it’s secure for only one message unless you use the Wegman–Carter
    construction. But in that case, it requires a nonce, and if the nonce is repeated,
    the algorithm becomes insecure. Finally, Poly1305 is optimized for long messages,
    but it’s overkill if you process only small messages (say, fewer than 128 bytes).
    In such cases, SipHash is the solution.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Poly1305快速且安全，但它也有几个缺点。首先，它的多项式计算实现效率较低，尤其是对许多不熟悉相关数学概念的人来说，难以高效实现。（可以查看*
    [https://github.com/floodyberry/poly1305-donna/](https://github.com/floodyberry/poly1305-donna/)*上的示例）。其次，仅靠它本身，它只能保证一个消息的安全，除非使用Wegman–Carter构造法。但在这种情况下，它需要一个nonce，如果nonce重复，算法就变得不安全。最后，Poly1305优化了长消息的处理，但如果只处理小消息（例如少于128字节），就显得过于复杂。在这种情况下，SipHash就是解决方案。
- en: 'I designed SipHash in 2012 with Dan Bernstein initially to address a noncryptographic
    problem: denial-of-service attacks on hash tables. Hash tables are data structures
    used to efficiently store elements in programming languages. Prior to the advent
    of SipHash, hash tables relied on noncryptographic keyed hash functions for which
    collisions were easy to find, and it was easy to exploit a remote system using
    a hash table by slowing it down with a denial-of-service attack. We determined
    that a PRF would address this problem and thus set out to design SipHash, a PRF
    suitable for hash tables. Because hash tables process mostly short inputs, SipHash
    is optimized for short messages. However, SipHash can be used for more than hash
    tables: it’s a full-blown PRF and MAC that shines where most inputs are short.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我在2012年与Dan Bernstein共同设计了SipHash，最初是为了解决一个非密码学问题：哈希表的拒绝服务攻击。哈希表是用于在编程语言中高效存储元素的数据结构。在SipHash出现之前，哈希表依赖于非密码学的带密钥哈希函数，而这些函数很容易产生碰撞，攻击者可以通过拒绝服务攻击轻松地使远程系统变慢。我们认为伪随机函数（PRF）可以解决这个问题，因此我们着手设计了SipHash，一个适用于哈希表的PRF。由于哈希表主要处理短输入，SipHash针对短消息进行了优化。然而，SipHash不仅仅可以用于哈希表：它是一个完整的PRF和MAC，特别适合处理大多数短输入的情况。
- en: How SipHash Works
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: SipHash的工作原理
- en: 'SipHash uses a trick that makes it more secure than basic sponge functions:
    instead of XORing message blocks only once before the permutation, SipHash XORs
    them before and after the permutation, as shown in [Figure 7-5](ch07.xhtml#ch7fig5).
    The 128-bit key of SipHash is seen as two 64-bit words, *K*[1] and *K*[2], XORed
    to a 256-bit fixed initial state that is seen as four 64-bit words. Next, the
    keys are discarded, and computing SipHash boils down to iterating through a core
    function called SipRound and then XORing message chunks to modify the four-word
    internal state. Finally, SipHash returns a 64-bit tag by XORing the four-state
    words together.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: SipHash使用了一种技巧，使其比基本的海绵函数更安全：它不是仅在置换前对消息块进行一次XOR操作，而是将它们在置换前后都进行XOR操作，如[图7-5](ch07.xhtml#ch7fig5)所示。SipHash的128位密钥被视为两个64位字，*K*[1]和*K*[2]，它们通过XOR运算生成一个256位的固定初始状态，该状态被视为四个64位字。接下来，密钥被丢弃，计算SipHash的过程简化为通过一个核心函数SipRound进行迭代，然后将消息块进行XOR操作，以修改四字内部状态。最后，SipHash通过将四个状态字进行XOR运算，返回一个64位的标签。
- en: '![image](../images/f07-05.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f07-05.jpg)'
- en: '*Figure 7-5: SipHash-2-4 processing a 15-byte message (a block,* M[1], of 8
    bytes and a block, M[2], of 7 bytes, plus 1 byte of padding)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：SipHash-2-4 处理一个 15 字节的消息（一个 8 字节的块 M[1] 和一个 7 字节的块 M[2]，再加上 1 字节的填充）*'
- en: 'The SipRound function uses a bunch of XORs together with additions and word
    rotations to make the function secure. SipRound transforms a state of four 64-bit
    words (*a*, *b*, *c*, *d*) by performing the following operations, top to bottom.
    The operations on the left and right are independent and can be carried out in
    parallel:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: SipRound 函数通过一系列 XOR 操作、加法和字旋转来确保函数的安全性。SipRound 通过执行以下操作来转换四个 64 位字的状态（*a*，*b*，*c*，*d*），从上到下。左右两边的操作是独立的，可以并行执行：
- en: '![image](../images/f0140-01.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0140-01.jpg)'
- en: Here, *a* += *b* is shorthand for *a* = *a* + *b*, and *b* <<< = 13 is shorthand
    for *b* = *b* <<< 13 (the 64-bit word *b* left-rotated 13 bits.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*a* += *b* 是 *a* = *a* + *b* 的简写，而 *b* <<< = 13 是 *b* = *b* <<< 13 的简写（64
    位字 *b* 左旋 13 位）。
- en: These simple operations on 64-bit words are almost all you need to implement
    in order to compute SipHash—although you won’t have to implement it yourself.
    You can find readily available implementations in most languages, including C,
    Go, Java, JavaScript, and Python.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对 64 位字的简单操作几乎是你计算 SipHash 所需实现的全部内容——尽管你不必自己实现它。你可以在大多数编程语言中找到现成的实现，包括 C、Go、Java、JavaScript
    和 Python。
- en: '**NOTE**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We write* **SipHash**-x-y *as the SipHash version, meaning it makes* x *SipRounds
    between each message block injection and then* y *rounds. More rounds require
    more operations, which slows down operations but also increases security. The
    default version is SipHash-2-4 (simply noted as SipHash), and it has so far resisted
    cryptanalysis. However, you may want to be conservative and opt for SipHash-4-8
    instead, which makes twice as many rounds and is therefore twice as slow.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将* **SipHash**-x-y *写作 SipHash 版本，表示它在每次消息块注入之间进行* x *轮 SipRounds，然后是* y
    *轮。更多的轮数意味着更多的操作，这会减慢操作速度，但也会增加安全性。默认版本是 SipHash-2-4（简写为 SipHash），目前它已经抵抗了密码分析。然而，你可能希望保守一些，选择
    SipHash-4-8，这样会进行两倍的轮数，因此速度也会变慢两倍。*'
- en: How Things Can Go Wrong
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误发生的方式
- en: Like ciphers and unkeyed hash functions, MACs and PRFs that are secure on paper
    can be vulnerable to attacks when used in a real setting, against realistic attackers.
    Let’s see two examples.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 像密码算法和无密钥哈希函数一样，纸面上安全的 MAC 和 PRF 在真实环境中面对现实攻击者时，也可能会受到攻击。我们来看两个例子。
- en: '*Timing Attacks on MAC Verification*'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*MAC 验证中的时间攻击*'
- en: '*Side-channel attacks* target the implementation of a cryptographic algorithm
    rather than the algorithm itself. In particular, *timing attacks* use an algorithm’s
    execution time to determine secret information, such as keys, plaintext, and secret
    random values. As you might imagine, variable-time string comparison induces vulnerabilities
    not only in MAC verification, but also in many other cryptographic and security
    functionalities.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*侧信道攻击* 针对的是加密算法的实现，而非算法本身。特别地，*时间攻击* 利用算法的执行时间来确定秘密信息，如密钥、明文和随机数值。正如你可能想象的那样，变量时间的字符串比较不仅会在
    MAC 验证中引入漏洞，还会在许多其他加密和安全功能中产生问题。'
- en: 'MACs can be vulnerable to timing attacks when a remote system verifies tags
    in a period of time that depends on the tag’s value, thereby allowing an attacker
    to determine the correct message tag by trying many incorrect ones to determine
    the one that takes the longest amount of time to complete. The problem occurs
    when a server compares the correct tag with an incorrect one by comparing the
    two strings byte per byte, in order, until the bytes differ. For example, the
    Python code in [Listing 7-1](ch07.xhtml#ch7list1) compares two strings byte per
    byte, in variable time: if the first bytes differ, the function will return after
    only one comparison; if the strings `x` and `y` are identical, the function will
    make `n` comparisons against the length of the strings.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当远程系统在验证标签时，其所用时间依赖于标签的值，从而使得 MAC 在面对时间攻击时可能会受到威胁，这允许攻击者通过尝试多个错误标签，找出执行时间最长的正确标签。问题发生在服务器通过逐字节比较正确标签和错误标签，直到两者的字节不同。例如，[列表
    7-1](ch07.xhtml#ch7list1) 中的 Python 代码逐字节比较两个字符串，且所用时间是可变的：如果第一个字节不同，函数将在一次比较后返回；如果字符串
    `x` 和 `y` 相同，函数将根据字符串的长度进行 `n` 次比较。
- en: '[PRE0]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 7-1: Comparison of two* n-*byte strings, taking variable time*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-1：比较两个* n-*字节字符串，所用时间可变*'
- en: To demonstrate the vulnerability of the `verify_mac()` function, let’s write
    a program that measures the execution time of 100000 calls to `verify_mac()`,
    first with identical 10-byte `x` and `y` values and then with `x` and `y` values
    that differ in their third byte. We should expect the latter comparison to take
    noticeably less time than the former because `verify_mac()` will compare fewer
    bytes than the identical `x` and `y` would, as shown in [Listing 7-2](ch07.xhtml#ch7list2).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 `verify_mac()` 函数的漏洞，让我们编写一个程序，测量 100000 次调用 `verify_mac()` 的执行时间，首先使用相同的
    10 字节 `x` 和 `y` 值，然后使用 `x` 和 `y` 在第三个字节上有所不同的值。我们应该预期，后者的比较时间会明显比前者短，因为 `verify_mac()`
    将比较更少的字节，而不像相同的 `x` 和 `y` 那样，正如在 [清单 7-2](ch07.xhtml#ch7list2) 中所示。
- en: '[PRE1]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 7-2: Measuring timing differences when executing compare_mac() from
    [Listing 7-1](ch07.xhtml#ch7list1)*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-2：在执行 compare_mac() 时测量时间差异，参见 [清单 7-1](ch07.xhtml#ch7list1)*'
- en: In my test environment, typical execution of the program in [Listing 7-2](ch07.xhtml#ch7list2)
    prints execution times of around 0.215 and 0.095 seconds, respectively. That difference
    is significant enough for you to identify what’s happening within the algorithm.
    Now move the difference to other offsets in the string, and you’ll observe different
    execution times for different offsets. If `MAC1` is the correct MAC tag and `MAC2`
    is the one tried by the attacker, you can easily identify the position of the
    first difference, which is the number of correctly guessed bytes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的测试环境中，程序在 [清单 7-2](ch07.xhtml#ch7list2) 中的典型执行时间分别为 0.215 秒和 0.095 秒。这一差异足够显著，可以让你识别算法中的发生情况。现在，将差异移到字符串的其他偏移位置，你会观察到不同偏移位置的执行时间不同。如果
    `MAC1` 是正确的 MAC 标签，而 `MAC2` 是攻击者尝试的标签，你可以轻松地识别第一个差异的位置，这就是正确猜测字节的数量。
- en: 'Of course, if execution time doesn’t depend on a secret timing, timing attacks
    won’t work, which is why implementers strive to write *constant-time* implementations—that
    is, code that takes exactly the same time to complete for any secret input value.
    For example, the C function in [Listing 7-3](ch07.xhtml#ch7list3) compares two
    buffers of `size` bytes in constant time: the temporary variable `result` will
    be nonzero if and only if there’s a difference somewhere in the two buffers.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果执行时间不依赖于秘密时序，时序攻击就不起作用，这就是为什么实现者努力编写 *常量时间* 实现——即对于任何秘密输入值，代码执行的时间完全相同。例如，[清单
    7-3](ch07.xhtml#ch7list3) 中的 C 函数在常量时间内比较两个 `size` 字节的缓冲区：临时变量 `result` 仅在两个缓冲区之间有差异时才为非零。
- en: '[PRE2]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-3: Constant-time comparison of two buffers, for safer MAC verification*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-3：对两个缓冲区进行常量时间比较，以便更安全地验证 MAC*'
- en: '*When Sponges Leak*'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*当海绵结构泄漏时*'
- en: Permutation-based algorithms like SHA-3 and SipHash are simple, easy to implement,
    and come with compact implementations, but they’re fragile in the face of side-channel
    attacks that recover a snapshot of the system’s state. For example, if a process
    can read the RAM and registers’ values at any time, or read a core dump of the
    memory, an attacker can determine the internal state of SHA-3 in MAC mode, or
    the internal state of SipHash, and then compute the reverse of the permutation
    to recover the initial secret state. They can then forge tags for any message,
    breaking the MAC’s security.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 基于置换的算法，如 SHA-3 和 SipHash，简单易用且实现紧凑，但在面对侧信道攻击（能恢复系统状态快照）时非常脆弱。例如，如果进程可以随时读取
    RAM 和寄存器的值，或读取内存的核心转储，攻击者就能确定 SHA-3 在 MAC 模式下的内部状态，或者 SipHash 的内部状态，然后计算置换的反向操作，恢复初始的秘密状态。接着，他们可以伪造任何消息的标签，从而破坏
    MAC 的安全性。
- en: Fortunately, this attack will not work against compression function–based MACs
    such as HMAC-SHA-256 and keyed BLAKE2 because the attacker would need a snapshot
    of memory at the exact time when the key is used. The upshot is that if you’re
    in an environment where parts of a process’s memory may leak, you can use a MAC
    based on a noninvertible transform compression function rather than a permutation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种攻击对于基于压缩函数的 MAC（如 HMAC-SHA-256 和带密钥的 BLAKE2）不起作用，因为攻击者需要在密钥被使用的确切时刻获得内存快照。结果是，如果你处在一个可能泄漏部分进程内存的环境中，可以使用基于不可逆变换压缩函数的
    MAC，而不是基于置换的 MAC。
- en: Further Reading
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'The venerable HMAC deserves more attention than I have space for here, and
    even more for the train of thought that led to its wide adoption, and eventually
    to its demise when combined with a weak hash function. I recommend the 1996 paper
    “Keying Hash Functions for Message Authentication” by Bellare, Canetti, and Krawczyk,
    which introduced HMAC and its cousin NMAC, and the 2006 follow-up paper by Bellare
    called “New Proofs for NMAC and HMAC: Security Without Collision-Resistance,”
    which proves that HMAC doesn’t need a collision-resistant hash, but only a hash
    with a compression function that is a PRF. On the offensive side, the 2007 paper
    “Full Key-Recovery Attacks on HMAC/NMAC-MD4 and NMAC-MD5” by Fouque, Leurent,
    and Nguyen shows how to attack HMAC and NMAC when they’re built on top of a brittle
    hash function such as MD4 or MD5\. (By the way, HMAC-MD5 and HMAC-SHA-1 aren’t
    totally broken, but the risk is high enough.)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 受人尊敬的HMAC值得比这里所能容纳的更多关注，尤其是它广泛应用的思路，以及当与弱哈希函数结合时最终导致其衰退的过程。我推荐1996年Bellare、Canetti和Krawczyk的论文《为消息认证键控哈希函数》，该文介绍了HMAC及其兄弟NMAC，以及2006年Bellare的后续论文《NMAC和HMAC的新证明：无碰撞抗性安全性》，该文证明了HMAC不需要碰撞抗性哈希，只需要具有压缩函数的哈希，该函数是伪随机函数（PRF）。在攻击方面，2007年Fouque、Leurent和Nguyen的论文《对HMAC/NMAC-MD4和NMAC-MD5的完全密钥恢复攻击》展示了当HMAC和NMAC建立在脆弱的哈希函数（如MD4或MD5）之上时，如何进行攻击。（顺便提一下，HMAC-MD5和HMAC-SHA-1并不是完全破坏的，但风险足够高。）
- en: The Wegman–Carter MACs are also worth more attention, both for their practical
    interest and underlying theory. The seminal papers by Wegman and Carter are available
    at *[http://cr.yp.to/bib/entries.html](http://cr.yp.to/bib/entries.html)*. Other
    state-of-the-art designs include UMAC and VMAC, which are among the fastest MACs
    on long messages.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Wegman–Carter MAC也值得更多关注，既因为它们在实践中的兴趣，也因为它们的基础理论。Wegman和Carter的开创性论文可以在*[http://cr.yp.to/bib/entries.html](http://cr.yp.to/bib/entries.html)*上找到。其他最先进的设计包括UMAC和VMAC，它们是长消息上最快的MAC之一。
- en: One type of MAC not discussed in this chapter is *Pelican*, which uses the AES
    block cipher reduced to four rounds (down from 10 in the full block cipher) to
    authenticate chunks of messages within a simplistic construction, as described
    in *[https://eprint.iacr.org/2005/088/](https://eprint.iacr.org/2005/088/)*. Pelican
    is more of a curiosity, though, and it’s rarely used in practice.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章未讨论的一种MAC是*Pelican*，它使用简化的AES分组密码（将完整的分组密码从10轮简化为4轮）在简化的结构中认证消息块，具体描述见*[https://eprint.iacr.org/2005/088/](https://eprint.iacr.org/2005/088/)*。然而，Pelican更像是一种好奇心，它在实际中很少使用。
- en: Last but not least, if you’re interested in finding vulnerabilities in cryptographic
    software, look for uses of CBC-MAC, or for weaknesses caused by HMAC handling
    keys of arbitrary sizes—taking **Hash**(*K*) as the key rather than *K* if *K*
    is too long, thus making *K* and **Hash**(*K*) *equivalent keys*. Or just look
    for systems than don’t use MAC when they should—a frequent occurrence.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你对发现加密软件中的漏洞感兴趣，可以查找使用CBC-MAC的情况，或者查找由于HMAC处理任意大小密钥而导致的弱点——如果*K*太长，就使用**Hash**(*K*)作为密钥，而不是*K*，从而使*K*和**Hash**(*K*)成为*等效密钥*。或者，直接查找那些在应该使用MAC时没有使用的系统——这是一个常见的情况。
- en: In [Chapter 8](ch08.xhtml#ch8), we’ll look at how to combine MACs with ciphers
    to protect a message’s authenticity, integrity, *and* confidentiality. We’ll also
    look at how to do it without MACs, thanks to authenticated ciphers, which are
    ciphers that combine the functionality of a basic cipher with that of a MAC by
    returning a tag along with each ciphertext.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.xhtml#ch8)中，我们将探讨如何将MAC与密码算法结合以保护消息的真实性、完整性，*以及*机密性。我们还将探讨如何通过认证密码实现这一目标，认证密码结合了基本密码的功能与MAC的功能，通过返回一个标签与每个密文一起传递。
