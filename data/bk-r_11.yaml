- en: '**9**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**CALLING FUNCTIONS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用函数**'
- en: '![image](../images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common-01.jpg)'
- en: Before you start writing your own functions in R, it’s useful to understand
    how functions are called and interpreted in an R session. First, you’ll look at
    how variable names are compartmentalized in R. You’ll see R’s rules for naming
    arguments and objects, and how R searches for arguments and other variables when
    a function is called. Then you’ll look at some alternative ways to specify arguments
    when calling a function.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写自己的 R 函数之前，了解函数在 R 会话中的调用和解释方式非常有用。首先，你将查看 R 中变量名是如何被划分的。你将了解 R 对参数和对象命名的规则，以及在调用函数时，R
    如何查找参数和其他变量。然后，你将了解调用函数时指定参数的几种替代方法。
- en: '**9.1 Scoping**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.1 作用域**'
- en: To begin with, it’s important to understand R’s *scoping rules*, which determine
    how the language compartmentalizes objects and retrieves them in a given session.
    This framework also defines the situations in which duplicate object names can
    exist at once. For example, you’ve used the argument `data` when calling `matrix`
    ([Section 3.1](ch03.xhtml#ch03lev1sec12)), but `data` is also the name of a ready-to-use
    function that loads data sets from contributed packages ([Section 8.1.2](ch08.xhtml#ch08lev2sec72)).
    In this section, you’ll gain an introductory understanding of how R behaves internally
    in these circumstances, which will help you later on when it comes to programming
    and executing your own functions and those of other packages.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，理解 R 的 *作用域规则* 很重要，它决定了语言如何划分对象并在给定的会话中检索它们。这个框架还定义了可以同时存在重复对象名称的情况。例如，在调用
    `matrix` 时，你使用了 `data` 作为参数([第 3.1 节](ch03.xhtml#ch03lev1sec12))，但 `data` 也是一个现成的函数名称，用于加载来自贡献包的数据集([第
    8.1.2 节](ch08.xhtml#ch08lev2sec72))。在本节中，你将对 R 在这些情况下的内部行为有一个初步的了解，这将帮助你在以后编写和执行你自己以及其他包的函数时。
- en: '***9.1.1 Environments***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***9.1.1 环境***'
- en: R enforces scoping rules with virtual *environments*. You can think of environments
    as separate compartments where data structures and functions are stored. They
    allow R to distinguish between identical names that are associated with different
    scopes and therefore stored in different environments. Environments are dynamic
    entities—new environments can be created, and existing environments can be manipulated
    or removed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: R 通过虚拟 *环境* 强制执行作用域规则。你可以将环境视为存储数据结构和函数的独立隔间。它们允许 R 区分与不同作用域相关的相同名称，并因此存储在不同的环境中。环境是动态实体——可以创建新的环境，也可以操作或删除现有的环境。
- en: '**NOTE**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Technically speaking, environments don’t actually contain items. Rather, they
    have* pointers *to the location of those items in the computer’s memory. But using
    the “compartment” metaphor and thinking of objects “belonging to” these compartments
    is useful when you’re first getting a general sense of how environments work.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*严格来说，环境并不包含项目。相反，它们有指向计算机内存中这些项目位置的* 指针 *。但是，使用“隔间”这一隐喻，并将对象“归属于”这些隔间，在你初步理解环境如何工作的过程中是很有用的。*'
- en: 'There are three important kinds of environments: global environments, package
    environments and namespaces, and local or lexical environments.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种重要的环境：全局环境、包环境和命名空间，以及局部或词法环境。
- en: '**Global Environment**'
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**全局环境**'
- en: The *global environment* is the compartment set aside for user-defined objects.
    Every object you’ve created or overwritten so far has resided in the global environment
    of your current R session. In [Section 1.3.1](ch01.xhtml#ch01lev2sec12), I mentioned
    that a call to `ls()` lists all the objects, variables, and user-defined functions
    in the active workspace—more precisely, `ls()` prints the names of everything
    in the current global environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*全局环境*是为用户定义的对象保留的隔间。到目前为止，你创建或重写的每个对象都驻留在当前 R 会话的全局环境中。在[第 1.3.1 节](ch01.xhtml#ch01lev2sec12)中，我提到过，调用
    `ls()` 会列出活动工作空间中的所有对象、变量和用户定义的函数——更准确地说，`ls()` 会打印当前全局环境中的所有内容。'
- en: 'Starting with a new R workspace, the following code creates two objects and
    confirms their existence in the global environment:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个新的 R 工作空间开始，以下代码创建了两个对象并确认它们在全局环境中的存在：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But what about all the ready-to-use objects and functions? Why aren’t those
    printed alongside `foo` and `bar` as members of this environment? In fact, those
    objects and functions belong to package-specific environments, described next.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，所有现成的对象和函数呢？为什么它们没有和`foo`、`bar`一起作为这个环境的成员打印出来呢？事实上，这些对象和函数属于特定的包环境，接下来会进行描述。
- en: '**Package Environments and Namespaces**'
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**包环境与命名空间**'
- en: For simplicity, I’ll use the term *package environment* rather loosely to refer
    to the items made available by each package in R. In fact, the structure of R
    packages in terms of scoping is a bit more complicated. Each package environment
    actually represents several environments that control different aspects of a search
    for a given object. A package *namespace*, for example, essentially defines the
    visibility of its functions. (A package can have visible functions that a user
    is able to use and invisible functions that provide internal support to the visible
    functions.) Another part of the package environment handles *imports* designations,
    dealing with any functions or objects from other libraries that the package needs
    to import for its own functionality.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简便起见，我会宽泛地使用*包环境*一词，指代R中每个包所提供的项目。实际上，R包的作用域结构要复杂得多。每个包环境实际上代表了多个环境，这些环境控制着对给定对象搜索的不同方面。例如，包的*命名空间*基本上定义了其函数的可见性。（一个包可以有可见函数，用户可以使用这些函数，也可以有不可见函数，这些函数为可见函数提供内部支持。）包环境的另一个部分处理*导入*指定，涉及包需要从其他库导入的任何函数或对象，以实现其自身功能。
- en: 'To clarify this, you can think of all the ready-to-use functions and objects
    you’re working with in this book as belonging to specific package environments.
    The same is true for the functions and objects of any contributed packages you’ve
    explicitly loaded with a call to `library`. You can use `ls` to list the items
    in a package environment as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明这一点，你可以将本书中你正在使用的所有现成函数和对象视为属于特定的包环境。同样，任何你通过调用`library`显式加载的贡献包的函数和对象也是如此。你可以使用`ls`列出包环境中的项目，方法如下：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `ls` command lists all of the visible objects contained in the `graphics`
    package environment. Note that this list includes some of the functions you used
    in [Chapter 7](ch07.xhtml#ch07), such as `arrows`, `plot`, and `segments`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls`命令列出了`graphics`包环境中所有可见的对象。请注意，这个列表包括你在[第7章](ch07.xhtml#ch07)中使用的部分函数，例如`arrows`、`plot`和`segments`。'
- en: '**Local Environments**'
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**局部环境**'
- en: Each time a function is called in R, a new environment is created called the
    *local environment*, sometimes referred to as the *lexical environment*. This
    local environment contains all the objects and variables created in and visible
    to the function, including any arguments you’ve supplied to the function upon
    execution. It’s this feature that allows the presence of argument names that are
    identical to other object names accessible in a given workspace.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在R中调用一个函数时，都会创建一个新的环境，称为*局部环境*，有时也被称为*词法环境*。这个局部环境包含所有在函数内部创建的、且该函数可以访问的对象和变量，包括你在执行函数时传入的任何参数。正是这个特性使得在给定的工作空间中，函数参数名可以与其他可访问对象名相同。
- en: 'For example, say you call `matrix` and pass in the argument `data`, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你调用`matrix`并传入参数`data`，如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Calling this function creates a local environment containing the `data` vector.
    When you execute the function, it begins by looking for `data` in this local environment.
    That means R isn’t confused by other objects or functions named `data` in other
    environments (such as the `data` function automatically loaded from the `utils`
    package environment). If a required item isn’t found in the local environment,
    only then does R begin to widen its search for that item (I’ll discuss this feature
    a little more in [Section 9.1.2](ch09.xhtml#ch09lev2sec80)). Once the function
    has completed, this local environment is automatically removed. The same comments
    apply to the `nrow` and `ncol` arguments.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数会创建一个包含`data`向量的局部环境。当你执行函数时，它首先会在该局部环境中查找`data`。这意味着R不会受到其他环境中名为`data`的对象或函数的干扰（例如，自动从`utils`包环境中加载的`data`函数）。如果在局部环境中找不到所需的项，R才会开始扩大搜索范围（我将在[第9.1.2节](ch09.xhtml#ch09lev2sec80)中进一步讨论这个特性）。一旦函数执行完成，该局部环境会自动被移除。对于`nrow`和`ncol`参数，也适用相同的说明。
- en: '***9.1.2 Search Path***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***9.1.2 搜索路径***'
- en: To access data structures and functions from environments other than the immediate
    global environment, R follows a *search path*. The search path lays out all the
    environments that a given R session has available to it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问来自非直接全局环境的数据结构和函数，R会遵循一个*搜索路径*。搜索路径列出了当前R会话可用的所有环境。
- en: The search path is basically a list of the environments that R will search when
    an object is requested. If the object isn’t found in one environment, R proceeds
    to the next one. You can view R’s search path at any time using `search()`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索路径基本上是R在请求对象时会搜索的环境列表。如果某个环境中没有找到对象，R会继续搜索下一个环境。你可以随时使用`search()`查看R的搜索路径。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the command prompt, this path will always begin at the global user environment
    (`.GlobalEnv`) and end after the `base` package environment (`package:base`).
    You can think of these as belonging to a hierarchy, with an arrow pointing from
    left to right between each pair of environments. For my current session, if I
    request a certain object at the R prompt, the program will inspect `.GlobalEnv`
    → `tools:RGUI` → `package:stats` → ... → `package:base` in turn, stopping the
    search when the desired object is found and retrieved. Note that, depending on
    your operating system and whether you’re using the built-in GUI, `tools:RGUI`
    might not be included in your search path.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令提示符来看，这条路径始终从全局用户环境（`.GlobalEnv`）开始，并在`base`包环境（`package:base`）之后结束。你可以将这些环境视为属于一个层次结构，每对环境之间有一条从左到右的箭头指示。在我当前的会话中，如果我在R提示符下请求某个对象，程序将依次检查`.GlobalEnv`
    → `tools:RGUI` → `package:stats` → ... → `package:base`，当找到所需对象并检索后就停止搜索。请注意，根据你的操作系统以及是否使用内置GUI，`tools:RGUI`可能不包括在你的搜索路径中。
- en: If R doesn’t find what it’s looking for by following the environments in the
    search path, the *empty environment* is reached. The empty environment is not
    explicitly listed in the output from `search()`, but it’s always the final destination
    after `package:base`. This environment is special because it marks the end of
    the search path.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果R通过搜索路径中的各个环境没有找到所需的对象，便会到达*空环境*。空环境不会在`search()`的输出中显式列出，但它总是`package:base`之后的最终目的地。这个环境很特殊，因为它标志着搜索路径的结束。
- en: 'For example, if you call the following, a number of things happen internally:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你调用以下内容，内部会发生一些事情：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: R first searches the global environment for a function called `seq`, and when
    this isn’t found, it goes on to search in the enclosing environment, which is
    the next level up in the search path (according to the left-to-right arrows mentioned
    earlier). It doesn’t find it there, so R keeps going through the path to the next
    environment, searching the packages that have been loaded (automatically or otherwise)
    until it finds what it’s looking for. In this example, R locates `seq` in the
    built-in `base` package environment. Then it executes the `seq` function (creating
    a temporary local environment) and assigns the results to a new object, `baz`,
    which resides in the global environment. In the subsequent call to print `baz`,
    R begins by searching the global environment and immediately finds the requested
    object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: R首先在全局环境中搜索名为`seq`的函数，当找不到时，它会继续在封闭环境中搜索，这是搜索路径中下一层的环境（如前所述，从左到右的箭头表示）。如果在那里也找不到，R会继续沿路径搜索，查找已加载的包（无论是自动加载还是手动加载），直到找到所需的内容。在这个例子中，R在内置的`base`包环境中找到了`seq`。然后，它执行`seq`函数（创建一个临时的局部环境），并将结果分配给一个新的对象`baz`，该对象位于全局环境中。在随后的`print(baz)`调用中，R首先在全局环境中搜索，立即找到了请求的对象。
- en: 'You can look up the enclosing environment of any function using `environment`,
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`environment`查找任何函数的封闭环境，方法如下：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, I’ve identified the package namespace of `base` as the owner of the `seq`
    function and the `graphics` package as the owner of the `arrows` function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我已将`base`包的命名空间标识为`seq`函数的拥有者，并将`graphics`包标识为`arrows`函数的拥有者。
- en: Each environment has a *parent*, to direct the order of the search path. Examining
    the earlier output from the call `search()`, you can see that the parent of `package:stats`,
    for example, is `package:graphics`. The specific parent-child structure is dynamic
    in the sense that the search path changes when additional libraries are loaded
    or data frames are `attach`ed. When you load a contributed package with a call
    to `library`, this essentially just inserts the desired package in the search
    path. For example, in [Exercise 8.1](ch08.xhtml#ch8exc1) on [page 161](ch08.xhtml#page_161),
    you installed the contributed package `car`. After loading this package, your
    search path will include its contents.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个环境都有一个*父环境*，用于指导搜索路径的顺序。通过检查之前`search()`调用的输出，您可以看到例如`package:stats`的父环境是`package:graphics`。这种父子结构是动态的，意味着当加载额外的库或数据框被`attach`时，搜索路径会发生变化。当您通过`library`调用加载一个贡献包时，它基本上会将所需的包插入到搜索路径中。例如，在[练习8.1](ch08.xhtml#ch8exc1)中，您安装了贡献包`car`。加载此包后，您的搜索路径将包括它的内容。
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note the position of the `car` package environment in the path—inserted directly
    after the global environment. This is where each subsequently loaded package will
    be placed (followed by any additional packages it depends upon for its own functionality).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`car`包环境在路径中的位置——它直接插入在全局环境之后。这是每个后续加载的包将被放置的位置（接着是它依赖的其他包）。
- en: As noted earlier, R will stop searching once it has exhausted the entire search
    path and reached the empty environment. If you request a function or object that
    you haven’t defined, that doesn’t exist, or that is perhaps in a contributed package
    that you’ve forgotten to load (this is quite a common little mistake), then an
    error is thrown. These “cannot find” errors are recognizable for both functions
    and other objects.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一旦R搜索完所有路径并到达空环境，它将停止搜索。如果您请求一个未定义的函数或对象，或者是可能在一个您忘记加载的贡献包中（这是一个常见的小错误），那么会抛出错误。这些“找不到”的错误无论是对于函数还是其他对象都可以识别。
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Environments help compartmentalize the huge amount of functionality in R. This
    becomes particularly important when there are functions with the same name in
    different packages in the search path. At that point, *masking*, discussed in
    [Section 12.3](ch12.xhtml#ch12lev1sec41), comes into play.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 环境有助于将R中的大量功能进行隔离。当搜索路径中不同包中有相同名称的函数时，这一点尤其重要。此时，*掩蔽*，如[第12.3节](ch12.xhtml#ch12lev1sec41)所讨论的那样，便开始起作用。
- en: As you get more comfortable with R and want more precise control over how it
    operates, it’s worth investigating in full how R handles environments. For more
    technical details on this, Gupta ([2012](ref.xhtml#ref27)) provides a particularly
    well-written online article.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您对R的熟悉，您可能希望更精确地控制其操作，因此值得全面调查R如何处理环境。关于这一点的更多技术细节，Gupta（[2012](ref.xhtml#ref27)）提供了一篇特别精彩的在线文章。
- en: '***9.1.3 Reserved and Protected Names***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***9.1.3 保留和受保护的名称***'
- en: A few key terms are strictly forbidden from being used as object names in R.
    These *reserved* names are necessary in order to protect fundamental operations
    and data types frequently used in the language.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: R中有一些关键术语严格禁止用作对象名称。这些*保留*名称是为了保护语言中经常使用的基本操作和数据类型。
- en: 'The following identifiers are reserved:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标识符是保留的：
- en: • `if` and `else`
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: • `if` 和 `else`
- en: • `for`, `while`, and `in`
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: • `for`、`while` 和 `in`
- en: • `function`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: • `function`
- en: • `repeat`, `break`, and `next`
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: • `repeat`、`break` 和 `next`
- en: • `TRUE` and `FALSE`
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: • `TRUE` 和 `FALSE`
- en: • `Inf` and `-Inf`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: • `Inf` 和 `-Inf`
- en: • `NA`, `NaN`, and `NULL`
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: • `NA`、`NaN` 和 `NULL`
- en: I haven’t yet covered some of the terms on this list. These items represent
    the core tools for programming in the R language, and you’ll begin to explore
    them in the following chapter. The last three bullet points include the familiar
    logical values ([Section 4.1](ch04.xhtml#ch04lev1sec16)) and special terms used
    to represent things like infinity and missing entries ([Section 6.1](ch06.xhtml#ch06lev1sec21)).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有覆盖这个列表中的一些术语。这些条目代表了R语言编程的核心工具，您将在接下来的章节中开始探索它们。最后三个项目包括熟悉的逻辑值（[第4.1节](ch04.xhtml#ch04lev1sec16)）和用于表示无限大和缺失条目的特殊术语（[第6.1节](ch06.xhtml#ch06lev1sec21)）。
- en: If you try to assign a new value to any of these reserved terms, an error occurs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试为这些保留术语分配新值，会发生错误。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because R is case sensitive, it’s possible to assign values to any case-variant
    of the reserved names, but this can be confusing and is generally not advisable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于R是区分大小写的，可能会给保留名称的任何大小写变体赋值，但这可能会导致混淆，通常不建议这样做。
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Also be wary of assigning values to `T` and `F`, the abbreviations of `TRUE`
    and `FALSE`. The full identifiers `TRUE` and `FALSE` are reserved, but the abbreviated
    versions are not.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，要小心不要给`T`和`F`赋值，这两个是`TRUE`和`FALSE`的简写。完整的标识符`TRUE`和`FALSE`是保留的，但简写版本不是。
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Assigning values to `T` and `F` this way will affect any subsequent code that
    intends to use `T` and `F` to refer to `TRUE` and `FALSE`. The second assignment
    (`F <- TRUE`) is perfectly legal in R’s eyes, but it’s extremely confusing given
    the normal usage of `F` as an abbreviation: the line `F&&TRUE` now represents
    a `TRUE&&TRUE` comparison! It’s best to simply avoid these types of assignments.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式给`T`和`F`赋值将影响任何后续的代码，这些代码意图使用`T`和`F`来表示`TRUE`和`FALSE`。第二个赋值（`F <- TRUE`）在R看来是完全合法的，但鉴于`F`通常作为简写，它会非常令人困惑：这一行`F&&TRUE`现在表示的是一个`TRUE&&TRUE`的比较！最好避免这种类型的赋值。
- en: If you’ve been following along with the examples in your R console, it’s prudent
    at this point to clear the global environment (thereby deleting the objects `False`,
    `nan`, `T`, and `F` from your workspace). To do this, use the `rm` function as
    shown next. Using `ls()`, supply a character vector of all objects in the global
    environment as the argument `list`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在跟随R控制台中的示例，建议此时清空全局环境（从工作区删除对象`False`、`nan`、`T`和`F`）。可以使用`rm`函数，如下所示。使用`ls()`时，提供一个包含全局环境中所有对象的字符向量作为`list`参数。
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now the global environment is empty, and calling `ls()` returns an empty character
    vector (`character(0)`).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，全局环境为空，调用`ls()`返回一个空的字符向量（`character(0)`）。
- en: '**Exercise 9.1**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.1**'
- en: Identify the first 20 items contained in the built-in and automatically loaded
    `methods` package. How many items are there in total?
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别内置并自动加载的`methods`包中的前20个项目。总共有多少个项目？
- en: 'Determine the environment that owns each of the following functions:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定以下每个函数所属的环境：
- en: '`read.table`'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`read.table`'
- en: '`data`'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`data`'
- en: '`matrix`'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`matrix`'
- en: '`jpeg`'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jpeg`'
- en: Use `ls` and a test for character string equality to confirm the function `smoothScatter`
    is part of the `graphics` package.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ls`和字符字符串相等性测试来确认`smoothScatter`函数属于`graphics`包。
- en: '**9.2 Argument Matching**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**9.2 参数匹配**'
- en: Another set of rules that determine how R interprets function calls has to do
    with *argument matching*. Argument matching conditions allow you to provide arguments
    to functions either with abbreviated names or without names at all.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组决定R如何解释函数调用的规则涉及*参数匹配*。参数匹配条件允许你通过简写的名称或完全不带名称的方式向函数提供参数。
- en: '***9.2.1 Exact***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***9.2.1 精确匹配***'
- en: So far, you’ve mostly been using *exact* matching of arguments, where each argument
    tag is written out in full. This is the most exhaustive way to call a function.
    It’s helpful to write out full argument names this way when first getting to know
    R or a new function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你主要在使用*精确*匹配参数，其中每个参数标签都写出完整。这是调用函数时最详尽的方式。当你初次学习R或新函数时，写出完整的参数名是非常有帮助的。
- en: 'Other benefits of exact matching include the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 精确匹配的其他好处包括：
- en: • Exact matching is less prone to mis-specification of arguments than other
    matching styles.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: • 与其他匹配方式相比，精确匹配更不容易出错。
- en: • The order in which arguments are supplied doesn’t matter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: • 参数的提供顺序无关紧要。
- en: • Exact matching is useful when a function has many possible arguments but you
    want to specify only a few.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: • 当一个函数有多个可能的参数，但你只想指定其中一部分时，精确匹配非常有用。
- en: 'The main drawbacks of exact matching are clear:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 精确匹配的主要缺点很明显：
- en: • It can be cumbersome for relatively simple operations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: • 对于相对简单的操作来说，这可能显得笨重。
- en: • Exact matching requires the user to remember or look up the full, case-sensitive
    tags.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: • 精确匹配要求用户记住或查找完整的、区分大小写的标签。
- en: 'As an example, in [Section 6.2.1](ch06.xhtml#ch06lev2sec59), you used exact
    matching to execute the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，在[第6.2.1节](ch06.xhtml#ch06lev2sec59)中，你使用了精确匹配来执行以下操作：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This creates a 3 × 3 matrix object `bar` with a `dimnames` attribute for the
    rows and columns. Since the argument tags are fully specified, the order of the
    arguments doesn’t matter. You could switch around the arguments, and the function
    still has all the information it requires.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个 3 × 3 的矩阵对象 `bar`，并为行和列设置 `dimnames` 属性。由于参数标签已完全指定，参数的顺序并不重要。你可以交换参数，函数仍然能获得它所需的所有信息。
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This behaves the same way as the previous function call. For the sake of consistency,
    you usually won’t switch around arguments each time you call a function, but this
    example shows a benefit of exact matching: you don’t have to worry about the order
    of any optional arguments or about skipping them.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的函数调用行为相同。为了保持一致性，通常在每次调用函数时你不会交换参数，但这个例子展示了精确匹配的一个好处：你不需要担心任何可选参数的顺序或跳过它们。
- en: '***9.2.2 Partial***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***9.2.2 部分匹配***'
- en: '*Partial* matching lets you identify arguments with an abbreviated tag. This
    can shorten your code, and it still lets you provide arguments in any order.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*部分*匹配让你能够通过缩写标签来识别参数。这可以缩短代码，同时仍然允许你以任意顺序提供参数。'
- en: 'Here is another way to call `matrix` that takes advantage of partial matching:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一种调用 `matrix` 的方式，它利用了部分匹配：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice I’ve shortened the `nrow`, `dimnames`, and `ncol` argument tags to the
    first two letters and shortened the `data` argument to the first three. For partial
    matching, there’s no set number of letters you have to provide, as long as each
    argument is still uniquely identifiable for the function being called. Partial
    matching has the following benefits:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已将 `nrow`、`dimnames` 和 `ncol` 的参数标签缩短为前两个字母，并将 `data` 参数缩短为前三个字母。对于部分匹配，你不必提供固定数量的字母，只要每个参数对于被调用的函数仍然是唯一可识别的。部分匹配有以下优点：
- en: • It requires less code than exact matching.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: • 它比精确匹配需要的代码更少。
- en: • Argument tags are still visible (which limits the possibility of mis-specification).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: • 参数标签仍然可见（这减少了误配的可能性）。
- en: • The order of supplied arguments still doesn’t matter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: • 提供的参数顺序仍然不重要。
- en: 'But partial matching also has some limitations. For one, it gets trickier if
    there are multiple arguments whose tags start with the same letters. Here’s an
    example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但部分匹配也有一些局限性。首先，如果有多个参数的标签以相同的字母开头，情况会变得更加复杂。这里有一个例子：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: An error has occurred. The fourth argument tag is designated simply as `d`,
    which is meant to stand for `data`. This is illegal because another argument,
    namely `dimnames`, also starts with `d`. Even though `dimnames` is specified separately
    as `di` earlier in the same line, the call isn’t valid.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了错误。第四个参数标签仅指定为 `d`，代表 `data`。这是不合法的，因为另一个参数 `dimnames` 也以 `d` 开头。即使 `dimnames`
    在同一行中稍早前已单独指定为 `di`，这个调用仍然无效。
- en: 'Drawbacks of partial matching include the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 部分匹配的缺点包括以下几点：
- en: • The user must be aware of other potential arguments that can be matched by
    the shortened tag (even if they aren’t specified in the call or have a default
    value assigned).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: • 用户必须意识到其他可能被缩短标签匹配的参数（即使它们没有在调用中指定或已分配了默认值）。
- en: • Each tag must have a unique identification, which can be difficult to remember.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: • 每个标签必须有唯一的标识符，这可能很难记住。
- en: '***9.2.3 Positional***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***9.2.3 位置匹配***'
- en: The most compact mode of function calling in R is *positional matching*. This
    is when you supply arguments without tags, and R interprets them based solely
    on their order.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: R 中最紧凑的函数调用方式是*位置匹配*。这是指你在没有标签的情况下提供参数，R 会仅根据它们的顺序来解释它们。
- en: 'Positional matching is usually used for relatively simple functions with only
    a few arguments, or functions that are very familiar to the user. For this type
    of matching, you *must* be aware of the precise positions of each argument. You
    can find that information in the “Usage” section of the function’s help file,
    or it can be printed to the console with the `args` function. Here’s an example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 位置匹配通常用于相对简单的函数，这些函数只有少量参数，或者是用户非常熟悉的函数。对于这种类型的匹配，你*必须*了解每个参数的精确位置。你可以在函数帮助文件的“Usage”部分找到该信息，或者可以通过
    `args` 函数将其打印到控制台。这里有一个例子：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This shows the defined order of arguments of the `matrix` function, as well
    as the default value for each argument. To construct the matrix `bar` with positional
    matching, execute the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了 `matrix` 函数的参数定义顺序，以及每个参数的默认值。要使用位置匹配构造矩阵 `bar`，请执行以下操作：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The benefits of positional matching are as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 位置匹配的好处如下：
- en: • Shorter, cleaner code, particularly for routine tasks
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: • 更简短、更清晰的代码，特别是对于常规任务
- en: • No need to remember specific argument tags
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: • 不需要记住特定的参数标签。
- en: 'Notice that when using exact and partial matching, you didn’t need to supply
    anything for the `byrow` argument, which, by default, is set to `FALSE`. With
    positional matching, you must provide a value (given here as `F`) for `byrow`
    as the fourth argument because R relies on position alone to interpret the function
    call. If you leave out the argument, you get an error, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在使用精确匹配和部分匹配时，你不需要为`byrow`参数提供任何内容，因为默认情况下它被设置为`FALSE`。而在位置匹配时，你必须为`byrow`提供一个值（这里为`F`），作为第四个参数，因为R仅通过位置来解释函数调用。如果你省略了这个参数，就会出现如下错误：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here R has tried to assign the fourth argument (the list you intended for `dimnames`)
    as the value for the logical `byrow` argument. This brings us to the drawbacks
    of positional matching:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里R试图将第四个参数（你原本打算用于`dimnames`的列表）赋值给逻辑值`byrow`的参数。这引出了位置匹配的缺点：
- en: • You must look up and exactly match the defined order of arguments.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: • 你必须查找并精确匹配已定义的参数顺序。
- en: • Reading code written by someone else can be more difficult, especially when
    it includes unfamiliar functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: • 阅读别人写的代码可能更困难，尤其是当代码中包含不熟悉的函数时。
- en: '***9.2.4 Mixed***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***9.2.4 混合匹配***'
- en: Since each matching style has pros and cons, it’s quite common, and perfectly
    legal, to mix these three styles in a single function call.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每种匹配方式都有优缺点，因此在一次函数调用中混合使用这三种匹配方式是非常常见且完全合法的。
- en: 'For instance, you can avoid the type of error shown in the previous example
    like so:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以像下面这样避免之前示例中的错误：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here I’ve used positional matching for the first three arguments, which are
    by now familiar to you. At the same time, I’ve used partial matching to explicitly
    tell R that the list is meant as a `dimnames` value, not for `byrow`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我为前三个参数使用了位置匹配，这些参数你现在已经熟悉了。同时，我使用了部分匹配，明确告诉R该列表是作为`dimnames`值，而不是`byrow`。
- en: '***9.2.5 Dot-Dot-Dot: Use of Ellipses***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***9.2.5 点点点：省略号的使用***'
- en: Many functions exhibit *variadic* behavior. That is, they can accept any number
    of arguments, and it’s up to the user to decide how many arguments to provide.
    The functions `c`, `data.frame`, and `list` are all like this. When you call a
    function like `data.frame`, you can specify any number of members as arguments.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数展示了*可变参数*行为。也就是说，它们可以接受任意数量的参数，由用户决定提供多少个参数。函数`c`、`data.frame`和`list`都是如此。当你调用像`data.frame`这样的函数时，你可以指定任意数量的成员作为参数。
- en: 'This flexibility is achieved in R through the special *dot-dot-dot* designation
    (`...`), also called the *ellipsis*. This construct allows the user to supply
    any number of data vectors (these become the columns in the final data frame).
    You can see whether an ellipsis is used in a function on the function’s help page
    or with `args`. Looking at `data.frame`, notice the first argument slot is an
    ellipsis:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性是在R中通过特殊的*点点点*符号（`...`）实现的，也叫做*省略号*。这种构造允许用户提供任意数量的数据向量（这些向量将成为最终数据框中的列）。你可以通过查看函数的帮助页面或使用`args`来判断函数是否使用了省略号。在`data.frame`中，可以看到第一个参数位置是一个省略号：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When you call a function and supply an argument that can’t be matched with one
    of the function’s defined argument tags, normally this would produce an error.
    But if the function is defined with an ellipsis, any arguments that aren’t matched
    to other argument tags are matched to the ellipsis.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个函数并提供一个无法与函数定义的参数标签匹配的参数时，通常这会导致一个错误。但是，如果函数是用省略号定义的，任何未与其他参数标签匹配的参数将会匹配到省略号。
- en: Functions that employ ellipses generally fall into two groups. The first group
    includes functions such as `c`, `data.frame`, and `list`, where the ellipsis always
    represents the “main ingredients” in the function call. That is, the objective
    of the function is to use contents of the ellipsis in the resulting object or
    output. The second group consists of functions where the ellipsis is meant as
    a *supplementary* or *potential* repository of optional arguments. This is common
    when the function of interest calls other *subfunctions* that themselves require
    additional arguments depending upon the originally supplied items. Rather than
    explicitly copy all the arguments desired by the subfunction into the argument
    list of the “parent” function, the parent function can instead be defined including
    an ellipsis that is subsequently provided to the subfunction.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用省略号的函数通常分为两类。第一类包括像`c`、`data.frame`和`list`这样的函数，其中省略号始终表示函数调用中的“主要成分”。也就是说，函数的目的是将省略号中的内容用于结果对象或输出中。第二类函数则是将省略号作为*补充*或*潜在*的可选参数存储库。这种情况通常出现在某个感兴趣的函数调用了其他*子函数*，这些子函数根据最初提供的参数可能需要额外的参数。为了避免将子函数需要的所有参数显式复制到“父”函数的参数列表中，父函数可以通过定义一个省略号来实现，之后将其提供给子函数。
- en: 'Here’s an example of the ellipsis used for supplementary arguments with the
    generic `plot` function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用省略号传递补充参数的例子，出现在通用的`plot`函数中：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From examining the arguments, it’s clear that optional arguments such as point
    size (argument tag `cex`) or line type (argument tag `lty`), if supplied, are
    matched to the ellipsis. These optional arguments are then passed in to the function
    to be used by various methods that tweak graphical parameters.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从检查参数来看，很明显如果提供了点大小（参数标签`cex`）或线型（参数标签`lty`）等可选参数，它们将与省略号匹配。这些可选参数随后会传递给函数，用于调整图形参数的各种方法。
- en: Ellipses are a convenient programming tool for writing variadic functions or
    functions where an unknown number of arguments may be supplied. This will become
    clearer when you start writing your own functions in [Chapter 11](ch11.xhtml#ch11).
    However, when writing functions like this, it’s important to properly document
    the intended use of `...` so the potential users of the function know exactly
    which arguments can be passed to it and what those arguments are subsequently
    used for in execution.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 省略号是编写可变参数函数或函数时一个方便的编程工具，其中可以传入未知数量的参数。当你开始在[第11章](ch11.xhtml#ch11)编写自己的函数时，这一点将变得更加清晰。然而，在编写这样的函数时，重要的是要正确记录`...`的预期用途，这样函数的潜在用户才能确切知道哪些参数可以传递给它，以及这些参数在执行过程中将如何使用。
- en: '**Exercise 9.2**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 9.2**'
- en: Use positional matching with `seq` to create a sequence of values between −4
    and 4 that progresses in steps of 0.2.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置匹配和`seq`创建一个从-4到4的值序列，步长为0.2。
- en: 'In each of the following lines of code, identify which style of argument matching
    is being used: exact, partial, positional, or mixed. If mixed, identify which
    arguments are specified in each style.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的每一行代码中，识别使用的是哪种参数匹配方式：精确匹配、部分匹配、位置匹配或混合匹配。如果是混合匹配，请确定每种方式中指定了哪些参数。
- en: '`array(8:1,dim=c(2,2,2))`'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`array(8:1,dim=c(2,2,2))`'
- en: '`rep(1:2,3)`'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rep(1:2,3)`'
- en: '`seq(from=10,to=8,length=5)`'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`seq(from=10,to=8,length=5)`'
- en: '`sort(decreasing=T,x=c(2,1,1,2,0.3,3,1.3))`'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sort(decreasing=T,x=c(2,1,1,2,0.3,3,1.3))`'
- en: '`which(matrix(c(T,F,T,T),2,2))`'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`which(matrix(c(T,F,T,T),2,2))`'
- en: '`which(matrix(c(T,F,T,T),2,2),a=T)`'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`which(matrix(c(T,F,T,T),2,2),a=T)`'
- en: Suppose you explicitly ran the plotting function `plot.default` and supplied
    values to arguments tagged `type`, `pch`, `xlab`, `ylab`, `lwd`, `lty`, and `col`.
    Use the function documentation to determine which of these arguments fall under
    the umbrella of the ellipsis.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你显式运行了绘图函数`plot.default`并为参数`type`、`pch`、`xlab`、`ylab`、`lwd`、`lty`和`col`提供了值。使用函数文档来确定这些参数中哪些属于省略号的范畴。
- en: '**Important Code in This Chapter**'
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**本章中的重要代码**'
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **函数/运算符** | **简要描述** | **首次出现** |'
- en: '| --- | --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ls` | Inspect environment objects | [Section 9.1.1](ch09.xhtml#ch09lev2sec79),
    [p. 167](ch09.xhtml#page_167) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `ls` | 检查环境对象 | [第9.1.1节](ch09.xhtml#ch09lev2sec79)，[第167页](ch09.xhtml#page_167)
    |'
- en: '| `search` | Current search path | [Section 9.1.2](ch09.xhtml#ch09lev2sec80),
    [p. 168](ch09.xhtml#page_168) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `search` | 当前搜索路径 | [第9.1.2节](ch09.xhtml#ch09lev2sec80)，[第168页](ch09.xhtml#page_168)
    |'
- en: '| `environment` | Function environment properties | [Section 9.1.2](ch09.xhtml#ch09lev2sec80),
    [p. 169](ch09.xhtml#page_169) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `environment` | 函数环境属性 | [第9.1.2节](ch09.xhtml#ch09lev2sec80)，[第169页](ch09.xhtml#page_169)
    |'
- en: '| `rm` | Delete objects in workspace | [Section 9.1.3](ch09.xhtml#ch09lev2sec81),
    [p. 171](ch09.xhtml#page_171) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `rm` | 删除工作区中的对象 | [第9.1.3节](ch09.xhtml#ch09lev2sec81)，[第171页](ch09.xhtml#page_171)
    |'
- en: '| `args` | Show function arguments | [Section 9.2.3](ch09.xhtml#ch09lev2sec84),
    [p. 174](ch09.xhtml#page_174) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `args` | 显示函数参数 | [第9.2.3节](ch09.xhtml#ch09lev2sec84)，[第174页](ch09.xhtml#page_174)
    |'
