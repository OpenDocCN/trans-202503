- en: '**16'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**16'
- en: UEFI FIRMWARE VULNERABILITIES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 固件漏洞
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Security products nowadays tend to focus on threats that operate at the high
    levels of the software stack, and they achieve reasonably good results. However,
    this leaves them unable to see what’s going on in the dark waters of firmware.
    If an attacker has already gained privileged access to the system and installed
    a firmware implant, these products are useless.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的安全产品倾向于专注于操作软件堆栈高层的威胁，并取得了相当不错的成果。然而，这使得它们无法看到固件中的黑暗水域。如果攻击者已经获得系统的特权访问权限并安装了固件植入物，那么这些产品将毫无作用。
- en: Very few security products examine firmware, and those that do only do so from
    the operating system level, detecting the presence of implants only after they’ve
    successfully installed and compromised the system. More complex implants can also
    use their privileged position in the system to avoid detection and subvert OS-level
    security products.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有安全产品检查固件，而且那些做检查的产品也仅限于操作系统级别，它们只能在植入物成功安装并破坏系统后，才能检测到其存在。更复杂的植入物还可以利用其在系统中的特权位置，避免被检测，并破坏操作系统级别的安全产品。
- en: For these reasons, firmware rootkits and implants are one of the most dangerous
    threats to PCs, and they pose an even bigger threat they pose to modern cloud
    platforms, where a single misconfigured or compromised guest operating system
    endangers all other guests, exposing their memory to malicious manipulation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些原因，固件 rootkit 和植入物是对个人电脑最危险的威胁之一，它们对现代云平台构成了更大的威胁，因为一个配置错误或被攻破的客户操作系统就会危及所有其他客户，暴露其内存并受到恶意操控。
- en: Detecting firmware anomalies is a difficult technical challenge for many reasons.
    The UEFI firmware codebases provided by various vendors are all different, and
    the existing methods of detecting anomalies aren’t effective in every case. Attackers
    can also use both the false positives and false negatives of a detection scheme
    to their advantage, and they can even take over the interfaces that OS-level detection
    algorithms use to access and examine the firmware.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 检测固件异常是一个技术挑战，原因有很多。不同厂商提供的 UEFI 固件代码库各不相同，现有的检测异常方法在每种情况下都不有效。攻击者还可以利用检测方案的误报和漏报来他们的优势，甚至可能接管操作系统级别的检测算法用来访问和检查固件的接口。
- en: The only viable way to protect against firmware rootkits is to prevent their
    installation. Detection and other mitigations don’t work; instead, we have to
    block the possible infection vectors. Solutions for detecting or preventing firmware
    threats work only when the developer has full control over both the software and
    hardware stacks, like Apple or Microsoft does. Third-party solutions will always
    have blind spots.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 保护免受固件 rootkit 攻击的唯一可行方法是防止其安装。检测和其他缓解措施无效；相反，我们必须阻止可能的感染途径。检测或防止固件威胁的解决方案仅在开发者完全控制软件和硬件堆栈时有效，就像苹果或微软那样。第三方解决方案总是会有盲点。
- en: In this chapter, we’ll outline most of the known vulnerabilities and exploitation
    vectors used for infecting UEFI firmware. We’ll first examine the vulnerable firmware,
    classify types of firmware weaknesses and vulnerabilities, and analyze existing
    firmware security measures. We will then describe vulnerabilities in Intel Boot
    Guard, SMM modules, the S3 Boot Script, and the Intel Management Engine.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述用于感染 UEFI 固件的大多数已知漏洞和利用途径。我们将首先检查易受攻击的固件，分类固件弱点和漏洞，并分析现有的固件安全措施。然后，我们将描述
    Intel Boot Guard、SMM 模块、S3 启动脚本和 Intel 管理引擎中的漏洞。
- en: '**What Makes Firmware Vulnerable?**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**是什么使固件容易受到攻击？**'
- en: We’ll begin by going over the specific firmware that attackers could target
    with a malicious update. Updates are the most effective method of infection.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从攻击者可能通过恶意更新攻击的固件开始讲解。更新是最有效的感染方法。
- en: Vendors will typically describe UEFI firmware updates broadly as *BIOS updates*,
    because the BIOS is the main firmware included, but a typical update also delivers
    many other kinds of embedded firmware to the various hardware units inside the
    motherboard, or even the CPU.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 厂商通常将 UEFI 固件更新广义地描述为 *BIOS 更新*，因为 BIOS 是主要的固件，但典型的更新还会为主板内部的各种硬件单元，甚至 CPU 提供许多其他类型的嵌入式固件。
- en: A compromised BIOS update destroys the integrity guarantees for all other firmware
    updates managed by the BIOS (some of these updates, like Intel microcode, have
    additional authentication methods and don’t rely solely on the BIOS), so any vulnerability
    that bypasses authentication for a BIOS update image also opens the door for the
    delivery of malicious rootkits or implants to any of these units.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 被篡改的BIOS更新会破坏由BIOS管理的所有其他固件更新的完整性保证（其中一些更新，如英特尔微码，具有额外的认证方法，不仅仅依赖BIOS），因此，任何绕过BIOS更新镜像认证的漏洞，也为恶意根工具或植入物的传送打开了大门，可能影响这些设备中的任何一个。
- en: '[Figure 16-1](ch16.xhtml#ch16fig01) shows the typical firmware units managed
    by the BIOS, all of which are susceptible to malicious BIOS updates.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-1](ch16.xhtml#ch16fig01)展示了BIOS管理的典型固件单元，所有这些都容易受到恶意BIOS更新的影响。'
- en: '![image](../images/16fig01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/16fig01.jpg)'
- en: '*Figure 16-1: Overview of different firmware in modern x86-based computers*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-1：现代基于x86计算机中不同固件的概述*'
- en: 'Here are brief descriptions of each type of firmware:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每种固件类型的简要描述：
- en: '**Power Management Unit (PMU)** A microcontroller that controls the power functions
    and transitions of a PC between different power states, such as sleep and hibernate.
    It contains its own firmware and a low-power processor.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**电源管理单元（PMU）** 一种微控制器，负责控制PC在不同电源状态之间的电源功能和过渡，例如睡眠和休眠。它包含自己的固件和低功耗处理器。'
- en: '**Intel Embedded Controller (EC)** A microcontroller that is always on. It
    supports multiple features, such as turning the computer on and off, processing
    signals from the keyboard, calculating thermal measurements, and controlling the
    fan. It communicates with the main CPU over ACPI, SMBus, or shared memory. The
    EC, along with the Intel Management Engine described shortly, can function as
    a security root of trust when the System Management Mode is compromised. The Intel
    BIOS Guard technology (vendor-specific implementations), for example, uses the
    EC to control the read/write access to SPI flash.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**英特尔嵌入式控制器（EC）** 一种始终开启的微控制器，支持多种功能，例如开关计算机、处理键盘信号、计算热量测量和控制风扇。它通过ACPI、SMBus或共享内存与主CPU通信。EC与随后描述的英特尔管理引擎一起，可以在系统管理模式被破坏时充当安全信任根。例如，英特尔BIOS保护技术（厂商特定的实现）使用EC控制对SPI闪存的读/写访问。'
- en: '**Intel Integrated Sensor Hub (ISH)** A microcontroller responsible for sensors,
    such as device rotation detectors and automatic backlight adjustors. It can also
    be responsible for some low-power sleep states for those sensors.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**英特尔集成传感器集线器（ISH）** 一种微控制器，负责传感器，例如设备旋转检测器和自动背光调节器。它还可以负责这些传感器的一些低功耗睡眠状态。'
- en: '**Graphics Processing Unit (GPU)** An integrated graphics processor (iGPU)
    that is part of the Platform Controller Hub (PCH) design in most modern Intel
    x86-based computers. GPUs have their own advanced firmware and computing units
    focused on generating graphics, such as shaders.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形处理单元（GPU）** 一种集成图形处理器（iGPU），它是大多数现代英特尔x86计算机中平台控制器集线器（PCH）设计的一部分。GPU具有自己的先进固件和计算单元，专注于生成图形，如着色器。'
- en: '**Intel Gigabit Network** Intel-integrated ethernet network cards for x86-based
    computers are represented as PCIe devices connected to PCH and contain their own
    firmware, delivered via BIOS update images.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**英特尔千兆网络** 集成以太网卡用于基于x86的计算机，表现为连接到PCH的PCIe设备，并包含其固件，通过BIOS更新镜像提供。'
- en: '**Intel CPU Microcode** The CPU’s internal firmware, which is the interpretive
    layer that interprets the ISA. The programmer-visible *instruction set architecture
    (ISA)* is a part of microcode, but some instructions can be more deeply integrated
    on the hardware level. Intel microcode is a layer of hardware-level instructions
    that implement higher-level machine code instructions and the internal state machine
    sequencing in many digital processing elements.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**英特尔CPU微码** CPU的内部固件，是解释ISA的解释层。程序员可见的*指令集架构（ISA）* 是微码的一部分，但有些指令可以在硬件层面上更深入地集成。英特尔微码是硬件级指令的一层，实现更高层次的机器码指令和许多数字处理元素中的内部状态机序列。'
- en: '**Authenticated Code Module (ACM)** A signed binary blob executed in cache
    memory. Intel microcode loads and executes within protected internal CPU memory,
    which is called *Authenticated Code RAM (ACRAM)*, or *Cache-as-RAM (CAR)*. This
    fast memory is initialized early in the boot process. It functions as regular
    RAM before the main RAM is activated and before the reset-vector code for early
    boot ACM code (Intel Boot Guard) runs; it can also be loaded later in the boot
    process. Later, it is repurposed for general-purpose caching. The ACM is signed
    by an RSA binary blob with a header that defines its entry point. Modern Intel
    computers can have multiple ACMs for different purposes, but they are mostly used
    to support additional platform security features.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证代码模块 (ACM)** 是一种签名的二进制文件，在缓存内存中执行。英特尔微代码在受保护的内部 CPU 内存中加载并执行，这块内存被称为*认证代码
    RAM (ACRAM)*，或*缓存作为 RAM (CAR)*。这块高速内存会在启动过程中较早初始化。在主内存被激活并且早期启动 ACM 代码（英特尔启动保护）的复位向量代码运行之前，它作为常规
    RAM 使用；也可以在启动过程稍后加载。之后，它会被重新用于一般用途的缓存。ACM 由一个带有定义入口点的 RSA 二进制文件签名。现代的英特尔计算机可能有多个
    ACM，用于不同的目的，但它们大多数用于支持额外的安全平台功能。'
- en: '**Intel Management Engine (ME)** A microcontroller that provides the root-of-trust
    functionality for multiple security features developed by Intel, including the
    software interface to the *firmware Trusted Platform Module*, or *fTPM* (usually
    the TPM is a specialized chip on an endpoint device for hardware-based authentication
    that also contains separate firmware of its own). Since the sixth generation of
    the Intel CPU, the Intel ME is an x86-based microcontroller.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**英特尔管理引擎 (ME)** 是一款微控制器，为英特尔开发的多项安全功能提供根信任功能，包括与*固件受信平台模块*（*fTPM*）的软硬件接口（通常，TPM
    是端点设备上的专用芯片，用于硬件认证，并且通常包含独立的固件）。自英特尔第六代 CPU 起，英特尔 ME 是一款基于 x86 架构的微控制器。'
- en: '**Intel Active Management Technology (AMT)** The hardware and firmware platform
    used for managing personal computers and servers remotely. It provides remote
    access to monitors, keyboards, and other devices. It comprises Intel’s chipset-based
    Baseboard Management Controller technology for client-oriented platforms (discussed
    next), integrated into Intel’s ME.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**英特尔主动管理技术 (AMT)** 是用于远程管理个人计算机和服务器的硬件和固件平台。它提供对显示器、键盘和其他设备的远程访问。它包括英特尔基于芯片组的基础板管理控制器技术，专为客户平台设计（稍后讨论），并集成在英特尔的
    ME 中。'
- en: '**Baseboard Management Controller (BMC)** A set of computer interface specifications
    for an autonomous computer subsystem that provides management and monitoring capabilities
    independently of the host system’s CPU, UEFI firmware, and real-time operating
    system. The BMC is usually implemented on a separate chip with its own ethernet
    network interface and firmware.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础板管理控制器 (BMC)** 是一套计算机接口规范，用于管理和监控计算机子系统，该子系统独立于主机系统的 CPU、UEFI 固件和实时操作系统运行。BMC
    通常在一个独立的芯片上实现，具有自己的以太网网络接口和固件。'
- en: '**System Management Controller (SMC)** A microcontroller on the logic board
    that controls the power functions and sensors. It’s most commonly found in computers
    produced by Apple.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统管理控制器 (SMC)** 是一款位于主板上的微控制器，用于控制电源功能和传感器。它通常出现在苹果生产的计算机中。'
- en: Every firmware unit is an opportunity for an attacker to store and execute code,
    and all units depend on one another to maintain their integrity. As an example,
    Alex Matrosov identified an issue in recent Gigabyte hardware wherein the ME allowed
    its memory regions to be written to and read from the BIOS. When combined with
    a weak Intel Boot Guard configuration, this issue allowed us to bypass the hardware’s
    Boot Guard implementation completely. (See CVE-2017–11313 and CVE-2017–11314 for
    more information about this vulnerability, which the vendor has since confirmed
    and patched.) We’ll discuss implementations of Boot Guard and possible ways to
    bypass them later in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个固件单元都可能成为攻击者存储和执行代码的机会，而所有单元又相互依赖以保持完整性。例如，Alex Matrosov 发现了近期某些技嘉硬件中的一个问题，ME
    允许其内存区域被写入并从 BIOS 中读取。结合弱配置的英特尔启动保护，这个问题使我们能够完全绕过硬件的启动保护实现。（更多关于此漏洞的信息，请参考 CVE-2017–11313
    和 CVE-2017–11314，供应商已确认并修复了此问题。）我们将在本章稍后讨论启动保护的实现及绕过方法。
- en: The primary objective of a BIOS rootkit is to maintain a persistent and stealthy
    infection, just like the kernel-mode rootkits and MBR/VBR bootkits described in
    the book so far. However, a BIOS rootkit may have additional interesting goals.
    It might, for instance, try to temporarily gain control of the System Management
    Mode (SMM) or nonprivileged Driver Execution Environment (DXE; executed outside
    of SMM) to conduct hidden operations with memory or the filesystem. Even a nonpersistent
    attack executed from the SMM can bypass security boundaries in modern Windows
    systems, including virtualization-based security (VBS) and instances of virtual
    machine guests.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS rootkit 的主要目标是保持持续且隐蔽的感染，就像书中描述的内核模式 rootkit 和 MBR/VBR 启动根kit一样。然而，BIOS
    rootkit 可能有额外的有趣目标。例如，它可能尝试临时控制系统管理模式（SMM）或非特权驱动程序执行环境（DXE；在 SMM 之外执行），以进行内存或文件系统的隐藏操作。即使是从
    SMM 执行的非持久性攻击，也能够绕过现代 Windows 系统中的安全边界，包括基于虚拟化的安全（VBS）和虚拟机来宾实例。
- en: '**Classifying UEFI Firmware Vulnerabilities**'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分类 UEFI 固件漏洞**'
- en: Before digging into the vulnerabilities, let’s classify the kinds of security
    flaws a BIOS implant installation might target. All the classes of vulnerabilities
    shown in [Figure 16-2](ch16.xhtml#ch16fig02) can help an attacker violate security
    boundaries and install persistent implants.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究漏洞之前，让我们先分类 BIOS 植入安装可能针对的安全缺陷类型。[图 16-2](ch16.xhtml#ch16fig02) 中展示的所有漏洞类别都可以帮助攻击者突破安全边界并安装持久性植入物。
- en: Intel researchers first attempted to classify UEFI firmware vulnerabilities
    according to the potential impact of an attack on that vulnerability. They presented
    their classifications at Black Hat USA 2017 in Las Vegas in their talk “Firmware
    Is the New Black—Analyzing Past Three Years of BIOS/UEFI Security Vulnerabilities”
    (*[https://www.youtube.com/watch?v=SeZO5AYsBCw](https://www.youtube.com/watch?v=SeZO5AYsBCw)*),
    which covered different classes of security issues as well as some mitigations.
    One of its most important contributions is the statistics on the growth in the
    total number of security issues processed by Intel PSIRT.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔研究人员首次尝试根据攻击对漏洞潜在影响的不同，来对 UEFI 固件漏洞进行分类。他们在 2017 年的 Black Hat USA 大会上，展示了他们的分类方法，主题为“固件是新的黑色——分析过去三年
    BIOS/UEFI 安全漏洞”（* [https://www.youtube.com/watch?v=SeZO5AYsBCw](https://www.youtube.com/watch?v=SeZO5AYsBCw)*），该演讲涵盖了不同类别的安全问题以及一些缓解措施。它的一个重要贡献是提供了英特尔
    PSIRT 处理的安全问题总数增长的统计数据。
- en: We have a different classification of security issues related to UEFI firmware
    that focuses on the impact of firmware rootkits, shown in [Figure 16-2](ch16.xhtml#ch16fig02).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一种不同的安全问题分类方法，专注于固件 rootkit 的影响，如 [图 16-2](ch16.xhtml#ch16fig02) 所示。
- en: '**NOTE**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The threat model represented in [Figure 16-2](ch16.xhtml#ch16fig02) covers
    only flows related to UEFI firmware, but the scope of security issues for Intel
    ME and AMT is increasing significantly. Additionally, in the past few years, the
    BMC has emerged as a very important security asset for remote management server
    platforms and is getting a lot of attention from researchers.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*[图 16-2](ch16.xhtml#ch16fig02) 中表示的威胁模型仅涵盖与 UEFI 固件相关的流量，但英特尔 ME 和 AMT 的安全问题范围正在显著增加。此外，近年来，BMC
    已成为远程管理服务器平台非常重要的安全资产，并且受到了研究人员的高度关注。*'
- en: '![image](../images/16fig02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/16fig02.jpg)'
- en: '*Figure 16-2: A classification of BIOS vulnerabilities useful for installing
    BIOS implants*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-2：适用于安装 BIOS 植入物的 BIOS 漏洞分类*'
- en: 'We can categorize the vulnerability classes proposed in [Figure 16-2](ch16.xhtml#ch16fig02)
    by how they are used, giving us two major groups: *post-exploitation* and *compromised
    supply chain*.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据漏洞的使用方式对 [图 16-2](ch16.xhtml#ch16fig02) 中提出的漏洞类别进行分类，分为两大类：*后期利用* 和 *受损供应链*。
- en: '***Post-Exploitation Vulnerabilities***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***后期利用漏洞***'
- en: Post-exploitation vulnerabilities are usually used as the second stage in delivering
    malicious payloads (this exploitation scheme is explained in [Chapter 15](ch15.xhtml#ch15)).
    This is the main category of vulnerabilities that attackers take advantage of
    to install both persistent and non-persistent implants after they’ve successfully
    exploited previous stages of attack. The following are the classes for the main
    implants, exploits, and vulnerabilities in this category.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 后渗透漏洞通常被用作传递恶意载荷的第二阶段（该利用方案在[第15章](ch15.xhtml#ch15)中有详细解释）。这是攻击者利用的主要漏洞类别，在成功利用先前攻击阶段后安装持久和非持久植入物的过程中被利用。以下是此类别中主要植入物、利用和漏洞的类别。
- en: '**Secure Boot bypass** Attackers focus on compromising the Secure Boot process
    over exploiting root of trust (that is, full compromise) or another vulnerability
    in one of the boot stages. Secure Boot bypasses can occur at different boot stages
    and can be leveraged by the attacker against all the subsequent layers and their
    trust mechanisms.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全启动绕过** 攻击者专注于绕过安全启动过程，而不是利用信任根（即完全妥协）或引导阶段中的其他漏洞。安全启动绕过可以发生在不同的引导阶段，并且可以被攻击者用来针对所有后续层和它们的信任机制。'
- en: '**SMM privilege escalation** SMM has a lot of power on x86 hardware, as almost
    all privilege escalation issues for SMM end up as code execution issues. Privilege
    escalation to SMM is often one of the final stages of a BIOS implant installation.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**SMM特权升级** SMM在x86硬件上具有很强的功能，因为几乎所有的SMM特权升级问题最终都会成为代码执行问题。提升到SMM的特权往往是BIOS植入物安装的最后阶段之一。'
- en: '**UEFI firmware implant** A UEFI firmware implant is the final stage of a persistent
    BIOS implant installation. The attacker can install the implant on various levels
    of the UEFI firmware, either as a modified legitimate module or a stand-alone
    driver like DXE or PEI, which we’ll discuss later.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**UEFI固件植入物** UEFI固件植入物是持久BIOS植入物安装的最终阶段。攻击者可以将植入物安装在UEFI固件的各个级别上，可以是修改后的合法模块，也可以是后续将讨论的DXE或PEI等独立驱动程序。'
- en: '**Persistent implant** A persistent implant is one that can survive full reboot
    and shutdown cycles. In some cases, in order to survive the post-update process,
    it can modify BIOS update images before those updates are installed.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**持久植入物** 持久植入物是可以在完全重启和关机周期中存活的植入物。在某些情况下，为了在后续更新过程中存活，它可以修改BIOS更新映像。'
- en: '**Non-persistent implant** A non-persistent implant is one that doesn’t survive
    full reboot and shutdown cycles. These implants might provide privilege escalation
    and code execution inside the OS with protected hardware virtualization (such
    as Intel VT-x) and layers of trusted execution (such as MS VBS). They can also
    be used as covert channels to deliver malicious payloads to the kernel mode of
    the operating system.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**非持久植入物** 非持久植入物是不能在完全重启和关机周期中存活的植入物。这些植入物可能会提供特权升级，并在具有受保护硬件虚拟化（如Intel VT-x）和受信任执行层（如MS
    VBS）的操作系统中提供代码执行。它们还可以用作向操作系统内核模式传递恶意载荷的隐蔽通道。'
- en: '***Compromised Supply Chain Vulnerabilities***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***受损供应链漏洞***'
- en: '*Compromised supply chain attacks* take advantage of mistakes made by the BIOS
    development team or the OEM hardware vendor, or they involve deliberate misconfigurations
    of the target software that provide attackers with a deniable bypass of the platform’s
    security features.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*受损供应链攻击* 利用BIOS开发团队或OEM硬件供应商的错误，或涉及目标软件的故意配置错误，从而提供给攻击者对平台安全特性的可否认绕过。'
- en: In supply chain attacks, an attacker gets access to the hardware during its
    production and manufacturing processes and injects malicious modifications to
    the firmware or installs malicious peripheral devices before the hardware ever
    gets to the consumer. Supply chain attacks can also happen remotely, as when an
    attacker gains access to the firmware developer’s internal network (or sometimes
    a vendor website) and delivers malicious modifications directly into the source
    code repository or build server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在供应链攻击中，攻击者在硬件生产和制造过程中获取硬件访问权限，并在硬件到达消费者之前向固件注入恶意修改或安装恶意外围设备。供应链攻击也可以远程发生，例如当攻击者获取固件开发者内部网络（有时是供应商网站）的访问权限，并直接将恶意修改传递到源代码存储库或构建服务器中。
- en: Supply chain attacks with physical access involve covertly meddling with the
    target platform, and they sometimes have similarities with *evil maid attacks*,
    when attackers have physical access for a limited time during which they exploit
    a supply chain vulnerability. These attacks take advantage of situations in which
    the hardware’s owner can’t monitor physical access to the hardware—such as when
    the owner leaves a laptop in a checked bag, surrenders it for a foreign customs
    inspection, or simply forgets it in a hotel room. An attacker can use these opportunities
    to misconfigure hardware and firmware to deliver BIOS implants or just physically
    flash malicious firmware to the SPI flash chip.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 具有物理访问权限的供应链攻击涉及悄悄干扰目标平台，它们有时与*邪恶女仆攻击*相似，攻击者在有限的时间内拥有物理访问权限，并利用供应链漏洞进行攻击。这些攻击利用了硬件所有者无法监控物理访问的情况——例如，当所有者将笔记本电脑放入托运行李中，交给外方海关检查，或者仅仅忘记在酒店房间里。攻击者可以利用这些机会重新配置硬件和固件，植入BIOS或直接将恶意固件写入SPI闪存芯片。
- en: Most of the following issues apply to supply chain and evil maid attack scenarios.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下大多数问题适用于供应链和邪恶女仆攻击场景。
- en: '**Misconfigured protections** By attacking the hardware or firmware during
    the development process or post-production stage, an attacker can misconfigure
    technology protections to allow them to be bypassed easily later.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置错误的保护措施** 通过在开发过程或生产后阶段攻击硬件或固件，攻击者可以错误配置技术保护措施，以便在后续轻松绕过它们。'
- en: '**Nonsecure root of trust** This vulnerability involves compromising the root
    of trust from the operating system via its communication interfaces with firmware
    (SMM, for example).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**不安全的信任根** 该漏洞涉及通过操作系统与固件（例如SMM）的通信接口来破坏信任根。'
- en: '**Malicious peripheral devices** This kind of attack involves implanting peripheral
    devices during the production or delivery stages. Malicious devices can be used
    in multiple ways, such as for *Direct Memory Access (DMA)* attacks.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**恶意外设** 这种攻击涉及在生产或交付阶段植入恶意外设。恶意设备可以以多种方式被使用，例如进行*直接内存访问（DMA）*攻击。'
- en: '**Implanted BIOS updates** An attacker may compromise a vendor website or another
    remote update mechanism and use it to deliver an infected BIOS update. The points
    of compromise can include the vendor’s build servers, developer systems, or stolen
    digital certificates with the vendor’s private keys.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**植入的BIOS更新** 攻击者可能会破坏供应商网站或其他远程更新机制，利用它来传送感染了的BIOS更新。攻击的突破点可能包括供应商的构建服务器、开发者系统或被窃取的数字证书与供应商的私钥。'
- en: '**Unauthenticated BIOS update process** Vendors may break the authentication
    process for BIOS updates, whether intentionally or not, allowing attackers to
    apply any modifications they want to the update images.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**未经认证的BIOS更新过程** 供应商可能会破坏BIOS更新的认证过程，无论是有意还是无意，从而允许攻击者对更新镜像进行任何他们想要的修改。'
- en: '**Outdated BIOS with known security issues** BIOS developers might continue
    to use older, vulnerable code versions of BIOS firmware, even after the underlying
    codebase has been patched, which makes the firmware vulnerable to attack. An outdated
    version of the BIOS originally delivered by the hardware vendor is likely to persist,
    without updates, on the users’ PCs or data center servers. This is one of the
    most common security failures involving BIOS firmware.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**具有已知安全问题的过时BIOS** BIOS开发人员可能会继续使用较旧的、存在漏洞的BIOS固件版本，即使基础代码库已经修补，这使得固件容易受到攻击。硬件供应商最初交付的过时BIOS版本可能会在用户的个人电脑或数据中心服务器上长期存在而没有更新。这是BIOS固件中最常见的安全问题之一。'
- en: '***Supply Chain Vulnerability Mitigation***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***供应链漏洞缓解***'
- en: It’s very hard to mitigate risks related to supply chains without making radical
    changes to the development and production lifecycles. The typical production client
    or server platform includes a lot of third-party components, in both software
    and hardware. Most companies that don’t own their full production cycle don’t
    care too much about security, nor can they really afford to.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在不对开发和生产生命周期进行根本性改变的情况下，很难减轻与供应链相关的风险。典型的生产客户端或服务器平台包括许多第三方组件，包括软件和硬件。大多数没有完全拥有生产周期的公司对安全性不太关注，也确实负担不起。
- en: The situation is exacerbated by the general lack of information and resources
    related to BIOS security configuration and to chipset configuration. The NIST
    800-147 (“BIOS Protection Guidelines”) and NIST 800-147B (“BIOS Protection Guidelines
    for Servers”) publications serve as a useful starting point but are quickly becoming
    outdated since their initial release in 2011 and update for servers in 2014.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况由于缺乏与 BIOS 安全配置和芯片组配置相关的信息和资源而进一步加剧。NIST 800-147（“BIOS 保护指南”）和 NIST 800-147B（“服务器
    BIOS 保护指南”）出版物作为一个有用的起点，但自 2011 年首次发布以及 2014 年针对服务器更新以来，它们很快就变得过时了。
- en: Let’s dive into the details of some UEFI firmware attacks to fill some of these
    gaps in widespread knowledge.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一些 UEFI 固件攻击，以填补这些普遍知识的空白。
- en: '**A History of UEFI Firmware Protections**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**UEFI 固件保护的历史**'
- en: In this section, we’ll go over some classes of vulnerabilities that allow an
    attacker to bypass Secure Boot; we’ll discuss specific Secure Boot implementation
    details in the next chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些允许攻击者绕过安全启动的漏洞类别；我们将在下一章讨论具体的安全启动实施细节。
- en: 'Previously, any security issue that allowed the attacker to execute code in
    the SMM environment could bypass Secure Boot. Though some modern hardware platforms,
    even with recent hardware updates, are still vulnerable to SMM-based Secure Boot
    attacks, most enterprise vendors have shifted to using the newest Intel security
    features, which make these attacks harder. Today’s Intel technologies, such as
    Intel Boot Guard and BIOS Guard (both of which will be discussed later in this
    chapter), move the boot process’s root of trust from SMM to a more secure environment:
    the Intel ME firmware/hardware.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，任何允许攻击者在 SMM 环境中执行代码的安全问题都可以绕过安全启动。尽管一些现代硬件平台，即使经过了最近的硬件更新，仍然容易受到基于 SMM 的安全启动攻击，但大多数企业供应商已经转向使用最新的英特尔安全功能，这使得这些攻击变得更加困难。今天的英特尔技术，如英特尔启动保护（Intel
    Boot Guard）和 BIOS 保护（BIOS Guard，稍后将在本章中讨论），将启动过程的信任根从 SMM 转移到一个更安全的环境：英特尔 ME 固件/硬件。
- en: '**ROOT OF TRUST**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**信任根**'
- en: The root of trust is a proven cryptographic key represented as the anchor for
    Secure Boot. Secure Boot establishes a hardware-validated boot process to ensure
    the platform can be started only with trusted code that has been verified successfully
    with the root of trust. Modern platform designs lock their root of trust in hardware-based
    protected storage, such as one-time programmable fuses or a separate chip with
    persistent storage.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 信任根是一个经过验证的加密密钥，作为安全启动的锚点。安全启动通过建立一个硬件验证的启动过程，确保平台只能使用已经通过信任根验证的受信任代码启动。现代平台设计将其信任根锁定在基于硬件的受保护存储中，例如一次性可编程熔丝或带有持久存储的独立芯片。
- en: The first version of UEFI Secure Boot was introduced in 2012\. Its main components
    included a root of trust implemented in the DXE boot phase (one of the latest
    stages in UEFI firmware boot, just before the OS receives control). That meant
    this early implementation of Secure Boot only really ensured the integrity of
    the OS bootloaders, not the BIOS itself.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 安全启动的第一个版本在 2012 年推出。它的主要组成部分包括在 DXE 启动阶段（UEFI 固件启动的最新阶段之一，操作系统接管控制之前）实现的信任根。这意味着这个早期的安全启动实现只真正确保了操作系统引导程序的完整性，而不是
    BIOS 本身。
- en: Soon the weaknesses of this design became clear, and in the next implementation,
    the root of trust was moved to PEI, an early platform initialization stage, where
    it was locked before DXE. That security boundary also proved weak. Since 2013,
    with the release of the Intel Boot Guard technology, the root of trust has been
    locked into hardware by way of the TPM chip (or equivalent functionality implemented
    in ME firmware to reduce the cost of support). Field-programmable fuses (FPFs)
    are located in the motherboard chipset (the PCH component, programmable via ME
    firmware).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，这一设计的弱点变得显而易见，在下一个实施中，信任根被移至 PEI，这是平台初始化的早期阶段，在 DXE 之前就将其锁定。然而，这个安全边界也证明是脆弱的。自
    2013 年起，随着英特尔启动保护技术的发布，信任根通过 TPM 芯片（或在 ME 固件中实现的等效功能，以降低支持成本）锁定在硬件中。现场可编程熔丝（FPF）位于主板芯片组（PCH
    组件，通过 ME 固件可编程）。
- en: Before we dig into the history of the relevant exploitations that motivated
    these redesigns, let’s discuss how basic BIOS protection technologies work.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨促使这些重新设计的相关漏洞历史之前，让我们先讨论一下基本的 BIOS 保护技术如何工作。
- en: '***How BIOS Protections Work***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***BIOS 保护如何工作***'
- en: '[Figure 16-3](ch16.xhtml#ch16fig03) shows a high-level view of the technologies
    used to protect persistent SPI flash storage. The SMM was originally allowed both
    read and write access to SPI flash storage as a means of implementing routine
    BIOS updates. This meant the integrity of the BIOS was dependent on the code quality
    of *any* code running in the SMM, as any such code would be able to modify the
    BIOS in the SPI storage. The security boundary was therefore as weak as the weakest
    code ever run in SMM that had access to the memory region outside of it. As a
    result, platform developers took steps to separate BIOS updates from the rest
    of the SMM functionality, introducing a series of additional security controls,
    such as Intel BIOS Guard.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 16-3](ch16.xhtml#ch16fig03)显示了用于保护持久 SPI 闪存存储的技术的高级视图。SMM 最初允许对 SPI 闪存存储进行读写访问，以便实现常规的
    BIOS 更新。这意味着 BIOS 的完整性依赖于 *任何* 在 SMM 中运行的代码的质量，因为任何此类代码都可以修改 SPI 存储中的 BIOS。因此，安全边界的强度仅与运行在
    SMM 中的最弱代码的强度相同，而这些代码又有权限访问 SMM 之外的内存区域。因此，平台开发者采取措施将 BIOS 更新与 SMM 的其他功能分开，引入了一系列附加的安全控制措施，例如英特尔
    BIOS Guard。'
- en: '![image](../images/16fig03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/16fig03.jpg)'
- en: '*Figure 16-3: High-level representation of BIOS security technologies*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-3：BIOS 安全技术的高级表示*'
- en: '***SPI Flash Protections and Their Vulnerabilities***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SPI 闪存保护及其漏洞***'
- en: 'We discussed some of the controls shown in [Figure 16-3](ch16.xhtml#ch16fig03)
    in “[(In)Effectiveness of Memory Protection Bits](ch15.xhtml#ch15lev2sec5)” on
    [page 263](ch15.xhtml#page_263): the BIOS Control Bit Protection (BIOS_CNTL),
    the Flash Configuration Lock-Down (FLOCKDN), and the SPI flash Write Protection
    (PRx). However, the BIOS_CNTL protections are effective only against an attacker
    attempting to modify the BIOS from the OS, and they can be bypassed by any code
    execution vulnerability from SMM (SMI handlers accessible from outside), as SMM
    code can freely change these protection bits. Basically, BIOS_CNTL only creates
    an illusion of security.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“[(内存保护位的(无)效力](ch15.xhtml#ch15lev2sec5)”第[263页](ch15.xhtml#page_263)中讨论了[图
    16-3](ch16.xhtml#ch16fig03)中显示的一些控制：BIOS 控制位保护（BIOS_CNTL）、闪存配置锁定（FLOCKDN）和 SPI
    闪存写保护（PRx）。然而，BIOS_CNTL 保护仅对尝试从操作系统修改 BIOS 的攻击者有效，并且它可以通过任何来自 SMM 的代码执行漏洞绕过（SMI
    处理程序可以从外部访问），因为 SMM 代码可以自由修改这些保护位。基本上，BIOS_CNTL 仅创建了一种安全的假象。
- en: Originally, the SMM had both read and write access to SPI Flash storage so it
    could implement routine BIOS updates. This made the integrity of the BIOS dependent
    on the quality of *any* code running in the SMM with calls to outside memory regions,
    as any such code was able to modify the BIOS in the SPI storage. This security
    boundary proved rather weak—as weak as the weakest code ever running in SMM.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，SMM 对 SPI 闪存存储既有读访问权限也有写访问权限，因此可以实现常规的 BIOS 更新。这使得 BIOS 的完整性依赖于 *任何* 在 SMM
    中运行的代码的质量，因为任何此类代码都能够修改 SPI 存储中的 BIOS。这个安全边界证明是相当脆弱的——脆弱程度与 SMM 中运行的最弱代码相当。
- en: As a result, platform developers took steps to separate BIOS updates from the
    rest of SMM functionality. Many of these controls themselves were rather weak.
    An example is the BIOS Control Bit Protection (BIOS_CNTL), which is effective
    only against an attacker attempting to modify the BIOS from the operating system;
    it can be bypassed by any code execution vulnerability from SMM, since SMM code
    can freely change these protection bits.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，平台开发者采取措施将 BIOS 更新与 SMM 的其他功能分离。这些控制本身往往较弱。例如，BIOS 控制位保护（BIOS_CNTL）仅对尝试从操作系统修改
    BIOS 的攻击者有效；任何来自 SMM 的代码执行漏洞都可以绕过该保护，因为 SMM 代码可以自由修改这些保护位。
- en: The PRx control is more effective because its policies can’t be changed from
    the SMM. However, as we’ll discuss shortly, many vendors don’t use PRx protections—including
    Apple and, surprisingly, Intel, the inventor of this protection technology.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: PRx 控制更有效，因为其政策无法从 SMM 中更改。然而，正如我们稍后将讨论的那样，许多厂商并未使用 PRx 保护——包括 Apple 和令人惊讶的
    Intel，尽管它是这种保护技术的发明者。
- en: '[Table 16-1](ch16.xhtml#ch16tab01) summarizes the state of active protection
    technologies based on security lock bits on x86-based hardware used by popular
    vendors as of January 2018\. Here, RP indicates *read protections* and WP *write
    protections*.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-1](ch16.xhtml#ch16tab01)总结了截至 2018 年 1 月，流行厂商基于安全锁位的 x86 硬件的活动保护技术状态。在此，RP
    表示 *读取保护*，WP 表示 *写入保护*。'
- en: '**Table 16-1:** Security Level of Popular Hardware Vendors'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 16-1：** 常见硬件厂商的安全级别'
- en: '| **Vendor name** | **BLE** | **SMM_BWP** | **PRx** | **Authenticated update**
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **厂商名称** | **BLE** | **SMM_BWP** | **PRx** | **认证更新** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **ASUS** | Active | Active | Not active | Not active |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **华硕** | 激活 | 激活 | 未激活 | 未激活 |'
- en: '| **MSI** | Not active | Not active | Not active | Not active |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **微星** | 未激活 | 未激活 | 未激活 | 未激活 |'
- en: '| **Gigabyte** | Active | Active | Not active | Not active |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **技嘉** | 激活 | 激活 | 未激活 | 未激活 |'
- en: '| **Dell** | Active | Active | RP/WP | Active |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **戴尔** | 激活 | 激活 | RP/WP | 激活 |'
- en: '| **Lenovo** | Active | Active | RP | Active |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **联想** | 激活 | 激活 | RP | 激活 |'
- en: '| **HP** | Active | Active | RP/WP | Active |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **惠普** | 激活 | 激活 | RP/WP | 激活 |'
- en: '| **Intel** | Active | Active | Not active | Active |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **英特尔** | 激活 | 激活 | 未激活 | 激活 |'
- en: '| **Apple** | Not active | Not active | WP | Active |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **苹果** | 未激活 | 未激活 | WP | 激活 |'
- en: As you can see, vendors differ wildly in their approaches to BIOS security.
    Some of these vendors don’t even authenticate BIOS updates, thereby creating a
    serious security concern because it is far easier to install implants (unless
    the vendor enforces Intel Boot Guard policies).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，厂商在 BIOS 安全性上的做法差异巨大。一些厂商甚至不对 BIOS 更新进行认证，这就带来了严重的安全隐患，因为安装植入程序变得更加容易（除非厂商强制执行
    Intel Boot Guard 策略）。
- en: Moreover, PRx protections must be configured correctly to be effective. [Listing
    16-1](ch16.xhtml#ch16list01) shows an example of poorly configured flash regions
    with all PRx segment definitions set to zero, rendering them useless.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，PRx 保护必须正确配置才能生效。[列表 16-1](ch16.xhtml#ch16list01) 显示了一个配置不当的闪存区域示例，所有 PRx
    段定义都设置为零，使其无法使用。
- en: '[PRE0]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 16-1: Poorly configured PRx access policies (dumped by Chipsec tool)*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16-1：配置不当的 PRx 访问策略（由 Chipsec 工具导出）*'
- en: We’ve also seen some vendors configure policies for read protection only, which
    still allows the attacker to modify SPI flash. Furthermore, PRx doesn’t guarantee
    any type of integrity measurements on the actual contents of SPI, as it only implements
    bit-based locking of direct read/write access in the very early PEI stage of the
    boot process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到一些厂商配置了仅限读取保护的策略，这仍然允许攻击者修改 SPI 闪存。此外，PRx 并不能保证对 SPI 实际内容的任何完整性度量，因为它仅在启动过程的非常早期
    PEI 阶段实现了对直接读写访问的按位锁定。
- en: The reason vendors like Apple and Intel tend to disable PRx protections is that
    these protections require an immediate reboot, making updating the BIOS less convenient.
    Without PRx protections, a vendor’s BIOS update tool can write the new BIOS image
    into a free region of physical memory using OS APIs, then call an SMI interrupt,
    so that some helper code residing in the SMM can take the image from that region
    and write it into SPI flash. The updated SPI flash image takes control on the
    next reboot, but that reboot can occur in the future at the user’s convenience.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一些厂商如苹果和英特尔倾向于禁用 PRx 保护的原因是，这些保护需要立即重启，使得 BIOS 更新变得不太方便。没有 PRx 保护时，厂商的 BIOS
    更新工具可以使用操作系统 API 将新的 BIOS 镜像写入物理内存中的空闲区域，然后调用 SMI 中断，使得驻留在 SMM 中的某些辅助代码可以从该区域获取镜像并将其写入
    SPI 闪存。更新后的 SPI 闪存镜像将在下次重启时接管控制，但该重启可以在用户方便时进行。
- en: When PRx is enabled and configured correctly to protect the appropriate regions
    of the SPI from modifications made by SMM code, the BIOS updater tool no longer
    can use the SMM to modify the BIOS. Instead, it must store the update image in
    dynamic random access memory (DRAM) and trigger an immediate reboot. The helper
    code to install the update must be part of a special early boot-stage driver,
    which runs before PRx protections are activated and transfers the update image
    from DRAM to SPI. This method of update sometimes requires a reboot (or a call
    to the SMI handler directly without reboot) right when the tool runs, which is
    a lot less convenient for the user.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PRx 被启用并正确配置以保护 SPI 的适当区域免受 SMM 代码修改时，BIOS 更新工具将无法再使用 SMM 来修改 BIOS。相反，它必须将更新镜像存储在动态随机存取内存（DRAM）中，并触发立即重启。安装更新的辅助代码必须是一个特殊的早期启动阶段驱动程序的一部分，该驱动程序在
    PRx 保护激活之前运行，并将更新镜像从 DRAM 转移到 SPI。这种更新方法有时需要在工具运行时进行重启（或直接调用 SMI 处理程序而不重启），这对用户来说不太方便。
- en: No matter which route the BIOS updater takes, it’s critical that the helper
    code authenticate the update image before installing it. Otherwise, PRx or no
    PRx, reboot or no reboot, the helper code will happily install an altered BIOS
    image with an implant, so long as the attacker manages to modify it at some point
    before the helper runs. As [Table 16-1](ch16.xhtml#ch16tab01) shows, some hardware
    vendors don’t authenticate firmware updates, making the attacker’s job as easy
    as tampering with the update image.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 无论BIOS更新程序采取哪种方式，都必须确保助手代码在安装之前认证更新镜像。否则，无论是否启用PRx，是否重启，助手代码都会毫不犹豫地安装一个经过修改的带有植入物的BIOS镜像，只要攻击者在助手代码运行之前能够修改该镜像。如[表16-1](ch16.xhtml#ch16tab01)所示，一些硬件供应商不认证固件更新，这使得攻击者的任务变得简单，只需篡改更新镜像即可。
- en: '**FIRST PUBLICLY KNOWN ATTACK ON THE BIOS UPDATE PROCESS**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一次公开已知的BIOS更新过程攻击**'
- en: Keep in mind that even if you correctly configure PRx and authenticate the BIOS
    updates’ cryptographic signatures, you could still be susceptible to attacks.
    The first publicly known attack against an authenticated and signed BIOS update
    process armed with active SPI flash protection bits was presented in “Attacking
    Intel BIOS” by Rafal Wojtczuk and Alex Tereshkin at Black Hat Vegas in 2009\.
    The authors demonstrated a memory corruption vulnerability inside the parser for
    the BIOS update image file that led to arbitrary code execution and bypassed authentication
    of the update file’s signature.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使你正确配置了PRx并认证了BIOS更新的加密签名，你仍然可能会受到攻击。2009年，Rafal Wojtczuk和Alex Tereshkin在Black
    Hat Vegas大会上提出了第一次公开已知的攻击，目标是一个经过认证和签名的BIOS更新过程，该过程装备了活跃的SPI闪存保护位。作者展示了BIOS更新镜像文件解析器中的内存损坏漏洞，该漏洞导致了任意代码执行，并绕过了更新文件签名的认证。
- en: '***Risks Posed by an Unauthenticated BIOS Update***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***未经认证的BIOS更新所带来的风险***'
- en: 'In September 2018, the antivirus company ESET released a research report about
    LOJAX, a rootkit that attacked UEFI firmware from the OS.^([1](footnotes.xhtml#ch16fn1))
    All of the techniques used by the LOJAX rootkit were well-known at the time of
    the attack, having been used in other discovered malware over the previous five
    years. LOJAX used tactics similar to those of the Hacking Team’s UEFI rootkit:
    it abused the unauthenticated Computrace components stored in the NTFS, as we
    discussed in [Chapter 15](ch15.xhtml#ch15). Thus, the LOJAX rootkit doesn’t use
    any new vulnerabilities; its only novelty is in how it infects the targets—it
    checks the systems for unauthenticated access to the SPI flash and, finding it,
    delivers a modified BIOS update file.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年9月，反病毒公司ESET发布了一份关于LOJAX的研究报告，LOJAX是一种针对UEFI固件的rootkit攻击。[1](footnotes.xhtml#ch16fn1)
    在攻击发生时，LOJAX rootkit所使用的所有技术都是众所周知的，曾在过去五年里出现在其他发现的恶意软件中。LOJAX采用了与黑客团队的UEFI rootkit相似的战术：它滥用了存储在NTFS中的未经认证的Computrace组件，如我们在[第15章](ch15.xhtml#ch15)中讨论的。因此，LOJAX
    rootkit并没有使用任何新漏洞；它唯一的新颖之处在于其感染目标的方式——它检查系统是否存在未经认证的SPI闪存访问，如果找到了，就交付一个经过修改的BIOS更新文件。
- en: Loose approaches to BIOS security present plenty of opportunities for attacks.
    An attacker can scan a system at runtime to find the right vulnerable targets
    and the right infection vector, both of which are plentiful. The LOJAX rootkit
    infector checked for several protections, including the BIOS Lock Bit (BLE) and
    the SMM BIOS Write Protection Bit (SMM_BWP). If the firmware hadn’t been authenticated,
    or if it hadn’t checked the integrity of a BIOS update image before transferring
    it to SPI storage, the attacker could deliver modified updates directly from the
    OS. LOJAX used the Speed Racer vulnerability (VU#766164, originally discovered
    by Corey Kallenberg in 2014) to bypass SPI flash protection bits via a race condition.
    You can detect this vulnerability and other weaknesses related to BIOS lock protection
    bits with the `chipsec_main -m common.bios_wp` command.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对BIOS安全的松懈态度为攻击提供了大量机会。攻击者可以在运行时扫描系统，寻找合适的易受攻击目标和感染向量，而这些都是丰富的。LOJAX rootkit感染者检查了多个保护措施，包括BIOS锁位（BLE）和SMM
    BIOS写保护位（SMM_BWP）。如果固件没有经过认证，或者在将BIOS更新镜像传输到SPI存储之前没有检查其完整性，攻击者就可以直接从操作系统交付修改过的更新。LOJAX使用了Speed
    Racer漏洞（VU#766164，最初由Corey Kallenberg在2014年发现）来通过竞争条件绕过SPI闪存保护位。你可以使用`chipsec_main
    -m common.bios_wp`命令来检测该漏洞及与BIOS锁保护位相关的其他弱点。
- en: This example shows that a security boundary is only as strong as its weakest
    component. No matter what other protections the platform may have, Computrace’s
    loose handling of code authentication undermined them, reenabling the OS-side
    attack vector that the other protections sought to eliminate. It only takes one
    breach of a sea wall to flood the plains.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，安全边界的强度仅取决于其最弱的组成部分。无论平台可能具有其他什么保护，Computrace对代码认证的松散处理都会削弱它们，重新启用了操作系统侧的攻击向量，而其他保护措施正是试图消除这个向量。只需要一处海堤被突破，整个平原就会被淹没。
- en: '***BIOS Protection with Secure Boot***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***具有安全启动的BIOS保护***'
- en: How does Secure Boot change this threat landscape? The short answer is, it depends
    on its implementation. Older versions, implemented before 2016 without Intel Boot
    Guard and BIOS Guard technologies, will be in danger, because in these old implementations,
    the root of trust is in the SPI flash and can be overwritten.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动如何改变这一威胁格局？简短的回答是，这取决于它的实现方式。2016年之前实现的旧版本（没有Intel Boot Guard和BIOS Guard技术）将面临危险，因为在这些旧实现中，信任根位于SPI闪存中，并且可能会被覆盖。
- en: When the first version of UEFI Secure Boot was introduced in 2012, its main
    components included a root of trust implemented in the *DXE boot phase*, which
    is one of the latest stages in UEFI firmware boot, occurring just before the OS
    receives control. Because the root of trust came so late in the boot process,
    this early Secure Boot implementation really assured only the integrity of the
    OS bootloaders, rather than the integrity of the BIOS itself. The weakness of
    this design soon became clear, and in the next implementation, the root of trust
    was moved to *PEI*, an early platform initialization stage, to lock the root of
    trust before DXE. That security boundary also proved weak.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当2012年首次推出UEFI安全启动时，其主要组成部分包括在*DXE启动阶段*实现的信任根，这是UEFI固件启动中的最新阶段之一，发生在操作系统获得控制之前。由于信任根在启动过程中的出现较晚，这一早期的安全启动实现实际上只保证了操作系统引导程序的完整性，而不是BIOS本身的完整性。这种设计的弱点很快显现出来，在下一版本中，信任根被移到了*PEI*，即早期平台初始化阶段，以便在DXE之前锁定信任根。这个安全边界也证明了其脆弱性。
- en: 'Boot Guard and BIOS Guard, more recent additions to Secure Boot, address this
    weakness: Boot Guard moved the root of trust from SPI into hardware, and BIOS
    Guard moved the task of updating the contents of the SPI flash from SMM to a separate
    chip (the Intel Embedded Controller, or EC) and removed the permissions that allowed
    the SMM to write to the SPI flash.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Boot Guard和BIOS Guard是安全启动中较新的功能，解决了这一弱点：Boot Guard将信任根从SPI移到硬件中，而BIOS Guard则将更新SPI闪存内容的任务从SMM转移到一个独立的芯片（Intel嵌入式控制器，简称EC），并移除了允许SMM写入SPI闪存的权限。
- en: Another consideration for moving the root of trust earlier in the boot process,
    and into hardware, is minimizing the boot time of a trusted platform. You could
    imagine a boot protection scheme that would verify digital signatures over dozens
    of individual available EFI images rather than a single image that includes all
    the drivers. However, this would be too slow for today’s world, in which platform
    vendors look to shave milliseconds off the bootup time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个考虑将信任根提早到启动过程中的硬件部分，是最小化可信平台的启动时间。你可以想象一种启动保护方案，它将验证成百上千个可用EFI映像的数字签名，而不是一个包含所有驱动程序的单一映像。然而，这对于今天的世界来说速度太慢，因为平台供应商希望在启动时间上节省毫秒级的时间。
- en: 'At this point, you might be asking: with so many moving parts involved in the
    Secure Boot process, how can we avoid situations in which a trivial bug destroys
    all of its security guarantees? (We’ll cover the full process of Secure Boot in
    [Chapter 17](ch17.xhtml#ch17).) The best answer, to date, is to have tools that
    make sure every component plays its appointed role and that every stage of the
    boot process takes place in the exact intended order. That is to say, we need
    a formal model of the process that automated code analysis tools can validate—and
    that means that the simpler the model, the more confidence we have that it will
    be checked correctly.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会问：既然安全启动过程涉及这么多组件，我们如何避免在其中一个微小的错误摧毁所有安全保障？（我们将在[第17章](ch17.xhtml#ch17)中详细介绍安全启动的完整过程。）迄今为止，最好的答案是拥有能够确保每个组件执行其指定角色的工具，并确保每个启动阶段按照确切的顺序进行。也就是说，我们需要一个过程的正式模型，自动化代码分析工具可以验证它——这意味着模型越简单，我们就越有信心它能被正确检查。
- en: 'Secure Boot relies on a chain of trust: the intended execution path begins
    with the root of trust locked into the hardware or SPI flash storage and moves
    through the stages of the Secure Boot process, which can proceed only in a particular
    order and only if all of the conditions and policies at every stage are satisfied.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动依赖于信任链：预定的执行路径从锁定在硬件或SPI闪存存储中的信任根开始，并通过安全启动过程的各个阶段，只有在每个阶段的所有条件和策略都满足的情况下，才能按特定顺序进行。
- en: Formally speaking, we call this model a *finite state machine*, where different
    states represent different stages of the system boot process. If any of the stages
    has nondeterministic behavior—for example, if a stage can switch the boot process
    into a different mode or have multiple exits—our Secure Boot process becomes a
    nondeterministic finite state machine. This makes the task of automatically verifying
    the Secure Boot process significantly harder, because it exponentially increases
    the number of execution paths we must verify. In our opinion, nondeterministic
    behavior in Secure Boot should be regarded as a design mistake that is likely
    to lead to costly vulnerabilities, as in the case of the S3 Boot Script vulnerability
    discussed later in this chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，我们将这个模型称为*有限状态机*，其中不同的状态代表系统启动过程中的不同阶段。如果任何一个阶段具有非确定性行为——例如，如果一个阶段可以将启动过程切换到不同的模式或有多个退出点——我们的安全启动过程就变成了一个非确定性有限状态机。这使得自动验证安全启动过程变得更加困难，因为它指数级地增加了我们必须验证的执行路径数量。在我们看来，安全启动中的非确定性行为应该被视为一种设计失误，可能会导致代价高昂的漏洞，正如本章稍后讨论的S3启动脚本漏洞一样。
- en: '**Intel Boot Guard**'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**英特尔Boot Guard**'
- en: In this section, we’ll discuss how Intel Boot Guard technology works, then explore
    some of its vulnerabilities. Although Intel has no publicly available official
    documentation about Boot Guard, our research and that of others allow us to paint
    a coherent picture of this remarkable technology.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论英特尔Boot Guard技术的工作原理，然后探讨它的一些漏洞。尽管英特尔没有公开的Boot Guard官方文档，但我们和其他人的研究使我们能够描绘出这项卓越技术的清晰图景。
- en: '***Intel Boot Guard Technology***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***英特尔Boot Guard技术***'
- en: 'Boot Guard divides Secure Boot into two phases: in the first phase, Boot Guard
    authenticates everything located in the BIOS section of the SPI storage, and in
    the second stage, Secure Boot handles the rest of the boot process, including
    authentication of the OS bootloader ([Figure 16-4](ch16.xhtml#ch16fig04)).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Boot Guard将安全启动分为两个阶段：在第一阶段，Boot Guard认证SPI存储器中BIOS部分的所有内容；在第二阶段，安全启动处理其余的启动过程，包括操作系统引导加载程序的认证（[图16-4](ch16.xhtml#ch16fig04)）。
- en: '![image](../images/16fig04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/16fig04.jpg)'
- en: '*Figure 16-4: The boot process with active Intel Boot Guard technology*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-4：启用英特尔Boot Guard技术的启动过程*'
- en: The Intel Boot Guard technology spans several levels of the CPU architecture
    and the related abstractions. One benefit is that it doesn’t need to trust the
    SPI storage, so it’s able to avoid the vulnerabilities we discussed earlier in
    this chapter. Boot Guard separates integrity checking of the BIOS stored in the
    SPI flash from the BIOS itself by using the Authenticated Code Module (ACM), which
    is signed by Intel, to verify the integrity of the BIOS image before allowing
    it to execute. With Boot Guard activated on a platform, the root of trust moves
    inside the Intel microarchitecture, wherein the CPU’s microcode parses the ACM
    contents and checks the digital signature verification routines implemented in
    the ACM, which in turn will check the BIOS signature.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔Boot Guard技术跨越了CPU架构的多个层次及相关抽象层。一个好处是它不需要信任SPI存储，因此能够避免我们在本章前面讨论的漏洞。Boot
    Guard通过使用英特尔签名的认证代码模块（ACM），将SPI闪存中存储的BIOS的完整性检查与BIOS本身分开，从而在允许执行之前验证BIOS映像的完整性。启用Boot
    Guard的设备上，信任根移入英特尔微架构中，其中CPU的微代码解析ACM内容，并检查ACM中实现的数字签名验证程序，进而检查BIOS签名。
- en: By contrast, the original UEFI Secure Boot root of trust resided in the UEFI
    DXE phase, almost the last one before control is passed to the OS bootloader—which
    is, as we’ve mentioned before, very late in the game. If UEFI firmware is compromised
    at the DXE stage, an attacker can completely bypass or disable Secure Boot. Without
    hardware-assisted verification, there is no way to guarantee the integrity of
    the boot process stages that take place before the DXE phase (PEI implementation
    also has confirmed weaknesses), including the integrity of the DXE drivers themselves.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，原始的UEFI安全启动信任根位于UEFI DXE阶段，这几乎是控制权交给操作系统引导加载程序之前的最后一个阶段——正如我们之前提到的，这个时间点非常靠后。如果在DXE阶段固件被妥协，攻击者可以完全绕过或禁用安全启动。如果没有硬件辅助的验证，就无法保证DXE阶段之前发生的启动过程阶段的完整性（PEI实现也存在已知的弱点），包括DXE驱动程序本身的完整性。
- en: Boot Guard addresses this problem by moving the root of trust for Secure Boot
    from the UEFI firmware to the hardware itself. For example, Verified Boot—a recent
    variant of Boot Guard that Intel introduced in 2013, which we’ll discuss in more
    detail in the next chapter—locks the hash of an OEM public key within the field
    programmable fuse (FPF) store. The FPF can be programmed only one time, and the
    hardware vendor locks the configuration by the end of the manufacturing process
    (in some cases this can be revoked, but because these are edge cases, we won’t
    discuss them here).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Boot Guard通过将安全启动的信任根从UEFI固件转移到硬件本身，解决了这个问题。例如，Verified Boot——这是英特尔在2013年引入的Boot
    Guard的一个新变种，我们将在下一章详细讨论——将OEM公钥的哈希值锁定在现场可编程熔丝（FPF）存储区内。FPF只能编程一次，硬件供应商在制造过程结束时锁定该配置（在某些情况下可以撤销，但由于这些属于边缘案例，这里不做讨论）。
- en: '***Vulnerabilities in Boot Guard***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Boot Guard中的漏洞***'
- en: 'Boot Guard’s efficacy depends on all of its components working together, with
    no layer containing any vulnerabilities for the attacker to execute code or to
    elevate privileges in order to interfere with other components of the multilayer
    Secure Boot scheme. Alex Matrosov’s “Betraying the BIOS: Where the Guardians of
    the BIOS Are Failing” (*[https://www.youtube.com/watch?v=Dfl2JI2eLc8](https://www.youtube.com/watch?v=Dfl2JI2eLc8)*),
    presented at Black Hat USA 2017, revealed that an attacker could successfully
    target the scheme by interfering with the bit flags set by the lower levels to
    pass the information about their state of integrity to the upper levels.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Boot Guard的有效性取决于其所有组件的协同工作，每一层都不应包含任何漏洞，避免攻击者执行代码或提升权限，以干扰多层安全启动方案的其他组件。Alex
    Matrosov在2017年Black Hat USA上发布的“背叛BIOS：BIOS的守护者在哪里失败” (*[https://www.youtube.com/watch?v=Dfl2JI2eLc8](https://www.youtube.com/watch?v=Dfl2JI2eLc8)*)
    演讲中揭示了攻击者如何通过干扰较低层设置的位标志，来传递关于其完整性状态的信息给上层，从而成功攻击该方案。
- en: As has been demonstrated, firmware cannot be trusted because most SMM attacks
    can compromise it. Even the Measured Boot scheme, which relies on the TPM as its
    root of trust, can be compromised, because the measuring code itself runs in SMM
    and can in many cases be modified from the SMM, even though the key stored in
    the TPM hardware cannot be changed by SMM. Although some attacks on the TPM chip
    are possible, the SMM privilege–wielding attackers do not need them, as they would
    simply attack the firmware’s interfaces to the TPM. In 2013 Intel introduced Verified
    Boot, which we just mentioned, to address this Measured Boot weakness.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如已证明的那样，固件无法被信任，因为大多数SMM攻击能够妥协它。即使是依赖TPM作为信任根的度量启动方案，也可能被破坏，因为度量代码本身运行在SMM中，并且在许多情况下可以从SMM进行修改，尽管存储在TPM硬件中的密钥无法被SMM更改。尽管对TPM芯片的某些攻击是可能的，但持有SMM权限的攻击者并不需要这些攻击，他们只需攻击固件与TPM的接口。2013年，英特尔引入了Verified
    Boot（我们刚刚提到的）来解决度量启动的弱点。
- en: The Boot Guard ACM verification logic measures the *initial boot block (IBB)*
    and checks its integrity before passing control to the IBB entry point. If IBB
    verification fails, the boot process will generally be interrupted depending on
    the policy. The IBB part of the UEFI firmware (BIOS) executes on a normal CPU
    (not isolated or authenticated). Next, IBB continues the boot process, following
    the Boot Guard policies in the verified or measured mode to the platform initialization
    phase. The PEI driver verifies the integrity of the DXE drivers and transitions
    the chain of trust to the DXE phase. The DXE phase then continues the chain of
    trust to the operating system bootloader. [Table 16-2](ch16.xhtml#ch16tab02) presents
    research data about the state of security in each of these stages across various
    hardware vendors.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 启动保护 ACM 验证逻辑会测量 *初始启动块 (IBB)* 并在将控制权传递到 IBB 入口点之前检查其完整性。如果 IBB 验证失败，启动过程通常会中断，具体取决于策略。UEFI
    固件（BIOS）的 IBB 部分在普通 CPU 上执行（非隔离或认证）。接下来，IBB 会继续启动过程，按照启动保护策略在已验证或已测量模式下进行，进入平台初始化阶段。PEI
    驱动程序验证 DXE 驱动程序的完整性，并将信任链过渡到 DXE 阶段。然后，DXE 阶段继续将信任链传递到操作系统启动加载程序。[表 16-2](ch16.xhtml#ch16tab02)展示了关于各个硬件厂商在这些阶段中安全状态的研究数据。
- en: '**Table 16-2:** How Different Hardware Vendors Configure Security (as of January
    2018)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 16-2：** 不同硬件厂商如何配置安全性（截至 2018 年 1 月）'
- en: '| **Vendor name** | **ME access** | **EC access** | **CPU debugging (DCI)**
    | **Boot Guard** | **Forced Boot Guard ACM** | **Boot Guard FPF** | **BIOS Guard**
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **厂商名称** | **ME 访问** | **EC 访问** | **CPU 调试 (DCI)** | **启动保护** | **强制启动保护
    ACM** | **启动保护 FPF** | **BIOS 保护** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **ASUS VivoMini** | Disabled | Disabled | Enabled | Disabled | Disabled |
    Disabled | Disabled |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **华硕 VivoMini** | 禁用 | 禁用 | 启用 | 禁用 | 禁用 | 禁用 | 禁用 |'
- en: '| **MSI Cubi2** | Disabled | Disabled | Enabled | Disabled | Disabled | Disabled
    | Disabled |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **微星 Cubi2** | 禁用 | 禁用 | 启用 | 禁用 | 禁用 | 禁用 | 禁用 |'
- en: '| **Gigabyte Brix** | Read/write enabled | Read/write enabled | Enabled | Measured
    verified | Enabled (FPF not set) | Not set | Disabled |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **技嘉 Brix** | 启用读写 | 启用读写 | 启用 | 已测量验证 | 启用（FPF 未设置） | 未设置 | 禁用 |'
- en: '| **Dell** | Disabled | Disabled | Enabled | Measured verified | Enabled |
    Enabled | Enabled |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **戴尔** | 禁用 | 禁用 | 启用 | 已测量验证 | 启用 | 启用 | 启用 |'
- en: '| **Lenovo ThinkCenter** | Disabled | Disabled | Enabled | Disabled | Disabled
    | Disabled | Disabled |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **联想 ThinkCenter** | 禁用 | 禁用 | 启用 | 禁用 | 禁用 | 禁用 | 禁用 |'
- en: '| **HP Elitedesk** | Disabled | Disabled | Enabled | Disabled | Disabled |
    Disabled | Disabled |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **惠普 Elitedesk** | 禁用 | 禁用 | 启用 | 禁用 | 禁用 | 禁用 | 禁用 |'
- en: '| **Intel NUC** | Disabled | Disabled | Enabled | Disabled | Disabled | Disabled
    | Disabled |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **英特尔 NUC** | 禁用 | 禁用 | 启用 | 禁用 | 禁用 | 禁用 | 禁用 |'
- en: '| **Apple** | Read enabled | Disabled | Disabled | Not supported | Not supported
    | Not supported | Not supported |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **苹果** | 启用读取 | 禁用 | 禁用 | 不支持 | 不支持 | 不支持 | 不支持 |'
- en: As you can see, catastrophic misconfigurations of these security options are
    not merely theoretical. For example, some vendors have not written their hashes
    in the FPF, or did so but didn’t subsequently disable the manufacturing mode that
    allows such a write. As a result, the attackers can write FPF keys of their own
    and then lock the system, tying it forever to their own root and chain of trust
    (though if the hardware manufacturer has developed a revocation process, a fuse
    overwrite for revocation exists). More precisely, the FPF can be written by the
    ME as its memory regions when the ME is still in the manufacturing mode; the ME
    in that mode, in turn, can be accessed from the OS for both reads and writes.
    In this way, the attacker really gets the keys to the kingdom.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这些安全选项的灾难性配置错误并非仅仅是理论上的。例如，一些厂商没有在 FPF 中写入其哈希值，或者写入了但随后没有禁用允许此类写入的制造模式。因此，攻击者可以写入自己的
    FPF 密钥，然后锁定系统，将其永远绑定到他们自己的根和信任链上（尽管如果硬件厂商已经开发了撤销过程，存在熔丝覆盖用于撤销）。更准确地说，FPF 可以由 ME
    在其内存区域中写入，当 ME 仍处于制造模式时；此时，ME 可以从操作系统进行访问，包括读取和写入。通过这种方式，攻击者实际上获得了“王国的钥匙”。
- en: Additionally, most of the researched Intel-based hardware had CPU debugging
    enabled, so all the doors were open to attackers with physical access to the CPU.
    Some of the platforms included support for the Intel BIOS Guard technology, but
    it was disabled in the manufacturing process to simplify BIOS updates.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大多数研究过的基于Intel的硬件都启用了CPU调试，因此对具有物理访问权限的攻击者来说，所有的“门”都是打开的。部分平台支持Intel BIOS
    Guard技术，但为了简化BIOS更新，该功能在制造过程中被禁用了。
- en: Thus, [Table 16-2](ch16.xhtml#ch16tab02) provides multiple excellent examples
    of supply chain security problems, wherein the vendors trying to simplify supporting
    hardware have created critical security holes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，[表16-2](ch16.xhtml#ch16tab02)提供了多个供应链安全问题的优秀示例，其中厂商为了简化硬件支持，创建了关键的安全漏洞。
- en: '**Vulnerabilities in the SMM Modules**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**SMM模块中的漏洞**'
- en: 'Let’s now look at another vector for exploiting UEFI firmware from the OS:
    leveraging mistakes in the SMM modules.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下从操作系统利用UEFI固件的另一个攻击途径：利用SMM模块中的错误。
- en: '***Understanding SMM***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***理解SMM***'
- en: We’ve discussed SMM and SMI handlers in previous chapters, but we’ll review
    both concepts now as a refresher.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中讨论了SMM和SMI处理程序，但现在我们将重新回顾这两个概念，以便温故知新。
- en: SMM is a highly privileged execution mode of x86 processors. It was designed
    to implement platform-specific management functions independently of the OS. These
    functions include advanced power management, secure firmware updates, and configuration
    of UEFI Secure Boot variables.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: SMM是x86处理器的一种高特权执行模式。它旨在独立于操作系统实现平台特定的管理功能。这些功能包括高级电源管理、安全固件更新和UEFI安全启动变量的配置。
- en: The key design feature of SMM is that it provides a separate execution environment,
    invisible to the OS. The code and data used in SMM are stored in a hardware-protected
    memory region, called *SMRAM*, that is accessible only to code running within
    SMM. To enter SMM, the CPU generates a System Management Interrupt (SMI), a special
    interrupt intended to be raised by the OS software.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: SMM的关键设计特性是，它提供了一个与操作系统不可见的独立执行环境。SMM中使用的代码和数据存储在一个硬件保护的内存区域，称为*SMRAM*，该区域只能由在SMM中运行的代码访问。为了进入SMM，CPU会生成一个系统管理中断（SMI），这是一个旨在由操作系统软件触发的特殊中断。
- en: '*SMI handlers* are the platform firmware’s privileged services and functions.
    The SMI serves as a bridge between the OS and these SMI handlers. Once all the
    necessary code and data have been loaded in SMRAM, the firmware locks the memory
    region so that it can be accessed only by code running in SMM, preventing the
    OS from accessing it.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*SMI处理程序*是平台固件的特权服务和功能。SMI充当操作系统与这些SMI处理程序之间的桥梁。一旦所有必要的代码和数据被加载到SMRAM中，固件会锁定该内存区域，使其只能由在SMM中运行的代码访问，从而防止操作系统访问它。'
- en: '***Exploiting SMI Handlers***'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***利用SMI处理程序***'
- en: Given SMM’s high privilege level, SMI handlers present a very interesting target
    for implants and rootkits. Any vulnerability in these handlers may present an
    opportunity for the attacker to elevate privileges to that of the SMM, the so-called
    Ring –2.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SMM具有高度特权级别，SMI处理程序是植入程序和根套件的一个非常有趣的目标。这些处理程序中的任何漏洞都可能为攻击者提供一个机会，将特权提升到SMM的级别，也就是所谓的Ring
    -2。
- en: As with other multilayer models, such as the kernel-userland separation, the
    best way to attack the privileged code is to target any data that can be consumed
    from outside the isolated privileged memory region. For SMM, this is any memory
    outside the SMRAM. For SMM’s security model, the attacker is the OS or privileged
    software (such as BIOS update tools); thus, any location in the OS that is outside
    the SMRAM is suspect because it can at times be manipulated by an attacker (potentially
    even after it has been somehow checked). Potential targets include function pointers
    consumed by the SMM code that can point execution to areas outside SMRAM or any
    buffers with data that SMM code reads/parses.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他多层模型一样，例如内核与用户空间分离，攻击特权代码的最佳方法是针对任何可以从外部消耗的数据，这些数据可能来自隔离的特权内存区域之外。对于SMM来说，这些数据是任何位于SMRAM之外的内存。对于SMM的安全模型，攻击者通常是操作系统或特权软件（如BIOS更新工具）；因此，操作系统中任何位于SMRAM之外的位置都可能是可疑的，因为它有时会被攻击者操控（甚至可能在经过某种检查之后）。潜在的攻击目标包括SMM代码消费的函数指针，这些指针可能会将执行指向SMRAM之外的区域，或者是任何包含数据的缓冲区，这些数据被SMM代码读取或解析。
- en: Nowadays, UEFI firmware developers try to reduce this attack surface by minimizing
    the number of SMI handlers communicating directly with the outside world (Ring
    0—the kernel mode of the operating system), as well as by finding new ways to
    structure and check these interactions. But this work has only just started, and
    security problems with SMI handlers will likely persist for quite some time.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，UEFI固件开发人员尝试通过最小化与外部世界（Ring 0——操作系统的内核模式）直接通信的SMI处理程序数量，来减少这一攻击面，并通过寻找新的方式来结构化和检查这些交互。但这项工作才刚刚开始，SMI处理程序的安全问题可能会持续相当长一段时间。
- en: Of course, the code in SMM can receive some data from the OS to be useful. However,
    in order to remain secure, just as with other multilayer models, the SMM code
    must never act on the outside data unless it’s been copied and checked inside
    the SMRAM. Any data that’s been checked but left outside the SMRAM can’t be trusted,
    as the attacker could potentially race to change it between the point of check
    and the point of use. Moreover, any data that has been copied in shouldn’t reference
    any unchecked and uncopied outside data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，SMM中的代码可以从操作系统接收一些数据以便发挥作用。然而，为了保持安全性，正如其他多层模型一样，SMM代码必须始终在数据被复制并在SMRAM内检查之后，才可以对外部数据进行处理。任何已被检查但仍保留在SMRAM外的数据都不能被信任，因为攻击者可能会在检查点和使用点之间通过竞态条件改变数据。此外，任何已被复制进来的数据都不应引用任何未经检查且未复制的外部数据。
- en: This sounds simple, but languages like C don’t natively help track the regions
    to which pointers point, and thus the all-important security distinction between
    the “inside” SMRAM memory locations and the “outside,” attacker-controlled, OS
    memory is not necessarily evident in the code. So the programmers are mostly on
    their own. (If you’re wondering how much of this problem can be solved with static
    analysis tools, read on—as it turns out, the SMI calling convention we discuss
    next makes it quite a challenge.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很简单，但像C这样的语言并不会原生帮助追踪指针指向的区域，因此“内部”SMRAM内存位置与“外部”受攻击者控制的操作系统内存之间的安全性差异，在代码中并不总是显而易见。因此，程序员通常只能依靠自己。（如果你在想，这个问题能通过静态分析工具解决多少，继续阅读——事实证明，我们接下来讨论的SMI调用约定使得这个问题变得相当具有挑战性。）
- en: To understand how attackers can exploit SMI handlers, you need to understand
    their calling convention. Although, as [Listing 16-2](ch16.xhtml#ch16list02) shows,
    calls to the SMI handler from the Python side of the Chipsec framework look like
    regular function calls, the actual binary calling convention, shown in [Listing
    16-3](ch16.xhtml#ch16list03), is different.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解攻击者如何利用SMI处理程序，你需要理解它们的调用约定。正如[清单16-2](ch16.xhtml#ch16list02)所示，从Chipsec框架的Python端调用SMI处理程序看起来像普通的函数调用，但实际的二进制调用约定，如[清单16-3](ch16.xhtml#ch16list03)所示，是不同的。
- en: '[PRE1]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 16-2: How to call an SMI handler from Python with the Chipsec framework*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-2：如何通过Chipsec框架从Python调用SMI处理程序*'
- en: The code in [Listing 16-2](ch16.xhtml#ch16list02) calls the SMI handler with
    all the parameters zeroed out except for 0x25, the number of the called handler.
    Such a call may indeed pass no parameters, but it’s also possible that the SMI
    handler retrieves these parameters indirectly—via ACPI or UEFI variables, for
    example—once it gets control. When the operating system triggers SMI (for instance,
    as a software interrupt via I/O port 0xB2), it passes arguments to the SMI handler
    via general-purpose registers. In [Listing 16-3](ch16.xhtml#ch16list03), you can
    see what an actual call to the SMI handler looks like in assembly and how the
    parameters are passed. The Chipsec framework, of course, implements this calling
    convention under the hood.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单16-2](ch16.xhtml#ch16list02)中的代码调用SMI处理程序时，除了0x25（被调用的处理程序编号）外，所有参数都被置为零。这样的调用可能确实不传递任何参数，但也有可能SMI处理程序在获得控制后间接获取这些参数——例如，通过ACPI或UEFI变量。当操作系统触发SMI时（例如，通过I/O端口0xB2作为软件中断），它通过通用寄存器将参数传递给SMI处理程序。在[清单16-3](ch16.xhtml#ch16list03)中，你可以看到SMI处理程序的实际调用方式以及参数是如何传递的。Chipsec框架当然在幕后实现了这一调用约定。'
- en: '[PRE2]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 16-3: An SMI handler call in assembly language*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-3：汇编语言中的SMI处理程序调用*'
- en: '**SMI Callout Issues and Arbitrary Code Execution**'
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**SMI调用问题与任意代码执行**'
- en: 'Most common SMI handler vulnerabilities of interest for BIOS implants fall
    into two major groups: SMI callout issues and arbitrary code execution (which,
    in many cases, is preceded by SMI callout issues). In SMI callout issues, SMM
    code unwittingly uses a function pointer, controlled by the attacker, that points
    at an implant payload outside the SMM. In arbitrary code execution, SMM code consumes
    some data from outside SMRAM that is capable of affecting the control flow and
    can be leveraged for more control. Such addresses are typically below the first
    megabyte of physical memory, as SMI handlers expect to use that memory range,
    which is unused by the OS. In SMI callout issues, when an attacker can overwrite
    the address of an indirect jump or a function pointer that is called from SMM,
    then arbitrary code under the attacker’s control will be executed outside of SMM,
    but with the privileges of SMM (a good example of such an attack is VU#631788).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对BIOS植入物感兴趣的最常见SMI处理程序漏洞主要分为两大类：SMI调用问题和任意代码执行（在许多情况下，任意代码执行是由SMI调用问题引发的）。在SMI调用问题中，SMM代码无意中使用了一个由攻击者控制的函数指针，该指针指向SMM外部的植入载荷。在任意代码执行中，SMM代码从SMRAM外部读取一些数据，这些数据能够影响控制流，并且可以被用来获得更多控制权限。这些地址通常位于物理内存的第一个兆字节以下，因为SMI处理程序预期使用这一内存范围，而操作系统并未使用该内存范围。在SMI调用问题中，当攻击者能够覆盖一个间接跳转的地址或一个从SMM调用的函数指针时，攻击者控制的任意代码将会在SMM外部执行，但仍然拥有SMM的特权（这种攻击的一个典型例子是VU#631788）。
- en: In the newer versions of the BIOS from major enterprise vendors, such vulnerabilities
    are harder to find, but issues with accessing pointers outside the SMRAM range
    remain, despite the introduction of the standard function `SmmIsBufferOutsideSmmValid()`
    to check whether a pointer to a memory buffer is in that range. The implementation
    of this generic check was introduced in the Intel EDK2 repository on GitHub (*[https://github.com/tianocore/edk2/blob/master/MdePkg/Library/SmmMemLib/SmmMemLib.c](https://github.com/tianocore/edk2/blob/master/MdePkg/Library/SmmMemLib/SmmMemLib.c)*),
    and its declaration is shown in [Listing 16-4](ch16.xhtml#ch16list04).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在主要企业厂商的新版本BIOS中，这类漏洞更难发现，但即使引入了标准函数`SmmIsBufferOutsideSmmValid()`来检查指向内存缓冲区的指针是否在SMRAM范围内，访问超出SMRAM范围的指针的问题仍然存在。这个通用检查的实现已经在GitHub上的Intel
    EDK2代码库中引入（* [https://github.com/tianocore/edk2/blob/master/MdePkg/Library/SmmMemLib/SmmMemLib.c](https://github.com/tianocore/edk2/blob/master/MdePkg/Library/SmmMemLib/SmmMemLib.c)
    *），它的声明见于[清单16-4](ch16.xhtml#ch16list04)。
- en: '[PRE3]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 16-4: Prototype of the function `SmmIsBufferOutsideSmmValid()` from
    Intel EDK2*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单16-4：来自Intel EDK2的函数`SmmIsBufferOutsideSmmValid()`的原型*'
- en: 'The `SmmIsBufferOutsideSmmValid()` function accurately detects pointers to
    memory buffers outside the SMRAM range, with one exception: it’s possible for
    the `Buffer` argument to be a structure and for one of the fields of this structure
    to be a pointer to another buffer outside SMRAM. If the security check happens
    only for the address of the structure itself, SMM code may still be vulnerable,
    despite a check with `SmmIsBufferOutsideSmmValid()`. Thus, SMI handlers have to
    validate each address or pointer—including offsets!—that they receive from the
    OS prior to reading from or writing to such memory locations. Importantly, this
    includes returning status and error codes. Any type of arithmetic calculation
    that happens inside SMM should validate any parameters coming from outside of
    SMM or less privileged modes.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`SmmIsBufferOutsideSmmValid()`函数可以准确检测指向SMRAM范围外的内存缓冲区的指针，唯一的例外是：`Buffer`参数可能是一个结构体，而该结构体的一个字段可能是指向SMRAM外部的另一个缓冲区的指针。如果安全检查仅对结构体本身的地址进行检查，SMM代码仍然可能存在漏洞，即使已经通过`SmmIsBufferOutsideSmmValid()`进行了检查。因此，SMI处理程序必须在从操作系统接收到每个地址或指针（包括偏移量！）之前验证它们，而在读取或写入这些内存位置时尤为重要。值得注意的是，这也包括返回状态和错误代码。在SMM内部发生的任何算术计算都应该验证任何来自SMM外部或低权限模式的参数。'
- en: '**SMI Handler Exploitation Case Studies**'
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**SMI处理程序利用案例研究**'
- en: Now that we’ve discussed the perils of SMI handlers taking data from the OS,
    it’s time to dig into a real case of SMI handler exploitation. We’ll look at the
    common workflow of a UEFI firmware update process used by Windows 10, among other
    operating systems. In this situation, the firmware is validated and authenticated
    inside SMM with weak DXE runtime drivers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了SMI处理程序从操作系统获取数据的危险，现在是时候深入探讨一个SMI处理程序被利用的实际案例了。我们将查看Windows 10等操作系统中使用的UEFI固件更新过程的常见工作流程。在这种情况下，固件在SMM内部进行验证和认证，使用的是较弱的DXE运行时驱动程序。
- en: '[Figure 16-5](ch16.xhtml#ch16fig05) shows a high-level picture of the BIOS
    update process in this scenario.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 16-5](ch16.xhtml#ch16fig05) 展示了该场景下 BIOS 更新过程的高级示意图。'
- en: '![image](../images/16fig05.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/16fig05.jpg)'
- en: '*Figure 16-5: High-level representation of the BIOS update process from the
    OS*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-5：操作系统中 BIOS 更新过程的高级表示*'
- en: As you can see, the userland BIOS update tool (Update App) communicates with
    its kernel-mode driver (Update Driver), which usually has direct access to the
    physical memory device over the Ring 0 API function `MmMapIoSpace()`. This access
    allows potential attackers to modify or map malicious data to the memory regions
    used to communicate with the SMI handler BIOS (SmiFlash or SecSmiFlash) update
    parsers. Usually, the parsing flow is complex enough to leave room for vulnerabilities,
    especially when the parsers are written in C, as they typically are. The attacker
    crafts a malicious data buffer and calls a vulnerable SMI handler by its number,
    as shown in [Listing 16-3](ch16.xhtml#ch16list03), using `__outbyte()` intrinsic
    functions available in the MS Visual C++ compiler.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，用户态 BIOS 更新工具（Update App）与其内核模式驱动程序（Update Driver）进行通信，后者通常通过 Ring 0 API
    函数 `MmMapIoSpace()` 直接访问物理内存设备。这种访问使得潜在攻击者可以修改或映射恶意数据到与 SMI 处理程序 BIOS（SmiFlash
    或 SecSmiFlash）更新解析器通信的内存区域。通常，解析流程复杂到足以留下漏洞，特别是当解析器通常用 C 语言编写时。攻击者构造一个恶意数据缓冲区，并通过其编号调用一个易受攻击的
    SMI 处理程序，如[清单 16-3](ch16.xhtml#ch16list03)所示，使用 MS Visual C++ 编译器中的 `__outbyte()`
    内建函数。
- en: The DXE drivers shown in [Figure 16-5](ch16.xhtml#ch16fig05), SmiFlash and SecSmiFlash,
    are found across many SMM codebases. SmiFlash flashes a BIOS image without any
    authentication. Using an update tool based on this driver, the attacker can simply
    flash a maliciously modified BIOS update image without further ado (a good example
    of this type of vulnerability is VU#507496, found by Alex Matrosov). SecSmiFlash,
    by contrast, can authenticate the update by checking its digital signature, blocking
    this kind of attack.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 16-5](ch16.xhtml#ch16fig05)中展示的 DXE 驱动程序 SmiFlash 和 SecSmiFlash，广泛存在于许多
    SMM 代码库中。SmiFlash 会在没有任何身份验证的情况下刷新 BIOS 镜像。使用基于此驱动程序的更新工具，攻击者可以轻松地刷新一个经过恶意修改的
    BIOS 更新镜像，而无需任何额外操作（这种类型漏洞的一个典型例子是 Alex Matrosov 发现的 VU#507496）。相反，SecSmiFlash
    通过检查数字签名来验证更新，从而阻止了这种攻击。
- en: '**Vulnerabilities in the S3 Boot Script**'
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**S3 启动脚本中的漏洞**'
- en: In this section, we’ll give you an overview of vulnerabilities in the S3 Boot
    Script, the script that the BIOS uses to wake from sleep mode. Although the S3
    Boot Script speeds up the waking process, incorrect implementations of it can
    have serious security impacts, as we’ll explore here.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将概述 S3 启动脚本中的漏洞，这是 BIOS 用于从睡眠模式唤醒的脚本。尽管 S3 启动脚本加速了唤醒过程，但其不当实现可能会带来严重的安全影响，我们将在此进行探讨。
- en: '***Understanding the S3 Boot Script***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***理解 S3 启动脚本***'
- en: The power transition states of modern hardware—such as working mode and sleep
    mode—are very complex and involve multiple DRAM manipulation stages. During sleep
    mode, or S3, DRAM is kept powered, although the CPU is not. When the system wakes
    from the sleep state, the BIOS restores the platform configuration, including
    the contents of the DRAM, and then transfers control to the operating system.
    You can find a good summary of these states in *[https://docs.microsoft.com/en-us/windows/desktop/power/system-power-states/](https://docs.microsoft.com/en-us/windows/desktop/power/system-power-states/).*
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现代硬件的电源转换状态——如工作模式和睡眠模式——非常复杂，涉及多个 DRAM 操作阶段。在睡眠模式（S3）期间，DRAM 保持供电，尽管 CPU 并未工作。当系统从睡眠状态唤醒时，BIOS
    恢复平台配置，包括 DRAM 的内容，然后将控制权转交给操作系统。你可以在 *[https://docs.microsoft.com/en-us/windows/desktop/power/system-power-states/](https://docs.microsoft.com/en-us/windows/desktop/power/system-power-states/)*
    中找到这些状态的简要总结。
- en: The S3 boot script is stored in DRAM, preserved across the S3 state, and executed
    when resuming full function from S3\. Although called a “script,” it is really
    a series of opcodes interpreted by the Boot Script Executor firmware module (*[https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Library/PiDxeS3BootScriptLib/BootScriptExecute.c](https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Library/PiDxeS3BootScriptLib/BootScriptExecute.c)*).
    The Boot Script Executor replays every operation defined by these opcodes at the
    end of the PEI phase to restore the configuration of the platform hardware and
    the entire preboot state for the OS. After executing the S3 boot script, the BIOS
    locates and executes the OS waking vector to restore its software execution to
    the state it was in when it left off. This means the S3 boot script allows the
    platform to skip the DXE phase and reduces the time it takes to wake from the
    S3 sleep state. Yet this optimization comes with some risks, as we’ll discuss
    next.^([2](footnotes.xhtml#ch16fn2))
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: S3 启动脚本存储在 DRAM 中，并在 S3 状态下得以保存，当从 S3 恢复完全功能时执行。尽管被称为“脚本”，但它实际上是一系列由启动脚本执行器固件模块解释的操作码（*
    [https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Library/PiDxeS3BootScriptLib/BootScriptExecute.c](https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Library/PiDxeS3BootScriptLib/BootScriptExecute.c)
    *）。启动脚本执行器在 PEI 阶段结束时重放这些操作码定义的每个操作，以恢复平台硬件的配置和操作系统的整个预启动状态。执行 S3 启动脚本后，BIOS 会定位并执行操作系统唤醒向量，将其软件执行恢复到它停止时的状态。这意味着
    S3 启动脚本使平台可以跳过 DXE 阶段，从而缩短从 S3 睡眠状态唤醒的时间。然而，这种优化也带来了一些风险，正如我们接下来将讨论的那样。^([2](footnotes.xhtml#ch16fn2))
- en: '***Targeting Weaknesses of the S3 Boot Script***'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***针对 S3 启动脚本的弱点***'
- en: An S3 boot script is just another kind of program code stored in memory. An
    attacker who can gain access to it and alter the code can either add surreptitious
    actions to the boot script itself (staying within the S3 programming model so
    as not to ring alarm bells) or, if this doesn’t suffice, exploit the boot script’s
    interpreter by going beyond the opcodes’ intended functionality.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: S3 启动脚本只是存储在内存中的另一种程序代码。攻击者如果能够访问并修改它，便可以在启动脚本中添加秘密操作（保持在 S3 编程模型内，以避免引起警觉），或者如果这不够，还可以通过超越操作码的预定功能，利用启动脚本的解释器。
- en: The S3 boot script has access to input/output (I/O) ports for read and write,
    PCI configuration read and write, direct access to the physical memory with read
    and write privileges, and other data that is critical for the platform’s security.
    Notably, an S3 boot script can attack a hypervisor to disclose otherwise isolated
    memory regions. All of this means that a rogue S3 script will have an impact similar
    to a code execution vulnerability inside the SMM, discussed earlier in this chapter.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: S3 启动脚本可以访问输入/输出（I/O）端口进行读写、PCI 配置读写、直接访问物理内存并具有读写权限，以及其他对平台安全至关重要的数据。特别是，S3
    启动脚本可以攻击虚拟机监控程序，泄露本应隔离的内存区域。所有这些意味着，恶意的 S3 脚本会产生类似于本章早些时候讨论的 SMM 内部代码执行漏洞的影响。
- en: As S3 scripts are executed early in the wake process, before various security
    measures are activated, the attacker can use them to bypass some security hardware
    configurations that would normally take effect during the boot process. Indeed,
    by design, most of the S3 boot script opcodes cause the system firmware to restore
    the contents of various hardware configuration registers. For the most part, this
    process isn’t any different from writing to these registers during the operating
    system runtime, except that write access is allowed for the S3 script but disallowed
    for the operating system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 S3 脚本在唤醒过程的早期执行，在各种安全措施激活之前，攻击者可以利用这些脚本绕过一些通常会在启动过程中生效的安全硬件配置。实际上，按设计，大多数
    S3 启动脚本的操作码会导致系统固件恢复各种硬件配置寄存器的内容。在大多数情况下，这个过程与在操作系统运行时向这些寄存器写入内容并无不同，只不过 S3 脚本允许写访问，而操作系统则不允许。
- en: Attackers can target the S3 boot script by altering a data structure called
    the *UEFI boot script table*, which saves the platform state during the Advanced
    Configuration and Power Interface (ACPI) specification’s S3 sleep stage, when
    most of the platform’s components are powered off. UEFI code constructs a boot
    script table during normal boot and interprets its entries during an S3 resumption,
    when the platform is waking up from sleep. Attackers able to modify the current
    boot script table’s contents from the OS kernel mode and then trigger an S3 suspend-resume
    cycle can achieve arbitrary code execution at the early platform wake stage, when
    some of security features are not yet initialized or locked in the memory.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以通过修改一个名为*UEFI引导脚本表*的数据结构来攻击S3引导脚本，该表保存了平台在高级配置和电源接口（ACPI）规范的S3睡眠阶段的状态，此时大部分平台组件已关闭电源。UEFI代码在正常引导过程中构建引导脚本表，并在S3恢复时解释其条目，此时平台正从睡眠中唤醒。能够从操作系统内核模式修改当前引导脚本表内容的攻击者，触发S3挂起恢复周期时，可以在平台早期唤醒阶段实现任意代码执行，此时一些安全功能尚未初始化或在内存中被锁定。
- en: '**DISCOVERY OF THE S3 BOOT SCRIPT VULNERABILITY**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**S3引导脚本漏洞的发现**'
- en: The first researchers to publicly describe the malicious behavior of an S3 boot
    script were Rafal Wojtczuk and Corey Kallenberg. In their December 2014 presentation
    “Attacks on UEFI Security, Inspired by Darth Venamis’s Misery and *Speed Racer*”
    (*[https://bit.ly/2ucc2vU](https://bit.ly/2ucc2vU)*) at the 31st Chaos Communication
    Congress (31C3), they revealed the S3-related vulnerability CVE-2014-8274 (VU#976132).
    A few weeks later, security researcher Dmytro Oleksiuk (also known as Cr4sh) released
    the first proof-of-concept exploit for this vulnerability. The PoC’s release triggered
    multiple discoveries by other researchers. A few months later, Pedro Vilaca found
    multiple related problems in Apple products based on UEFI firmware. Researchers
    at the Intel Advanced Threat Research group also highlighted several potential
    S3 attacks in virtualization security in their talk “Attacking Hypervisors via
    Firmware and Hardware” (*[https://www.youtube.com/watch?v=nyW3eTobXAI](https://www.youtube.com/watch?v=nyW3eTobXAI)*),
    presented at Black Hat Vegas in 2015\. If you want to know more about the S3 boot
    script vulnerabilities, we recommend looking at some of these presentations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首批公开描述S3引导脚本恶意行为的研究人员是Rafal Wojtczuk和Corey Kallenberg。在他们2014年12月的演讲《针对UEFI安全的攻击，灵感来自Darth
    Venamis的痛苦和*速度赛车*》(*[https://bit.ly/2ucc2vU](https://bit.ly/2ucc2vU)*)中，他们揭示了与S3相关的漏洞CVE-2014-8274（VU＃976132）。几周后，安全研究员Dmytro
    Oleksiuk（也被称为Cr4sh）发布了该漏洞的第一个概念验证（PoC）漏洞利用。PoC的发布引发了其他研究人员的多次发现。几个月后，Pedro Vilaca在基于UEFI固件的Apple产品中发现了多个相关问题。英特尔高级威胁研究小组的研究人员还在他们的讲座“通过固件和硬件攻击虚拟化程序”(*[https://www.youtube.com/watch?v=nyW3eTobXAI](https://www.youtube.com/watch?v=nyW3eTobXAI)*)中，强调了几个潜在的S3攻击，讲座于2015年在Black
    Hat Vegas上展示。如果你想了解更多关于S3引导脚本漏洞的信息，我们推荐查看一些这些演讲。
- en: '***Exploiting the S3 Boot Script Vulnerability***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***利用S3引导脚本漏洞***'
- en: The impact of an S3 boot script exploit is clearly huge. But how exactly does
    the attack work? First, the attacker must already have code execution in the kernel
    mode (Ring 0) of the operating system, as [Figure 16-6](ch16.xhtml#ch16fig06)
    shows.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: S3引导脚本漏洞的影响显然是巨大的。但攻击是如何工作的呢？首先，攻击者必须已经在操作系统的内核模式（Ring 0）中获得代码执行权限，如[图16-6](ch16.xhtml#ch16fig06)所示。
- en: '![image](../images/16fig06.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/16fig06.jpg)'
- en: '*Figure 16-6: Step-by-step exploitation of an S3 boot script*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-6：S3引导脚本的逐步利用*'
- en: Let’s dig into each step of this exploit.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入研究这个漏洞利用的每一个步骤。
- en: '**Initial reconnaissance.** During the reconnaissance phase, an attacker must
    get the S3 boot script pointer (address) from the UEFI variable `AcpiGlobalVariable`,
    which points to the boot script location in unprotected DRAM memory. Then they
    must copy the original boot script into a memory location so they can restore
    the original state after exploitation. Finally, they must make sure the system
    is actually affected by the S3 boot script vulnerability by using the modification
    dispatch code `EFI_BOOT_SCRIPT_DISPATCH_OPCODE`, which adds a record into the
    specified boot script table to execute arbitrary code, as shown in [Listing 16-5](ch16.xhtml#ch16list05).
    If the modification of a single S3 opcode is successful, the system is most likely
    vulnerable.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初步侦察。** 在侦察阶段，攻击者必须从 UEFI 变量 `AcpiGlobalVariable` 获取 S3 启动脚本指针（地址），该变量指向未保护的
    DRAM 内存中的启动脚本位置。然后，他们必须将原始启动脚本复制到一个内存位置，以便在利用后恢复原始状态。最后，他们必须确保系统实际受到 S3 启动脚本漏洞的影响，可以通过使用修改后的调度代码
    `EFI_BOOT_SCRIPT_DISPATCH_OPCODE` 来验证，这段代码将一条记录添加到指定的启动脚本表中以执行任意代码，如[清单 16-5](ch16.xhtml#ch16list05)所示。如果成功修改了单个
    S3 操作码，系统很可能存在漏洞。'
- en: '**S3 boot script modification.** To modify the boot script, the attacker inserts
    a malicious dispatch opcode record at the top of the copied boot script to place
    as the first boot script opcode command. They then overwrite the boot script address
    location by setting the `AcpiGlobalVariable` to a pointer to the modified malicious
    version of the boot script.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**S3 启动脚本修改。** 为了修改启动脚本，攻击者将恶意的调度操作码记录插入到复制的启动脚本顶部，将其放置为第一个启动脚本操作码命令。然后，他们通过将
    `AcpiGlobalVariable` 设置为指向修改后的恶意版本启动脚本的指针，覆盖启动脚本地址位置。'
- en: '**Payload delivery.** The S3 boot script dispatch code (`EFI_BOOT_SCRIPT_DISPATCH_OPCODE`)
    should now point to the malicious shellcode. The content of the payload depends
    on the attacker’s target. It could serve multiple purposes, including bypassing
    SMM memory protection or executing additional shellcode stages mapped separately
    elsewhere in memory.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有效载荷交付。** S3 启动脚本调度代码（`EFI_BOOT_SCRIPT_DISPATCH_OPCODE`）现在应该指向恶意的 shellcode。有效载荷的内容取决于攻击者的目标。它可以服务于多种目的，包括绕过
    SMM 内存保护或执行额外的 shellcode 阶段，这些阶段可能在内存中的其他位置单独映射。'
- en: '**Vulnerability trigger.** The malicious boot script is executed right after
    the attacked machine returns from sleep mode. To trigger an exploit, either the
    user or additional malicious code inside the OS would have to activate S3 sleep
    mode. After the boot script starts execution, it jumps to the entry point address
    defined by the dispatch code—where the malicious shellcode receives control.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**漏洞触发。** 恶意启动脚本在被攻击的机器从睡眠模式恢复后立即执行。要触发漏洞，用户或操作系统内的其他恶意代码必须激活 S3 睡眠模式。启动脚本开始执行后，它会跳转到由调度代码定义的入口地址——此时恶意的
    shellcode 获取控制权。'
- en: '[Listing 16-5](ch16.xhtml#ch16list05) lists all S3 boot script opcodes documented
    by Intel, including the highlighted `EFI_BOOT_SCRIPT_DISPATCH_OPCODE`, which executes
    the malicious shellcode.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-5](ch16.xhtml#ch16list05)列出了 Intel 文档中的所有 S3 启动脚本操作码，包括突出显示的 `EFI_BOOT_SCRIPT_DISPATCH_OPCODE`，该操作码用于执行恶意的
    shellcode。'
- en: '[PRE4]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 16-5: S3 Boot Script dispatch opcodes*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 16-5：S3 启动脚本调度操作码*'
- en: You can find a reference implementation of the S3 boot script developed by Intel
    in the EDKII repository on GitHub (*[https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Library/PiDxeS3BootScriptLib/](https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Library/PiDxeS3BootScriptLib/)*).
    This code is useful for understanding both the internals of the S3 boot script
    behavior on x86 systems and the mitigations implemented to prevent the vulnerability
    we just discussed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上的 EDKII 仓库中找到 Intel 开发的 S3 启动脚本的参考实现（*[https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Library/PiDxeS3BootScriptLib/](https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Library/PiDxeS3BootScriptLib/)*）。这段代码对于理解
    x86 系统上 S3 启动脚本行为的内部机制以及实施的防护措施非常有用，能够帮助防止我们刚才讨论的漏洞。
- en: To check whether a system is affected by the S3 boot script vulnerability, you
    can use Chipsec’s S3 Boot Script tool (*chipsec/modules/common/uefi/s3bootscript.py*).
    You can’t use this tool to exploit the vulnerability, however.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查系统是否受到 S3 启动脚本漏洞的影响，可以使用 Chipsec 的 S3 启动脚本工具（*chipsec/modules/common/uefi/s3bootscript.py*）。然而，你不能使用这个工具来利用漏洞。
- en: You could, however, use Dmytro Oleksiuk’s PoC of the exploit published on GitHub
    (*[https://github.com/Cr4sh/UEFI_boot_script_expl/](https://github.com/Cr4sh/UEFI_boot_script_expl/)*)
    to deliver a payload. [Listing 16-6](ch16.xhtml#ch16list06) shows the successful
    result of this PoC exploitation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以使用Dmytro Oleksiuk在GitHub上发布的PoC利用代码（*[https://github.com/Cr4sh/UEFI_boot_script_expl/](https://github.com/Cr4sh/UEFI_boot_script_expl/)）来交付有效载荷。[Listing
    16-6](ch16.xhtml#ch16list06)展示了这一PoC利用的成功结果。
- en: '[PRE5]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 16-6: The result of successful S3 boot script exploitation*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 16-6: 成功的S3启动脚本利用结果*'
- en: 'This vulnerability and its exploit are also useful for disabling some of the
    BIOS protection bits, such as BIOS Lock Enabled, BIOS Write Protection, and some
    others configured in the FLOCKDN (Flash Lock-Down) register. Importantly, an S3
    exploit can also disable the protected ranges of PRx registers by modifying their
    configuration. Also, as we mentioned before, you can use the S3 vulnerability
    to bypass virtualization memory isolation technologies, such as Intel VT-x. In
    fact, the following S3 opcodes can make direct memory accesses during recovery
    from sleep state:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞及其利用方式同样有助于禁用一些BIOS保护位，例如启用BIOS锁定、BIOS写保护，以及在FLOCKDN（Flash Lock-Down）寄存器中配置的其他一些保护位。重要的是，S3漏洞还可以通过修改PRx寄存器的配置来禁用受保护的寄存器范围。另外，正如我们之前提到的，您可以利用S3漏洞绕过虚拟化内存隔离技术，例如Intel
    VT-x。事实上，以下S3操作码可以在从睡眠状态恢复期间直接访问内存：
- en: '[PRE6]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Those opcodes can write some value to a specified memory location on behalf
    of the UEFI firmware, which makes it possible to attack a guest VM. Even when
    the architecture includes a hypervisor more privileged than the host system, the
    host system can attack it via S3 and, through it, all the guests.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作码可以代表UEFI固件将某些值写入指定的内存位置，从而使得攻击来宾虚拟机成为可能。即使架构中包括了比主机系统更具特权的虚拟机监控器，主机系统仍然可以通过S3攻击它，并通过它攻击所有来宾虚拟机。
- en: '***Fixing the S3 Boot Script Vulnerability***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修复S3启动脚本漏洞***'
- en: The S3 boot script vulnerability was one of the most impactful security vulnerabilities
    in UEFI firmware. It was easy to exploit and hard to mitigate, since an actual
    fix required multiple firmware architectural changes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: S3启动脚本漏洞是UEFI固件中最具影响力的安全漏洞之一。它容易被利用且难以缓解，因为真正的修复需要多个固件架构的更改。
- en: 'Mitigating the S3 boot script issue required integrity protection from Ring
    0 modifications. One way to achieve this was to move the S3 boot script to the
    SMRAM (SMM memory range). But there’s another way: in a technique introduced in
    EDKII (*edk2/MdeModulePkg/Library/SmmLockBoxLib*), Intel architects designed a
    LockBox mechanism to protect the S3 boot script from any modifications outside
    of SMM.^([3](footnotes.xhtml#ch16fn3))'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解S3启动脚本问题需要防止Ring 0的修改。实现这一点的一种方法是将S3启动脚本移动到SMRAM（SMM内存范围）。但还有另一种方法：在EDKII中引入的技术中（*edk2/MdeModulePkg/Library/SmmLockBoxLib*），英特尔架构师设计了一种LockBox机制，用以保护S3启动脚本不受SMM外部任何修改的影响。^([3](footnotes.xhtml#ch16fn3))
- en: '**Vulnerabilities in the Intel Management Engine**'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**英特尔管理引擎中的漏洞**'
- en: The Intel Management Engine is interesting for an attacker. This technology
    has tantalized hardware security researchers ever since its inception, because
    it’s both virtually undocumented and extremely powerful. Today, the ME uses a
    separate x86-based CPU (in the past, it used the boutique ARC CPU) and serves
    as the foundation for the Intel hardware root of trust and multiple security technologies
    such as Intel Boot Guard, Intel BIOS Guard, and, partially, Intel Software Guard
    Extension (SGX). Thus, compromising ME provides a way to bypass Secure Boot.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔管理引擎对攻击者具有吸引力。这项技术自诞生以来就一直令硬件安全研究人员感到着迷，因为它几乎没有文档记录且极其强大。今天，ME使用一个独立的基于x86的CPU（过去使用的是定制的ARC
    CPU），并作为英特尔硬件信任根和多个安全技术的基础，例如Intel Boot Guard、Intel BIOS Guard以及部分的Intel软件保护扩展（SGX）。因此，妥协ME可以绕过安全启动。
- en: Control of ME is a highly coveted goal for attackers, since ME has all the power
    of SMM but can also execute an embedded real-time OS on a separate 32-bit microcontroller
    that operates totally independently of the main CPU. Let’s look at some of its
    vulnerabilities.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ME的控制权是攻击者非常渴望的目标，因为ME拥有SMM的所有权限，但还可以在一个独立的32位微控制器上执行嵌入式实时操作系统，该微控制器完全独立于主CPU运行。让我们来看看它的一些漏洞。
- en: '***A History of ME Vulnerabilities***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ME漏洞历史***'
- en: In 2009, security researchers Alexander Tereshkin and Rafal Wojtczuk from Invisible
    Things Lab presented their research on abusing ME in their talk, “Introducing
    Ring –3 Rootkits,” presented at the Black Hat USA conference in Las Vegas.^([4](footnotes.xhtml#ch16fn4))
    They shared their discoveries about Intel ME internals and discussed ways of injecting
    code into the Intel AMT execution context—by co-opting ME into a rootkit, for
    example.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年，安全研究人员亚历山大·特列什金（Alexander Tereshkin）和拉法尔·沃伊茨丘克（Rafal Wojtczuk）来自Invisible
    Things Lab，在他们的报告《Introducing Ring –3 Rootkits》中展示了他们关于滥用ME的研究，该报告在拉斯维加斯的Black
    Hat USA大会上进行。^([4](footnotes.xhtml#ch16fn4)) 他们分享了关于英特尔ME内部机制的发现，并讨论了如何将代码注入到英特尔AMT执行上下文中——例如，通过将ME作为rootkit的一部分来实现。
- en: The next advance in understanding ME vulnerabilities came an entire eight years
    later. Researchers Maxim Goryachy and Mark Ermolov from Positive Technologies
    discovered code execution vulnerabilities in the newer version of ME, present
    in Intel’s sixth, seventh, and eighth generations of CPUs. These vulnerabilities—CVE-2017-5705,
    CVE-2017-5706, and CVE-2017-5707, respectively—allowed an attacker to execute
    arbitrary code inside ME’s operating system context, resulting in a complete compromise
    of the respective platforms at the highest level of privilege. Goryachy and Ermolov
    presented these discoveries in “How to Hack a Turned-Off Computer, or Running
    Unsigned Code in Intel Management Engine” at Black Hat Europe 2017,^([5](footnotes.xhtml#ch16fn5))
    where the researchers showed how rootkit code could bypass or disable multiple
    security features, including Intel’s Boot Guard and BIOS Guard technologies, by
    compromising their root of trust. Whether any security technologies are resilient
    to a compromised ME remains an open research question. Among other capabilities,
    rootkit code that executes in the Intel ME context allows the attacker to modify
    the BIOS image (and, partially, the root of trust of Boot Guard) directly inside
    the SPI flash chip and thus to bypass most security features.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对ME漏洞的下一次突破出现在整整八年后。来自Positive Technologies的研究人员马克西姆·戈里亚奇（Maxim Goryachy）和马克·厄尔莫洛夫（Mark
    Ermolov）发现了英特尔第六、七和八代CPU中更新版本的ME代码执行漏洞。这些漏洞——分别为CVE-2017-5705、CVE-2017-5706和CVE-2017-5707——允许攻击者在ME操作系统上下文中执行任意代码，从而完全妥协相应平台的最高权限。戈里亚奇和厄尔莫洛夫在2017年Black
    Hat Europe大会上展示了这些发现，报告题为《如何攻击一台关机的计算机，或者在英特尔管理引擎中运行未签名的代码》^([5](footnotes.xhtml#ch16fn5))，研究人员展示了如何通过危及信任根，绕过或禁用多个安全功能，包括英特尔的Boot
    Guard和BIOS Guard技术。是否有任何安全技术能够抵抗被妥协的ME仍然是一个开放的研究问题。除了其他功能外，在英特尔ME上下文中执行的rootkit代码使得攻击者能够直接在SPI闪存芯片中修改BIOS映像（以及部分Boot
    Guard的信任根），从而绕过大多数安全功能。
- en: '***ME Code Attacks***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ME代码攻击***'
- en: Even though ME code executes on its own chip, it communicates with other layers
    of the OS and can be attacked via these communications. As always, the communication
    boundary is a part of any computational environment’s attack surface, no matter
    how isolated the environment.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ME代码在其自己的芯片上执行，但它与操作系统的其他层进行通信，并可以通过这些通信受到攻击。像往常一样，通信边界是任何计算环境攻击面的一部分，无论该环境多么隔离。
- en: Intel created a special interface, called the *Host-Embedded Controller Interface
    (HECI)*, so ME applications could communicate with the operating system kernel.
    This interface could be used, for example, to remotely manage a system via a network
    connection terminating at the ME but capable of capturing the operating system
    GUI (via VNC, for example) or for operating system–aided configuration of the
    platform during the manufacturing process. It could also be used to implement
    Intel vPro enterprise management services, including AMT (which we discuss in
    the next section).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔创建了一个特殊的接口，称为*主机-嵌入式控制器接口（HECI）*，以便ME应用程序能够与操作系统内核进行通信。这个接口可以用于远程管理系统，例如通过网络连接终止在ME端但能够捕获操作系统GUI（例如通过VNC）进行管理，或者在制造过程中实现操作系统辅助的系统配置。它还可以用于实现英特尔vPro企业管理服务，包括AMT（我们将在下一节讨论）。
- en: Typically, UEFI firmware initializes HECI via a proxy SMM driver, `HeciInitDxe`,
    located inside the BIOS. This SMM driver passes messages between ME and the host
    OS vendor-specific driver over the PCH bridge, which connects the CPU and the
    ME chip.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，UEFI固件通过位于BIOS中的代理SMM驱动程序`HeciInitDxe`来初始化HECI。该SMM驱动程序通过PCH桥在ME和主机操作系统供应商特定驱动程序之间传递消息，而PCH桥连接着CPU和ME芯片。
- en: Applications running inside the ME can register HECI handlers to accept communication
    from the host operating system (the ME should not trust any input from the OS).
    If the OS kernel is taken over by an attacker, these interfaces become a part
    of the ME’s attack surface; for example, an overly trusting parser inside an ME
    application that does not fully validate messages coming from the OS side could
    be compromised by a crafted message, just as weak network servers are. This is
    why it’s important to reduce the attack surface for ME applications by minimizing
    the number of HECI handlers. Indeed, Apple platforms permanently disable the HECI
    interfaces and minimize the number of their ME applications as a deliberate security
    policy decision. However, one compromised ME application doesn’t mean the entire
    ME is compromised.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在ME内部运行的应用程序可以注册HECI处理程序，以接受来自主机操作系统的通信（ME不应信任操作系统的任何输入）。如果操作系统内核被攻击者接管，这些接口就成为ME的攻击面的一部分；例如，一个过于信任的解析器在ME应用程序内，未能完全验证来自操作系统的消息，就可能被精心构造的消息所攻破，就像脆弱的网络服务器一样。这就是为什么通过最小化HECI处理程序的数量来减少ME应用程序的攻击面非常重要。实际上，苹果平台出于安全政策决定，永久禁用HECI接口，并最小化其ME应用程序的数量。然而，一个被攻破的ME应用程序并不意味着整个ME被攻破。
- en: '***Case Studies: Attacks on Intel AMT and BMC***'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***案例研究：针对英特尔AMT和BMC的攻击***'
- en: Let’s now consider vulnerabilities in two technologies that use the ME. To manage
    large data centers, as well as massive enterprise workstation inventories that
    must be centrally managed, organizations often use technologies that embed the
    management endpoint and logic into a platform’s main board. This allows them to
    control the platform remotely, even when the platform’s main CPU isn’t running.
    These technologies, which include Intel’s AMT and various baseboard management
    controller (BMC) chips, have inevitably become a part of their platforms’ attack
    surface.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来考虑在使用ME的两种技术中的漏洞。为了管理大型数据中心，以及必须集中管理的大规模企业工作站库存，组织通常使用将管理端点和逻辑嵌入到平台主板中的技术。这使得他们能够远程控制平台，即使平台的主CPU没有运行。这些技术，包括英特尔的AMT和各种基板管理控制器（BMC）芯片，不可避免地成为其平台攻击面的一部分。
- en: A full discussion of attacks on AMT and BMCs is outside the scope of this chapter.
    However, we still want to provide some pointers, since exploitation of these technologies
    is directly tied to UEFI vulnerabilities and has gotten a lot of attention lately,
    due to high-impact Intel AMT and BMC vulnerabilities revealed in 2017 and 2018\.
    We’ll discuss these vulnerabilities next.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对AMT和BMC攻击的全面讨论超出了本章的范围。然而，我们仍然希望提供一些指引，因为这些技术的利用直接与UEFI漏洞相关，且由于2017年和2018年暴露的高影响力英特尔AMT和BMC漏洞，最近受到了广泛关注。接下来，我们将讨论这些漏洞。
- en: '**AMT Vulnerabilities**'
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**AMT 漏洞**'
- en: Intel’s AMT platform is implemented as an ME application and so directly relates
    to the Intel ME execution environment. AMT leverages the ME’s ability to communicate
    with a platform over a network even when the main CPU is not active or is completely
    powered down. It also uses the ME to read and write DRAM at runtime, independently
    of the main CPU. AMT is an archetypical example of an ME firmware application
    that is intended to be updated via the BIOS update mechanism. For this purpose,
    Intel AMT runs its own web server, used as the main entry point for an enterprise
    remote management console.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔的AMT平台作为ME应用程序实现，因此与英特尔ME执行环境直接相关。AMT利用ME即使在主CPU不活动或完全关闭的情况下，也能通过网络与平台进行通信的能力。它还使用ME在运行时读取和写入DRAM，独立于主CPU。AMT是一个典型的ME固件应用程序示例，旨在通过BIOS更新机制进行更新。为此，英特尔AMT运行其自己的Web服务器，作为企业远程管理控制台的主要入口点。
- en: In 2017, after nearly two decades of having a clean public security record,
    AMT had its first vulnerability reported—but it was a shocking one, and, given
    its nature, hardly the last one we’ll see! Researchers from Embedi (a private
    security company) alerted Intel about the critical issue CVE-2017-5689 (INTEL-SA-00075),
    which allowed for remote access and authentication bypass. All Intel systems produced
    since 2008 and that support the ME are affected. (This excludes the sizable Intel
    Atom population, which itself did not include the ME, although all of its server
    and workstation products were likely vulnerable if they included vulnerable components
    of the ME. Officially, only Intel vPro systems have AMT.) The scope of this vulnerability
    is pretty interesting, as it mostly affected systems designed to be accessed via
    a remote AMT management console even when turned off—meaning that the system could
    also be *attacked* when turned off.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 2017 年，在近二十年没有任何公开的安全记录之后，AMT 首次报告了漏洞——但这是一个令人震惊的漏洞，并且鉴于其性质，几乎肯定不会是我们看到的最后一个！来自
    Embedi（一个私人安全公司）的研究人员向英特尔通报了关键问题 CVE-2017-5689（INTEL-SA-00075），该漏洞允许远程访问和认证绕过。所有自
    2008 年以来生产的支持 ME 的英特尔系统都受到影响。（这不包括大量的英特尔 Atom 系列产品，它们本身不包含 ME，但如果它们包括易受攻击的 ME
    组件，则所有服务器和工作站产品可能存在漏洞。官方上，只有英特尔 vPro 系统才包含 AMT。）该漏洞的范围相当有趣，因为它主要影响设计为通过远程 AMT
    管理控制台访问的系统，即使在关闭时——这意味着系统在关闭时也可能被 *攻击*。
- en: Typically, AMT was marketed as a part of the Intel vPro technology, but in the
    same presentation, Embedi researchers demonstrated that AMT could be enabled for
    non-vPro systems. They released the AMTactivator tool, which an operating system
    administrator could run to activate AMT even when it was not officially a part
    of the platform. The researchers showed that AMT was a part of all current Intel
    CPUs powered by the ME, no matter whether they were marketed as vPro-enabled or
    not; in the latter case, AMT was still present and could be activated, for good
    or bad. More details about this vulnerability can be found at *[https://www.blackhat.com/docs/us-17/thursday/us-17-Evdokimov-Intel-AMT-Stealth-Breakthrough-wp.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Evdokimov-Intel-AMT-Stealth-Breakthrough-wp.pdf)*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，AMT 被作为英特尔 vPro 技术的一部分进行推广，但在同一场展示中，Embedi 的研究人员演示了 AMT 可以在非 vPro 系统上启用。他们发布了
    AMTactivator 工具，操作系统管理员可以运行该工具来启用 AMT，即使它并非该平台的正式组成部分。研究人员展示了 AMT 是所有当前由 ME 驱动的英特尔
    CPU 的一部分，无论它们是否被宣传为 vPro 启用；在后一种情况下，AMT 仍然存在并可以激活，无论是好是坏。关于此漏洞的更多细节可以在 *[https://www.blackhat.com/docs/us-17/thursday/us-17-Evdokimov-Intel-AMT-Stealth-Breakthrough-wp.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Evdokimov-Intel-AMT-Stealth-Breakthrough-wp.pdf)*
    中找到。
- en: Intel has deliberately disclosed very little information regarding AMT, creating
    considerable difficulties for anyone outside of Intel attempting to research the
    security failings of this technology. However, advanced attackers took the challenge
    and made significant progress in analyzing AMT’s hidden possibilities. Further
    nasty surprises for defenders may follow.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔故意披露了关于 AMT 的极少信息，这给任何想要研究该技术安全漏洞的外部人员带来了相当大的困难。然而，先进的攻击者接受了挑战，并在分析 AMT 的隐藏可能性方面取得了显著进展。防御者可能还会面临更多令人不安的惊喜。
- en: '**THE PLATINUM APT ROOTKIT**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**铂金 APT 根工具**'
- en: Not directly related to Intel AMT firmware but also interesting is the fact
    that the so-called *PLATINUM APT* actor used AMT’s Serial-over-LAN (SOL) channel
    for network communications. This rootkit was discovered by Microsoft’s Windows
    Defender Research group in the summer of 2017\. AMT SOL’s communications worked
    independently of the operating system and so were invisible to the OS-level firewall
    and network monitoring applications running on the host device. Until this incident,
    no malware had been known to abuse the AMT SOL feature as a covert communication
    channel. For additional details, check out the original paper and blog post released
    by Microsoft (*[https://cloudblogs.microsoft.com/microsoftsecure/2017/06/07/platinum-continues-to-evolve-find-ways-to-maintain-invisibility/](https://cloudblogs.microsoft.com/microsoftsecure/2017/06/07/platinum-continues-to-evolve-find-ways-to-maintain-invisibility/)*).
    The existence of this channel was discovered by LegbaCore researchers, who disclosed
    it before it was discovered in the wild (*[http://legbacore.com/Research_files/HowManyMillionBIOSWouldYouLikeToInfect_Full.pdf](http://legbacore.com/Research_files/HowManyMillionBIOSWouldYouLikeToInfect_Full.pdf)*).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与英特尔AMT固件没有直接关系，但有趣的是，所谓的*PLATINUM APT*攻击者使用了AMT的串行-以太网（SOL）通道进行网络通信。这个根工具包是由微软的Windows
    Defender研究小组在2017年夏季发现的。AMT SOL的通信独立于操作系统工作，因此对操作系统级防火墙和在主机设备上运行的网络监控应用程序不可见。在此事件之前，尚未有恶意软件被发现利用AMT
    SOL特性作为隐蔽通信通道。更多详细信息，请查阅微软发布的原始论文和博客文章 (*[https://cloudblogs.microsoft.com/microsoftsecure/2017/06/07/platinum-continues-to-evolve-find-ways-to-maintain-invisibility/](https://cloudblogs.microsoft.com/microsoftsecure/2017/06/07/platinum-continues-to-evolve-find-ways-to-maintain-invisibility/)*)。该通道的存在是由LegbaCore的研究人员发现的，他们在该漏洞在野外被发现之前就已披露了这一信息
    (*[http://legbacore.com/Research_files/HowManyMillionBIOSWouldYouLikeToInfect_Full.pdf](http://legbacore.com/Research_files/HowManyMillionBIOSWouldYouLikeToInfect_Full.pdf)*).
- en: '**BMC Chip Vulnerabilities**'
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**BMC芯片漏洞**'
- en: 'At the same time that Intel was developing vPro offerings powered by the AMT
    platform’s ME execution environments, other vendors were busy developing competing
    centralized remote management solutions for servers: BMC chips integrated into
    the servers. As products of this parallel evolution, BMC designs have a lot of
    the same weaknesses as AMT.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与英特尔在开发基于AMT平台的vPro解决方案的同时，其他厂商也在忙于开发用于服务器的竞争性集中式远程管理解决方案：BMC芯片集成到服务器中。作为这一平行发展的产物，BMC设计与AMT有很多相同的弱点。
- en: Commonly found in server hardware, BMC deployments are ubiquitous in data centers.
    Major hardware vendors like Intel, Dell, and HP have their own BMC implementations,
    based primarily on ARM microcontrollers with integrated network interfaces and
    flash storage. This dedicated flash storage contains a real-time OS (RTOS) that
    powers a number of applications, such as a web server listening on the BMC chip’s
    network interface (a separate network management interface).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: BMC在服务器硬件中常见，BMC部署在数据中心中无处不在。像英特尔、戴尔和惠普等主要硬件厂商都有自己的BMC实现，主要基于集成了网络接口和闪存存储的ARM微控制器。这些专用的闪存存储包含一个实时操作系统（RTOS），支持多种应用程序，例如一个监听BMC芯片网络接口的Web服务器（一个独立的网络管理接口）。
- en: 'If you’ve been reading attentively, this should scream “attack surface!” Indeed,
    a BMC’s embedded web server is typically written in C (including CGI) and is thus
    a prime target for attackers in the market for input-handling vulnerabilities.
    A good example of such a vulnerability is HP iLO BMC’s CVE-2017-12542, which allowed
    an authentication bypass and remote code execution in the respective BMC’s web
    server. This security issue was discovered by Airbus researchers Fabien Périgaud,
    Alexandre Gazet, and Joffrey Czarny. We highly recommend their detailed whitepaper
    “Subverting Your Server Through Its BMC: The HPE iLO4 Case” (*[https://bit.ly/2HxeCUS](https://bit.ly/2HxeCUS)*).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在仔细阅读，这应该会让你想到“攻击面！”的警告。的确，BMC的嵌入式Web服务器通常是用C语言编写的（包括CGI），因此它是攻击者在寻找输入处理漏洞时的主要目标。一个很好的例子是HP
    iLO BMC的CVE-2017-12542漏洞，该漏洞允许身份验证绕过和远程代码执行。这一安全问题是由空客的研究人员Fabien Périgaud、Alexandre
    Gazet和Joffrey Czarny发现的。我们强烈推荐他们的详细白皮书《通过BMC颠覆你的服务器：HPE iLO4案例》 (*[https://bit.ly/2HxeCUS](https://bit.ly/2HxeCUS)*).
- en: BMC vulnerabilities underscore the fact that, no matter what hardware separation
    techniques you employ, the overall measure of a platform’s attack surface is its
    communication boundary. The more functionality you expose at this boundary, the
    greater the risk to the platform’s overall security. A platform may feature a
    separate CPU with a separate firmware running on it, but if this firmware includes
    a rich target, such as a web server, the attacker can leverage the platform’s
    weaknesses to install an implant. For example, a BMC-based firmware update process
    that does not authenticate over-the-network update images is just as vulnerable
    as any security-through-obscurity software installation scheme.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: BMC 漏洞凸显了一个事实：无论你采用何种硬件隔离技术，平台攻击面整体的衡量标准是其通信边界。你在这个边界上暴露的功能越多，平台整体安全性的风险就越大。一个平台可能配有一个独立的
    CPU 和运行独立固件，但如果这个固件包括一个丰富的目标，比如一个 web 服务器，攻击者就能利用平台的弱点安装植入物。例如，一个不对网络更新镜像进行身份验证的基于
    BMC 的固件更新过程，其安全性与任何安全性依赖模糊的软件下载方案一样脆弱。
- en: '**Conclusion**'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: The trustworthiness of UEFI firmware and other system firmware for x86-based
    platforms is a hot topic today, worthy of an entire book of its own. In a sense,
    UEFI was meant to reinvent the BIOS, but it did so with all the failings of security-by-obscurity
    approaches of the legacy BIOS, plus a lot more.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 固件和其他系统固件在 x86 平台上的可信度是今天的一个热门话题，值得写一本专门的书来讨论。从某种意义上说，UEFI 本应重新定义 BIOS，但它在保留了传统
    BIOS 安全性模糊化方法所有缺点的同时，带来了更多的问题。
- en: We made some hard decisions about which vulnerabilities to include here and
    which to give more detailed coverage to in order to illustrate the larger architectural
    failings. In the end, we hope that this chapter has covered just enough background
    to give you a deeper understanding of the current state of UEFI firmware security
    through the prism of common design flaws, rather than merely regaling you with
    a hodgepodge of infamous vulnerabilities.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做出了一些艰难的决定，决定包含哪些漏洞，以及哪些漏洞需要更详细的覆盖，以便说明更大的架构性失败。最终，我们希望这一章已经提供了足够的背景，以便通过常见设计缺陷的视角，帮助你深入了解当前
    UEFI 固件安全性，而不仅仅是给你讲述一堆臭名昭著的漏洞。
- en: Nowadays UEFI firmware is the cornerstone of platform security, despite being
    universally neglected by vendors a few years ago. The collaborative effort of
    the security research community made this change possible—and we hope that our
    book gives it its due and helps further its progress.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，UEFI 固件是平台安全性的基石，尽管几年前它在厂商中几乎被普遍忽视。安全研究社区的协作努力使得这一变化成为可能——我们希望我们的书能为此给予应有的关注，并帮助推动其进展。
