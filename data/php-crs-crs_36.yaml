- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 30 ORM LIBRARIES AND DATABASE SECURITY
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 30 ORM 库与数据库安全
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, we’ll explore techniques that make working with databases easier
    and more secure. First, much of the CRUD code in repository classes can become
    tedious and repetitive to write, varying only in terms of the names of the model
    classes and their properties. *Object-relational mapping (ORM) libraries* relieve
    this problem, automating lower-level work like preparing and executing SQL queries
    based on the way an application’s model classes are named and structured. You’ll
    see how to use such a library to simplify or replace our repository classes with
    just a few lines of code. We’ll start by adding a simple ORM library to our example
    web application, then later integrate the professional-grade Doctrine ORM library
    with the project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探索使数据库工作更简单、更安全的技术。首先，仓库类中的许多 CRUD 代码会变得乏味且重复，仅在模型类名称和其属性上有所不同。*对象关系映射（ORM）库*解决了这个问题，自动化了低级工作，比如根据应用程序的模型类的命名和结构准备和执行
    SQL 查询。你将看到如何使用这样的库，通过几行代码简化或替换我们的仓库类。我们将从向我们的示例网页应用程序添加一个简单的 ORM 库开始，然后在项目中整合专业级的
    Doctrine ORM 库。
- en: On the security front, adopting on ORM library will push us to remove any hardcoded
    database credentials from our code, instead placing those credentials in a separate
    data file. We’ll also explore best practices for handling login information in
    a web application, including using *password hashing* to avoid storing plaintext
    passwords in a database. As you’ll see, PHP provides built-in functions that make
    this process straightforward.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全方面，采用 ORM 库将推动我们从代码中移除任何硬编码的数据库凭证，而是将这些凭证放在一个单独的数据文件中。我们还将探索在网页应用程序中处理登录信息的最佳实践，包括使用*密码哈希*来避免在数据库中存储明文密码。正如你将看到的，PHP
    提供了内置的函数，使这个过程变得非常简单。
- en: Simplifying Database Code with an ORM Library
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ORM 库简化数据库代码
- en: One approach to making web applications communicate with databases is to design
    and write the necessary low-level code from scratch for each project. This includes
    the code to connect to database servers, create schemas and tables, and perform
    the four CRUD operations so that the database tables can store the data to support
    the application. Implementing this code requires careful analysis of the project
    requirements, especially the requirements for which data needs to be persisted
    to a database. The result is code that’s tailored to the application at hand and
    can be written for computational efficiency to maximize speed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一种使网页应用程序与数据库进行通信的方法是为每个项目从零开始设计并编写必要的低级代码。这包括连接数据库服务器的代码、创建模式和表格的代码，以及执行四个
    CRUD 操作的代码，以便数据库表格能够存储支持应用程序的数据。实现这些代码需要对项目需求进行仔细分析，尤其是哪些数据需要持久化到数据库中。最终的结果是，代码是针对当前应用程序量身定制的，可以根据计算效率来编写，以最大化速度。
- en: We’ve followed this approach of designing and writing custom, application-specific
    database code in the last few chapters. It’s been helpful for learning about how
    to work with a database, but it also comes with disadvantages. First, it takes
    time to design, write, and test code for every new application. Second, if the
    application requirements change, both the web application’s database communication
    code and the database structure itself need to be changed accordingly. Finally,
    any new developers joining a software team for an ongoing project will have to
    learn all the details of the system’s design to communicate with the database.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们采用了设计和编写定制的、特定应用程序的数据库代码的方法。这对学习如何与数据库交互很有帮助，但也带来了一些缺点。首先，每个新应用程序都需要花时间设计、编写和测试代码。其次，如果应用程序的需求发生变化，网页应用程序的数据库通信代码和数据库结构本身也需要相应地做出调整。最后，任何加入正在进行项目的开发者都必须学习系统设计的所有细节，以便能够与数据库进行交互。
- en: An alternative approach is to use an ORM library to abstract away the lower-level
    work of communication with the database. ORM libraries use the structure and associations
    of an application’s model classes (often with a little additional metadata) to
    automatically create and update the structure of the corresponding database tables.
    If changes in the application requirements lead to changes in the model classes
    (perhaps new model classes are added, or existing classes are given new properties
    or associations), then the ORM library can automatically update the database table
    structures accordingly and manage updated database queries based on the new model
    class declarations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 ORM 库来抽象化与数据库通信的底层工作。ORM 库使用应用程序模型类的结构和关联（通常还会有一些附加的元数据）来自动创建和更新相应数据库表的结构。如果应用程序需求的变化导致模型类发生变化（例如新增模型类，或者现有类添加了新属性或关联），那么
    ORM 库可以根据新的模型类声明自动更新数据库表结构，并管理基于这些更新后的模型类的数据库查询。
- en: ORM libraries can be less computationally efficient than custom-written low-level
    database communication code. If speed isn’t the most important feature for a web
    application, however, they have several strengths. For one, the database structure
    and queries are updated as soon as the model classes are updated, which streamlines
    the coding process. Also, if the project uses a well-known, industrial-standard
    ORM library, new developers joining a project will likely already be familiar
    with the abstracted ways to use the ORM library to handle database operations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与自定义编写的低级数据库通信代码相比，ORM 库的计算效率可能较低。然而，如果速度不是 Web 应用程序中最重要的特性，它们有几个优点。首先，数据库结构和查询会在模型类更新的同时自动更新，这简化了编码过程。此外，如果项目使用的是一个知名的工业标准
    ORM 库，那么加入项目的新开发人员很可能已经熟悉使用 ORM 库处理数据库操作的抽象方式。
- en: Before we get into the details of how to use an ORM library, let’s consider
    an example that illustrates this approach’s benefits, compared to using custom
    code. [Listing 30-1](#lis30-1) shows an excerpt of the ProductRepository class
    developed in the previous two chapters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解如何使用 ORM 库之前，让我们先看一个例子，说明这种方法与使用自定义代码相比的优势。[清单 30-1](#lis30-1)展示了前两章开发的
    ProductRepository 类的部分内容。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 30-1: Some of the contents of the ProductRepository class'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 30-1：ProductRepository 类的部分内容
- en: We developed this class manually, meaning we had to implement lower-level methods
    such as a constructor to retrieve a database connection and CRUD methods such
    as findAll() and find() to prepare and execute SQL queries. Compare this code
    with [Listing 30-2](#lis30-2), which declares an equivalent ProductRepository
    class with the help of an ORM library.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手动开发了这个类，这意味着我们必须实现一些底层方法，比如构造函数来获取数据库连接，以及 CRUD 方法，如 findAll() 和 find()，以准备和执行
    SQL 查询。将这段代码与[清单 30-2](#lis30-2)进行对比，后者通过 ORM 库的帮助声明了一个等效的 ProductRepository 类。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 30-2: A ProductRepository class inheriting from an ORM library'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 30-2：一个继承自 ORM 库的 ProductRepository 类
- en: For straightforward database interactions, an ORM library can do almost all
    the work for us. Instead of implementing custom methods in the repository class,
    we simply inherit those methods from an ORM library superclass (in this case,
    DatabaseTableRepository). The superclass is designed to use *reflection*, a technique
    of inspecting the classes and objects it interacts with, such as the Product model
    class. Then the superclass uses what it finds to generate SQL queries suitable
    for objects of those classes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于直接的数据库交互，ORM 库几乎可以为我们完成所有工作。我们不需要在 repository 类中实现自定义方法，而是简单地从 ORM 库的超类（在这种情况下是
    DatabaseTableRepository）继承这些方法。超类设计使用*反射*，这是一种检查它与之交互的类和对象的技术，比如 Product 模型类。然后，超类利用找到的信息生成适用于这些类对象的
    SQL 查询。
- en: In the coming sections, we’ll explore how this works in more detail by using
    a simple ORM library, one that I maintain as an open source project on GitHub.
    Later we’ll also try out an industrial-strength ORM library called Doctrine, one
    of the most popular ORM libraries available for modern PHP. For now, though, take
    a moment to appreciate how much shorter the ORM-assisted ProductRepository class
    declaration is than the manually coded version.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过使用一个简单的 ORM 库来更详细地探讨这一过程，这是我在 GitHub 上作为开源项目维护的一个库。稍后，我们还将尝试一个工业级的
    ORM 库，名为 Doctrine，这是现代 PHP 中最流行的 ORM 库之一。不过现在，先花点时间欣赏一下 ORM 辅助的 ProductRepository
    类声明比手动编写版本要简短得多。
- en: Adding an ORM Library to a Project
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将ORM库添加到项目中
- en: 'Let’s extend our database-driven web application from the previous chapters
    to work with a simple ORM library called pdo-crud-for-free-repositories that I
    maintain (*[https://github.com/dr-matt-smith/pdo-crud-for-free-repositories](https://github.com/dr-matt-smith/pdo-crud-for-free-repositories)*).
    It has limited features but is straightforward to use, making it a good tool for
    introducing the basics of ORM libraries. To get started, enter the following at
    the command line to add the library to the project:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展前几章中的数据库驱动Web应用程序，使用我维护的一个简单ORM库——pdo-crud-for-free-repositories（* [https://github.com/dr-matt-smith/pdo-crud-for-free-repositories](https://github.com/dr-matt-smith/pdo-crud-for-free-repositories)
    *）。该库功能有限，但易于使用，是介绍ORM库基础知识的好工具。要开始使用，在命令行中输入以下内容以将库添加到项目中：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will add a *mattsmithdev* folder inside *vendor* containing the library
    code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会在*vendor*文件夹中添加一个*mattsmithdev*文件夹，里面包含库的代码。
- en: At the time of this writing, the released version of the pdo-crud-for-free -repositories
    is compatible only with MySQL, so we’ll focus on the MySQL version of our web
    application rather than the SQLite version.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，发布的pdo-crud-for-free-repositories版本仅与MySQL兼容，因此我们将重点介绍我们的Web应用程序的MySQL版本，而非SQLite版本。
- en: Moving Database Credentials to a .env File
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将数据库凭据移至.env文件
- en: The ORM library we’re using requires all our database credentials to be declared
    in a file named *.env*, commonly known as a *dotenv file*, rather than hardcoded
    in the Database class where we currently have them. Dotenv files are human-readable
    text files defining name/value pairs necessary for a program to run; other common
    file types for such variables include XML and YAML. This requirement is not a
    bad thing, since it also makes the application more secure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的ORM库要求所有数据库凭据都声明在名为*.env*的文件中，该文件通常被称为*dotenv文件*，而不是硬编码在我们目前的Database类中。Dotenv文件是人类可读的文本文件，用于定义程序运行所需的名称/值对；其他常见的文件类型包括XML和YAML。这一要求并不是坏事，因为它还增强了应用程序的安全性。
- en: Typically, we’d exclude dotenv files when using version-control systems such
    as Git so that when code is archived or pushed to open source projects, sensitive
    database credentials won’t be included. This reduces the chance of a security
    breach from code being published or distributed to unauthorized people. Another
    advantage of this approach is that different environments can be set up in multiple
    dotenv files, such as for local development, remote development, testing, and
    live production systems.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在使用版本控制系统（如Git）时，我们会排除dotenv文件，以便在代码归档或推送到开源项目时，不会包含敏感的数据库凭据。这减少了通过代码发布或分发给未经授权的人所引发的安全漏洞的可能性。这种方法的另一个好处是，可以在多个dotenv文件中设置不同的环境，如本地开发、远程开发、测试和实际生产系统。
- en: To satisfy this ORM library requirement, create a file called *.env* and save
    it in the main project directory. Enter the contents of [Listing 30-3](#lis30-3)
    into the file, changing values such as the password and port to match the MySQL
    server properties running on your computer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足该ORM库的要求，创建一个名为*.env*的文件，并将其保存在主项目目录中。将[列表30-3](#lis30-3)中的内容输入文件中，并根据您计算机上运行的MySQL服务器属性修改密码和端口等值。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 30-3: The database credentials in the .env file'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表30-3：.env文件中的数据库凭据
- en: These MySQL attributes were all previously defined as constants in our Database
    class. We can now delete the Database class from our project, since the ORM library
    comes with its own class for managing the connection with the database, based
    on the information in the dotenv file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些MySQL属性之前都作为常量定义在我们的Database类中。现在，我们可以将Database类从项目中删除，因为ORM库自带了一个类来管理与数据库的连接，基于dotenv文件中的信息。
- en: Relegating Product Operations to the ORM Library
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将产品操作委托给ORM库
- en: Now that the ORM library has access to the database, we can shift responsibility
    for all CRUD operations relating to the product table from our ProductRepository
    class to the ORM library. We’ll still use the ProductRepository class, but as
    hinted earlier, instead of manually filling it with methods that prepare and execute
    SQL statements, we’ll simply declare it to be a subclass of one of the ORM library
    classes. Replace the contents of *src/ProductRepository.php* with the code shown
    in [Listing 30-4](#lis30-4).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 既然 ORM 库已经可以访问数据库，我们就可以将所有与产品表相关的 CRUD 操作的责任，从 ProductRepository 类转移到 ORM 库中。我们仍然会使用
    ProductRepository 类，但正如之前所暗示的那样，我们不再手动填充它的方法来准备和执行 SQL 语句，而是简单地将它声明为 ORM 库类的一个子类。用
    [Listing 30-4](#lis30-4) 中显示的代码替换 *src/ProductRepository.php* 文件的内容。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 30-4: The much-simplified ProductRepository class'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 30-4: 极大简化的 ProductRepository 类'
- en: 'The use statement specifies that we want to refer to the DatabaseTableRepository
    class in the Mattsmithdev\PdoCrudRepo namespace. Then we declare ProductRepository
    as a subclass of DatabaseTableRepository, with no code whatsoever in the class
    body. And that’s it! We now have a working ProductRepository class with just those
    few lines of code. It will inherit all the methods declared in the DatabaseTableRepository
    superclass that happen to follow the same naming convention we used previously:
    find(), findAll(), delete(), deleteAll(), and so on.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语句指定我们想要引用 Mattsmithdev\PdoCrudRepo 命名空间中的 DatabaseTableRepository 类。然后我们将
    ProductRepository 声明为 DatabaseTableRepository 的子类，类体中不包含任何代码。就这样！我们现在拥有了一个只包含几行代码的有效
    ProductRepository 类。它将继承 DatabaseTableRepository 超类中所有的方法，这些方法恰好遵循我们之前使用的命名约定：find()、findAll()、delete()、deleteAll()
    等。
- en: But how does the DatabaseTableRepository class know that we want it to work
    with a product table with id, description, and price fields? This is where reflection
    comes into play. The DatabaseTableRepository class uses this technique to infer
    the details about how to construct appropriate SQL statements based on the classes
    and objects it comes into contact with. In this case, the reflection code assumes
    that the ProductRepository repository class manages database methods for a model
    class in the same namespace called Product, and that a corresponding product table
    in the database has fields matching the property names of the Product class. As
    long as all the names align, the ORM library will be able to do its job.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，DatabaseTableRepository 类是如何知道我们希望它与一个具有 id、description 和 price 字段的产品表配合使用的呢？这就是反射技术发挥作用的地方。DatabaseTableRepository
    类使用这种技术来推断如何根据它接触到的类和对象构建适当的 SQL 语句。在这种情况下，反射代码假设 ProductRepository 仓库类管理一个与同一命名空间中的名为
    Product 的模型类相对应的数据库方法，并且数据库中相应的产品表具有与 Product 类的属性名称匹配的字段。只要所有的名称一致，ORM 库就能完成它的工作。
- en: For the reflection process to work, the DatabaseTableRepository methods need
    to receive objects of the appropriate model class, rather than free- floating
    variables as we’d previously designed the CRUD methods in [Chapter 29](chapter29.xhtml).
    To finalize the shift to the ORM library, we therefore need to refactor our ProductController
    class to pass in Product objects when calling the insert() and update() methods
    to process new and updated products. Change the *src/ProductController.php* file
    as shown in [Listing 30-5](#lis30-5).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让反射过程正常工作，DatabaseTableRepository 方法需要接收适当模型类的对象，而不是我们之前在 [第29章](chapter29.xhtml)
    设计 CRUD 方法时使用的自由浮动变量。为了最终完成对 ORM 库的转换，我们需要重构我们的 ProductController 类，在调用 insert()
    和 update() 方法处理新产品和更新产品时，传入 Product 对象。按照 [Listing 30-5](#lis30-5) 中的方式修改 *src/ProductController.php*
    文件。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 30-5: The updated src/ProductController.php class'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 30-5: 更新后的 src/ProductController.php 类'
- en: In the revised processCreate() method, we first create a new Product object
    and set its description and price properties to the values passed into the method.
    We then pass this Product object to the ProductRepository object’s insert() method
    to add the new product to the database ❶. The ORM library assumes that every database
    table has an auto-incrementing primary key named id, so no value for the product
    ID is needed when creating a new row in the database. We make a similar change
    to the processEdit() method, using the id to get a reference to the Product object
    to be updated ❷, setting the other properties received from the form, and passing
    the object reference to the repository class’s update() method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改后的processCreate()方法中，我们首先创建一个新的Product对象，并将其描述和价格属性设置为传入方法的值。然后，我们将这个Product对象传递给ProductRepository对象的insert()方法，以将新产品添加到数据库中❶。ORM库假设每个数据库表都有一个名为id的自增主键，因此在创建新数据库行时，不需要为产品ID提供值。我们对processEdit()方法做了类似的修改，使用id来获取要更新的Product对象的引用❷，设置从表单接收到的其他属性，并将对象引用传递给仓库类的update()方法。
- en: Run the web server and you should now see the web application is working just
    as before, but with significantly less code! In this way, working with an ORM
    library greatly simplified the task of executing standard database CRUD operations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Web服务器，你现在应该能看到Web应用程序与之前一样工作，但代码大大减少！通过这种方式，使用ORM库大大简化了执行标准数据库CRUD操作的任务。
- en: NOTE
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Before moving on, make a copy of your project at this point. In “The Doctrine
    ORM Library” on [page 615](#pg_615), we’ll modify that copy to use Doctrine.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*在继续之前，先在此时备份你的项目。在《Doctrine ORM库》一节中（见[第615页](#pg_615)），我们将修改该副本以使用Doctrine。*'
- en: Adding a New Database Table
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加新数据库表
- en: Now that we’ve incorporated the ORM library into the project, let’s expand our
    web application by adding another table to the database. With the library handling
    all the CRUD operations, the process will be much more efficient than our effort
    in [Chapter 29](chapter29.xhtml) to get CRUD working for the product table. When
    we look at security in “Security Best Practices” on [page 608](#pg_608), we’ll
    discuss best practices for handling passwords, so we’ll go ahead and add a user
    table storing username and password information.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将ORM库集成到项目中，让我们通过向数据库添加另一个表来扩展我们的Web应用程序。由于库处理所有CRUD操作，整个过程将比我们在[第29章](chapter29.xhtml)中为产品表实现CRUD时更高效。当我们在《安全最佳实践》一节（见[第608页](#pg_608)）中讨论安全时，我们将讨论处理密码的最佳实践，因此我们将继续添加一个存储用户名和密码信息的用户表。
- en: Along with the new database table, we’ll need a User model class, a UserRepository
    repository class (so named to match the ORM library’s requirements), a UserController
    controller class, and a page for displaying all the users. [Figure 30-1](#fig30-1)
    shows that page. Of course, this page exists just to illustrate that the database
    methods are working; displaying a list of usernames and passwords is *not* an
    example of secure web development.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新的数据库表外，我们还需要一个User模型类，一个UserRepository仓库类（命名符合ORM库的要求），一个UserController控制器类，以及一个用于显示所有用户的页面。[图30-1](#fig30-1)展示了该页面。当然，这个页面仅用于演示数据库方法是否正常工作；显示用户名和密码列表*并不是*安全Web开发的示例。
- en: '![](../images/figure30-1.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure30-1.jpg)'
- en: 'Figure 30-1: The User List page'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图30-1：用户列表页面
- en: We’ll start by declaring the User model class. Add a *src/User.php* file containing
    the code in [Listing 30-6](#lis30-6) to the project.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从声明User模型类开始。将[列表30-6](#lis30-6)中的代码添加到*src/User.php*文件，并将其添加到项目中。
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 30-6: The User class'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表30-6：User类
- en: The class has an integer id property (a requirement for the ORM library) and
    string properties for username and password. We declare standard getter and setter
    methods for each of these properties.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该类具有一个整数id属性（这是ORM库的要求），以及用于存储用户名和密码的字符串属性。我们为这些属性声明了标准的getter和setter方法。
- en: Now we’ll create the UserRepository class in *src/UserRepository.php*. As with
    ProductRepository, we’ll have this class extend the ORM library’s DatabaseTableRepository
    class. [Listing 30-7](#lis30-7) shows the code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在*src/UserRepository.php*中创建UserRepository类。与ProductRepository一样，我们将让这个类继承ORM库的DatabaseTableRepository类。[列表30-7](#lis30-7)展示了代码。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 30-7: The simple UserRepository class'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表30-7：简单的UserRepository类
- en: We don’t need to declare any methods for this repository class, since it will
    inherit all the necessary CRUD methods from the DatabaseTableRepository class.
    Thanks to the naming of the UserRepository and User classes, these CRUD methods
    will know to work with the user table in the database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为这个仓库类声明任何方法，因为它将继承自DatabaseTableRepository类的所有必要的CRUD方法。由于UserRepository和User类的命名，这些CRUD方法将知道与数据库中的用户表进行交互。
- en: Next, let’s create a UserController class, with a method to retrieve all users
    from the database and display them with a Twig template. Create *src/UserController.php*
    containing the code in [Listing 30-8](#lis30-8).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个UserController类，其中包含一个从数据库中检索所有用户并使用Twig模板显示它们的方法。创建*src/UserController.php*并包含[清单30-8](#lis30-8)中的代码。
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 30-8: The UserController class declaring a list() method'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-8：UserController类声明list()方法
- en: We declare UserController as a subclass of Controller so that it will inherit
    a twig property for rendering templates. We declare a private userRepository property
    and initialize it in the constructor (where we also must first invoke the parent
    Controller class’s constructor to set up the twig property). We then declare a
    list() method, which uses the UserRepository object’s findAll() method (inherited
    from the ORM library) to retrieve all users from the database ❶. The results are
    returned as an array of objects, which we store as $users. We pass this array
    as the Twig variable users for rendering by the *templates/user/list.xhtml.twig*
    template.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将UserController声明为Controller的子类，以便它继承一个用于渲染模板的twig属性。我们声明一个私有的userRepository属性，并在构造函数中初始化它（同时必须先调用父类Controller的构造函数以设置twig属性）。接着，我们声明一个list()方法，它使用UserRepository对象的findAll()方法（继承自ORM库）从数据库中检索所有用户❶。结果作为对象数组返回，我们将其存储为$users。然后，我们将这个数组作为Twig变量users传递给*templates/user/list.xhtml.twig*模板进行渲染。
- en: Now we’ll add a navigation bar link for the User List page to the base Twig
    template that all other templates inherit from. Update *templates/base.xhtml.twig*
    to match the contents of [Listing 30-9](#lis30-9).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在所有其他模板继承的基本Twig模板中添加一个指向用户列表页面的导航栏链接。更新*templates/base.xhtml.twig*以匹配[清单30-9](#lis30-9)的内容。
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 30-9: Adding a user list link to /templates/base.xhtml.twig'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-9：将用户列表链接添加到/templates/base.xhtml.twig
- en: Here we add a navigation list item with the text User List page. The anchor
    element has an action of users, and its CSS class attribute declares an empty
    Twig block called userLink. As with the other navigation bar items, this block
    can be overridden with the text active to highlight the link.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个导航列表项，文本为用户列表页面。该锚元素的action为users，CSS类属性声明了一个名为userLink的空Twig块。与其他导航栏项一样，这个块可以被重写为文本active，以突出显示该链接。
- en: With the base template updated, we can now create the *templates/user/list.xhtml.twig*
    child template for the User List page. [Listing 30-10](#lis30-10) shows how.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 更新了基本模板后，我们现在可以为用户列表页面创建*templates/user/list.xhtml.twig*子模板。[清单30-10](#lis30-10)展示了如何操作。
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 30-10: The list.xhtml.twig template'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-10：list.xhtml.twig模板
- en: In this template, we override the userLink block to contain the text active
    ❶, highlighting the User List page link in the navigation bar. In the body block,
    we use a Twig for loop ❷ to iterate through the users array, creating a list item
    for each user displaying the associated ID, username, and password.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，我们重写了userLink块，使其包含文本active ❶，在导航栏中突出显示用户列表页面链接。在body块中，我们使用Twig的for循环❷遍历用户数组，为每个用户创建一个列表项，显示关联的ID、用户名和密码。
- en: Now we need to add a case for the action=users route to our front-controller
    Application class. Update *src/Application.php* to match the contents of [Listing
    30-11](#lis30-11).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为action=users路由在我们的前端控制器应用程序类中添加一个案例。更新*src/Application.php*以匹配[清单30-11](#lis30-11)的内容。
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 30-11: Adding a route to the user list in the Application class'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-11：在Application类中添加用户列表的路由
- en: We declare a userController property and initialize it as a new UserController
    object in the constructor. Then, in the switch statement, we declare a case for
    when the action is 'users', invoking the list() method of the UserController object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个userController属性，并在构造函数中将其初始化为一个新的UserController对象。然后，在switch语句中，我们声明一个当action为'users'时的case，调用UserController对象的list()方法。
- en: All we need to do now is add the user table to the database schema and insert
    user rows into the table. Create a new helper script, *db/setup_users.php*, as
    shown in [Listing 30-12](#lis30-12).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将用户表添加到数据库模式中，并向表中插入用户行。创建一个新的辅助脚本，*db/setup_users.php*，如[清单30-12](#lis30-12)所示。
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 30-12: The setup script for the user table in /db/setup_users.php'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-12：/db/setup_users.php中用户表的设置脚本
- en: When we first set up the product table in [Chapter 28](chapter28.xhtml), we
    had to manually type out and execute each SQL statement to add a new row to the
    database. Now we can instead build each row as an instance of the User class and
    add it to the table by calling the insert() method of the UserRepository class
    (inherited from the ORM library). In this script, we do that for two users, assigning
    them usernames and passwords.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一次设置[第28章](chapter28.xhtml)中的产品表时，我们需要手动输入并执行每个SQL语句，以便向数据库中添加一行新数据。现在，我们可以通过将每一行构建为User类的实例，并通过调用UserRepository类的insert()方法（该方法继承自ORM库）来将其添加到表中。在这个脚本中，我们为两个用户做了这个操作，分配了他们的用户名和密码。
- en: First, though, we invoke the UserRepository class’s resetTable() method ❶, which
    drops any existing table mapped to the User class and creates a new table based
    on the names and data types of the User class. This is another “free” method automatically
    available to our repository class through inheritance from the ORM library’s DatabaseTableRepository
    class. To confirm the database table has been created and two User records have
    been inserted, the script ends by retrieving all users from the database with
    the findAll() method and printing them with var_dump().
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用UserRepository类的resetTable()方法❶，该方法会删除任何已映射到User类的现有表，并根据User类的名称和数据类型创建一个新表。通过继承自ORM库的DatabaseTableRepository类，这又是一个“免费”的方法，自动可用于我们的存储库类。为了确认数据库表已被创建并且两个User记录已被插入，脚本最后通过findAll()方法从数据库中检索所有用户并使用var_dump()打印它们。
- en: 'Enter php db/setup_users.php at the terminal to run this setup script. You
    should see the following output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端输入php db/setup_users.php来运行这个设置脚本。你应该会看到以下输出：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The terminal output shows an array containing two User objects, proof that the
    user database table has been added to the database schema, complete with two users.
    At this point, you can also launch the web application again and visit the User
    List page. It should look like [Figure 30-1](#fig30-1).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 终端输出显示了一个包含两个User对象的数组，证明用户数据库表已被添加到数据库模式中，并且已插入了两个用户。此时，你也可以重新启动Web应用程序并访问用户列表页面。它应该看起来像[图30-1](#fig30-1)。
- en: By working with my pdo-crud-for-free-repositories library, we’ve seen how using
    an ORM library can remove the need to code low-level database queries. This reduces
    the amount of code required for each individual web application, simplifying the
    development process. We’ll continue to use this library as we turn our attention
    to application security, but later we’ll return to the topic of ORM libraries
    to see the added benefits of working with a more sophisticated library like Doctrine.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用我的pdo-crud-for-free-repositories库，我们已经看到如何使用ORM库来避免编写底层数据库查询。这减少了每个Web应用程序所需的代码量，从而简化了开发过程。我们将继续使用这个库，转而关注应用程序安全性，但稍后我们会回到ORM库的话题，看看使用像Doctrine这样更复杂的库能带来的额外好处。
- en: Security Best Practices
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全最佳实践
- en: Security is an essential part of software development, both in your local development
    environment and when deploying web applications to the real world as public websites.
    Perhaps the most common manifestation of security a user meets these days is a
    username/password login form. We’ll explore best practices for securing login
    information in this section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是软件开发中的一个关键部分，无论是在本地开发环境中，还是在将Web应用程序部署到实际的公共网站时。如今，用户最常遇到的安全性体现之一便是用户名/密码登录表单。我们将在本节中探讨保护登录信息的最佳实践。
- en: Storing Hashed Passwords
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 存储哈希密码
- en: You should never store plaintext passwords in your application’s database. Otherwise,
    if someone gets access to the database, all those accounts would be compromised.
    One option for securely storing data is to *encrypt* it, encoding data in such
    a way that it can be decoded back to its original form at a later time. When sending
    confidential messages, for example, it’s common to encrypt them first and to provide
    the intended recipient with the method for decrypting the message once received.
    For passwords, however, encryption isn’t the best solution; if the database were
    accessed, brute-force techniques could allow attackers to eventually decrypt the
    data (although depending on the speed of their computers, it might take a long
    time).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你绝不应该在应用程序的数据库中存储明文密码。否则，如果有人获得了数据库的访问权限，所有这些账户都会受到威胁。安全存储数据的一个选择是 *加密*，即以某种方式对数据进行编码，以便在以后能够解码回原始形式。例如，在发送机密消息时，通常会先对其加密，并在接收方收到消息后提供解密方法。然而，对于密码来说，加密并不是最好的解决方案；如果数据库被访问，暴力破解技术可能会允许攻击者最终解密数据（尽管根据他们计算机的速度，可能需要很长时间）。
- en: A better technique for password storage is *hashing*. This is an irreversible
    way of creating a new piece of data from the original data; there’s no way to
    reconstruct the plaintext password from the hashed version. The same password
    passed through the same hash algorithm will always yield the same hash, however.
    When a user is logging into an application, you can therefore test whether their
    password is valid by hashing what they’ve entered and comparing it with the hash
    stored in the database. With this mechanism, there’s no need to ever store the
    original plaintext password.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更好的密码存储技术是 *哈希处理*。这是一种不可逆的方式，通过原始数据生成新的数据；无法从哈希版本恢复出明文密码。然而，相同的密码通过相同的哈希算法处理时将始终生成相同的哈希值。因此，当用户登录应用程序时，你可以通过哈希他们输入的密码并与数据库中存储的哈希值进行比较，从而验证密码是否有效。使用这种机制，永远不需要存储原始的明文密码。
- en: Let’s make our web application more secure by storing hashes rather than plaintext
    passwords in the user database table. Conveniently, modern PHP offers a built-in
    password_hash() function for calculating the hash of a string. We’ll change the
    setPassword() method of the User entity class to take advantage of this function.
    Update *src/User.php* to match the contents of [Listing 30-13](#lis30-13).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在用户数据库表中存储哈希值而不是明文密码来提高我们Web应用的安全性。方便的是，现代 PHP 提供了一个内置的 `password_hash()`
    函数，用于计算字符串的哈希值。我们将修改用户实体类的 `setPassword()` 方法，利用这个函数。请更新 *src/User.php* 文件，使其内容与
    [Listing 30-13](#lis30-13) 匹配。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 30-13: Storing a hashed password in the User class'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 30-13: 在用户类中存储哈希密码'
- en: The revised setPassword() method takes in the plaintext password for a new user
    and passes it to the password_hash() function for hashing. The PASSWORD_DEFAULT
    constant means the function will use the strongest hashing algorithm available
    in the installed version of PHP, though there are other constants for explicitly
    choosing a particular hashing algorithm. We store the hash in the $hashedPassword
    variable and assign this as the value of the User object’s password property.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的 `setPassword()` 方法接受新用户的明文密码，并将其传递给 `password_hash()` 函数进行哈希处理。`PASSWORD_DEFAULT`
    常量意味着该函数将使用安装的 PHP 版本中最强的哈希算法，尽管也有其他常量可以明确选择某种特定的哈希算法。我们将哈希值存储在 `$hashedPassword`
    变量中，并将其作为用户对象的密码属性的值。
- en: 'With this change, any new User objects created and passed to the database will
    contain hashed rather than plaintext passwords. To prove it, rerun our user table
    setup script by entering php db/setup_users.php at the command line. This will
    delete and re-create the table with the modified User class. Here’s the resulting
    var_dump() output in the terminal:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，任何新创建并传递到数据库的用户对象将包含哈希密码，而不是明文密码。为了验证这一点，在命令行输入 `php db/setup_users.php`
    重新运行用户表设置脚本。这将删除并重新创建包含修改后用户类的表。以下是在终端中显示的 `var_dump()` 输出：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The black text lines show the hashes in each password field. Each hash is a
    long character string that has no discernible relationship with the original password.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 黑色文本行显示每个密码字段中的哈希值。每个哈希值都是一个长字符字符串，与原始密码没有明显的关系。
- en: Verifying Hashed Passwords at Login
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 登录时验证哈希密码
- en: Another useful built-in PHP function is password_verify(), which takes in a
    plaintext password, hashes it, and compares it with an existing hash to determine
    whether the password is correct. With this function, we can implement a login
    page for our application, where the user inputs a username and password for verification
    against their record in the user database table. [Figure 30-2](#fig30-2) shows
    the login page we’ll create.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的内建 PHP 函数是 password_verify()，它接受一个明文密码，将其哈希化，并与现有的哈希值进行比较，以确定密码是否正确。使用这个函数，我们可以为应用程序实现一个登录页面，用户在其中输入用户名和密码，系统会根据用户数据库表中的记录进行验证。[图
    30-2](#fig30-2)展示了我们将要创建的登录页面。
- en: '![](../images/figure30-2.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/figure30-2.jpg)'
- en: 'Figure 30-2: The new login page'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 30-2：新的登录页面
- en: Our application will need two new routes, one to request display of the login
    page (action=login) and one to request processing of the submitted data from the
    login form (action=processLogin). First, we’ll add cases for these routes to our
    front-controller Application class. Update the switch statement in *src/Application.php*
    to match [Listing 30-14](#lis30-14).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要两个新路由，一个用于请求显示登录页面（action=login），另一个用于请求处理从登录表单提交的数据（action=processLogin）。首先，我们将为这些路由添加对应的情况到我们的前端控制器
    Application 类中。更新 *src/Application.php* 中的 switch 语句以匹配 [列表 30-14](#lis30-14)。
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 30-14: Adding login routes to the Application class'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 30-14：向应用程序类添加登录路由
- en: For the 'login' case, we invoke the loginForm() method of the UserController
    object ❶. For the 'processLogin' case, we first attempt to extract the 'username'
    and 'password' values from the variables received in the POST request. If either
    is empty ❷, an appropriate error message is displayed by passing a string message
    to the error() method of the DefaultController object. Otherwise, the username
    and password are passed to the processLogin() method of the UserController object
    ❸.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 'login' 情况，我们调用 UserController 对象的 loginForm() 方法 ❶。对于 'processLogin' 情况，我们首先尝试从
    POST 请求中提取 'username' 和 'password' 的值。如果其中任何一个为空 ❷，则通过将字符串消息传递给 DefaultController
    对象的 error() 方法，显示相应的错误信息。否则，用户名和密码会传递给 UserController 对象的 processLogin() 方法 ❸。
- en: Now we need to add the new methods to the UserController class. Update *src/UserController.php*
    as shown in [Listing 30-15](#lis30-15).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要向 UserController 类添加新方法。更新 *src/UserController.php*，如 [列表 30-15](#lis30-15)
    所示。
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 30-15: Adding login methods to the UserController class'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 30-15：向 UserController 类添加登录方法
- en: For the loginForm() method, we simply render the appropriate Twig template,
    which doesn’t require any arguments. For the processLogin() method, we take in
    the received $username and $password variables and pass them to the isValidUsernamePassword()
    helper method ❶, which returns a Boolean. If true, we print a success message,
    or an error message if false. In a full web application, at this stage, we would
    store the login success in the session as we did in [Chapter 16](chapter16.xhtml).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 loginForm() 方法，我们仅渲染相应的 Twig 模板，该模板不需要任何参数。对于 processLogin() 方法，我们接收 $username
    和 $password 变量，并将它们传递给 isValidUsernamePassword() 辅助方法 ❶，该方法返回一个布尔值。如果返回 true，我们显示成功消息；如果返回
    false，则显示错误消息。在完整的 Web 应用中，在此阶段，我们会像在 [第 16 章](chapter16.xhtml) 中那样将登录成功信息存储到会话中。
- en: The isValidUsernamePassword() helper is responsible for determining whether
    the database holds a record matching the received username and password. First,
    we call the UserRepository class method findOneByUsername(), which attempts to
    retrieve a record (in the form of a User object) from the user table matching
    the provided username ❷. If a single user can’t be retrieved, findOneByUsername()
    returns NULL, in which case the validation method returns false. Otherwise, we
    call PHP’s built-in password_verify() function, passing it the submitted password
    ($password) and the correct password hash (accessed with the User object’s getPassword()
    method) ❸. The password_verify() function hashes the provided plaintext password
    and returns a Boolean indicating whether it matches the provided hash.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: isValidUsernamePassword() 辅助函数负责确定数据库中是否存在与接收到的用户名和密码匹配的记录。首先，我们调用 UserRepository
    类的方法 findOneByUsername()，它尝试从用户表中检索与提供的用户名匹配的记录（以 User 对象的形式） ❷。如果无法检索到单个用户，findOneByUsername()
    会返回 NULL，此时验证方法返回 false。否则，我们调用 PHP 内建的 password_verify() 函数，将提交的密码（$password）和正确的密码哈希（通过
    User 对象的 getPassword() 方法访问）传入 ❸。password_verify() 函数会对提供的明文密码进行哈希处理，并返回一个布尔值，指示它是否与提供的哈希值匹配。
- en: Now let’s write the findOneByUsername() method for the UserRepository class.
    Update *src/UserRepository.php* to match the code in [Listing 30-16](#lis30-16).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为UserRepository类编写findOneByUsername()方法。更新*src/UserRepository.php*，使其与[清单30-16](#lis30-16)中的代码一致。
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 30-16: Adding the findOneByUsername() method to the UserRepository
    class'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-16：将findOneByUsername()方法添加到UserRepository类
- en: The new findOneByUsername() method has a nullable ?User return type. It uses
    the searchByColumn() method inherited from the ORM library, which takes in a column
    name ('username') and a value (in the $username variable) and returns an array
    of records where the value in that column of the database table is a match. If
    the resulting array doesn’t have a length of exactly 1 (either because it’s empty
    or because multiple records were retrieved), findOneByUsername() returns NULL.
    However, if a single user matches the submitted username string, the corresponding
    User object is returned.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 新的findOneByUsername()方法具有可空的?User返回类型。它使用从ORM库继承的searchByColumn()方法，该方法接受列名（'username'）和一个值（在$username变量中），并返回一个记录数组，其中数据库表中该列的值与给定值匹配。如果返回的数组的长度不等于1（无论是为空还是返回了多个记录），findOneByUsername()将返回NULL。然而，如果单个用户与提交的用户名字符串匹配，则返回相应的User对象。
- en: Note that the logic in this method could have been made part of the isValidUsernamePassword()
    method in UserController, but what’s needed is a query for a user with a given
    username, which is a model database query. It therefore makes sense to create
    this as a custom method in our UserRepository class, where all the code for querying
    the user database table lives. It’s also worth highlighting that even though we’re
    relying on an ORM library for generic methods such as find() and findAll(), it’s
    often still necessary to extend a repository class with custom database methods
    that support the more specialized controller logic specific to the application
    at hand. In this case, we need to search by the username column rather than id,
    so the inherited find() method wouldn’t do. The ORM library is still helping us
    through the searchByColumn() method, but we still need the custom logic of verifying
    that exactly one User object has been retrieved.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个方法中的逻辑本可以成为UserController中isValidUsernamePassword()方法的一部分，但我们需要的是一个通过给定用户名查询用户的操作，这属于模型数据库查询。因此，将其作为我们UserRepository类中的自定义方法是合适的，因为所有查询用户数据库表的代码都在这里。值得一提的是，尽管我们依赖ORM库中的通用方法，如find()和findAll()，但通常仍然需要通过扩展仓库类来支持特定于应用程序的更专业的控制器逻辑。在这种情况下，我们需要按用户名列而不是ID来查询，因此继承的find()方法不适用。ORM库仍然通过searchByColumn()方法帮助我们，但我们仍然需要自定义逻辑来验证确实只获取了一个User对象。
- en: Next, we’ll add a login page link to the navigation bar in the base template.
    Update *templates/base.xhtml.twig* as shown in [Listing 30-17](#lis30-17).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在基础模板中的导航栏中添加一个登录页面链接。更新*templates/base.xhtml.twig*，如[清单30-17](#lis30-17)所示。
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 30-17: Adding a login link to the base.xhtml.twig template'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-17：将登录链接添加到base.xhtml.twig模板
- en: Here we add a navigation list item with the text Login and a URL route of action=login.
    With that added, we can create the child template for the login page itself in
    */templates/user/login.xhtml.twig*. [Listing 30-18](#lis30-18) shows the code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个导航列表项，文本为“登录”，URL路由为action=login。添加后，我们可以在*/templates/user/login.xhtml.twig*中创建登录页面本身的子模板。[清单30-18](#lis30-18)显示了代码。
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 30-18: The login.xhtml.twig template'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-18：login.xhtml.twig模板
- en: The body of the page features a <form> element with a POST action of processLogin.
    The form features fields for a username and password, along with a Submit button.
    Notice that the password input is of type "password" ❶. With this setting, the
    browser will display placeholder characters such as dots or asterisks, hiding
    the actual characters the user enters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 页面主体包含一个<form>元素，POST动作为processLogin。该表单包含用户名和密码字段，以及一个提交按钮。请注意，密码输入框的类型是"password"
    ❶。设置为此后，浏览器将显示占位符字符，例如点或星号，从而隐藏用户输入的实际字符。
- en: Try testing out the new login form with the username matt and password password1,
    or with any incorrect username/password combination. Thanks to PHP’s secure, handy
    password_verify() function, you should find that the form works, even though the
    database is storing password hashes rather than plaintext passwords.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用用户名matt和密码password1，或使用任何不正确的用户名/密码组合来测试新的登录表单。得益于PHP的安全、便捷的password_verify()函数，您应该会发现表单能够正常工作，即使数据库中存储的是密码哈希，而不是明文密码。
- en: Securing Database Credentials
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据库凭证的安全性
- en: Another important security measure for web applications is to avoid exposing
    your database credentials. Whether you declare these credentials as class constants
    or in a completely separate file such as *.env*, as we did earlier in the chapter,
    it’s important not to have them in any public-facing files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的Web应用程序安全措施是避免暴露数据库凭证。无论你是将这些凭证声明为类常量，还是像我们在本章早些时候所做的那样存放在一个完全独立的文件中（如*.env*），都必须确保它们不出现在任何公开文件中。
- en: To begin, you should have only a single file for your credentials. If you’re
    using class constants rather than a *.env* file, I recommend having a completely
    separate class that just declares the constants. Then you can reference this class
    from your Database class (or whatever other class is responsible for establishing
    the database connection).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时，你应该只为凭证拥有一个单独的文件。如果你使用类常量而不是*.env*文件，我建议你创建一个完全独立的类，仅声明常量。然后你可以在数据库类（或任何其他负责建立数据库连接的类）中引用这个类。
- en: Next, mark the file containing your credentials to be ignored by any backup
    or archiving system. For example, if you’re using the Git distributed version
    control system, you’d list this file in your project’s *.gitignore* file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，标记包含凭证的文件，以便任何备份或归档系统忽略该文件。例如，如果你使用的是Git分布式版本控制系统，你需要在项目的*.gitignore*文件中列出该文件。
- en: The Doctrine ORM Library
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Doctrine ORM库
- en: The open source Doctrine project is a well-maintained, fully featured PHP ORM
    library. It’s widely used; for example, the Symfony framework uses Doctrine for
    all database communications. My small ORM library is fine for small projects and
    for learning the basics, but for larger projects with many interrelated model
    classes, Doctrine is a more robust, sophisticated solution. Some of its features
    include easily facilitating object-to-object references that become foreign keys
    in the database schema and providing low-level control of the database table and
    column names beyond the default naming conventions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 开源的Doctrine项目是一个维护良好、功能齐全的PHP ORM库。它被广泛使用；例如，Symfony框架使用Doctrine进行所有数据库通信。我的小型ORM库适用于小型项目和学习基础知识，但对于具有多个相互关联模型类的大型项目，Doctrine是一个更强大、更复杂的解决方案。它的一些特性包括轻松实现对象与对象之间的引用，这些引用会成为数据库模式中的外键，并且提供低级别的控制，可以更改数据库表和列名，而不仅仅是使用默认的命名约定。
- en: After [Listing 30-5](#lis30-5) (before adding the User model class), you were
    asked to make a copy of your project. (Don’t worry if you didn’t make a copy of
    your project at that point; you can copy my listing30-05 from the book codes at
    *[https://github.com/dr-matt-smith/php-crash-course](https://github.com/dr-matt-smith/php-crash-course)*.)
    The coming sections will show you how to adapt that copy of the project to use
    Doctrine rather than my pdo-crud-for-free-repositories ORM library.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表30-5](#lis30-5)之后（在添加User模型类之前），你被要求复制你的项目。（如果当时你没有复制项目，不用担心；你可以从书中的代码获取我的listing30-05，网址为*[https://github.com/dr-matt-smith/php-crash-course](https://github.com/dr-matt-smith/php-crash-course)*。）接下来的部分将展示如何将该项目副本调整为使用Doctrine，而不是我之前的pdo-crud-for-free-repositories
    ORM库。
- en: Removing the Previous ORM Library
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移除之前的ORM库
- en: 'First, let’s remove the previous ORM library features from the project. Enter
    the following at the command line to remove the pdo-crud-for-free -repositories
    library from the project’s */vendor* folder and *composer.json* project dependencies
    file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从项目中移除之前的ORM库功能。请在命令行输入以下内容，将`pdo-crud-for-free-repositories`库从项目的*/vendor*文件夹以及*composer.json*项目依赖文件中移除：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We also need to remove the references to the old library’s DatabaseTableRepository
    class from the ProductRepository class declaration. [Listing 30-19](#lis30-19)
    shows how to update the *src/UserRepository.php* file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从ProductRepository类声明中移除对旧库的DatabaseTableRepository类的引用。[列表30-19](#lis30-19)展示了如何更新*src/UserRepository.php*文件。
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 30-19: The ProductRepository class, without inheriting from the ORM
    library'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表30-19：ProductRepository类，未继承自ORM库
- en: For now, we’re left with an empty class declaration, but later we’ll return
    to the class and integrate it with Doctrine.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只剩下一个空的类声明，但稍后我们会回到这个类，并将其与Doctrine集成。
- en: Adding Doctrine
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加Doctrine
- en: 'Now we’ll use Composer to add the Doctrine ORM library to the project, along
    with two other required libraries. Enter the following at the command line:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用Composer将Doctrine ORM库添加到项目中，并一起添加另外两个必需的库。在命令行中输入以下内容：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Doctrine requires a cache to aid its performance, and symfony/cache is the recommended
    choice. Additionally, symfony/dotenv will make it easy to access values from the
    project’s *.env* file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine需要缓存来提高性能，推荐使用symfony/cache。此外，symfony/dotenv将使我们能够轻松访问项目的*.env*文件中的值。
- en: Next, we need to connect Doctrine with the database. Create a script in the
    project’s top-level directory named *bootstrap.php*, containing the code in [Listing
    30-20](#lis30-20). This script is based on Doctrine’s documentation pages at *[https://www.doctrine-project.org](https://www.doctrine-project.org)*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将Doctrine与数据库连接起来。在项目的顶层目录中创建一个名为*bootstrap.php*的脚本，包含[Listing 30-20](#lis30-20)中的代码。这个脚本是基于Doctrine文档页面中的内容编写的，链接地址是*[https://www.doctrine-project.org](https://www.doctrine-project.org)*。
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 30-20: The bootstrap.php script to set up Doctrine'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 30-20：用于设置Doctrine的bootstrap.php脚本
- en: We read in the Composer autoloader, create a Dotenv object to load the database
    credentials from the project’s *.env* file ❶, and package those credentials into
    a $connectionParams array. We then use this array and some Doctrine static methods
    to establish a database connection ❷ and create an EntityManager object ❸. The
    EntityManager class is key to the way Doctrine works; the class maintains the
    link between the model class objects in the PHP code and their corresponding database
    table rows defined with unique primary keys.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取了Composer自动加载器，创建了一个Dotenv对象来从项目的*.env*文件中加载数据库凭证 ❶，并将这些凭证打包成$connectionParams数组。然后我们使用这个数组和一些Doctrine的静态方法来建立数据库连接
    ❷，并创建一个EntityManager对象 ❸。EntityManager类是Doctrine工作机制的关键；该类维护PHP代码中的模型类对象与其对应的数据库表行之间的联系，这些表行是通过唯一的主键来定义的。
- en: Any other script that reads in *bootstrap.php* will now have access to a database
    connection through the $connection variable and to Doctrine’s entity manager through
    the $entityManager variable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他读取*bootstrap.php*的脚本，现在都可以通过$connection变量访问数据库连接，并通过$entityManager变量访问Doctrine的实体管理器。
- en: Verifying That Doctrine Is Working
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 验证Doctrine是否工作正常
- en: Before we go any further, let’s make sure Doctrine is successfully linked with
    the project’s database. [Listing 30-21](#lis30-21) shows a simple script that
    tests Doctrine by retrieving Product objects from the database as an associative
    array. Save this script as *public/doctrine1.php*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们确保Doctrine已经成功地与项目的数据库建立了连接。[Listing 30-21](#lis30-21)展示了一个简单的脚本，它通过从数据库中检索Product对象并以关联数组的形式返回，来测试Doctrine。将此脚本保存为*public/doctrine1.php*。
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 30-21: The doctrine1.php script to retrieve existing rows from the
    database'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 30-21：用于从数据库中检索现有行的doctrine1.php脚本
- en: 'After reading in the autoloader and the Doctrine bootstrap script, we create
    an SQL query to select all rows from the product database table, then execute
    the query by using the Doctrine database connection (in the $connection variable).
    The results are returned as a nested array; each inner array maps the column names
    to the values in a particular row of the product database table. We loop through
    this array and print each row. If you run this *public/doctrine1.php* script,
    you should see the following output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取自动加载器和Doctrine引导脚本后，我们创建一个SQL查询，选择产品数据库表中的所有行，然后通过Doctrine的数据库连接（存储在$connection变量中）执行查询。结果将以嵌套数组的形式返回；每个内部数组将列名映射到特定行中的值。我们遍历这个数组并打印每一行。如果你运行这个*public/doctrine1.php*脚本，你应该会看到如下输出：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We’ve successfully retrieved the two products from the database, indicating
    that Doctrine is up and running.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地从数据库中检索到了两个产品，表明Doctrine已经成功运行。
- en: Creating Database Tables
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建数据库表
- en: One of Doctrine’s strengths is its ability to update the structure of a database
    based on the classes it encounters in the application’s PHP code, creating new
    tables and columns as needed. To see how this works, let’s switch our project
    over to a new, empty database. Then we can use Doctrine to create the product
    table from scratch.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine的一个优势是它能够根据应用程序的PHP代码中遇到的类来更新数据库的结构，必要时创建新的表和列。为了了解这一点，让我们将项目切换到一个新的空数据库。然后，我们可以使用Doctrine从头开始创建产品表。
- en: To begin, open the project’s *.env* file and change the value associated with
    the MYSQL_DATABASE key to demo2. Next, we need to write a script to create this
    new demo2 database schema. Create *db/create_database.php* and enter the contents
    of [Listing 30-22](#lis30-22).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开项目的*.env*文件，并将MYSQL_DATABASE键对应的值修改为demo2。接下来，我们需要编写一个脚本来创建这个新的demo2数据库架构。创建*db/create_database.php*并输入[Listing
    30-22](#lis30-22)的内容。
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 30-22: The db/create_database.php script to create the database named
    in the .env file'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 30-22：创建名为 .env 文件中指定的数据库的 db/create_database.php 脚本
- en: We use a Dotenv object ❶ to read the database credentials from the *.env* file
    and create an array of connection parameters. Then, inside a try...catch block,
    we create a connection to the MySQL database server by using Doctrine’s DriverManager::getConnection()
    method ❷. We then get an array of all the database names and search that array
    for the database name from our *.env* file, storing the result (true or false)
    in the $databaseExists variable ❸.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个 Dotenv 对象 ❶ 从 *.env* 文件中读取数据库凭证，并创建一个连接参数数组。然后，在 try...catch 块中，我们通过使用
    Doctrine 的 DriverManager::getConnection() 方法 ❷ 与 MySQL 数据库服务器建立连接。接着，我们获取所有数据库名称的数组，并在该数组中搜索来自
    *.env* 文件的数据库名称，将结果（真或假）存储在 $databaseExists 变量 ❸ 中。
- en: If the database exists, we drop it by using the dropDatabase() method. Then
    we create the database anew by using the createDatabase() method ❹ and print a
    success message. If any Exception is caught ❺, we print an error message instead.
    Run this script and you should now have a new, empty database schema called demo2.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库存在，我们使用 dropDatabase() 方法将其删除。然后，我们通过使用 createDatabase() 方法 ❹ 重新创建数据库，并打印成功消息。如果捕获到任何异常
    ❺，则打印错误消息。运行此脚本后，您应该会得到一个新的、空的数据库架构，名为 demo2。
- en: The basic usage of Doctrine is to run a command line script that reads metadata
    about model classes in the PHP code (called *entity classes* in Doctrine’s parlance)
    and executes SQL statements to create corresponding structures in the database
    schema. The command line script is usually placed in a file called */bin/doctrine*
    (without the.*php* file extension). Create this file as shown in [Listing 30-23](#lis30-23).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine 的基本用法是运行一个命令行脚本，读取 PHP 代码中模型类的元数据（在 Doctrine 的术语中称为 *实体类*），并执行 SQL
    语句，在数据库架构中创建相应的结构。命令行脚本通常保存在名为 */bin/doctrine* 的文件中（不带 .php 文件扩展名）。按照 [清单 30-23](#lis30-23)
    中所示创建此文件。
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 30-23: The /bin/doctrine command line script'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 30-23：/bin/doctrine 命令行脚本
- en: 'This script invokes the run() method of Doctrine’s ConsoleRunner class. The
    method takes in the arguments from the command line and uses them to run whatever
    Doctrine command has been entered after bin/doctrine in the terminal. Let’s run
    this script to try updating the new database schema. Enter php bin/doctrine orm:schema-tool:create
    at the command line. You should see the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本调用了 Doctrine 的 ConsoleRunner 类的 run() 方法。该方法接受命令行中的参数，并使用它们运行在终端中 bin/doctrine
    后输入的任何 Doctrine 命令。让我们运行此脚本，尝试更新新的数据库架构。在命令行中输入 php bin/doctrine orm:schema-tool:create。您应该会看到以下输出：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The script hasn’t done anything because we haven’t yet added any of the necessary
    metadata for Doctrine to know which model classes and properties should be mapped
    to which database tables and columns. We’ll now add metadata to the Product model
    class so that Doctrine will have a table to create in the database. As you’ll
    see, each metadata tag is preceded by a hash mark (#) and enclosed in square brackets.
    Modify the *src/Product.php* file as shown in [Listing 30-24](#lis30-24).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本还没有做任何事情，因为我们还没有添加 Doctrine 所需的元数据，以便知道哪些模型类和属性应映射到哪些数据库表和列。接下来，我们将向 Product
    模型类添加元数据，以便 Doctrine 在数据库中创建一个表。正如您所见，每个元数据标签前面都有一个井号（#），并用方括号括起来。按照 [清单 30-24](#lis30-24)
    中所示修改 *src/Product.php* 文件。
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 30-24: Adding Doctrine metadata to the Product class'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 30-24：向 Product 类添加 Doctrine 元数据
- en: To keep the metadata easier to read, we start with a use statement aliasing
    the Doctrine\ORM\Mapping class as ORM. Then we add metadata to the class itself
    and to each of its properties. We declare the class as an Entity ❶, indicating
    that it should correspond to a database table, and specify that this table should
    be named product. Without the latter, Doctrine would default to Product (starting
    with a capital letter) as the table name, to match the class name.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让元数据更易于阅读，我们首先使用 `use` 语句将 Doctrine\ORM\Mapping 类别名为 ORM。接着，我们向类本身及其每个属性添加元数据。我们将类声明为实体
    ❶，表示它应当对应一个数据库表，并指定该表应命名为 product。否则，Doctrine 默认将使用 Product（以大写字母开头）作为表名，与类名匹配。
- en: For the class’s id property, the Id tag indicates that this property should
    be used as the primary key ❷, Column indicates the property should correspond
    to a column in the database table, and GeneratedValue means the property should
    be auto-incremented in the database system. For the remaining properties, all
    we need is the Column tag. Notice that we can either specify the database column’s
    data type as part of the Column tag or let Doctrine guess the appropriate data
    type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类的id属性，Id标签表示此属性应作为主键使用❷，Column表示该属性应与数据库表中的一列对应，GeneratedValue意味着该属性应在数据库系统中自增。对于其余的属性，我们只需要Column标签。请注意，我们可以通过Column标签指定数据库列的数据类型，也可以让Doctrine猜测合适的数据类型。
- en: 'With this metadata added, we can run our Doctrine command line script again.
    First, let’s add the --dump-sql option, which will show the SQL that Doctrine
    *would* execute, without actually executing it yet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了这些元数据后，我们可以再次运行Doctrine命令行脚本。首先，添加--dump-sql选项，这将显示Doctrine*将*执行的SQL语句，但不会实际执行：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This shows that Doctrine will issue SQL code to create a product table with
    an auto-incrementing integer primary key id, a text description, and a floating-point
    price. Exactly what we want! Now run the command line script again without the
    --dump-sql option to execute that SQL:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了Doctrine将发出SQL代码来创建一个包含自增整数主键id、文本描述和浮动价格的产品表。正是我们想要的！现在再次运行命令行脚本，但不带--dump-sql选项来执行该SQL：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Doctrine has now created the product table in the demo2 database schema.  ####
    Adding Records to a Table'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine现在已经在demo2数据库模式中创建了产品表。#### 向表中添加记录
- en: Now that we’ve used Doctrine to map our Product class to the product database
    table, we can create new Product objects and store their data in the database.
    [Listing 30-25](#lis30-25) shows the *public/doctrine2.php* script to do this.
    Add this file to the project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用Doctrine将Product类映射到产品数据库表中，我们可以创建新的Product对象并将其数据存储到数据库中。[清单30-25](#lis30-25)显示了用于此操作的*public/doctrine2.php*脚本。将该文件添加到项目中。
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 30-25: The public/doctrine2.php script to insert and retrieve a database
    row'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-25：用于插入和检索数据库行的public/doctrine2.php脚本
- en: We create a Product object ❶ and set its description and price. Then we use
    the Doctrine EntityManager object to add this product’s data to a queue (the persist()
    method) and insert the object into the database (the flush() method).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个Product对象❶并设置它的描述和价格。然后我们使用Doctrine的EntityManager对象将该产品的数据添加到队列中（persist()方法），并将对象插入到数据库中（flush()方法）。
- en: 'To confirm this has worked, we use EntityManager to create and get a reference
    to a Doctrine repository object for the Product class ❷. This is a custom repository
    object linking the Product class with the records in the product database table.
    We use this repository object to retrieve all the records (in this case, just
    the one) from the table with the object’s findAll() method. Then we loop through
    the resulting $products array and print each object. Here’s the output of running
    this script:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认此操作已成功，我们使用EntityManager创建并获取一个Doctrine存储库对象的引用，针对Product类❷。这是一个自定义的存储库对象，它将Product类与产品数据库表中的记录关联。我们使用这个存储库对象通过对象的findAll()方法从表中检索所有记录（在此情况下，仅有一条记录）。然后我们遍历结果中的$products数组并打印每个对象。下面是运行此脚本的输出：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This output confirms that Doctrine has successfully added the "small hammer"
    object to the product database table.  #### Integrating Doctrine into the Application
    Code'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出确认Doctrine已成功将"小锤子"对象添加到产品数据库表中。#### 将Doctrine集成到应用程序代码中
- en: All the code is in place now to integrate the Doctrine ORM library into our
    main web application so that we can easily map objects and database table rows.
    First, to minimize changes required throughout the application code, we’ll add
    a helper class called OrmHelper that manages access to the Doctrine EntityManager
    instance. [Listing 30-26](#lis30-26) shows how to declare this class in *src/OrmHelper.php*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有代码都已到位，将Doctrine ORM库集成到我们的主Web应用程序中，这样我们就可以轻松地映射对象和数据库表行。首先，为了最小化对应用程序代码的更改，我们将添加一个名为OrmHelper的辅助类，它管理对Doctrine
    EntityManager实例的访问。[清单30-26](#lis30-26)显示了如何在*src/OrmHelper.php*中声明这个类。
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 30-26: The OrmHelper class storing and providing access to the $entityManager
    property'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 清单30-26：OrmHelper类存储并提供对$entityManager属性的访问
- en: This class declares a private static entityManager property, with public static
    getters and setters. We use static members to allow retrieval of a reference to
    the Doctrine EntityManager object from anywhere in our application code (after
    the variable has been set), without having to create an object or pass an object
    reference down through several constructor methods when creating the application,
    controller, or repository classes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该类声明了一个私有的静态 entityManager 属性，并提供了公共静态的 getter 和 setter 方法。我们使用静态成员，以便在我们的应用程序代码中的任何地方（在变量被设置之后）检索到对
    Doctrine EntityManager 对象的引用，而无需创建对象或在创建应用程序、控制器或存储库类时通过多个构造方法传递对象引用。
- en: Notice that the setter method takes in a reference to an EntityManager object
    and passes it along to the class’s entityManager property. We’ve already created
    that reference in the *bootstrap.php* script, so we just need to read in the bootstrap
    script before invoking the setter method. We’ll do that now by updating the *public/index.php*
    script as shown in [Listing 30-27](#lis30-27).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，setter 方法接受一个 EntityManager 对象的引用，并将其传递给类的 entityManager 属性。我们已经在 *bootstrap.php*
    脚本中创建了该引用，因此我们只需要在调用 setter 方法之前读取引导脚本。我们现在通过更新 *public/index.php* 脚本来实现这一点，如
    [列表 30-27](#lis30-27) 所示。
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 30-27: Updating the index.php script to bootstrap Doctrine and store
    the EntityManager object reference'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 30-27：更新 index.php 脚本以引导 Doctrine 并存储 EntityManager 对象的引用
- en: We add a require_once statement to read and run our Doctrine bootstrap script
    ❶. We add a use statement so that we can refer to the OrmHelper class in our code
    ❷. Then we store a reference to the script’s EntityManager object by calling the
    setEntityManager() static method of our OrmHelper class. This means the EntityManager
    object is now available anywhere in our web application logic via the public static
    method OrmHelper::getEntityManager().
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个 require_once 语句来读取并运行我们的 Doctrine 引导脚本 ❶。我们添加一个 use 语句，以便在代码中引用 OrmHelper
    类 ❷。然后，我们通过调用 OrmHelper 类的 setEntityManager() 静态方法，存储对脚本中 EntityManager 对象的引用。这意味着通过公共静态方法
    OrmHelper::getEntityManager()，EntityManager 对象现在可以在我们的 Web 应用程序逻辑中的任何地方使用。
- en: Finally, we need to fill out our ProductRepository class, which we left as an
    empty class declaration when we switched over to Doctrine. Our ProductController
    class expects ProductRepository to have CRUD methods like find(), findAll(), insert(),
    delete(), and so on. [Listing 30-28](#lis30-28) shows how to update *src/ProductRepository.php*
    accordingly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要填写我们的 ProductRepository 类，在切换到 Doctrine 时我们将其作为空类声明。我们的 ProductController
    类期望 ProductRepository 具有像 find()、findAll()、insert()、delete() 等 CRUD 方法。[列表 30-28](#lis30-28)
    展示了如何相应地更新 *src/ProductRepository.php*。
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 30-28: Updating ProductRepository with Doctrine-based CRUD methods'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 30-28：使用基于 Doctrine 的 CRUD 方法更新 ProductRepository
- en: We declare ProductRepository as a subclass of Doctrine\ORM\EntityRepository.
    This means it will inherit methods such as find() and findAll() from its parent.
    The class declares one instance variable, an EntityManager object, which is assigned
    its value in the constructor via our OrmHelper class ❶. The remaining lines in
    the constructor retrieve the required metadata about the Product class and pass
    it along to the parent class’s constructor to tailor the repository class to the
    product table ❷.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 ProductRepository 声明为 Doctrine\ORM\EntityRepository 的子类。这意味着它将继承如 find()
    和 findAll() 这样的父类方法。该类声明了一个实例变量，一个 EntityManager 对象，在构造函数中通过我们的 OrmHelper 类 ❶
    为其赋值。构造函数中的剩余代码检索关于 Product 类的必要元数据，并将其传递给父类的构造函数，以便将存储库类定制为产品表 ❷。
- en: We continue the class by declaring the remaining CRUD methods our application
    expects. For insert() and update(), we use the persist() and flush() methods of
    the EntityManager object methods to add or modify a database record. The delete()
    method uses the remove() and flush() methods of the EntityManager object to remove
    a record. Finally, the deleteAll() method retrieves all objects with the inherited
    findAll() method, then loops through them to remove each one from the database.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续为该类声明应用程序期望的剩余 CRUD 方法。对于 insert() 和 update()，我们使用 EntityManager 对象的 persist()
    和 flush() 方法来添加或修改数据库记录。delete() 方法使用 EntityManager 对象的 remove() 和 flush() 方法来删除记录。最后，deleteAll()
    方法使用继承的 findAll() 方法检索所有对象，然后循环遍历它们以从数据库中删除每个对象。
- en: Creating Foreign-Key Relationships
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建外键关系
- en: It may seem like we’ve done a lot of work to incorporate Doctrine while gaining
    little or no functionality beyond the previous ORM library. However, we can begin
    to see some of the real power of the Doctrine ORM library when we start creating
    foreign-key relationships between database tables and their corresponding model
    classes. In our code, we establish this relationship by adding a property to a
    model class whose value is a reference to an object of another model class. With
    the right metadata, Doctrine can see this relationship and generate all the SQL
    needed to realize it in the database.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是我们为集成Doctrine做了很多工作，但在功能上几乎没有超出之前的ORM库。然而，当我们开始在数据库表之间以及它们对应的模型类之间创建外键关系时，我们就能开始看到Doctrine
    ORM库的真正强大功能。在我们的代码中，我们通过向模型类添加一个属性来建立这种关系，该属性的值是对另一个模型类对象的引用。凭借正确的元数据，Doctrine可以看到这种关系，并生成所有实现它所需的SQL。
- en: To illustrate, let’s add a Category model class to our project along with the
    equivalent category database table. Then we’ll modify the Product model class
    so that each product is associated with a category. In the process, we’ll see
    how Doctrine manages the foreign-key relationship behind this association. [Listing
    30-29](#lis30-29) shows the *src/Category.php* script declaring the new Category
    class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明问题，首先我们将向项目中添加一个Category模型类，以及对应的category数据库表。然后我们将修改Product模型类，使每个产品都与一个类别相关联。在这个过程中，我们将看到Doctrine如何管理这种关联背后的外键关系。[列表
    30-29](#lis30-29)展示了声明新Category类的*src/Category.php*脚本。
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 30-29: The Category model class, including Doctrine ORM metadata'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 30-29：Category模型类，包括Doctrine ORM元数据
- en: 'The initial metadata before the class name indicates that this simple model
    class (or Doctrine entity) should correspond to a database table called category
    ❶. The class has two properties: a unique integer id and a string name. As with
    the Product class, we include a tag specifying that id is to be autogenerated
    by the database ❷. For each property, we declare basic getter and setter methods.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 类名之前的初始元数据表明，这个简单的模型类（或Doctrine实体）应对应一个名为category的数据库表❶。该类有两个属性：一个唯一的整数id和一个字符串name。与Product类一样，我们包含一个标签，指定id将由数据库自动生成❷。对于每个属性，我们声明了基本的getter和setter方法。
- en: Now let’s add a category property to the Product class so that each Product
    object will be associated with one Category object. [Listing 30-30](#lis30-30)
    shows how to modify *src/Product.php*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向Product类添加一个类别属性，以便每个Product对象都将与一个Category对象相关联。[列表 30-30](#lis30-30)展示了如何修改*src/Product.php*。
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 30-30: Adding a category property to the Product class'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 30-30：向Product类添加类别属性
- en: We declare the category property as either NULL or a reference to a Category
    object, and give it public getter and setter methods. The metadata attribute preceding
    the property ❶ tells Doctrine that this field in the database should hold a foreign-key
    reference to a row in the category table. Here ManyToOne indicates that the foreign
    key establishes a *many-to-one* relationship, where many products can be of the
    same category, and targetEntity sets the model class (and database table) on the
    other end of the relationship.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将类别属性声明为NULL或Category对象的引用，并为其提供公共的getter和setter方法。属性前面的元数据属性❶告诉Doctrine，这个数据库字段应保存指向category表中某行的外键引用。在这里，ManyToOne表示外键建立了一个*多对一*关系，即多个产品可以属于同一个类别，targetEntity设置了关系另一端的模型类（和数据库表）。
- en: 'Since we’ve changed the structure of the Product model class, as well as adding
    the new Category class, we need Doctrine to update the structure of the database
    accordingly. First, let’s use our *bin/doctrine* command-line script to drop the
    old product table from the database schema:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经更改了Product模型类的结构，并且添加了新的Category类，我们需要Doctrine相应地更新数据库的结构。首先，让我们使用*bin/doctrine*命令行脚本从数据库模式中删除旧的产品表：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This drops *all* tables from the schema (in our case, that’s just the product
    table). Now we’ll use the command-line script again to create the database schema
    anew, complete with the product and category tables and the foreign-key relationship
    between them. As before, we’ll first use the --dump-sql option to view the SQL
    statements Doctrine wants to run:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除模式中的*所有*表（在我们的例子中，只有产品表）。现在，我们将再次使用命令行脚本重新创建数据库模式，包含产品表和类别表，以及它们之间的外键关系。和之前一样，我们将首先使用--dump-sql选项查看Doctrine希望执行的SQL语句：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This shows that Doctrine will issue SQL code to create the category and product
    tables, where product has a category_id field with a foreign-key reference to
    a category database row. Real-world databases abound with foreign-key references
    like this, and here we see how Doctrine excels at managing the SQL for these relationships
    so we don’t have to.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 Doctrine 将生成 SQL 代码来创建类别和产品表，其中产品表有一个 `category_id` 字段，并且该字段通过外键关联到类别数据库行。现实世界的数据库中充满了这样的外键引用，在这里我们看到
    Doctrine 在管理这些关系的 SQL 方面表现出色，这样我们就不需要自己处理这些了。
- en: Run the command-line script once more without the --dump-sql option to execute
    the SQL statements and create these related database tables. To make sure the
    related tables have been successfully created in the database, we’ll write a one-off
    script creating related Product and Category objects, saving them to the database,
    and retrieving them. [Listing 30-31](#lis30-31) shows *public/doctrine3.php* implementing
    these actions. Add this file to your project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行命令行脚本，不带 --dump-sql 选项，以执行 SQL 语句并创建这些相关的数据库表。为了确保相关表已经成功创建在数据库中，我们将编写一个临时脚本，创建相关的
    Product 和 Category 对象，将它们保存到数据库中并进行检索。[Listing 30-31](#lis30-31) 展示了 *public/doctrine3.php*
    实现这些操作。将此文件添加到您的项目中。
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 30-31: The public/doctrine3.php script to insert related records into
    the database'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 30-31：public/doctrine3.php 脚本，用于将相关记录插入数据库
- en: 'We create two Category objects for HARDWARE and APPLIANCES, then store them
    in the database by using the Doctrine EntityManager object from the bootstrap
    script. Notice that we call the persist() method on each Category object individually,
    then call the flush() method once ❶; flush() will batch-process any operations
    that have been queued up for it with methods like persist(). We next use our ProductRepository
    class to create and insert two Product objects into the database, one for each
    category. Then we retrieve an array of all the products from the database with
    the ProductRepository class’s findAll() method ❷. If the array isn’t empty, we
    loop through it and print each product. Here’s the output of running this script:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个 Category 对象，分别代表 HARDWARE 和 APPLIANCES，然后通过引导脚本中的 Doctrine EntityManager
    对象将它们存储到数据库中。请注意，我们对每个 Category 对象单独调用了 persist() 方法，然后在 ❶ 调用了 flush() 方法；flush()
    将批量处理所有已经排队的操作，例如通过 persist() 方法添加的操作。接下来，我们使用 ProductRepository 类创建并插入两个 Product
    对象到数据库中，每个类别一个。然后，我们使用 ProductRepository 类的 findAll() 方法 ❷ 从数据库中检索所有产品的数组。如果该数组不为空，我们遍历数组并打印每个产品。以下是运行此脚本时的输出：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Each product is shown with its associated category. With just a little bit of
    metadata in the Product model classes (the Doctrine ManyToOne attribute added
    before the category property), we’ve created a whole database of foreign-key declaration
    and storage mapping.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 每个产品都与其关联的类别一起展示。通过在 Product 模型类中加入一点元数据（在类别属性之前添加的 Doctrine ManyToOne 属性），我们已经创建了一个完整的外键声明和存储映射数据库。
- en: Overall, although switching from my simple ORM library to Doctrine added complexity
    to the code, such as the need for a bootstrap script and metadata tags in the
    model classes, Doctrine comes with added benefits like increased flexibility and
    support for foreign-key relationships. Using a popular ORM library like Doctrine
    for a project also means that developers you collaborate with will be more likely
    to already be familiar with its operations, which can save time in code development
    and maintenance. Another advantage of ORM libraries like Doctrine is that they
    allow you to seamlessly switch from one DBMS to another (such as from MySQL to
    PostgreSQL), without any of your core web application code having to change. The
    only downside may be the effort of learning the library in the first place, and
    perhaps some performance reduction due to the extra layer of abstraction. Still,
    the advantages will in many cases outweigh any minor performance reduction.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，虽然从我简单的 ORM 库切换到 Doctrine 增加了代码的复杂性，比如需要引导脚本和在模型类中添加元数据标签，但 Doctrine 带来了额外的好处，如更高的灵活性和对外键关系的支持。使用像
    Doctrine 这样流行的 ORM 库进行项目开发，还意味着你与之协作的开发人员更有可能已经熟悉其操作，这可以节省代码开发和维护的时间。像 Doctrine
    这样的 ORM 库的另一个优点是，它们允许你无缝地从一个数据库管理系统（DBMS）切换到另一个（比如从 MySQL 切换到 PostgreSQL），而无需更改核心的
    web 应用程序代码。唯一的缺点可能是初学时学习该库所需要的努力，或者由于额外的抽象层带来的性能下降。但在许多情况下，这些优点将超过任何轻微的性能下降。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used my pdo-crud-for-free-repositories library to explore
    the basics of ORM libraries, seeing how they can simplify the process of working
    with a database by eliminating the need for writing a lot of repetitive code for
    CRUD applications. When we transitioned to the Doctrine ORM library, we saw that
    this more robust and feature-complete library has added benefits like greater
    flexibility and support for foreign-key associations between model classes and
    their corresponding database tables.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了我的 pdo-crud-for-free-repositories 库来探索 ORM 库的基础，看到它们如何通过消除为 CRUD 应用编写大量重复代码的需求来简化与数据库交互的过程。当我们转向
    Doctrine ORM 库时，我们看到这个更强大且功能完整的库增加了诸如更大的灵活性和支持模型类及其相应数据库表之间外键关联等优势。
- en: This chapter also outlined important practices in web application security.
    In previous chapters, we were already using prepared SQL statements, which help
    protect against SQL injection attacks. Now we’ve added the ability to store and
    verify against hashed passwords, so we never need to store plaintext passwords
    in a database. We’ve also emphasized the importance of keeping database credentials
    in a separate file so that they won’t be published or archived and accidentally
    exposed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还概述了Web应用安全中的重要实践。在之前的章节中，我们已经使用了预处理SQL语句，这有助于防止SQL注入攻击。现在，我们添加了存储和验证哈希密码的功能，这样我们就不需要在数据库中存储明文密码了。我们还强调了将数据库凭据保存在单独的文件中的重要性，这样它们就不会被发布或归档并意外泄露。
- en: Exercises
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '1.   I’ve created a publicly shared sample project to help explore the pdo-crud
    -for-free-repositories library. The project uses PHP templates (not Twig) to illustrate
    how to use the ORM library for a Movie model class and its associated MovieRepository
    class. To check out the project, do the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 我创建了一个公开共享的示例项目，帮助探索 pdo-crud-for-free-repositories 库。该项目使用 PHP 模板（不是 Twig）展示了如何使用
    ORM 库来处理 Movie 模型类及其关联的 MovieRepository 类。要查看该项目，请执行以下操作：
- en: 'a.   Enter the following at the command line to create a new project named
    *demo1* based on my published project template:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: a. 在命令行中输入以下内容，以基于我发布的项目模板创建一个名为 *demo1* 的新项目：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: b.   In the *demo1* directory that was created, edit the MySQL credentials in
    the *.env* file to match your computer’s setup.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: b. 在创建的 *demo1* 目录中，编辑 *.env* 文件中的 MySQL 凭据，使其与你计算机的设置相匹配。
- en: c.   Run the database setup script in *db/migrateAndLoadFixtures.php.*
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: c. 运行 *db/migrateAndLoadFixtures.php* 中的数据库设置脚本。
- en: d.   Run a web server and visit the home page and movie list page.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: d. 启动一个Web服务器，访问主页和电影列表页面。
- en: e.   Examine the Movie model class, and the listMovies() method in the Application
    class.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: e. 检查 Movie 模型类和 Application 类中的 listMovies() 方法。
- en: '2.   Use the pdo-crud-for-free-repositories library to create a MySQL CRUD
    web application for Book objects with these properties:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 使用 pdo-crud-for-free-repositories 库为 Book 对象创建一个 MySQL CRUD Web 应用程序，Book
    对象包含以下属性：
- en: id (integer), an auto-incrementing primary key
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: id (整数)，自动递增的主键
- en: title (string)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: title (字符串)
- en: author (string)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: author (字符串)
- en: price (float)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: price (浮动)
- en: You can either create a new project from scratch, extend the demo project from
    the previous exercise, or adapt your work from Exercise 2 of the previous chapter.
    You may find it helpful to adapt the database schema creation and initial data
    script from [Listing 30-12](#lis30-12), or if you’re using the demo project, you
    can adapt the database setup script in *db/migrateAndLoadFixtures.php*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从零开始创建一个新项目，扩展上一练习中的演示项目，或者修改你在上一章第2个练习中的工作。你可能会觉得修改 [Listing 30-12](#lis30-12)
    中的数据库模式创建和初始数据脚本有帮助，或者如果你使用的是演示项目，你可以修改 *db/migrateAndLoadFixtures.php* 中的数据库设置脚本。
- en: '3.   Web application security is an enormous topic (the subject of entire books),
    and covering it exhaustively here would be impossible. Learn more about PHP security
    best practices by exploring the following resources:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 3. Web应用安全是一个庞大的话题（是整本书的内容），在这里详尽地讨论是不可能的。通过探索以下资源，了解更多关于 PHP 安全最佳实践的信息：
- en: The Paragon Initiative Enterprises PHP security guide, *[https://paragonie.com/blog/2017/12/2018-guide-building-secure-php-software](https://paragonie.com/blog/2017/12/2018-guide-building-secure-php-software)*
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Paragon Initiative Enterprises PHP 安全指南，* [https://paragonie.com/blog/2017/12/2018-guide-building-secure-php-software](https://paragonie.com/blog/2017/12/2018-guide-building-secure-php-software)
    *
- en: The Open Web Application Security Project, *[https://owasp.org](https://owasp.org)*
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 开放式Web应用安全项目，* [https://owasp.org](https://owasp.org) *
- en: PHP The Right Way’s security chapters, by Josh Lockhart (codeguy), *[https://phptherightway.com/#security](https://phptherightway.com/#security)*
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: PHP The Right Way的安全章节，由Josh Lockhart (codeguy)编写，* [https://phptherightway.com/#security](https://phptherightway.com/#security)
    *
