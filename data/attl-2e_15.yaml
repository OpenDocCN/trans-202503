- en: '15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '15'
- en: 'FLAIM PART II: PUSHING THE ENVELOPE'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM 第二部分：突破极限
- en: '*What we do in college is to get over our little-mindedness. Education—to get
    it you have to hang around till you catch on.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们在大学里所做的，就是克服我们的小气思想。教育——要得到它，你必须呆在那儿，直到你能理解。*'
- en: —Robert Lee Frost*^([1](footnote.xhtml#ch15fn1))
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —罗伯特·李·弗罗斯特*^([1](footnote.xhtml#ch15fn1))
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: It’s a well-understood principle that no matter how many books you read, or
    how many lectures you attend, or how many queries you present on mailing lists,
    you’ll still be left with unanswered questions. It’s estimated that half of the
    world’s population has access to the internet today.^([2](footnote.xhtml#ch15fn2))
    There are thousands of terabytes of information available from your desktop. Nevertheless,
    it seems every project has one or two issues that are just different enough from
    all others that even internet searches are fraught with futility.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个被广泛理解的原则是，无论你读了多少书，参加了多少讲座，或者在邮件列表上提了多少问题，你仍然会有一些没有答案的问题。据估计，今天全球约有一半人口可以上网。^([2](footnote.xhtml#ch15fn2))
    从你的桌面上可以获取成千上万的千兆字节信息。然而，似乎每个项目都有一两个问题，足够与其他问题有所不同，即使是互联网搜索也常常无济于事。
- en: To reduce the potential frustration of learning the Autotools, this chapter
    continues with the FLAIM build system conversion project by tackling some of the
    less common features of FLAIM’s build system requirements. My hope is that by
    presenting solutions to some of these less common problems, you’ll become familiar
    with the underlying framework provided by the Autotools. Such familiarity provides
    the insight needed to bend the Autotools to your own unique requirements.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少学习 Autotools 可能带来的挫败感，本章继续进行 FLAIM 构建系统转换项目，通过解决 FLAIM 构建系统要求中一些不常见的功能来继续进行。我希望通过展示一些不常见问题的解决方案，您将能熟悉
    Autotools 提供的底层框架。这样的熟悉将为您提供洞察力，使您能够将 Autotools 灵活地应用于您的独特需求。
- en: The *xflaim* library provides Java and C# language bindings. Automake provides
    rudimentary support for building Java sources but currently provides no built-in
    support for building C# sources. In this chapter, I’ll show you how to use Automake’s
    built-in Java support to build the Java language bindings in xflaim, and then
    I’ll show you how to write your own `make` rules for the C# language bindings.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*xflaim* 库提供 Java 和 C# 语言绑定。Automake 提供了构建 Java 源代码的基础支持，但目前没有内置支持构建 C# 源代码。在本章中，我将向您展示如何使用
    Automake 内置的 Java 支持来构建 xflaim 中的 Java 语言绑定，然后我将向您展示如何为 C# 语言绑定编写您自己的 `make` 规则。'
- en: We’ll round out this chapter, and finish up the FLAIM conversion pro­ject, with
    discussions of using native compiler options, building generated documentation,
    and adding your own top-level recursive `make` targets.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过讨论使用本地编译器选项、构建生成的文档，以及添加您自己的顶层递归 `make` 目标，来完成本章内容，并结束 FLAIM 转换项目。
- en: Building Java Sources Using the Autotools
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Autotools 构建 Java 源代码
- en: The *GNU Automake Manual* presents information on building Java sources in two
    different ways. The first is the traditional and widely understood method of compiling
    Java source code into Java byte code, which can then be executed within the Java
    virtual machine (JVM). The second way is the lesser-known method of compiling
    Java source code directly into native machine code using the GNU Compiler for
    Java (`gcj`) frontend to the GNU compiler tool suite. The object files containing
    this machine code can then be linked together into native executable programs
    using the standard GNU linker. Probably due to lack of interest, and to the JVM’s
    having been vastly improved over the years, the GCJ project is no longer being
    maintained. It’s therefore likely that all support for this mechanism will soon
    be entirely dropped from the Autotools.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU Automake 手册* 介绍了两种构建 Java 源代码的方法。第一种是传统的、被广泛理解的方法，即将 Java 源代码编译成 Java
    字节码，然后在 Java 虚拟机（JVM）中执行。第二种方法是较少人知的，通过使用 GNU 编译器工具套件的 GNU Java 编译器前端（`gcj`）将
    Java 源代码直接编译成本地机器码。包含这些机器码的目标文件可以通过标准的 GNU 链接器链接成本地可执行程序。由于缺乏兴趣，并且由于 JVM 在多年来得到了极大的改进，GCJ
    项目已经不再维护。因此，很可能所有对这一机制的支持很快会完全从 Autotools 中删除。'
- en: In this chapter, I’ll focus on the former—building Java class files from Java
    source files using the Automake built-in `JAVA` primary. We’ll also explore the
    necessary extensions required to build and install *.jar* files.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将重点讲解前者——使用 Automake 内置的 `JAVA` 主体从 Java 源文件构建 Java 类文件。我们还将探讨构建和安装 *.jar*
    文件所需的扩展。
- en: '*Autotools Java Support*'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Autotools Java 支持*'
- en: Autoconf has little, if any, built-in support for Java. For example, it provides
    no macros that locate Java tools in the end user’s environment.^([3](footnote.xhtml#ch15fn3))
    Automake’s built-in support for building Java classes is minimal, but getting
    it to work is not really that difficult if you’re willing to dig in a bit. The
    biggest stumbling block is conceptual more than functional. You have to work a
    little to align your understanding of the Java build process with that of the
    Automake designers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 对 Java 的内置支持几乎没有，甚至可以说是没有。例如，它没有提供任何宏来定位终端用户环境中的 Java 工具。^([3](footnote.xhtml#ch15fn3))
    Automake 对构建 Java 类的内置支持非常有限，但如果你愿意花些时间去深入了解，使其工作并不难。最大的问题更多是概念性的，而非功能性的。你需要付出一些努力，将你对
    Java 构建过程的理解与 Automake 设计者的理解对齐。
- en: Automake provides a built-in primary (`JAVA`) for building Java sources, but
    it does not provide any preconfigured installation location prefixes for installing
    Java classes. However, the usual place to install Java classes and *.jar* files
    is in the `$(datadir)`*/java* directory, so creating a proper prefix is as simple
    as using the Automake prefix extension mechanism of defining a variable suffixed
    with *dir*, as shown in [Listing 15-1](ch15.xhtml#ch15ex1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Automake 提供了一个内置的主体（`JAVA`）来构建 Java 源文件，但它并没有提供任何预配置的安装位置前缀来安装 Java 类。然而，通常安装
    Java 类和 *.jar* 文件的位置是 `$(datadir)`*/java* 目录，因此，创建一个正确的前缀和使用 Automake 的前缀扩展机制，定义一个以
    *dir* 结尾的变量就可以了，具体可以参见 [Listing 15-1](ch15.xhtml#ch15ex1)。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 15-1: Defining a Java installation directory in a* Makefile.am *file*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-1：在* Makefile.am *文件中定义 Java 安装目录*'
- en: Now, you don’t often want to install Java sources, which is what you will accomplish
    when you define your `JAVA` primary in this manner. Rather, you want the *.class*
    files to be installed, or more likely a *.jar* file containing all of your *.class*
    files. It’s generally more useful, therefore, to define the `JAVA` primary with
    the `noinst` prefix. Additionally, files in a `JAVA` primary list are not distributed
    by default, so you may even want to use the `dist` super-prefix, as shown in [Listing
    15-2](ch15.xhtml#ch15ex2).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你通常不希望安装 Java 源文件，而是希望安装 *.class* 文件，或者更可能是包含所有 *.class* 文件的 *.jar* 文件。这通常更有用，因此，定义
    `JAVA` 主体时使用 `noinst` 前缀会更合适。此外，`JAVA` 主体列表中的文件默认不会分发，所以你甚至可能想使用 `dist` 超前缀，如
    [Listing 15-2](ch15.xhtml#ch15ex2) 所示。
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 15-2: Defining a list of non-installed Java files that are distributed*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-2：定义一个非安装的 Java 文件列表，这些文件会被分发*'
- en: When you define a list of Java source files in a variable containing the `JAVA`
    primary, Automake generates a `make` rule that builds that list of files all in
    one command, using the syntax shown in [Listing 15-3](ch15.xhtml#ch15ex3).^([4](footnote.xhtml#ch15fn4))
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在一个包含 `JAVA` 主体的变量中定义 Java 源文件列表时，Automake 会生成一个 `make` 规则，该规则在一个命令中构建该文件列表，使用
    [Listing 15-3](ch15.xhtml#ch15ex3) 中显示的语法。^([4](footnote.xhtml#ch15fn4))
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 15-3: This long shell command was taken from a* Makefile *generated
    by Automake.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-3：这个长 shell 命令来自 Automake 生成的* Makefile *文件。*'
- en: Most of the code you see in these commands exists solely to prepend the `$(srcdir)`
    prefix onto each file in the user-specified list of Java sources in order to properly
    support `VPATH` builds. This code uses a shell `for` statement to split the list
    into individual files, prepend the `$(srcdir)`, and then reassemble the list.^([5](footnote.xhtml#ch15fn5))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些命令中，你看到的大部分代码仅仅是为了将 `$(srcdir)` 前缀加到用户指定的 Java 源文件列表中的每个文件，以便正确支持 `VPATH`
    构建。该代码使用 shell 的 `for` 语句将列表拆分为单独的文件，添加 `$(srcdir)` 前缀，然后重新组装列表。^([5](footnote.xhtml#ch15fn5))
- en: The part that actually does the work of building the Java sources is found in
    two lines (four wrapped lines, actually)^([6](footnote.xhtml#ch15fn6)) near the
    bottom at ➊.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上完成构建 Java 源文件工作的部分出现在底部附近的两行（实际上是四行折叠的行）^([6](footnote.xhtml#ch15fn6)) ➊。
- en: Automake generates a stamp file at ➋ because the single `$(JAVAC)` command generates
    several *.class* files from the *.java* files. Rather than choosing one of these
    files at random, Automake generates and uses a stamp file as the target of the
    rule, which causes `make` to ignore the relationships between individual *.class*
    files and their corresponding *.java* files. That is, if you delete a *.class*
    file, the rules in the makefile will not cause it to be rebuilt. The only way
    to cause the re-execution of the `$(JAVAC)` command is to either modify one or
    more of the *.java* files, thereby causing their timestamps to become newer than
    that of the stamp file, or delete the stamp file entirely.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Automake在➋处生成一个印记文件，因为单个`$(JAVAC)`命令会从*.java*文件生成多个*.class*文件。Automake不会随机选择其中一个文件，而是生成并使用印记文件作为规则的目标，这会导致`make`忽略单个*.class*文件与其对应的*.java*文件之间的关系。也就是说，如果删除一个*.class*文件，makefile中的规则不会导致其被重新构建。唯一能导致重新执行`$(JAVAC)`命令的方法是修改一个或多个*.java*文件，从而使它们的时间戳变得比印记文件更新，或者完全删除印记文件。
- en: The variables used in the build environment and on the command line include
    `JAVAROOT`, `JAVAC`, `JAVACFLAGS`, `AM_JAVACFLAGS`, and `CLASSPATH_ENV`. Each
    variable may be specified in the *Makefile.am* file.^([7](footnote.xhtml#ch15fn7))
    If a variable is not specified, the defaults shown in [Listing 15-3](ch15.xhtml#ch15ex3)
    are used instead.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建环境和命令行中使用的变量包括`JAVAROOT`、`JAVAC`、`JAVACFLAGS`、`AM_JAVACFLAGS`和`CLASSPATH_ENV`。每个变量可以在*Makefile.am*文件中指定。^([7](footnote.xhtml#ch15fn7))
    如果未指定某个变量，则使用[列表15-3](ch15.xhtml#ch15ex3)中显示的默认值。
- en: All *.java* files specified in a `JAVA` primary variable are compiled using
    a single command line, which may pose a problem on systems with limited command
    line lengths. If you encounter such a problem, you can either break up your Java
    project into multiple Java source directories or develop your own `make` rules
    for building Java classes. (When I discuss building C# code in “Building the C#
    Sources” on [page 418](ch15.xhtml#page_418), I demonstrate how to write such custom
    rules.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`JAVA`主变量中指定的所有*.java*文件将通过单个命令行编译，这在命令行长度有限的系统上可能会导致问题。如果遇到此类问题，您可以将Java项目拆分为多个Java源目录，或者编写自己的`make`规则来构建Java类。（在我讨论如何在“构建C#源代码”一节中构建C#代码时，[第418页](ch15.xhtml#page_418)展示了如何编写这些自定义规则。）
- en: The `CLASSPATH_ENV` variable sets the Java `CLASSPATH` environment variable
    so that it contains `$(JAVAROOT)`, `$(srcdir)/$(JAVAROOT)`, and then any class
    path that may have been configured in the environment by the end user.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLASSPATH_ENV`变量设置Java `CLASSPATH`环境变量，使其包含`$(JAVAROOT)`、`$(srcdir)/$(JAVAROOT)`，以及任何可能由最终用户在环境中配置的类路径。'
- en: The `JAVAROOT` variable is used to specify the location of the project’s Java
    root directory within the project’s build tree, where the Java compiler will expect
    to find the start of generated package directory hierarchies belonging to your
    project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`JAVAROOT`变量用于指定项目构建树中项目的Java根目录的位置，Java编译器将会在该位置找到生成的包目录层级的起点。'
- en: The `JAVAC` variable contains `javac` by default, with the assumption that `javac`
    can be found in the system path. The `AM_JAVACFLAGS` variable may be set in *Makefile.am*,
    though the non-Automake version of this variable (`JAVACFLAGS`) is considered
    a user variable and thus shouldn’t be set in makefiles.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`JAVAC`变量默认包含`javac`，假设`javac`可以在系统路径中找到。`AM_JAVACFLAGS`变量可以在*Makefile.am*中设置，尽管该变量的非Automake版本（`JAVACFLAGS`）被视为用户变量，因此不应在makefile中设置。'
- en: This is all fine as far as it goes, but it doesn’t go nearly far enough. In
    this relatively simple Java project, we still need to generate Java native interface
    (JNI) header files using the `javah` utility as well as a *.jar* file from the
    *.class* files built from the Java sources. Unfortunately, Automake-provided Java
    support doesn’t even begin to handle these tasks, so we’ll have to do the rest
    with handcoded `make` rules. We’ll begin with Autoconf macros to ensure that we
    have a good Java build environment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这在一定程度上是可行的，但远远不够。在这个相对简单的Java项目中，我们仍然需要使用`javah`工具生成Java本地接口（JNI）头文件，并从Java源代码构建的*.class*文件生成*.jar*文件。不幸的是，Automake提供的Java支持甚至无法处理这些任务，因此我们必须通过手动编写`make`规则来完成剩余工作。我们将首先使用Autoconf宏来确保我们拥有一个良好的Java构建环境。
- en: '*Using ac-archive Macros*'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*使用ac-archive宏*'
- en: The GNU Autoconf Archive supplies community-contributed Autoconf macros that
    come close to what we need in order to ensure that we have a good Java development
    environment. In this particular case, I downloaded the latest source package and
    just hand-installed the *.m4* files that I needed into the *xflaim/m4* directory.^([8](footnote.xhtml#ch15fn8))
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: GNU Autoconf Archive提供了社区贡献的Autoconf宏，接近我们需要的功能，以确保我们拥有一个良好的Java开发环境。在这种情况下，我下载了最新的源代码包，并将我需要的*.m4*文件手动安装到*xflaim/m4*目录中。^([8](footnote.xhtml#ch15fn8))
- en: Then I modified the files (including their names) to work the way my `FLM_PROG_TRY_DOXYGEN`
    macro works. I wanted to locate any existing Java tools, but I also wanted be
    able to continue without them if necessary. Though it has gotten much better in
    the last 10 years, given the politics surrounding the existence of Java tools
    in Linux distributions, this is probably a wise approach.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我修改了这些文件（包括它们的名称），使其像我的`FLM_PROG_TRY_DOXYGEN`宏那样工作。我想定位任何现有的Java工具，但如果需要，我也希望能够继续没有这些工具的工作。虽然在过去的10年里情况有了很大的改善，但考虑到围绕Java工具在Linux发行版中的存在所涉及的政治问题，这种做法可能是明智的。
- en: 'I created the following macros within corresponding Java-related *.m4* files:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我在相应的Java相关的*.m4*文件中创建了以下宏：
- en: '`FLM_PROG_TRY_JAVAC` is defined in *flm_prog_try_javac.m4*.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLM_PROG_TRY_JAVAC`定义在*flm_prog_try_javac.m4*中。'
- en: '`FLM_PROG_TRY_JAVAH` is defined in *flm_prog_try_javah.m4*.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLM_PROG_TRY_JAVAH`定义在*flm_prog_try_javah.m4*中。'
- en: '`FLM_PROG_TRY_JAVADOC` is defined in *flm_prog_try_javadoc.m4*.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLM_PROG_TRY_JAVADOC`定义在*flm_prog_try_javadoc.m4*中。'
- en: '`FLM_PROG_TRY_JAR` is defined in *flm_prog_try_jar.m4*.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLM_PROG_TRY_JAR`定义在*flm_prog_try_jar.m4*中。'
- en: '`FLM_PROG_TRY_JNI` is defined in *flm_prog_try_jni.m4*.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLM_PROG_TRY_JNI`定义在*flm_prog_try_jni.m4*中。'
- en: 'With a bit more effort, I was also able to create the C# macros I needed to
    accomplish the same tasks for the C# language bindings:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过稍微多一点的努力，我也能够创建C#宏，以完成相同的任务，处理C#语言绑定：
- en: '`FLM_PROG_TRY_CSC` is defined in *flm_prog_try_csc.m4*.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLM_PROG_TRY_CSC`定义在*flm_prog_try_csc.m4*中。'
- en: '`FLM_PROG_TRY_CSVM` is defined in *flm_prog_try_csvm.m4*.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLM_PROG_TRY_CSVM`定义在*flm_prog_try_csvm.m4*中。'
- en: '[Listing 15-4](ch15.xhtml#ch15ex4) shows the portion of the xflaim *configure.ac*
    file that invokes these Java and C# macros.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 15-4](ch15.xhtml#ch15ex4)展示了xflaim *configure.ac*文件中的一部分，调用了这些Java和C#宏。'
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 15-4:* xflaim/configure.ac: *The portion of this file that searches
    for Java and C# tools*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-4:* xflaim/configure.ac: *该文件中的一部分，负责查找Java和C#工具*'
- en: These macros set the `CSC`, `CSVM`, `JAVAC`, `JAVAH`, `JAVADOC`, and `JAR` variables
    to the location of their respective C# and Java tools and then substitute them
    into the xflaim project’s *Makefile.in* templates using `AC_SUBST`. If any of
    these variables are already set in the user’s environment when the `configure`
    script is executed, their values are left untouched, thus allowing the user to
    override the values that would have been set by the macros.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏将`CSC`、`CSVM`、`JAVAC`、`JAVAH`、`JAVADOC`和`JAR`变量设置为它们各自的C#和Java工具的位置，然后使用`AC_SUBST`将它们替换到xflaim项目的*Makefile.in*模板中。如果在执行`configure`脚本时用户的环境中已经设置了这些变量，它们的值将保持不变，从而允许用户覆盖宏原本会设置的值。
- en: I discuss the internal operation of these macros in [Chapter 16](ch16.xhtml).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第16章](ch16.xhtml)中讨论了这些宏的内部操作。
- en: '*Canonical System Information*'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*标准系统信息*'
- en: The only non-obvious bit of information you need to know about using macros
    from the GNU Autoconf Archive is that many of them rely on the built-in Autoconf
    macro, `AC_CANONICAL_HOST`. Autoconf provides a way to automatically expand any
    macros used internally by a macro definition right before the definition so that
    required macros are made available immediately. However, if `AC_CANONICAL_HOST`
    is not used before certain macros (including `LT_INIT`), `autoreconf` will generate
    about a dozen warning messages.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自GNU Autoconf Archive的宏时，你需要了解的唯一一个不太显眼的信息是，许多宏依赖于内置的Autoconf宏`AC_CANONICAL_HOST`。Autoconf提供了一种方法，可以在宏定义之前自动扩展宏内部使用的任何宏，从而使所需的宏立即可用。然而，如果在某些宏（包括`LT_INIT`）之前没有使用`AC_CANONICAL_HOST`，`autoreconf`将生成大约十几个警告消息。
- en: To eliminate these warnings, I added `AC_CANONICAL_TARGET` to my xflaim-level
    *configure.ac* file, immediately after the call to `AC_INIT`. The `AC_CANONICAL_SYSTEM`
    macro, and the macros that it calls (`AC_CANONICAL_BUILD`, `AC_CANONICAL_HOST`,
    and `AC_CANONICAL_TARGET`), are designed to ensure that the `$build`, `$host`,
    and `$target` environment variables are defined by `configure` to contain appropriate
    values describing the user’s build, host, and target systems, respectively. Because
    I’m not doing any cross-compiling in this build system, I only needed to invoke
    `AC_CANONICAL_TARGET`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除这些警告，我在我的xflaim级别的*configure.ac*文件中添加了`AC_CANONICAL_TARGET`，并将其置于`AC_INIT`调用之后。`AC_CANONICAL_SYSTEM`宏，以及它调用的宏（`AC_CANONICAL_BUILD`、`AC_CANONICAL_HOST`和`AC_CANONICAL_TARGET`），旨在确保`configure`定义了适当的值，描述用户的构建、主机和目标系统，分别保存在`$build`、`$host`和`$target`环境变量中。由于我在这个构建系统中没有进行交叉编译，因此我只需要调用`AC_CANONICAL_TARGET`。
- en: These variables contain canonical values for the build, host, and target CPU,
    vendor, and operating system. Values like these are very useful to extension macros.
    If a macro can assume these variables are set properly, then it saves quite a
    bit of code duplication in the macro definition.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量包含构建、主机和目标CPU、供应商及操作系统的规范值。类似这样的值对于扩展宏非常有用。如果宏可以假设这些变量已经正确设置，那么它可以节省在宏定义中重复的代码。
- en: 'The values of these variables are calculated using the helper scripts `config
    .guess` and `config.sub`, which are distributed with Autoconf.^([9](footnote.xhtml#ch15fn9))
    The `config.guess` script uses a combination of `uname` commands to ferret out
    information about the build system, then uses that information to derive a set
    of canonical values for CPU, vendor, and operating system. The `config.sub` script
    is used to reformat build, host, and target information specified by the user
    on the `configure` command line into a canonical value. The host and target values
    default to that of the build, unless you override them with command line options
    to `configure`. Such an override might be used when cross-compiling. (See “Item
    6: Cross-Compiling” on [page 517](ch18.xhtml#page_517) for a more detailed explanation
    of cross-compiling within the Autotools framework.)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量的值是通过辅助脚本`config.guess`和`config.sub`计算得出的，这些脚本与Autoconf一起分发。`config.guess`脚本通过一系列`uname`命令来探测构建系统的信息，然后使用这些信息推导出CPU、供应商和操作系统的规范值。`config.sub`脚本用于将用户在`configure`命令行上指定的构建、主机和目标信息重新格式化为规范值。除非你通过`configure`的命令行选项覆盖它们，否则主机和目标值默认为构建的值。这样的覆盖可能用于交叉编译。（有关Autotools框架中交叉编译的更详细说明，请参见[第517页](ch18.xhtml#page_517)的“第6项：交叉编译”）
- en: '*The xflaim/java Directory Structure*'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*xflaim/java目录结构*'
- en: 'The original xflaim source layout had the Java JNI and C# native sources located
    in directory structures outside of *xflaim/src*. The JNI sources were in *xflaim/java/jni*,
    and the C# native sources were in *xflaim/csharp/xflaim*. While Automake can generate
    rules for accessing files outside the current directory hierarchy, it seems silly
    to put these files so far away from the only library they can really belong to.
    Therefore, in this case, I broke my own rule about not rearranging files and moved
    the contents of these two directories beneath *xflaim/src*. I named the JNI directory
    *xflaim/src/java* and the C# native sources directory *xflaim/src/cs*. The following
    diagram illustrates this new directory hierarchy:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的xflaim源代码布局将Java JNI和C#本地源代码放置在*xflaim/src*之外的目录结构中。JNI源代码位于*xflaim/java/jni*，C#本地源代码位于*xflaim/csharp/xflaim*。虽然Automake可以生成规则来访问当前目录层次结构之外的文件，但将这些文件放置得离它们唯一真正属于的库如此遥远似乎是没有必要的。因此，在这种情况下，我打破了自己不重新安排文件的规则，并将这两个目录的内容移到了*xflaim/src*下。我将JNI目录命名为*xflaim/src/java*，将C#本地源代码目录命名为*xflaim/src/cs*。以下图表展示了这一新的目录层次结构：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, I also added a *wrapper* directory beneath the *java* directory,
    in which I rooted the xflaim wrapper package hierarchy. Since the Java xflaim
    wrapper classes are part of the Java xflaim package, they must be located in a
    directory called *xflaim*. Nevertheless, the build happens in the wrapper directory.
    There are no build files found in the *wrapper/xflaim* directory or any directories
    below that point.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我还在*java*目录下添加了一个*wrapper*目录，并在其中根植了xflaim包装器包层次结构。由于Java xflaim包装器类是Java
    xflaim包的一部分，它们必须位于名为*xflaim*的目录中。然而，构建过程发生在wrapper目录中。在*wrapper/xflaim*目录或其下的任何目录中都没有找到构建文件。
- en: '**NOTE**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*No matter how deep your package hierarchy is, you will still build the Java
    classes in the* wrapper *directory, which is the *`JAVAROOT`* directory for this
    project. Autotools Java projects consider the *`JAVAROOT`* directory the build
    directory for the java package.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*无论你的包层次结构多深，你仍然将在*wrapper* *目录中构建 Java 类，该目录就是该项目的*`JAVAROOT`* 目录。Autotools
    Java 项目认为 *`JAVAROOT`* 目录是 Java 包的构建目录。*'
- en: '*The xflaim/src/Makefile.am File*'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*xflaim/src/Makefile.am 文件*'
- en: At this point, the *configure.ac* file is doing about all it can to ensure that
    I have a good Java build environment, in which case my build system will be able
    to generate my JNI wrapper classes and header files and build my C++ JNI sources.
    If my end user’s system doesn’t provide these tools, they simply won’t be able
    to build or link the JNI language bindings to the *xflaim* library on that host.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，*configure.ac* 文件尽其所能确保我拥有良好的 Java 构建环境，在这种情况下，我的构建系统将能够生成 JNI 包装类和头文件，并构建我的
    C++ JNI 源文件。如果我的最终用户的系统未提供这些工具，他们将无法在该主机上构建或链接 JNI 语言绑定到 *xflaim* 库。
- en: Have a look at the *xflaim/src/Makefile.am* file shown in [Listing 15-5](ch15.xhtml#ch15ex5)
    and examine the portions that are relevant to building the Java and C# language
    bindings.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 看一看 [列表 15-5](ch15.xhtml#ch15ex5) 中展示的 *xflaim/src/Makefile.am* 文件，检查与构建 Java
    和 C# 语言绑定相关的部分。
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 15-5*: xflaim/src/Makefile.am: *The portion of this makefile that
    builds Java and C# sources*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-5*：xflaim/src/Makefile.am：*这个 makefile 中构建 Java 和 C# 源文件的部分*'
- en: I’ve already explained the use of the conditionals to ensure that the *java*
    and *cs* directories are only built if the proper conditions are met. You can
    now see how this fits into the build system I’ve created so far.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经解释了使用条件语句来确保只有在满足适当条件时，*java* 和 *cs* 目录才会被构建。你现在可以看到这如何融入我到目前为止所创建的构建系统中。
- en: Notice that I’m conditionally defining two new library variables. If I can build
    the Java language bindings, the *java* subdirectory will be built, and the `JNI_LIBADD`
    variable will refer to the library that is built in the *java* directory. If I
    can build the C# language bindings, the *cs* subdirectory will be built, and the
    `CSI_LIBADD` variable will refer to the library that is built in the *cs* directory.
    In either case, if the required tools are not found by `configure`, the corresponding
    variable will remain undefined. When an undefined `make` variable is referenced,
    it expands to nothing, so there’s no harm in using it in `libxflaim_la_LIBADD`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在条件中定义了两个新的库变量。如果我能构建 Java 语言绑定，*java* 子目录将被构建，`JNI_LIBADD` 变量将引用在 *java*
    目录中构建的库。如果我能构建 C# 语言绑定，*cs* 子目录将被构建，`CSI_LIBADD` 变量将引用在 *cs* 目录中构建的库。在这两种情况下，如果
    `configure` 没有找到所需的工具，对应的变量将保持未定义。当引用一个未定义的 `make` 变量时，它展开为空，因此在 `libxflaim_la_LIBADD`
    中使用它没有问题。
- en: '*Building the JNI C++ Sources*'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*构建 JNI C++ 源文件*'
- en: Now turn your attention to the *xflaim/src/java/Makefile.am* file shown in [Listing
    15-6](ch15.xhtml#ch15ex6).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请注意 *xflaim/src/java/Makefile.am* 文件，见 [列表 15-6](ch15.xhtml#ch15ex6)。
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 15-6*: xflaim/src/java/Makefile.am: *This makefile builds the JNI
    sources.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-6*：xflaim/src/java/Makefile.am：*这个 makefile 构建 JNI 源文件。*'
- en: Again, I want the *wrapper* directory to be built first (the dot at the end
    of the `SUBDIRS` list is implied), before the *xflaim* library, because the *wrapper*
    directory will build the class files and JNI header files required by the JNI
    convenience library sources. Building this directory is not conditional. If I’ve
    made it this far into the build hierarchy, I know I have all the Java tools I
    need. This *Makefile.am* file simply builds a convenience library containing my
    JNI C++ interface functions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我希望 *wrapper* 目录在 *xflaim* 库之前先被构建（`SUBDIRS` 列表末尾的点是隐含的），因为 *wrapper* 目录将构建
    JNI 便利库源文件所需的类文件和 JNI 头文件。构建这个目录不是条件性的。如果我已经到达构建层次结构的这一部分，我知道我拥有所有需要的 Java 工具。这个
    *Makefile.am* 文件仅构建一个包含我的 JNI C++ 接口函数的便利库。
- en: Because of the way Libtool builds both shared and static libraries from the
    same sources, this convenience library will become part of both the *xflaim* shared
    and static libraries. The original build system makefile accounted for this by
    linking the JNI and C# native interface objects only into the shared library (where
    they make sense).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Libtool 以相同的源代码构建共享库和静态库，因此这个便利库将成为 *xflaim* 共享库和静态库的一部分。原始的构建系统 makefile
    已通过仅将 JNI 和 C# 本地接口对象链接到共享库中（在那里它们是有意义的）来考虑这一点。
- en: '**NOTE**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The fact that these libraries are added to both the shared and static* xflaim
    *libraries is not really a problem. Objects in a static library remain unused
    in applications or libraries linking to the static library, as long as functions
    and data in those objects remain unreferenced, though this is a bit of a wart
    on my new build system.*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些库被添加到共享和静态*xflaim*库中并不是一个真正的问题。只要这些对象中的函数和数据没有被引用，静态库中的对象在应用程序或链接到静态库的库中就不会被使用，尽管这在我新的构建系统中有些瑕疵。*'
- en: '*The Java Wrapper Classes and JNI Headers*'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*Java包装类和JNI头文件*'
- en: Finally, *xflaim/src/java/wrapper/Makefile.am* takes us to the heart of the
    matter. I’ve tried many different configurations for building Java JNI wrappers,
    and this one always comes out on top. [Listing 15-7](ch15.xhtml#ch15ex7) shows
    the *wrapper* directory’s Automake input file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*xflaim/src/java/wrapper/Makefile.am*带我们进入了问题的核心。我尝试过许多不同的配置来构建Java JNI包装器，而这个配置总是表现得最为出色。[列表15-7](ch15.xhtml#ch15ex7)展示了*包装*目录的Automake输入文件。
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 15-7*: xflaim/src/java/wrapper/Makefile.am: *The wrapper directory’s*
    Makefile.am *file*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表15-7*：xflaim/src/java/wrapper/Makefile.am：*包装目录的*Makefile.am*文件*'
- en: At the top of the file, I’ve set the `JAVAROOT` variable to dot (`.`), because
    I want Automake to be able to tell the Java compiler that this is where the package
    hierarchy begins. The default value for `JAVAROOT` is `$(top_builddir)`, which
    would incorrectly have the wrapper class belong to the *xflaim.src.java.wrapper.xflaim*
    package.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的顶部，我将`JAVAROOT`变量设置为点（`.`），因为我希望Automake能够告诉Java编译器这里是包层次结构的起始点。`JAVAROOT`的默认值是`$(top_builddir)`，这将错误地使包装类属于*xflaim.src.java.wrapper.xflaim*包。
- en: I create a variable at ➊ called `jarfile`, which derives its value from `$(PACKAGE``_TARNAME)`
    and `$(PACKAGE_VERSION)`. (Recall from [Chapter 3](ch03.xhtml) that this is also
    how the `distdir` variable is derived, from which the name of the tarball comes.)
    A `make` rule indicates how the *.jar* file should be built. Here, I’m using the
    `JAR` variable, whose value was calculated by the `FLM_PROG_TRY_JNI` macro in
    the `configure` script.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我在➊创建了一个名为`jarfile`的变量，其值来自`$(PACKAGE``_TARNAME)`和`$(PACKAGE_VERSION)`。 （回想一下第[3章](ch03.xhtml)中，`distdir`变量的值也是这样得出的，从中得到了tarball的名称。）一个`make`规则指明了*.jar*文件应该如何构建。这里，我使用的是`JAR`变量，其值由`configure`脚本中的`FLM_PROG_TRY_JNI`宏计算得出。
- en: I define a new installation variable at ➋ called `jardir` where *.jar* files
    are to be installed, and I use that variable as the prefix for a `DATA` primary
    at ➌. Automake considers files that fit the Automake *`where_HOW`* scheme (with
    a defined *`where`*`dir`) as either architecture-independent data files or platform-specific
    executables. Installation location variables (those ending in `dir`) that begin
    with `bin`, `sbin`, `libexec`, `sysconf`, `localstate`, `lib`, or `pkglib` or
    that contain the string “exec” are considered platform-specific executables and
    are installed during execution of the `install-exec` target. Automake considers
    files installed in any other locations data files. These are installed during
    execution of the `install-data` target. The well-known installation locations
    such as *bindir*, *sbindir*, and so on are already taken, but if you want to install
    custom architecture-dependent executable files, just ensure that your custom installation
    location variable contains the string “exec,” as in `myspecialexecdir`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我在➋定义了一个新的安装变量`jardir`，用于指定*.jar*文件的安装位置，并在➌处将该变量用作`DATA`主项的前缀。Automake认为符合Automake
    *`where_HOW`*模式（带有定义的*`where`*`dir`）的文件，要么是架构独立的数据文件，要么是平台特定的可执行文件。以`bin`、`sbin`、`libexec`、`sysconf`、`localstate`、`lib`、`pkglib`开头，或包含“exec”字符串的安装位置变量（以`dir`结尾）被视为平台特定的可执行文件，并在执行`install-exec`目标时安装。Automake认为安装在其他位置的文件是数据文件，并在执行`install-data`目标时进行安装。诸如*bindir*、*sbindir*等常见的安装位置已经被占用，但如果你想安装自定义的依赖架构的可执行文件，只需确保你的自定义安装位置变量包含“exec”字符串，如`myspecialexecdir`。
- en: I use another stamp file at ➍ in the rule that builds the JNI header files from
    the *.class* files for the same reasons that Automake uses a stamp file in the
    rule that it uses to build *.class* files from *.java* source files.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我在➍使用另一个时间戳文件，在规则中从*.class*文件生成JNI头文件，原因与Automake在规则中使用时间戳文件来从*.java*源文件生成*.class*文件相同。
- en: This is the most complex part of this makefile, so I’ll break it into smaller
    pieces.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个Makefile中最复杂的部分，所以我将其拆分成更小的部分。
- en: The rule states that the stamp file depends on the source files listed in the
    `dist_noinst_JAVA` variable. The command is a bit of complex shell script that
    strips the *.java* extensions from the file list and converts all the slash characters
    into periods. The reason for this is that the `javah` utility wants a list of
    class names, not a list of filenames. The `$(JAVAH)` command then accepts this
    entire list as input in order to generate a corresponding list of JNI header files.
    The last line, of course, generates the stamp file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则声明，stamp文件依赖于`dist_noinst_JAVA`变量中列出的源文件。该命令是一个复杂的Shell脚本，它会从文件列表中剥离*.java*扩展名，并将所有的斜杠字符转换为点号。这样做的原因是`javah`工具需要的是类名列表，而不是文件名列表。`$(JAVAH)`命令接受这个完整的列表作为输入，以生成相应的JNI头文件列表。当然，最后一行会生成stamp文件。
- en: Finally at ➎, I hook my `java-headers.stamp` target into the `all` target by
    adding it as a dependency to the `all-local` target. When the `all` target (the
    default for all Automake-generated makefiles) is executed in this makefile, *java-headers.stamp*
    will be built, along with the JNI headers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在➎处，我将`java-headers.stamp`目标与`all`目标挂钩，通过将它作为依赖项添加到`all-local`目标中。当在此makefile中执行`all`目标（所有Automake生成的makefile的默认目标）时，*java-headers.stamp*将与JNI头文件一起构建。
- en: '**NOTE**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It’s a good idea to add custom rule targets as dependencies to the Automake-provided
    hook and local targets, rather than directly associating commands with these hook
    and local targets. By doing this, the commands for individual tasks on those targets
    remain isolated and thus easier to maintain.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*最好将自定义规则目标作为依赖项添加到Automake提供的钩子和本地目标中，而不是直接将命令与这些钩子和本地目标关联。这样，单个任务的命令将保持独立，从而更易于维护。*'
- en: I add the *.jar* file, all of the *.class* files, the *java-headers.stamp* file,
    and all of the generated JNI header files to the `CLEANFILES` variable at ➏ so
    that Automake will clean them up when `make clean` is executed. Again, I can use
    the `CLEANFILES` variable here because I’m not trying to delete any directories.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我将*.jar*文件、所有*.class*文件、*java-headers.stamp*文件以及所有生成的JNI头文件添加到`CLEANFILES`变量中（➏），以便在执行`make
    clean`时，Automake会将它们清理掉。再次强调，我可以在这里使用`CLEANFILES`变量，因为我并不打算删除任何目录。
- en: The final step in writing any such custom code is to ensure that the `distcheck`
    target still works, because when we generate our own products, we have to ensure
    that the `clean` target properly removes them all.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 编写任何自定义代码的最后一步是确保`distcheck`目标仍然有效，因为当我们生成自己的产品时，必须确保`clean`目标能够正确地删除它们。
- en: Finally, I should mention that the rule to build the *.jar* file, near the top
    of [Listing 15-7](ch15.xhtml#ch15ex7), relies on a wildcard to pick up all the
    *.class* files in the *xflaim* directory. The Autotools purposely avoid such wildcards
    for many reasons, including the very valid reason that you may inadvertently pick
    up files that were built by a previous build that are no longer relevant to your
    project after changes eliminate those sources from the project. For Java, the
    only way to specify the exact *.class* files that should go into the *.jar* file
    is to parse all the *.java* files and derive a list of *.class* files that would
    be built from those sources. I made a judgment call here and decided that using
    a wildcard was worth the possible problems doing so may cause. I also used wildcards
    in the `CLEANFILES` variable near the bottom of [Listing 15-7](ch15.xhtml#ch15ex7).
    Of course, the same potential problems exist here—you could remove a file that
    is present but no longer associated with the build.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我应该提到，构建*.jar*文件的规则（在[列表 15-7](ch15.xhtml#ch15ex7)顶部附近）依赖于通配符来选取*xflaim*目录中的所有*.class*文件。Autotools故意避免使用此类通配符，原因有很多，其中一个非常合理的原因是你可能会无意中选中那些由先前构建生成、但在更改后不再与项目相关的文件，因为这些源文件已从项目中删除。对于Java，指定应放入*.jar*文件中的确切*.class*文件的唯一方法是解析所有*.java*文件，并生成一个由这些源文件构建出的*.class*文件的列表。我在这里做出了一个判断，决定使用通配符值得冒着可能会引起的问题。我还在[列表
    15-7](ch15.xhtml#ch15ex7)底部的`CLEANFILES`变量中使用了通配符。当然，这里也存在相同的潜在问题——你可能会删除一个文件，而这个文件目前存在，但已不再与构建相关。
- en: '*A Caveat About Using the JAVA Primary*'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*关于使用JAVA主目标的警告*'
- en: The one important caveat to using the `JAVA` primary is that you may define
    only one `JAVA` primary variable per *Makefile.am* file. The reason for this is
    that multiple classes may be generated from a single *.java* file, and the only
    way to know which classes came from which *.java* file would be for Automake to
    parse the *.java* files (which is ridiculous, and arguably the primary reason
    why build tools like *Apache Ant* and *Maven* were developed). Rather than do
    this, Automake allows only one `JAVA` primary per file, so all *.class* files
    generated within a given build directory are installed in the location specified
    by the single `JAVA` primary variable prefix.^([10](footnote.xhtml#ch15fn10))
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `JAVA` 主变量时，有一个重要的警告，那就是每个 *Makefile.am* 文件中只能定义一个 `JAVA` 主变量。其原因在于，一个 *.java*
    文件可能会生成多个类，而要知道哪些类是由哪个 *.java* 文件生成的，唯一的办法就是让 Automake 解析 *.java* 文件（这显然不现实，并且也是像
    *Apache Ant* 和 *Maven* 这样的构建工具被开发出来的主要原因）。为了避免这样做，Automake 只允许每个文件定义一个 `JAVA`
    主变量，因此所有在给定构建目录中生成的 *.class* 文件都会安装到由单个 `JAVA` 主变量前缀指定的位置。^([10](footnote.xhtml#ch15fn10))
- en: '**NOTE**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The system I’ve designed will work fine for this case, but it’s a good thing
    I don’t need to install my JNI header files, because I have no way of knowing
    what they’re called from within my* Makefile.am *file*!'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*我设计的系统在这种情况下能很好地工作，但好在我不需要安装我的 JNI 头文件，因为我无法从我的 Makefile.am 文件中知道它们叫什么！*'
- en: You should by now be able to see the problems that the Autotools have with Java.
    In fact, these problems are not so much related to the design issues in the Autotools
    as they are to design issues within the Java language itself, as you’ll see in
    the next section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该能看到 Autotools 在处理 Java 时遇到的问题。事实上，这些问题更多是与 Java 语言本身的设计问题相关，而不是 Autotools
    设计中的问题，正如你将在下一节中看到的。
- en: Building the C# Sources
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 C# 源代码
- en: 'Returning to the *xflaim/src/cs* directory brings us to a discussion of building
    sources for a language for which Automake has no support: C#. [Listing 15-8](ch15.xhtml#ch15ex8)
    shows the *Makefile.am* file that I wrote for the *cs* directory.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 *xflaim/src/cs* 目录，我们将讨论如何为 Automake 不支持的语言构建源代码：C#。[清单 15-8](ch15.xhtml#ch15ex8)
    显示了我为 *cs* 目录编写的 *Makefile.am* 文件。
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 15-8*: xflaim/src/cs/Makefile.am: *The contents of the cs directory’s
    Automake input file*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-8*：xflaim/src/cs/Makefile.am：*cs 目录的 Automake 输入文件内容*'
- en: Not surprisingly, this looks almost identical to the *Makefile.am* file found
    in the *xflaim/src/java* directory because I’m building a simple convenience library
    from C++ source files found in this directory, just as I did in the *java* directory.
    As in the Java version, this makefile first builds a subdirectory called *wrapper*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，这看起来与 *xflaim/src/java* 目录中的 *Makefile.am* 文件几乎相同，因为我正在从该目录中的 C++ 源文件构建一个简单的便捷库，正如我在
    *java* 目录中所做的那样。与 Java 版本一样，这个 makefile 首先会构建一个名为 *wrapper* 的子目录。
- en: '[Listing 15-9](ch15.xhtml#ch15ex9) shows the full contents of the *wrapper/Makefile.am*
    file.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 15-9](ch15.xhtml#ch15ex9) 显示了 *wrapper/Makefile.am* 文件的完整内容。'
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 15-9*: xflaim/src/cs/wrapper/Makefile.am: *The full contents of the
    C# makefile*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-9*：xflaim/src/cs/wrapper/Makefile.am：*C# makefile 的完整内容*'
- en: The default target for *Makefile.am* is `all`, the same as that of a normal
    non-Automake makefile. Again, I’ve hooked my code into the `all` target by implementing
    the `all-local` target, which depends on a file named *xflaim_csharp.dll*.^([11](footnote.xhtml#ch15fn11))
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*Makefile.am* 的默认目标是 `all`，与普通的非-Automake makefile 相同。同样，我通过实现 `all-local`
    目标将我的代码挂钩到 `all` 目标，该目标依赖于名为 *xflaim_csharp.dll* 的文件。^([11](footnote.xhtml#ch15fn11))'
- en: The C# sources are built by the commands under the *xflaim_csharp.dll* target
    at ➋, and the *xflaim_csharp.dll* binary depends on the list of C# source files
    specified in the `xfcs_sources` variable. The commands in this rule are copied
    from the Automake-generated *java/wrapper/Makefile* and are slightly modified
    to build C# binaries from C# source files (as highlighted in the listing). This
    isn’t intended to be a lesson in building C# sources; the point here is that the
    default target is automatically built by creating a dependency between the `all-local`
    target and your own targets at ➊.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: C# 源文件通过 ➋ 处的 *xflaim_csharp.dll* 目标下的命令进行构建，而 *xflaim_csharp.dll* 二进制文件依赖于
    `xfcs_sources` 变量中指定的 C# 源文件列表。此规则中的命令是从 Automake 生成的 *java/wrapper/Makefile*
    中复制的，并经过稍微修改，以便从 C# 源文件构建 C# 二进制文件（如清单中所示）。这里的重点不是讲解如何构建 C# 源文件；重点在于通过在 ➊ 处创建
    `all-local` 目标与您自己目标之间的依赖关系，默认目标会被自动构建。
- en: This *Makefile.am* file also builds a set of unit tests in C# that assess the
    C# language bindings. The target of this rule is *cstest.exe* (➌), which ultimately
    becomes a C# executable. The rule states that *cstest.exe* depends on *xflaim_csharp.dll*
    and the source files. I’ve again copied the commands from the rule for building
    *xflaim_csharp.dll* (as highlighted) and modified them for building the C# programs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*Makefile.am*文件还构建了一套用于评估C#语言绑定的单元测试。该规则的目标是*cstest.exe*（➌），最终成为一个C#可执行文件。规则说明，*cstest.exe*依赖于*xflaim_csharp.dll*和源文件。我再次复制了构建*xflaim_csharp.dll*的规则中的命令（如高亮显示），并对其进行了修改以构建C#程序。
- en: Ultimately, upon building the `check` target, the Automake-generated makefile
    will attempt to execute the scripts or executables listed in the `TESTS` variable.
    The idea here is to ensure that all necessary components are built before these
    files are executed. I’ve tied into the `check` target by defining `check-local`
    and making it depend on my test code targets.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，在构建`check`目标时，Automake生成的makefile将尝试执行`TESTS`变量中列出的脚本或可执行文件。这里的目的是确保在执行这些文件之前，所有必要的组件都已经构建完成。我通过定义`check-local`并使其依赖于我的测试代码目标，来将其与`check`目标关联起来。
- en: The `cstest_script` at ➍ is a shell script built solely to execute the *cstest.exe*
    binary within the C# virtual machine. The C# virtual machine is found in the `CSVM`
    variable, which was defined in `configure` by the code generated by the `FLM_PROG_TRY_CSVM`
    macro.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ➎处的`cstest_script`是一个仅用于在C#虚拟机中执行* cstest.exe*二进制文件的Shell脚本。C#虚拟机位于`CSVM`变量中，该变量由`FLM_PROG_TRY_CSVM`宏生成的`configure`代码定义。
- en: The `cstest_script` depends only on the `cstest.exe` program. However, the *xflaim*
    library either must be present in the current directory or must be in the system
    library search path. We gain maximum portability here by using Libtool’s *execute*
    mode to add the *xflaim* library to the system library search path before executing
    the C# virtual machine at ➎.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`cstest_script`仅依赖于`cstest.exe`程序。然而，*xflaim*库要么必须存在于当前目录中，要么必须在系统库搜索路径中。在这里，我们通过使用Libtool的*execute*模式，在执行C#虚拟机之前将*xflaim*库添加到系统库搜索路径中，从而实现最大的可移植性。'
- en: '*Manual Installation*'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*手动安装*'
- en: Since in this example I’m doing everything myself, I have to write my own installation
    rules. [Listing 15-10](ch15.xhtml#ch15ex10) reproduces only the installation rules
    in the *Makefile.am* file from [Listing 15-9](ch15.xhtml#ch15ex9).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这个示例中我自己完成所有工作，因此我必须编写自己的安装规则。[清单15-10](ch15.xhtml#ch15ex10)仅复制了[清单15-9](ch15.xhtml#ch15ex9)中的*Makefile.am*文件中的安装规则。
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 15-10*: xflaim/src/cs/wrapper/Makefile.am: *The installation rules
    of this makefile*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单15-10*：xflaim/src/cs/wrapper/Makefile.am：*该makefile的安装规则*'
- en: According to the rules defined in the *GNU Coding Standards*, the installation
    targets do not depend on the binaries they install, so if the binaries haven’t
    been built yet, I may have to exit from *root* to my user account to build the
    binaries with `make all` first.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*GNU编码标准*中定义的规则，安装目标不依赖于它们所安装的二进制文件，因此，如果二进制文件尚未构建，我可能需要退出*root*账户，切换到我的用户账户并先使用`make
    all`构建二进制文件。
- en: Automake distinguishes between installing programs and installing data. However,
    there’s only one `uninstall` target. The rationale seems to be that you might
    want to do an `install-exec` operation per system in your network, but only one
    shared `install-data` operation. Uninstalling a product requires no such separation,
    because uninstalling data multiple times is typically harmless.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Automake区分安装程序和安装数据。然而，只有一个`uninstall`目标。其基本原理似乎是，你可能希望在网络中的每台系统上执行`install-exec`操作，但只需进行一次共享的`install-data`操作。卸载产品时不需要这种区分，因为卸载数据多次通常是无害的。
- en: '*Cleaning Up Again*'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*再次清理*'
- en: As usual, things must be cleaned up properly in order to make distribution checks
    happy. The `clean-local` target handles this nicely, as shown in [Listing 15-11](ch15.xhtml#ch15ex11).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，必须正确清理文件，以便使分发检查通过。`clean-local`目标很好地处理了这一点，如[清单15-11](ch15.xhtml#ch15ex11)所示。
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 15-11*: xflaim/src/cs/wrapper/Makefile.am: *The clean rules defined
    in this makefile*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单15-11*：xflaim/src/cs/wrapper/Makefile.am：*该makefile中定义的清理规则*'
- en: Configuring Compiler Options
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置编译器选项
- en: The original GNU Make build system provided a number of command line build options.
    By specifying a list of auxiliary targets on the `make` command line, the user
    could indicate that they wanted a debug or release build, force a 32-bit build
    on a 64-bit system, generate generic SPARC code on a Solaris system, and so on.
    This was a turnkey approach to build systems that is quite common in commercial
    code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的GNU Make构建系统提供了许多命令行构建选项。通过在`make`命令行中指定一系列辅助目标，用户可以指示他们想要调试或发布构建、在64位系统上强制进行32位构建、在Solaris系统上生成通用的SPARC代码等等。这是一种即插即用的构建系统方法，在商业代码中非常常见。
- en: 'In open source projects, and particularly in Autotools-based build systems,
    the more common practice is to omit much of this rigid framework, allowing the
    user to set their own options in the standard user variables: `CC`, `CPP`, `CXX`,
    `CFLAGS`, `CXXFLAGS`, `CPPFLAGS`, and so on.^([12](footnote.xhtml#ch15fn12))'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在开源项目中，尤其是在基于Autotools的构建系统中，更常见的做法是省略这些固定的框架，允许用户在标准用户变量中设置自己的选项：`CC`、`CPP`、`CXX`、`CFLAGS`、`CXXFLAGS`、`CPPFLAGS`等。^([12](footnote.xhtml#ch15fn12))
- en: Probably the most compelling argument for the Autotools approach to option management
    is that it’s policy driven and the rigid frameworks used by commercial software
    vendors can easily be implemented in terms of the much more flexible policy-driven
    Autotools framework. For example, a *config.site* file might be used to provide
    site-wide options for all Autotools-based builds done at a particular site. A
    simple script can be used to configure various environment-based options before
    calling `configure`, or these options may even be passed to `configure` or `make`
    directly within such a script. The Autotools policy-driven approach offers the
    flexibility to be as configurable as a developer might want or as tight as required
    by management.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可能对于Autotools方法管理选项最有力的论点是，它是政策驱动的，商业软件供应商使用的固定框架可以很容易地通过更加灵活的政策驱动的Autotools框架来实现。例如，*config.site*文件可以用于为特定站点上进行的所有基于Autotools的构建提供站点范围的选项。在调用`configure`之前，可以使用一个简单的脚本来配置各种基于环境的选项，或者这些选项甚至可以在这样的脚本中直接传递给`configure`或`make`。Autotools的政策驱动方法提供了灵活性，可以根据开发人员的需求进行配置，或者根据管理层的要求进行严格限制。
- en: Ultimately, we’d like to have FLAIM project options conform to the Autotools
    policy-driven approach; however, I didn’t want to lose the research effort involved
    in determining the hardcoded native compiler options specified in the original
    makefile. To this end, I’ve added back in *some* of the options to the *configure.ac*
    file that were supported by the original build system, but I’ve left others out.
    [Listing 15-12](ch15.xhtml#ch15ex12) shows the end result of these efforts. This
    code enables various native compiler options, optimizations, and debugging features
    on demand, based on the contents of some of the user variables.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们希望FLAIM项目选项符合Autotools政策驱动的方法；然而，我不想失去确定原始makefile中硬编码本地编译器选项所涉及的研究工作。为此，我已经将*部分*选项添加回了*configure.ac*文件，这些选项是原始构建系统所支持的，但我也有一些选项没有添加。
    [清单 15-12](ch15.xhtml#ch15ex12)显示了这些努力的最终结果。此代码根据一些用户变量的内容，按需启用各种本地编译器选项、优化和调试功能。
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 15-12*: xflaim/configure.ac: *The portion of this file that enables
    compiler-specific options*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-12*：xflaim/configure.ac：*此文件中启用特定编译器选项的部分*'
- en: Remember that this code depends on the earlier use of the `AC_CANONICAL_SYSTEM`
    (or `AC_CANONICAL_TARGET`) macro, which sets `build`, `host`, and `target` environment
    variables to canonical string values that indicate CPU, vendor, and operating
    system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这段代码依赖于之前使用的`AC_CANONICAL_SYSTEM`（或`AC_CANONICAL_TARGET`）宏，该宏将`build`、`host`和`target`环境变量设置为规范的字符串值，以指示CPU、供应商和操作系统。
- en: In [Listing 15-12](ch15.xhtml#ch15ex12), I used the `host` variable in the `case`
    statement at ➊ to determine the type of system for which I was building. This
    `case` statement determines if the user is building on Solaris, Apple Darwin,
    AIX, or HP-UX by looking for substrings in `host` that are common to all variations
    of these platforms. The `config.guess` and `config.sub` files are your friends
    here. If you need to write code like this for your project, examine these files
    to find common traits for the processes and systems for which you’d like to set
    various compiler and linker options.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 15-12](ch15.xhtml#ch15ex12) 中，我在 ➊ 的 `case` 语句中使用了 `host` 变量来确定我为其构建的系统类型。这个
    `case` 语句通过查找 `host` 中的子字符串来判断用户是否在 Solaris、Apple Darwin、AIX 或 HP-UX 上构建，这些子字符串在这些平台的所有变体中都是共同的。`config.guess`
    和 `config.sub` 文件是你在这里的好帮手。如果你需要为你的项目编写类似的代码，可以检查这些文件，找出你希望为其设置各种编译器和链接器选项的进程和系统的共同特征。
- en: '**NOTE**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In each of these cases (except for the definition of the *`OSX`* preprocessor
    variable on Apple Darwin systems), I’m really only setting flags for native compilers.
    The GNU compiler tools seem to be able to handle any code without the need for
    additional compiler options. It’s worth reiterating here that the Autotools feature-present
    approach to setting options once again wins. Maintenance is reduced dramatically
    when you don’t have to support large *`case`* statements for an ever-growing list
    of supported hosts and tool sets.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这些情况下（除了在 Apple Darwin 系统上定义 *`OSX`* 预处理器变量的情况），我实际上只是为本地编译器设置标志。GNU 编译器工具似乎能够处理任何代码，而无需额外的编译器选项。在这里值得再次强调的是，Autotools
    的特性-存在方法设置选项再次胜出。当你不必为一个不断增长的支持主机和工具集列表支持大量的 *`case`* 语句时，维护工作会大大减少。*'
- en: Hooking Doxygen into the Build Process
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Doxygen 集成到构建过程中
- en: I want to generate documentation as part of my build process, if possible. That
    is, if the user has `doxygen` installed, the build system will use it to build
    Doxygen documentation as part of the `make all` process.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望在构建过程中生成文档，如果可能的话。也就是说，如果用户已经安装了 `doxygen`，构建系统将使用它作为 `make all` 过程的一部分来生成
    Doxygen 文档。
- en: The original build system has both static and generated documentation. The static
    documentation should always be installed, but the Doxygen documentation can only
    be built if the `doxygen` program is available on the host. Thus, I always build
    the *docs* directory, but I use the `AM_CONDITIONAL` macro to conditionally build
    the *docs/doxygen* directory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的构建系统同时有静态文档和生成的文档。静态文档应始终安装，但只有在主机上可用 `doxygen` 程序时，Doxygen 文档才可以构建。因此，我始终构建
    *docs* 目录，但我使用 `AM_CONDITIONAL` 宏来有条件地构建 *docs/doxygen* 目录。
- en: Doxygen uses a configuration file (often called *doxyfile*) to configure literally
    hundreds of Doxygen options. This configuration file contains some information
    that is known to the configuration script. This sounds like the perfect opportunity
    to use an Autoconf-generated file. To this end, I’ve written an Autoconf template
    file called *doxyfile.in* that contains most of what a normal Doxygen input file
    would contain, as well as a few Autoconf substitution variable references. The
    relevant lines in this file are shown in [Listing 15-13](ch15.xhtml#ch15ex13).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Doxygen 使用配置文件（通常称为 *doxyfile*）来配置数百个 Doxygen 选项。这个配置文件包含一些配置脚本已知的信息。这听起来像是一个使用
    Autoconf 生成的文件的绝佳机会。为此，我编写了一个名为 *doxyfile.in* 的 Autoconf 模板文件，包含了一个正常的 Doxygen
    输入文件会包含的大部分内容，并且有一些 Autoconf 替换变量引用。此文件中的相关行如 [清单 15-13](ch15.xhtml#ch15ex13)
    所示。
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 15-13*: xflaim/docs/doxygen/doxyfile.in: *The lines in this file that
    contain Autoconf variables*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-13*：xflaim/docs/doxygen/doxyfile.in：*此文件中包含 Autoconf 变量的行*'
- en: There are many other lines in this file, but they are all identical to the output
    file, so I’ve omitted them for the sake of space and clarity. The key here is
    that `config.status` will replace these substitution variables with their values
    as defined in *configure.ac* and by Autoconf itself. If these values change in
    *configure.ac*, the generated file will be rewritten with the new values. I’ve
    added a conditional reference for *xflaim/docs/doxygen/doxyfile* to the `AC_CONFIG_FILES`
    list in xflaim’s *configure.ac* file. That’s all it takes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件中还有很多其他行，但它们与输出文件完全相同，所以为了节省空间和提高清晰度，我省略了它们。这里的关键是 `config.status` 会将这些替换变量替换为它们在
    *configure.ac* 中定义的值，并由 Autoconf 本身定义。如果这些值在 *configure.ac* 中发生变化，生成的文件将会使用新值重新写入。我在
    xflaim 的 *configure.ac* 文件中为 *xflaim/docs/doxygen/doxyfile* 添加了一个条件引用到 `AC_CONFIG_FILES`
    列表中。就这么简单。
- en: '[Listing 15-14](ch15.xhtml#ch15ex14) shows the *xflaim/docs/doxygen/Makefile.am*
    file.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单15-14](ch15.xhtml#ch15ex14)显示了*xflaim/docs/doxygen/Makefile.am*文件。'
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 15-14*: xflaim/docs/doxygen/Makefile.am: *The full contents of this
    makefile*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单15-14*：xflaim/docs/doxygen/Makefile.am：*此Makefile的完整内容*'
- en: Here, I create a package name at ➊ for the tarball that will contain the Doxygen
    documentation files. This is basically the same as the distribution tarball for
    the xflaim project, except that it contains the text `-doxy` after the package
    name.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我在➊为包含Doxygen文档文件的tar包创建了一个包名称。这基本上与xflaim项目的分发tar包相同，只不过包名称后包含`-doxy`。
- en: I define a `doc_DATA` variable at ➋ that contains the name of the Doxygen tarball.
    This file will be installed in the `$(docdir)` directory, which by default is
    `$(datarootdir)`*/doc/*`$(PACKAGE_TARNAME)`, and `$(datarootdir)` is configured
    by Automake as `$(prefix)`*/share*, by default.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我在➋定义了一个`doc_DATA`变量，该变量包含Doxygen tar包的名称。该文件将安装到`$(docdir)`目录，默认情况下是`$(datarootdir)`*/doc/*`$(PACKAGE_TARNAME)`，而`$(datarootdir)`由Automake配置为`$(prefix)`*/share*，默认情况下如此。
- en: '**NOTE**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The* `DATA` *primary brings with it significant Automake functionality—installation
    is managed automatically. While I must build the Doxygen documentation package,
    the* `DATA` *primary automatically hooks the* `all` *target for me so that my
    package is built when the user executes* `make` *or* `make all`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*The* `DATA` *主目标带来了显著的Automake功能——安装由系统自动管理。虽然我必须构建Doxygen文档包，但* `DATA` *主目标自动为我挂钩`all`目标，这样当用户执行`make`或`make
    all`时，我的包就会被构建。'
- en: I use another stamp file at ➌ because Doxygen generates literally hundreds of
    *.html* files from the source files in my project. Rather than attempt to figure
    out a rational way to assign dependencies, I’ve chosen to generate one stamp file
    and then use that to determine whether the documentation is out-of-date.^([13](footnote.xhtml#ch15fn13))
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我在➌使用另一个印章文件，因为Doxygen会从我的项目中的源文件生成数百个*.html*文件。与其尝试找出一个合理的方法来分配依赖关系，我选择生成一个印章文件，然后使用它来判断文档是否过时。^([13](footnote.xhtml#ch15fn13))
- en: I also decided that it would be nice to unpack the documentation archive into
    the package *doc* directory. Left up to Automake, the tarball would make it into
    the proper directory at installation time, but that’s as far as it would go. I
    needed to be able to hook the installation process to do this, and this is the
    perfect use for an Automake `-hook` target. I use the `install-data-hook` target
    at ➍ because the `-hook` targets allow you to perform extra user-defined shell
    commands after the operation that’s being hooked has completed. Likewise, I use
    `uninstall-hook` to remove the *html* directory created when the *.tar* file was
    extracted during installation. (There is no distinction between uninstalling platform-specific
    and platform-independent files, so there is only one hook for uninstalling files.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我还决定，将文档归档解压到包的*doc*目录会很不错。如果仅依赖Automake，tar包会在安装时被放入正确的目录，但仅此而已。我需要能够挂钩安装过程来完成这一操作，而这正是Automake
    `-hook`目标的完美应用。我在➍使用`install-data-hook`目标，因为`-hook`目标允许你在被挂钩操作完成后执行额外的用户定义的Shell命令。同样，我使用`uninstall-hook`来删除在安装过程中提取*.tar*文件时创建的*html*目录。（卸载平台特定文件和平台无关文件之间没有区别，因此卸载文件时只有一个钩子。）
- en: To clean my generated files, I use a combination of the `CLEANFILES` variable
    at ➎ and a `clean-local` rule just to demonstrate that it can be done.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理我生成的文件，我使用了➎处的`CLEANFILES`变量和一个`clean-local`规则，只是为了演示它可以被完成。
- en: Adding Nonstandard Targets
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加非标准目标
- en: Adding a new nonstandard target is a little different than hooking an existing
    target. In the first place, you don’t need to use `AM_CONDITIONAL` and other Autoconf
    tests to see if you have the tools you need. Instead, you can do all conditional
    testing from the *Makefile.am* file because you control the entire command set
    associated with the target, although this isn’t recommended practice. (It’s always
    preferable to ensure that the build environment is configured correctly from the
    `configure` script.) In cases where `make` targets can only be expected to work
    under certain conditions, or on certain platforms, it’s a good idea to provide
    checks within the target to ensure that the operation requested can actually be
    performed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的非标准目标与挂钩现有目标略有不同。首先，你不需要使用 `AM_CONDITIONAL` 和其他 Autoconf 测试来检查是否拥有所需的工具。相反，你可以直接从
    *Makefile.am* 文件中进行所有条件测试，因为你控制与目标相关的整个命令集，尽管这并不是推荐的做法。（最好从 `configure` 脚本确保构建环境配置正确。）在某些情况下，如果
    `make` 目标只能在特定条件下或特定平台上工作，最好在目标中提供检查，确保请求的操作实际上可以执行。
- en: To start with, I create a directory within each project root directory called
    *obs* to contain the *Makefile.am* file for building RPM package files. (*OBS*
    is an acronym for *openSUSE Build Service*, an online package-building service.)^([14](footnote.xhtml#ch15fn14))
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我在每个项目的根目录下创建了一个名为 *obs* 的目录，用来存放构建 RPM 包文件的 *Makefile.am* 文件。（*OBS* 是 *openSUSE
    Build Service* 的缩写，一个在线包构建服务。）^([14](footnote.xhtml#ch15fn14))
- en: Building RPM package files is done using a configuration file, called a *spec*
    file, which is very much like the *doxyfile* used to configure Doxygen for a specific
    project. As with the *doxyfile*, the RPM spec file references information that
    `configure` knows about the package. So, I wrote an *xflaim.spec.in* file, adding
    substitution variables where appropriate, and then added another file reference
    to the `AC_CONFIG_FILES` macro. This allows `configure` to substitute information
    about the project into the spec file. [Listing 15-15](ch15.xhtml#ch15ex15) shows
    the relevant portion of the *xflaim.spec.in* file in bold.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 RPM 包文件是通过一个配置文件完成的，这个配置文件叫做 *spec* 文件，它非常类似于用于为特定项目配置 Doxygen 的 *doxyfile*。与
    *doxyfile* 一样，RPM spec 文件引用了 `configure` 知道的包信息。因此，我编写了一个 *xflaim.spec.in* 文件，在适当的地方添加了替换变量，然后将另一个文件引用添加到
    `AC_CONFIG_FILES` 宏中。这使得 `configure` 可以将项目的信息替换到 spec 文件中。[清单 15-15](ch15.xhtml#ch15ex15)
    显示了 *xflaim.spec.in* 文件中的相关部分。
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 15-15*: x flaim/obs/xflaim.spec.in: *The portion of this file that
    illustrates using Autoconf variables*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-15*：x flaim/obs/xflaim.spec.in：*此文件中展示了如何使用 Autoconf 变量的部分*'
- en: Notice the use of the variables `@PACKAGE_TARNAME@` and `@PACKAGE_VERSION@`
    in this listing. Although the tar name is not likely to change much over the life
    of this project, the version will change often. Without the Autoconf substitution
    mechanism, I’d have to remember to update this version number whenever I updated
    the version in the *configure.ac* file. [Listing 15-16](ch15.xhtml#ch15ex16) shows
    the *xflaim/obs/Makefile.am* file, which actually does the work of building the
    RPMs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在这个清单中使用了变量 `@PACKAGE_TARNAME@` 和 `@PACKAGE_VERSION@`。虽然在这个项目的生命周期中，tar 文件名不太可能发生变化，但版本号会经常变化。如果没有
    Autoconf 替换机制，每当我更新 *configure.ac* 文件中的版本时，我必须记得更新这个版本号。[清单 15-16](ch15.xhtml#ch15ex16)
    展示了 *xflaim/obs/Makefile.am* 文件，它实际上完成了构建 RPM 的工作。
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 15-16*: xflaim/obs/Makefile.am: *The complete contents of this makefile*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-16*：xflaim/obs/Makefile.am：*该 makefile 的完整内容*'
- en: Building RPM packages is rather simple, as you can see. The targets provided
    by this makefile include `srcrpm` and `rpms`. The `rpmcheck` target at ➊ is used
    internally to verify that RPMs can be built in the end user’s environment.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 RPM 包非常简单，正如你所看到的。这个 makefile 提供的目标包括 `srcrpm` 和 `rpms`。➊ 处的 `rpmcheck` 目标在内部使用，用于验证
    RPM 是否可以在最终用户的环境中构建。
- en: In order to find out which targets in a lower-level *Makefile.am* file are supported
    by a top-level build, look at the top-level *Makefile.am* file. As [Listing 15-17](ch15.xhtml#ch15ex17)
    shows, if the target is not passed down, that target must be intended for internal
    use only, within the lower-level directory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要查明低级别 *Makefile.am* 文件中哪些目标被顶级构建支持，请查看顶级 *Makefile.am* 文件。如 [清单 15-17](ch15.xhtml#ch15ex17)
    所示，如果目标没有传递下来，那么该目标必须仅用于内部，在低级目录中。
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 15-17*: xflaim/Makefile.am: *If the target is not passed down, it’s
    an internal target.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-17*：xflaim/Makefile.am：*如果目标没有传递下来，它就是一个内部目标。*'
- en: As you can see from the command at ➊ in [Listing 15-17](ch15.xhtml#ch15ex17),
    when a user targets `rpms` or `srcrpm` from the top-level build directory, the
    commands are recursively passed down to *obs/Makefile*. The remaining commands
    simply remove droppings left behind by the RPM build process that are simpler
    to remove at this level. (Try building an RPM package sometime, and you’ll see
    what I mean!)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从[清单15-17](ch15.xhtml#ch15ex17)中➊处的命令可以看到，当用户从顶级构建目录中选择`rpms`或`srcrpm`时，命令会递归传递给*obs/Makefile*。其余的命令则只是删除RPM构建过程中留下的垃圾文件，这些垃圾文件在这一层次上更容易清除。（有机会构建一次RPM包，你就会明白我是什么意思！）
- en: Notice, too, that both of these top-level makefile targets depend on the `dist`
    target because the RPM build process requires the distribution tarball. Adding
    the tarball as a dependency of the `rpms` target simply ensures that the distribution
    tarball is there when the `rpmbuild` utility needs it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，这两个顶级makefile目标都依赖于`dist`目标，因为RPM构建过程需要分发的tarball。将tarball添加为`rpms`目标的依赖项，可以确保在`rpmbuild`工具需要它时，分发tarball已经存在。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: While using the Autotools, you have many details to manage—most of which, as
    they say in the open source software world, *can wait for the next release*! Even
    as I committed this code to the FLAIM project repository, I noticed details that
    could be improved. The takeaway lesson here is that a build system is never really
    finished. It should be incrementally improved over time, as you find time in your
    schedule to work on it. And it can be rewarding to do so.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Autotools时，你需要管理许多细节——大多数细节，如开源软件界所说，*可以等到下一次发布再处理*！即使我将这段代码提交到FLAIM项目的代码库时，我也注意到有一些细节是可以改进的。这里的关键教训是，构建系统永远不可能完成。它应该随着时间推移而逐步改进，利用你时间表中的空闲时间进行优化。而且，做到这一点是很有回报的。
- en: I’ve shown you a number of new features that have not been covered in earlier
    chapters, and there are many more features that I cannot begin to cover in this
    book. Study the Autotools manuals to become truly proficient. At this point, it
    should be pretty simple for you to pick up that additional information yourself.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经向你展示了许多本书前面章节没有涉及到的新特性，当然还有许多更多的特性是本书无法涵盖的。要真正精通，建议你阅读Autotools的手册。到现在为止，你应该能够轻松地自己去获取这些额外的信息。
