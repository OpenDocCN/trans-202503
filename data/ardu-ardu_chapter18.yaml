- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">18</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ARDUINO-TO-RS485
    COMMUNICATION</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">18</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ARDUINO-TO-RS485
    COMMUNICATION</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: In the previous chapter, you used the RS232 bus to create long, reliable wired
    data connections between Arduino microcontrollers and other devices. This chapter
    introduces the RS485 bus, which you can use for even longer wired connections.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你使用了 RS232 总线创建了 Arduino 微控制器与其他设备之间的长距离可靠有线数据连接。本章介绍了 RS485 总线，你可以使用它实现更长的有线连接。
- en: The RS485 data bus is used for a wide range of devices, from device controllers
    for heating, ventilation, and air conditioning (HVAC) systems to remote-sensor
    communications and security system networks. It requires a twin-core shielded
    wire. Depending on the data speed, your cable length can extend more than 800
    meters, and you can connect up to 256 devices on a single bus. This secure, interference-free
    communication between devices isn’t possible with wireless data modules. RS485
    modules are quite inexpensive, allowing you to easily use them in your own projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: RS485 数据总线广泛应用于各种设备，从供暖、通风和空调（HVAC）系统的设备控制器到远程传感器通信和安全系统网络。它需要使用双绞屏蔽线。根据数据传输速度，你的电缆长度可以超过
    800 米，并且可以在单一总线上连接多达 256 台设备。这种设备之间的安全、无干扰通信是无线数据模块无法实现的。RS485 模块价格非常低廉，使得你可以轻松地在自己的项目中使用它们。
- en: 'In this chapter, I’ll explain how to connect RS485 interface modules with Arduino.
    You’ll learn to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何将 RS485 接口模块与 Arduino 连接。你将学习：
- en: Send data from a remote Arduino to your PC via a circuit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过电路将数据从远程 Arduino 发送到你的 PC。
- en: Create a remote thermometer with LCD readout
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个带 LCD 显示的远程温度计
- en: Build remote-controlled Arduino projects with one primary controller and two
    or more secondary remote-controlled Arduinos
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个远程控制的 Arduino 项目，包含一个主要控制器和两个或更多的远程控制 Arduino。
- en: You can use these projects as a framework for your future Arduino-to-RS485 communication
    needs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些项目作为未来 Arduino 到 RS485 通信需求的框架。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The RS485 Bus</samp>
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">RS485 总线</samp>
- en: The RS485 data bus was designed to connect two or more data terminal equipment
    devices directly without needing modems over a longer distance than is possible
    with other data buses like the RS232\. It’s ideal for connecting two microcontroller-based
    devices that need to communicate with each other, as it’s more reliable than wireless
    data links and works over a much greater distance between units.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: RS485 数据总线旨在直接连接两个或多个数据终端设备，而无需通过调制解调器，连接距离比 RS232 等其他数据总线更长。它非常适合连接需要相互通信的两个基于微控制器的设备，因为它比无线数据链接更可靠，并且在设备之间的通信距离更长。
- en: Like RS232, RS485 is a serial data bus that operates in a similar manner to
    the Arduino’s serial port (usually found on pins D0 and D1). However, data doesn’t
    simply pass from the Arduino through an RS485 interface to the RS485-based device
    at the other end. The Arduino must tell the RS485 device whether it’s transmitting
    or receiving data before the data can move along the bus as required. The data
    then travels along the RS485 bus as required to another RS485 device, then to
    the attached Arduino.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与 RS232 类似，RS485 是一种串行数据总线，其工作方式与 Arduino 的串口（通常位于 D0 和 D1 引脚）类似。然而，数据并不会简单地从
    Arduino 通过 RS485 接口传输到另一端的 RS485 设备。Arduino 必须在数据传输前告诉 RS485 设备是发送数据还是接收数据，然后数据才能按照需要在总线上传输。数据随后按照要求沿
    RS485 总线传输到另一个 RS485 设备，再传输到连接的 Arduino。
- en: Although the RS485 bus sends sequential bits of data representing ones and zeros,
    the signal type differs from the TTL serial you’re used to with Arduino. For comparison,
    the image in [Figure 18-1](chapter18.xhtml#fig18-1) shows some data being sent
    from an Arduino’s serial port, as captured on an oscilloscope. As you can see,
    the ones are at 5 V and the zeros are at 0 V.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 RS485 总线发送的是表示 1 和 0 的顺序数据位，但其信号类型与 Arduino 中常见的 TTL 串行通信不同。为了比较，[图 18-1](chapter18.xhtml#fig18-1)
    显示了从 Arduino 串口发送的一些数据，捕捉到的波形图。正如你所看到的，1 的电平是 5 V，0 的电平是 0 V。
- en: '![AN IMAGE OF TTL LOGIC DATA CAPTURED FROM AN OSCILLOSCOPE](../images/fig18-1.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![TTL 逻辑数据通过示波器捕获的图像](../images/fig18-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-1: Data being sent
    from an Arduino serial port</samp>'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-1：从 Arduino 串口发送的数据</samp>
- en: Now consider the same piece of data being sent along RS485, as shown in [Figure
    18-2](chapter18.xhtml#fig18-2). RS485 uses two wires, A and B. When a 1 is sent,
    the A line has a voltage higher than the B line, and when a 0 is sent, the A line
    has a voltage lower than the B line. The voltages used can vary between −7 V and
    12 V DC or more, depending on the RS485 interface hardware used.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑通过 RS485 发送的相同数据，如 [图 18-2](chapter18.xhtml#fig18-2) 所示。RS485 使用两根线，A 和
    B。当发送 1 时，A 线的电压高于 B 线，当发送 0 时，A 线的电压低于 B 线。所使用的电压范围可以在 −7 V 到 12 V DC 或更高之间变化，具体取决于所使用的
    RS485 接口硬件。
- en: '![AN IMAGE OF RS485 LOGIC DATA CAPTURED FROM AN OSCILLOSCOPE](../images/fig18-2.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![通过示波器捕获的 RS485 逻辑数据图像](../images/fig18-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-2: Data being sent
    from an RS485 interface</samp>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-2：通过 RS485 接口发送的数据</samp>
- en: Using different voltages for ones and zeros over two wires enables clear definition
    of the two bits, removing chance of confusion and thus increasing data accuracy.
    Thanks to the wide voltage range, the length of the RS485 cable has less effect
    on the signal integrity, as there’s more scope for a change in signal voltage
    due to cable length (the longer the cable, the larger the voltage drop over the
    cable due to the resistance of wire). Combined with the use of shielded cable,
    this voltage range means you can use RS485 over much longer distances than other
    data buses, such as RS232.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的电压表示 1 和 0，通过两根导线可以清晰地区分这两个比特，消除了混淆的可能性，从而提高了数据的准确性。由于电压范围较宽，RS485 电缆的长度对信号完整性的影响较小，因为信号电压可以在电缆长度变化的范围内变化（电缆越长，因电缆电阻而导致的电压降越大）。结合使用屏蔽电缆，这个电压范围意味着你可以在比其他数据总线（如
    RS232）更长的距离上使用 RS485。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Connecting to RS485</samp>
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">连接到 RS485</samp>
- en: The basic RS485 interface board or module has a transmit terminal (called RO)
    and receive terminal (called DI) used for communication between the Arduino, along
    with power (usually 5V) and GND. An additional signal from the microcontroller
    to the RS485 interface, usually labeled DE/RE, indicates whether data will be
    received or transmitted. On some modules, DE and RE are separate pins which you
    must connect with one other. Finally, as described in the previous section, connection
    between the RS485 interfaces uses two wires, A and B. This allows for *half-duplex
    communication*, in which data travels in one direction at a time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 RS485 接口板或模块具有一个发送端子（称为 RO）和一个接收端子（称为 DI），用于 Arduino 之间的通信，还有电源（通常为 5V）和地线（GND）。从微控制器到
    RS485 接口的一个额外信号，通常标记为 DE/RE，用于指示数据是接收还是发送。在某些模块上，DE 和 RE 是两个独立的引脚，必须将它们连接在一起。最后，正如上一节所描述，RS485
    接口之间的连接使用两根线，A 和 B。这允许进行 *半双工通信*，即数据一次只能在一个方向上传输。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The RS485 bus also supports full-duplex communication over four wires, but
    describing this in detail is outside the scope of this book.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*RS485 总线还支持通过四根线进行全双工通信，但详细描述此内容超出了本书的范围。*'
- en: You can see all the pins clearly labeled on an inexpensive RS485 module, such
    as PMD Way part number 600197, shown in [Figure 18-3](chapter18.xhtml#fig18-3).
    These modules can be placed conveniently in solderless breadboards for experimenting
    or rapid prototyping. You’ll use them in projects throughout this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在廉价的 RS485 模块上清晰地看到所有引脚的标注，例如 [图 18-3](chapter18.xhtml#fig18-3) 中显示的 PMD
    Way 零件号 600197。这些模块可以方便地放置在无焊接面包板上进行实验或快速原型设计。在本章的项目中，你将使用这些模块。
- en: '![AN IMAGE OF THE RS485 INTERFACE MODULE](../images/fig18-3.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![RS485 接口模块图像](../images/fig18-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-3: An inexpensive
    RS485 interface module</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-3：一款廉价的 RS485 接口模块</samp>
- en: '[Figure 18-4](chapter18.xhtml#fig18-4) shows the schematic symbol used for
    these modules.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-4](chapter18.xhtml#fig18-4) 显示了这些模块使用的原理图符号。'
- en: The 5V and GND pins in the schematic connect to a power source. The A and B
    pins of the interface modules connect to other interface modules; A pins are connected
    to A pins, and B pins to B pins. The DI (data in) pin receives data from the Arduino
    and sends it out along RS485\. The R0 pin sends data received over RS485 to the
    Arduino. Finally, use the DE and RE pins in your circuits to set the interface
    module to transmit or receive data, setting them HIGH to transmit and LOW to receive
    data, as you’ll do in the following project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 原理图中的 5V 和 GND 引脚连接到电源。接口模块的 A 和 B 引脚连接到其他接口模块；A 引脚连接到 A 引脚，B 引脚连接到 B 引脚。DI（数据输入）引脚接收来自
    Arduino 的数据，并通过 RS485 发送出去。R0 引脚将通过 RS485 接收到的数据发送到 Arduino。最后，在电路中使用 DE 和 RE
    引脚设置接口模块为发送或接收模式，将它们设置为 HIGH 以发送数据，设置为 LOW 以接收数据，就像你将在接下来的项目中所做的那样。
- en: '![AN IMAGE OF THE RS485 INTERFACE MODULE SCHEMATIC SYMBOL](../images/fig18-4.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![RS485 接口模块原理图符号](../images/fig18-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-4: The RS485 interface
    module schematic symbol</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-4：RS485 接口模块原理图符号</samp>
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #51: Creating an Arduino-to-PC
    Data Link</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #51：创建 Arduino 到 PC 的数据链路</samp>'
- en: This project demonstrates how easy it is to send data from one Arduino, to another
    Arduino, to a PC with the RS485 bus. You can also use it to capture data to a
    PC from a remote Arduino.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目展示了如何通过 RS485 总线轻松地将数据从一个 Arduino 发送到另一个 Arduino，再到 PC。你也可以用它从远程 Arduino
    捕获数据到 PC。
- en: 'You’ll need the following parts:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下部件：
- en: Two Arduino Uno or compatible boards and one USB cable
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 Arduino Uno 或兼容板和一根 USB 电缆
- en: Two RS485 interface modules
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 RS485 接口模块
- en: Two solderless breadboards
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个免焊接面包板
- en: Assorted jumper wires
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: A suitable power supply for an Arduino Uno or compatible board
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合 Arduino Uno 或兼容板的电源
- en: A twin-core wire for a long-distance communication (optional)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根用于长距离通信的双绞线（可选）
- en: 'As with all the projects in this chapter, you’ll create two Arduino-to- RS485
    circuits: a receiver circuit and a transmitter circuit. The transmitter’s Arduino
    will send data to the receiver’s Arduino via RS485, and that data will then travel
    to the PC via the usual USB connection. You may find it easier to upload the receiver
    and transmitter sketches for this project to their respective Arduinos before
    constructing the circuits, as it is then easier to build out the circuits, especially
    over a distance.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的所有项目一样，你将创建两个 Arduino 到 RS485 的电路：一个接收器电路和一个发送器电路。发送器的 Arduino 将通过 RS485
    向接收器的 Arduino 发送数据，这些数据然后通过常规的 USB 连接传输到 PC。你可能会发现，在构建电路之前先将接收器和发送器的草图上传到各自的 Arduino
    会更容易，因为那样在构建电路时会更加方便，特别是当电路之间有较长距离时。
- en: If you want to run a long RS485 cable, use shielded twin-core cable and use
    the cable shield to connect the GND of the transmitter and receiver. However,
    you can also test this project with short hook-up wire.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用长的 RS485 电缆，请使用屏蔽双绞线，并利用电缆的屏蔽层将发送端和接收端的 GND 连接起来。不过，你也可以使用短接线来测试此项目。
- en: '[Figure 18-5](chapter18.xhtml#fig18-5) shows the schematic diagram for the
    receiver circuit.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-5](chapter18.xhtml#fig18-5) 显示了接收器电路的原理图。'
- en: '![AN IMAGE OF THE PROJECT #51 RECEIVER CIRCUIT SCHEMATIC](../images/fig18-5.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #51 接收器电路原理图](../images/fig18-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-5: The Project #51
    receiver circuit schematic</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-5：项目 #51 接收器电路原理图</samp>'
- en: '[Figure 18-6](chapter18.xhtml#fig18-6) shows the schematic diagram for the
    transmitter circuit.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-6](chapter18.xhtml#fig18-6) 显示了发送器电路的原理图。'
- en: '![AN IMAGE OF THE PROJECT #51 TRANSMITTER CIRCUIT SCHEMATIC](../images/fig18-6.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #51 发送器电路原理图](../images/fig18-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-6: The Project #51
    transmitter circuit schematic</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-6：项目 #51 发送器电路原理图</samp>'
- en: Once you’ve built the circuits and uploaded the sketches, connect the receiver
    unit to the PC via USB and open the Arduino’s Serial Monitor or terminal software
    such as CoolTerm (as first explained in [Chapter 14](chapter14.xhtml)). The terminal
    should display values for analog pin 0 on the transmitter circuit’s Arduino, as
    shown in [Figure 18-7](chapter18.xhtml#fig18-7).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建了电路并上传了草图，通过 USB 将接收单元连接到 PC，并打开 Arduino 的串行监视器或终端软件（如 CoolTerm，第一次在 [第
    14 章](chapter14.xhtml) 中解释）。终端应该显示发送器电路的 Arduino 上模拟引脚 0 的值，如 [图 18-7](chapter18.xhtml#fig18-7)
    所示。
- en: '![A SCREENSHOT OF THE RESULTS OF PROJECT #51 IN THE COOLTERM WINDOW](../images/fig18-7.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #51 在CoolTerm窗口中的结果截图](../images/fig18-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-7: Example output
    from Project #51</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-7：项目 #51的示例输出</samp>'
- en: 'Let’s see how this works, first taking a closer look at the sketch for the
    transmitter circuit:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的，首先仔细查看发射器电路的草图：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The sketch configures software serial to communicate with the RS485 interface
    modules using digital pins D4 and D3 ❶. It uses Arduino digital pin D2 to control
    the DE/RE pins that determine the data direction on the RS485 bus ❷. In <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch starts
    the software serial that will communicate with the RS485 module, then sets pin
    D2 to output to control the data direction on the RS485 module. It then sets the
    direction to transmit. Finally, in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>, the sketch continuously sends the example data in the form of the
    value for analog input 0 along the RS485 bus via software serial.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该草图配置软件串行以使用数字引脚D4和D3 ❶与RS485接口模块进行通信。它使用Arduino数字引脚D2来控制DE/RE引脚，这些引脚决定RS485总线上的数据方向
    ❷。在<samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>中，草图启动将与RS485模块通信的软件串行，然后设置D2引脚为输出，以控制RS485模块上的数据方向。然后，它将方向设置为发送。最后，在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>中，草图通过软件串行不断地将模拟输入0的值作为示例数据沿RS485总线发送。
- en: 'Now consider the receiver circuit sketch:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑接收电路的草图：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Configuration for the receiver sketch is identical to the transmitter sketch,
    except that the program sets the RS485 module to receive mode by setting digital
    pin D2 to LOW ❶. The Arduino then waits for a character of text to come from the
    RS485 bus via software serial. When a character arrives, the Arduino sends it
    to the attached computer via hardware serial and USB ❷. You can use this project
    to send any type of data generated by devices connected to an Arduino over an
    RS485 data link and back to a PC for recording.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器草图的配置与发射器草图相同，唯一不同的是程序通过将数字引脚D2设置为低电平 ❶来将RS485模块设置为接收模式。然后，Arduino等待通过软件串行从RS485总线接收到一个字符。当一个字符到达时，Arduino通过硬件串行和USB将其发送到连接的计算机
    ❷。您可以使用此项目通过RS485数据连接将由连接到Arduino的设备生成的任何类型的数据发送到PC进行记录。
- en: The next project demonstrates a way of viewing data received over an RS485 data
    link that is independent of using a computer for operation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个项目演示了一种查看通过RS485数据连接接收的数据的方法，且不依赖于计算机进行操作。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #52: Creating an Arduino-to-Arduino
    Data Link</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #52：创建Arduino与Arduino的数据连接</samp>'
- en: In this project, you’ll build an RS485 data link that sends temperature data
    from a BMP180 sensor over the bus, to be displayed using an I²C PCF8574 LCD module.
    Apart from being another good demonstration of using the RS485 data bus, this
    project serves as a framework for building remote real-time monitoring systems
    that don’t require a host computer at the receiving end, such as operating temperature,
    machine speed, or other sensor data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在此项目中，您将建立一个RS485数据连接，通过总线发送来自BMP180传感器的温度数据，并使用I²C PCF8574 LCD模块进行显示。除了作为使用RS485数据总线的另一个良好示范外，该项目还作为构建远程实时监控系统的框架，这些系统在接收端无需主机计算机，例如操作温度、机器速度或其他传感器数据。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*If you’re not familiar with I**²**C PCF8574 module LCDs, review their use
    as described in [Chapter 13](chapter13.xhtml). I also cover the BMP180 sensor
    in [Chapter 10](chapter10.xhtml).*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您不熟悉I**²**C PCF8574模块LCD，请参考[第13章](chapter13.xhtml)中描述的用法。我还在[第10章](chapter10.xhtml)中讲解了BMP180传感器。*'
- en: 'You’ll need the following parts for this project:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下零件来完成此项目：
- en: Two Arduino Uno or compatible boards and one USB cable
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个Arduino Uno或兼容板和一根USB电缆
- en: Two RS485 interface modules
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个RS485接口模块
- en: Two solderless breadboards
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个无焊面包板
- en: Assorted jumper wires
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: Two suitable power supplies for an Arduino Uno or compatible board
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个适合Arduino Uno或兼容板的电源供应器
- en: A PCF8574 LCD module
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个PCF8574 LCD模块
- en: A BMP180 temperature and air pressure sensor board
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个BMP180温度和气压传感器板
- en: A twin-core wire for a longer distance communication (optional)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根双芯电缆用于远距离通信（可选）
- en: You’ll again build two Arduino-to-RS485 circuits, a receiver and a transmitter.
    In this project, the transmitter’s Arduino will send temperature data to the receiver’s
    Arduino via RS485 to be displayed on the LCD. Again, you may find it easier to
    upload the two sketches for this project to their respective Arduinos before constructing
    the circuits.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你将再次构建两个 Arduino 至 RS485 电路，一个接收器和一个发送器。在这个项目中，发送器的 Arduino 将通过 RS485 向接收器的
    Arduino 发送温度数据，以在 LCD 上显示。同样，你可能会发现，在构建电路之前先将两个草图上传到各自的 Arduino 上会更容易。
- en: '[Figure 18-8](chapter18.xhtml#fig18-8) shows the schematic diagram for the
    receiver circuit.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-8](chapter18.xhtml#fig18-8) 显示了接收器电路的原理图。'
- en: '![AN IMAGE OF THE PROJECT #52 RECEIVER CIRCUIT SCHEMATIC](../images/fig18-8.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #52 接收器电路原理图](../images/fig18-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-8: The Project #52
    receiver circuit schematic</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-8: 项目 #52 接收器电路原理图</samp>'
- en: '[Figure 18-9](chapter18.xhtml#fig18-9) shows the schematic for the transmitter
    circuit.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-9](chapter18.xhtml#fig18-9) 显示了发送器电路的原理图。'
- en: '![AN IMAGE OF THE PROJECT #52 TRANSMITTER CIRCUIT SCHEMATIC](../images/fig18-9.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #52 发送器电路原理图](../images/fig18-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-9: The Project #52
    transmitter circuit schematic</samp>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-9: 项目 #52 发送器电路原理图</samp>'
- en: Once you have uploaded the sketches to their respective Arduino boards and the
    circuits are complete, power both circuits up. The current ambient temperature
    should appear on the LCD, as shown in [Figure 18-10](chapter18.xhtml#fig18-10).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将草图上传到各自的 Arduino 板并完成电路搭建，启动两个电路。当前的环境温度应该会显示在 LCD 上，如 [图18-10](chapter18.xhtml#fig18-10)
    所示。
- en: '![AN IMAGE OF THE PROJECT #52 LCD DISPLAYING: “TEMPERATURE: 28.10 CELSIUS](../images/fig18-10.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #52 LCD 显示: “温度: 28.10 摄氏度](../images/fig18-10.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-10: Example output
    from Project #52</samp>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 18-10: 项目 #52 示例输出</samp>'
- en: 'Let’s see how this works, first taking a closer look at the transmitter sketch:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个是如何工作的，首先仔细观察发送器的草图：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The sketch first includes the library required to use the BMP180 temperature
    sensor and creates the instance ❶. Again, the sketch configures software serial
    to communicate with the RS485 interface modules using digital pins D4 and D3 ❷.
    The sketch uses Arduino digital pin D2 to control the DE/RE pins that determine
    the data direction on the RS485 bus ❸.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 草图首先包含了使用 BMP180 温度传感器所需的库，并创建了实例 ❶。然后，草图配置软件串行通信，使用数字引脚 D4 和 D3 与 RS485 接口模块进行通信
    ❷。草图使用 Arduino 的数字引脚 D2 来控制 DE/RE 引脚，从而决定 RS485 总线上的数据方向 ❸。
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch
    starts the software serial that will communicate with the RS485 module, then sets
    pin D2 to output to control the data direction on the RS485 module. It then sets
    the direction to transmit and starts the BMP180 sensor. Finally, in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>, it sends temperature data from the BMP180 sensor every half a second
    along the RS485 bus via software serial.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> 中，程序启动软件串行通信，与
    RS485 模块进行通信，然后设置 D2 引脚为输出，以控制 RS485 模块上的数据方向。接着，它将方向设置为发送模式，并启动 BMP180 传感器。最后，在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp> 中，它通过软件串行通信每半秒将
    BMP180 传感器的温度数据通过 RS485 总线发送出去。
- en: 'Now consider the receiver circuit sketch:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来看一下接收器电路的草图：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since the receiver uses the PCF8574 I²C LCD, the required library for the I²C
    bus, the sketch includes the LCD display and instance ❶. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>, it starts the I²C bus and begins communication to the LCD in order
    to configure the LCD display size ❷, turn on the backlight ❸, and clear the display
    ❹. The sketch then includes the RS485 configuration for the receiver sketch. This
    is identical to that of the transmitter sketch, except that the sketch sets the
    RS485 module to receive mode by setting digital pin D2 to LOW.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接收器使用 PCF8574 I²C LCD，草图包含了 I²C 总线所需的库、LCD 显示和实例 ❶。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp> 中，它启动了 I²C 总线并开始与 LCD 通信，以配置 LCD 显示的尺寸 ❷，打开背光 ❸，并清空显示 ❹。然后，草图包含了接收器草图的
    RS485 配置。这与发送器草图完全相同，只是草图通过将数字引脚 D2 设置为 LOW，将 RS485 模块设置为接收模式。
- en: The Arduino waits for text to come from the RS485 bus via software serial ❺.
    Once the text arrives, the sketch converts it into a floating-point number using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">.parsefloat()</samp> function
    from the serial library. The temperature information is then displayed on the
    LCD ❻. The process repeats when more temperature data arrives from the transmitter
    circuit.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino通过软件串行口❺等待来自RS485总线的文本。一旦文本到达，示意图会使用串口库中的<samp class="SANS_TheSansMonoCd_W5Regular_11">.parsefloat()</samp>函数将其转换为浮点数。然后，温度信息会显示在LCD屏幕❻上。这个过程在接收到更多来自发射电路的温度数据时会重复。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #53: Remote Control Operation</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">项目#53：远程控制操作</samp>
- en: Since it supports longer cable runs, the RS485 bus also lends itself well to
    remote-control applications. This project demonstrates remote-control operation
    over RS485, in which one Arduino circuit (the primary) sends signals to another
    Arduino (the secondary) over RS485 to take various actions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RS485支持更长的电缆连接，它也非常适合远程控制应用。这个项目展示了通过RS485进行远程控制操作，其中一个Arduino电路（主电路）通过RS485向另一个Arduino电路（次级电路）发送信号，以执行各种操作。
- en: 'You’ll need the following parts for this project:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下零件来完成这个项目：
- en: Two Arduino Uno or compatible boards and one USB cable
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个Arduino Uno或兼容板和一根USB电缆
- en: Two RS485 interface modules
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个RS485接口模块
- en: Two solderless breadboards
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两块无焊接面包板
- en: Assorted jumper wires
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: Two suitable power supplies for an Arduino Uno or compatible board
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个适用于Arduino Uno或兼容板的电源
- en: A twin-core wire for a longer distance communication (optional)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根双芯电缆，用于更长距离的通信（可选）
- en: In this project, the primary Arduino sends single characters to the secondary
    Arduino via RS485\. You’ll program the secondary Arduino to take various actions
    depending on the character received; if an unknown command is received, a default
    action will occur. Again, you may find it easier to upload the sketches to each
    Arduino before constructing the circuits.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，主Arduino通过RS485向次级Arduino发送单个字符。你将编程次级Arduino，根据接收到的字符执行各种操作；如果接收到未知命令，将执行默认操作。同样，你可能会发现，在构建电路之前，将示意图上传到每个Arduino会更容易一些。
- en: '[Figure 18-11](chapter18.xhtml#fig18-11) shows the schematic diagram for the
    primary circuit.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-11](chapter18.xhtml#fig18-11)展示了主电路的原理图。'
- en: '![AN IMAGE OF THE PROJECT #53 PRIMARY CIRCUIT SCHEMATIC](../images/fig18-11.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![项目#53主电路原理图](../images/fig18-11.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-11: The Project #53
    primary circuit schematic</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图18-11：项目#53主电路原理图</samp>
- en: '[Figure 18-12](chapter18.xhtml#fig18-12) shows the schematic diagram for the
    secondary circuit.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-12](chapter18.xhtml#fig18-12)展示了次级电路的原理图。'
- en: '![AN IMAGE OF THE PROJECT #53 SECONDARY CIRCUIT SCHEMATIC](../images/fig18-12.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![项目#53次级电路原理图](../images/fig18-12.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-12: The Project #53
    secondary circuit schematic</samp>'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图18-12：项目#53次级电路原理图</samp>
- en: Once you have uploaded the project sketches to their respective Arduino boards
    and built the circuits, power them both up. The primary Arduino should start sending
    commands to the secondary, which will act on those commands by blinking the Arduino’s
    onboard LED in various sequences.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将项目示意图上传到各自的Arduino板并搭建好电路，启动电源。主Arduino应开始向次级Arduino发送命令，次级Arduino将通过各种顺序闪烁其板载LED灯来响应这些命令。
- en: 'Let’s see how this works, first examining the sketch for the primary circuit:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个是如何工作的，首先查看主电路的示意图：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This sketch configures the primary circuit to transmit over RS485, as did previous
    projects. The point of difference is the example commands sent in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>. The secondary Arduino is configured to act upon the commands 0,
    1, 2, and 3, so the primary sketch sends those commands as a demonstration. It
    also sends the number 8 to demonstrate the function on the receiver which deals
    with unknown commands. Each command is sent in turn with a delay between each.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此示意图配置了主电路，通过RS485进行传输，就像以前的项目一样。不同之处在于在<samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>中发送的示例命令。次级Arduino被配置为响应命令0、1、2和3，因此主示意图会按顺序发送这些命令作为演示。它还发送数字8来展示接收方处理未知命令的功能。每个命令依次发送，每个命令之间有延迟。
- en: 'Here’s the sketch for the secondary circuit:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是次级电路的示意图：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The secondary circuit is configured to receive commands over RS485 then act
    based on those commands. To demonstrate this, the sketch uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp>
    function, which accepts an integer and blinks the onboard LED that number of times.
    The secondary circuit awaits a character of text (the command) from the RS485
    bus via the software serial port ❶. The secondary unit uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    function ❷ to determine which function to call, depending on the command received
    from the primary unit. If it receives a command that isn’t covered in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp> function, it blinks
    the LED twice ❸.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从属电路配置为通过RS485接收命令，然后根据这些命令执行操作。为了演示这一点，草图使用了<sup class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</sup>函数，该函数接受一个整数并使板载LED闪烁该次数。从属电路通过软件串口
    ❶等待来自RS485总线的一个文本字符（命令）。从属单元使用<sup class="SANS_TheSansMonoCd_W5Regular_11">switch…case</sup>函数
    ❷来确定根据从主单元接收到的命令调用哪个函数。如果它收到的命令不在<sup class="SANS_TheSansMonoCd_W5Regular_11">switch…case</sup>函数中，它会让LED闪烁两次
    ❸。
- en: You can modify this project for your own remote-control needs by replacing the
    calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp> function
    with your own actionable requirements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将对<sup class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</sup>函数的调用替换为你自己的可操作需求，修改此项目以满足你自己的远程控制需求。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Controlling Two or More Secondary RS485
    Devices</samp>
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">控制两个或更多从属RS485设备</samp>
- en: So far, you’ve learned how to communicate between two RS485-connected Arduino
    boards. As mentioned earlier, however, you can control more than one secondary
    device with the RS485 bus, up to 256 devices in total. In this section and the
    following project, I’ll show you how to do so.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何在两块RS485连接的Arduino板之间进行通信。然而，如前所述，你可以通过RS485总线控制多个从设备，最多可以连接256个设备。在本节以及接下来的项目中，我将向你展示如何做到这一点。
- en: The wiring of the RS485 bus is slightly different when using three or more devices.
    The transceiver IC found on the modules you’ve been using also requires a 120
    Ω terminating resistor across the A and B wires at each end of the RS485 bus.
    This resistor is fitted with the required terminating resistor, so if you’re just
    using the two modules, you don’t need to change anything. If you’re using three
    or more of the RS485 modules covered in this chapter, though, you’ll need to desolder
    the terminating resistor labeled R7 on the PCB (with the value 121 on the resistor,
    which is interpreted as 12 Ω, with a 0 added on the end for 120 Ω) from the module.
    This resistor is circled in [Figure 18-13](chapter18.xhtml#fig18-13).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用三个或更多设备时，RS485总线的布线稍有不同。你一直在使用的模块上的收发器IC还需要在RS485总线的每个端点，A和B线之间添加一个120 Ω的终端电阻。如果你只使用两个模块，那么终端电阻已经装配好，你不需要做任何更改。然而，如果你使用本章中介绍的三个或更多RS485模块，你需要从模块上拆下标有R7的终端电阻（电阻值为121，解释为12
    Ω，末尾加上0变为120 Ω）。这个电阻在[图18-13](chapter18.xhtml#fig18-13)中已圈出。
- en: '![AN IMAGE OF THE TERMINATING RESISTOR ON THE RS485 MODULE](../images/fig18-13.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![RS485模块上的终端电阻图像](../images/fig18-13.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-13: An RS485 terminating
    resistor</samp>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图18-13：一个RS485终端电阻</samp>
- en: When wiring your devices over distances longer than that used for demonstration
    on your workbench, ensure the A/B pair of wires travel from device to device in
    a “daisy-chain” configuration, as shown in [Figure 18-14](chapter18.xhtml#fig18-14).
    Don’t create a separate run from each device back to a main A/B pair.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的设备连接距离超过演示中工作台上的距离时，确保A/B对的线缆以“菊花链”配置从一个设备延伸到另一个设备，如[图18-14](chapter18.xhtml#fig18-14)所示。不要为每个设备创建一条从设备到主A/B对的单独线路。
- en: '![AN EXAMPLE OF THE RS485 WIRING CONFIGURATION FOR THREE DEVICES](../images/fig18-14.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![三个设备的RS485布线配置示例](../images/fig18-14.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-14: Example RS485
    wiring configuration for three devices</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图18-14：三个设备的RS485布线配置示例</samp>
- en: You’ll put this technique to work in the next project.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一个项目中实际应用这个技术。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #54: Controlling Two or More
    Secondary Arduino Boards</samp>'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #54：控制两个或更多从属Arduino板</samp>'
- en: This project demonstrates controlling two or more secondary Arduino boards over
    RS485 from one primary board. One Arduino circuit (the primary) will send commands
    to other Arduinos (the secondary devices) over RS485, telling them to take various
    actions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目演示了如何通过RS485从一个主板控制两个或更多的从Arduino板。一个Arduino电路（主设备）会通过RS485向其他Arduino（从设备）发送命令，指示它们执行各种操作。
- en: 'The hardware for this project is the same as that used in Project #53, except
    that you’ll use two or more secondary devices. Start by building one primary device
    and two secondary devices, connecting them via the RS485 bus as shown in [Figure
    18-14](chapter18.xhtml#fig18-14) in the previous section. Again, it’s a good idea
    to upload the sketches to each Arduino before building the circuits. You can add
    more secondary devices to the project later, if you like, once you’ve got your
    three-device setup working.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的硬件与第53号项目中使用的相同，只是你将使用两个或更多的从设备。首先搭建一个主设备和两个从设备，通过RS485总线将它们连接起来，正如上一节中[图18-14](chapter18.xhtml#fig18-14)所示。同样，在搭建电路之前，最好先将草图上传到每个Arduino。如果你喜欢，可以在三设备设置成功后，稍后再向项目中添加更多的从设备。
- en: If you’re just testing this project on your workbench, the distance of the RS485
    bus will be short enough that you may not need to remove the terminating resistors
    from the RS485 modules, so test the code before making any changes to your hardware.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是测试这个项目在工作台上的表现，RS485总线的距离足够短，你可能不需要从RS485模块中移除终端电阻，因此在对硬件做出任何更改之前，先测试代码。
- en: In this project, the primary board sends a three-digit number across the RS485
    bus, which is received by all the secondary boards. The first digit of the command
    represents the number of the secondary unit to control (units 1 through 9), and
    the final 2 digits represent the command being sent to the specific secondary
    unit. For example, to send command 12 to secondary unit 2, the primary would send
    212 across the RS485 bus, since the sketch loaded onto the second secondary unit
    is programmed to act based on receiving 12\. If you add 10 or more secondary units,
    you can change the commands in the sketch so they send four-digit numbers, or
    modify the command coding method for your own needs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，主板通过RS485总线发送一个三位数字，所有从板都会接收到这个数字。命令的第一位表示要控制的从设备的编号（从设备1到9），最后两位表示发送给特定从设备的命令。例如，要向从设备2发送命令12，主设备会通过RS485总线发送212，因为加载到第二个从设备的草图被编程为根据接收12来执行动作。如果你添加了10个或更多从设备，你可以更改草图中的命令，以便它们发送四位数字，或根据自己的需求修改命令编码方式。
- en: This project is just a demonstration of multiple-secondary-device control over
    RS485\. In its current form, each command sent from the primary will trigger the
    matching secondary device to blink its onboard LED a certain number of times.
    However, in your own future projects, you can replace the simple example actions
    in the secondary units with your own requirements.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目只是一个通过RS485控制多个从设备的演示。在当前形式下，从主设备发送的每个命令都会触发对应从设备的LED闪烁特定次数。然而，在你未来的项目中，你可以用你自己的需求替换从设备中的简单示例动作。
- en: 'Let’s see how this works in the sketches, starting with the primary device
    sketch:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个在草图中是如何工作的，从主设备的草图开始：
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In a sequence that should be familiar to you by now, the sketch first configures
    the primary unit to send data to the RS485 bus. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>, it sends two new example commands: 105 ❶, which is command 5 for
    the secondary unit 1, and 205 ❷, which is command 5 for secondary unit 2\. Remember
    that the commands are three digits, with the first being the secondary unit to
    address, and the following two digits (00 to 99) being the actual command.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在你现在应该已经熟悉的序列中，草图首先配置主设备以将数据发送到RS485总线。在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp> 中，它发送两个新的示例命令：105 ❶，这是给从设备1的命令5，以及205 ❷，这是给从设备2的命令5。记住，命令是三位数字，第一位表示目标从设备的编号，后两位（00到99）表示实际的命令。
- en: 'The following is the sketch for secondary device 1:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从设备1的草图：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This sketch is configured so that commands received from the primary unit call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp> function with
    a varying parameter to blink the LED a different number of times. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>, the secondary awaits an incoming integer from the RS485 bus ❶.
    It then checks whether the received integer falls between 100 and 199 inclusive
    ❷. If so, meaning the command is intended for this unit, the sketch compares the
    integer against the preset commands using the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    function. For example, if the command 105 is received, the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp>
    function is called to blink the onboard LED five times ❸. If a command is received
    but not recognized ❹, the LED blinks twice.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该草图配置为，当接收到来自主单元的命令时，会调用<samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp>函数，并传递一个变化的参数来使LED闪烁不同次数。在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>中，次级设备等待来自RS485总线的整数输入❶。然后，它检查接收到的整数是否在100到199之间（包括100和199）❷。如果是，表示该命令是为该单元发出的，草图会使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>函数将该整数与预设的命令进行比较。例如，如果收到命令105，调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp>函数使板载LED闪烁五次❸。如果接收到的命令无法识别❹，LED闪烁两次。
- en: 'The first part of the sketch for secondary device 2 is the same as for secondary
    device 1\. Only the <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>
    section of the sketch differs:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 次级设备2的草图的第一部分与次级设备1相同。只有草图中的<samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>部分有所不同：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The sketch tests the received command to see whether it falls between 200 and
    299 inclusive ❶, as the first digit of the command (2) notes the command is for
    this secondary unit. If the command is for this unit, the sketch compares it against
    the preset commands using the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    function. For example, if the device receives the command 205, the sketch calls
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp> function to
    blink the onboard LED five times ❷. If a command is received but not recognized
    ❸, the LED blinks twice.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该草图测试接收到的命令，检查它是否在200到299之间（包括200和299）❶，因为命令的第一位数字（2）表示该命令是为该次级单元发出的。如果该命令是为此单元发出的，草图会使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>函数将其与预设的命令进行比较。例如，如果设备收到命令205，草图会调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">blinkLED()</samp>函数使板载LED闪烁五次❷。如果接收到的命令无法识别❸，LED闪烁两次。
- en: To add additional secondary units, you’d simply change the test line ❶ so the
    new unit can check whether a command from the primary device falls within its
    required numeric range. You’d also need to add the appropriate commands and required
    actions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加额外的次级单元，您只需修改测试行❶，以便新单元能够检查主设备发出的命令是否在其要求的数字范围内。您还需要在<samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>函数中添加相应的命令和所需的操作。
- en: For a challenge, you might try creating a system that returns data from the
    secondary devices back to the primary device.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加挑战，您可以尝试创建一个系统，将来自次级设备的数据返回给主设备。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">继续前进</samp>
- en: This chapter has given you the basic building blocks for implementing the RS485
    data bus with Arduino. You can use this knowledge to make your own data transfer
    and control applications over longer distances, such as monitoring sensors or
    controlling devices in other rooms in an office or factory.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已为您提供了使用Arduino实现RS485数据总线的基本构建模块。您可以利用这些知识，制作自己的数据传输和控制应用，支持远距离操作，例如监控传感器或控制办公室或工厂内其他房间的设备。
- en: In the next chapter, you’ll get started with popular Wi-Fi-capable Arduino-compatible
    boards to make remote-control devices that can be controlled from a cell phone
    or any web-enabled device.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将开始使用流行的支持Wi-Fi的Arduino兼容板，制作可以从手机或任何网络设备远程控制的设备。
