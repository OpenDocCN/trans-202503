- en: '**17'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**17**'
- en: HOW UEFI SECURE BOOT WORKS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**UEFI安全启动如何工作**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: In previous chapters, we talked about the introduction of the Kernel-Mode Code
    Signing Policy, which encouraged malware developers to shift from using rootkits
    to using bootkits, moving the attack vector from the OS kernel to unprotected
    boot components. This kind of malware executes before the OS loads, so it’s able
    to bypass or disable OS security mechanisms. In order to enforce security and
    ensure safety, then, the OS must be able to boot into a trusted environment whose
    components have not been tampered with.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了内核模式代码签名策略的引入，它鼓励恶意软件开发者从使用根套件转向使用引导套件，将攻击向量从操作系统内核转移到未受保护的引导组件。这种恶意软件在操作系统加载之前执行，因此能够绕过或禁用操作系统的安全机制。为了强制执行安全性并确保安全性，操作系统必须能够启动到一个受信任的环境中，其中的组件未被篡改。
- en: This is where UEFI Secure Boot technology, the subject of this chapter, comes
    into play. Aimed primarily at protecting the platform’s boot components against
    modification and ensuring that only trusted modules are loaded and executed at
    bootup, UEFI Secure Boot can be an effective solution to bootkit threats—as long
    as it covers all angles of attack.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是UEFI安全启动技术发挥作用的地方，本章的主题。UEFI安全启动主要旨在保护平台的引导组件免受修改，并确保只有受信任的模块在启动时加载和执行。只要它覆盖所有攻击角度，UEFI安全启动可以有效应对引导套件威胁。
- en: However, the protections offered by UEFI Secure Boot are vulnerable to *firmware
    rootkits*, the newest and fastest-growing malware technology. As a result, you
    need another layer of security to cover the entire boot process from the very
    beginning. You can achieve this with an implementation of Secure Boot called *Verified
    and Measured Boot*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，UEFI安全启动提供的保护容易受到*固件根套件*的威胁，后者是最新且增长最快的恶意软件技术。因此，你需要额外的安全层来覆盖整个引导过程的开始。你可以通过一种名为*验证和测量启动*的安全启动实现来做到这一点。
- en: This chapter introduces you to the core of this security technology, first describing
    how it can protect against firmware rootkits when anchored into hardware and then
    discussing its implementation details and how it protects victims against bootkits.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍这项安全技术的核心，首先描述它如何在嵌入到硬件中时保护免受固件根套件的攻击，然后讨论其实现细节以及它如何保护受害者免受引导套件的攻击。
- en: As often happens in the security industry, though, very few security solutions
    can provide an ultimate protection against attacks; the attackers and defenders
    are locked in an eternal arms race. We’ll close the chapter by discussing the
    flaws of UEFI Secure Boot, ways to bypass it, and how to protect it using two
    versions of Verified and Measured Boot from Intel and ARM.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如安全行业中常见的那样，极少有安全解决方案能够提供对攻击的终极保护；攻击者和防御者在一场永恒的军备竞赛中相互博弈。我们将在本章结束时讨论UEFI安全启动的缺陷、绕过方法以及如何使用英特尔和ARM的两个版本的验证和测量启动来保护它。
- en: '**What Is Secure Boot?**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是安全启动？**'
- en: The main purpose of Secure Boot is to prevent anyone from executing unauthorized
    code in the preboot environment; thus, only code that meets the platform’s integrity
    policy is allowed to execute. This technology is very important for high-assurance
    platforms, and it’s also frequently used on embedded devices and mobile platforms,
    as it allows vendors to restrict platforms to vendor-approved software, such as
    iOS on iPhones or the Windows 10 S operating system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动的主要目的是防止任何人在引导环境中执行未经授权的代码；因此，只有符合平台完整性策略的代码才能执行。这项技术对高安全保障平台非常重要，也常用于嵌入式设备和移动平台，因为它允许供应商限制平台只能运行经过供应商批准的软件，例如iPhone上的iOS或Windows
    10 S操作系统。
- en: 'Secure Boot comes in three forms, which depend on the level of the boot process
    hierarchy at which it’s enforced:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动有三种形式，具体取决于在哪个引导过程层次上执行：
- en: '**OS Secure Boot** Implemented at the level of the OS bootloader. This verifies
    components loaded by the OS bootloader, such as the OS kernel and boot-start drivers.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作系统安全启动** 在操作系统引导加载程序层面实现。它验证操作系统引导加载程序加载的组件，例如操作系统内核和引导启动驱动程序。'
- en: '**UEFI Secure Boot** Implemented in UEFI firmware. This verifies UEFI DXE drivers
    and applications, Option ROMs, and OS bootloaders.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**UEFI安全启动** 实现于UEFI固件中。它验证UEFI DXE驱动程序和应用程序、选项ROM以及操作系统引导加载程序。'
- en: '**Platform Secure Boot (Verified and Measured Secure Boot)** Anchored in the
    hardware. This verifies platform initialization firmware.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**平台安全启动（验证和测量安全启动）** 锚定在硬件中。它验证平台初始化固件。'
- en: We discussed OS Secure Boot in [Chapter 6](ch06.xhtml#ch06), so in this chapter
    we focus on UEFI Secure Boot and Verified and Measured Boot.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第6章](ch06.xhtml#ch06)中讨论了操作系统安全启动，因此在本章中我们将重点讨论UEFI安全启动以及验证启动和度量启动。
- en: '**UEFI Secure Boot Implementation Details**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**UEFI安全启动实现细节**'
- en: We’ll start this discussion with how UEFI Secure Boot works. First, it’s important
    to note that UEFI Secure Boot is a part of the UEFI specification, which you can
    find at *[http://www.uefi.org/sites/default/files/resources/UEFI_Spec_2_7.pdf](http://www.uefi.org/sites/default/files/resources/UEFI_Spec_2_7.pdf)*.
    We’ll be referring to the specification—in other words, the description of how
    UEFI Secure Boot is *supposed* to work—though different platform manufacturers
    may have different implementation details.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从UEFI安全启动的工作原理开始讨论。首先，重要的是要注意，UEFI安全启动是UEFI规范的一部分，你可以在*[http://www.uefi.org/sites/default/files/resources/UEFI_Spec_2_7.pdf](http://www.uefi.org/sites/default/files/resources/UEFI_Spec_2_7.pdf)*找到这份规范。我们将参考该规范——换句话说，描述UEFI安全启动*应该*如何工作的内容——尽管不同的平台制造商可能有不同的实现细节。
- en: '**NOTE**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When we refer to “Secure Boot” from now on in this section, we’re talking
    about UEFI Secure Boot unless otherwise mentioned.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*当我们在本节中提到“安全启动”时，除非另有说明，我们指的是UEFI安全启动。*'
- en: We’ll begin by looking at the boot sequence to see where Secure Boot comes into
    play. Then, we’ll look at how Secure Boot authenticates executables and discuss
    the databases involved.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看启动序列，了解“安全启动”在其中的作用。然后，我们将讨论“安全启动”如何认证可执行文件，并讨论涉及的数据库。
- en: '***The Boot Sequence***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动序列***'
- en: Let’s quickly review the UEFI boot sequence described in [Chapter 14](ch14.xhtml#ch14)
    to see where Secure Boot comes into the process. If you skipped that chapter,
    it’s worth visiting it now.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下在[第14章](ch14.xhtml#ch14)中描述的UEFI启动序列，看看“安全启动”在这个过程中出现的位置。如果你跳过了这一章，现在回去看看是值得的。
- en: 'If you refer back to “[How UEFI Firmware Works](ch14.xhtml#ch14lev1sec4)” on
    [page 242](ch14.xhtml#page_242), you’ll see that the first piece of code executed
    when a system comes out of reset is the platform initialization (PI) firmware,
    which performs basic initialization of the platform hardware. When the PI is executed,
    the chipset and memory controller are still in an uninitialized state: no DRAM
    is available for the firmware yet, and peripheral devices on the PCIe bus have
    not yet been enumerated. (The *PCIe bus* is a high-speed serial bus standard used
    on virtually all modern PCs; we’ll discuss it more in later chapters.) At this
    point, Secure Boot isn’t yet active, meaning the PI part of the system’s firmware
    isn’t protected at this point.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到[第242页](ch14.xhtml#page_242)的“[UEFI固件如何工作](ch14.xhtml#ch14lev1sec4)”一节，你会看到系统从复位状态启动时，执行的第一段代码是平台初始化（PI）固件，它执行平台硬件的基本初始化。当PI执行时，芯片组和内存控制器仍处于未初始化状态：此时固件还无法访问DRAM，PCIe总线上的外设设备尚未被枚举。（*PCIe总线*是一种高速串行总线标准，几乎用于所有现代PC；我们将在后续章节中进一步讨论。）此时，“安全启动”尚未激活，这意味着系统固件的PI部分在此时并没有受到保护。
- en: Once the PI firmware discovers and configures RAM and performs the basic platform
    initialization, it proceeds to load the DXE drivers and UEFI applications, which
    in turn continue to initialize the platform hardware. This is when Secure Boot
    comes into play. Anchored in the PI firmware, Secure Boot is used to authenticate
    the UEFI modules loaded from the SPI (Serial Peripheral Interface) flash or Option
    ROMs of peripheral devices.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦PI固件发现并配置了RAM，并完成了平台硬件的基本初始化，它将继续加载DXE驱动程序和UEFI应用程序，后者继续初始化平台硬件。这时，“安全启动”开始发挥作用。作为PI固件的一部分，“安全启动”用于验证从SPI（串行外设接口）闪存或外设设备的选项ROM中加载的UEFI模块。
- en: The authentication mechanism used in Secure Boot is, in essence, a digital signature
    verification process. Only properly authenticated images are allowed to execute.
    Secure Boot relies on a *public key infrastructure (PKI)* to manage signature
    verification keys.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “安全启动”中使用的认证机制本质上是一个数字签名验证过程。只有经过正确认证的映像才被允许执行。“安全启动”依赖于*公钥基础设施（PKI）*来管理签名验证密钥。
- en: Explained simply, a Secure Boot implementation contains a public key that is
    used to verify the digital signature of executable images loaded at boot. The
    images should have an embedded digital signature, although, as you’ll see later
    in this chapter, there are some exceptions to this rule. If an image passes verification,
    it is loaded and eventually executed. If an image does not have a signature and
    verification fails, it will trigger remediation behavior—actions executed in cases
    when Secure Boot fails. Depending on the policy, the system can continue booting
    normally or abort the boot process and display an error message to the user.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，安全启动实现包含一个公钥，用于验证启动时加载的可执行映像的数字签名。映像应该包含嵌入的数字签名，尽管正如你将在本章稍后看到的那样，某些情况下此规则有例外。如果映像通过验证，它将被加载并最终执行。如果映像没有签名并且验证失败，则会触发修复行为——当安全启动失败时执行的操作。根据策略，系统可以继续正常启动，也可以中止启动过程并向用户显示错误信息。
- en: Actual implementations of Secure Boot are a bit more complicated than we’ve
    described here. To properly establish trust in the code that’s executed during
    boot, Secure Boot uses different types of signature databases, keys, and policies.
    Let’s take a look at these factors one by one and dig into the details.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动的实际实现比我们在这里描述的要复杂一些。为了正确建立启动过程中执行的代码的信任，安全启动使用不同类型的签名数据库、密钥和策略。让我们逐一看一下这些因素，并深入了解其细节。
- en: '**REAL-WORLD IMPLEMENTATIONS: TRADEOFFS**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**实际世界的实现：权衡**'
- en: In real implementations of UEFI firmware, platform manufacturers often compromise
    between security and performance. Checking the digital signature of every UEFI
    image requesting execution takes time. On an average modern platform, there may
    be a few hundred UEFI images trying to load, so verifying the digital signature
    of every single executable would prolong the boot process. At the same time, manufacturers
    are under pressure to reduce boot time, especially in embedded systems and in
    the automotive industry. Instead of verifying every UEFI image, firmware vendors
    often choose to verify UEFI images with hashes to increase performance. The set
    of hashes for allowed images is located in a storage solution, the integrity and
    authenticity of which is ensured only once, via digital signature, when the storage
    is accessed. We’ll discuss these hashes in more detail later in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的UEFI固件实现中，平台制造商通常在安全性和性能之间做出妥协。检查每个请求执行的UEFI映像的数字签名需要时间。在现代平台上，可能有几百个UEFI映像试图加载，因此验证每个可执行文件的数字签名会延长启动过程。同时，制造商面临着缩短启动时间的压力，特别是在嵌入式系统和汽车行业中。固件供应商通常选择通过哈希值来验证UEFI映像，以提高性能，而不是验证每个UEFI映像。允许的映像的哈希集存储在一个存储解决方案中，该存储解决方案的完整性和真实性仅在访问存储时通过数字签名确保。我们将在本章稍后详细讨论这些哈希值。
- en: '***Executable Authentication with Digital Signatures***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用数字签名进行可执行文件认证***'
- en: As a first step toward understanding Secure Boot, let’s take a look at how UEFI
    executables are actually signed—that is, where the digital signature is located
    in an executable file and what kinds of signatures Secure Boot supports.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为理解安全启动的第一步，让我们看看UEFI可执行文件是如何被签名的——即数字签名位于可执行文件的哪个位置，以及安全启动支持哪些类型的签名。
- en: For UEFI executable files that are Portable Executable (PE) images, the digital
    signatures are contained in special data structures called *signature certificates*.
    The location of these certificates in the binary is determined by a special field
    of the PE header data structure called the *Certificate Table Data Directory*,
    illustrated in [Figure 17-1](ch17.xhtml#ch17fig01). It’s worth mentioning that
    there may be multiple digital signatures for a single file, generated using different
    signing keys for different purposes. By looking at this field, the UEFI firmware
    can locate the signature information used to authenticate the executable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于作为可移植可执行（PE）映像的UEFI可执行文件，数字签名包含在一种特殊的数据结构中，称为*签名证书*。这些证书在二进制文件中的位置由PE头数据结构中的一个特殊字段确定，称为*证书表数据目录*，如[图17-1](ch17.xhtml#ch17fig01)所示。值得一提的是，单个文件可能有多个数字签名，这些签名使用不同的签名密钥生成，目的是用于不同的用途。通过查看这个字段，UEFI固件可以找到用于验证可执行文件的签名信息。
- en: '![image](../images/17fig01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig01.jpg)'
- en: '*Figure 17-1: Location of digital signatures in UEFI images*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-1：UEFI映像中数字签名的位置*'
- en: Other types of UEFI executable images, such as *Terse Executable (TE)* images,
    don’t have embedded digital signatures due to the specifics of their executable
    format. The TE image format was derived from the PE/COFF format in an attempt
    to reduce the TE’s size so that it would take up less space. Thus, TE images contain
    only the fields of the PE format that are necessary to execute an image in a PI
    environment, which means they don’t contain fields like the Certificate Table
    Data Directory. As a result, UEFI firmware can’t directly authenticate such images
    by verifying their digital signature. However, Secure Boot provides capabilities
    for authenticating these images using cryptographic hashes, a mechanism that is
    described in more detail in the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的 UEFI 可执行镜像，如 *简洁可执行文件（TE）* 镜像，由于其可执行格式的特点，未嵌入数字签名。TE 镜像格式源自 PE/COFF 格式，旨在减少
    TE 的大小，使其占用更少的空间。因此，TE 镜像仅包含 PE 格式中执行镜像所需的字段，这意味着它们不包含诸如证书表数据目录之类的字段。因此，UEFI 固件无法通过验证数字签名直接对这些镜像进行认证。然而，安全启动提供了通过加密散列来认证这些镜像的功能，下一节将详细描述这一机制。
- en: The layout of an embedded signature certificate depends on its type. We won’t
    get into layout specifics here, but you can learn more in “[Location of Driver
    Signatures](ch06.xhtml#ch06lev2sec4)” on [page 73](ch06.xhtml#page_73).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式签名证书的布局取决于其类型。我们在此不深入讨论布局的具体细节，但你可以在[第73页](ch06.xhtml#page_73)的“[驱动程序签名的位置](ch06.xhtml#ch06lev2sec4)”中了解更多。
- en: 'Every type of signature certificate used in Secure Boot contains the following
    at a minimum: information on the cryptographic algorithms used for signature generation
    and verification (for instance, cryptographic hash functions and digital signature
    algorithm identifiers), a cryptographic hash of the executable in question, the
    actual digital signature, and the public key used to verify the digital signature.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每种用于安全启动的签名证书至少包含以下内容：用于签名生成和验证的加密算法信息（例如，密码散列函数和数字签名算法标识符）、目标可执行文件的加密散列、实际的数字签名，以及用于验证数字签名的公钥。
- en: This information is sufficient for Secure Boot to verify the authenticity of
    an executable image. To do this, the UEFI firmware locates and reads a signature
    certificate from the executable, computes the hash of the executable according
    to a specified algorithm, and then compares the hash with the one provided in
    the signature certificate. If they match, the UEFI firmware verifies the digital
    signature of the hash using the key provided in the signature certificate. If
    the signature verification succeeds, then the UEFI firmware accepts the signature.
    In any other case (like a hash mismatch or signature verification failure), the
    UEFI firmware fails to authenticate the image.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息足以让安全启动验证可执行镜像的真实性。为此，UEFI 固件会定位并读取可执行文件中的签名证书，按照指定的算法计算可执行文件的散列值，然后将该散列值与签名证书中提供的散列值进行比较。如果匹配，UEFI
    固件将使用签名证书中提供的密钥验证该散列的数字签名。如果签名验证成功，则 UEFI 固件接受该签名。在任何其他情况下（如散列不匹配或签名验证失败），UEFI
    固件将无法认证该镜像。
- en: However, simply verifying that the signature matches isn’t enough to establish
    trust in a UEFI executable. UEFI firmware must also ensure that the executable
    was signed with an authorized key. Otherwise, there’s nothing to prevent anyone
    from generating a custom signing key and signing a malicious image with it to
    pass Secure Boot validation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅验证签名是否匹配不足以建立对 UEFI 可执行文件的信任。UEFI 固件还必须确保该可执行文件是用授权密钥签名的。否则，任何人都可以生成自定义签名密钥，并使用该密钥签署恶意镜像以通过安全启动验证。
- en: That’s why the public key used for signature validation should be matched with
    a trusted private key. The UEFI firmware explicitly trusts these private keys,
    so they may be used to establish trust in an image. A list of the trusted public
    keys is stored in the `db` database, which we’ll explore next.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么用于签名验证的公钥应该与受信任的私钥匹配的原因。UEFI 固件显式信任这些私钥，因此它们可以用于建立对镜像的信任。受信任公钥的列表存储在`db`数据库中，接下来我们将进行探索。
- en: '***The db Database***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***db 数据库***'
- en: The `db` database holds a list of trusted public key certificates authorized
    to authenticate signatures. Whenever Secure Boot performs signature verification
    on an executable, it checks the signature public key against the list of keys
    in the `db` database to determine whether or not it can trust the key. Only code
    signed with private keys that correspond to these certificates will be executed
    on the platform during the boot process.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`db`数据库保存了一个受信任的公钥证书列表，这些证书被授权用来验证签名。每当安全启动执行可执行文件的签名验证时，它会将签名的公钥与`db`数据库中的密钥列表进行比对，以判断是否可以信任该密钥。只有使用与这些证书对应的私钥签名的代码，才能在启动过程中在平台上执行。'
- en: In addition to the list of trusted public key certificates, the `db` database
    contains hashes of individual executables that are allowed to execute on the platform,
    regardless of whether or not they’re digitally signed. This mechanism can be used
    to authenticate TE files that don’t have embedded digital signatures.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了受信任的公钥证书列表外，`db`数据库还包含允许在平台上执行的单个可执行文件的哈希值，无论这些文件是否有数字签名。这个机制可以用来验证没有嵌入数字签名的TE文件。
- en: According to the UEFI specification, the signatures database is stored in a
    nonvolatile RAM (NVRAM) variable that persists across reboots of the system. The
    implementation of NVRAM variables is platform specific, and different original
    equipment manufacturers (OEMs) may implement it in different ways. Most commonly,
    these variables are stored in the same SPI flash that contains platform firmware,
    such as the BIOS. As you’ll see in “[Modifying the UEFI Variables to Bypass Security
    Checks](ch17.xhtml#ch17lev2sec11)” on [page 337](ch17.xhtml#page_337), this leads
    to vulnerabilities that you can use to bypass Secure Boot.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据UEFI规范，签名数据库存储在一个非易失性RAM（NVRAM）变量中，该变量在系统重启后依然保留。NVRAM变量的实现方式是平台特定的，不同的原始设备制造商（OEM）可能会以不同的方式实现它。最常见的是，这些变量存储在与平台固件（如BIOS）相同的SPI闪存中。正如你将在[《修改UEFI变量以绕过安全检查》](ch17.xhtml#ch17lev2sec11)中看到的，在[第337页](ch17.xhtml#page_337)，这会导致一些漏洞，你可以利用这些漏洞绕过安全启动。
- en: Let’s check out the contents of the `db` database on your own system by dumping
    the contents of the NVRAM variable that holds the database. We’ll be using the
    Lenovo Thinkpad T540p platform as our example, but you should use whatever platform
    you’re working with. We’ll dump the contents of the NVRAM variable using the Chipsec
    open source toolset, which you encountered in [Chapter 15](ch15.xhtml#ch15). This
    toolset has rich functionality useful for forensic analysis, and we’ll discuss
    it in more detail in [Chapter 19](ch19.xhtml#ch19).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过转储保存数据库的NVRAM变量的内容，来查看你自己系统上`db`数据库的内容。我们将以联想Thinkpad T540p平台为例，但你应该使用你所工作的平台。我们将使用Chipsec开源工具集来转储NVRAM变量的内容，这个工具集你在[第15章](ch15.xhtml#ch15)中已经接触过。这个工具集具有丰富的功能，适用于取证分析，我们将在[第19章](ch19.xhtml#ch19)中更详细地讨论它。
- en: 'Download the Chipsec tool from GitHub at *[https://github.com/chipsec/chipsec/](https://github.com/chipsec/chipsec/)*.
    The tool depends on `winpy` (Python for Windows Extensions), which you’ll need
    to download and install before running Chipsec. Once you have both, open Command
    Prompt or another command line interpreter and navigate into the directory holding
    the downloaded Chipsec tool. Then enter the following command to get a list of
    your UEFI variables:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub下载Chipsec工具，地址是*[https://github.com/chipsec/chipsec/](https://github.com/chipsec/chipsec/)*。该工具依赖于`winpy`（Windows平台的Python扩展），你需要先下载并安装`winpy`，然后才能运行Chipsec。安装完毕后，打开命令提示符或其他命令行解释器，进入存放下载的Chipsec工具的目录。然后输入以下命令，获取你的UEFI变量列表：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command dumps all the UEFI variables from your current directory into the
    subdirectory *efi_variables.dir* and decodes the contents of some of them (Chipsec
    decodes only the contents of known variables). Navigate to the directory, and
    you should see something similar to [Figure 17-2](ch17.xhtml#ch17fig02).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将从当前目录转储所有UEFI变量到子目录*efi_variables.dir*中，并解码其中的一些内容（Chipsec只解码已知变量的内容）。进入该目录，你应该会看到类似[图17-2](ch17.xhtml#ch17fig02)的内容。
- en: '![image](../images/17fig02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig02.jpg)'
- en: '*Figure 17-2: UEFI variables dumped by Chipsec*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-2：Chipsec转储的UEFI变量*'
- en: Every entry in this directory corresponds to a separate UEFI NVRAM variable.
    These variable names have the structure VarName`_`VarGUID`_`VarAttributes`.bin`,
    where VarName is the name of the variable, VarGUID is the variable’s 16-byte global
    unique identifier (GUID), and VarAttributes is a list of the variable’s attributes
    in short form. Based on the UEFI specification, here are some of the attributes
    of the entries in [Figure 17-2](ch17.xhtml#ch17fig02).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该目录中的每个条目对应一个单独的 UEFI NVRAM 变量。这些变量名的结构为 VarName`_`VarGUID`_`VarAttributes`.bin，其中
    VarName 是变量的名称，VarGUID 是变量的 16 字节全局唯一标识符（GUID），VarAttributes 是该变量属性的简短列表。根据 UEFI
    规范，以下是 [图 17-2](ch17.xhtml#ch17fig02) 中条目的部分属性。
- en: NV Nonvolatile, meaning the variable’s content persists across reboot.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: NV 非易失性，意味着变量的内容在重启后仍然存在。
- en: BS Can be accessed by UEFI boot services. UEFI boot services are generally available
    during boot time before the OS loader is executed. Once the OS loader is launched,
    the UEFI boot services are no longer available.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: BS 可以通过 UEFI 启动服务访问。UEFI 启动服务通常在启动时可用，即操作系统加载器执行之前。一旦操作系统加载器启动，UEFI 启动服务将不再可用。
- en: RT Can be accessed by UEFI runtime services. Unlike UEFI boot services, the
    runtime services persist throughout the loading of the OS and during the OS runtime.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: RT 可以通过 UEFI 运行时服务访问。与 UEFI 启动服务不同，运行时服务在操作系统加载和运行期间持续有效。
- en: AWS Count-based authenticated variable, meaning that any new variable content
    needs to be signed with an authorized key so the variable can be written to. The
    variable’s signed data includes a counter to protect against rollback attacks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 基于计数的认证变量，意味着任何新的变量内容需要用授权密钥进行签名，以便该变量能够被写入。该变量的签名数据包括一个计数器，用于防止回滚攻击。
- en: TBAWS Time-based authenticated variable, meaning any new variable content needs
    to be signed with an authorized key in order for the variable to be written to.
    The timestamp in the signature reflects the time when the data was signed. It’s
    used to confirm that the signature was created before the corresponding signing
    key expired. We provide more information on time-based authentication in the next
    section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: TBAWS 基于时间的认证变量，意味着任何新的变量内容需要用授权密钥进行签名，以便该变量能够被写入。签名中的时间戳反映了数据签名的时间。它用于确认签名是在相应的签名密钥过期之前创建的。我们将在下一节提供有关基于时间认证的更多信息。
- en: If Secure Boot is configured and the `db` variable exists on the platform, you
    should find a subfolder in this directory with a name starting with *db_D719B2CB-3D3A-4596-A3BC-DAD00E67656F*.
    When Chipsec dumps the `db` UEFI variable, it automatically decodes the variable’s
    contents into this subfolder, which contains files corresponding to public key
    certificates and hashes of UEFI images authorized for execution. In our case,
    we have five files—four certificates and one SHA256 hash, as shown in [Figure
    17-3](ch17.xhtml#ch17fig03).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置了安全启动并且平台上存在 `db` 变量，你应该在该目录中找到一个以 *db_D719B2CB-3D3A-4596-A3BC-DAD00E67656F*
    开头的子文件夹。当 Chipsec 转储 `db` UEFI 变量时，它会自动将变量的内容解码到该子文件夹中，该子文件夹包含与公钥证书和授权执行的 UEFI
    镜像的哈希值对应的文件。在我们的例子中，我们有五个文件——四个证书和一个 SHA256 哈希，如 [图 17-3](ch17.xhtml#ch17fig03)
    所示。
- en: '![image](../images/17fig03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig03.jpg)'
- en: '*Figure 17-3: The contents of a signature database UEFI variable*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-3：签名数据库 UEFI 变量的内容*'
- en: 'These certificates are encoded with X.509, a cryptographic standard that defines
    the format of public key certificates. We can decode these certificates to get
    information about the issuer, which will tell us whose signature will pass Secure
    Boot verification. For this, we’ll use the `openssl` toolkit, described in the
    box “The OpenSSL Toolkit.” Install the tool from *[https://github.com/openssl/openssl/](https://github.com/openssl/openssl/)*,
    and then run it with the following command, replacing certificate_file_path with
    the directory on your computer that contains `openssl`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些证书采用 X.509 编码，X.509 是一种定义公钥证书格式的加密标准。我们可以解码这些证书，获取有关发行者的信息，这将告诉我们谁的签名能够通过安全启动验证。为此，我们将使用
    `openssl` 工具包，工具包的描述见框中“OpenSSL 工具包”。从 *[https://github.com/openssl/openssl/](https://github.com/openssl/openssl/)*
    安装该工具包，然后使用以下命令运行它，替换 `certificate_file_path` 为包含 `openssl` 的目录路径：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On a Windows operating system, simply change the extension of the X.509 certificate
    file from *bin* to *crt* and open the file with Explorer to see the results of
    the decoding. [Table 17-1](ch17.xhtml#ch17tab01) shows our results, with the issuers
    and subjects of the certificates.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 操作系统上，只需将 X.509 证书文件的扩展名从*bin*更改为*crt*，然后使用资源管理器打开该文件，即可查看解码结果。[表17-1](ch17.xhtml#ch17tab01)展示了我们的结果，其中列出了证书的颁发者和主题。
- en: '**Table 17-1:** The Decoded Certificates and Hashes from the UEFI Variable'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**表17-1：** 从 UEFI 变量中解码的证书和哈希值'
- en: '| **Filename** | **Issued to** | **Issued by** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **文件名** | **颁发给** | **颁发者** |'
- en: '| --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *X509-7FACC7B6-127F-4E9C-9C5D-080F98994345-03.bin* | Thinkpad Product CA
    2012 | Lenovo Ltd. Root CA 2012 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| *X509-7FACC7B6-127F-4E9C-9C5D-080F98994345-03.bin* | Thinkpad 产品 CA 2012
    | 联想有限公司根证书 CA 2012 |'
- en: '| *X509-7FACC7B6-127F-4E9C-9C5D-080F98994345-04.bin* | Lenovo UEFI CA 2014
    | Lenovo UEFI CA 2014 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| *X509-7FACC7B6-127F-4E9C-9C5D-080F98994345-04.bin* | 联想 UEFI CA 2014 | 联想
    UEFI CA 2014 |'
- en: '| *X509-77FA9ABD-0359-4D32-BD60-28F4E78F784B-01.bin* | Microsoft Corporation
    UEFI CA 2011 | Microsoft Corporation Third-Party Marketplace Root |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| *X509-77FA9ABD-0359-4D32-BD60-28F4E78F784B-01.bin* | 微软公司 UEFI CA 2011 |
    微软公司第三方市场根证书 |'
- en: '| *X509-77FA9ABD-0359-4D32-BD60-28F4E78F784B-02.bin* | Microsoft Windows Production
    PCA 2011 | Microsoft Root Certificate Authority 2010 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| *X509-77FA9ABD-0359-4D32-BD60-28F4E78F784B-02.bin* | 微软 Windows 生产 PCA 2011
    | 微软根证书颁发机构 2010 |'
- en: From the table, you can see that only UEFI images signed by Lenovo and Microsoft
    will pass the UEFI Secure Boot code integrity checks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从表中可以看到，只有由联想和微软签名的 UEFI 镜像才能通过 UEFI 安全启动的代码完整性检查。
- en: '**THE OPENSSL TOOLKIT**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**OPENSSL 工具包**'
- en: OpenSSL is an open source software library that implements the Secure Socket
    Layer and Transport Layer Security protocols, as well as general-purpose cryptography
    primitives. Licensed under an Apache-style license, OpenSSL is frequently used
    in commercial and noncommercial applications. The library offers rich functionality
    for working with X.509 certificates, whether you’re parsing existing certificates
    or generating new ones. You can find information on the project at *[https://www.openssl.org/](https://www.openssl.org/)*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL 是一个开源软件库，实现了安全套接字层（SSL）和传输层安全性（TLS）协议，以及通用的加密原语。OpenSSL 在 Apache 风格的许可证下发布，广泛应用于商业和非商业应用程序。该库提供了丰富的功能，供用户操作
    X.509 证书，无论是解析现有证书还是生成新证书。你可以在*[https://www.openssl.org/](https://www.openssl.org/)*找到有关该项目的信息。
- en: '***The dbx Database***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***dbx 数据库***'
- en: In contrast to `db`, the `dbx` database contains certificates of public keys
    and hashes of UEFI executables that are *prohibited* from executing at boot time.
    This database is also referred to as the *Revoked Signature Database*, and it
    explicitly lists images that will fail Secure Boot verification, preventing execution
    of a module with a known vulnerability that may compromise the security of the
    whole platform.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与`db`数据库不同，`dbx`数据库包含公钥证书和 UEFI 可执行文件的哈希值，这些文件在启动时被*禁止*执行。这个数据库也被称为*撤销签名数据库*，它明确列出了将无法通过安全启动验证的镜像，防止已知漏洞的模块执行，从而保护整个平台的安全。
- en: We’ll explore the contents of the `dbx` database the same way we did for the
    `db` signature database. Among the folders generated when you run the Chipsec
    tool, you’ll find the folder *efi_variables.dir*, which should contain a subfolder
    with a name beginning *dbx_D719B2CB-3D3A-4596-A3BC-DAD00E67656f*. This folder
    contains certificates and hashes of forbidden UEFI images. In our case, the folder
    contains only 78 hashes and no certificates, as shown in [Figure 17-4](ch17.xhtml#ch17fig04).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与`db`签名数据库相同的方式探讨`dbx`数据库的内容。当你运行 Chipsec 工具时，会生成一些文件夹，在这些文件夹中，你会找到名为*efi_variables.dir*的文件夹，该文件夹下应该包含一个以*dbx_D719B2CB-3D3A-4596-A3BC-DAD00E67656f*开头的子文件夹。这个文件夹包含被禁止的
    UEFI 镜像的证书和哈希值。在我们的案例中，文件夹仅包含 78 个哈希值，而没有证书，如[图17-4](ch17.xhtml#ch17fig04)所示。
- en: '![image](../images/17fig04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig04.jpg)'
- en: '*Figure 17-4: Contents of the `dbx` database (the revoked signature database)
    UEFI variable*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-4：`dbx`数据库（撤销签名数据库）UEFI 变量的内容*'
- en: '[Figure 17-5](ch17.xhtml#ch17fig05) shows the image signature verification
    algorithm using both the `db` and `dbx` databases.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17-5](ch17.xhtml#ch17fig05)展示了使用`db`和`dbx`数据库的镜像签名验证算法。'
- en: '![image](../images/17fig05.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig05.jpg)'
- en: '*Figure 17-5: The UEFI Secure Boot image verification algorithm*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-5：UEFI 安全启动镜像验证算法*'
- en: From this figure, you can see that an UEFI executable passes authentication
    only when its hash or signature certificate is trusted per the `db` database and
    when it is not listed in the `dbx` database. Otherwise, the image fails the Secure
    Boot integrity check.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张图中，你可以看到，只有当 UEFI 可执行文件的哈希或签名证书在`db`数据库中被信任且未列在`dbx`数据库中时，它才会通过认证。否则，该映像将无法通过
    Secure Boot 的完整性检查。
- en: '***Time-Based Authentication***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基于时间的认证***'
- en: In addition to the `db` and `dbx` databases, Secure Boot uses two other databases,
    called `dbt` and `dbr`. The first, `dbr`, contains public key certificates used
    to verify the signatures of the OS recovery loader. We won’t discuss it much.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`db`和`dbx`数据库，Secure Boot 还使用另外两个数据库，分别叫做`dbt`和`dbr`。第一个，`dbr`，包含用于验证操作系统恢复加载程序签名的公钥证书，我们不再深入讨论。
- en: The second, `dbt`, contains timestamping certificates used to validate the timestamp
    of a UEFI executable’s digital signature, enabling time-based authentication (TBAWS)
    in Secure Boot. (You saw TBAWS earlier in this chapter when we looked at the attributes
    of UEFI variables.)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，`dbt`，包含用于验证 UEFI 可执行文件数字签名时间戳的时间戳证书，从而实现 Secure Boot 中的基于时间的认证（TBAWS）。(你在本章早些时候查看
    UEFI 变量的属性时，已经见过 TBAWS。)
- en: The digital signature of a UEFI executable sometimes contains a timestamp issued
    by the *Time Stamping Authority (TSA)* service. The signature’s timestamp reflects
    the time at which the signature was generated. By comparing the signature timestamp
    and the expiration timestamp of the signing key, Secure Boot determines whether
    the signature was generated before or after the signing key expired. Generally,
    the expiration date of the signing key is the date after which the signing key
    is considered compromised. As a result, the timestamp of the signature allows
    Secure Boot to verify that the signature was generated at a moment when the signing
    key wasn’t compromised, ensuring that the signature is legitimate. In this way,
    time-based authentication reduces the complexity of PKI when it comes to Secure
    Boot `db` certificates.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 可执行文件的数字签名有时包含由*时间戳认证机构（TSA）*服务颁发的时间戳。该签名的时间戳反映了签名生成的时间。通过比较签名时间戳与签名密钥的过期时间戳，Secure
    Boot 可以确定签名是生成在签名密钥过期之前还是之后。通常，签名密钥的过期日期是指签名密钥被认为已被泄露的日期。因此，签名的时间戳使得 Secure Boot
    能够验证签名是在签名密钥未被泄露的时刻生成的，从而确保签名的合法性。通过这种方式，基于时间的认证减少了 PKI 在 Secure Boot `db` 证书中的复杂性。
- en: Time-based authentication also allows you to avoid re-signing the same UEFI
    images. The timestamp of the signature proves to Secure Boot that a UEFI image
    was signed before the corresponding signing key expired or was revoked. As a result,
    the signature remains valid even after the signing key is expired, since it was
    created when the signing key was still valid and not compromised.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基于时间的认证还允许你避免重新签名相同的 UEFI 映像。签名的时间戳向 Secure Boot 证明，某个 UEFI 映像是在相应签名密钥过期或被撤销之前签署的。因此，即使签名密钥过期，签名仍然有效，因为它是在签名密钥仍然有效且未被泄露时创建的。
- en: '***Secure Boot Keys***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Secure Boot 密钥***'
- en: Now that you’ve seen where Secure Boot obtains information on trusted and revoked
    public key certificates, let’s talk about how these databases are stored and protected
    from unauthorized modification. After all, by modifying the `db` database, an
    attacker could easily bypass Secure Boot checks by injecting a malicious certificate
    and replacing the OS bootloader with a rogue bootloader signed with a private
    key corresponding to the malicious certificate. Since the malicious certificate
    is in the `db` signature database, Secure Boot would allow the rogue bootloader
    to run.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Secure Boot 如何获取受信任和撤销的公钥证书信息，让我们来谈谈这些数据库是如何存储并防止未经授权的修改的。毕竟，通过修改`db`数据库，攻击者可以轻松绕过
    Secure Boot 检查，注入恶意证书，并用与恶意证书对应的私钥签名的流氓引导程序替换操作系统引导加载程序。由于恶意证书已经存在于`db`签名数据库中，Secure
    Boot 将允许流氓引导程序运行。
- en: So, to protect the `db` and `dbx` databases from unauthorized modification,
    the platform or OS system vendor must sign the databases. When the UEFI firmware
    goes to read the content of these databases, it first authenticates them by verifying
    their digital signature with a public key called the *key exchange key (KEK)*.
    It then authenticates each KEK with a second key called the *platform key (PK)*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了防止 `db` 和 `dbx` 数据库遭受未经授权的修改，平台或操作系统供应商必须对这些数据库进行签名。当 UEFI 固件读取这些数据库的内容时，它首先通过验证数字签名来认证它们，验证的过程使用了一个称为
    *密钥交换密钥（KEK）* 的公钥。然后，它使用第二个密钥，称为 *平台密钥（PK）*，来认证每个 KEK。
- en: '**Key Exchange Keys**'
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**密钥交换密钥**'
- en: As with the `db` and `dbx` databases, the list of public KEKs is stored in an
    NVRAM UEFI variable. We’ll explore the content of the `KEK` variable using the
    results of our previous execution of the `chipsec` command. Open the directory
    containing the results, and you should see a subfolder labeled something like
    *KEK_8BE4DF61-93CA-11D2-AA0D-00E098032B8C*, which contains certificates of public
    KEKs ([Figure 17-6](ch17.xhtml#ch17fig06)). This UEFI variable is authenticated
    as well, as you’ll see next.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `db` 和 `dbx` 数据库一样，公钥 KEK 的列表也存储在 NVRAM UEFI 变量中。我们将使用之前执行的 `chipsec` 命令的结果来探索
    `KEK` 变量的内容。打开包含结果的目录，你应该会看到一个名为 *KEK_8BE4DF61-93CA-11D2-AA0D-00E098032B8C* 的子文件夹，里面包含公钥
    KEK 的证书（见 [图 17-6](ch17.xhtml#ch17fig06)）。这个 UEFI 变量也需要进行认证，正如你接下来会看到的那样。
- en: '![image](../images/17fig06.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig06.jpg)'
- en: '*Figure 17-6: Contents of the `KEK` UEFI variable*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-6：`KEK` UEFI 变量的内容*'
- en: Only the owner of the private key corresponding to any of these certificates
    can modify the contents of the `db` and `dbx` databases. In this example, we have
    only two KEK certificates, by Microsoft and Lenovo, as indicated in [Table 17-2](ch17.xhtml#ch17tab02).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 只有对应这些证书中任何一个的私钥所有者才能修改 `db` 和 `dbx` 数据库的内容。在这个例子中，我们只有两个 KEK 证书，分别来自 Microsoft
    和 Lenovo，如 [表 17-2](ch17.xhtml#ch17tab02) 所示。
- en: '**Table 17-2:** Certificates in the KEK UEFI Variable'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 17-2：KEK UEFI 变量中的证书**'
- en: '| **Filename** | **Issued to** | **Issued by** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **文件名** | **发放给** | **由...发放** |'
- en: '| --- | --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *X509-7FACC7B6-127F-4E9C-9C5D-080F98994345-00.bin* | Lenovo Ltd. KEK CA 2012
    | Lenovo Ltd. KEK CA 2012 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| *X509-7FACC7B6-127F-4E9C-9C5D-080F98994345-00.bin* | 联想有限公司 KEK CA 2012 |
    联想有限公司 KEK CA 2012 |'
- en: '| *X509-77FA9ABD-0359-4D32-BD60-28F4E78F784B-01.bin* | Microsoft Corporation
    KEK CA 2011 | Microsoft Corporation Third-Party Marketplace Root |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| *X509-77FA9ABD-0359-4D32-BD60-28F4E78F784B-01.bin* | 微软公司 KEK CA 2011 | 微软公司第三方市场根证书
    |'
- en: You can discover the owners of the private keys corresponding to your system’s
    KEK certificates by dumping the `KEK` variable and executing the `openssl` command
    we used earlier.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过转储 `KEK` 变量并执行我们之前使用的 `openssl` 命令，来发现与你系统的 KEK 证书相对应的私钥所有者。
- en: '**Platform Key**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**平台密钥**'
- en: The PK is the last signing key in the PKI key hierarchy of Secure Boot. As you
    might have guessed, this key is used to authenticate KEKs by signing the `KEK`
    UEFI variable. According to the UEFI specification, each platform has a single
    PK. Usually, this key corresponds to the platform manufacturer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: PK 是安全启动中 PKI 密钥层级的最后一个签名密钥。正如你可能已经猜到的，这个密钥用于通过签名 `KEK` UEFI 变量来认证 KEK。根据 UEFI
    规范，每个平台都有一个唯一的 PK。通常，这个密钥对应于平台的制造商。
- en: Return to the *PK_8BE4DF61-93CA-11D2-AA0D-00E098032B8C* subfolder of *efi_variables.dir*
    that was created when you executed `chipsec`. There, you can find the certificate
    of the public PK. Your certificate will correspond to your platform. So, since
    we used the Lenovo Thinkpad T540p platform, we would expect our PK certificate
    to correspond to Lenovo (see [Figure 17-7](ch17.xhtml#ch17fig07)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到你执行 `chipsec` 时创建的 *efi_variables.dir* 文件夹中的 *PK_8BE4DF61-93CA-11D2-AA0D-00E098032B8C*
    子文件夹。在那里，你可以找到公钥 PK 的证书。你的证书将对应于你的平台。因此，既然我们使用了 Lenovo Thinkpad T540p 平台，我们可以预期我们的
    PK 证书会对应于 Lenovo（见 [图 17-7](ch17.xhtml#ch17fig07)）。
- en: '![image](../images/17fig07.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig07.jpg)'
- en: '*Figure 17-7: The PK certificate*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-7：PK 证书*'
- en: You can see that ours was indeed issued by Lenovo. The `PK` UEFI variable is
    also authenticated, and every update of the variable should be signed with the
    corresponding private key. In other words, if the platform owner (or the platform
    manufacturer, in UEFI terminology) wants to update the `PK` variable with a new
    certificate, the buffer with the new certificate should be signed with the private
    key that corresponds to the current certificate stored in the `PK` variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这个确实是由联想发布的。`PK` UEFI变量也经过认证，并且每次更新该变量时都应使用相应的私钥进行签名。换句话说，如果平台所有者（或者在UEFI术语中是平台制造商）希望用新证书更新`PK`变量，则包含新证书的缓冲区应使用与当前存储在`PK`变量中的证书对应的私钥进行签名。
- en: '***UEFI Secure Boot: The Complete Picture***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***UEFI安全启动：完整图景***'
- en: Now that we’ve explored the complete hierarchy of the PKI infrastructure used
    in UEFI Secure Boot, let’s put everything together to see the whole picture, shown
    in [Figure 17-8](ch17.xhtml#ch17fig08).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了UEFI安全启动中使用的PKI基础设施的完整层次结构，让我们把所有内容汇总起来，看看整个图景，见[图17-8](ch17.xhtml#ch17fig08)。
- en: '![image](../images/17fig08.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig08.jpg)'
- en: '*Figure 17-8: UEFI Secure Boot verification flow*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-8：UEFI安全启动验证流程*'
- en: At the top of the figure, you can see that the root of trust (the components
    that UEFI Secure Boot inherently trusts, upon which it bases all of its future
    verification) is the platform initialization firmware and the platform key. The
    platform initialization firmware is the very first piece of code executed when
    the CPU comes out of a reset, and the UEFI Secure Boot implicitly trusts this
    code. If an attacker compromises the PI firmware, the whole chain of trust enforced
    by Secure Boot is broken. In that case, the attacker can patch any UEFI module
    that implements the Secure Boot image verification routines so it always returns
    a success and, as a result, allows every UEFI image supplied to pass authentication.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形的顶部，你可以看到信任根（UEFI安全启动固有信任的组件，所有未来验证的基础）是平台初始化固件和平台密钥。平台初始化固件是在CPU复位后第一次执行的代码，UEFI安全启动隐式信任这段代码。如果攻击者破坏了PI固件，安全启动强制的整个信任链就会被打破。在这种情况下，攻击者可以修改任何实现安全启动镜像验证程序的UEFI模块，使其始终返回成功，从而允许所有提供的UEFI镜像通过认证。
- en: That’s why the Secure Boot trust model assumes you’ve correctly implemented
    the Firmware Secure Update mechanism, which requires every update of the firmware
    to be signed with the proper signing key (which must be different from the PK).
    That way, only authorized updates of PI firmware take place, and the root of trust
    remains uncompromised.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么安全启动信任模型假设你已正确实现固件安全更新机制，该机制要求每次固件更新都必须使用正确的签名密钥进行签名（该密钥必须不同于平台密钥PK）。这样，只有经过授权的PI固件更新才能进行，并且信任根保持不被破坏。
- en: It’s easy to see that this trust model does not protect against physical attackers,
    who can physically reprogram the SPI flash with a malicious firmware image and
    compromise the PI firmware. We’ll talk about protecting firmware against physical
    attacks in “[Protecting Secure Boot with Verified and Measured Boot](ch17.xhtml#ch17lev1sec4)”
    on [page 338](ch17.xhtml#page_338).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，这种信任模型无法防范物理攻击者，物理攻击者可以通过恶意固件镜像重新编程SPI闪存，从而危及PI固件。我们将在《[通过验证和度量启动保护安全启动](ch17.xhtml#ch17lev1sec4)》一章的[第338页](ch17.xhtml#page_338)讨论如何保护固件免受物理攻击。
- en: At the top of [Figure 17-8](ch17.xhtml#ch17fig08), you can see the platform
    key provided by the platform manufacturer has the same level of inherent trust
    as PI firmware. This key is used to establish trust between the PI firmware and
    the platform manufacturer. Once the platform key is provided, the platform firmware
    allows the manufacturer to update the KEKs and, as a result, control which images
    pass Secure Boot checks and which don’t.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图17-8](ch17.xhtml#ch17fig08)的顶部，你可以看到由平台制造商提供的平台密钥与PI固件具有相同级别的固有信任。此密钥用于建立PI固件与平台制造商之间的信任。一旦提供了平台密钥，平台固件允许制造商更新KEK密钥，因此可以控制哪些镜像通过安全启动检查，哪些不通过。
- en: One level below, you see the KEKs that establish trust between the PI firmware
    and the OS running on the platform. Once the platform KEK is provisioned in the
    UEFI variable, the OS is able to specify which images can pass Secure Boot check.
    For example, the OS vendor can use the KEK to allow the UEFI firmware to execute
    the OS loader.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一级，你可以看到用于建立平台上 PI 固件与操作系统之间信任的 KEK。一旦平台的 KEK 被写入 UEFI 变量中，操作系统就能够指定哪些镜像可以通过
    Secure Boot 检查。例如，操作系统厂商可以使用 KEK 来允许 UEFI 固件执行操作系统加载程序。
- en: At the bottom of the trust model, you see the `db` and `dbx` databases signed
    with KEKs, which contain hashes of images and public key certificates that are
    used directly in integrity checks of executables enforced by Secure Boot.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在信任模型的底层，你可以看到使用 KEK 签名的 `db` 和 `dbx` 数据库，这些数据库包含镜像的哈希值和公钥证书，它们直接用于 Secure Boot
    强制执行的可执行文件完整性检查。
- en: '***Secure Boot Policy***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Secure Boot 策略***'
- en: By itself, Secure Boot uses the `PK`, `KEK`, `db`, `dbx`, and `dbt` variables
    to tell the platform whether or not an executable image is trusted, as you’ve
    seen. However, the way in which the result of Secure Boot verification is interpreted
    (in other words, whether or not to execute an image) largely depends on the policy
    in place.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，Secure Boot 使用 `PK`、`KEK`、`db`、`dbx` 和 `dbt` 变量来告诉平台一个可执行镜像是否可信，如你所见。然而，Secure
    Boot 验证结果的解释方式（换句话说，是否执行镜像）在很大程度上取决于所实施的策略。
- en: We’ve already mentioned Secure Boot policies a few times in this chapter without
    getting into the details of what one actually is. So, let’s take a closer look
    at this concept.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章中多次提到 Secure Boot 策略，但尚未深入探讨它究竟是什么。所以，让我们更详细地了解这个概念。
- en: In essence, a Secure Boot policy dictates which actions the platform firmware
    should take after it performs image authentication. The firmware might execute
    the image, deny image execution, defer image execution, or ask a user to make
    the decision.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，Secure Boot 策略决定了平台固件在执行镜像认证后应该采取的行动。固件可能会执行该镜像、拒绝镜像执行、推迟镜像执行，或要求用户做出决定。
- en: Secure Boot policy isn’t rigorously defined in the UEFI specification and, therefore,
    is specific to each implementation. In particular, policies can vary between implementations
    of UEFI firmware by different vendors. In this section, we’ll explore some Secure
    Boot policy elements implemented in Intel’s EDK2 source code, which we used in
    [Chapter 15](ch15.xhtml#ch15). Download or clone the EDK2 source code now from
    the repository at *[https://github.com/tianocore/edk2/](https://github.com/tianocore/edk2/)*
    if you haven’t already.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Secure Boot 策略在 UEFI 规范中并没有严格定义，因此它是特定于每个实现的。特别是，不同厂商的 UEFI 固件实现之间的策略可能有所不同。在本节中，我们将探讨一些在英特尔
    EDK2 源代码中实现的 Secure Boot 策略元素，这些源代码在 [第15章](ch15.xhtml#ch15) 中已经使用。如果你还没有下载或克隆
    EDK2 源代码，请立即从 *[https://github.com/tianocore/edk2/](https://github.com/tianocore/edk2/)*
    仓库中获取。
- en: One of the elements that Secure Boot, as implemented in EDK2, takes into account
    is the origin of the executable images being authenticated. The images could come
    from different storage devices, some of which may be inherently trusted. For instance,
    if the image is loaded from the SPI flash, meaning it’s located on the same storage
    device as the rest of UEFI firmware, then the platform might trust it automatically.
    (However, if an attacker is able to alter the image on SPI flash, they could also
    tamper with the rest of the firmware and disable Secure Boot completely. We’ll
    discuss this attack later in “[Patching PI Firmware to Disable Secure Boot](ch17.xhtml#ch17lev2sec10)”
    on [page 335](ch17.xhtml#page_335).) On the other hand, if the image is loaded
    from an external PCI device—for example, an Option ROM, special firmware loaded
    from external peripheral devices in the preboot environment—then it would be treated
    as untrusted and subject to a Secure Boot check.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EDK2 中实现的 Secure Boot 考虑的因素之一是被认证的可执行镜像的来源。这些镜像可能来自不同的存储设备，其中一些设备可能本身就被信任。例如，如果镜像是从
    SPI 闪存加载的，即它与其余的 UEFI 固件位于同一存储设备上，那么平台可能会自动信任它。（然而，如果攻击者能够修改 SPI 闪存上的镜像，他们也可能篡改其他固件并完全禁用
    Secure Boot。我们将在 “[修补 PI 固件以禁用 Secure Boot](ch17.xhtml#ch17lev2sec10)” [第335页](ch17.xhtml#page_335)
    中讨论这一攻击。）另一方面，如果镜像是从外部 PCI 设备加载的——例如，Option ROM 或从外部外设设备加载的特殊固件——则它会被视为不可信，并需经过
    Secure Boot 检查。
- en: Here, we outline the definitions of some of the policies that determine how
    to process images with respect to their origin. You can find these policies in
    the *SecurityPkg\SecurityPkg.dec* file located in the EDK2 repository. Each policy
    assigns a default value to the images that meet the criteria.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，我们概述了一些决定如何处理与其来源相关的图像的策略定义。你可以在EDK2代码库中的*SecurityPkg\SecurityPkg.dec*文件中找到这些策略。每个策略都会为符合条件的图像分配一个默认值。
- en: 'PcdOptionRomImageVerificationPolicy Defines the verification policy for images
    loaded as Option ROMs, like those from PCI devices (default value: 0x00000004).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: PcdOptionRomImageVerificationPolicy 定义了作为选项ROM加载的图像的验证策略，例如来自PCI设备的图像（默认值：0x00000004）。
- en: 'PcdRemovableMediaImageVerificationPolicy Defines the verification policy for
    images located on removable media, which includes CD-ROM, USB, and network (default
    value: 0x00000004).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: PcdRemovableMediaImageVerificationPolicy 定义了位于可移动介质上的图像的验证策略，包括CD-ROM、USB和网络（默认值：0x00000004）。
- en: 'PcdFixedMediaImageVerificationPolicy Defines the verification policy for images
    located on fixed media devices, such as hard disks (default value: 0x00000004).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: PcdFixedMediaImageVerificationPolicy 定义了位于固定介质设备（如硬盘）上的图像的验证策略（默认值：0x00000004）。
- en: 'In addition to these policies, there are two more policies that aren’t explicitly
    defined in the *SecurityPkg\SecurityPkg.dec* file but are used in EDK2 Secure
    Boot implementation:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些策略外，还有两种策略并未在*SecurityPkg\SecurityPkg.dec*文件中明确定义，但在EDK2 Secure Boot实现中使用：
- en: '**SPI flash ROM policy** Defines the verification policy for images located
    on SPI flash (default value: 0x00000000).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**SPI闪存ROM策略** 定义了位于SPI闪存上的图像的验证策略（默认值：0x00000000）。'
- en: '**Other origin** Defines the verification policy for any images located on
    devices other than those just described (default value: 0x00000004).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他来源** 定义了对于位于除前述设备外的任何设备上的图像的验证策略（默认值：0x00000004）。'
- en: '**NOTE**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Keep in mind that this isn’t a comprehensive list of Secure Boot policies
    used for image authentication. Different firmware vendors can modify or extend
    this list with their custom policies.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，这并不是用于图像认证的Secure Boot策略的完整列表。不同的固件厂商可以修改或扩展此列表，加入他们的自定义策略。*'
- en: 'Here are the descriptions of the default policy values:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是默认策略值的描述：
- en: '**0x00000000** Always trust the image regardless of whether or not it’s signed
    and regardless of whether its hash is in the `db` or `dbx` database.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x00000000** 始终信任该图像，无论其是否已签名，也无论其哈希是否在`db`或`dbx`数据库中。'
- en: '**0x00000001** Never trust the image. Even images with valid signatures will
    be rejected.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x00000001** 永远不信任该图像。即使图像有有效签名，也会被拒绝。'
- en: '**0x00000002** Allow execution when there is a security violation. The image
    will be executed even if the signature cannot be verified or if its hash is blacklisted
    in the `dbx` database.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x00000002** 允许在存在安全违规时执行。当签名无法验证或其哈希在`dbx`数据库中被列入黑名单时，仍然会执行该图像。'
- en: '**0x00000003** Defer execution when there is a security violation. In this
    case, the image isn’t rejected immediately and is loaded in memory. However, its
    execution is postponed until its authentication status is reevaluated.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x00000003** 在存在安全违规时推迟执行。在这种情况下，图像不会立即被拒绝，而是被加载到内存中。然而，直到重新评估其认证状态后，其执行才会被推迟。'
- en: '**0x00000004** Deny execution when Secure Boot fails to authenticate the image
    using the `db` and `dbx` databases.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x00000004** 在Secure Boot无法使用`db`和`dbx`数据库验证图像时拒绝执行。'
- en: '**0x00000005** Query the user when there is a security violation. In this case,
    if Secure Boot fails to authenticate the image, an authorized user may make a
    decision about whether to trust the image. For example, the user may be shown
    a message prompt at boot time.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x00000005** 在存在安全违规时询问用户。在这种情况下，如果Secure Boot无法验证图像，授权用户可以决定是否信任该图像。例如，用户在启动时可能会看到一个提示消息。'
- en: From the Secure Boot policy definitions, you can see that all the images loaded
    from SPI flash are inherently trusted and aren’t subject to digital signature
    verification at all. In all other cases, the default value of 0x000000004 enforces
    signature verification and prohibits the execution of any unauthenticated code
    that comes as Option ROM or that is located on removable, fixed, or any other
    media.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从Secure Boot策略定义中，你可以看到，从SPI闪存加载的所有图像天生是可信的，根本不需要进行数字签名验证。在所有其他情况下，默认值0x000000004
    强制执行签名验证，并禁止执行任何未经认证的代码，无论该代码是作为选项ROM加载的，还是位于可移动、固定或任何其他介质上。
- en: '***Protection Against Bootkits Using Secure Boot***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Secure Boot防止Bootkit***'
- en: Now that you’ve seen how Secure Boot works, let’s take a look at a specific
    example of how it protects against bootkits that target the OS boot flow. We won’t
    discuss bootkits that target the MBR and VBR, since, as [Chapter 14](ch14.xhtml#ch14)
    explained, UEFI firmware no longer uses objects like the MBR and VBR (except in
    the UEFI compatibility mode), so traditional bootkits cannot compromise UEFI-based
    systems.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了安全启动（Secure Boot）的工作原理，我们来看看一个具体的例子，了解它如何保护操作系统启动流程免受启动病毒（bootkit）的攻击。我们不会讨论针对MBR和VBR的启动病毒，因为正如[第14章](ch14.xhtml#ch14)所解释的那样，UEFI固件不再使用像MBR和VBR这样的对象（除非在UEFI兼容模式下），因此传统的启动病毒无法危害基于UEFI的系统。
- en: 'As mentioned in [Chapter 15](ch15.xhtml#ch15), the DreamBoot bootkit was the
    first public proof-of-concept bootkit targeting UEFI-based systems. On a UEFI
    system without Secure Boot in place, this bootkit works as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第15章](ch15.xhtml#ch15)所提到的，DreamBoot启动病毒是第一个公开的、针对UEFI系统的启动病毒概念验证。对于没有启用安全启动的UEFI系统，该启动病毒的工作方式如下：
- en: The author of the bootkit replaces the original UEFI Windows bootloader, *bootmgfw.efi*,
    with the malicious bootloader, *bootx64.efi*, on the boot partition.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动病毒的作者将原始的UEFI Windows启动加载器 *bootmgfw.efi* 替换为恶意启动加载器 *bootx64.efi*，并将其放置在启动分区中。
- en: The malicious bootloader loads the original *bootmgfw.efi*, patches it to get
    control of the Windows loader *winload.efi*, and executes it, as demonstrated
    in [Figure 17-9](ch17.xhtml#ch17fig09).![image](../images/17fig09.jpg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恶意启动加载器会加载原始的 *bootmgfw.efi*，并对其进行修补以控制Windows加载程序 *winload.efi*，然后执行它，正如在[图17-9](ch17.xhtml#ch17fig09)中所展示的那样。![image](../images/17fig09.jpg)
- en: '*Figure 17-9: The flow of the DreamBoot attack against the OS bootloader*'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图17-9：DreamBoot攻击操作系统启动加载器的流程*'
- en: The malicious code continues patching the system modules until it reaches the
    kernel of the operating system, bypassing the kernel protection mechanisms (such
    as the Kernel-Mode Code Signing Policy) intended to prevent unauthorized kernel-mode
    code execution.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恶意代码会继续修补系统模块，直到它达到操作系统的内核，绕过了旨在防止未授权内核模式代码执行的内核保护机制（例如内核模式代码签名策略）。
- en: This kind of attack is possible because, by default, the OS bootloader is not
    authenticated in the UEFI boot process. UEFI firmware obtains the location of
    the OS bootloader from a UEFI variable, which for Microsoft Windows platforms
    is located at *\EFI\Microsoft\Boot\bootmgfw.efi* on the boot partition. An attacker
    with system privileges can easily replace or alter the bootloader.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击之所以可能发生，是因为默认情况下，操作系统启动加载器在UEFI启动过程中没有经过身份验证。UEFI固件通过UEFI变量获取操作系统启动加载器的位置，对于Microsoft
    Windows平台来说，它位于启动分区的 *\EFI\Microsoft\Boot\bootmgfw.efi*。具有系统权限的攻击者可以轻松地替换或篡改启动加载器。
- en: However, when Secure Boot is enabled, this attack is no longer possible. Since
    Secure Boot verifies the integrity of UEFI images executed at boot time, and the
    OS bootloader is one of the executables verified during boot, Secure Boot will
    check the bootloader’s signature against the `db` and `dbx` databases. The malicious
    bootloader isn’t signed with a proper signing key, so it will potentially fail
    the checks and will not execute (depending on the boot policy). This is one way
    in which Secure Boot protects against bootkits.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当启用安全启动时，这种攻击就不再可能。由于安全启动会验证启动时执行的UEFI镜像的完整性，而操作系统启动加载器是启动时验证的可执行文件之一，安全启动将会检查启动加载器的签名是否符合
    `db` 和 `dbx` 数据库中的记录。恶意启动加载器没有使用正确的签名密钥，因此它可能会在检查时失败并无法执行（这取决于启动策略）。这是安全启动防止启动病毒的一种方式。
- en: '**Attacking Secure Boot**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**攻击安全启动**'
- en: Now let’s look at some attacks that can succeed against UEFI Secure Boot. Because
    Secure Boot relies on PI firmware and PKs as the root of trust, if either one
    of these components is compromised, the whole chain of Secure Boot checks becomes
    useless. We’ll look at both bootkits and rootkits capable of undermining Secure
    Boot.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些能够成功攻击UEFI安全启动的攻击方式。由于安全启动依赖PI固件和PK作为信任的根源，如果其中任何一个组件被破坏，整个安全启动检查链就会失效。我们将研究一些能够破坏安全启动的启动病毒和根病毒（rootkit）。
- en: The class of bootkits we’ll look at here relies predominantly on modifications
    of SPI flash content. In modern computer systems, SPI flash is often used as primary
    firmware storage. Almost every laptop and desktop computer will store UEFI firmware
    in flash memory that is accessed through an SPI controller.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的启动病毒主要依赖于对SPI闪存内容的修改。在现代计算机系统中，SPI闪存通常用作主要固件存储几乎每台笔记本电脑和台式计算机都会将UEFI固件存储在通过SPI控制器访问的闪存中。
- en: In [Chapter 15](ch15.xhtml#ch15), we presented various attacks that install
    persistent UEFI rootkits on flash firmware, so we won’t go into those details
    again here, though those same attacks (SMI handler issues, S3 boot script, BIOS
    write protection, and so on) may be leveraged against Secure Boot. For the attacks
    in this section, we’ll assume the attacker is already able to modify the contents
    of flash memory containing UEFI firmware. Let’s see what they can do next!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](ch15.xhtml#ch15)，我们介绍了各种将持久性UEFI rootkit安装到闪存固件中的攻击，因此在这里我们不再详细讨论这些内容，尽管相同的攻击（SMI处理程序问题、S3启动脚本、BIOS写保护等）可能会被用于攻击安全启动。本节中的攻击假设攻击者已经能够修改包含UEFI固件的闪存内容。接下来我们来看看他们可以做些什么！
- en: '***Patching PI Firmware to Disable Secure Boot***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修补PI固件以禁用安全启动***'
- en: Once an attacker is able to modify the contents of SPI flash, they can easily
    disable Secure Boot by patching the PI firmware. You saw in [Figure 17-8](ch17.xhtml#ch17fig08)
    that UEFI Secure Boot is anchored in the PI firmware, so if we alter the modules
    of the PI firmware that implement Secure Boot, we can effectively disable its
    functionality.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦攻击者能够修改SPI闪存的内容，他们可以通过修补PI固件轻松禁用安全启动。你在[图17-8](ch17.xhtml#ch17fig08)中看到，UEFI安全启动是基于PI固件的，因此如果我们修改实现安全启动的PI固件模块，就能有效地禁用其功能。
- en: To explore this process, we’ll once again use Intel’s EDK2 source code (*[https://github.com/tianocore/edk2/](https://github.com/tianocore/edk2/)*)
    as an example implementation of UEFI. You’ll find out where the Secure Boot verification
    functionality is implemented and how you might corrupt it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这个过程，我们将再次使用Intel的EDK2源代码（*[https://github.com/tianocore/edk2/](https://github.com/tianocore/edk2/)）作为UEFI实现的示例。你将了解安全启动验证功能的实现位置，以及如何可能会破坏它。
- en: Inside the *SecurityPkg/Library/DxeImageVerificationLib* folder in the repository,
    you’ll find the *DxeImageVerificationLib.c* source code file that implements the
    code integrity verification functionality. Specifically, this file implements
    the `DxeImageVerificationHandler` routine, which decides whether a UEFI executable
    is trusted and should be executed or whether it fails verification. [Listing 17-1](ch17.xhtml#ch17list01)
    shows the prototype of the routine.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库中的*SecurityPkg/Library/DxeImageVerificationLib*文件夹内，你会找到实现代码完整性验证功能的*DxeImageVerificationLib.c*源代码文件。具体来说，这个文件实现了`DxeImageVerificationHandler`例程，用于决定一个UEFI可执行文件是否被信任并应该被执行，或者它是否未通过验证。[列表17-1](ch17.xhtml#ch17list01)展示了该例程的原型。
- en: '[PRE2]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 17-1: Definition of the `DxeImageVerificationHandler` routine*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表17-1：`DxeImageVerificationHandler`例程的定义*'
- en: As a first parameter, the routine receives the `AuthenticationStatus` variable
    ➊, which indicates whether or not the image is signed. The `File` argument ➋ is
    a pointer to the device path of the file being dispatched. The `FileBuffer` ➌
    and `FileSize` ➍ arguments provide a pointer to the UEFI image and its size for
    verification.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个参数，例程接收`AuthenticationStatus`变量 ➊，它指示镜像是否已签名。`File`参数 ➋是指向正在分派的文件的设备路径的指针。`FileBuffer`
    ➌ 和 `FileSize` ➍ 参数提供指向UEFI镜像及其大小的指针，以便进行验证。
- en: Finally, `BootPolicy` ➎ is a parameter indicating whether the request to load
    the image being authenticated came from the UEFI boot manager and is a boot selection
    (meaning the image is a selected OS bootloader). We discussed the UEFI boot manager
    in more detail in [Chapter 14](ch14.xhtml#ch14).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`BootPolicy` ➎是一个参数，指示请求加载正在认证的镜像是否来自UEFI引导管理器，并且是一个启动选择（意味着该镜像是选定的操作系统引导加载程序）。我们在[第14章](ch14.xhtml#ch14)中更详细地讨论了UEFI引导管理器。
- en: 'Upon completion of the verification, this routine returns one of the following
    values:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证完成后，该例程返回以下值之一：
- en: EFI_SUCCESS Authentication has successfully passed and the image will be executed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: EFI_SUCCESS 认证成功，镜像将被执行。
- en: EFI_ACCESS_DENIED The image is not authenticated because the platform policy
    has dictated that the firmware may not use this image file. This may happen if
    the firmware attempts to load an image from a removable medium and the platform
    policy prohibits execution from removable media at boot time, regardless of whether
    or not they are signed. In this case, this routine will immediately return `EFI_ACCESS_DENIED`
    without any signature verification.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: EFI_ACCESS_DENIED 该镜像未通过认证，因为平台策略已规定固件不能使用该镜像文件。如果固件尝试从可移动介质加载镜像，而平台策略禁止在启动时从可移动介质执行，无论这些镜像是否已签名，都可能会发生这种情况。在这种情况下，该例程将立即返回`EFI_ACCESS_DENIED`，而不会进行任何签名验证。
- en: EFI_SECURITY_VIOLATION Authentication failed either because Secure Boot was
    unable to verify the image’s digital signature or because a hash value of the
    executable was found in the database of prohibited images (`dbx`). This return
    value indicates that the image is not trusted and the platform should follow the
    Secure Boot policy to determine whether the image may be executed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: EFI_SECURITY_VIOLATION 认证失败，原因是 Secure Boot 无法验证映像的数字签名，或者可执行文件的哈希值被发现存在于禁止映像的数据库（`dbx`）中。这个返回值表明映像不被信任，平台应遵循
    Secure Boot 策略来决定是否允许执行该映像。
- en: EFI_OUT_RESOURCE An error occurred during the verification process due to a
    lack of system resources (usually, not enough memory) to perform image authentication.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: EFI_OUT_RESOURCE 在验证过程中发生错误，原因是系统资源不足（通常是内存不足），无法执行映像认证。
- en: To bypass Secure Boot checks, an attacker with write access to the SPI flash
    can patch this routine to always return the `EFI_SUCCESS` value for whatever executable
    it takes as input. As a result, all the UEFI images will pass authentication regardless
    of whether they are signed or not.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过 Secure Boot 检查，具有 SPI 闪存写入权限的攻击者可以修改这个例程，使其始终返回 `EFI_SUCCESS` 值，不论输入的可执行文件是否有效。结果，所有
    UEFI 映像都会通过认证，无论它们是否已签名。
- en: '***Modifying the UEFI Variables to Bypass Security Checks***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修改 UEFI 变量以绕过安全检查***'
- en: Another way to attack the Secure Boot implementation is to modify the UEFI NVRAM
    variables. As we discussed earlier in this chapter, Secure Boot uses certain variables
    to store its configuration parameters, details like whether Secure Boot is enabled,
    the PKs and KEKs, the signature databases, and the platform policies. If an attacker
    can modify these variables, they can disable or bypass Secure Boot verification
    checks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击 Secure Boot 实现的另一种方式是修改 UEFI NVRAM 变量。如本章前面所述，Secure Boot 使用某些变量来存储其配置参数，诸如
    Secure Boot 是否启用、PK 和 KEK、签名数据库以及平台策略等详细信息。如果攻击者能够修改这些变量，他们可以禁用或绕过 Secure Boot
    验证检查。
- en: Indeed, most implementations of Secure Boot will store UEFI NVRAM variables
    in SPI flash memory alongside the system firmware. Even though these variables
    are authenticated, and changing their values from the kernel mode by using the
    UEFI API requires a corresponding private key, an attacker capable of writing
    to SPI flash could change their content.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，大多数 Secure Boot 实现会将 UEFI NVRAM 变量存储在 SPI 闪存中，与系统固件一起使用。尽管这些变量是经过认证的，并且通过使用
    UEFI API 从内核模式更改它们的值需要相应的私钥，但具有写入 SPI 闪存权限的攻击者仍然可以更改其内容。
- en: Once an attacker has access to the UEFI NVRAM variables, they could, for example,
    tamper with `PK`, `KEK`, `db`, and `dbx` to add custom malicious certificates,
    which would allow a malicious module to bypass security checks. Another option
    would be to add the hash of the malicious file to the `db` database and remove
    it from the `dbx` database (in the case that the hash was originally in the `dbx`
    database). As shown in [Figure 17-10](ch17.xhtml#ch17fig10), by changing the `PK`
    variable to include the attacker’s public key certificate, the attacker is able
    to add and remove KEKs from the `KEK` UEFI variable, which, in turn, gives them
    control over the `db` and `dbx` signature databases, breaking Secure Boot protection.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦攻击者访问了 UEFI NVRAM 变量，他们可以例如篡改 `PK`、`KEK`、`db` 和 `dbx`，添加自定义的恶意证书，从而允许恶意模块绕过安全检查。另一种方式是将恶意文件的哈希值添加到
    `db` 数据库，并将其从 `dbx` 数据库中移除（如果该哈希值最初在 `dbx` 数据库中）。如[图 17-10](ch17.xhtml#ch17fig10)所示，通过更改
    `PK` 变量以包含攻击者的公钥证书，攻击者能够在 `KEK` UEFI 变量中添加和删除 KEK，从而控制 `db` 和 `dbx` 签名数据库，突破 Secure
    Boot 保护。
- en: '![image](../images/17fig10.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig10.jpg)'
- en: '*Figure 17-10: Attack against the UEFI Secure Boot chain of trust*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-10：针对 UEFI Secure Boot 信任链的攻击*'
- en: As a third option, instead of changing the PK and compromising the underlying
    PKI hierarchy, an attacker could simply corrupt the PK in the UEFI variable. In
    order to work, Secure Boot requires a valid PK enrolled into the platform firmware;
    otherwise, protection is disabled.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第三种选择，攻击者可以直接破坏 UEFI 变量中的 PK，而不必更改 PK 或妥协底层的 PKI 层级。为了正常工作，Secure Boot 需要一个有效的
    PK 被注册到平台固件中；否则，保护机制将被禁用。
- en: 'If you’re interested in learning more about these attacks, the following conference
    papers contain comprehensive analyses of UEFI Secure Boot technology:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些攻击感兴趣，以下会议论文对 UEFI Secure Boot 技术进行了全面分析：
- en: 'Corey Kallenberg et al., “Setup for Failure: Defeating Secure Boot,” LegbaCore,
    *[https://papers.put.as/papers/firmware/2014/SetupForFailure-syscan-v4.pdf](https://papers.put.as/papers/firmware/2014/SetupForFailure-syscan-v4.pdf)*.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Corey Kallenberg 等人，"Setup for Failure: Defeating Secure Boot"，LegbaCore，*
    [https://papers.put.as/papers/firmware/2014/SetupForFailure-syscan-v4.pdf](https://papers.put.as/papers/firmware/2014/SetupForFailure-syscan-v4.pdf)*。'
- en: Yuriy Bulygin et al., “Summary of Attacks Against BIOS and Secure Boot,” Intel
    Security, *[http://www.c7zero.info/stuff/DEFCON22-BIOSAttacks.pdf](http://www.c7zero.info/stuff/DEFCON22-BIOSAttacks.pdf)*.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yuriy Bulygin 等人，"Summary of Attacks Against BIOS and Secure Boot"，英特尔安全，* [http://www.c7zero.info/stuff/DEFCON22-BIOSAttacks.pdf](http://www.c7zero.info/stuff/DEFCON22-BIOSAttacks.pdf)*。
- en: '**Protecting Secure Boot with Verified and Measured Boot**'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过验证启动和度量启动保护安全启动**'
- en: As we’ve just discussed, Secure Boot alone is not capable of protecting against
    attacks that involve changes in platform firmware. So is there any protection
    for Secure Boot technology itself? The answer is yes. In this section, we’ll focus
    on security technologies intended to protect system firmware against unauthorized
    modifications—namely, Verified and Measured Boot. *Verified Boot* checks that
    the platform firmware hasn’t been altered or modified, while *Measured Boot* computes
    cryptographic hashes of certain components involved in the boot process and stores
    them in Trusted Platform Module Platform Configuration Registers, or TPM PCRs.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才讨论的，单靠安全启动无法防范涉及平台固件变化的攻击。那么，是否有任何保护措施来保护安全启动技术本身呢？答案是肯定的。在本节中，我们将重点介绍旨在保护系统固件免受未经授权修改的安全技术——即验证启动和度量启动。*验证启动*检查平台固件是否未被篡改或修改，而*度量启动*计算启动过程中涉及的某些组件的加密哈希，并将其存储在受信任平台模块平台配置寄存器（TPM
    PCR）中。
- en: Verified Boot and Measured Boot function independently, and it’s possible to
    have platforms with only one of them enabled, or with both. However, both Verified
    Boot and Measured Boot are part of the same chain of trust (as shown in [Figure
    17-11](ch17.xhtml#ch17fig11)).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 验证启动和度量启动是独立运作的，因此有可能只启用其中一个，或同时启用两者。然而，验证启动和度量启动都属于同一信任链的一部分（如[图17-11](ch17.xhtml#ch17fig11)所示）。
- en: '![image](../images/17fig11.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig11.jpg)'
- en: '*Figure 17-11: Verified and Measured Boot flow*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-11：验证启动和度量启动流程*'
- en: As you saw in [Figure 17-8](ch17.xhtml#ch17fig08), the PI firmware is the very
    first piece of code executed after the CPU comes out of reset. UEFI Secure Boot
    unconditionally trusts the PI firmware, so it makes sense that current attacks
    against Secure Boot rely on unauthorized modifications of it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图17-8](ch17.xhtml#ch17fig08)所示，PI固件是在CPU复位后执行的第一段代码。UEFI安全启动无条件信任PI固件，因此当前对安全启动的攻击依赖于对其的未经授权的修改，这一点是可以理解的。
- en: In order to protect against such attacks, the system needs a root of trust *outside*
    the PI firmware. This is where Verified and Measured Boot come into play. These
    processes execute protection mechanisms whose root of trust is anchored in the
    hardware. Moreover, they execute before the system firmware, which means they
    are able to both authenticate *and* measure it. We’ll discuss what measurement
    means in this context in a moment.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防范此类攻击，系统需要一个位于PI固件*之外*的信任根。这就是验证启动（Verified Boot）和度量启动（Measured Boot）发挥作用的地方。这些过程执行的保护机制，其信任根被锚定在硬件中。而且，它们在系统固件之前执行，这意味着它们既能认证*又能*度量系统固件。稍后我们将讨论在这个背景下“度量”意味着什么。
- en: '***Verified Boot***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***验证启动***'
- en: When a system with Verified Boot is powered on, the hardware logic launches
    the boot verification functionality that’s implemented in a boot ROM or microcode
    within the CPU. This logic is *immutable*, which means software can’t change it.
    Usually, Verified Boot executes a module to verify the integrity of the system,
    ensuring that the system will execute the authentic firmware without malicious
    modifications. To verify the firmware, Verified Boot relies on public key cryptography;
    like UEFI Secure Boot, it checks the digital signature of the platform firmware
    to ensure its authenticity. After it’s been successfully authenticated, the platform
    firmware is executed and proceeds to verify other firmware components (for example,
    the Option ROMs, DXE drivers, and OS bootloaders) to maintain the proper chain
    of trust. That’s the Verified portion of Verified and Measured Boot. Now for the
    Measured part.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用验证启动的系统通电时，硬件逻辑会启动实现于启动 ROM 或 CPU 内的微代码中的启动验证功能。这个逻辑是*不可变的*，这意味着软件无法更改它。通常，验证启动会执行一个模块来验证系统的完整性，确保系统将执行未经恶意修改的真实固件。为了验证固件，验证启动依赖于公钥加密技术；与
    UEFI 安全启动类似，它会检查平台固件的数字签名，以确保其真实性。成功认证后，平台固件被执行并继续验证其他固件组件（例如，选项 ROM、DXE 驱动程序和操作系统引导加载程序）以保持正确的信任链。这就是“验证启动”中“验证”部分的内容。现在我们来看看“度量启动”部分。
- en: '***Measured Boot***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***度量启动***'
- en: Measured Boot works by measuring the platform firmware and OS bootloaders. This
    means it computes the cryptographic hashes of the components involved in the boot
    process. The hashes are stored in a set of TPM PCRs. The hash values themselves
    don’t tell you if the measured components are benign or malicious, but they do
    tell you whether the configuration and boot components have been changed at some
    point. If a boot component has been modified, its hash value will differ from
    the one computed over the original version of the boot component. Thus, Measured
    Boot will notice any modification of the boot component.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 度量启动通过测量平台固件和操作系统引导加载程序来工作。这意味着它会计算启动过程相关组件的加密哈希值。这些哈希值存储在一组 TPM PCR 中。哈希值本身并不能告诉你所测量的组件是良性的还是恶意的，但它们确实告诉你配置和启动组件是否在某个时刻发生过更改。如果某个启动组件被修改，其哈希值将与对原始版本组件计算出的哈希值不同。因此，度量启动将注意到任何启动组件的修改。
- en: Later, the system software can use the hashes in these TPM PCRs to ensure the
    system is running in a known good state without any malicious modifications. The
    system might also use these hashes for *remote attestation*, which is when a system
    tries to prove to another system that it’s in a trusted state.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 后续，系统软件可以使用这些 TPM PCR 中的哈希值来确保系统处于一个已知的良好状态，没有任何恶意修改。系统还可以使用这些哈希值进行*远程证明*，即当一个系统试图向另一个系统证明它处于一个受信状态时。
- en: Now that you know how Verified and Measured Boot work in general, let’s take
    a look at a couple implementations of it, starting with Intel BootGuard.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了验证启动和度量启动的一般工作原理，接下来我们来看看它的几种实现方式，首先是英特尔 BootGuard。
- en: '**Intel BootGuard**'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**英特尔 BootGuard**'
- en: Intel BootGuard is Intel’s Verified and Measured Boot technology. [Figure 17-12](ch17.xhtml#ch17fig12)
    shows the boot flow on a platform with Intel BootGuard enabled.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔 BootGuard 是英特尔的验证启动和度量启动技术。[图 17-12](ch17.xhtml#ch17fig12) 显示了启用英特尔 BootGuard
    的平台上的启动流程。
- en: '![image](../images/17fig12.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig12.jpg)'
- en: '*Figure 17-12: The Intel BootGuard flow*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-12：英特尔 BootGuard 流程*'
- en: During initialization, before the CPU starts executing the first code located
    at the reset vector, it executes code from the boot ROM. This code performs the
    necessary initialization of the CPU state, then loads and executes the BootGuard
    *Authenticated Code Module (ACM)*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化期间，在 CPU 开始执行位于复位向量的第一段代码之前，它会执行启动 ROM 中的代码。这段代码执行必要的 CPU 状态初始化，然后加载并执行
    BootGuard *认证代码模块 (ACM)*。
- en: The ACM is a special type of module for performing security-sensitive operations
    and must be signed by Intel. Thus, the boot ROM code that loads the ACM performs
    mandatory signature verification to keep the module from running unless it’s signed
    by Intel. After successful signature verification, the ACM is executed in an isolated
    environment in order to prevent any malicious software from interfering with its
    execution.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ACM 是一种用于执行安全敏感操作的特殊模块，必须由英特尔签名。因此，加载 ACM 的启动 ROM 代码会执行强制签名验证，除非 ACM 由英特尔签名，否则模块无法运行。成功通过签名验证后，ACM
    会在隔离的环境中执行，以防止任何恶意软件干扰其执行。
- en: The BootGuard ACM implements Verified and Measured Boot functionality. This
    module loads the first-stage firmware loader, called the initial boot block (IBB),
    into memory and, depending on the boot policy in effect, verifies and/or measures
    it. The IBB is part of the firmware that contains code executed at the reset vector.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: BootGuard ACM 实现了验证和测量启动功能。此模块将第一阶段固件加载器，即初始启动块（IBB），加载到内存中，并根据当前的启动策略对其进行验证和/或测量。IBB
    是固件的一部分，包含在重置向量处执行的代码。
- en: Strictly speaking, at this point in the boot process there is no RAM. The memory
    controller hasn’t yet been initialized, and RAM isn’t accessible. However, the
    CPU configures its last-level cache so that it can be used as RAM by putting it
    in Cache-as-RAM mode until the point in the boot process when the BIOS memory
    reference code can configure the memory controller and discover RAM.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，在启动过程中，此时还没有 RAM。内存控制器尚未初始化，RAM 也不可访问。然而，CPU 会配置其最后一级缓存，使其可以被用作 RAM，通过将其设置为
    Cache-as-RAM 模式，直到启动过程中的某个时刻，BIOS 内存引用代码可以配置内存控制器并发现 RAM。
- en: 'The ACM transfers control to the IBB once the IBB is successfully verified
    and/or measured. If the IBB fails verification, the ACM behaves according to whatever
    boot policy is in effect: the system may be shut down immediately or allow firmware
    recovery after a certain timeout.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 IBB 成功验证和/或测量完毕，ACM 会将控制权转交给 IBB。如果 IBB 验证失败，ACM 会根据当前的启动策略进行处理：系统可能会立即关闭，或者在某个超时后允许固件恢复。
- en: The IBB then loads the rest of the UEFI firmware from SPI flash and verifies
    and/or measures it. Once the IBB receives control, Intel BootGuard is no longer
    responsible for maintaining the proper chain of trust, since its purpose is simply
    to verify and measure the IBB. The IBB is responsible for continuing the chain
    of trust up the point when UEFI Secure Boot takes over the verification and measuring
    of firmware images.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，IBB 从 SPI 闪存加载其余的 UEFI 固件，并对其进行验证和/或测量。一旦 IBB 获得控制，Intel BootGuard 就不再负责维持正确的信任链，因为它的目的仅仅是验证和测量
    IBB。IBB 负责继续信任链，直到 UEFI 安全启动接管固件镜像的验证和测量。
- en: '***Finding the ACM***'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***寻找 ACM***'
- en: 'Let’s look at the implementation details of Intel BootGuard technology for
    desktop platforms, starting with the ACM. Since the ACM is one of the first Intel
    BootGuard components executed when the system is powered up, the first question
    is: how does the CPU find the ACM when it is powered on?'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 ACM 开始，了解 Intel BootGuard 技术在桌面平台上的实现细节。由于 ACM 是系统开机时执行的第一个 Intel BootGuard
    组件之一，第一个问题是：CPU 在开机时如何找到 ACM？
- en: The exact location of the ACM is provided in a special data structure called
    the *Firmware Interface Table (FIT)*, stored in the firmware image. The FIT is
    organized as an array of FIT entries, each describing the location of a specific
    object in the firmware, such as the ACM or microcode update files. [Figure 17-13](ch17.xhtml#ch17fig13)
    shows the layout of a FIT in system memory after reset.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ACM 的确切位置存储在一种特殊的数据结构中，称为 *固件接口表（FIT）*，它存储在固件镜像中。FIT 被组织为 FIT 条目的数组，每个条目描述固件中特定对象的位置，如
    ACM 或微代码更新文件。[图 17-13](ch17.xhtml#ch17fig13) 显示了重置后 FIT 在系统内存中的布局。
- en: '![image](../images/17fig13.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig13.jpg)'
- en: '*Figure 17-13: The FIT’s location in memory*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-13：FIT 在内存中的位置*'
- en: When the CPU is powered on, it reads the address of the FIT from the memory
    location 0xFFFFFFC0 ➊. Since there’s no RAM yet, when the CPU posts a read memory
    transaction for the physical address 0xFFFFFFC0, the internal chipset logic recognizes
    that this address belongs to a special address range and, instead of sending this
    transaction to the memory controller, decodes it. Read memory transactions for
    the FIT table are forwarded to the SPI flash controller, which reads FIT from
    flash memory.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当 CPU 开机时，它会从内存地址 0xFFFFFFC0 ➊ 读取 FIT 的地址。由于此时还没有 RAM，当 CPU 对物理地址 0xFFFFFFC0
    发出读取内存事务时，内部芯片组逻辑会识别该地址属于特殊地址范围，因此不会将该事务发送给内存控制器，而是解码它。对 FIT 表的读取内存事务将被转发到 SPI
    闪存控制器，由其从闪存中读取 FIT。
- en: We’ll take a closer look at this process by returning to the EDK2 repository.
    In the *IntelSiliconPkg/Include/IndustryStandard/* directory, you’ll find the
    *FirmwareInterfaceTable.h* header file, which contains some code definitions related
    to the FIT structure. The layout of FIT entries is shown in [Listing 17-2](ch17.xhtml#ch17list02).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过返回到EDK2仓库来更详细地了解这个过程。在*IntelSiliconPkg/Include/IndustryStandard/*目录中，您将找到*FirmwareInterfaceTable.h*头文件，其中包含与FIT结构相关的一些代码定义。FIT条目的布局请参见[Listing
    17-2](ch17.xhtml#ch17list02)。
- en: '[PRE3]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 17-2: Layout of FIT entries*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 17-2：FIT条目的布局*'
- en: 'As mentioned, each FIT entry describes a certain object in the firmware image.
    The nature of each object is encoded in the FIT’s `Type` field. These objects
    could be microcode update files, a BootGuard’s ACM, or a BootGuard policy, for
    instance. The `Address` field ➊ and `Size` field ➋ provide the location of the
    object in memory: `Address` contains the physical address of the object, and `Size`
    defines the size expressed in `dword`s (4-byte values). The `C_V` field ➎ is the
    checksum valid field; if it’s set to `1`, the `Chksum` field ➏ contains a valid
    checksum of the object. The sum of all the bytes in the component modulo 0xFF
    and the value in the `Chksum` field must be zero. The `Version` field ➌ contains
    the version number of the component in binary-coded decimal format. For the FIT
    header entry, the value in this field will indicate the revision number of the
    FIT data structure.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个FIT条目描述了固件镜像中的某个对象。每个对象的性质由FIT的`Type`字段编码。这些对象可能是微代码更新文件、BootGuard的ACM，或者BootGuard策略等。例如，`Address`字段➊和`Size`字段➋提供了该对象在内存中的位置：`Address`包含该对象的物理地址，而`Size`定义了以`dword`（4字节值）为单位的大小。`C_V`字段➎是校验和有效字段；如果该字段为`1`，则`Chksum`字段➏包含该对象的有效校验和。组件中所有字节的和对0xFF取模后的结果与`Chksum`字段中的值必须为零。`Version`字段➌包含组件的版本号，采用二进制编码的十进制格式。对于FIT头条目，该字段的值将指示FIT数据结构的修订号。
- en: 'The header *FirmwareInterfaceTable.h* contains values that the `Type` field
    ➍ can take. These type values are mostly undocumented, with little information
    available, but the definitions of FIT entry types are quite verbose, and you can
    deduce their meanings from the context. Here are the types relevant to BootGuard:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件*FirmwareInterfaceTable.h*包含了`Type`字段➍可能取的值。这些类型值大多没有文档说明，信息较少，但FIT条目类型的定义相当详细，您可以从上下文中推断它们的含义。以下是与BootGuard相关的类型：
- en: The `FIT_TYPE_00_HEADER` entry provides the total number of FIT entries in the
    FIT table in its `Size` field. Its address field contains a special 8-byte signature,
    `'_FIT_'` (there are three spaces after `_FIT_`).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIT_TYPE_00_HEADER`条目在其`Size`字段中提供FIT表中条目的总数。其地址字段包含一个特殊的8字节签名，`''_FIT_''`（`_FIT_`后有三个空格）。'
- en: The entry of type `FIT_TYPE_02_STARTUP_ACM` provides the location of the BootGuard
    ACM, which the boot ROM code parses to locate the ACM in system memory.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为`FIT_TYPE_02_STARTUP_ACM`的条目提供了BootGuard ACM的位置，启动ROM代码解析该位置以在系统内存中找到ACM。
- en: The entries of types `FIT_TYPE_0C_BOOT_POLICY_MANIFEST` (BootGuard boot policy
    manifest) and `FIT_TYPE_0B_KEY_MANIFEST` (BootGuard key manifest) provide BootGuard
    with the boot policy that’s in effect and the configuration information, which
    we’ll discuss shortly in “[Configuring Intel BootGuard](ch17.xhtml#ch17lev2sec16)”
    on [page 343](ch17.xhtml#page_343).
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIT_TYPE_0C_BOOT_POLICY_MANIFEST`（BootGuard启动策略清单）和`FIT_TYPE_0B_KEY_MANIFEST`（BootGuard密钥清单）类型的条目提供了当前生效的BootGuard启动策略和配置信息，我们将在稍后的“[配置Intel
    BootGuard](ch17.xhtml#ch17lev2sec16)”中讨论这些内容，见[第343页](ch17.xhtml#page_343)。'
- en: Keep in mind that the Intel BootGuard boot policy and the UEFI Secure Boot policy
    are two different things. The first term refers to the boot policy used for the
    Verified and Measured Boot procedures. That is, Intel BootGuard boot policy is
    enforced by ACM and chipset logic, and it includes parameters like whether BootGuard
    should perform Verified and Measured Boot and what BootGuard should do in cases
    when it fails to authenticate the IBB. The second term refers to UEFI Secure Boot,
    discussed earlier in this chapter, and is entirely enforced by UEFI firmware.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Intel BootGuard启动策略和UEFI Secure Boot策略是两个不同的概念。第一个术语指的是用于验证和度量启动过程的启动策略。也就是说，Intel
    BootGuard启动策略由ACM和芯片组逻辑执行，其中包括是否应执行验证和度量启动以及当BootGuard无法验证IBB时应采取什么措施等参数。第二个术语指的是本章早些时候讨论的UEFI
    Secure Boot，完全由UEFI固件执行。
- en: '***Exploring FIT***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***探索FIT***'
- en: You can explore some FIT entries in the firmware image using UEFITool, which
    we introduced in [Chapter 15](ch15.xhtml#ch15) (and which we’ll discuss more in
    [Chapter 19](ch19.xhtml#ch19)), and extract the ACM from the image, along with
    the boot policy and key manifests, for further analysis. This can be useful because
    the ACM can be used to hide malicious code. In the following example, we use a
    firmware image obtained from a system with Intel BootGuard technology enabled.
    ([Chapter 19](ch19.xhtml#ch19) provides information on how to acquire a firmware
    from the platform.)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用UEFITool浏览固件镜像中的一些FIT条目，我们在[第15章](ch15.xhtml#ch15)中介绍过它（并且我们将在[第19章](ch19.xhtml#ch19)中进一步讨论），并从镜像中提取ACM、启动策略和密钥清单以进行进一步分析。这是有用的，因为ACM可以用来隐藏恶意代码。在下面的示例中，我们使用从启用了Intel
    BootGuard技术的系统中获取的固件镜像。（[第19章](ch19.xhtml#ch19)提供了如何从平台获取固件的信息。）
- en: First, load the firmware image in UEFITool by selecting **File**▸**Open Image
    File**. After specifying the firmware image file to load, you’ll see a window
    like the one shown in [Figure 17-14](ch17.xhtml#ch17fig14).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在UEFITool中加载固件镜像，方法是选择**文件**▸**打开镜像文件**。在指定要加载的固件镜像文件后，你将看到一个像[图17-14](ch17.xhtml#ch17fig14)所示的窗口。
- en: '![image](../images/17fig14.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig14.jpg)'
- en: '*Figure 17-14: Browsing FIT in UEFITool*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-14：在UEFITool中浏览FIT*'
- en: 'In the lower half of the window, you can see the FIT tab that lists the entries.
    The `Type` column of the FIT tab displays the type of FIT entries. We are looking
    for FIT entries for the types BIOS ACM, BootGuard key manifest, and BootGuard
    Boot Policy. Using that information, we can locate the Intel BootGuard components
    in the firmware image and extract them for further analysis. In this particular
    example, FIT entry #6 indicates the location of the BIOS ACM; it starts at the
    address 0xfffc0000\. FIT entries #7 and #8 indicate the locations of the key and
    boot policy manifests; they start at the addresses 0xfffc9180 and 0xfffc8100,
    respectively.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口的下半部分，你可以看到列出条目的FIT标签。FIT标签的`Type`列显示FIT条目的类型。我们正在寻找BIOS ACM、BootGuard密钥清单和BootGuard启动策略类型的FIT条目。根据这些信息，我们可以在固件镜像中定位Intel
    BootGuard组件并提取它们进行进一步分析。在这个特定示例中，FIT条目#6指示BIOS ACM的位置；它从地址0xfffc0000开始。FIT条目#7和#8分别指示密钥和启动策略清单的位置；它们分别从地址0xfffc9180和0xfffc8100开始。
- en: '***Configuring Intel BootGuard***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置Intel BootGuard***'
- en: Upon execution, the BootGuard BIOS ACM consumes the BootGuard key, while the
    boot policy locates the IBB in the system memory to obtain the correct public
    key to verify the IBB’s signature.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，BootGuard BIOS ACM会消耗BootGuard密钥，而启动策略则定位系统内存中的IBB，以获取正确的公钥来验证IBB的签名。
- en: The BootGuard key manifest contains the hash of the boot policy manifest (BPM),
    the OEM root public key, the digital signature of the preceding fields (with the
    exception of the root public key, which isn’t included in the signed data), and
    the security version number (a counter that is incremented with every security
    update, intended to prevent rollback attacks).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: BootGuard密钥清单包含启动策略清单（BPM）的哈希、OEM根公钥、前述字段的数字签名（根公钥除外，因为它不包含在签名数据中）以及安全版本号（一个随着每次安全更新递增的计数器，旨在防止回滚攻击）。
- en: 'The BPM itself contains the security version number, location, and hash of
    the IBB; the BPM public key; and digital signatures for the BPM fields just listed—again,
    with the exception of the root public key, which may be validated with the BPM
    public key. The location of the IBB provides the layout of the IBB in memory.
    This may not be in a contiguous memory block; it could consist instead of a few
    nonadjacent memory regions. The IBB hash contains the cumulative hash value of
    all the memory regions occupied by the IBB. Thus, the whole process of verifying
    the IBB’s signature is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: BPM本身包含IBB的安全版本号、位置和哈希值；BPM公钥；以及刚才列出的BPM字段的数字签名——除了根公钥，根公钥可以通过BPM公钥验证。IBB的位置提供了IBB在内存中的布局。这可能不是一个连续的内存块；它可能由几个不相邻的内存区域组成。IBB哈希包含IBB占用的所有内存区域的累计哈希值。因此，验证IBB签名的整个过程如下：
- en: BootGuard locates the key manifest (KM) using FIT and obtains the boot policy
    manifest hash value and the OEM root key, which we’ll call key 1\. BootGuard verifies
    the digital signature in the KM using key 1 to ensure the integrity of the BPM
    hash value. If the verification fails, BootGuard reports an error and triggers
    remediation actions.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BootGuard使用FIT定位密钥清单（KM），获取启动策略清单的哈希值和OEM根密钥，我们称之为密钥1。BootGuard使用密钥1验证KM中的数字签名，以确保BPM哈希值的完整性。如果验证失败，BootGuard会报告错误并触发修复操作。
- en: If the verification succeeds, BootGuard locates the BPM using FIT, computes
    a hash value of the BPM, and compares it with the BPM hash in the KM. If the values
    aren’t equal, BootGuard reports an error and triggers remediation actions; otherwise,
    it obtains the IBB hash value and location from the BPM.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果验证成功，BootGuard将使用FIT定位BPM，计算BPM的哈希值，并将其与KM中的BPM哈希值进行比较。如果值不相等，BootGuard会报告错误并触发修复操作；否则，它将从BPM获取IBB的哈希值和位置。
- en: BootGuard locates the IBB in memory, computes its cumulative hash, and compares
    it with the IBB hash value in the BPM. If the hashes aren’t equal, BootGuard reports
    an error and triggers remediation actions.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BootGuard定位IBB在内存中的位置，计算其累积哈希值，并将其与BPM中的IBB哈希值进行比较。如果哈希值不相等，BootGuard会报告错误并触发修复操作。
- en: Otherwise, BootGuard reports that the verification succeeded. If Measured Boot
    is enabled, BootGuard also measures the IBB by calculating its hash and stores
    the measurement in the TPM. Then BootGuard transfers control to the IBB.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，BootGuard会报告验证成功。如果启用了度量启动，BootGuard还会通过计算IBB的哈希值并将度量结果存储在TPM中来度量IBB。然后，BootGuard将控制权转交给IBB。
- en: The KM is an essential structure, as it contains the OEM root public key used
    to verify the integrity of the IBB. You might be asking, “If BootGuard’s KM is
    stored in unprotected SPI flash along with firmware image, doesn’t that mean attackers
    can modify it in flash to provide BootGuard with a fake verification key?” To
    prevent an attack like this, the hash of the OEM root public key is instead stored
    in the chipset’s *field-programmable fuses*. These fuses can be programmed only
    once, at the point when the BootGuard boot policy is provisioned. Once the fuses
    are written, it’s impossible to override them. This is how the BootGuard verification
    key is anchored in the hardware, making the hardware the immutable root of trust.
    (The BootGuard boot policy is stored in chipset fuses as well, making it impossible
    to alter the policy after the fact.)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: KM是一个关键结构，因为它包含用于验证IBB完整性的OEM根公钥。你可能会问：“如果BootGuard的KM和固件映像一起存储在未保护的SPI闪存中，那是不是意味着攻击者可以修改闪存中的内容，给BootGuard提供一个假的验证密钥？”为了防止此类攻击，OEM根公钥的哈希值存储在芯片组的*现场可编程保险丝*中。这些保险丝只能在BootGuard启动策略配置时编程一次。保险丝一旦写入，就无法被覆盖。这就是BootGuard验证密钥如何被锚定在硬件中，使硬件成为不可变的信任根。（BootGuard启动策略也存储在芯片组的保险丝中，因此在启动策略配置后无法更改该策略。）
- en: If an attacker changes the BootGuard key manifest, the ACM will spot the key
    alteration by computing its hash and comparing it with the “golden” value fused
    into the chipset. Mismatched hashes trigger an error report and remediation behavior.
    [Figure 17-15](ch17.xhtml#ch17fig15) demonstrates the chain of trust enforced
    by BootGuard.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者更改了BootGuard密钥清单，ACM将通过计算其哈希值并将其与“黄金”值进行比较来检测密钥的更改，这个“黄金”值被写入芯片组中。哈希不匹配会触发错误报告和修复行为。[图17-15](ch17.xhtml#ch17fig15)展示了BootGuard强制执行的信任链。
- en: '![image](../images/17fig15.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig15.jpg)'
- en: '*Figure 17-15: The Intel BootGuard chain of trust*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-15：英特尔BootGuard信任链*'
- en: Once the IBB is successfully verified and, if necessary, measured, it executes
    and performs some basic chipset initialization, then loads the UEFI firmware.
    At this point, it is the IBB’s responsibility to authenticate the UEFI firmware
    before loading and executing it. Otherwise, the chain of trust will be broken.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦IBB成功验证，并在必要时进行测量，它将执行一些基本的芯片组初始化，然后加载UEFI固件。在此时，IBB有责任在加载和执行固件之前对UEFI固件进行身份验证。否则，信任链将被打破。
- en: '[Figure 17-16](ch17.xhtml#ch17fig16) concludes this section by representing
    the boundaries of responsibility for Secure Boot implementations.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17-16](ch17.xhtml#ch17fig16)通过展示安全启动实现的责任边界来总结本节内容。'
- en: '![image](../images/17fig16.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig16.jpg)'
- en: '*Figure 17-16: The boundaries of responsibility for Secure Boot implementation*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-16：安全启动实现的责任边界*'
- en: '**ARM Trusted Boot Board**'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**ARM可信启动板**'
- en: ARM has its own implementation of Verified and Measured Boot technology, called
    the *Trusted Boot Board (TBB)*, or simply *Trusted Boot*. In this section, we’ll
    look at Trusted Boot’s design. ARM has a very particular setup, known as *Trust
    Zone* security technology, that divides the execution environment into two parts.
    Before we go into the Verified and Measured Boot process with ARM, we need to
    describe how Trust Zone works.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 有自己实现的验证和度量引导技术，称为*受信引导板（TBB）*，简称*受信引导*。在本节中，我们将探讨受信引导的设计。ARM 有一种非常特定的设置，称为*Trust
    Zone* 安全技术，将执行环境分为两个部分。在介绍 ARM 的验证和度量引导过程之前，我们需要描述 Trust Zone 的工作原理。
- en: '***ARM Trust Zone***'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ARM Trust Zone***'
- en: 'Trust Zone security technology is a hardware-implemented security feature that
    separates the ARM execution environment into two *worlds*: the secure world and
    the normal (or nonsecure) world, which coexist on the same physical core, as shown
    in [Figure 17-17](ch17.xhtml#ch17fig17). The logic implemented in the processor’s
    hardware and firmware ensures that the secure world’s resources are properly isolated
    and protected from software running in the nonsecure world.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Trust Zone 安全技术是一种硬件实现的安全特性，它将 ARM 执行环境分为两个*世界*：安全世界和普通（或非安全）世界，这两个世界共存于同一个物理核心中，如[图
    17-17](ch17.xhtml#ch17fig17)所示。处理器硬件和固件中实现的逻辑确保安全世界的资源与在非安全世界中运行的软件正确隔离并得到保护。
- en: '![image](../images/17fig17.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig17.jpg)'
- en: '*Figure 17-17: The ARM Trust Zone*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-17：ARM Trust Zone*'
- en: 'Both worlds have their own dedicated and distinct firmware and software stacks:
    the normal world executes user applications and an OS, while the secure world
    executes a secure OS and trusted services. The firmware of these worlds consists
    of different bootloaders responsible for initializing the world and loading the
    OS, which we’ll talk about in a moment. For this reason, the secure and normal
    worlds have different firmware images.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 两个世界各自拥有独立的固件和软件栈：普通世界执行用户应用程序和操作系统，而安全世界执行安全操作系统和受信服务。这些世界的固件由不同的引导加载程序组成，负责初始化各自的世界并加载操作系统，我们稍后会谈到。因此，安全世界和普通世界具有不同的固件镜像。
- en: Within the processor, software running in the normal world cannot access code
    and data in the secure world directly. The access control logic that prevents
    this is implemented in the hardware, usually in the System on Chip hardware. However,
    software running in the normal world can transfer control to the software located
    in the secure world (for instance, to execute a trusted service in the secure
    world) using particular software called Secure Monitor (in ARM Cortex-A) or core
    logic (in ARM Cortex-M). This mechanism ensures that switches between worlds don’t
    violate the security of the system.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理器内部，运行在普通世界中的软件无法直接访问安全世界中的代码和数据。防止这种访问的控制逻辑是由硬件实现的，通常位于芯片系统硬件中。然而，运行在普通世界中的软件可以通过特定的软件（如
    ARM Cortex-A 中的 Secure Monitor 或 ARM Cortex-M 中的核心逻辑）将控制权转移到位于安全世界中的软件（例如，执行安全世界中的受信服务）。此机制确保世界之间的切换不会破坏系统的安全性。
- en: Together, the Trusted Boot technology and Trust Zone create the Trusted Execution
    Environment, used to run software with high privileges and provide an environment
    for security technologies like digital rights management, cryptography and authentication
    primitives, and other security-sensitive applications. In this way, an isolated,
    protected environment may house the most sensitive software.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Trusted Boot 技术和 Trust Zone 一起构成了受信执行环境，用于运行具有高级权限的软件，并为数字版权管理、加密和身份验证原语以及其他安全敏感应用提供安全环境。通过这种方式，一个孤立的、受保护的环境可以容纳最敏感的软件。
- en: '***ARM Boot Loaders***'
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***ARM 引导加载程序***'
- en: 'Because the secure and normal worlds are kept separate, each world needs its
    own set of bootloaders. Also, the boot process for each world consists of multiple
    stages, which means a number of bootloaders must execute at different points in
    the boot process. Here, we’ll describe the Trusted Boot flow for ARM application
    processors in general terms, beginning with the following list of bootloaders
    involved in Trusted Boot. We showed these back in [Figure 17-17](ch17.xhtml#ch17fig17):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全世界和普通世界是分开的，每个世界需要自己的引导加载程序。此外，每个世界的引导过程由多个阶段组成，这意味着必须在引导过程的不同阶段执行多个引导加载程序。在这里，我们将以一般术语描述
    ARM 应用处理器的受信引导流程，并列出涉及受信引导的引导加载程序，这些在[图 17-17](ch17.xhtml#ch17fig17)中已有展示：
- en: '**BL1** First-stage bootloader, located in boot ROM and executed in the secure
    world.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**BL1** 第一阶段引导加载程序，位于启动 ROM 中并在安全世界执行。'
- en: '**BL2** Second-stage bootloader, located in flash memory, loaded and executed
    by BL1 in the secure world.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**BL2** 第二阶段引导加载程序，位于闪存中，由 BL1 在安全世界加载并执行。'
- en: '**BL31** Secure-world runtime firmware, loaded and executed by BL2.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**BL31** 安全世界运行时固件，由 BL2 加载并执行。'
- en: '**BL32** Optional secure-world third-stage bootloader, loaded by BL2.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**BL32** 可选的安全世界第三阶段引导加载程序，由 BL2 加载。'
- en: '**BL33** Normal-world runtime firmware, loaded and executed by BL2.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**BL33** 普通世界运行时固件，由 BL2 加载并执行。'
- en: This list isn’t a complete and accurate list of all the ARM implementations
    in the real world, as some manufacturers introduce additional bootloaders or remove
    some of the existing ones. In some cases, BL1 may not be the very first code executed
    on the application processor when the system comes out of reset.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这份清单并不是所有 ARM 实现的完整和准确列表，因为一些制造商引入了额外的引导加载程序或移除了一些现有的程序。在某些情况下，BL1 可能不是系统复位后应用处理器上执行的第一个代码。
- en: To verify the integrity of these boot components, Trusted Boot relies on X.509
    public key certificates (remember that the files in UEFI Secure Boot’s `db` database
    were encoded with X.509). It’s worth mentioning that all certificates are self-signed.
    There is no need for a certificate authority, because the chain of trust is not
    established by the validity of a certificate’s issuer but rather by the content
    of the certificate extensions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这些引导组件的完整性，受信启动依赖于 X.509 公钥证书（请记住，UEFI 安全启动中的 `db` 数据库文件是使用 X.509 编码的）。值得一提的是，所有证书都是自签名的。无需证书颁发机构，因为信任链的建立并不是通过证书颁发者的有效性，而是通过证书扩展的内容。
- en: 'Trusted Boot uses two types of certificates: *key* and *content* certificates.
    It uses key certificates first to verify the public keys that are used to sign
    content certificates. Then it uses the content certificates to store the hashes
    of boot loader images. This relationship is illustrated in [Figure 17-18](ch17.xhtml#ch17fig18).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 受信启动使用两种类型的证书：*密钥*证书和*内容*证书。它首先使用密钥证书验证用于签名内容证书的公钥。然后，它使用内容证书存储引导加载程序映像的哈希值。这种关系如[图
    17-18](ch17.xhtml#ch17fig18)所示。
- en: '![image](../images/17fig18.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig18.jpg)'
- en: '*Figure 17-18: Trusted Boot key and content certificates*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-18：受信启动密钥和内容证书*'
- en: Trusted Boot authenticates an image by calculating its hash and matching the
    result with the hash extracted from the content certificate.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 受信启动通过计算映像的哈希值并将结果与从内容证书中提取的哈希值进行匹配来验证映像。
- en: '***Trusted Boot Flow***'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***受信启动流程***'
- en: Now that you’re familiar with the foundational concepts of Trusted Boot, let’s
    take a look at the Trusted Boot flow for an application processor, shown in [Figure
    17-19](ch17.xhtml#ch17fig19). This will give you the full picture of how Verified
    Boot is implemented in ARM processors and how it protects platforms from the execution
    of untrusted code, including firmware rootkits.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了受信启动的基础概念，让我们看看应用处理器的受信启动流程，如[图 17-19](ch17.xhtml#ch17fig19)所示。这将为你提供一个完整的视角，了解在
    ARM 处理器中如何实现验证启动，并且它如何保护平台免受不受信任代码的执行，包括固件根套件。
- en: In [Figure 17-19](ch17.xhtml#ch17fig19), solid arrows denote the transfer of
    execution flow, and dashed arrows denote the trust relationship; in other words,
    each element trusts the element its dotted arrow points to.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 17-19](ch17.xhtml#ch17fig19)中，实线箭头表示执行流的转移，虚线箭头表示信任关系；换句话说，每个元素信任其虚线箭头指向的元素。
- en: Once the CPU is released from reset, the first piece of the code executed is
    bootloader 1 (BL1) ➊. BL1 is loaded from the read-only boot ROM, which means it
    can’t be tampered with while it’s stored there. BL1 reads the bootloader 2 (BL2)
    content certificate ➒ from flash memory and checks its issuer key. BL1 then computes
    the hash of the BL2 content certificate issuer and compares it with the “golden”
    values stored in the secure *root of trust public key register (ROTPK)* register
    ➓ in the hardware. The ROTPK register and boot ROM are the roots of trust, anchored
    in hardware for Trusted Boot. If the hashes aren’t equal or verification of the
    BL2 content certificate signature fails, the system panics.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦CPU从重置中恢复，执行的第一段代码是引导加载程序1（BL1）➊。BL1从只读引导ROM加载，这意味着在存储期间它不能被篡改。BL1读取来自闪存的引导加载程序2（BL2）内容证书➒并检查其发行者密钥。BL1然后计算BL2内容证书发行者的哈希值，并将其与硬件中存储在*受信任的根公钥寄存器（ROTPK）*寄存器中的“黄金”值进行比较➓。ROTPK寄存器和引导ROM是受信任引导的根信任来源，根植于硬件。如果哈希值不相等或BL2内容证书签名验证失败，系统将出现故障。
- en: Once the BL2 content certificate is verified against the ROTPK, BL1 loads the
    BL2 image from flash ➋, computes its cryptographic hash, and compares this hash
    value with the value obtained from the BL2 content certificate ➎.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦BL2内容证书通过ROTPK验证，BL1从闪存加载BL2映像➋，计算其加密哈希值，并将该哈希值与从BL2内容证书➎获取的哈希值进行比较。
- en: Once authenticated, BL1 transfers control to BL2, which, in turn, reads its
    trusted key certificate ➏ from flash memory. This trusted key certificate contains
    public keys for the verification of the firmware for both the secure world ➐ and
    the normal world ➑. The key that issued the trusted key certificate is checked
    against the ROTPK register ➓.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦认证通过，BL1将控制权转交给BL2，BL2随后从闪存读取其受信任的密钥证书➏。该受信任的密钥证书包含用于验证安全世界➐和普通世界➑固件的公钥。发行该受信任密钥证书的密钥将与ROTPK寄存器➓进行比对。
- en: Next, BL2 authenticates BL31 ➌, which is the runtime firmware for the secure
    world. To authenticate the BL31 image, BL2 uses the key certificate and content
    certificate for BL31 ➍. BL2 verifies these key certificates by using the secure
    world public key obtained from the trusted key certificate. The BL31 key certificate
    contains the BL31 content certificate public key used to verify the signature
    of the BL32 content certificate.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，BL2认证BL31➌，即安全世界的运行时固件。为了认证BL31映像，BL2使用BL31的密钥证书和内容证书➌。BL2通过使用从受信任的密钥证书获取的安全世界公钥来验证这些密钥证书。BL31密钥证书包含用于验证BL32内容证书签名的BL31内容证书公钥。
- en: '![image](../images/17fig19.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig19.jpg)'
- en: '*Figure 17-19: Trusted Boot flow*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-19：受信任引导流程*'
- en: Once the BL31 content certificate is verified, the hash value of the BL31 image
    stored within this BL31 certificate is used to check the integrity of the BL3
    image. Again, any failures result in a system panic.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦BL31内容证书验证通过，存储在该BL31证书中的BL31映像的哈希值将用于检查BL3映像的完整性。再次，如果验证失败，系统将出现故障。
- en: Similarly, BL2 checks the integrity of the optional secure-world BL32 image
    using the BL32 key and content certificates.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，BL2使用BL32密钥和内容证书检查可选的安全世界BL32映像的完整性。
- en: The integrity of the BL33 firmware image (executed in the normal world) is checked
    with the BL33 key and BL33 content certificates. The BL33 key certificate is verified
    with the normal world public key obtained from the trusted key certificate.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: BL33固件映像（在普通世界中执行）的完整性将通过BL33密钥和BL33内容证书进行检查。BL33密钥证书将通过从受信任的密钥证书中获取的普通世界公钥进行验证。
- en: If all the checks pass successfully, the system proceeds by executing the authenticated
    firmware for both the secure and normal worlds.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有检查都成功通过，系统将继续执行经过认证的安全世界和普通世界固件。
- en: '**AMD HARDWARE VALIDATED BOOT**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**AMD硬件验证引导**'
- en: Although not discussed in this chapter, AMD has its own implementation of Verified
    and Measured Boot called Hardware Validated Boot (HVB). This technology implements
    functionality similar to Intel BootGuard. Based on AMD Platform Security Processor
    technology, it has a microcontroller devoted to security-related computations
    that runs independently of the system’s main core.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章没有讨论，但AMD有自己的验证和测量引导实现，称为硬件验证引导（HVB）。该技术实现了类似于Intel BootGuard的功能。基于AMD平台安全处理器技术，它拥有一颗专门用于安全相关计算的微控制器，独立于系统的主核心运行。
- en: '**Verified Boot vs. Firmware Rootkits**'
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**验证引导与固件根木马**'
- en: With all of this knowledge in hand, let’s finally see whether Verified Boot
    can protect against firmware rootkits.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到这些知识后，最终让我们来看看验证启动（Verified Boot）是否能防止固件根套件（rootkits）攻击。
- en: We know that Verified Boot takes place before any firmware is executed in the
    boot process. This means that when Verified Boot starts verifying firmware, any
    infecting firmware rootkit won’t yet be active, so the malware can’t counteract
    the verification process. Verified Boot will detect any malicious modification
    of firmware and prevent its execution.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，验证启动发生在任何固件在启动过程中执行之前。这意味着当验证启动开始验证固件时，任何感染的固件根套件还没有激活，因此恶意软件无法反制验证过程。验证启动将检测任何恶意修改的固件并防止其执行。
- en: Moreover, the root of trust for Verified Boot is anchored in the hardware, so
    attackers can’t tamper with it. Intel BootGuard’s OEM root public key is fused
    into the chipset, and ARM’s root of trust key is stored in secure registers. In
    both cases, the boot code that triggers Verified Boot is loaded from read-only
    memory, so malware can’t patch or modify it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，验证启动的信任根是基于硬件的，因此攻击者无法篡改它。Intel BootGuard 的 OEM 根公钥被烧录到芯片组中，而 ARM 的信任根密钥则存储在安全寄存器中。在这两种情况下，触发验证启动的启动代码是从只读存储器中加载的，因此恶意软件无法修补或修改它。
- en: So, we can conclude that Verified Boot can withstand attacks from firmware rootkits.
    However, as you might have observed, the whole technology is quite complex; it
    has many dependencies, so it could easily be implemented incorrectly. This technology
    is only as secure as its weakest component; a single flaw in the chain of trust
    makes it possible to bypass. That means there’s a good chance attackers could
    find vulnerabilities in an implementation of Verified Boot to exploit and install
    firmware rootkits.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出结论，验证启动能够抵御固件根套件的攻击。然而，正如你可能已经观察到的，这项技术非常复杂；它有很多依赖项，因此很容易被错误实现。这项技术的安全性与其最薄弱的组件相当；信任链中的任何一个缺陷都可能导致绕过。这意味着攻击者很可能在验证启动的实现中找到漏洞，从而利用并安装固件根套件。
- en: '**Conclusion**'
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: 'In this chapter, we explored three Secure Boot technologies: UEFI Secure Boot,
    Intel BootGuard, and ARM Trusted Boot. These technologies rely on a chain of trust—enforced
    from the very beginning of the boot process to the execution of user applications—and
    involve an enormous number of boot modules. When correctly configured and implemented,
    they provide protection against the ever-growing number of UEFI firmware rootkits.
    That’s why high-assurance systems must use Secure Boot, and why, these days, many
    consumer systems enable Secure Boot by default. In the next chapter, we’ll focus
    on forensic approaches for analyzing firmware rootkits.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们探讨了三种安全启动技术：UEFI 安全启动、Intel BootGuard 和 ARM Trusted Boot。这些技术依赖于从启动过程开始到用户应用程序执行的信任链，并涉及大量的启动模块。当正确配置和实现时，它们能够防止日益增长的
    UEFI 固件根套件攻击。这也是为什么高安全性系统必须使用安全启动的原因，现如今许多消费级系统默认启用安全启动。在下一章，我们将重点讨论分析固件根套件的取证方法。
