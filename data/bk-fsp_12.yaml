- en: Chapter 12. Computation Expressions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12章。计算表达式
- en: 'In [Chapter 6](ch06.html "Chapter 6. Going to Collections"), we looked at how
    sequence expressions simplify creating sequences. In [Chapter 10](ch10.html "Chapter 10. Show
    Me the Data"), we saw how query expressions provide a unified approach to querying
    data from disparate data sources. Similarly, in [Chapter 11](ch11.html "Chapter 11. Asynchronous
    and Parallel Programming"), we explored how asynchronous workflows can be employed
    to simplify creating and executing asynchronous operations. Each of these constructs
    serves a very different purpose, but what they all have in common is that they’re
    examples of another F# language feature: the computation expression.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。走向集合")中，我们了解了序列表达式如何简化序列的创建。在[第10章](ch10.html "第10章。展示数据")中，我们看到查询表达式如何为从不同数据源查询数据提供统一的方法。类似地，在[第11章](ch11.html
    "第11章。异步和并行编程")中，我们探讨了如何利用异步工作流简化异步操作的创建与执行。这些构造各自服务于不同的目的，但它们共同的特点是，它们都是F#语言的另一个特性：计算表达式。
- en: '*Computation expressions*, sometimes referred to as *workflows*, provide a
    convenient construct for expressing a series of operations where data flow and
    side effects are controlled. In that regard, computation expressions are similar
    to what other functional languages refer to as *monads*. Where computation expressions
    differ, though, is that they’re designed in such a way that individual expressions
    look like a natural part of the language.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算表达式*，有时也称为*工作流*，提供了一种方便的构造，用于表达一系列操作，其中数据流和副作用被控制。从这个角度来看，计算表达式类似于其他函数式语言所称的*单子*。然而，计算表达式的不同之处在于，它们被设计成个别表达式看起来像语言的自然部分。'
- en: Within the context of a computation expression, you can repurpose several familiar
    language elements—such as the `let` and `use` keywords, and `for` loops—to unify
    the syntax with the language. Computation expressions also provide an alternative
    “bang” syntax for some of these elements, allowing you to nest computation expressions
    for inline evaluation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算表达式的上下文中，你可以重新利用几个熟悉的语言元素——例如`let`和`use`关键字以及`for`循环——将语法与语言统一。计算表达式还为其中一些元素提供了替代的“bang”语法，允许你嵌套计算表达式进行内联求值。
- en: This feature’s generalized nature means that computation expressions can simplify
    working with complex types and are applicable to a variety of situations. For
    instance, we already know that the built-in computation expressions streamline
    sequence creation, querying, and asynchronous processing, but they also have applications
    in logging and in projects such as the {m}brace framework that aim to simplify
    offloading computations to the cloud.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该特性具有广泛的适用性，计算表达式可以简化与复杂类型的交互，并适用于各种场景。例如，我们已经知道内置的计算表达式可以简化序列创建、查询和异步处理，但它们也在日志记录和一些项目中具有应用，例如{m}brace框架，旨在简化将计算任务卸载到云端。
- en: In this chapter, we’ll explore the inner workings of computation expressions.
    We’ll forego discussing monadic theory because it doesn’t really help you understand
    how computation expressions can fit into your solutions. Instead, we’ll begin
    with a look at builder classes and how they enable computation expressions. With
    that foundation established, we’ll then walk through two examples of custom computation
    expressions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨计算表达式的内部工作原理。我们将跳过讨论单子理论，因为它并不能帮助你理解计算表达式如何融入到你的解决方案中。相反，我们将从了解构建器类及其如何启用计算表达式开始。在建立了这个基础后，我们将通过两个自定义计算表达式的示例来进行讲解。
- en: Anatomy of a Computation Expression
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算表达式的结构
- en: 'You’re already familiar with the basic pattern for writing computation expressions,
    but until now, you haven’t seen how they work beyond a brief glimpse behind the
    scenes when we created some additional query operators in [Extending Query Expressions](ch10.html#extending_query_expressions
    "Extending Query Expressions"). To reiterate for the more general case, computation
    expressions take the following form:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉了编写计算表达式的基本模式，但直到现在，你还没有看到它们如何运作，除了在我们创建一些额外查询操作符时对其背后原理进行简短的介绍（参见[扩展查询表达式](ch10.html#extending_query_expressions
    "扩展查询表达式")）。为了更一般地重申，计算表达式具有以下形式：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Computation expressions are designed around an underlying *computation type*
    (sometimes called a *monadic type*) that we compute by transparently invoking
    methods exposed by a *builder class*. In the preceding syntax, *builder-name*
    represents a concrete instance of a builder class, and *computation-expression-body*
    represents the series of nested expressions that map to the method calls necessary
    to produce an instance of the computation type. For example, asynchronous workflows
    are based on `Async<'T>` and built via `AsyncBuilder`. Similarly, query expressions
    are based on `QuerySource<'T, 'Q>` and built via `QueryBuilder`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 计算表达式围绕一个基本的*计算类型*（有时称为*单子类型*）设计，我们通过透明地调用*构建器类*暴露的方法来进行计算。在前面的语法中，*builder-name*
    表示构建器类的一个具体实例，*computation-expression-body* 表示一系列嵌套的表达式，这些表达式映射到产生计算类型实例所需的方法调用。例如，异步工作流基于
    `Async<'T>`，通过 `AsyncBuilder` 构建。类似地，查询表达式基于 `QuerySource<'T, 'Q>`，通过 `QueryBuilder`
    构建。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Sequence expressions are an anomaly in the realm of computation expressions
    in that they don’t follow the normal implementation pattern. Although sequence
    expressions use the computation expression syntax and are based on `IEnumerable<''T>`,
    they don’t have a corresponding builder class. Instead, the details that would
    normally be handled by the builder class are handled directly by the F# compiler.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列表达式在计算表达式领域中是一种特例，因为它们不遵循正常的实现模式。尽管序列表达式使用计算表达式语法并基于 `IEnumerable<''T>`，但它们没有对应的构建器类。相反，通常由构建器类处理的细节直接由
    F# 编译器处理。*'
- en: Builder classes define the operations supported by a computation expression.
    Defining a builder class is largely a matter of convention, as there are no specific
    interfaces to implement or base classes to inherit. There aren’t any steadfast
    rules for naming builder classes, but you typically do so by appending `Builder`
    to the underlying type name (for example, `AsyncBuilder` and `QueryBuilder`).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器类定义了计算表达式支持的操作。定义构建器类在很大程度上是一种约定，因为没有特定的接口需要实现，也没有基类需要继承。对于构建器类的命名没有严格的规则，但通常是通过在基础类型名称后附加
    `Builder` 来命名（例如，`AsyncBuilder` 和 `QueryBuilder`）。
- en: Although computation expressions are part of the language, they are really just
    syntactic sugar—a more convenient way to call into the builder class’s methods.
    When the compiler encounters what appears to be a computation expression, it attempts
    to convert the code to a series of method calls through a process called *desugaring*.
    This process involves replacing each operation in the computation expression with
    a call to a corresponding instance method on the builder type (similar to how
    LINQ query expressions are translated to extension method calls and delegates
    in C# and Visual Basic). I like to think of the builder class methods as belonging
    to either of two groups. The first group, listed in [Table 12-1](ch12.html#control_methods_for_syntactic_elements
    "Table 12-1. Control Methods for Syntactic Elements"), controls various syntactic
    elements such as bindings, `for` and `while` loops, and return values.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然计算表达式是语言的一部分，但它们实际上只是语法糖——一种更方便的方式来调用构建器类的方法。当编译器遇到看似计算表达式的代码时，它会尝试通过一个叫做*去糖化*的过程将代码转换为一系列方法调用。这个过程涉及用构建器类型上对应实例方法的调用替换计算表达式中的每个操作（类似于
    LINQ 查询表达式如何转换为 C# 和 Visual Basic 中的扩展方法调用和委托）。我喜欢把构建器类的方法分为两组。第一组列在[表 12-1](ch12.html#control_methods_for_syntactic_elements
    "表 12-1. 语法元素控制方法")中，控制各种语法元素，如绑定、`for` 和 `while` 循环、以及返回值。
- en: Table 12-1. Control Methods for Syntactic Elements
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-1. 语法元素控制方法
- en: '| Method | Description | Signature |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 | 签名 |'
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Bind` | Enables `let!` and `do!` bindings | `M<''T> * (''T -> M<''U>) ->
    M<''U>` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `Bind` | 启用 `let!` 和 `do!` 绑定 | `M<''T> * (''T -> M<''U>) -> M<''U>` |'
- en: '| `For` | Enables `for` loops | `seq<''T> * (''T -> M<''U>) -> M<''U>`or`seq<''T>
    * (''T -> M<''U>) -> seq<M<''U>>` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `For` | 启用 `for` 循环 | `seq<''T> * (''T -> M<''U>) -> M<''U>` 或 `seq<''T>
    * (''T -> M<''U>) -> seq<M<''U>>` |'
- en: '| `Return` | Enables `return` | `''T -> M<''T>` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `Return` | 启用 `return` | `''T -> M<''T>` |'
- en: '| `ReturnFrom` | Enables `return!` | `M<''T> -> M<''T>` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `ReturnFrom` | 启用 `return!` | `M<''T> -> M<''T>` |'
- en: '| `TryFinally` | Allows exception handling through `try...finally` | `M<''T>
    * (unit -> unit) -> M<''T>` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `TryFinally` | 允许通过 `try...finally` 进行异常处理 | `M<''T> * (unit -> unit) ->
    M<''T>` |'
- en: '| `TryWith` | Allows exception handling through `try...with` | `M<''T> * (exn
    -> M<''T>) -> M<''T>` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `TryWith` | 允许通过 `try...with` 进行异常处理 | `M<''T> * (exn -> M<''T>) -> M<''T>`
    |'
- en: '| `Using` | Enables creating `IDisposable` objects with `use` and `use!` |
    `''T * (''T -> M<''U>) -> M<''U>`when`''U :> IDisposable` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `Using` | 使得可以使用 `use` 和 `use!` 创建 `IDisposable` 对象 | `''T * (''T -> M<''U>)
    -> M<''U>`当`''U :> IDisposable`时 |'
- en: '| `While` | Allows you to use `while...do` loops within a computation expression
    | `(unit -> bool) * M<''T> -> M<''T>` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `While` | 允许在计算表达式中使用 `while...do` 循环 | `(unit -> bool) * M<''T> -> M<''T>`
    |'
- en: '| `Yield` | Returns items from a nested computation expression using a sequence-like
    approach with the `yield` keyword | `''T -> M<''T>` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `Yield` | 使用 `yield` 关键字，以类似序列的方式从嵌套的计算表达式中返回项 | `''T -> M<''T>` |'
- en: '| `YieldFrom` | Returns items from a nested computation expression using a
    sequence-like approach with the `yield!` keyword | `M<''T> -> M<''T>` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `YieldFrom` | 使用 `yield!` 关键字，以类似序列的方式从嵌套的计算表达式中返回项 | `M<''T> -> M<''T>`
    |'
- en: The second group of methods, those that control how computation expressions
    are evaluated, is listed in [Table 12-2](ch12.html#methods_affecting_computation_expression
    "Table 12-2. Methods Affecting Computation Expression Evaluation").
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组方法，控制计算表达式如何被评估的方法，列在[表12-2](ch12.html#methods_affecting_computation_expression
    "Table 12-2. 影响计算表达式评估的方法")中。
- en: Table 12-2. Methods Affecting Computation Expression Evaluation
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表12-2. 影响计算表达式评估的方法
- en: '| Method | Description | Signature |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 | 签名 |'
- en: '| --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Combine` | Merges two parts of a computation expression into one | `M<''T>
    * M<''T> -> M<''T>`or`M<unit> * M<''T> -> M<''T>` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `Combine` | 将计算表达式的两个部分合并成一个 | `M<''T> * M<''T> -> M<''T>`或`M<unit> * M<''T>
    -> M<''T>` |'
- en: '| `Delay` | Wraps a computation expression in a function for deferred execution,
    thereby helping prevent unintended side effects | `(unit -> M<''T>) -> M<''T>`
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `Delay` | 将计算表达式包装成一个函数，以便延迟执行，从而帮助防止不必要的副作用 | `(unit -> M<''T>) -> M<''T>`
    |'
- en: '| `Run` | Executed as the last step in evaluating a computation expression;
    can “undo” a delay by invoking the function returned by `Delay` and can also transform
    the result into a more consumable format | `M<''T> -> M<''T>`or`M<''T> -> ''T`
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `Run` | 在评估计算表达式时作为最后一步执行；可以通过调用 `Delay` 返回的函数来“撤销”延迟，也可以将结果转换为更易消费的格式 |
    `M<''T> -> M<''T>`或`M<''T> -> ''T` |'
- en: '| `Zero` | Returns a default value for the expression’s monadic type; used
    when a computation expression doesn’t explicitly return a value | `unit -> M<''T>`(`''T`
    can be `unit`) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `Zero` | 返回表达式的单子类型的默认值；当计算表达式没有显式返回值时使用 | `unit -> M<''T>`（`''T` 可以是 `unit`）
    |'
- en: Because computation expressions are intended to be designed in such a way that
    they apply to a variety of situations, it’s important to keep them as generic
    as possible. This is reflected in the highly generalized structure of the signatures.
    For instance, the notation `M<_>` is used to indicate that the underlying type
    wraps another value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算表达式的设计目的是使其能够适用于各种情况，因此保持它们尽可能通用非常重要。这一点通过签名的高度通用结构得以体现。例如，`M<_>`的符号表示底层类型封装了另一个值。
- en: 'It is not necessary to implement each method listed in [Table 12-1](ch12.html#control_methods_for_syntactic_elements
    "Table 12-1. Control Methods for Syntactic Elements") in your builder classes.
    Should you omit any of those methods, though, the corresponding mapped syntax
    will not be available within the computation expression and the compiler will
    produce an error. For example, if you try to include a `use` binding within a
    custom computation expression but omit the `Using` method from the builder class,
    compilation will fail with the message:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的构建器类中并不需要实现[表12-1](ch12.html#control_methods_for_syntactic_elements "Table
    12-1. 语法元素的控制方法")中列出的每个方法。然而，如果你省略了某些方法，相应的映射语法将无法在计算表达式中使用，编译器会报错。例如，如果你尝试在自定义计算表达式中包含
    `use` 绑定，但省略了构建器类中的 `Using` 方法，编译将失败，并显示如下错误信息：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Likewise, it is not always necessary to implement each method from [Table 12-2](ch12.html#methods_affecting_computation_expression
    "Table 12-2. Methods Affecting Computation Expression Evaluation"), but failure
    to do so in some situations can lead to undesirable results. For instance, not
    implementing the `Delay` method will prevent you from composing expressions that
    yield multiple results. Furthermore, when your computation expression involves
    side effects, not implementing the `Delay` method can invoke the side effects
    prematurely—regardless of where they appear within the expression—because they
    are evaluated immediately when they’re encountered instead of wrapped up in a
    function for deferred execution.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，并非每个方法都需要从[表12-2](ch12.html#methods_affecting_computation_expression "表12-2。影响计算表达式评估的方法")实现，但在某些情况下未实现某些方法可能会导致不希望出现的结果。例如，未实现
    `Delay` 方法将阻止你组合返回多个结果的表达式。此外，当计算表达式涉及副作用时，未实现 `Delay` 方法可能会过早引发副作用——无论它们出现在表达式的何处——因为它们会在遇到时立即被评估，而不是被包装在一个函数中以便延迟执行。
- en: Computation expressions can be difficult to understand when discussed in abstract
    terms focused on the builder classes and method calls. I think it’s far more helpful
    to walk through some simple implementations to see how the pieces work together.
    We’ll spend the remainder of the chapter discussing two examples. In particular,
    we’ll look at the builder implementations, their corresponding expression syntax,
    and the desugaring process.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们仅仅讨论构建器类和方法调用时，计算表达式可能很难理解。我认为，走过一些简单的实现示例，看看这些组件如何协同工作，更加有帮助。本章剩余的部分我们将讨论两个示例。特别是，我们将查看构建器实现、它们对应的表达式语法以及去糖过程。
- en: 'Example: FizzBuzz'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：FizzBuzz
- en: In [Chapter 7](ch07.html "Chapter 7. Patterns, Patterns, Everywhere"), we looked
    at a few ways to solve the FizzBuzz problem by iterating over a sequence using
    `Seq.map` and using pattern-matching functions with active patterns and partial
    active patterns to identify which value should be printed. At its core, however,
    the FizzBuzz problem is essentially just an exercise in sequence transformation.
    As such, the problem can easily be solved with a computation expression.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。模式，处处是模式")中，我们研究了几种通过使用`Seq.map`迭代序列以及使用带有活动模式和部分活动模式的模式匹配函数来解决
    FizzBuzz 问题的方法。然而，FizzBuzz 问题的核心本质上只是一个序列转换的练习。因此，使用计算表达式可以轻松解决该问题。
- en: When implemented as a computation expression, our FizzBuzz sequence can be constructed
    in a manner such that it looks and behaves like a standard sequence expression.
    With the computation expression, though, mapping a number to the corresponding
    string will be completely abstracted away within the builder class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为计算表达式实现时，我们的 FizzBuzz 序列可以以一种方式构建，使其看起来和行为像一个标准的序列表达式。然而，使用计算表达式时，将数字映射到相应的字符串将完全抽象化，隐藏在构建器类中。
- en: Because FizzBuzz transforms integers to strings and carries no intrinsic state,
    we’ll forego creating an intermediary wrapper type and jump right into creating
    the builder class incrementally, beginning with the `Yield` method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 FizzBuzz 将整数转换为字符串并且不包含内在状态，我们将跳过创建中介包装类型，直接从创建构建器类开始，逐步实现，首先从 `Yield` 方法开始。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have a rudimentary builder class, we can create the instance that
    we’ll use for every FizzBuzz computation expression, like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个基础的构建器类，我们可以创建实例，并在每次 FizzBuzz 计算表达式中使用它，像这样：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That’s it! There’s nothing fancy here; we just create an instance of the class
    via its primary constructor. To use the instance as a computation expression,
    we can write something such as the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！没有什么花哨的地方；我们只是通过它的主构造函数创建了类的一个实例。为了将该实例用作计算表达式，我们可以编写如下内容：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, evaluating the preceding expression doesn’t give us quite the
    result we’re looking for. Instead of returning a sequence of strings, it gives
    us only a single string, because so far the builder class doesn’t know how to
    create a sequence; it simply yields a string based on an integer value. You can
    see this a bit more clearly in the desugared form, which resembles this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，评估前面的表达式并没有给我们预期的结果。它并没有返回一个字符串序列，而是只返回了一个单一的字符串，因为到目前为止，构建器类还不知道如何创建序列；它只是基于整数值返回一个字符串。你可以在去糖后的形式中更清楚地看到这一点，它大致如下：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get a sequence of strings, we could make `Yield` return a singleton sequence
    (a sequence containing only a single item), but doing so would complicate implementing
    other methods, such as `For` and `While`. Instead, we’ll extend the builder class
    to include the `Delay` method as follows (be sure to re-create the builder instance
    after updating the builder class to ensure that the `fizzbuzz` expressions are
    evaluated using the latest definitions):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得一个字符串序列，我们可以让`Yield`返回一个单例序列（只包含一个项目的序列），但这样做会使实现其他方法（如`For`和`While`）变得复杂。相反，我们将扩展构建器类，包含`Delay`方法，如下所示（确保在更新构建器类后重新创建构建器实例，以确保使用最新定义来评估`fizzbuzz`表达式）：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Evaluating the previous `fizzbuzz` expression with the `Delay` method in place
    gives us a slightly more desirable result:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Delay`方法到位的情况下，评估之前的`fizzbuzz`表达式会得到一个稍微更理想的结果：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Again, the desugared expression can help clarify what’s happening. With the
    inclusion of the `Delay` method, the desugared form now looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，去糖化后的表达式可以帮助澄清发生了什么。通过包含`Delay`方法，去糖化后的形式现在如下所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As it stands now, though, all we’ll ever get from a `fizzbuzz` expression is
    a singleton sequence because we can’t yield multiple values. In fact, trying to
    do so as follows will result in a compiler error indicating that the builder class
    must define a `Combine` method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如今，来自`fizzbuzz`表达式的所有结果都只是一个单例序列，因为我们无法生成多个值。实际上，试图按照以下方式生成多个值将导致编译器错误，指示构建器类必须定义一个`Combine`方法：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To make the preceding snippet work, we’ll provide two overloaded implementations
    of the `Combine` method. The reason for overloading the methods is that, depending
    on their position within the expression, we’ll either be combining individual
    strings into a sequence or appending a new string to an existing sequence. We
    want to be careful that we don’t create a sequence containing a sequence, so we’ll
    also need to overload the existing `Delay` method to simply return a supplied
    sequence. We can implement each of these methods as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前面的代码片段能够正常工作，我们将提供两个重载版本的`Combine`方法。重载方法的原因是，根据表达式中的位置，我们可能是将单个字符串组合成一个序列，或者是将一个新的字符串附加到现有的序列中。我们需要小心，避免创建包含序列的序列，因此我们还需要重载现有的`Delay`方法，使其简单地返回一个提供的序列。我们可以按如下方式实现这些方法：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now evaluating the preceding `fizzbuzz` expression will result in a sequence
    containing three strings:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，评估前面的`fizzbuzz`表达式将得到一个包含三个字符串的序列：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When yielding multiple results like this, the desugaring process produces a
    much more complicated chain of method calls. For instance, desugaring the preceding
    expression that yields three items results in code that resembles this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当像这样生成多个结果时，去糖化过程会产生一个更复杂的链式方法调用。例如，去糖化前面的表达式（生成三个项）会得到类似下面的代码：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Yielding instances one at a time as we’ve been doing isn’t a very effective
    way to build a sequence of any length. It would be much nicer if we could compose
    a `fizzbuzz` expression using a `for` loop. For this we need to implement the
    `For` method. The approach we’ll take is to simply wrap a call to `Seq.map`, as
    shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性生成一个实例的方式（我们一直在使用的这种方式）并不是构建任意长度序列的高效方法。如果我们能够通过一个`for`循环来组合一个`fizzbuzz`表达式，那就会更好。为此，我们需要实现`For`方法。我们采取的方法是简单地包装一次对`Seq.map`的调用，如下所示：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now it’s trivial to generate FizzBuzz sequences because instead of using multiple
    `yield` expressions, we can nest a single `yield` expression within a `for` loop,
    like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在生成FizzBuzz序列变得非常简单，因为我们可以将一个单独的`yield`表达式嵌套在`for`循环中，而不是使用多个`yield`表达式，像这样：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Part of the beauty of implementing the `Yield`, `Delay`, `Combine`, and `For`
    methods in the builder class is that we can combine the styles for more flexible
    expressions. For instance, we can yield values directly before yielding them from
    a loop:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建器类中实现`Yield`、`Delay`、`Combine`和`For`方法的一个优点是，我们可以将这些风格组合起来，从而实现更灵活的表达式。例如，我们可以直接在循环中生成值，然后再将它们输出：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As it’s currently written, the builder class doesn’t support every way you could
    combine the various expressions, but you shouldn’t have trouble adding the appropriate
    overloads to support many more scenarios.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如目前所写，构建器类并不支持你可以组合各种表达式的每一种方式，但你不应该在添加适当的重载以支持更多场景时遇到问题。
- en: 'For your convenience, here’s the builder class in its entirety:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，这里是完整的构建器类：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Example: Building Strings'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：构建字符串
- en: 'FizzBuzz does a nice job showing how you can use computation expressions to
    create your own sequence-like constructs with the `For` and `Yield` methods, but
    it’s not particularly practical for everyday computing. For a more useful example,
    we turn to a common programming task: combining strings.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: FizzBuzz很好地展示了如何使用计算表达式通过`For`和`Yield`方法创建自己的类似序列的构造，但它对于日常计算并不特别实用。为了得到一个更实用的例子，我们转向一个常见的编程任务：合并字符串。
- en: 'It has long been established that constructing strings using a `StringBuilder`
    is usually more efficient than concatenation. `StringBuilder`’s fluent interface
    keeps the code fairly clean, as shown in the following snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 长久以来，使用`StringBuilder`构建字符串通常比连接字符串更高效已被广泛认可。`StringBuilder`的流畅接口使代码保持相当简洁，如下所示：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Creating a `StringBuider` instance and chaining calls to the various `Append`
    methods doesn’t really fit into the functional-first paradigm, however. The `Printf`
    module tries to address this disconnect through the `bprintf` function, which
    formats a string and appends it to a `StringBuilder` instance as shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`StringBuider`实例并将不同的`Append`方法链接调用并不完全符合函数式优先的范式，然而，`Printf`模块通过`bprintf`函数试图解决这种脱节问题，`bprintf`函数格式化一个字符串并将其附加到`StringBuilder`实例中，如下所示：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'All `bprintf` really accomplishes, though, is replacing an instance method
    call with a call to a function that accepts a `StringBuilder` as an argument.
    What’s more, you still have to manage the `StringBuilder` instance and pass it
    to each `bprintf` call. With a computation expression, not only can you make string
    construction look like a natural part of the F# language, you can also abstract
    away the `StringBuilder`! The computation expression we’ll define shortly will
    allow us to compose strings using the following syntax:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`bprintf`所完成的事情仅仅是将实例方法调用替换为一个接收`StringBuilder`作为参数的函数调用。更重要的是，你仍然需要管理`StringBuilder`实例，并将其传递给每一个`bprintf`调用。通过计算表达式，你不仅可以让字符串构造看起来像F#语言的自然部分，还可以抽象掉`StringBuilder`！我们将很快定义的计算表达式将允许我们使用以下语法组合字符串：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we chain together a number of strings by yielding them within a `buildstring`
    expression. To make this magic happen, we first need to define the underlying
    type for the expression. For convenience we’ll use a discriminated union called
    `StringFragment` to track all of the strings as we yield them. The `StringFragment`
    type is defined as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过在`buildstring`表达式中`yield`多个字符串来将它们串联起来。为了实现这一点，我们首先需要定义表达式的基础类型。为了方便起见，我们将使用一个称为`StringFragment`的判别联合来跟踪我们在`yield`时所有的字符串。`StringFragment`类型定义如下：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `StringFragment` union has three cases, `Empty`①, `Fragment` ②, and `Concat`
    ③. The `Empty` case represents empty strings, while the `String` case contains
    a single string. The final case, `Concat`, forms a hierarchy of `StringFragment`
    instances that will eventually be joined together through the `ToString` method.
    The beauty of this type is that once the builder is in place, you never have to
    manually manage these instances or the `StringBuilder`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringFragment`联合体有三种情况，`Empty`①，`Fragment`②和`Concat`③。`Empty`表示空字符串，而`Fragment`包含一个单一的字符串。最后的情况，`Concat`，形成一个`StringFragment`实例的层次结构，最终通过`ToString`方法将它们连接在一起。这种类型的优点在于，一旦构建器就位，你就不需要手动管理这些实例或`StringBuilder`了。'
- en: The builder class, which we’ll call `StringFragmentBuilder`, is similar to the
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器类，我们称之为`StringFragmentBuilder`，与
- en: '`FizzBuzzBuilder`, but instead of creating sequences it creates `StringFragment`s.
    We already know based on the earlier syntax that we’ll be using the `yield` keyword,
    so we’ll need to provide a `Yield` method. To yield multiple items, we’ll need
    to implement the `Combine` and `Delay` methods as well. It would be nice to allow
    nested expressions, too, so we’ll implement a `YieldFrom` method. Here is the
    `StringFragmentBuilder` class in its entirety along with the instance used with
    `buildString` expressions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`FizzBuzzBuilder`，但它不是创建序列，而是创建`StringFragment`。根据之前的语法，我们已经知道我们将使用`yield`关键字，因此我们需要提供一个`Yield`方法。为了生成多个项，我们还需要实现`Combine`和`Delay`方法。此外，允许嵌套表达式也是一个不错的主意，因此我们将实现一个`YieldFrom`方法。以下是完整的`StringFragmentBuilder`类，以及与`buildString`表达式一起使用的实例：'
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `StringFragmentBuilder` class is considerably simpler than `FizzBuzzSequenceBuilder`
    because it’s concerned only with mapping strings to `StringFragments` and controlling
    execution. Let’s look at each method individually to understand how it’s used
    within the context of the computation expression.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringFragmentBuilder`类比`FizzBuzzSequenceBuilder`简单得多，因为它仅关注将字符串映射到`StringFragments`并控制执行。我们逐一查看每个方法，以了解它们在计算表达式中的使用方式。'
- en: The first method, `Zero`, returns a default value for the expression. In this
    case, we return `Empty` to indicate an empty string. During the desugaring process,
    a call to `Zero` will be inserted automatically in scenarios such as the expression
    returning `unit`, or a nested `if` expression not including an `else` branch.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法`Zero`为表达式返回一个默认值。在这种情况下，我们返回`Empty`表示一个空字符串。在去糖化过程中，当表达式返回`unit`或嵌套的`if`表达式不包括`else`分支时，会自动插入对`Zero`的调用。
- en: The `Yield` method enables the `yield` keyword within the `buildstring` expression.
    In this implementation, `Yield` accepts a string, which it wraps in a new `Fragment`
    instance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Yield`方法在`buildstring`表达式中启用了`yield`关键字。在这个实现中，`Yield`接受一个字符串，并将其包装在一个新的`Fragment`实例中。'
- en: The `YieldFrom` method allows you to evaluate a nested `buildstring` expression
    through the `yield!` keyword. This method is similar to `Yield`, but instead of
    returning a new `StringFragment`, it returns the one created by the nested expression.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`YieldFrom`方法允许你通过`yield!`关键字求值一个嵌套的`buildstring`表达式。这个方法类似于`Yield`，但它返回的是嵌套表达式创建的`StringFragment`，而不是返回一个新的`StringFragment`。'
- en: Each `yield` or `yield!` in the computation expression represents the end of
    a portion of the expression, so we need a way to merge them all together. For
    that we turn to the `Combine` method, which essentially treats the remainder of
    the expression as a continuation. `Combine` takes two `StringFragments` and wraps
    them each within a `Concat` instance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`yield`或`yield!`在计算表达式中代表着表达式的一部分结束，因此我们需要一种方法将它们合并在一起。为此，我们使用`Combine`方法，它本质上将表达式的其余部分视为一个延续。`Combine`接受两个`StringFragments`，并将它们各自包装在一个`Concat`实例中。
- en: Combine, Exposed
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Combine，暴露
- en: 'I think it’s easier to understand the `Combine` method’s role by looking at
    the desugared form. Say you’re writing a `buildstring` expression that combines
    `"A"` and `"B"` into a single string like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为通过查看去糖化的形式，更容易理解`Combine`方法的作用。假设你正在编写一个`buildstring`表达式，将`"A"`和`"B"`合并为一个字符串，如下所示：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The corresponding desugared form of this expression would look very much like
    this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该表达式的相应去糖化形式将非常类似于此：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For clarity, I simplified the desugared form to just the parts essential for
    understanding the process. Here, the first call to `Yield` returns `Fragment("A")`
    and the second returns `Fragment("B")`. The `Combine` method takes both of these
    and produces the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地理解，我将去糖化的形式简化为仅包含理解过程所需的部分。这里，第一个`Yield`调用返回`Fragment("A")`，第二个返回`Fragment("B")`。`Combine`方法接受这两者并生成以下内容：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`Combine` is called for every yield after the first. If our hypothetical example
    were extended to also yield `"C"`, then the desugared form would then resemble
    this simplified code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Combine`会在第一个`yield`之后为每个`yield`调用。如果我们的假设示例扩展到也`yield` `"C"`，那么去糖化后的形式将类似于以下简化代码：'
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The resulting `StringFragment` should then be:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的`StringFragment`应为：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next method in the `StringFragmentBuilder` class, `Delay`, controls when
    the computation expression is evaluated. When a computation expression has multiple
    parts, the compiler requires you to define `Delay` to avoid prematurely evaluating
    expressions that contain side effects and control execution as expressions are
    combined. Many of the method calls are wrapped in a function that’s passed to
    `Delay`, so that those portions of the expression won’t be evaluated until `Delay`
    is invoked. More specifically, the entire expression is wrapped in one `Delay`
    call, as are the calls that compute the second argument to each `Combine` call.
    The desugared form looks a bit like this (simplified for clarity):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringFragmentBuilder`类中的下一个方法`Delay`控制计算表达式何时被求值。当一个计算表达式有多个部分时，编译器要求你定义`Delay`以避免过早求值包含副作用的表达式，并在表达式组合时控制执行。许多方法调用被包装在传递给`Delay`的函数中，这样这些表达式部分直到调用`Delay`时才会被求值。更具体地说，整个表达式被包装在一个`Delay`调用中，每个`Combine`调用的第二个参数计算也被如此包装。去糖化后的形式大致如下（为清晰起见简化）：'
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, the `For` method allows us to use `for` loops within a `buildstring`
    expression. Unlike the FizzBuzz implementation, however, this version employs
    the Map/Reduce pattern to map the supplied sequence values to individual `StringFragment`
    instances and then reduce them into a single `StringFragment` instance through
    the `Combine` method. This flattened instance can then be used in conjunction
    with other instances.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`For`方法允许我们在`buildstring`表达式中使用`for`循环。然而，与FizzBuzz实现不同，这个版本采用了Map/Reduce模式，将提供的序列值映射到单独的`StringFragment`实例，然后通过`Combine`方法将它们减少成一个单一的`StringFragment`实例。这个扁平化的实例可以与其他实例一起使用。
- en: 'Now that you’ve seen the builder class and understand how the methods work
    together through the desugaring process, let’s look at an example that exercises
    the entire chain. For this, we can use `buildstring` expressions to build the
    lyrics to a popular children’s song about a farmer and his dog, Bingo. The song’s
    simple lyrics and its repetitive nature make it easy to represent programmatically,
    like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看过构建器类，并理解了这些方法是如何通过去糖化过程协同工作的，让我们来看一个完整的例子，展示如何执行整个链条。为此，我们可以使用`buildstring`表达式来构建一首关于农夫和他的小狗Bingo的儿童歌曲的歌词。这首歌的简单歌词和重复性质使得它很容易用编程的方式表示，如下所示：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Nested within the `bingo` function are three functions: `buildNamePhrase`,`buildClapAndSpellPhrases`,
    and `buildVerse`. Each of these functions constructs a `StringFragment` through
    a `buildstring` expression. At the end of each verse, the `buildstring` expression
    includes a match expression to determine whether it should end with the `Zero`
    value (implied by returning `unit`) or recursively include another fully constructed
    verse via the `yield!` keyword.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`bingo`函数内部嵌套了三个函数：`buildNamePhrase`、`buildClapAndSpellPhrases`和`buildVerse`。这三个函数通过`buildstring`表达式构建一个`StringFragment`。在每个诗句的末尾，`buildstring`表达式包含一个`match`表达式，用来判断是否应该以`Zero`值（通过返回`unit`来隐含表示）结束，或者通过`yield!`关键字递归地包含另一个完全构造的诗句。'
- en: 'Evaluating the preceding snippet should print the following string (remember,
    the `%O` token formats the corresponding argument by calling its `ToString` method):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 评估前面的代码片段应该会打印出以下字符串（记住，`%O`标记会通过调用相应对象的`ToString`方法来格式化该参数）：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Computation expressions play an important role within F#. Out of the box, they
    make creating sequences, querying data from disparate data sources, and managing
    asynchronous operations appear to be a native part of the language by reusing
    familiar language elements. They’re also fully extensible, so you can define your
    own computation expressions by creating a builder class that constructs an instance
    of an underlying type. Creating custom computation expressions can be a tricky
    endeavor, but once you understand the purpose of each builder class method and
    the desugaring process, the result can be cleaner, more descriptive code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 计算表达式在F#中扮演着重要角色。开箱即用，它们使得创建序列、从不同数据源查询数据以及管理异步操作看起来像是语言的原生功能，借助了语言中熟悉的元素。它们还具有完全的可扩展性，因此你可以通过创建构建器类来定义自己的计算表达式，构造底层类型的实例。创建自定义的计算表达式可能是一个具有挑战性的任务，但一旦理解了每个构建器类方法的目的和去糖化过程，最终结果可以使代码更加简洁、具有描述性。
- en: It can be difficult to find good information about computation expressions,
    but there are a few resources you can use for further study. First, the computation
    expressions series at *F# for Fun and Profit* (*[http://fsharpforfunandprofit.com/series/computation-expressions.htm](http://fsharpforfunandprofit.com/series/computation-expressions.htm)*)
    has plenty of examples covering the range of builder methods. For some more real-world
    examples, check out the ExtCore project on GitHub (*[https://github.com/jack-pappas/ExtCore/](https://github.com/jack-pappas/ExtCore/)*),
    which contains several practical applications for computation expressions, such
    as a lazy list implementation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于计算表达式的信息可能比较难找，但你可以使用一些资源进行深入学习。首先，*F# for Fun and Profit*系列文章（* [http://fsharpforfunandprofit.com/series/computation-expressions.htm](http://fsharpforfunandprofit.com/series/computation-expressions.htm)
    *）提供了许多涵盖不同构建器方法的示例。如果你需要一些更真实的应用实例，可以查看GitHub上的ExtCore项目（* [https://github.com/jack-pappas/ExtCore/](https://github.com/jack-pappas/ExtCore/)*），其中包含了多个计算表达式的实际应用，如懒加载列表实现。
