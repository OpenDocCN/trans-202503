- en: 'Chapter 61. Sockets: Advanced Topics'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第61章 套接字：高级主题
- en: 'This chapter considers a range of more advanced topics relating to sockets
    programming, including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论与套接字编程相关的一些更高级的主题，包括以下内容：
- en: the circumstances in which partial reads and writes can occur on stream sockets;
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流套接字上发生部分读取和写入的情况；
- en: the use of *shutdown()* to close one half of the bidirectional channel between
    two connected sockets;
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*shutdown()*来关闭两个已连接套接字之间的单向通道；
- en: the *recv()* and *send()* I/O system calls, which provide socket-specific functionality
    not available with *read()* and *write()*;
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*recv()*和*send()* I/O系统调用，它们提供了套接字特有的功能，这是*read()*和*write()*所不具备的；'
- en: the *sendfile()* system call, which is used in certain circumstances to efficiently
    output data on a socket;
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sendfile()*系统调用，在某些情况下用于高效地在套接字上传输数据；'
- en: details of the operation of the TCP protocol, with the aim of eliminating some
    common misunderstandings that lead to mistakes when writing programs that use
    TCP sockets;
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP协议的操作细节，目的是消除一些常见的误解，这些误解可能导致在编写使用TCP套接字的程序时出现错误；
- en: the use of the *netstat* and *tcpdump* commands for monitoring and debugging
    applications that use sockets; and
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*netstat*和*tcpdump*命令来监视和调试使用套接字的应用程序；
- en: the use of the *getsockopt()* and *setsockopt()* system calls to retrieve and
    modify options affecting the operation of a socket.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*getsockopt()*和*setsockopt()*系统调用来检索和修改影响套接字操作的选项。
- en: We also consider a number of other more minor topics, and conclude the chapter
    with a summary of some advanced sockets features.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了一些其他较小的主题，并以总结一些高级套接字功能作为本章的结束。
- en: Partial Reads and Writes on Stream Sockets
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流套接字的部分读取和写入
- en: 'When we first introduced the *read()* and *write()* system calls in [Chapter 4](ch04.html
    "Chapter 4. File I/O: The Universal I/O Model"), we noted that, in some circumstances,
    they may transfer fewer bytes than requested. Such partial transfers can occur
    when performing I/O on stream sockets. We now consider why they can occur and
    show a pair of functions that transparently handle partial transfers.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次在[第4章](ch04.html "第4章 文件I/O：通用I/O模型")介绍*read()*和*write()*系统调用时，我们提到在某些情况下，它们可能传输的字节数少于请求的字节数。部分传输可以在流套接字上进行I/O时发生。我们现在考虑为什么它们会发生，并展示一对透明处理部分传输的函数。
- en: A partial read may occur if there are fewer bytes available in the socket than
    were requested in the *read()* call. In this case, *read()* simply returns the
    number of bytes available. (This is the same behavior that we saw with pipes and
    FIFOs in [Semantics of *read()* and *write()* on Pipes and FIFOs](ch44.html#semantics_of_read_open_parenthesis_close
    "Semantics of read() and write() on Pipes and FIFOs").)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果套接字中可用的字节数少于*read()*调用请求的字节数，则可能发生部分读取。在这种情况下，*read()*仅返回可用的字节数。（这与我们在[管道和FIFO的*read()*和*write()*语义](ch44.html#semantics_of_read_open_parenthesis_close
    "管道和FIFO的read()和write()语义")中看到的行为相同。）
- en: 'A partial write may occur if there is insufficient buffer space to transfer
    all of the requested bytes and one of the following is true:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缓冲区空间不足以传输所有请求的字节，并且以下之一为真，则可能发生部分写入：
- en: A signal handler interrupted the *write()* call ([Interruption and Restarting
    of System Calls](ch21.html#interruption_and_restarting_of_system_ca "Interruption
    and Restarting of System Calls")) after it transferred some of the requested bytes.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号处理程序在*write()*调用之后中断了操作（[系统调用的中断与重启](ch21.html#interruption_and_restarting_of_system_ca
    "系统调用的中断与重启")），该调用已经传输了部分请求的字节。
- en: The socket was operating in nonblocking mode (`O_NONBLOCK`), and it was possible
    to transfer only some of the requested bytes.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字在非阻塞模式下操作（`O_NONBLOCK`），并且只能传输部分请求的字节。
- en: An asynchronous error occurred after only some of the requested bytes had been
    transferred. By an *asynchronous error*, we mean an error that occurs asynchronously
    with respect to the application’s use of calls in the sockets API. An asynchronous
    error can arise, for example, because of a problem with a TCP connection, perhaps
    resulting from a crash by the peer application.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在仅传输了部分请求字节后发生了*异步错误*。这里所说的*异步错误*是指与应用程序使用套接字API调用无关的错误。例如，由于TCP连接出现问题，可能是由于对等应用程序崩溃所致。
- en: In all of the above cases, assuming that there was space to transfer at least
    1 byte, the *write()* is successful, and returns the number of bytes that were
    transferred to the output buffer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述所有情况中，假设至少有 1 个字节可以传输，*write()* 将成功，并返回传输到输出缓冲区的字节数。
- en: 'If a partial I/O occurs—for example, if a *read()* returns fewer bytes than
    requested or a blocked *write()* is interrupted by a signal handler after transferring
    only part of the requested data—then it is sometimes useful to restart the system
    call to complete the transfer. In [Example 61-1](ch61.html#implementation_of_readn_open_parenthesis
    "Example 61-1. Implementation of readn() and writen()"), we provide two functions
    that do this: *readn()* and *writen()*. (The ideas for these functions are drawn
    from functions of the same name presented in [Stevens et al., 2004].)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生部分 I/O，例如，如果 *read()* 返回的字节数少于请求的字节数，或被信号处理程序中断的阻塞 *write()* 仅传输了部分请求的数据，那么有时重新启动系统调用以完成传输是有用的。在[示例
    61-1](ch61.html#implementation_of_readn_open_parenthesis "示例 61-1. 读写函数 readn()
    和 writen() 的实现")中，我们提供了两个完成这一任务的函数：*readn()* 和 *writen()*。（这些函数的思路来源于[Stevens
    等，2004]中的同名函数。）
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes read, 0 on EOF, or -1 on error
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 返回读取的字节数，文件结束时返回 0，出错时返回 -1
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes written, or -1 on error
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 返回写入的字节数，如果出错则返回 -1
- en: The *readn()* and *writen()* functions take the same arguments as *read()* and
    *write()*. However, they use a loop to restart these system calls, thus ensuring
    that the requested number of bytes is always transferred (unless an error occurs
    or end-of-file is detected on a *read()*).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*readn()* 和 *writen()* 函数与 *read()* 和 *write()* 函数具有相同的参数。它们通过使用循环重新启动这些系统调用，从而确保请求的字节数总是被传输（除非发生错误或
    *read()* 检测到文件结束）。'
- en: Example 61-1. Implementation of *readn()* and *writen()*
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 61-1. *readn()* 和 *writen()* 的实现
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The *shutdown()* System Call
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*shutdown()* 系统调用'
- en: Calling *close()* on a socket closes both halves of the bidirectional communication
    channel. Sometimes, it is useful to close one half of the connection, so that
    data can be transmitted in just one direction through the socket. The *shutdown()*
    system call provides this functionality.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对套接字调用 *close()* 会关闭双向通信通道的两个端点。有时，关闭连接的一端是有用的，这样数据就可以只通过套接字单向传输。*shutdown()*
    系统调用提供了这一功能。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: 'The *shutdown()* system call closes one or both channels of the socket *sockfd*,
    depending on the value of *how*, which is specified as one of the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*shutdown()* 系统调用根据 *how* 的值来关闭套接字 *sockfd* 的一个或两个通道，*how* 的值可以是以下之一：'
- en: '`SHUT_RD`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHUT_RD`'
- en: Close the reading half of the connection. Subsequent reads will return end-of-file
    (0). Data can still be written to the socket. After a `SHUT_RD` on a UNIX domain
    stream socket, the peer application receives a `SIGPIPE` signal and the `EPIPE`
    error if it makes further attempts to write to the peer socket. As discussed in
    [Calling *shutdown()* on a TCP Socket](ch61.html#calling_shutdown_open_parenthesis_close
    "Calling shutdown() on a TCP Socket"), `SHUT_RD` can’t be used meaningfully for
    TCP sockets.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭连接的读取端。后续的读取将返回文件结束标志（0）。数据仍然可以写入套接字。在 UNIX 域流套接字上执行 `SHUT_RD` 后，对端应用程序如果继续写入对端套接字，将会收到
    `SIGPIPE` 信号，并且出现 `EPIPE` 错误。如在[对 TCP 套接字调用 *shutdown()*](ch61.html#calling_shutdown_open_parenthesis_close
    "对 TCP 套接字调用 shutdown()")中讨论，`SHUT_RD` 对于 TCP 套接字并无实际意义。
- en: '`SHUT_WR`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHUT_WR`'
- en: 'Close the writing half of the connection. Once the peer application has read
    all outstanding data, it will see end-of-file. Subsequent writes to the local
    socket yield the `SIGPIPE` signal and an `EPIPE` error. Data written by the peer
    can still be read from the socket. In other words, this operation allows us to
    signal end-of-file to the peer while still being able to read data that the peer
    sends back to us. The `SHUT_WR` operation is employed by programs such as *ssh*
    and *rsh* (refer to [Working with Symbolic Links: *symlink()* and *readlink()*](ch18.html#working_with_symbolic_links_colon_symlin
    "Working with Symbolic Links: symlink() and readlink()") of [Stevens, 1994]).
    The `SHUT_WR` operation is the most common use of *shutdown()*, and is sometimes
    referred to as a *socket half-close*.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭连接的写半部分。一旦对等应用程序读取完所有待处理数据，它将看到文件结束标志。后续写入本地套接字会触发`SIGPIPE`信号和`EPIPE`错误。对等方写入的数据仍然可以从套接字读取。换句话说，这个操作使我们能够向对等方发送文件结束标志，同时仍能读取对等方发送回我们的数据。`SHUT_WR`操作被*ssh*和*rsh*等程序使用（参见[操作符号链接：*symlink()*和*readlink()*](ch18.html#working_with_symbolic_links_colon_symlin
    "操作符号链接：symlink()和readlink()")，[Stevens, 1994]）。`SHUT_WR`操作是*shutdown()*最常见的用途，有时也被称为*套接字半关闭*。
- en: '`SHUT_RDWR`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHUT_RDWR`'
- en: Close both the read and the write halves of the connection. This is the same
    as performing a `SHUT_RD` followed by a `SHUT_WR`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭连接的读写两半。这等同于先执行`SHUT_RD`，然后执行`SHUT_WR`。
- en: 'Aside from the semantics of the *how* argument, *shutdown()* differs from *close()*
    in another important respect: it closes the socket channel(s) regardless of whether
    there are other file descriptors referring to the socket. (In other words, *shutdown()*
    is performing an operation on the open file description, rather than the file
    descriptor. See [Figure 5-1](ch05.html#failing_to_exclusively_create_a_file "Figure 5-1. Failing
    to exclusively create a file"), in [Creating a file exclusively](ch05.html#creating_a_file_exclusively-id1
    "Creating a file exclusively").) Suppose, for example, that *sockfd* refers to
    a connected stream socket. If we make the following calls, then the connection
    remains open, and we can still perform I/O on the connection via the file descriptor
    *fd2*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*how*参数的语义外，*shutdown()*与*close()*在另一个重要方面有所不同：无论是否存在其他文件描述符引用该套接字，*shutdown()*都会关闭套接字通道。（换句话说，*shutdown()*是在操作打开的文件描述，而不是文件描述符。请参见[图5-1](ch05.html#failing_to_exclusively_create_a_file
    "图5-1. 未能独占地创建文件")，在[独占创建文件](ch05.html#creating_a_file_exclusively-id1 "独占创建文件")一节。）例如，假设*sockfd*指向一个已连接的流套接字。如果我们按以下方式调用，那么连接将保持打开，并且我们仍然可以通过文件描述符*fd2*在该连接上执行I/O操作：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, if we make the following sequence of calls, then both channels of
    the connection are closed, and I/O can no longer be performed via *fd2*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们按以下顺序进行调用，那么连接的两个通道都会关闭，且无法通过*fd2*进行I/O操作：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A similar scenario holds if a file descriptor for a socket is duplicated during
    a *fork()*. If, after the *fork()*, one process does a `SHUT_RDWR` on its copy
    of the descriptor, then the other process also can no longer perform I/O on its
    descriptor.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行*fork()*时，套接字的文件描述符被复制，情况也类似。如果在*fork()*之后，一个进程在其副本上执行了`SHUT_RDWR`，那么另一个进程也将无法在其描述符上执行I/O操作。
- en: Note that *shutdown()* doesn’t close the file descriptor, even if *how* is specified
    as `SHUT_RDWR`. To close the file descriptor, we must additionally call *close()*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使*how*参数指定为`SHUT_RDWR`，*shutdown()*也不会关闭文件描述符。要关闭文件描述符，我们还需要额外调用*close()*。
- en: Example program
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 61-2](ch61.html#a_client_for_the_echo_service "Example 61-2. A client
    for the echo service") demonstrates the use of the *shutdown()* `SHUT_WR` operation.
    This program is a TCP client for the *echo* service. (We presented a TCP server
    for the *echo* service in Section 60.3.) To shorten the implementation, we make
    use of functions in the Internet domain sockets library shown in [An Internet
    Domain Sockets Library](ch59.html#an_internet_domain_sockets_library "An Internet
    Domain Sockets Library").'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例61-2](ch61.html#a_client_for_the_echo_service "示例61-2. 回声服务的客户端")演示了*shutdown()*的`SHUT_WR`操作。该程序是*回声*服务的TCP客户端。（我们在第60.3节中介绍了*回声*服务的TCP服务器。）为了简化实现，我们使用了[互联网域套接字库](ch59.html#an_internet_domain_sockets_library
    "互联网域套接字库")中显示的函数。'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In some Linux distributions, the *echo* service is not enabled by default, and
    therefore we must enable it before running the program in [Example 61-2](ch61.html#a_client_for_the_echo_service
    "Example 61-2. A client for the echo service"). Typically, this service is implemented
    internally by the *inetd(8)* daemon ([The *inetd* (Internet Superserver) Daemon](ch60.html#the_inetd_open_parenthesis_internet_supe
    "The inetd (Internet Superserver) Daemon")), and, to enable the *echo* service,
    we must edit the file `/etc/inetd.conf` to uncomment the two lines corresponding
    to the UDP and TCP *echo* services (see [Example 60-5](ch60.html#example_lines_from_solidus_etc_solidus_i
    "Example 60-5. Example lines from /etc/inetd.conf"), in [The `/etc/inetd.conf`
    file](ch60.html#the_solidus_etc_solidus_inetd.conf_file "The /etc/inetd.conf file")),
    and then send a `SIGHUP` signal to the *inetd* daemon.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 Linux 发行版中，*echo* 服务默认未启用，因此在运行 [示例 61-2](ch61.html#a_client_for_the_echo_service
    "示例 61-2. *echo* 服务的客户端") 前，我们必须先启用它。通常，该服务由 *inetd(8)* 守护进程（[The *inetd* (Internet
    Superserver) Daemon](ch60.html#the_inetd_open_parenthesis_internet_supe "The inetd
    (Internet Superserver) Daemon")）内部实现。为了启用 *echo* 服务，我们必须编辑文件 `/etc/inetd.conf`，取消注释与
    UDP 和 TCP *echo* 服务相关的两行（参见 [示例 60-5](ch60.html#example_lines_from_solidus_etc_solidus_i
    "示例 60-5. /etc/inetd.conf 中的示例行")，以及 [The `/etc/inetd.conf` 文件](ch60.html#the_solidus_etc_solidus_inetd.conf_file
    "The /etc/inetd.conf file")），然后向 *inetd* 守护进程发送 `SIGHUP` 信号。
- en: Many distributions supply the more modern *xinetd(8)* instead of *inetd(8)*.
    Consult the *xinetd* documentation for information about how to make the equivalent
    changes under *xinetd*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 许多发行版提供了更现代的 *xinetd(8)* 代替 *inetd(8)*。有关如何在 *xinetd* 中进行等效更改的信息，请参考 *xinetd*
    文档。
- en: As its single command-line argument, the program takes the name of the host
    on which the *echo* server is running. The client performs a *fork()*, yielding
    parent and child processes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其唯一的命令行参数，程序接受运行 *echo* 服务器的主机名称。客户端执行 *fork()*，产生父进程和子进程。
- en: The client parent writes the contents of standard input to the socket, so that
    it can be read by the *echo* server. When the parent detects end-of-file on standard
    input, it uses *shutdown()* to close the writing half of its socket. This causes
    the *echo* server to see end-of-file, at which point it closes its socket (which
    causes the client child in turn to see end-of-file). The parent then terminates.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端父进程将标准输入的内容写入套接字，以便 *echo* 服务器可以读取。当父进程检测到标准输入的文件结束时，它使用 *shutdown()* 来关闭其套接字的写入半部分。这会导致
    *echo* 服务器看到文件结束，此时它关闭其套接字（这反过来会导致客户端子进程看到文件结束）。然后父进程终止。
- en: The client child reads the *echo* server’s response from the socket and echoes
    the response on standard output. The child terminates when it sees end-of-file
    on the socket.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端子进程从套接字读取 *echo* 服务器的响应，并将响应回显到标准输出。当它在套接字上看到文件结束时，子进程终止。
- en: 'The following shows an example of what we see when running this program:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了运行此程序时我们看到的示例：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Example 61-2. A client for the *echo* service
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 61-2. *echo* 服务的客户端
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Socket-Specific I/O System Calls: *recv()* and *send()*'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套接字特定的 I/O 系统调用：*recv()* 和 *send()*
- en: The *recv()* and *send()* system calls perform I/O on connected sockets. They
    provide socket-specific functionality that is not available with the traditional
    *read()* and *write()* system calls.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*recv()* 和 *send()* 系统调用在连接的套接字上执行 I/O 操作。它们提供了传统的 *read()* 和 *write()* 系统调用所不具备的套接字特定功能。'
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes received, 0 on EOF, or -1 on error
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 返回接收到的字节数，文件结束时返回 0，出错时返回 -1。
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes sent, or -1 on error
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 返回发送的字节数，出错时返回 -1。
- en: 'The return value and the first three arguments to *recv()* and *send()* are
    the same as for *read()* and *write()*. The last argument, *flags*, is a bit mask
    that modifies the behavior of the I/O operation. For *recv()*, the bits that may
    be ORed in *flags* include the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*recv()* 和 *send()* 的返回值及前三个参数与 *read()* 和 *write()* 相同。最后一个参数 *flags* 是一个位掩码，修改
    I/O 操作的行为。对于 *recv()*，可以在 *flags* 中进行或运算的位包括以下内容：'
- en: '`MSG_DONTWAIT`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSG_DONTWAIT`'
- en: Perform a nonblocking *recv()*. If no data is available, then instead of blocking,
    return immediately with the error `EAGAIN`. We can obtain the same behavior by
    using *fcntl()* to set nonblocking mode (`O_NONBLOCK`) on the socket, with the
    difference that `MSG_DONTWAIT` allows us to control nonblocking behavior on a
    per-call basis.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 执行非阻塞的 *recv()*。如果没有数据可用，则不阻塞，而是立即返回错误 `EAGAIN`。我们可以通过使用 *fcntl()* 设置套接字的非阻塞模式（`O_NONBLOCK`）来获得相同的行为，区别在于
    `MSG_DONTWAIT` 允许我们在每次调用时控制非阻塞行为。
- en: '`MSG_OOB`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSG_OOB`'
- en: Receive out-of-band data on the socket. We briefly describe this feature in
    [Out-of-Band Data](ch61.html#out-of-band_data "Out-of-Band Data").
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在套接字上接收带外数据。我们在[带外数据](ch61.html#out-of-band_data "Out-of-Band Data")中简要描述了此功能。
- en: '`MSG_PEEK`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSG_PEEK`'
- en: Retrieve a copy of the requested bytes from the socket buffer, but don’t actually
    remove them from the buffer. The data can later be reread by another *recv()*
    or *read()* call.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从套接字缓冲区中获取请求的字节的副本，但不将其实际从缓冲区中移除。数据可以通过另一次 *recv()* 或 *read()* 调用重新读取。
- en: '`MSG_WAITALL`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSG_WAITALL`'
- en: 'Normally, a *recv()* call returns the lesser of the number of bytes requested
    (*length*) and the number of bytes actually available in the socket. Specifying
    the `MSG_WAITALL` flag causes the system call to block until *length* bytes have
    been received. However, even when this flag is specified, the call may return
    fewer bytes than requested if: (a) a signal is caught; (b) the peer on a stream
    socket terminated the connection; (c) an out-of-band data byte ([Out-of-Band Data](ch61.html#out-of-band_data
    "Out-of-Band Data")) was encountered; (d) the received message from a datagram
    socket is less than *length* bytes; or (e) an error occurs on the socket. (The
    `MSG_WAITALL` flag can replace the *readn()* function that we show in [Example 61-1](ch61.html#implementation_of_readn_open_parenthesis
    "Example 61-1. Implementation of readn() and writen()"), with the difference that
    our *readn()* function does restart itself if interrupted by a signal handler.)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*recv()* 调用返回请求的字节数（*length*）和套接字中实际可用字节数中较小的值。指定 `MSG_WAITALL` 标志会使系统调用阻塞，直到接收到
    *length* 字节。然而，即使指定了此标志，如果发生以下情况，调用可能会返回比请求的字节数少的字节数：（a）捕获到信号；（b）流套接字的对端终止了连接；（c）遇到带外数据字节（[带外数据](ch61.html#out-of-band_data
    "Out-of-Band Data")）；（d）来自数据报套接字的接收消息少于 *length* 字节；或（e）套接字发生错误。（`MSG_WAITALL`
    标志可以替代我们在[示例 61-1](ch61.html#implementation_of_readn_open_parenthesis "Example
    61-1. Implementation of readn() and writen()")中展示的 *readn()* 函数，区别在于我们的 *readn()*
    函数会在信号处理程序中断时重新启动。）
- en: All of the above flags are specified in SUSv3, except for `MSG_DONTWAIT`, which
    is nevertheless available on some other UNIX implementations. The `MSG_WAITALL`
    flag was a later addition to the sockets API, and is not present in some older
    implementations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述所有标志在 SUSv3 中都有说明，除了 `MSG_DONTWAIT`，但它在某些其他 UNIX 实现中仍然可用。`MSG_WAITALL` 标志是后来的添加到套接字
    API 中，在一些旧版本的实现中没有此标志。
- en: 'For *send()*, the bits that may be ORed in *flags* include the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *send()*，*flags* 中可以进行按位或的位包括以下内容：
- en: '`MSG_DONTWAIT`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSG_DONTWAIT`'
- en: Perform a nonblocking *send()*. If the data can’t be immediately transferred
    (because the socket send buffer is full), then, instead of blocking, fail with
    the error `EAGAIN`. As with *recv()*, the same effect can be achieved by setting
    the `O_NONBLOCK` flag for the socket.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 执行非阻塞 *send()*。如果数据无法立即传输（因为套接字发送缓冲区已满），则不会阻塞，而是返回错误 `EAGAIN`。与 *recv()* 一样，通过为套接字设置
    `O_NONBLOCK` 标志也可以实现相同的效果。
- en: '`MSG_MORE` (since Linux 2.4.4)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSG_MORE`（自 Linux 2.4.4 起）'
- en: This flag is used with TCP sockets to achieve the same effect as the `TCP_CORK`
    socket option ([The *sendfile()* System Call](ch61.html#the_sendfile_open_parenthesis_close_pare
    "The sendfile() System Call")), with the difference that it provides corking of
    data on a per-call basis. Since Linux 2.6, this flag can also be used with datagram
    sockets, where it has a different meaning. Data transmitted in successive *send()*
    or *sendto()* calls specifying `MSG_MORE` is packaged into a single datagram that
    is transmitted only when a further call is made that does not specify this flag.
    (Linux also provides an analogous `UDP_CORK` socket option that causes data from
    successive *send()* or *sendto()* calls to be accumulated into a single datagram
    that is transmitted when `UDP_CORK` is disabled.) The `MSG_MORE` flag has no effect
    for UNIX domain sockets.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志与 TCP 套接字一起使用，达到与 `TCP_CORK` 套接字选项相同的效果（[*sendfile()* 系统调用](ch61.html#the_sendfile_open_parenthesis_close_pare
    "The sendfile() System Call")），其区别在于它提供了按调用次数为单位的数据“塞栓”。自 Linux 2.6 起，此标志也可以与数据报套接字一起使用，其含义不同。在连续的
    *send()* 或 *sendto()* 调用中指定 `MSG_MORE` 的数据被打包成一个单独的数据报，只有在不指定此标志的进一步调用时，数据才会被传输。（Linux
    还提供了类似的 `UDP_CORK` 套接字选项，使得来自连续 *send()* 或 *sendto()* 调用的数据被累积成一个数据报，在禁用 `UDP_CORK`
    时传输。）`MSG_MORE` 标志对 UNIX 域套接字没有影响。
- en: '`MSG_NOSIGNAL`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSG_NOSIGNAL`'
- en: When sending data on a connected stream socket, don’t generate a `SIGPIPE` signal
    if the other end of the connection has been closed. Instead, the *send()* call
    fails with the error `EPIPE`. This is the same behavior as can be obtained by
    ignoring the `SIGPIPE` signal, with the difference that the `MSG_NOSIGNAL` flag
    controls the behavior on a per-call basis.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当在已连接的流套接字上发送数据时，如果连接的另一端已关闭，不要生成`SIGPIPE`信号。相反，*send()*调用会因错误`EPIPE`而失败。这与忽略`SIGPIPE`信号时获得的行为相同，区别在于`MSG_NOSIGNAL`标志按调用逐个控制行为。
- en: '`MSG_OOB`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSG_OOB`'
- en: Send out-of-band data on a stream socket. Refer to [Out-of-Band Data](ch61.html#out-of-band_data
    "Out-of-Band Data").
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在流套接字上发送带外数据。请参阅[带外数据](ch61.html#out-of-band_data "带外数据")。
- en: Of the above flags, only `MSG_OOB` is specified by SUSv3\. SUSv4 adds a specification
    for `MSG_NOSIGNAL. MSG_DONTWAIT` is not standardized, but appears on a few other
    UNIX implementations. `MSG_MORE` is Linux-specific. The *send(2)* and *recv(2)*
    manual pages describe further flags that we don’t cover here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述标志中，只有`MSG_OOB`由SUSv3指定。SUSv4增加了`MSG_NOSIGNAL`的规范。`MSG_DONTWAIT`不是标准化的，但出现在一些其他的UNIX实现中。`MSG_MORE`是Linux特有的。*send(2)*和*recv(2)*手册页面描述了更多的标志，这里不再涉及。
- en: The *sendfile()* System Call
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*sendfile()*系统调用'
- en: 'Applications such as web servers and file servers frequently need to transfer
    the unaltered contents of a disk file through a (connected) socket. One way to
    do this would be a loop of the following form:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Web 服务器和文件服务器等应用程序经常需要通过（已连接的）套接字传输磁盘文件的未修改内容。实现这一功能的一种方法是使用以下形式的循环：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For many applications, such a loop is perfectly acceptable. However, if we
    frequently transfer large files via a socket, this technique is inefficient. In
    order to transmit the file, we must use two system calls (possibly multiple times
    within a loop): one to copy the file contents from the kernel buffer cache into
    user space, and the other to copy the user-space buffer back to kernel space in
    order to be transmitted via the socket. This scenario is shown on the left side
    of [Figure 61-1](ch61.html#transferring_the_contents_of_a_file_to_a "Figure 61-1. Transferring
    the contents of a file to a socket"). Such a two-step process is wasteful if the
    application doesn’t perform any processing of the file contents before transmitting
    them. The *sendfile()* system call is designed to eliminate this inefficiency.
    When an application calls *sendfile()*, the file contents are transferred directly
    to the socket, without passing through user space, as shown on the right side
    of [Figure 61-1](ch61.html#transferring_the_contents_of_a_file_to_a "Figure 61-1. Transferring
    the contents of a file to a socket"). This is referred to as a *zero-copy transfer*.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用程序，这样的循环是完全可以接受的。然而，如果我们通过套接字频繁传输大文件，这种技术效率低下。为了传输文件，我们必须使用两次系统调用（可能在循环内多次调用）：一次是将文件内容从内核缓冲区复制到用户空间，另一次是将用户空间的缓冲区复制回内核空间，以便通过套接字传输。该场景如[图61-1](ch61.html#transferring_the_contents_of_a_file_to_a
    "图61-1. 将文件内容传输到套接字")左侧所示。如果应用程序在传输文件内容之前不对其进行处理，这种两步过程是浪费的。*sendfile()*系统调用旨在消除这种低效。当应用程序调用*sendfile()*时，文件内容会直接传输到套接字，而无需经过用户空间，如[图61-1](ch61.html#transferring_the_contents_of_a_file_to_a
    "图61-1. 将文件内容传输到套接字")右侧所示。这被称为*零拷贝传输*。
- en: '![Transferring the contents of a file to a socket](figs/web/61-1_SOCKADV-sendfile.png.jpg)Figure 61-1. Transferring
    the contents of a file to a socket'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![将文件内容传输到套接字](figs/web/61-1_SOCKADV-sendfile.png.jpg)图61-1。将文件内容传输到套接字'
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes transferred, or -1 on error
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 返回传输的字节数，出错时返回-1
- en: The *sendfile()* system call transfers bytes from the file referred to by the
    descriptor *in_fd* to the file referred to by the descriptor *out_fd*. The *out_fd*
    descriptor must refer to a socket. The *in_fd* argument must refer to a file to
    which *mmap()* can be applied; in practice, this usually means a regular file.
    This somewhat restricts the use of *sendfile()*. We can use it to pass data from
    a file to a socket, but not vice versa. And we can’t use *sendfile()* to pass
    data directly from one socket to another.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*sendfile()*系统调用将由描述符*in_fd*引用的文件中的字节传输到由描述符*out_fd*引用的文件中。*out_fd*描述符必须引用一个套接字。*in_fd*参数必须引用一个可以应用*mmap()*的文件；实际上，这通常意味着一个常规文件。这在某种程度上限制了*sendfile()*的使用。我们可以用它将数据从文件传输到套接字，但不能反向操作。而且，我们不能使用*sendfile()*将数据直接从一个套接字传输到另一个套接字。'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Performance benefits could also be obtained if *sendfile()* could be used to
    transfer bytes between two regular files. On Linux 2.4 and earlier, *out_fd* could
    refer to a regular file. Some reworking of the underlying implementation meant
    that this possibility disappeared in the 2.6 kernel. However, this feature may
    be reinstated in a future kernel version.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*sendfile()*可以用来在两个常规文件之间传输字节，也可以获得性能上的好处。在Linux 2.4及更早版本中，*out_fd*可以指向一个常规文件。一些底层实现的重构意味着这个功能在2.6内核中消失了。然而，这个功能可能会在未来的内核版本中恢复。
- en: If *offset* is not `NULL`, then it should point to an *off_t* value that specifies
    the starting file offset from which bytes should be transferred from *in_fd*.
    This is a value-result argument. On return, it contains the offset of the next
    byte following the last byte that was transferred from *in_fd*. In this case,
    *sendfile()* doesn’t change the file offset for *in_fd*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*offset*不是`NULL`，则它应指向一个*off_t*类型的值，该值指定从*in_fd*中传输字节的起始文件偏移量。这是一个值结果参数。返回时，它包含从*in_fd*中传输的最后一个字节之后的下一个字节的偏移量。在这种情况下，*sendfile()*不会更改*in_fd*的文件偏移量。
- en: If *offset* is `NULL`, then bytes are transferred from *in_fd* starting at the
    current file offset, and the file offset is updated to reflect the number of bytes
    transferred.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*offset*是`NULL`，则字节将从*in_fd*的当前文件偏移处开始传输，并且文件偏移量将更新以反映传输的字节数。
- en: The *count* argument specifies the number of bytes to be transferred. If end-of-file
    is encountered before *count* bytes are transferred, only the available bytes
    are transferred. On success, *sendfile()* returns the number of bytes actually
    transferred.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*count*参数指定要传输的字节数。如果在传输*count*字节之前遇到文件结尾，则仅传输可用的字节。成功时，*sendfile()*返回实际传输的字节数。'
- en: SUSv3 doesn’t specify *sendfile()*. Versions of *sendfile()* are available on
    some other UNIX implementations, but the argument list is typically different
    from the version on Linux.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3并未指定*sendfile()*。某些其他UNIX实现中提供了*sendfile()*的版本，但其参数列表通常与Linux版本不同。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with kernel 2.6.17, Linux provides three new (nonstandard) system calls—*splice()*,
    *vmsplice()*, and *tee()*—that provide a superset of the functionality of *sendfile()*.
    See the manual pages for details.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从2.6.17内核开始，Linux提供了三个新的（非标准的）系统调用——*splice()*、*vmsplice()*和*tee()*——它们提供了*sendfile()*功能的超集。有关详细信息，请参阅手册页。
- en: The `TCP_CORK` socket option
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`TCP_CORK`套接字选项'
- en: 'To further improve the efficiency of TCP applications using *sendfile()*, it
    is sometimes useful to employ the Linux-specific `TCP_CORK` socket option. As
    an example, consider a web server delivering a page in response to a request by
    a web browser. The web server’s response consists of two parts: HTTP headers,
    perhaps output using *write()*, followed by the page data, perhaps output using
    *sendfile()*. In this scenario, normally *two* TCP segments are transmitted: the
    headers are sent in the first (rather small) segment, and then the page data is
    sent in a second segment. This is an inefficient use of network bandwidth. It
    probably also creates unnecessary work for both the sending and the receiving
    TCP, since in many cases the HTTP headers and the page data would be small enough
    to fit inside a single TCP segment. The `TCP_CORK` option is designed to address
    this inefficiency.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步提高使用*sendfile()*的TCP应用程序的效率，有时使用Linux特有的`TCP_CORK`套接字选项是有益的。例如，考虑一个web服务器响应浏览器请求并传送网页的场景。web服务器的响应由两部分组成：HTTP头部，可能通过*write()*输出，然后是网页数据，可能通过*sendfile()*输出。在这种情况下，通常会传输*两个*TCP段：头部在第一个（相对较小的）段中发送，然后页面数据在第二个段中发送。这种网络带宽的使用效率低下。它可能还会为发送和接收的TCP带来不必要的工作，因为在许多情况下，HTTP头部和页面数据足够小，可以放入一个单独的TCP段中。`TCP_CORK`选项旨在解决这个低效问题。
- en: When the `TCP_CORK` option is enabled on a TCP socket, all subsequent output
    is buffered into a single TCP segment until either the upper limit on the size
    of a segment is reached, the `TCP_CORK` option is disabled, the socket is closed,
    or a maximum of 200 milliseconds passes from the time that the first corked byte
    is written. (The timeout ensures that the corked data is transmitted if the application
    forgets to disable the `TCP_CORK` option.)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当`TCP_CORK`选项在TCP套接字上启用时，所有后续的输出都会被缓冲到一个单一的TCP段中，直到达到段大小的上限、`TCP_CORK`选项被禁用、套接字被关闭，或从第一次写入被“塞住”字节的时刻起经过最多200毫秒。（这个超时确保了如果应用程序忘记禁用`TCP_CORK`选项，仍然能够传输已塞住的数据。）
- en: 'We enable and disable the `TCP_CORK` option using the *setsockopt()* system
    call ([Socket Options](ch61.html#socket_options "Socket Options")). The following
    code (which omits error checking) demonstrates the use of `TCP_CORK` for our hypothetical
    HTTP server example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 *setsockopt()* 系统调用启用和禁用 `TCP_CORK` 选项（[套接字选项](ch61.html#socket_options
    "Socket Options")）。以下代码（省略了错误检查）演示了如何在我们的假设 HTTP 服务器示例中使用 `TCP_CORK`：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We could avoid the possibility of two segments being transmitted by building
    a single data buffer within our application, and then transmitting that buffer
    with a single *write()*. (Alternatively, we could use *writev()* to combine two
    distinct buffers in a single output operation.) However, if we want to combine
    the zero-copy efficiency of *sendfile()* with the ability to include a header
    as part of the first segment of transmitted file data, then we need to use `TCP_CORK`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在应用程序中构建一个单一的数据缓冲区，然后使用一次 *write()* 传输该缓冲区，来避免两个数据段被传输的可能性。（另外，我们也可以使用
    *writev()* 将两个不同的缓冲区合并成一次输出操作。）然而，如果我们想要结合 *sendfile()* 的零拷贝效率，同时能够将一个头部包含在传输文件数据的第一个数据段中，那么我们需要使用
    `TCP_CORK`。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In [Socket-Specific I/O System Calls: *recv()* and *send()*](ch61.html#socket-specific_i_solidus_o_system_calls
    "Socket-Specific I/O System Calls: recv() and send()"), we noted that the `MSG_MORE`
    flag provides similar functionality to `TCP_CORK`, but on a per-system-call basis.
    This is not necessarily an advantage. It is possible to set the `TCP_CORK` option
    on the socket, and then exec a program that performs output on the inherited file
    descriptor without being aware of the `TCP_CORK` option. By contrast, the use
    of `MSG_MORE` requires explicit changes to the source code of a program.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '在 [Socket-Specific I/O System Calls: *recv()* 和 *send()*](ch61.html#socket-specific_i_solidus_o_system_calls
    "Socket-Specific I/O System Calls: recv() and send()") 中，我们提到过 `MSG_MORE` 标志提供了类似于
    `TCP_CORK` 的功能，但它是按每次系统调用来处理的。这不一定是一个优势。可以在套接字上设置 `TCP_CORK` 选项，然后执行一个程序，该程序在继承的文件描述符上执行输出，而不需要知道
    `TCP_CORK` 选项。相比之下，使用 `MSG_MORE` 需要明确修改程序的源代码。'
- en: FreeBSD provides an option similar to `TCP_CORK` in the form of `TCP_NOPUSH`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 提供了类似于 `TCP_CORK` 的选项，形式为 `TCP_NOPUSH`。
- en: Retrieving Socket Addresses
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取套接字地址
- en: The *getsockname()* and *getpeername()* system calls return, respectively, the
    local address to which a socket is bound and the address of the peer socket to
    which the local socket is connected.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*getsockname()* 和 *getpeername()* 系统调用分别返回本地套接字绑定的本地地址和本地套接字所连接的对等套接字地址。'
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: For both calls, *sockfd* is a file descriptor referring to a socket, and *addr*
    is a pointer to a suitably sized buffer that is used to return a structure containing
    the socket address. The size and type of this structure depend on the socket domain.
    The *addrlen* argument is a value-result argument. Before the call, it should
    be initialized to the length of the buffer pointed to by *addr*; on return, it
    contains the number of bytes actually written to this buffer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两个调用，*sockfd* 是一个指向套接字的文件描述符，*addr* 是一个指向适当大小缓冲区的指针，该缓冲区用于返回包含套接字地址的结构体。该结构体的大小和类型取决于套接字的域。*addrlen*
    参数是一个值结果参数。在调用之前，它应该被初始化为 *addr* 指向的缓冲区的长度；返回时，它包含实际写入该缓冲区的字节数。
- en: The *getsockname()* function returns a socket’s address family and the address
    to which a socket is bound. This is useful if the socket was bound by another
    program (e.g., *inetd(8)*) and the socket file descriptor was then preserved across
    an *exec()*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*getsockname()* 函数返回套接字的地址族和套接字绑定的地址。如果套接字是由其他程序（例如 *inetd(8)*) 绑定的，且套接字文件描述符在
    *exec()* 过程中被保留，则这非常有用。'
- en: 'Calling *getsockname()* is also useful if we want to determine the ephemeral
    port number that the kernel assigned to a socket when performing an implicit bind
    of an Internet domain socket. The kernel performs an implicit bind in the following
    circumstances:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 *getsockname()* 也很有用，如果我们想要确定内核在执行隐式绑定一个 Internet 域套接字时为套接字分配的临时端口号。内核会在以下情况下执行隐式绑定：
- en: after a *connect()* or a *listen()* call on a TCP socket that has not previously
    been bound to an address by *bind()*;
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对一个尚未通过 *bind()* 绑定地址的 TCP 套接字调用 *connect()* 或 *listen()* 后；
- en: on the first *sendto()* on a UDP socket that had not previously been bound to
    an address; or
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对一个尚未绑定地址的 UDP 套接字进行第一次 *sendto()* 调用时；或者
- en: after a *bind()* call where the port number (*sin_port*) was specified as 0\.
    In this case, the *bind()* specifies the IP address for the socket, but the kernel
    selects an ephemeral port number.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*bind()*调用后，端口号（*sin_port*）指定为0。在这种情况下，*bind()*指定了套接字的IP地址，但内核会选择一个临时的端口号。
- en: The *getpeername()* system call returns the address of the peer socket on a
    stream socket connection. This is useful primarily with TCP sockets, if the server
    wants to find out the address of the client that has made a connection. This information
    could also be obtained when the *accept()* call is performed; however, if the
    server was execed by the program that did the *accept()* (e.g., *inetd*), then
    it inherits the socket file descriptor, but the address information returned by
    *accept()* is no longer available.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*getpeername()*系统调用返回流套接字连接的对等套接字的地址。这在TCP套接字中尤其有用，尤其是当服务器想要找出已建立连接的客户端的地址时。也可以在执行*accept()*调用时获得该信息；然而，如果服务器是由执行了*accept()*的程序（例如，*inetd*）启动的，则它会继承套接字文件描述符，但*accept()*返回的地址信息不再可用。'
- en: '[Example 61-3](ch61.html#using_getsockname_open_parenthesis_close "Example 61-3. Using
    getsockname() and getpeername()") demonstrates the use of *getsockname()* and
    *getpeername()*. This program employs the functions that we defined in [Example 59-9](ch59.html#an_internet_domain_sockets_librar
    "Example 59-9. An Internet domain sockets library") (in [An Internet Domain Sockets
    Library](ch59.html#an_internet_domain_sockets_library "An Internet Domain Sockets
    Library")), and performs the following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 61-3](ch61.html#using_getsockname_open_parenthesis_close "示例 61-3. 使用 getsockname()
    和 getpeername()")演示了*getsockname()*和*getpeername()*的使用。此程序使用我们在[示例 59-9](ch59.html#an_internet_domain_sockets_librar
    "示例 59-9. 一个互联网域套接字库")中定义的函数（在[一个互联网域套接字库](ch59.html#an_internet_domain_sockets_library
    "一个互联网域套接字库")中），并执行以下步骤：'
- en: Use our *inetListen()* function to create a listening socket, *listenFd*, bound
    to the wildcard IP address and the port specified in the program’s sole command-line
    argument. (The port can be specified numerically or as a service name.) The *len*
    argument returns the length of the address structure for this socket’s domain.
    This value is passed in a later call to *malloc()* to allocate a buffer that is
    used to return a socket address from calls to *getsockname()* and *getpeername()*.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的*inetListen()*函数创建一个监听套接字，*listenFd*，该套接字绑定到程序唯一命令行参数指定的通配符IP地址和端口。（端口可以通过数字指定，也可以通过服务名称指定。）*len*参数返回此套接字域的地址结构的长度。这个值会在稍后的*malloc()*调用中传递，用于分配一个缓冲区，该缓冲区用于从*getsockname()*和*getpeername()*调用中返回套接字地址。
- en: Use our *inetConnect()* function to create a second socket, *connFd*, which
    is used to send a connection request to the socket created in step 1.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的*inetConnect()*函数创建第二个套接字，*connFd*，该套接字用于向第一步中创建的套接字发送连接请求。
- en: Call *accept()* on the listening socket in order to create a third socket, *acceptFd*,
    that is connected to the socket created in the previous step.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在监听套接字上调用*accept()*以创建一个第三个套接字，*acceptFd*，该套接字与前一步创建的套接字建立连接。
- en: Use calls to *getsockname()* and *getpeername()* to obtain the local and peer
    addresses for the two connected sockets, *connFd* and *acceptFd*. After each of
    these calls, the program uses our *inetAddressStr()* function to convert the socket
    address into printable form.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*getsockname()*和*getpeername()*调用获取两个已连接套接字（*connFd*和*acceptFd*）的本地和对等地址。在每次调用之后，程序使用我们的*inetAddressStr()*函数将套接字地址转换为可打印的形式。
- en: Sleep for a few seconds so that we can run *netstat* in order to confirm the
    socket address information. (We describe *netstat* in Section 61.7.)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稍等几秒钟，以便我们可以运行*netstat*来确认套接字地址信息。（我们在第61.7节中描述了*netstat*）
- en: 'The following shell session log shows an example run of this program:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例程序运行的Shell会话日志：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: From the above output, we can see that the connected socket (*connFd*) was bound
    to the ephemeral port 32835\. The *netstat* command shows us information about
    all three sockets created by the program, and allows us to confirm the port information
    for the two connected sockets, which are in the ESTABLISHED state (described in
    [TCP State Machine and State Transition Diagram](ch61.html#tcp_state_machine_and_state_transition_d
    "TCP State Machine and State Transition Diagram")).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中，我们可以看到已连接的套接字（*connFd*）已绑定到临时端口32835\. *netstat*命令展示了程序创建的所有三个套接字的信息，并允许我们确认两个连接套接字的端口信息，这两个套接字处于已建立（ESTABLISHED）状态（在[TCP状态机和状态转换图](ch61.html#tcp_state_machine_and_state_transition_d
    "TCP State Machine and State Transition Diagram")中描述）。
- en: Example 61-3. Using *getsockname()* and *getpeername()*
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 61-3. 使用 *getsockname()* 和 *getpeername()*
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A Closer Look at TCP
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更深入了解 TCP
- en: 'Knowing some of the details of the operation of TCP helps us to debug applications
    that use TCP sockets, and, in some cases, to make such applications more efficient.
    In the following sections, we look at:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 TCP 操作的某些细节可以帮助我们调试使用 TCP 套接字的应用程序，并在某些情况下提高应用程序的效率。在接下来的部分，我们将探讨：
- en: the format of TCP segments;
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP 段的格式；
- en: the TCP acknowledgement scheme;
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP 确认机制；
- en: the TCP state machine;
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP 状态机；
- en: TCP connection establishment and termination; and
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP 连接的建立和终止；
- en: the TCP TIME_WAIT state.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP TIME_WAIT 状态。
- en: Format of a TCP Segment
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP 段格式
- en: '[Figure 61-2](ch61.html#format_of_a_tcp_segment-id1 "Figure 61-2. Format of
    a TCP segment") shows the format of the TCP segments that are exchanged between
    the endpoints of a TCP connection. The meanings of these fields are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 61-2](ch61.html#format_of_a_tcp_segment-id1 "Figure 61-2. Format of a TCP
    segment") 显示了 TCP 连接的端点之间交换的 TCP 段的格式。各字段的含义如下：'
- en: '*Source port number*: This is the port number of the sending TCP.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*源端口号*：这是发送方 TCP 的端口号。'
- en: '*Destination port number*: This is the port number of the destination TCP.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*目标端口号*：这是目标 TCP 的端口号。'
- en: '*Sequence number*: This is the sequence number for this segment. This is the
    offset of the first byte of data in this segment within the stream of data being
    transmitted in this direction over the connection, as described in [Transmission
    Control Protocol (TCP)](ch58.html#transmission_control_protocol_open_paren "Transmission
    Control Protocol (TCP)").'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*序列号*：这是该段的序列号。它是该段中第一个数据字节相对于在此连接方向上传输的数据流中的偏移量，如 [传输控制协议（TCP）](ch58.html#transmission_control_protocol_open_paren
    "Transmission Control Protocol (TCP)") 中所述。'
- en: '![Format of a TCP segment](figs/web/61-2_SOCKADV-TCP-segment.png.jpg)Figure 61-2. Format
    of a TCP segment'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![TCP 段格式](figs/web/61-2_SOCKADV-TCP-segment.png.jpg)图 61-2. TCP 段格式'
- en: '*Acknowledgement number*: If the ACK bit (see below) is set, then this field
    contains the sequence number of the next byte of data that the receiver expects
    to receive from the sender.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确认号*：如果 ACK 位（见下文）被设置，则此字段包含接收方期望从发送方接收的下一个字节的数据的序列号。'
- en: '*Header length*: This is the length of the header, in units of 32-bit words.
    Since this is a 4-bit field, the total header length can be up to 60 bytes (15
    words). This field enables the receiving TCP to determine the length of the variable-length
    *options* field and the starting point of the *data*.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*头部长度*：这是头部的长度，单位为 32 位字。由于这是一个 4 位字段，总的头部长度最多可以是 60 字节（15 个字）。该字段使接收方 TCP
    能够确定可变长度 *选项* 字段的长度以及 *数据* 的起始点。'
- en: '*Reserved*: This consists of 4 unused bits (must be set to 0).'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保留*：该字段由 4 位未使用的比特组成（必须设置为 0）。'
- en: '*Control bits*: This field consists of 8 bits that further specify the meaning
    of the segment:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制位*：此字段由 8 位组成，进一步指定该段的含义：'
- en: '*CWR*: the *congestion window reduced* flag.'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CWR*：*拥塞窗口减少*标志。'
- en: '*ECE*: the *explicit congestion notification echo* flag. The CWR and ECE flags
    are used as part of TCP/IP’s Explicit Congestion Notification (ECN) algorithm.
    ECN is a relatively recent addition to TCP/IP and is described in RFC 3168 and
    in [Floyd, 1994]. ECN is implemented in Linux from kernel 2.4 onward, and enabled
    by placing a nonzero value in the Linux-specific `/proc/sys/net/ipv4/tcp_ecn`
    file.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ECE*：*显式拥塞通知回显*标志。CWR 和 ECE 标志作为 TCP/IP 显式拥塞通知（ECN）算法的一部分。ECN 是 TCP/IP 中相对较新的添加项，描述详见
    RFC 3168 和 [Floyd, 1994]。ECN 从 Linux 内核 2.4 版本起得到支持，并通过将非零值放入 Linux 特定的 `/proc/sys/net/ipv4/tcp_ecn`
    文件中启用。'
- en: '*URG*: if set, then the *urgent pointer* field contains valid information.'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*URG*：如果设置，则 *紧急指针* 字段包含有效信息。'
- en: '*ACK*: if set, then the *acknowledgement number* field contains valid information
    (i.e., this segment acknowledges data previously sent by the peer).'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ACK*：如果设置，则 *确认号* 字段包含有效信息（即该段确认了先前由对端发送的数据）。'
- en: '*PSH*: push all received data to the receiving process. This flag is described
    in RFC 993 and in [Stevens, 1994].'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PSH*：将所有接收到的数据推送到接收进程。此标志在 RFC 993 和 [Stevens, 1994] 中有所描述。'
- en: '*RST*: reset the connection. This is used to handle various error situations.'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RST*：重置连接。此标志用于处理各种错误情况。'
- en: '*SYN*: synchronize sequence numbers. Segments with this flag set are exchanged
    during connection establishment to allow the two TCPs to specify the initial sequence
    numbers to be used for transferring data in each direction.'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SYN*：同步序列号。带有此标志的段在连接建立期间交换，以允许两个TCP指定用于每个方向数据传输的初始序列号。'
- en: '*FIN*: used by a sender to indicate that it has finished sending data.'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FIN*：由发送方使用，表示它已经完成数据发送。'
- en: Multiple control bits (or none at all) may be set in a segment, which allows
    a single segment to serve multiple purposes. For example, we’ll see later that
    a segment with both the SYN and the ACK bits set is exchanged during TCP connection
    establishment.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个段中可以设置多个控制位（或根本没有设置），这使得一个段可以同时用于多个目的。例如，稍后我们将看到，带有SYN和ACK位的段将在TCP连接建立过程中交换。
- en: '*Window size*: This field is used when a receiver sends an ACK to indicate
    the number of bytes of data that the receiver has space to accept. (This relates
    to the sliding window scheme briefly described in [Transmission Control Protocol
    (TCP)](ch58.html#transmission_control_protocol_open_paren "Transmission Control
    Protocol (TCP)").)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*窗口大小*：当接收方发送ACK以指示接收方有足够的空间接受多少字节的数据时，使用此字段。（这与在[传输控制协议（TCP）](ch58.html#transmission_control_protocol_open_paren
    "Transmission Control Protocol (TCP)")中简要描述的滑动窗口方案有关。）'
- en: '*Checksum*: This is a 16-bit checksum covering both the TCP header and the
    TCP data.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*校验和*：这是一个16位的校验和，涵盖TCP头和TCP数据。'
- en: Note
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The TCP checksum covers not just the TCP header and data, but also 12 bytes
    usually referred to as the TCP *pseudoheader*. The pseudoheader consists of the
    following: the source and destination IP address (4 bytes each); 2 bytes specifying
    the size of the TCP segment (this value is computed, but doesn’t form part of
    either the IP or the TCP header); 1 byte containing the value 6, which is TCP’s
    unique protocol number within the TCP/IP suite of protocols; and 1 padding byte
    containing 0 (so that the length of the pseudoheader is a multiple of 16 bits).
    The purpose of including the pseudoheader in the checksum calculation is to allow
    the receiving TCP to double-check that an incoming segment has arrived at the
    correct destination (i.e., that IP has not wrongly accepted a datagram that was
    addressed to another host or passed TCP a packet that should have gone to another
    upper layer). UDP calculates the checksum in its packet headers in a similar manner
    and for similar reasons. See [Stevens, 1994] for further details on the pseudoheader.'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TCP校验和不仅涵盖TCP头和数据，还包括通常称为TCP *伪头部*的12个字节。伪头部包括以下内容：源和目的IP地址（各4个字节）；2个字节指定TCP段的大小（该值是计算得出的，但不构成IP或TCP头的一部分）；1个字节包含值6，这是TCP在TCP/IP协议栈中的唯一协议号；以及1个包含0的填充字节（使伪头部的长度是16位的倍数）。将伪头部包括在校验和计算中是为了允许接收方的TCP再次检查传入的段是否到达正确的目的地（即，确保IP没有错误地接受指向其他主机的数据报，或者没有把应该传递给其他上层的包交给TCP）。UDP也以类似的方式计算其数据包头部的校验和，原因相似。有关伪头部的更多细节，请参见[Stevens,
    1994]。
- en: '*Urgent pointer*: If the URG control bit is set, then this field indicates
    the location of so-called urgent data within the stream of data being transmitted
    from the sender to the receiver. We briefly discuss urgent data in [Out-of-Band
    Data](ch61.html#out-of-band_data "Out-of-Band Data").'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*紧急指针*：如果设置了URG控制位，则该字段指示在从发送方到接收方传输的数据流中所谓的紧急数据的位置。我们将在[带外数据](ch61.html#out-of-band_data
    "Out-of-Band Data")中简要讨论紧急数据。'
- en: '*Options*: This is a variable-length field containing options controlling the
    operation of the TCP connection.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选项*：这是一个可变长度的字段，包含控制TCP连接操作的选项。'
- en: '*Data*: This field contains the user data transmitted in this segment. This
    field may be of length 0 if this segment doesn’t contain any data (e.g., if it
    is simply an ACK segment).'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据*：此字段包含在此段中传输的用户数据。如果此段不包含任何数据（例如，仅为ACK段），则该字段的长度可能为0。'
- en: TCP Sequence Numbers and Acknowledgements
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP序列号和确认
- en: Each byte that is transmitted over a TCP connection is assigned a logical sequence
    number by TCP. (Each of the two streams in a connection has its own sequence numbering.)
    When a segment is transmitted, its *sequence number* field is set to the logical
    offset of the first byte of data in the segment within the stream of data being
    transmitted in this direction over the connection. This allows the receiving TCP
    to assemble the received segments in the correct order, and to indicate which
    data was received when sending an acknowledgement to the sender.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 TCP 连接传输的每个字节都由 TCP 分配一个逻辑序列号。（连接中的每个流都有自己的序列号。）当一个报文段被传输时，它的 *序列号* 字段会设置为报文段中第一个数据字节在该方向数据流中的逻辑偏移量。这样接收方
    TCP 就能按正确的顺序组装接收到的报文段，并在发送确认时指明哪些数据已经被接收。
- en: To implement reliable communication, TCP uses positive acknowledgements; that
    is, when a segment is successfully received, an acknowledgement message (i.e.,
    a segment with the ACK bit set) is sent from the receiving TCP to the sending
    TCP, as shown in [Figure 61-3](ch61.html#acknowledgements_in_tcp "Figure 61-3. Acknowledgements
    in TCP"). The *acknowledgement number* field of this message is set to indicate
    the logical sequence number of the next byte of data that the receiver expects
    to receive. (In other words, the value in the acknowledgement number field is
    the sequence number of the last byte in the segment that it acknowledges, plus
    1.)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现可靠通信，TCP 使用正向确认；也就是说，当一个报文段成功接收时，接收方 TCP 会发送一个确认消息（即设置了 ACK 位的报文段）给发送方 TCP，如
    [图 61-3](ch61.html#acknowledgements_in_tcp "图 61-3. TCP 中的确认")所示。此消息的 *确认号* 字段被设置为指示接收方预期接收的下一个字节的数据的逻辑序列号。（换句话说，确认号字段中的值是它确认的报文段中最后一个字节的序列号加
    1。）
- en: '![Acknowledgements in TCP](figs/web/61-3_SOCKADV-TCP-ACK.png.jpg)Figure 61-3. Acknowledgements
    in TCP'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![TCP 中的确认](figs/web/61-3_SOCKADV-TCP-ACK.png.jpg)图 61-3. TCP 中的确认'
- en: When the sending TCP transmits a segment, it sets a timer. If an acknowledgement
    is not received before the timer expires, the segment is retransmitted.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送方 TCP 发送一个报文段时，它会设置一个定时器。如果在定时器到期之前没有收到确认，报文段将被重新发送。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[Figure 61-3](ch61.html#acknowledgements_in_tcp "Figure 61-3. Acknowledgements
    in TCP") and later similar diagrams are intended to illustrate the exchange of
    TCP segments between two endpoints. An implicit time dimension is assumed when
    reading these diagrams from top to bottom.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 61-3](ch61.html#acknowledgements_in_tcp "图 61-3. TCP 中的确认")以及后续类似的图示旨在说明两个端点之间
    TCP 报文段的交换。在阅读这些图示时，假设有一个隐式的时间维度，从上到下阅读时表示时间的流逝。'
- en: TCP State Machine and State Transition Diagram
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP 状态机与状态转换图
- en: 'Maintaining a TCP connection requires the coordination of the TCPs at both
    ends of the connection. To reduce the complexity of this task, a TCP endpoint
    is modeled as a *state machine*. This means that the TCP can be in one of a fixed
    set of *states*, and it moves from one state to another in response to *events*,
    such as system calls by the application above the TCP or the arrival of TCP segments
    from the peer TCP. The TCP states are the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 维持一个 TCP 连接需要协调连接两端的 TCP。为了简化这项任务，TCP 端点被建模为一个 *状态机*。这意味着 TCP 可以处于一组固定的 *状态*
    中，并且根据 *事件*（例如来自应用程序的系统调用或来自对端 TCP 的报文段到达）在状态之间转换。TCP 状态包括以下几种：
- en: 'LISTEN: The TCP is waiting for a connection request from a peer TCP.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LISTEN：TCP 正在等待来自对端 TCP 的连接请求。
- en: 'SYN_SENT: The TCP has sent a SYN on behalf of an application performing an
    active open and is waiting for a reply from the peer in order to complete the
    connection.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYN_SENT：TCP 已代表应用程序发送了一个 SYN 请求，正在等待对端的回复，以完成连接。
- en: 'SYN_RECV: The TCP, formerly in the LISTEN state, has received a SYN and has
    responded with a SYN/ACK (i.e., a TCP segment with both the SYN and ACK bits set),
    and is now waiting for an ACK from the peer TCP in order to complete the connection.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYN_RECV：TCP 在 LISTEN 状态下收到一个 SYN，并以 SYN/ACK 响应（即同时设置了 SYN 和 ACK 位的 TCP 报文段），现在等待接收方
    TCP 的 ACK 来完成连接。
- en: 'ESTABLISHED: Establishment of the connection to the peer TCP has been completed.
    Data segments can now be exchanged in either direction between the two TCPs.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ESTABLISHED：与对端 TCP 的连接已建立完成。现在两个 TCP 之间可以在任意方向交换数据报文段。
- en: 'FIN_WAIT1: The application has closed the connection. The TCP has sent a FIN
    to the peer TCP in order to terminate its side of the connection and is waiting
    for an ACK from the peer. This and the next three states are associated with an
    application performing an active close—that is, the first application to close
    its side of the connection.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'FIN_WAIT1: 应用程序已关闭连接。TCP向对端TCP发送了FIN，以终止自己一方的连接，并在等待对方的ACK。此状态及接下来的三个状态与执行主动关闭的应用程序相关，即第一个关闭连接一方的应用程序。'
- en: 'FIN_WAIT2: The TCP, formerly in the FIN_WAIT1 state, has now received an ACK
    from the peer TCP.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'FIN_WAIT2: TCP原本处于FIN_WAIT1状态，现在已收到来自对端TCP的ACK。'
- en: 'CLOSING: The TCP, formerly awaiting an ACK in the FIN_WAIT1 state, instead
    received a FIN from its peer indicating that the peer simultaneously tried to
    perform an active close. (In other words, the two TCPs sent FIN segments at almost
    the same time. This is a rare scenario.)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CLOSING: TCP原本在FIN_WAIT1状态下等待ACK，但却收到了来自对端的FIN，这表明对端同时试图执行主动关闭。（换句话说，两个TCP几乎在同一时间发送了FIN段。这是一个罕见的情况。）'
- en: 'TIME_WAIT: Having done an active close, the TCP has received a FIN, indicating
    that the peer TCP has performed a passive close. This TCP now spends a fixed period
    of time in the TIME_WAIT state, in order to ensure reliable termination of the
    TCP connection and to ensure that any old duplicate segments expire in the network
    before a new incarnation of the same connection is created. (We explain the TIME_WAIT
    state in more detail in [The TIME_WAIT State](ch61.html#the_time_underscore_wait_state
    "The TIME_WAIT State").) When this fixed time period expires, the connection is
    closed, and the associated kernel resources are freed.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'TIME_WAIT: 在执行主动关闭后，TCP已收到FIN，表明对端TCP执行了被动关闭。此时，TCP会在TIME_WAIT状态下等待一段固定时间，以确保TCP连接可靠终止，并确保任何过期的重复段在创建相同连接的新实例之前从网络中消失。（我们将在[TIME_WAIT状态](ch61.html#the_time_underscore_wait_state
    "TIME_WAIT状态")一节中详细解释TIME_WAIT状态。）当这段固定时间过后，连接关闭，相关的内核资源被释放。'
- en: 'CLOSE_WAIT: The TCP has received a FIN from the peer TCP. This and the following
    state are associated with an application performing a passive close—that is, the
    second application to close the connection.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CLOSE_WAIT: TCP已收到来自对端TCP的FIN。此状态及后续状态与执行被动关闭的应用程序相关，即第二个关闭连接的应用程序。'
- en: 'LAST_ACK: The application performed a passive close, and the TCP, formerly
    in the CLOSE_WAIT state, sent a FIN to the peer TCP and is waiting for it to be
    acknowledged. When this ACK is received, the connection is closed, and the associated
    kernel resources are freed.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LAST_ACK: 应用程序执行了被动关闭，原本处于CLOSE_WAIT状态的TCP向对端TCP发送了FIN，并在等待对方的确认。当收到这个ACK时，连接关闭，相关的内核资源被释放。'
- en: To the above states, RFC 793 adds one further, fictional state, CLOSED, representing
    the state when there is no connection (i.e., no kernel resources are allocated
    to describe a TCP connection).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对上述状态，RFC 793添加了一个额外的虚拟状态——CLOSED，表示没有连接的状态（即没有为描述TCP连接分配内核资源）。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the above list we use the spellings for the TCP states as defined in the
    Linux source code. These differ slightly from the spellings in RFC 793.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述列表中，我们使用的是Linux源代码中定义的TCP状态的拼写方式。这些拼写与RFC 793中的拼写略有不同。
- en: '[Figure 61-4](ch61.html#tcp_state_transition_diagram "Figure 61-4. TCP state
    transition diagram") shows the *state transition diagram* for TCP. (This figure
    is based on diagrams in RFC 793 and [Stevens et al., 2004].) This diagram shows
    how a TCP endpoint moves from one state to another in response to various events.
    Each arrow indicates a possible transition and is labeled with the event that
    triggers the transition. This label is either an action by the application (in
    boldface) or the string *recv*, indicating the receipt of a segment from the peer
    TCP. As a TCP moves from one state to another, it may transmit a segment to the
    peer, and this is indicated by the *send* label on the transition. For example,
    the arrow for the transition from the ESTABLISHED to the FIN_WAIT1 state shows
    that the triggering event is a *close()* by the local application, and that, during
    the transition, the TCP sends a FIN segment to its peer.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 61-4](ch61.html#tcp_state_transition_diagram "图 61-4. TCP 状态转换图")显示了 TCP
    的*状态转换图*。（该图基于 RFC 793 中的图示以及[Stevens 等，2004]的图示。）此图展示了 TCP 端点如何响应各种事件从一个状态转移到另一个状态。每个箭头表示一种可能的转换，并标注了触发该转换的事件。该标签可以是应用程序的动作（以粗体显示），也可以是*recv*字符串，表示接收到来自对端
    TCP 的数据段。当 TCP 从一个状态转移到另一个状态时，它可能会向对端发送数据段，这一点通过转换上的*send*标签来表示。例如，从 ESTABLISHED
    状态到 FIN_WAIT1 状态的转换箭头显示，触发事件是本地应用程序的*close()*，并且在转换过程中，TCP 向对端发送一个 FIN 数据段。'
- en: In [Figure 61-4](ch61.html#tcp_state_transition_diagram "Figure 61-4. TCP state
    transition diagram"), the usual transition path for a client TCP is shown with
    heavy solid arrows, and the usual transition path for a server TCP is shown with
    heavy dashed arrows. (Other arrows indicate paths less traveled.) Looking at the
    parenthetical numbering on the arrows in these paths, we can see that the segments
    sent and received by the two TCPs are mirror images of one another. (After the
    ESTABLISHED state, the paths traveled by the server TCP and the client TCP may
    be the opposite of those indicated, if it is the server that performs the active
    close.)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 61-4](ch61.html#tcp_state_transition_diagram "图 61-4. TCP 状态转换图")中，客户端 TCP
    的常见转换路径通过粗实线箭头表示，服务器 TCP 的常见转换路径通过粗虚线箭头表示。（其他箭头表示较少使用的路径。）通过查看这些路径上箭头的括号编号，我们可以看到两个
    TCP 发送和接收的段是彼此的镜像。（在 ESTABLISHED 状态之后，如果是服务器执行主动关闭，则服务器 TCP 和客户端 TCP 的路径可能与所示路径相反。）
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[Figure 61-4](ch61.html#tcp_state_transition_diagram "Figure 61-4. TCP state
    transition diagram") doesn’t show all possible transitions for the TCP state machine;
    it illustrates just those of principal interest. A more detailed TCP state transition
    diagram can be found at [http://www.cl.cam.ac.uk/~pes20/Netsem/poster.pdf](http://www.cl.cam.ac.uk/~pes20/Netsem/poster.pdf).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 61-4](ch61.html#tcp_state_transition_diagram "图 61-4. TCP 状态转换图")并未显示 TCP
    状态机的所有可能转换；它仅展示了主要感兴趣的那些。更详细的 TCP 状态转换图可以在[http://www.cl.cam.ac.uk/~pes20/Netsem/poster.pdf](http://www.cl.cam.ac.uk/~pes20/Netsem/poster.pdf)找到。'
- en: TCP Connection Establishment
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP 连接建立
- en: 'At the sockets API level, two stream sockets are connected via the following
    steps (see [Figure 56-1](ch56.html#overview_of_system_calls_used_with_strea "Figure 56-1. Overview
    of system calls used with stream sockets"), in [Listening for Incoming Connections:
    *listen()*](ch56.html#listening_for_incoming_connections_colon "Listening for
    Incoming Connections: listen()")):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在套接字 API 层，通过以下步骤连接两个流套接字（参见[图 56-1](ch56.html#overview_of_system_calls_used_with_strea
    "图 56-1. 用于流套接字的系统调用概述")，在[监听传入连接：*listen()*](ch56.html#listening_for_incoming_connections_colon
    "监听传入连接：listen()")）：
- en: The server calls *listen()* to perform a passive open of a socket, and then
    calls *accept()*, which blocks until a connection is established.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器调用*listen()*执行套接字的被动打开，然后调用*accept()*，该调用会阻塞，直到建立连接。
- en: The client calls *connect()* to perform an active open of a socket in order
    to establish a connection to the server’s passive socket.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端调用*connect()*来执行套接字的主动打开，以便建立与服务器的被动套接字的连接。
- en: 'The steps performed by TCP to establish a connection are shown in [Figure 61-5](ch61.html#three-way_handshake_for_tcp_connection_e
    "Figure 61-5. Three-way handshake for TCP connection establishment"). These steps
    are often referred to as the *three-way handshake*, since three segments pass
    between the two TCPs. The steps are as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 执行建立连接的步骤如[图 61-5](ch61.html#three-way_handshake_for_tcp_connection_e "图 61-5.
    TCP 连接建立的三次握手")所示。这些步骤通常被称为*三次握手*，因为在两个 TCP 之间会传递三个数据段。步骤如下：
- en: The *connect()* causes the client TCP to send a SYN segment to the server TCP.
    This segment informs the server TCP of the client TCP’s initial sequence number
    (labeled *M* in the diagram). This information is necessary because sequence numbers
    don’t begin at 0, as noted in [Transmission Control Protocol (TCP)](ch58.html#transmission_control_protocol_open_paren
    "Transmission Control Protocol (TCP)").
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*connect()* 函数使客户端 TCP 向服务器 TCP 发送一个 SYN 数据段。这个数据段通知服务器 TCP 客户端 TCP 的初始序列号（图中标记为
    *M*）。这一信息是必要的，因为序列号并不是从 0 开始的，正如在 [传输控制协议 (TCP)](ch58.html#transmission_control_protocol_open_paren
    "传输控制协议 (TCP)") 中所提到的那样。'
- en: The server TCP must both acknowledge the client TCP’s SYN segment and inform
    the client TCP of its own initial sequence number (labeled *N* in the diagram).
    (Two sequence numbers are required because a stream socket is bidirectional.)
    The server TCP can perform both operations by returning a single segment with
    both the SYN and the ACK control bits set. (We say that the ACK is *piggybacked*
    on the SYN.)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器 TCP 必须同时确认客户端 TCP 的 SYN 数据段，并通知客户端 TCP 其自己的初始序列号（图中标记为 *N*）。(需要两个序列号，因为流套接字是双向的。)
    服务器 TCP 可以通过返回一个包含 SYN 和 ACK 控制位的单个数据段来完成这两个操作。（我们说 ACK 是 *附加* 在 SYN 上的。）
- en: The client TCP sends an ACK segment to acknowledge the server TCP’s SYN segment.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端 TCP 向服务器 TCP 发送 ACK 数据段以确认服务器 TCP 的 SYN 数据段。
- en: '![TCP state transition diagram](figs/web/61-4_SOCKADV-TCP-STD.png.jpg)Figure 61-4. TCP
    state transition diagram'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![TCP 状态转换图](figs/web/61-4_SOCKADV-TCP-STD.png.jpg)图 61-4. TCP 状态转换图'
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The SYN segments exchanged in the first two steps of the three-way handshake
    may contain information in the *options* field of the TCP header that is used
    to determine various parameters for the connection. See [Stevens et al., 2004],
    [Stevens, 1994], and [Wright & Stevens, 1995] for details.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在三次握手的前两步中交换的 SYN 数据段，可能包含 TCP 头部的 *options* 字段中的信息，这些信息用于确定连接的各种参数。有关详细信息，请参见
    [Stevens 等，2004]、[Stevens，1994] 和 [Wright & Stevens，1995]。
- en: The labels inside angle brackets (e.g., <LISTEN>) in [Figure 61-5](ch61.html#three-way_handshake_for_tcp_connection_e
    "Figure 61-5. Three-way handshake for TCP connection establishment") indicate
    the states of the TCPs on either side of the connection.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 61-5](ch61.html#three-way_handshake_for_tcp_connection_e "图 61-5. TCP 连接建立的三次握手")
    中尖括号内的标签（例如，<LISTEN>）表示连接两端 TCP 的状态。'
- en: The SYN flag consumes a byte of the sequence-number space for the connection.
    This is necessary so that this flag can be acknowledged unambiguously, since segments
    with this flag set may also contain data bytes. This is why we show the acknowledgement
    of the *SYN M* segment as *ACK M+1* in [Figure 61-5](ch61.html#three-way_handshake_for_tcp_connection_e
    "Figure 61-5. Three-way handshake for TCP connection establishment").
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: SYN 标志占用了连接的序列号空间中的一个字节。这样做是必要的，因为该标志必须能够明确地被确认，因为带有此标志的数据段可能还包含数据字节。这就是为什么我们在
    [图 61-5](ch61.html#three-way_handshake_for_tcp_connection_e "图 61-5. TCP 连接建立的三次握手")
    中显示对 *SYN M* 数据段的确认为 *ACK M+1* 的原因。
- en: '![Three-way handshake for TCP connection establishment](figs/web/61-5_SOCKADV-TCP-connection-establishment.png.jpg)Figure 61-5. Three-way
    handshake for TCP connection establishment'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![TCP 连接建立的三次握手](figs/web/61-5_SOCKADV-TCP-connection-establishment.png.jpg)图
    61-5. TCP 连接建立的三次握手'
- en: TCP Connection Termination
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP 连接终止
- en: 'Closing a TCP connection normally occurs in the following manner:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭 TCP 连接通常按以下方式进行：
- en: An application on one end of the connection performs a *close()*. (This is often,
    but not necessarily, the client.) We say that this application is performing an
    *active close*.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接一端的应用程序执行 *close()*。通常情况下，但不一定是客户端，会执行此操作。我们称这个应用程序执行了 *主动关闭*。
- en: Later, the application on the other end of the connection (the server) also
    performs a *close()*. This is termed a *passive close*.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，连接另一端的应用程序（服务器）也执行 *close()* 操作。这被称为 *被动关闭*。
- en: '[Figure 61-6](ch61.html#tcp_connection_termination-id1 "Figure 61-6. TCP connection
    termination") shows the corresponding steps performed by the underlying TCPs (here,
    we assume that it is the client that does the active close). These steps are as
    follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 61-6](ch61.html#tcp_connection_termination-id1 "图 61-6. TCP 连接终止") 显示了底层
    TCP 执行的相应步骤（在此假设是客户端执行主动关闭）。这些步骤如下：'
- en: The client performs an active close, which causes the client TCP to send a FIN
    to the server TCP.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端执行主动关闭，导致客户端 TCP 向服务器 TCP 发送 FIN。
- en: After receipt of the FIN, the server TCP responds with an ACK. Any subsequent
    attempt by the server to *read()* from the socket yields end-of-file (i.e., a
    0 return).
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在收到FIN后，服务器TCP会响应一个ACK。之后，服务器若尝试从套接字上*read()*，则会返回文件结束符（即0）。
- en: When the server later closes its end of the connection, the server TCP sends
    a FIN to the client TCP.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当服务器稍后关闭连接的一端时，服务器TCP会向客户端TCP发送一个FIN。
- en: The client TCP responds with an ACK to acknowledge the server’s FIN.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端TCP用ACK回应，以确认服务器的FIN。
- en: As with the SYN flag, and for the same reasons, the FIN flag consumes a byte
    of the sequence-number space for the connection. This is why we show the acknowledgement
    of the *FIN M* segment as *ACK M+1* in [Figure 61-6](ch61.html#tcp_connection_termination-id1
    "Figure 61-6. TCP connection termination").
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与SYN标志类似，出于相同的原因，FIN标志会占用连接序列号空间中的一个字节。这就是为什么我们在[图61-6](ch61.html#tcp_connection_termination-id1
    "图61-6. TCP连接终止")中将*FIN M*段的确认表示为*ACK M+1*。
- en: '![TCP connection termination](figs/web/61-6_SOCKADV-TCP-disconnect.png.jpg)Figure 61-6. TCP
    connection termination'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![TCP连接终止](figs/web/61-6_SOCKADV-TCP-disconnect.png.jpg)图61-6. TCP连接终止'
- en: Calling *shutdown()* on a TCP Socket
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在TCP套接字上调用*shutdown()*
- en: The discussion in the preceding section assumed a full-duplex close; that is,
    an application closes both the sending and receiving channels of the TCP socket
    using *close()*. As noted in [The *shutdown()* System Call](ch61.html#the_shutdown_open_parenthesis_close_pare
    "The shutdown() System Call"), we can use *shutdown()* to close just one channel
    of the connection (a half-duplex close). This section notes some specific details
    for *shutdown()* on a TCP socket.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节讨论假设了全双工关闭；即，应用程序使用*close()*关闭TCP套接字的发送和接收通道。正如在[系统调用*shutdown()*](ch61.html#the_shutdown_open_parenthesis_close_pare
    "系统调用shutdown()")中所指出的，我们可以使用*shutdown()*仅关闭连接的一个通道（半双工关闭）。本节指出了在TCP套接字上使用*shutdown()*的一些具体细节。
- en: Specifying *how* as `SHUT_WR` or `SHUT_RDWR` initiates the TCP connection termination
    sequence (i.e., the active close) described in [TCP Connection Termination](ch61.html#tcp_connection_termination
    "TCP Connection Termination"), regardless of whether there are other file descriptors
    referring to the socket. Once this sequence has been initiated, the local TCP
    moves into the FIN_WAIT1 state, and then into the FIN_WAIT2 state, while the peer
    TCP moves into the CLOSE_WAIT state ([Figure 61-6](ch61.html#tcp_connection_termination-id1
    "Figure 61-6. TCP connection termination")). If *how* is specified as `SHUT_WR`,
    then, since the socket file descriptor remains valid and the reading half of the
    connection remains open, the peer can continue to send data back to us.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将*how*指定为`SHUT_WR`或`SHUT_RDWR`会启动TCP连接终止序列（即主动关闭），该过程在[TCP连接终止](ch61.html#tcp_connection_termination
    "TCP连接终止")中进行了描述，无论是否有其他文件描述符引用该套接字。一旦该序列被启动，本地TCP进入FIN_WAIT1状态，然后进入FIN_WAIT2状态，而对端TCP进入CLOSE_WAIT状态（[图61-6](ch61.html#tcp_connection_termination-id1
    "图61-6. TCP连接终止")）。如果*how*指定为`SHUT_WR`，由于套接字文件描述符保持有效且连接的读取半部分仍然开放，因此对端可以继续向我们发送数据。
- en: The `SHUT_RD` operation can’t be meaningfully used with TCP sockets. This is
    because most TCP implementations don’t provide the expected behavior for `SHUT_RD`,
    and the effect of `SHUT_RD` varies across implementations. On Linux and a few
    other implementations, following a `SHUT_RD` (and after any outstanding data has
    been read), a *read()* returns end-of-file, as we expect from the description
    of `SHUT_RD` in Section 61.2. However, if the peer application subsequently writes
    data on its socket, then it is still possible to read that data on the local socket.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHUT_RD`操作在TCP套接字上无法有效使用。这是因为大多数TCP实现并未提供`SHUT_RD`预期的行为，且`SHUT_RD`的效果在不同的实现中有所不同。在Linux及其他一些实现中，在执行`SHUT_RD`（并且读取完所有待处理数据）之后，*read()*会返回文件结束符，这与第61.2节中对`SHUT_RD`的描述一致。然而，如果对端应用随后在其套接字上写入数据，则仍然可以在本地套接字上读取该数据。'
- en: On some other implementations (e.g., the BSDs), `SHUT_RD` does indeed cause
    subsequent calls to *read()* to always return 0\. However, on those implementations,
    if the peer continues to *write()* to the socket, then the data channel will eventually
    fill until the point where a further (blocking) call to *write()* by the peer
    will block. (With UNIX domain stream sockets, a peer would receive a `SIGPIPE`
    signal and the `EPIPE` error if it continued writing to its socket after a `SHUT_RD`
    had been performed on the local socket.)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些其他实现中（例如 BSD 系统），`SHUT_RD` 确实会导致后续对 *read()* 的调用始终返回 0。然而，在这些实现中，如果对端继续对套接字执行
    *write()* 操作，则数据通道最终会填满，直到对端的进一步（阻塞） *write()* 调用被阻塞。（对于 UNIX 域流套接字，如果对端在本地套接字执行了
    `SHUT_RD` 后继续向其套接字写入数据，它将收到 `SIGPIPE` 信号，并且出现 `EPIPE` 错误。）
- en: In summary, the use of `SHUT_RD` should be avoided for portable TCP applications.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，应避免在可移植的 TCP 应用程序中使用 `SHUT_RD`。
- en: The TIME_WAIT State
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TIME_WAIT 状态
- en: 'The TCP TIME_WAIT state is a frequent source of confusion in network programming.
    Looking at [Figure 61-4](ch61.html#tcp_state_transition_diagram "Figure 61-4. TCP
    state transition diagram"), we can see that a TCP performing an active close goes
    through this state. The TIME_WAIT state exists to serve two purposes:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 的 TIME_WAIT 状态是网络编程中常见的一个困惑来源。通过查看 [图 61-4](ch61.html#tcp_state_transition_diagram
    "图 61-4. TCP 状态转换图")，我们可以看到执行主动关闭的 TCP 会经历该状态。TIME_WAIT 状态存在有两个目的：
- en: to implement reliable connection termination; and
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现可靠的连接终止；并且
- en: to allow expiration of old duplicate segments in the network so that they are
    not accepted by a new incarnation of the connection.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许旧的重复段在网络中过期，以便它们不会被新连接的实例接受。
- en: The TIME_WAIT state differs from the other states in that the event that causes
    a transition out of this state (to CLOSED) is a timeout. This timeout has a duration
    of twice the MSL (2MSL), where MSL (*maximum segment lifetime*) is the assumed
    maximum lifetime of a TCP segment in the network.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: TIME_WAIT 状态与其他状态不同，因为导致从该状态（转至 CLOSED）过渡的事件是超时。该超时的持续时间为两倍的 MSL（2MSL），其中 MSL（*最大段生命周期*）是指
    TCP 段在网络中假定的最大生命周期。
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An 8-bit time-to-live (TTL) field in the IP header ensures that all IP packets
    are eventually discarded if they don’t reach their destination within a fixed
    number of hops (routers traversed) while traveling from the source to the destination
    host. The MSL is an estimate of the maximum time that an IP packet could take
    to exceed the TTL limit. Since it is represented using 8 bits, the TTL permits
    a maximum of 255 hops. Normally, an IP packet requires considerably fewer hops
    than this to complete its journey. A packet could encounter this limit because
    of certain types of router anomalies (e.g., a router configuration problem) that
    cause the packet to get caught in a network loop until it exceeds the TTL limit.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: IP 头部中的 8 位生存时间（TTL）字段确保所有 IP 数据包在经过固定数量的跃点（路由器跳数）并且没有到达目的地时，最终会被丢弃。MSL 是一个估计值，表示一个
    IP 数据包超出 TTL 限制所需的最大时间。由于 TTL 使用 8 位表示，最大允许的跃点数为 255。通常，IP 数据包所需的跃点数远低于此值。数据包可能会遇到此限制，原因是某些类型的路由器异常（例如路由器配置问题）导致数据包在网络中形成环路，直到超过
    TTL 限制。
- en: The BSD sockets implementation assumes a value of 30 seconds for the MSL, and
    Linux follows the BSD norm. Thus, the TIME_WAIT state has a lifetime of 60 seconds
    on Linux. However, RFC 1122 recommends a value of 2 minutes for the MSL, and,
    on implementations following this recommendation, the TIME_WAIT state can thus
    last 4 minutes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: BSD 套接字实现假定 MSL 的值为 30 秒，而 Linux 遵循 BSD 标准。因此，在 Linux 上，TIME_WAIT 状态的生命周期为 60
    秒。然而，RFC 1122 推荐将 MSL 的值设为 2 分钟，遵循此推荐的实现中，TIME_WAIT 状态的持续时间可以达到 4 分钟。
- en: 'We can understand the first purpose of the TIME_WAIT state--ensuring reliable
    connection termination--by looking at [Figure 61-6](ch61.html#tcp_connection_termination-id1
    "Figure 61-6. TCP connection termination"). In this diagram, we can see that four
    segments are usually exchanged during the termination of a TCP connection. The
    last of these is an ACK sent from the TCP performing the active close to the TCP
    performing the passive close. Suppose that this ACK gets lost in the network.
    If this occurs, then the TCP performing the passive close will eventually retransmit
    its FIN. Having the TCP that performs the active close remain in the TIME_WAIT
    state for a fixed period ensures that it is available to resend the final ACK
    in this case. If the TCP that performs the active close did not still exist, then—since
    it wouldn’t have any state information for the connection—the TCP protocol would
    respond to the resent FIN by sending an RST (reset) segment to the TCP performing
    the passive close, and this RST would be interpreted as an error. (This explains
    why the duration of the TIME_WAIT state is *twice* the MSL: one MSL for the final
    ACK to reach the peer TCP, plus a further MSL in case a further FIN must be sent.)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看[图 61-6](ch61.html#tcp_connection_termination-id1 "图 61-6. TCP 连接终止")来理解
    TIME_WAIT 状态的第一个目的——确保可靠的连接终止。在该图中，我们可以看到，TCP 连接的终止通常会交换四个段。这些段中最后一个是从执行主动关闭的
    TCP 发送给执行被动关闭的 TCP 的 ACK。假设这个 ACK 在网络中丢失。如果发生这种情况，执行被动关闭的 TCP 最终会重新传输其 FIN。让执行主动关闭的
    TCP 保持在 TIME_WAIT 状态一段固定时间，可以确保它能够在这种情况下重新发送最终的 ACK。如果执行主动关闭的 TCP 不再存在，那么——因为它没有连接的状态信息——TCP
    协议会对重新传输的 FIN 发送一个 RST（复位）段给执行被动关闭的 TCP，而这个 RST 会被解释为一个错误。（这也解释了为什么 TIME_WAIT
    状态的持续时间是*两倍*的 MSL：一个 MSL 用于最终的 ACK 到达对端 TCP，再加一个 MSL，以防必须发送进一步的 FIN。）
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An equivalent of the TIME_WAIT state is not required for the TCP performing
    the passive close, because it is the initiator of the final exchange in the connection
    termination. After sending the FIN, this TCP will wait for the ACK from its peer,
    and retransmit the FIN if its timer expires before the ACK is received.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于执行被动关闭的 TCP 来说，不需要 TIME_WAIT 状态的等效机制，因为它是连接终止中最后交换的发起者。在发送完 FIN 后，该 TCP 会等待来自对端的
    ACK，并在定时器在收到 ACK 之前过期时重新传输 FIN。
- en: To understand the second purpose of the TIME_WAIT state—ensuring the expiration
    of old duplicate segments in the network—we must remember that the retransmission
    algorithm used by TCP means that duplicate segments may be generated, and that,
    depending on routing decisions, these duplicates could arrive after the connection
    has been closed. For example, suppose that we have a TCP connection between two
    socket addresses, say, `204.152.189.116` port 21 (the FTP port) and `200.0.0.1`
    port 50,000\. Suppose also that this connection is closed, and that later a new
    connection is established using exactly the same IP addresses and ports. This
    is referred to as a new incarnation of the connection. In this case, TCP must
    ensure that no old duplicate segments from the previous incarnation are accepted
    as valid data in the new incarnation. This is done by preventing a new incarnation
    from being established while there is an existing TCP in the TIME_WAIT state on
    one of the endpoints.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 TIME_WAIT 状态的第二个目的——确保网络中旧的重复段过期——我们必须记住，TCP 使用的重传算法可能会生成重复的段，并且根据路由决策，这些重复的段可能在连接关闭后到达。例如，假设我们有一个
    TCP 连接，连接的两个套接字地址分别是 `204.152.189.116` 端口 21（FTP 端口）和 `200.0.0.1` 端口 50,000。假设这个连接已经关闭，随后建立了一个新连接，使用完全相同的
    IP 地址和端口。这被称为连接的新实例。在这种情况下，TCP 必须确保旧的重复段不会在新实例中被当作有效数据接受。为此，TCP 会通过防止在 TIME_WAIT
    状态的端点存在时建立新的连接实例来实现这一点。
- en: A frequent question posted to online forums is how to disable the TIME_WAIT
    state, since it can lead to the error `EADDRINUSE` (“Address already in use”)
    when a restarted server tries to bind a socket to an address that has a TCP in
    the TIME_WAIT state. Although there are ways of doing this (see [Stevens et al.,
    2004]), and also ways of assassinating a TCP in this state (i.e., causing the
    TIME_WAIT state to terminate prematurely, see [Snader, 2000]), this should be
    avoided, since it would thwart the reliability guarantees that the TIME_WAIT state
    provides. In [The *SO_REUSEADDR* Socket Option](ch61.html#the_so_underscore_reuseaddr_socket_optio
    "The SO_REUSEADDR Socket Option"), we look at the use of the `SO_REUSEADDR` socket
    option, which can be used to avoid the usual causes of the `EADDRINUSE` error,
    while still allowing the TIME_WAIT to provide its reliability guarantees.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在线论坛上一个常见的问题是如何禁用 TIME_WAIT 状态，因为当重新启动的服务器尝试将套接字绑定到处于 TIME_WAIT 状态的地址时，可能会导致
    `EADDRINUSE` 错误（“地址已在使用”）。虽然有方法可以做到这一点（参见 [Stevens 等，2004]），也有方法可以终结处于此状态的 TCP（即使
    TIME_WAIT 状态提前终止，参见 [Snader，2000]），但应该避免这样做，因为它会破坏 TIME_WAIT 状态所提供的可靠性保证。在 [The
    *SO_REUSEADDR* Socket Option](ch61.html#the_so_underscore_reuseaddr_socket_optio
    "SO_REUSEADDR 套接字选项") 中，我们将探讨如何使用 `SO_REUSEADDR` 套接字选项，它可以避免 `EADDRINUSE` 错误的常见原因，同时仍然允许
    TIME_WAIT 提供其可靠性保证。
- en: 'Monitoring Sockets: *netstat*'
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控套接字：*netstat*
- en: The *netstat* program displays the state of Internet and UNIX domain sockets
    on a system. It is a useful debugging tool when writing socket applications. Most
    UNIX implementations provide a version of *netstat*, although there is some variation
    in the syntax of its command-line arguments across implementations.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*netstat* 程序显示系统上互联网和 UNIX 域套接字的状态。它是编写套接字应用程序时的一个有用的调试工具。大多数 UNIX 实现都提供了 *netstat*
    的版本，尽管在命令行参数的语法上不同的实现存在一些差异。'
- en: By default, when executed with no command-line options, *netstat* displays information
    for connected sockets in both the UNIX and Internet domains. We can use a number
    of command-line options to change the information displayed. Some of these options
    are listed in [Table 61-1](ch61.html#options_for_the_netstat_command "Table 61-1. Options
    for the netstat command").
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在没有命令行选项的情况下执行 *netstat* 时，会显示 UNIX 和互联网域中已连接的套接字的信息。我们可以使用多个命令行选项来更改显示的信息。部分选项列在
    [表格 61-1](ch61.html#options_for_the_netstat_command "Table 61-1. netstat 命令的选项")
    中。
- en: Table 61-1. Options for the *netstat* command
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 61-1. *netstat* 命令的选项
- en: '| Option | Description |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-a` | Display information about all sockets, including listening sockets
    |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `-a` | 显示所有套接字的信息，包括监听套接字 |'
- en: '| `-e` | Display extended information (includes user ID of socket owner) |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `-e` | 显示扩展信息（包括套接字所有者的用户 ID） |'
- en: '| `-c` | Redisplay socket information continuously (each second) |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `-c` | 持续重新显示套接字信息（每秒更新一次） |'
- en: '| `-l` | Display information only about listening sockets |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `-l` | 仅显示监听套接字的信息 |'
- en: '| `-n` | Display IP addresses, port numbers, and usernames in numerical form
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `-n` | 以数字形式显示 IP 地址、端口号和用户名 |'
- en: '| `-p` | Show the process ID and name of program to which socket belongs |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `-p` | 显示套接字所属程序的进程 ID 和名称 |'
- en: '| `--inet` | Display information for Internet domain sockets |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `--inet` | 显示互联网域套接字的信息 |'
- en: '| `--tcp` | Display information for Internet domain TCP (stream) sockets |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `--tcp` | 显示互联网域 TCP（流式）套接字的信息 |'
- en: '| `--udp` | Display information for Internet domain UDP (datagram) sockets
    |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `--udp` | 显示互联网域 UDP（数据报）套接字的信息 |'
- en: '| `--unix` | Display information for UNIX domain sockets |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `--unix` | 显示 UNIX 域套接字的信息 |'
- en: 'Here is an abridged example of the output that we see when using *netstat*
    to list all Internet domain sockets on the system:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 *netstat* 列出系统上所有互联网域套接字时的简化输出示例：
- en: '[PRE16]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For each Internet domain socket, we see the following information:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个互联网域套接字，我们会看到以下信息：
- en: '`Proto`: This is the socket protocol—for example, `tcp` or `udp`.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Proto`：这是套接字协议—例如，`tcp` 或 `udp`。'
- en: '`Recv-Q`: This is the number of bytes in the socket receive buffer that are
    as yet unread by the local application. For UDP sockets, this field counts not
    just data, but also bytes in UDP headers and other metadata.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Recv-Q`：这是本地应用程序尚未读取的套接字接收缓冲区中的字节数。对于 UDP 套接字，此字段不仅计算数据，还包括 UDP 头部和其他元数据中的字节。'
- en: '`Send-Q`: This is the number of bytes queued for transmission in the socket
    send buffer. As with the `Recv-Q` field, for UDP sockets, this field includes
    bytes in UDP headers and other metadata.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`发送队列`：这是套接字发送缓冲区中排队等待传输的字节数。与 `接收队列` 字段一样，对于 UDP 套接字，这个字段包括 UDP 头和其他元数据中的字节数。'
- en: '`Local Address`: This is the address to which the socket is bound, expressed
    in the form *host-IP-address:port*. By default, both components of the address
    are displayed as names, unless the numeric values can’t be resolved to corresponding
    host and service names. An asterisk (`*`) in the host part of the address means
    the wildcard IP address.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`本地地址`：这是套接字绑定的地址，格式为 *主机-IP地址:端口*。默认情况下，地址的两个部分都会显示为名称，除非数字值无法解析为相应的主机和服务名称。如果地址的主机部分为星号（`*`），则表示通配符IP地址。'
- en: '`Foreign Address`: This is the address of the peer socket to which this socket
    is bound. The string `*:*` indicates no peer address.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`外部地址`：这是与此套接字绑定的对等套接字的地址。字符串 `*:*` 表示没有对等地址。'
- en: '`State`: This is the current state of the socket. For a TCP socket, this state
    is one of those described in [TCP State Machine and State Transition Diagram](ch61.html#tcp_state_machine_and_state_transition_d
    "TCP State Machine and State Transition Diagram").'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`状态`：这是套接字的当前状态。对于TCP套接字，此状态是 [TCP 状态机与状态转换图](ch61.html#tcp_state_machine_and_state_transition_d
    "TCP 状态机与状态转换图") 中描述的状态之一。'
- en: For further details, see the *netstat(8)* manual page.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多详细信息，请参阅 *netstat(8)* 手册页面。
- en: Various Linux-specific files in the directory `/proc/net` allow a program to
    read much of the same information that is displayed by *netstat*. These files
    are named `tcp`, `udp`, `tcp6`, `udp6`, and `unix`, with the obvious purposes.
    For further details, see the *proc(5)* manual page.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/net` 目录下的各种 Linux 特定文件允许程序读取与 *netstat* 显示的相同信息。这些文件分别命名为 `tcp`、`udp`、`tcp6`、`udp6`
    和 `unix`，用途显而易见。欲了解更多详细信息，请参阅 *proc(5)* 手册页面。'
- en: Using *tcpdump* to Monitor TCP Traffic
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 *tcpdump* 监控 TCP 流量
- en: The *tcpdump* program is a useful debugging tool that allows the superuser to
    monitor the Internet traffic on a live network, generating a real-time textual
    equivalent of diagrams such as [Figure 61-3](ch61.html#acknowledgements_in_tcp
    "Figure 61-3. Acknowledgements in TCP"). Despite its name, *tcpdump* can be used
    to display traffic for all kinds of network packets (e.g., TCP segments, UDP datagrams,
    and ICMP packets). For each network packet, *tcpdump* displays information such
    as timestamps, the source and destination IP addresses, and further protocol-specific
    details. It is possible to select the packets to be monitored by protocol type,
    source and destination IP address and port number, and a range of other criteria.
    Full details are provided in the *tcpdump* manual page.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcpdump* 程序是一个有用的调试工具，它允许超级用户监控实时网络上的互联网流量，生成类似于图表的实时文本信息，如 [图 61-3](ch61.html#acknowledgements_in_tcp
    "图 61-3. TCP中的确认")。尽管其名称为 *tcpdump*，但它可以用于显示所有类型网络包的流量（例如 TCP 段、UDP 数据报和 ICMP
    包）。对于每个网络包，*tcpdump* 显示诸如时间戳、源和目标IP地址以及其他协议特定的细节信息。可以根据协议类型、源和目标IP地址及端口号以及其他标准来选择要监控的包。有关详细信息，请参阅
    *tcpdump* 手册页面。'
- en: Note
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *wireshark* (formerly *ethereal*; [http://www.wireshark.org](http://www.wireshark.org))
    program performs a similar task to *tcpdump*, but displays traffic information
    via a graphical interface.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*wireshark*（前身为 *ethereal*；[http://www.wireshark.org](http://www.wireshark.org)）程序执行的任务与
    *tcpdump* 相似，但通过图形界面显示流量信息。'
- en: 'For each TCP segment, *tcpdump* displays a line of the following form:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个 TCP 段，*tcpdump* 会显示如下形式的一行：
- en: '[PRE17]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These fields have the following meanings:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段的含义如下：
- en: '*src*: This is the source IP address and port.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*src*：这是源IP地址和端口。'
- en: '*dst*: This is the destination IP address and port.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*dst*：这是目标IP地址和端口。'
- en: '*flags*: This field contains zero or more of the following letters, each of
    which corresponds to one of the TCP control bits described in [Format of a TCP
    Segment](ch61.html#format_of_a_tcp_segment "Format of a TCP Segment"): S (SYN),
    F (FIN), P (PSH), R (RST), E (ECE), and C (CWR).'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*flags*：该字段包含零个或多个字母，每个字母对应 [TCP 段格式](ch61.html#format_of_a_tcp_segment "TCP
    段格式") 中描述的一个 TCP 控制位：S（SYN）、F（FIN）、P（PSH）、R（RST）、E（ECE）和 C（CWR）。'
- en: '*data-seqno*: This is the range of the sequence-number space covered by the
    bytes in this packet.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*data-seqno*：这是该数据包中所包含字节的序列号空间的范围。'
- en: Note
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, the sequence-number range is displayed relative to the first byte
    monitored for this direction of the data stream. The *tcpdump -S* option causes
    sequence numbers to be displayed in absolute format.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，序列号范围是相对于监视数据流的第一个字节显示的。*tcpdump -S*选项使得序列号以绝对格式显示。
- en: '*ack*: This is a string of the form “`ack` *num*” indicating the sequence number
    of the next byte expected from the other direction on this connection.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ack*：这是一个形式为“`ack` *num*”的字符串，表示从连接的另一个方向预期接收的下一个字节的序列号。'
- en: '*window*: This is a string of the form “`win` *num*” indicating the number
    of bytes of receive buffer space available for transmission in the opposite direction
    on this connection.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*window*：这是一个形式为“`win` *num*”的字符串，表示此连接在反方向上可用于传输的接收缓冲区空间的字节数。'
- en: '*urg*: This is a string of the form “`urg` *num*” indicating that this segment
    contains urgent data at the specified offset within the segment.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*urg*：这是一个形式为“`urg` *num*”的字符串，表示该报文段在指定偏移量处包含紧急数据。'
- en: '*options*: This string describes any TCP options contained in the segment.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*options*：这个字符串描述了报文段中包含的任何TCP选项。'
- en: The *src*, *dst*, and *flags* fields always appear. The remaining fields are
    displayed only if appropriate.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*src*、*dst*和*flags*字段始终会出现。其余字段仅在适当时显示。'
- en: The shell session below shows how *tcpdump* can be used to monitor the traffic
    between a client (running on the host `pukaki`) and a server (running on `tekapo`).
    In this shell session, we use two *tcpdump* options that make the output less
    verbose. The *-t* option suppresses the display of timestamp information. The
    *-N* option causes hostnames to be displayed without a qualifying domain name.
    Furthermore, for brevity, and because we don’t describe the details of TCP options,
    we have removed the *options* fields from the lines of *tcpdump* output.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的Shell会话展示了如何使用*tcpdump*监控客户端（运行在`pukaki`主机上）与服务器（运行在`tekapo`主机上）之间的流量。在这个Shell会话中，我们使用了两个使输出更简洁的*tcpdump*选项。*
    -t *选项禁止显示时间戳信息。* -N *选项使得主机名显示时不带有限定的域名。此外，为了简洁起见，并且因为我们没有描述TCP选项的细节，我们已从*tcpdump*输出的行中删除了*options*字段。
- en: 'The server operates on port 55555, so our *tcpdump* command selects traffic
    for that port. The output shows the three segments exchanged during connection
    establishment:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在端口55555上运行，因此我们的*tcpdump*命令选择了该端口的流量。输出显示了在连接建立过程中交换的三个报文段：
- en: '[PRE18]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These three segments are the SYN, SYN/ACK, and ACK segments exchanged for the
    three-way handshake (see [Figure 61-5](ch61.html#three-way_handshake_for_tcp_connection_e
    "Figure 61-5. Three-way handshake for TCP connection establishment")).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个报文段是为了三次握手而交换的SYN、SYN/ACK和ACK报文段（参见[图61-5](ch61.html#three-way_handshake_for_tcp_connection_e
    "图61-5. 三次握手用于TCP连接建立")）。
- en: 'In the following output, the client sends the server two messages, containing
    16 and 32 bytes, respectively, and the server responds in each case with a 4-byte
    message:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下输出中，客户端发送给服务器两条消息，分别包含16字节和32字节，而服务器分别以4字节的消息做出响应：
- en: '[PRE19]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For each of the data segments, we see an ACK sent in the opposite direction.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个数据段，我们可以看到反方向发送的ACK。
- en: 'Lastly, we show the segments exchanged during connection termination (first,
    the client closes its end of the connection, and then the server closes the other
    end):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了在连接终止过程中交换的报文段（首先，客户端关闭连接的一端，然后服务器关闭另一端）：
- en: '[PRE20]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The above output shows the four segments exchanged during connection termination
    (see [Figure 61-6](ch61.html#tcp_connection_termination-id1 "Figure 61-6. TCP
    connection termination")).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示了在连接终止过程中交换的四个报文段（参见[图61-6](ch61.html#tcp_connection_termination-id1 "图61-6.
    TCP连接终止")）。
- en: Socket Options
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套接字选项
- en: Socket options affect various features of the operation of a socket. In this
    book, we describe just a couple of the many socket options that are available.
    An extensive discussion covering most standard socket options is provided in [Stevens
    et al., 2004]. See the *tcp(7)*, *udp(7)*, *ip(7)*, *socket(7)*, and *unix(7)*
    manual pages for additional Linux-specific details.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字选项影响套接字操作的各个特性。在本书中，我们仅描述了几种可用的套接字选项。关于大多数标准套接字选项的详细讨论请参见[Stevens等人，2004]。有关更多Linux特定细节，请参阅*tcp(7)*、*udp(7)*、*ip(7)*、*socket(7)*和*unix(7)*手册页。
- en: The *setsockopt()* and *getsockopt()* system calls set and retrieve socket options.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*setsockopt()*和*getsockopt()*系统调用用于设置和获取套接字选项。'
- en: '[PRE21]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 两者在成功时返回0，出错时返回-1。
- en: For both *setsockopt()* and *getsockopt()*, *sockfd* is a file descriptor referring
    to a socket.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*setsockopt()*和*getsockopt()*，*sockfd*是一个指向套接字的文件描述符。
- en: The *level* argument specifies the protocol to which the socket option applies—for
    example, IP or TCP. For most of the socket options that we describe in this book,
    *level* is set to `SOL_SOCKET`, which indicates an option that applies at the
    sockets API level.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*level*参数指定套接字选项适用的协议——例如，IP或TCP。对于本书中描述的大多数套接字选项，*level*被设置为`SOL_SOCKET`，表示该选项适用于套接字API层。'
- en: The *optname* argument identifies the option whose value we wish to set or retrieve.
    The *optval* argument is a pointer to a buffer used to specify or return the option
    value; this argument is a pointer to an integer or a structure, depending on the
    option.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*optname*参数标识我们希望设置或检索其值的选项。*optval*参数是一个指向缓冲区的指针，用于指定或返回选项值；根据选项，该参数是指向整数或结构的指针。'
- en: The *optlen* argument specifies the size (in bytes) of the buffer pointed to
    by *optval*. For *setsockopt()*, this argument is passed by value. For *getsockopt()*,
    *optlen* is a value-result argument. Before the call, we initialize it to the
    size of the buffer pointed to by *optval*; upon return, it is set to the number
    of bytes actually written to that buffer.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*optlen*参数指定了*optval*指向的缓冲区的大小（以字节为单位）。对于*setsockopt()*，该参数按值传递。对于*getsockopt()*，*optlen*是一个值-结果参数。在调用之前，我们将其初始化为*optval*指向的缓冲区的大小；返回时，它被设置为实际写入该缓冲区的字节数。'
- en: As detailed in [Inheritance of Flags and Options Across *accept()*](ch61.html#inheritance_of_flags_and_options_across
    "Inheritance of Flags and Options Across accept()"), the socket file descriptor
    returned by a call to *accept()* inherits the values of settable socket options
    from the listening socket.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如[《*accept()*跨越标志和选项的继承》](ch61.html#inheritance_of_flags_and_options_across
    "《*accept()*跨越标志和选项的继承》")中详细描述，*accept()*调用返回的套接字文件描述符会继承监听套接字的可设置套接字选项值。
- en: Socket options are associated with an open file description (refer to [Figure 5-2](ch05.html#relationship_between_file_descriptors_co
    "Figure 5-2. Relationship between file descriptors, open file descriptions, and
    i-nodes"), in [Relationship Between File Descriptors and Open Files](ch05.html#relationship_between_file_descriptors_an
    "Relationship Between File Descriptors and Open Files")). This means that file
    descriptors duplicated as a consequence of *dup()* (or similar) or *fork()* share
    the same set of socket options.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字选项与一个打开的文件描述符相关联（参见[图5-2](ch05.html#relationship_between_file_descriptors_co
    "图5-2. 文件描述符、打开文件描述符和i节点的关系")，在[文件描述符与打开文件之间的关系](ch05.html#relationship_between_file_descriptors_an)中）。这意味着通过*dup()*（或类似操作）或*fork()*复制的文件描述符共享相同的套接字选项集。
- en: 'A simple example of a socket option is `SO_TYPE`, which can be used to find
    out the type of a socket, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的套接字选项示例是`SO_TYPE`，它可以用来查看套接字的类型，示例如下：
- en: '[PRE22]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After this call, *optval* contains the socket type—for example, `SOCK_STREAM`
    or `SOCK_DGRAM`. Using this call can be useful in a program that inherited a socket
    file descriptor across an *exec()*—for example, a program execed by *inetd*—since
    that program may not know which type of socket it inherited.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在此调用后，*optval*包含套接字类型——例如，`SOCK_STREAM`或`SOCK_DGRAM`。在一个通过*exec()*继承了套接字文件描述符的程序中使用此调用非常有用——例如，由*inetd*启动的程序——因为该程序可能不知道它继承了哪种类型的套接字。
- en: '`SO_TYPE` is an example of a read-only socket option. It is not possible to
    use *setsockopt()* to change a socket’s type.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`SO_TYPE`是一个只读套接字选项的示例。无法使用*setsockopt()*更改套接字的类型。'
- en: The *SO_REUSEADDR* Socket Option
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*SO_REUSEADDR*套接字选项'
- en: 'The `SO_REUSEADDR` socket option serves a number of purposes (see [Chapter 7](ch07.html
    "Chapter 7. Memory Allocation") of [Stevens et al., 2004] for details). We’ll
    concern ourselves with only one common use: to avoid the `EADDRINUSE` (“Address
    already in use”) error when a TCP server is restarted and tries to bind a socket
    to a port that currently has an associated TCP. There are two scenarios in which
    this usually occurs:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`SO_REUSEADDR`套接字选项有多种用途（详见[第7章](ch07.html "第7章. 内存分配")，[Stevens等，2004]）。我们只关心其中一个常见用法：避免在TCP服务器重新启动并尝试将套接字绑定到当前有关联TCP的端口时出现`EADDRINUSE`（“地址已在使用”）错误。通常发生这种情况的有两种情况：'
- en: A previous invocation of the server that was connected to a client performed
    an active close, either by calling *close()*, or by crashing (e.g., it was killed
    by a signal). This leaves a TCP endpoint that remains in the TIME_WAIT state until
    the 2MSL timeout expires.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前对连接到客户端的服务器的调用执行了主动关闭操作，可能是通过调用*close()*，也可能是由于崩溃（例如，它被信号杀死）。这会导致一个TCP端点保持在TIME_WAIT状态，直到2MSL超时到期。
- en: A previous invocation of the server created a child process to handle a connection
    to a client. Later, the server terminated, while the child continues to serve
    the client, and thus maintain a TCP endpoint using the server’s well-known port.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前对服务器的调用创建了一个子进程来处理与客户端的连接。稍后，服务器终止，而子进程继续为客户端提供服务，从而保持使用服务器著名端口的TCP端点。
- en: In both of these scenarios, the outstanding TCP endpoint is unable to accept
    new connections. Nevertheless, in both cases, by default, most TCP implementations
    prevent a new listening socket from being bound to the server’s well-known port.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，未完成的TCP端点无法接受新的连接。然而，在这两种情况下，默认情况下，大多数TCP实现都会阻止将新的监听套接字绑定到服务器的著名端口。
- en: Note
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `EADDRINUSE` error doesn’t usually occur with clients, since they typically
    use an ephemeral port that won’t be one of those ports currently in the TIME_WAIT
    state. However, if a client binds to a specific port number, then it also can
    encounter this error.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`EADDRINUSE`错误通常不会出现在客户端，因为它们通常使用一个临时端口，该端口不会是当前在TIME_WAIT状态的端口之一。然而，如果客户端绑定到特定端口号，它也可能会遇到此错误。'
- en: To understand the operation of the `SO_REUSEADDR` socket option, it can help
    to return to our earlier telephone analogy for stream sockets ([Stream Sockets](ch56.html#stream_sockets
    "Stream Sockets")). Like a telephone call (we ignore the notion of conference
    calls), a TCP socket connection is identifiable by the *combination* of a pair
    of connected endpoints. The operation of *accept()* is analogous to the task performed
    by a telephone operator on an internal company switchboard (“a server”). When
    an external telephone call arrives, the operator transfers it to some internal
    telephone (“a new socket”) within the organization. From an outside perspective,
    there is no way of identifying that internal telephone. When multiple external
    calls are being handled by the switchboard, the only way of distinguishing them
    is via the combination of the external caller’s number and the switchboard number.
    (The latter is necessary when we consider that there will be multiple company
    switchboards within the telephone network as a whole.) Analogously, each time
    we accept a socket connection on a listening socket, a new socket is created.
    All of these sockets are associated with the same local address as the listening
    socket. The only way of distinguishing them is via their connections to different
    peer sockets.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解`SO_REUSEADDR`套接字选项的操作，可以帮助回顾我们之前关于流套接字的电话类比（[流套接字](ch56.html#stream_sockets
    "Stream Sockets")）。就像电话通话（我们忽略了电话会议的概念），TCP套接字连接是通过一对连接端点的*组合*来标识的。*accept()*的操作类似于电话接线员在内部公司总机上执行的任务（“服务器”）。当外部电话到达时，接线员将其转接到公司内部的某个电话（“新套接字”）。从外部的角度来看，无法识别这个内部电话。当多个外部电话通过总机处理时，区分它们的唯一方法是通过外部来电者的号码和总机号码的组合。（考虑到整个电话网络中将会有多个公司总机时，后者是必要的。）类似地，每次我们在监听套接字上接受一个套接字连接时，都会创建一个新的套接字。所有这些套接字都与监听套接字使用相同的本地地址。区分它们的唯一方法是通过它们与不同对等套接字的连接。
- en: 'In other words, a connected TCP socket is identified by a 4-tuple (i.e., a
    combination of four values) of the following form:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，一个已连接的TCP套接字是通过以下形式的四元组（即四个值的组合）来标识的：
- en: '[PRE23]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The TCP specification requires that each such tuple be unique; that is, only
    one corresponding connection incarnation (“telephone call”) can exist. The problem
    is that most implementations (including Linux) enforce a stricter constraint:
    a local port can’t be reused (i.e., specified in a call to *bind()*) if any TCP
    connection incarnation with a matching local port exists on the host. This rule
    is enforced even when the TCP could not accept new connections, as in the scenarios
    described at the start of this section.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: TCP规范要求每个这样的四元组是唯一的；也就是说，只有一个对应的连接实例（“电话通话”）可以存在。问题是，大多数实现（包括Linux）强制执行更严格的约束：如果主机上存在具有匹配本地端口的任何TCP连接实例，则无法重用本地端口（即在调用*bind()*时指定）。即使TCP无法接受新的连接，也会强制执行这一规则，就像本节开头描述的场景一样。
- en: Enabling the `SO_REUSEADDR` socket option relaxes this constraint, bringing
    it closer to the TCP requirement. By default, this option has the value 0, meaning
    that it is disabled. We enable the option by giving it a nonzero value before
    binding a socket, as shown in [Example 61-4](ch61.html#setting_the_so_underscore_reuseaddr_sock
    "Example 61-4. Setting the SO_REUSEADDR socket option").
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 启用`SO_REUSEADDR`套接字选项放宽了此约束，使其更接近TCP要求。默认情况下，此选项的值为0，意味着它是禁用的。我们通过在绑定套接字之前赋予它一个非零值来启用此选项，如[示例
    61-4](ch61.html#setting_the_so_underscore_reuseaddr_sock "示例 61-4. 设置SO_REUSEADDR套接字选项")所示。
- en: Setting the `SO_REUSEADDR` option means that we can bind a socket to a local
    port even if another TCP is bound to the same port in either of the scenarios
    described at the start of this section. Most TCP servers should enable this option.
    We have already seen some examples of the use of this option in [Example 59-6](ch59.html#an_iterative_server_that_uses_a_stream_s
    "Example 59-6. An iterative server that uses a stream socket to communicate with
    clients") (page 1221) and [Example 59-9](ch59.html#an_internet_domain_sockets_librar
    "Example 59-9. An Internet domain sockets library") (page 1228).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`SO_REUSEADDR`选项意味着即使在本节开头描述的两种情况中的任何一种中，另一个TCP已经绑定到相同的端口，我们仍然可以将套接字绑定到本地端口。大多数TCP服务器应该启用此选项。我们已经在[示例
    59-6](ch59.html#an_iterative_server_that_uses_a_stream_s "示例 59-6. 使用流套接字与客户端通信的迭代服务器")（第1221页）和[示例
    59-9](ch59.html#an_internet_domain_sockets_librar "示例 59-9. 一个互联网域套接字库")（第1228页）中看到了一些使用此选项的例子。
- en: Example 61-4. Setting the `SO_REUSEADDR` socket option
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 61-4. 设置`SO_REUSEADDR`套接字选项
- en: '[PRE24]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inheritance of Flags and Options Across *accept()*
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标志和选项在*accept()*中的继承
- en: Various flags and settings can be associated with open file descriptions and
    file descriptors ([Relationship Between File Descriptors and Open Files](ch05.html#relationship_between_file_descriptors_an
    "Relationship Between File Descriptors and Open Files")). Furthermore, as described
    in [Socket Options](ch61.html#socket_options "Socket Options"), various options
    can be set for a socket. If these flags and options are set on a listening socket,
    are they inherited by the new socket returned by *accept()*? We describe the details
    here.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 各种标志和设置可以与打开的文件描述符和文件描述符关联（[文件描述符与打开文件的关系](ch05.html#relationship_between_file_descriptors_an
    "文件描述符与打开文件的关系")）。此外，正如在[套接字选项](ch61.html#socket_options "套接字选项")中所描述的，可以为套接字设置各种选项。如果这些标志和选项设置在监听套接字上，它们会被*accept()*返回的新套接字继承吗？我们在这里描述了详细信息。
- en: 'On Linux, the following attributes are not inherited by the new file descriptor
    returned by *accept()*:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，以下属性不会被*accept()*返回的新文件描述符继承：
- en: The status flags associated with an open file description—the flags that can
    be altered using the *fcntl()* `F_SETFL` operation ([Open File Status Flags](ch05.html#open_file_status_flags
    "Open File Status Flags")). These include flags such as `O_NONBLOCK` and `O_ASYNC`.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与打开的文件描述符相关的状态标志—这些标志可以通过*fcntl()*的`F_SETFL`操作进行更改（[打开文件状态标志](ch05.html#open_file_status_flags
    "打开文件状态标志")）。其中包括如`O_NONBLOCK`和`O_ASYNC`等标志。
- en: The file descriptor flags—the flags that can be altered using the *fcntl()*
    `F_SETFD` operation. The only such flag is the close-on-exec flag (`FD_CLOEXEC`,
    described in [File Descriptors and *exec()*](ch27.html#file_descriptors_and_exec_open_parenthes
    "File Descriptors and exec()")).
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件描述符标志—这些标志可以通过*fcntl()*的`F_SETFD`操作进行更改。唯一的此类标志是执行时关闭标志（`FD_CLOEXEC`，在[文件描述符和*exec()*](ch27.html#file_descriptors_and_exec_open_parenthes
    "文件描述符和exec()")中有描述）。
- en: The *fcntl()* `F_SETOWN` (owner process ID) and `F_SETSIG` (generated signal)
    file descriptor attributes associated with signal-driven I/O ([Signal-Driven I/O](ch63.html#signal-driven_i_solidus_o
    "Signal-Driven I/O")).
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*fcntl()*中的`F_SETOWN`（所有者进程ID）和`F_SETSIG`（生成信号）与信号驱动I/O相关的文件描述符属性（[信号驱动I/O](ch63.html#signal-driven_i_solidus_o
    "信号驱动I/O")）。'
- en: On the other hand, the new descriptor returned by *accept()* inherits a copy
    of most of the socket options that can be set using *setsockopt()* ([Socket Options](ch61.html#socket_options
    "Socket Options")).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*accept()*返回的新描述符会继承大多数可以使用*setsockopt()*设置的套接字选项的副本（[套接字选项](ch61.html#socket_options
    "套接字选项")）。
- en: SUSv3 is silent on the details described here, and the inheritance rules for
    the new connected socket returned by *accept()* vary across UNIX implementations.
    Most notably, on some UNIX implementations, if open file status flags such as
    `O_NONBLOCK` and `O_ASYNC` are set on a listening socket, then they are inherited
    by the new socket returned by *accept()*. For portability, it may be necessary
    to explicitly reset these attributes on a socket returned by *accept()*.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3对这里描述的细节保持沉默，以及由*accept()*返回的新连接套接字的继承规则在UNIX实现中有所不同。 特别是，在某些UNIX实现中，如果在侦听套接字上设置了诸如`O_NONBLOCK`和`O_ASYNC`等开放文件状态标志，则它们将被*accept()*返回的新套接字继承。
    为了可移植性，可能需要显式地重置*accept()*返回的套接字上的这些属性。
- en: TCP Versus UDP
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP与UDP
- en: 'Given that TCP provides reliable delivery of data, while UDP does not, an obvious
    question is, “Why use UDP at all?” The answer to this question is covered at some
    length in [Chapter 22](ch22.html "Chapter 22. Signals: Advanced Features") of
    [Stevens et al., 2004]. Here, we summarize some of the points that may lead us
    to choose UDP over TCP:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '鉴于TCP提供数据的可靠传输，而UDP则不提供，一个显而易见的问题是，“为什么要使用UDP呢？” 这个问题的答案在[第22章](ch22.html "Chapter 22. Signals:
    Advanced Features")中有详细讨论，见于[Stevens等人，2004年]。 在这里，我们总结了一些可能导致我们选择UDP而不是TCP的要点：'
- en: A UDP server can receive (and reply to) datagrams from multiple clients, without
    needing to create and terminate a connection for each client (i.e., transmission
    of single messages using UDP has a lower overhead than is required when using
    TCP).
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP服务器可以从多个客户端接收（和回复）数据报，而无需为每个客户端创建和终止连接（即，使用UDP传输单个消息的开销低于使用TCP时所需的开销）。
- en: For simple request-response communications, UDP can be faster than TCP, since
    it doesn’t require connection establishment and termination. [Appendix A](apa.html
    "Appendix A. Tracing System Calls") of [Stevens, 1996] notes that in the best-case
    scenario, the time using TCP is
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于简单的请求-响应通信，UDP可能比TCP更快，因为它不需要建立和终止连接。 [附录A](apa.html "Appendix A. Tracing
    System Calls")提到，在最佳情况下，使用TCP的时间是
- en: '[PRE25]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this formula, RTT is the round-trip time (the time required to send a request
    and receive a response), and SPT is the time spent by the server processing the
    request. (On a wide area network, the SPT value may be small compared to the RTT.)
    For UDP, the best-case scenario for a single request-response communication is
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个公式中，RTT是往返时间（发送请求并接收响应所需的时间），而SPT是服务器处理请求所花费的时间。 （在广域网上，与RTT相比，SPT值可能很小。）对于UDP，单个请求-响应通信的最佳情况是
- en: '[PRE26]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is one RTT less than the time required for TCP. Since the RTT between hosts
    separated by large (i.e., intercontinental) distances or many intervening routers
    is typically several tenths of a second, this difference can make UDP attractive
    for some types of request-response communication. DNS is a good example of an
    application that uses UDP for this reason—using UDP allows name lookup to be performed
    by transmitting a single packet in each direction between servers.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这比TCP所需的时间少一个RTT。 由于在大范围（即跨洲际）距离或许多中间路由器之间分隔的主机之间的RTT通常是几十分之一秒，这种差异可以使UDP对某些类型的请求-响应通信具有吸引力。
    DNS是一个使用UDP的好例子，原因在于使用UDP允许在服务器之间的每个方向传输单个数据包来执行名称查找。
- en: 'UDP sockets permit broadcasting and multicasting. *Broadcasting* allows a sender
    to transmit a datagram to the same destination port on all of the hosts connected
    to a network. *Multicasting* is similar, but allows a datagram to be sent to a
    specified set of hosts. For further details see [Chapter 21](ch21.html "Chapter 21. Signals:
    Signal Handlers") and [Chapter 22](ch22.html "Chapter 22. Signals: Advanced Features")
    of [Stevens et al., 2004].'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'UDP套接字允许广播和多播。 *广播* 允许发送者向连接到网络的所有主机的相同目的端口传输数据报。 *多播* 类似，但允许将数据报发送到指定的一组主机。
    更多细节请参见[第21章](ch21.html "Chapter 21. Signals: Signal Handlers")和[第22章](ch22.html
    "Chapter 22. Signals: Advanced Features")，见于[Stevens等人，2004年]。'
- en: Certain types of applications (e.g., streaming video and audio transmission)
    can function acceptably without the reliability provided by TCP. On the other
    hand, the delay that may occur after TCP tries to recover from a lost segment
    may result in transmission delays that are unacceptably long. (A delay in streaming
    media transmission may be worse than a brief loss of the transmission stream.)
    Therefore, such applications may prefer UDP, and adopt application-specific recovery
    strategies to deal with occasional packet loss.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些类型的应用程序（例如，视频和音频流传输）在没有TCP提供的可靠性的情况下也能正常工作。另一方面，TCP尝试从丢失的数据段恢复后的延迟可能导致不可接受的传输延迟。（流媒体传输的延迟可能比传输流的短暂丢失更糟。）因此，这些应用程序可能更倾向于使用UDP，并采用特定于应用的恢复策略来应对偶尔的数据包丢失。
- en: An application that uses UDP, but nevertheless requires reliability, must implement
    reliability features itself. Usually, this requires at least sequence numbers,
    acknowledgements, retransmission of lost packets, and duplicate detection. An
    example of how to do this is shown in [Stevens et al., 2004]. However, if more
    advanced features such as flow control and congestion control are also required,
    then it is probably best to use TCP instead. Trying to implement all of these
    features on top of UDP is complex, and, even when well implemented, the result
    is unlikely to perform better than TCP.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UDP的应用程序，如果仍然需要可靠性，必须自行实现可靠性功能。通常，这至少需要序列号、确认、丢失数据包的重传和重复检测。如何实现这一点的示例可以参见[Stevens
    et al., 2004]。然而，如果还需要更高级的功能，如流量控制和拥塞控制，那么最好使用TCP。尝试在UDP上实现所有这些功能是复杂的，即使实现得很好，结果也不太可能比TCP表现更好。
- en: Advanced Features
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级功能
- en: UNIX and Internet domain sockets have many other features that we have not detailed
    in this book. We summarize a few of these features in this section. For full details,
    see [Stevens et al., 2004].
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX和互联网域套接字还有许多其他特性，我们在本书中没有详细介绍。我们在本节中总结了一些这些特性。有关详细信息，请参见[Stevens et al.,
    2004]。
- en: Out-of-Band Data
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带外数据
- en: Out-of-band data is a feature of stream sockets that allows a sender to mark
    transmitted data as high priority; that is, the receiver can obtain notification
    of the availability of out-of-band data without needing to read all of the intervening
    data in the stream. This feature is used in programs such as *telnet, rlogin*,
    and *ftp* to make it possible to abort previously transmitted commands. Out-of-band
    data is sent and received using the `MSG_OOB` flag in calls to *send()* and *recv()*.
    When a socket receives notification of the availability of out-of-band data, the
    kernel generates the `SIGURG` signal for the socket owner (normally the process
    using the socket), as set by the *fcntl()* `F_SETOWN` operation.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 带外数据是流套接字的一项功能，它允许发送方将传输的数据标记为高优先级；即接收方可以在不需要读取流中所有中间数据的情况下获得带外数据可用的通知。这个功能在如*telnet、rlogin*和*ftp*等程序中使用，使得可以中止之前传输的命令。带外数据通过在调用*send()*和*recv()*时使用`MSG_OOB`标志来发送和接收。当套接字接收到带外数据可用的通知时，内核会为套接字的拥有者（通常是使用该套接字的进程）生成`SIGURG`信号，这是由*fcntl()*的`F_SETOWN`操作设置的。
- en: When employed with TCP sockets, at most 1 byte of data may be marked as being
    out-of-band at any one time. If the sender transmits an additional byte of out-of-band
    data before the receiver has processed the previous byte, then the indication
    for the earlier out-of-band byte is lost.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在与TCP套接字一起使用时，每次最多只能标记1字节的数据为带外数据。如果发送方在接收方处理完前一个字节之前传输了额外的带外数据字节，那么前一个带外字节的指示将丢失。
- en: Note
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: TCP’s limitation of out-of-band data to a single byte is an artifact of the
    mismatch between the generic out-of-band model of the sockets API and its specific
    implementation using TCP’s *urgent mode*. We touched on TCP’s urgent mode when
    looking at the format of TCP segments in [Format of a TCP Segment](ch61.html#format_of_a_tcp_segment
    "Format of a TCP Segment"). TCP indicates the presence of urgent (out-of-band)
    data by setting the URG bit in the TCP header and setting the urgent pointer field
    to point to the urgent data. However, TCP has no way of indicating the length
    of an urgent data sequence, so the urgent data is considered to consist of a single
    byte.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: TCP对带外数据限制为单个字节，这是套接字API的通用带外模型与其使用TCP的*紧急模式*的具体实现之间不匹配的结果。我们在[TCP段格式](ch61.html#format_of_a_tcp_segment
    "TCP段格式")中提到过TCP的紧急模式。TCP通过设置TCP头中的URG位并将紧急指针字段指向紧急数据，来指示带外（紧急）数据的存在。然而，TCP无法指示紧急数据序列的长度，因此紧急数据被认为由单个字节组成。
- en: Further information about TCP urgent data can be found in RFC 793.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 关于TCP带外数据的更多信息可以在RFC 793中找到。
- en: Under some UNIX implementations, out-of-band data is supported for UNIX domain
    stream sockets. Linux doesn’t support this.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些UNIX实现中，UNIX域流套接字支持带外数据。Linux不支持此功能。
- en: The use of out-of-band data is nowadays discouraged, and it may be unreliable
    in some circumstances (see [Gont & Yourtchenko, 2009]). An alternative is to maintain
    a pair of stream sockets for communication. One of these is used for normal communication,
    while the other is used for high-priority communication. An application can monitor
    both channels using one of the techniques described in [Chapter 63](ch63.html
    "Chapter 63. Alternative I/O Models"). This approach allows multiple bytes of
    priority data to be transmitted. Furthermore, it can be employed with stream sockets
    in any communication domain (e.g., UNIX domain sockets).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不推荐使用带外数据，在某些情况下可能不可靠（参见[Gont & Yourtchenko, 2009]）。一种替代方案是保持一对流套接字用于通信。其中一个用于正常通信，另一个用于高优先级通信。应用程序可以使用在[第63章](ch63.html
    "第63章。替代I/O模型")中描述的技术之一来监控这两个通道。这种方法允许传输多个字节的优先级数据。此外，它可以与任何通信域中的流套接字一起使用（例如，UNIX域套接字）。
- en: The *sendmsg()* and *recvmsg()* System Calls
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*sendmsg()* 和 *recvmsg()* 系统调用'
- en: 'The *sendmsg()* and *recvmsg()* system calls are the most general purpose of
    the socket I/O system calls. The *sendmsg()* system call can do everything that
    is done by *write()*, *send()*, and *sendto()*; the *recvmsg()* system call can
    do everything that is done by *read()*, *recv()*, and *recvfrom()*. In addition,
    these calls allow the following:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '*sendmsg()* 和 *recvmsg()* 系统调用是套接字I/O系统调用中最通用的。*sendmsg()* 系统调用可以执行*write()*、*send()*和*sendto()*所做的所有操作；*recvmsg()*
    系统调用可以执行*read()*、*recv()*和*recvfrom()*所做的所有操作。此外，这些调用还允许以下操作：'
- en: 'We can perform scatter-gather I/O, as with *readv()* and *writev()* ([Scatter-Gather
    I/O: *readv()* and *writev()*](ch05.html#scatter-gather_i_solidus_o_colon_readv_o
    "Scatter-Gather I/O: readv() and writev()")). When we use *sendmsg()* to perform
    gather output on a datagram socket (or *writev()* on a connected datagram socket),
    a single datagram is generated. Conversely, *recvmsg()* (and *readv()*) can be
    used to perform scatter input on a datagram socket, dispersing the bytes of a
    single datagram into multiple user-space buffers.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们可以执行散列-聚集I/O，类似于*readv()*和*writev()*（[散列-聚集I/O: *readv()* 和 *writev()*](ch05.html#scatter-gather_i_solidus_o_colon_readv_o
    "散列-聚集I/O：readv() 和 writev()")）。当我们使用*sendmsg()*在数据报套接字上执行聚集输出时（或在连接的UDP套接字上使用*writev()*），会生成一个数据报。相反，*recvmsg()*（和*readv()*）可以用于在数据报套接字上执行散列输入，将单个数据报的字节分散到多个用户空间缓冲区中。'
- en: We can transmit messages containing domain-specific *ancillary data* (also known
    as control information). Ancillary data can be passed via both stream and datagram
    sockets. We describe some examples of ancillary data below.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以传输包含特定领域的*附加数据*（也称为控制信息）的消息。附加数据可以通过流套接字和数据报套接字传递。我们在下面描述了一些附加数据的示例。
- en: Note
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Linux 2.6.33 adds a new system call, *recvmmsg()*. This system call is similar
    to *recvmsg()*, but allows multiple datagrams to be received in a single system
    call. This reduces the system-call overhead in applications that deal with high
    levels of network traffic. An analogous *sendmmsg()* system call is likely to
    be added in a future kernel version.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 2.6.33新增了一个系统调用，*recvmmsg()*。这个系统调用与*recvmsg()*类似，但允许在一次系统调用中接收多个数据报文。这减少了在处理高网络流量的应用程序中系统调用的开销。一个类似的*sendmmsg()*系统调用可能会在未来的内核版本中添加。
- en: Passing File Descriptors
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递文件描述符
- en: Using *sendmsg()* and *recvmsg()*, we can pass ancillary data containing a file
    descriptor from one process to another process on the same host via a UNIX domain
    socket. Any type of file descriptor can be passed in this manner—for example,
    one obtained from a call to *open()* or *pipe()*. An example that is more relevant
    to sockets is that a master server could accept a client connection on a TCP listening
    socket and pass that descriptor to one of the members of a pool of server child
    processes ([Other Concurrent Server Designs](ch60.html#other_concurrent_server_designs
    "Other Concurrent Server Designs")), which would then respond to the client request.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*sendmsg()*和*recvmsg()*，我们可以通过UNIX域套接字将包含文件描述符的辅助数据从一个进程传递到同一主机上的另一个进程。任何类型的文件描述符都可以通过这种方式传递——例如，通过调用*open()*或*pipe()*获得的文件描述符。一个与套接字更相关的示例是，主服务器可以在TCP监听套接字上接受客户端连接，并将该描述符传递给服务器子进程池中的一个成员（[其他并发服务器设计](ch60.html#other_concurrent_server_designs
    "其他并发服务器设计")），该子进程随后会响应客户端请求。
- en: Although this technique is commonly referred to as passing a file descriptor,
    what is really being passed between the two processes is a reference to the same
    open file description ([Figure 5-2](ch05.html#relationship_between_file_descriptors_co
    "Figure 5-2. Relationship between file descriptors, open file descriptions, and
    i-nodes"), in [Relationship Between File Descriptors and Open Files](ch05.html#relationship_between_file_descriptors_an
    "Relationship Between File Descriptors and Open Files")). The file descriptor
    number employed in the receiving process would typically be different from the
    number employed in the sender.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种技术通常被称为传递文件描述符，但实际上在两个进程之间传递的是对同一打开文件描述的引用（[图 5-2](ch05.html#relationship_between_file_descriptors_co
    "图 5-2. 文件描述符、打开文件描述符和i节点之间的关系")，在[文件描述符与打开文件之间的关系](ch05.html#relationship_between_file_descriptors_an
    "文件描述符与打开文件之间的关系")中）。接收进程中使用的文件描述符号通常与发送方使用的文件描述符号不同。
- en: Note
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An example of passing file descriptors is provided in the files `scm_rights_send.c`
    and `scm_rights_recv.c` in the `sockets` subdirectory in the source code distribution
    for this book.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的源代码分发包中的`sockets`子目录下，文件`scm_rights_send.c`和`scm_rights_recv.c`提供了传递文件描述符的示例。
- en: Receiving Sender Credentials
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接收发送方凭证
- en: Another example of the use of ancillary data is for receiving sender credentials
    via a UNIX domain socket. These credentials consist of the user ID, the group
    ID, and the process ID of the sending process. The sender may specify its user
    and group IDs as the corresponding real, effective, or saved set IDs. This allows
    the receiving process to authenticate a sender on the same host. For further details,
    see the *socket(7)* and *unix(7)* manual pages.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使用辅助数据的另一个示例是通过UNIX域套接字接收发送方凭证。这些凭证包括发送进程的用户ID、组ID和进程ID。发送方可以指定其用户ID和组ID作为对应的真实ID、有效ID或保存ID。这使得接收进程能够验证同一主机上的发送方。更多详细信息，请参见*socket(7)*和*unix(7)*手册页。
- en: Unlike passing file credentials, passing sender credentials is not specified
    in SUSv3\. Aside from Linux, this feature is implemented in some of the modern
    BSDs (where the credentials structure contains somewhat more information than
    on Linux), but is available on few other UNIX implementations. The details of
    credential passing on FreeBSD are described in [Stevens et al., 2004].
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 与传递文件凭证不同，传递发送方凭证在SUSv3中并未指定。除了Linux外，这一功能在一些现代BSD系统中得到了实现（其中凭证结构包含的信息比Linux中的更多），但在其他一些UNIX实现中则较为罕见。有关FreeBSD上凭证传递的详细信息，请参见[Stevens等人，2004]。
- en: On Linux, a privileged process can fake the user ID, group ID, and process ID
    that are passed as credentials if it has, respectively, the `CAP_SETUID`, `CAP_SETGID`,
    and `CAP_SYS_ADMIN` capabilities.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '在Linux中，如果特权进程具有相应的`CAP_SETUID`、`CAP_SETGID`和`CAP_SYS_ADMIN`能力，它可以伪造作为凭证传递的用户ID、组ID和进程ID。 '
- en: Note
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An example of passing credentials is provided in the files `scm_cred_send.c`
    and `scm_cred_recv.c` in the `sockets` subdirectory in the source code distribution
    for this book.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 一个传递凭证的示例可以在源代码分发包中的 `sockets` 子目录下的 `scm_cred_send.c` 和 `scm_cred_recv.c` 文件中找到。
- en: Sequenced-Packet Sockets
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顺序数据包套接字
- en: 'Sequenced-packet sockets combine features of both stream and datagram sockets:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序数据包套接字结合了流套接字和数据报套接字的特性：
- en: Like stream sockets, sequenced-packet sockets are connection-oriented. Connections
    are established in the same way as for stream sockets, using *bind()*, *listen()*,
    *accept()*, and *connect()*.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与流套接字类似，顺序数据包套接字是面向连接的。连接的建立方式与流套接字相同，使用 *bind()*、*listen()*、*accept()* 和 *connect()*。
- en: Like datagram sockets, message boundaries are preserved. A *read()* from a sequenced-packet
    socket returns exactly one message (as written by the peer). If the message is
    longer than the buffer supplied by the caller, the excess bytes are discarded.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像数据报套接字一样，消息边界被保留。从顺序数据包套接字的 *read()* 操作中读取时，将返回一个完整的消息（如对等方所写）。如果消息的长度超过了调用者提供的缓冲区，则多余的字节会被丢弃。
- en: Like stream sockets, and unlike datagram sockets, communication via sequenced-packet
    sockets is reliable. Messages are delivered to the peer application error-free,
    in order, and unduplicated, and they are guaranteed to arrive (assuming that there
    is not a system or application crash, or a network outage).
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像流套接字一样，顺序数据包套接字与数据报套接字不同，通信是可靠的。消息将按顺序、无错误、不重复地传递给对等应用程序，并保证到达（假设没有系统或应用程序崩溃，或网络中断）。
- en: A sequenced-packet socket is created by calling *socket()* with the *type* argument
    specified as `SOCK_SEQPACKET`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 *socket()* 并将 *type* 参数指定为 `SOCK_SEQPACKET` 来创建顺序数据包套接字。
- en: Historically, Linux, like most UNIX implementations, did not support sequenced-packet
    sockets in either the UNIX or the Internet domains. However, starting with kernel
    2.6.4, Linux supports `SOCK_SEQPACKET` for UNIX domain sockets.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，Linux 和大多数 UNIX 实现一样，既不支持 UNIX 域也不支持互联网域中的顺序数据包套接字。然而，从内核 2.6.4 开始，Linux
    支持 UNIX 域套接字中的 `SOCK_SEQPACKET`。
- en: In the Internet domain, the UDP and TCP protocols do not support `SOCK_SEQPACKET`,
    but the SCTP protocol (described in the next section) does.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网领域，UDP 和 TCP 协议不支持 `SOCK_SEQPACKET`，但 SCTP 协议（将在下一节中介绍）支持。
- en: We don’t show an example of the use of sequenced-packet sockets in this book,
    but, other than the preservation of message boundaries, their use is very similar
    to stream sockets.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中没有展示顺序数据包套接字的使用示例，但除了保留消息边界外，它们的使用方式与流套接字非常相似。
- en: SCTP and DCCP Transport-Layer Protocols
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SCTP 和 DCCP 传输层协议
- en: SCTP and DCCP are two newer transport-layer protocols that are likely to become
    increasingly common in the future.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: SCTP 和 DCCP 是两种较新的传输层协议，未来可能会变得越来越常见。
- en: The *Stream Control Transmission Protocol* (SCTP, [http://www.sctp.org/](http://www.sctp.org/))
    was designed to support telephony signaling in particular, but is also general
    purpose. Like TCP, SCTP provides reliable, bidirectional, connection-oriented
    transport. Unlike TCP, SCTP preserves message boundaries. One of the distinctive
    features of SCTP is multistream support, which allows multiple logical data streams
    to be employed over a single connection.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '*流控制传输协议*（SCTP，[http://www.sctp.org/](http://www.sctp.org/)）最初是为了支持电话信令而设计的，但它也是通用的。像
    TCP 一样，SCTP 提供可靠的、双向的、面向连接的传输。与 TCP 不同，SCTP 保留了消息边界。SCTP 的一个显著特征是支持多流，可以在单个连接上使用多个逻辑数据流。'
- en: SCTP is described in [Stewart & Xie, 2001], [Stevens et al., 2004], and in RFCs
    4960, 3257, and 3286.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: SCTP 在 [Stewart & Xie, 2001]、[Stevens et al., 2004] 和 RFC 4960、3257、3286 中有描述。
- en: SCTP is available on Linux since kernel 2.6\. Further information about this
    implementation can be found at [http://lksctp.sourceforge.net/](http://lksctp.sourceforge.net/).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Linux 内核 2.6 版本起，SCTP 可在 Linux 上使用。有关此实现的更多信息，请访问 [http://lksctp.sourceforge.net/](http://lksctp.sourceforge.net/)。
- en: 'Throughout the preceding chapters that describe the sockets API, we equated
    Internet domain stream sockets with TCP. However, SCTP provides an alternative
    protocol for implementing stream sockets, created using the following call:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面描述套接字 API 的章节中，我们将互联网域的流套接字与 TCP 等同。然而，SCTP 提供了一种替代协议来实现流套接字，可以通过以下调用创建：
- en: '[PRE27]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Starting in kernel 2.6.14, Linux supports a new datagram protocol, the *Datagram
    Congestion Control Protocol* (DCCP). Like TCP, DCCP provides congestion control
    (removing the need to implement congestion control at the application level) to
    prevent a fast transmitter from overwhelming the network. (We explained congestion
    control when describing TCP in [Transmission Control Protocol (TCP)](ch58.html#transmission_control_protocol_open_paren
    "Transmission Control Protocol (TCP)").) However, unlike TCP (but like UDP), DCCP
    doesn’t provide guarantees about reliable or in-order delivery, and thus allows
    applications that don’t need these features to avoid the delays that they can
    incur. Information about DCCP can be found at [http://www.read.cs.ucla.edu/dccp/](http://www.read.cs.ucla.edu/dccp/)
    and RFCs 4336 and 4340.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核 2.6.14 开始，Linux 支持一种新的数据报协议——*数据报拥塞控制协议*（DCCP）。像 TCP 一样，DCCP 提供了拥塞控制（避免需要在应用层实现拥塞控制），防止快速传输者压垮网络。（我们在讲解
    TCP 时已解释了拥塞控制，参见 [传输控制协议 (TCP)](ch58.html#transmission_control_protocol_open_paren
    "Transmission Control Protocol (TCP)")。）然而，与 TCP 不同（但像 UDP 一样），DCCP 不提供可靠或按顺序交付的保证，因此允许不需要这些特性的应用程序避免由此产生的延迟。关于
    DCCP 的信息可以在 [http://www.read.cs.ucla.edu/dccp/](http://www.read.cs.ucla.edu/dccp/)
    和 RFC 4336、4340 中找到。
- en: Summary
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In various circumstances, partial reads and writes can occur when performing
    I/O on stream sockets. We showed the implementation of two functions, *readn()*
    and *writen()*, that can be used to ensure a complete buffer of data is read or
    written.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的情况下，执行流套接字的 I/O 操作时可能会发生部分读取和写入。我们展示了两个函数的实现，*readn()* 和 *writen()*，可以确保完整的缓冲区数据被读取或写入。
- en: The *shutdown()* system call provides more precise control over connection termination.
    Using *shutdown()*, we can forcibly shut down either or both halves of a bidirectional
    communication stream, regardless of whether there are other open file descriptors
    referring to the socket.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*shutdown()* 系统调用提供了更精确的连接终止控制。通过使用 *shutdown()*，我们可以强制关闭双向通信流的任意一半或两半，无论是否存在其他指向该套接字的打开文件描述符。'
- en: Like *read()* and *write()*, *recv()* and *send()* can be used to perform I/O
    on a socket, but calls provide an extra argument, *flags*, that controls socket-specific
    I/O functionality.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *read()* 和 *write()* 类似，*recv()* 和 *send()* 可用于在套接字上执行 I/O 操作，但这些调用提供了一个额外的参数
    *flags*，用于控制套接字特定的 I/O 功能。
- en: The *sendfile()* system call allows us to efficiently copy the contents of a
    file to a socket. This efficiency is gained because we don’t need to copy the
    file data to and from user memory, as would be required with calls to *read()*
    and *write()*.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '*sendfile()* 系统调用允许我们高效地将文件内容复制到套接字。这种效率是因为我们不需要像调用 *read()* 和 *write()* 时那样，将文件数据复制到用户内存和从用户内存复制回来。'
- en: The *getsockname()* and *getpeername()* system calls retrieve, respectively,
    the local address to which a socket is bound and the address of the peer to which
    that socket is connected.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*getsockname()* 和 *getpeername()* 系统调用分别用于检索套接字绑定的本地地址和与该套接字连接的对端地址。'
- en: We considered some details of the operation of TCP, including TCP states and
    the TCP state transition diagram, and TCP connection establishment and termination.
    As part of this discussion, we saw why the TIME_WAIT state is an important part
    of TCP’s reliability guarantee. Although this state can lead to the “Address already
    in use” error when restarting a server, we later saw that the `SO_REUSEADDR` socket
    option can be used to avoid this error, while nevertheless allowing the TIME_WAIT
    state to serve its intended purpose.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑了 TCP 操作的一些细节，包括 TCP 状态、TCP 状态转换图以及 TCP 连接的建立和终止。在这部分讨论中，我们了解了为什么 TIME_WAIT
    状态是 TCP 可靠性保证的重要组成部分。尽管这个状态在重启服务器时可能导致“地址已在使用”错误，但我们后来发现可以使用 `SO_REUSEADDR` 套接字选项来避免此错误，同时仍然允许
    TIME_WAIT 状态发挥其预期作用。
- en: The *netstat* and *tcpdump* commands are useful tools for monitoring and debugging
    applications that use sockets.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '*netstat* 和 *tcpdump* 命令是监控和调试使用套接字的应用程序的有用工具。'
- en: The *getsockopt()* and *setsockopt()* system calls retrieve and modify options
    affecting the operation of a socket.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*getsockopt()* 和 *setsockopt()* 系统调用用于检索和修改影响套接字操作的选项。'
- en: On Linux, when a new socket is created by *accept()*, it does not inherit the
    listening sockets open file status flags, file descriptor flags, or file descriptor
    attributes related to signal-driven I/O. However, it does inherit the settings
    of socket options. We noted that SUSv3 is silent on these details, which vary
    across implementations.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，当一个新的套接字由 *accept()* 创建时，它不会继承监听套接字的打开文件状态标志、文件描述符标志或与信号驱动 I/O 相关的文件描述符属性。然而，它确实会继承套接字选项的设置。我们注意到
    SUSv3 对这些细节保持沉默，而这些细节在不同的实现中有所不同。
- en: Although UDP doesn’t provide the reliability guarantees of TCP, we saw that
    there are nevertheless reasons why UDP can be preferable for some applications.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 UDP 没有提供 TCP 的可靠性保证，但我们看到仍然有一些原因表明，UDP 在某些应用中可能更为优选。
- en: Finally, we outlined a few advanced features of sockets programming that we
    don’t describe in detail in this book.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们概述了几项套接字编程的高级功能，但在本书中并未详细描述。
- en: Further information
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步信息
- en: Refer to the sources of further information listed in [Further Information](ch59.html#further_information-id81
    "Further Information").
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[进一步信息](ch59.html#further_information-id81 "进一步信息")中列出的其他信息来源。
- en: Exercises
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Suppose that the program in [Example 61-2](ch61.html#a_client_for_the_echo_service
    "Example 61-2. A client for the echo service") (`is_echo_cl.c`) was modified so
    that, instead of using *fork()* to create two processes that operate concurrently,
    it instead used just one process that first copies its standard input to the socket
    and then reads the server’s response. What problem might occur when running this
    client? (Look at [Figure 58-8](ch58.html#connected_tcp_sockets "Figure 58-8. Connected
    TCP sockets"), in [Selecting a UDP datagram size to avoid IP fragmentation](ch58.html#selecting_a_udp_datagram_size_to_avoid_i
    "Selecting a UDP datagram size to avoid IP fragmentation").)
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设 [示例 61-2](ch61.html#a_client_for_the_echo_service "示例 61-2. 回声服务客户端") (`is_echo_cl.c`)
    中的程序被修改，改为使用一个进程，首先将标准输入复制到套接字，然后读取服务器的响应，而不是使用 *fork()* 创建两个并发操作的进程。那么，运行此客户端时可能会出现什么问题？（请查看
    [图 58-8](ch58.html#connected_tcp_sockets "图 58-8. 连接的 TCP 套接字")，[选择一个 UDP 数据报大小以避免
    IP 分片](ch58.html#selecting_a_udp_datagram_size_to_avoid_i "选择一个 UDP 数据报大小以避免 IP
    分片")。）
- en: Implement *pipe()* in terms of *socketpair()*. Use *shutdown()* to ensure that
    the resulting pipe is unidirectional.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *socketpair()* 来实现 *pipe()*。使用 *shutdown()* 确保结果管道是单向的。
- en: Implement a replacement for *sendfile()* using *read()*, *write()*, and *lseek()*.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*read()*、*write()* 和 *lseek()* 实现 *sendfile()* 的替代方案。
- en: Write a program that uses *getsockname()* to show that, if we call *listen()*
    on a TCP socket without first calling *bind()*, the socket is assigned an ephemeral
    port number.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，使用*getsockname()* 来展示，如果我们在 TCP 套接字上调用 *listen()* 而没有先调用 *bind()*，套接字将被分配一个临时端口号。
- en: 'Write a client and a server that permit the client to execute arbitrary shell
    commands on the server host. (If you don’t implement any security mechanism in
    this application, you should ensure that the server is operating under a user
    account where it can do no damage if invoked by malicious users.) The client should
    be executed with two command-line arguments:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个客户端和一个服务器，允许客户端在服务器主机上执行任意的 shell 命令。（如果在这个应用程序中没有实现任何安全机制，应该确保服务器在一个用户帐户下运行，该帐户在受到恶意用户调用时不会造成任何损害。）客户端应该使用两个命令行参数执行：
- en: '[PRE28]''[PRE29]''`'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE28]''[PRE29]''`'
- en: '```'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '```'
- en: 'After connecting to the server, the client sends the given command to the server,
    and then closes its writing half of the socket using *shutdown()*, so that the
    server sees end-of-file. The server should handle each incoming connection in
    a separate child process (i.e., a concurrent design). For each incoming connection,
    the server should read the command from the socket (until end-of-file), and then
    exec a shell to perform the command. Here are a couple hints:'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 连接到服务器后，客户端将给定的命令发送到服务器，然后使用 *shutdown()* 关闭套接字的写入端，这样服务器就会看到文件结束符。服务器应在一个单独的子进程中处理每个传入的连接（即并发设计）。对于每个传入的连接，服务器应从套接字中读取命令（直到文件结束符），然后执行一个
    shell 来执行该命令。以下是几个提示：
- en: See the implementation of *system()* in [Implementing *system()*](ch27.html#implementing_system_open_parenthesis_clo
    "Implementing system()") for an example of how to execute a shell command.
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[实现 *system()*](ch27.html#implementing_system_open_parenthesis_clo "实现 system()")中的
    *system()* 实现示例，以了解如何执行 shell 命令。
- en: By using *dup2()* to duplicate the socket on standard output and standard error,
    the execed command will automatically write to the socket.
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用*dup2()*将套接字复制到标准输出和标准错误，execed命令将自动写入套接字。
- en: '[Out-of-Band Data](ch61.html#out-of-band_data "Out-of-Band Data") noted that
    an alternative to out-of-band data would be to create two socket connections between
    the client and server: one for normal data and one for priority data. Write client
    and server programs that implement this framework. Here are a few hints:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[带外数据](ch61.html#out-of-band_data "Out-of-Band Data")提到，带外数据的替代方法是创建两个客户端和服务器之间的套接字连接：一个用于正常数据，另一个用于优先数据。编写客户端和服务器程序来实现这个框架。以下是一些提示：'
- en: The server needs some way of knowing which two sockets belong to the same client.
    One way to do this is to have the client first create a listening socket using
    an ephemeral port (i.e., binding to port 0). After obtaining the ephemeral port
    number of its listening socket (using *getsockname()*), the client connects its
    “normal” socket to the server’s listening socket and sends a message containing
    the port number of the client’s listening socket. The client then waits for the
    server to use the client’s listening socket to make a connection in the opposite
    direction for the “priority” socket. (The server can obtain the client’s IP address
    during the *accept()* of the normal connection.)
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器需要某种方法来知道哪两个套接字属于同一个客户端。一种方法是让客户端首先使用临时端口（即绑定到端口0）创建一个监听套接字。在获取到其监听套接字的临时端口号（使用*getsockname()*）后，客户端将其“正常”套接字连接到服务器的监听套接字，并发送包含客户端监听套接字端口号的消息。然后，客户端等待服务器使用客户端的监听套接字在相反方向建立连接，以获取“优先级”套接字。（服务器可以在*accept()*正常连接时获取客户端的IP地址。）
- en: Implement some type of security mechanism to prevent a rogue process from trying
    to connect to the client’s listening socket. To do this, the client could send
    a cookie (i.e., some type of unique message) to the server using the normal socket.
    The server would then return this cookie via the priority socket so that the client
    could verify it.
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现某种类型的安全机制，防止恶意进程尝试连接到客户端的监听套接字。为此，客户端可以通过正常套接字向服务器发送一个cookie（即某种唯一消息）。然后，服务器通过优先级套接字返回该cookie，以便客户端进行验证。
- en: In order to experiment with transmitting normal and priority data from the client
    to the server, you will need to code the server to multiplex the input from the
    two sockets using *select()* or *poll()* (described in [I/O Multiplexing](ch63.html#i_solidus_o_multiplexing
    "I/O Multiplexing")).
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了实验从客户端到服务器传输正常数据和优先数据，你需要编写服务器代码，通过*select()*或*poll()*对来自两个套接字的输入进行多路复用（如在[I/O
    多路复用](ch63.html#i_solidus_o_multiplexing "I/O Multiplexing")中所描述的）。
