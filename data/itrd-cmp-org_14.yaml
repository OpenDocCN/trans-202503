- en: '**14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**14**'
- en: INSIDE SUBFUNCTIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**子函数内部**'
- en: '![Image](../images/pg297_Image_276.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg297_Image_276.jpg)'
- en: Good engineering practice generally includes breaking problems down into functionally
    distinct subproblems. In software, this approach leads to programs with many functions,
    each of which solves a subproblem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的工程实践通常包括将问题拆分为功能上不同的子问题。在软件中，这种方法会导致程序包含多个函数，每个函数解决一个子问题。
- en: The main advantage of this *divide and conquer* approach is that it’s usually
    easier to solve a small subproblem than the overall problem. Another advantage
    is that previous solutions to subproblems are often reusable, as we have demonstrated
    by using functions from the C standard library. We can also save development time
    by having several people work on different parts of the overall problem simultaneously.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*分治*方法的主要优点是，通常解决一个小的子问题比解决整个问题要容易。另一个优点是，之前对子问题的解决方案通常是可以重用的，就像我们通过使用 C 标准库中的函数所展示的那样。通过让几个人同时处理整体问题的不同部分，我们也可以节省开发时间。
- en: When breaking down a problem like this, it’s important to coordinate the many
    partial solutions so that they work together to provide a correct overall solution.
    In software, this translates to making sure the data interface between a calling
    function and a called function works correctly. To ensure correct operation of
    the interface, it must be explicitly specified. In this chapter, I’ll show you
    how to do that. I’ll first show you how to place data items in a global location
    so that all the functions in the program can have direct access to them. Then
    I’ll cover restricting the passage of data items as arguments to a function, which
    gives us better control over the data the function works with.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当像这样拆解一个问题时，重要的是协调许多部分解决方案，使它们能够协同工作，提供正确的整体解决方案。在软件中，这意味着确保调用函数和被调用函数之间的数据接口正常工作。为了确保接口的正确操作，必须明确指定接口。在本章中，我将向你展示如何做到这一点。我将首先向你展示如何将数据项放置在全局位置，以便程序中的所有函数都可以直接访问它们。然后，我将介绍如何限制数据项作为函数参数传递，这样我们就可以更好地控制函数处理的数据。
- en: In the previous chapters, you learned how to pass arguments to a function in
    registers. In this chapter, you’ll learn how to store these arguments in memory
    so the registers can be reused inside the called function. You’ll also learn how
    to pass more arguments to a function than can be done with the eight registers
    specified in [Table 11-3](ch11.xhtml#ch11tab3) in [Chapter 11](ch11.xhtml).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，你学会了如何通过寄存器将参数传递给函数。在本章中，你将学习如何将这些参数存储在内存中，以便寄存器可以在被调用函数内部重新使用。你还将学会如何传递比[第11章](ch11.xhtml)中[表11-3](ch11.xhtml#ch11tab3)所指定的八个寄存器更多的参数。
- en: Finally, I’ll discuss in more detail the creation of variables within a function.
    I’ll cover variables that exist only when program flow is in the function, as
    well as variables that stay in memory for the duration of the program but are
    accessible only within their defining function.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我会更详细地讨论函数内部变量的创建。我将涵盖只在程序流程处于该函数时存在的变量，以及在整个程序运行期间保持在内存中的变量，但只能在其定义的函数内访问。
- en: Before we get into the inner workings of functions, however, let’s take a look
    at some of the rules that govern the use of variable names in C.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们深入了解函数的内部工作原理之前，先来看看 C 中一些关于变量名称使用的规则。
- en: '**Scope of Variable Names in C**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**C 中变量名称的作用域**'
- en: '*Scope* refers to the places in our code where a variable’s name is *visible*,
    meaning we can use that name. This is not a book on C, so I won’t cover all the
    rules of where variable names can be used in a program, but I’ll explain enough
    to help you understand the basic concepts.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*作用域*是指我们代码中变量名称*可见*的地方，意味着我们可以使用该名称。这不是一本关于 C 的书，所以我不会涵盖变量名称在程序中可以使用的所有规则，但我会解释足够的内容，帮助你理解基本概念。'
- en: In C, a *declaration* of a variable introduces its name and data type into the
    current scope. A *definition* of a variable is a declaration that also allocates
    memory for the variable. A variable can be defined in only one place in a program,
    but as you’ll see in “Global Variables” on [page 271](ch14.xhtml#ch14lev1sec3),
    it might be declared in more than one scope.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中，*声明*一个变量将其名称和数据类型引入当前作用域。*定义*一个变量是一个声明，同时也为变量分配内存。变量只能在程序中定义一次，但正如你将在[第271页](ch14.xhtml#ch14lev1sec3)的“全局变量”部分看到的，它可以在多个作用域中声明。
- en: 'Variables that are defined inside a function definition are called *local variables*,
    and names declared in a function’s parameter list are called *formal parameters*.
    Both local variables and formal parameters have *function scope*: their scope
    extends from the point of declaration to the end of the function.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义内部定义的变量称为*局部变量*，而在函数参数列表中声明的名称称为*形式参数*。局部变量和形式参数都具有*函数作用域*：它们的作用范围从声明的位置开始，直到函数的结束。
- en: A *block* in C is a group of C statements enclosed in a matched pair of curly
    brackets, `{}`. The scope of variables defined inside a block extends from the
    point of definition to the end of that block, including any enclosed blocks. This
    is *block scope*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中，*块*是由一对匹配的大括号`{}`括起来的 C 语句组。块内部定义的变量的作用范围从定义的位置开始，直到该块的结束，包括任何被包含的块。这就是*块作用域*。
- en: 'A *function prototype* is only a declaration of the function, not its definition.
    It includes the name of the function, the data types of any parameters passed
    to the function, and the return data type. The parameters don’t need to be named
    in the prototype, but doing so provides some documentation within the prototype
    itself. The scope of a parameter name in a prototype declaration is limited to
    its own prototype. This limit allows us to use the same names in different function
    prototypes. For example, the C standard library includes functions for computing
    sine and cosine, whose prototypes are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数原型*仅是函数的声明，而不是定义。它包含函数的名称、传递给函数的参数的数据类型，以及返回数据类型。在原型中，参数不需要命名，但这样做能为原型本身提供一些文档说明。原型声明中参数名称的作用范围仅限于其自身的原型。这一限制允许我们在不同的函数原型中使用相同的名称。例如，C
    标准库中包含计算正弦和余弦的函数，其原型如下：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can use both function prototypes in the same function without having to use
    different names for the parameters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在同一个函数中使用两个函数原型，而无需为参数使用不同的名称。
- en: Before looking at the final kind of scope, file scope, I’ll give you a brief
    overview of the reasons for passing arguments to a function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看最终一种作用域——文件作用域之前，我将简要介绍传递参数给函数的原因。
- en: '**Overview of Passing Arguments**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**传递参数概述**'
- en: Input and output are relative to our point of view. As you read through this
    section, be careful to distinguish between data input from and data output to
    a calling function and data input from and data output to a user of the program.
    In this chapter, we’re looking at inputs to a function that come from and outputs
    that go to other functions in the program. We’ll look at program inputs from and
    outputs to I/O devices in [Chapter 20](ch20.xhtml).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和输出相对于我们的视角。阅读本节时，请小心区分来自调用函数的输入和输出，以及来自程序用户的输入和输出。在本章中，我们讨论的是来自其他函数的输入和输出。我们将在[第
    20 章](ch20.xhtml)中探讨程序输入和输出与 I/O 设备相关的内容。
- en: 'To illustrate the difference, consider this C program statement (from [Listing
    2-1](ch02.xhtml#ch2list1) in [Chapter 2](ch02.xhtml)), which is used to input
    an integer from the keyboard, an I/O device:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明区别，请考虑以下 C 程序语句（来自[清单 2-1](ch02.xhtml#ch2list1)在[第 2 章](ch02.xhtml)中），该语句用于从键盘（一个
    I/O 设备）输入整数：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `scanf` function has one data input from the `main` function: the address
    of the formatting text string, `"%x"`. The `scanf` function reads user data that
    is input from the keyboard and outputs data, an unsigned integer, to the `an_int`
    variable in the `main` function.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`scanf`函数从`main`函数接收一个数据输入：格式化文本字符串`"%x"`的地址。`scanf`函数读取从键盘输入的用户数据，并将数据（一个无符号整数）输出到`main`函数中的`an_int`变量。'
- en: 'Functions can interact with the data in other parts of the program in four
    ways:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过四种方式与程序其他部分的数据交互：
- en: '**Direct** Data that is global to the program can be directly accessed from
    any function in the program.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接** 程序中全局的数据可以从任何函数中直接访问。'
- en: '**Input** The data comes from another part of the program and is used by the
    function, but the original copy is not modified.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入** 数据来自程序的其他部分，并被函数使用，但原始副本未被修改。'
- en: '**Output** The function provides new data to another part of the program.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出** 函数将新数据提供给程序的其他部分。'
- en: '**Update** The function modifies a data item that is held by another part of
    the program. The new value is based on the value before the function was called.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**更新** 函数修改由程序其他部分持有的数据项。新值基于函数调用前的值。'
- en: All four interactions can be performed if the called function also knows the
    location of the data item, but this exposes the original copy of the data and
    allows it to be changed even if it’s intended to be used only as input to the
    called function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被调用的函数也知道数据项的位置，那么可以执行这四种交互，但这会暴露数据的原始副本，并允许其被更改，即使它仅仅是作为输入传递给被调用函数。
- en: We can output data from a function by placing the output in a globally known
    location, such as a register or a globally known address. We can also pass the
    called function the address of the place to store the output. Updates require
    the called function to know the address of the data being updated.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将输出放置在全局已知位置（如寄存器或全局已知地址）来输出数据。我们还可以将存储输出的地址传递给被调用的函数。更新需要被调用的函数知道要更新的数据的地址。
- en: To see how this works, we’ll start by looking at how global variables are created
    and how they are accessed in a subfunction.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到它是如何工作的，我们将从查看全局变量是如何创建的，以及它们在子函数中如何被访问开始。
- en: '**Global Variables**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**全局变量**'
- en: '*Global variables* are defined outside any functions and have *file scope*,
    which means they can be accessed from the point of their definition to the end
    of the file. Global variables can also be accessed from another file by declaring
    them with the `extern` modifier. Using `extern` only introduces the name and data
    type of the variable into the scope of the declaration, without allocating memory
    for it.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*全局变量* 在任何函数外部定义，并具有 *文件作用域*，这意味着它们可以从定义的地方一直访问到文件的末尾。全局变量还可以通过 `extern` 修饰符在另一个文件中访问。使用
    `extern` 仅将变量的名称和数据类型引入声明的作用域，而不会为其分配内存。'
- en: '[Listing 14-1](ch14.xhtml#ch14list1) shows how to define global variables.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-1](ch14.xhtml#ch14list1) 展示了如何定义全局变量。'
- en: '*sum_ints_global.c*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*sum_ints_global.c*'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 14-1: A* main *function that uses three global variables*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-1：一个* 使用三个全局变量的 *主函数*'
- en: Placing the definitions of the variables `x`, `y`, and `z` outside the function
    body makes them global ❶. The first two variables are initialized, but not the
    third. I’ll show you how the compiler treats the difference.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `x`、`y` 和 `z` 的定义放在函数体外使它们成为全局变量❶。前两个变量被初始化，但第三个没有。我将向你展示编译器如何处理这些差异。
- en: This `main` function calls the `add_two` function, which will add `x` and `y`
    and store the sum in `z`. [Listing 14-2](ch14.xhtml#ch14list2) shows the assembly
    language produced by the compiler for this `main` function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `main` 函数调用了 `add_two` 函数，它将 `x` 和 `y` 相加，并将结果存储在 `z` 中。[清单 14-2](ch14.xhtml#ch14list2)
    显示了编译器为此 `main` 函数生成的汇编语言。
- en: '*sum_ints_global.s*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*sum_ints_global.s*'
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 14-2: The compiler-generated assembly language for the function in
    [Listing 14-1](ch14.xhtml#ch14list1)*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-2：在[清单 14-1](ch14.xhtml#ch14list1)中使用的函数的编译器生成的汇编语言*'
- en: I don’t know why the compiler added the first `.text` directive ❶, but it’s
    not needed. Its effect is immediately overridden by the `.data` assembler directive,
    which switches us to the data segment ❷.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道为什么编译器添加了第一个 `.text` 指令❶，但它并不需要。它的效果立即被 `.data` 汇编指令覆盖，这将我们切换到数据段❷。
- en: The `.word` directive allocates a word (4 bytes) of memory and initializes it
    to the value of the argument, which is the integer 123 here ❸. The `.bss` assembler
    directive then switches us to a *block starting symbol* section, which will be
    located in the data segment when the program is loaded into memory for execution
    ❹. Each label defined in a `.bss` section will name the start of an uninitialized
    block of memory. Only the size of each labeled block is stored in the program’s
    executable file, thus making the file smaller.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`.word` 指令分配一个字（4 字节）的内存，并将其初始化为参数的值，这里是整数 123 ❸。然后，`.bss` 汇编指令将我们切换到 *块开始符号*
    区段，当程序加载到内存中执行时，该区段将位于数据段中❹。在 `.bss` 区段中定义的每个标签都将表示未初始化内存块的起始位置。程序的可执行文件中仅存储每个标记块的大小，从而使文件变得更小。'
- en: The Linux operating system initializes all the bytes in memory in a `.bss` section
    to 0 when the program is loaded, but your algorithm should not depend on the variables
    there being 0 unless they are explicitly set to 0 in your source code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 操作系统在加载程序时会将内存中 `.bss` 区段的所有字节初始化为 0，但除非在源代码中显式将其设置为 0，否则你的算法不应依赖于其中的变量为
    0。
- en: The `.size` assembler directive associates a label with a number of bytes in
    its block ❺. The `z` label is for a 4-byte variable in this program. Although
    `z` is not initialized in our C code, and the `.bss` segment will be set to 0
    when the program is loaded, the compiler has used the `.zero` assembler directive,
    which specifies 4 bytes of memory, each set to 0 here ❻. The `.skip` directive
    would have the same effect as a `.zero` directive in a `.bss` section. Since we
    are in a `.bss` segment, the assembler does not store the 4 zero bytes in the
    object file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`.size`汇编指令将一个标签与其块中的字节数相关联❺。`z`标签表示程序中的一个4字节变量。虽然`z`在我们的C代码中没有初始化，并且`.bss`段在程序加载时会被设置为0，编译器仍然使用了`.zero`汇编指令，指定了4字节内存，每个字节在此处都设置为0❻。`.skip`指令在`.bss`段中会产生与`.zero`相同的效果。由于我们处于`.bss`段，汇编器不会在目标文件中存储这4个零字节。'
- en: The variables are defined in this file, so the compiler uses the `adrp`/`add`
    two-instruction sequence to load their addresses ❼.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量在此文件中定义，因此编译器使用`adrp`/`add`两条指令序列来加载它们的地址❼。
- en: Next, let’s look at `add_two`. First, we need a header file for the function.
    This is shown in [Listing 14-3](ch14.xhtml#ch14list3).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看`add_two`。首先，我们需要为该函数准备一个头文件。这在[清单14-3](ch14.xhtml#ch14list3)中有所展示。
- en: '*add_two_global.h*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_two_global.h*'
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 14-3: The header file for the* add_two *function using global variables.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-3：使用全局变量的* add_two *函数的头文件*'
- en: Header files are used to declare a function prototype, which can be declared
    only once in a C source code file ❸. A header file can include other header files,
    some of which could include the original header file, leading to a function prototype
    being declared more than once. To guard against this, we define an identifier
    that is a stylized version of the header file’s name ❷.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件用于声明函数原型，这在C源代码文件中只能声明一次❸。一个头文件可以包含其他头文件，其中一些可能会包含原始头文件，从而导致函数原型被多次声明。为了避免这种情况，我们定义了一个标识符，它是头文件名称的风格化版本❷。
- en: We start with an `#ifndef` assembler directive to check if this identifier has
    already been defined ❶. If not, the contents of the file up to the end of the
    `#endif` directive are included, defining the filename identifier and declaring
    the function prototype. The check for the filename identifier in any subsequent
    inclusions of this header file will then show that the identifier has been defined,
    so the preprocessor will skip down to the `#endif` and avoid declaring the function
    prototype again.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`#ifndef`汇编指令开始，检查此标识符是否已经定义❶。如果没有，文件的内容会一直包括到`#endif`指令的末尾，定义文件名标识符并声明函数原型。之后在任何进一步包含该头文件时，检查文件名标识符会显示该标识符已经定义，因此预处理器会跳到`#endif`并避免再次声明函数原型。
- en: '[Listing 14-4](ch14.xhtml#ch14list4) shows the definition of the `add_two`
    function using global variables.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-4](ch14.xhtml#ch14list4)显示了使用全局变量的`add_two`函数的定义。'
- en: '*add_two_global.c*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_two_global.c*'
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 14-4: The* add_two *function using global variables*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-4：使用全局变量的* add_two *函数*'
- en: The header file for a function should be included in the file where the function
    is defined to make sure the function prototype in the header file matches the
    definition ❶. The global variables are defined in only one place, but they need
    to be declared in any other file that uses them ❷.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的头文件应该包含在定义该函数的文件中，以确保头文件中的函数原型与定义匹配❶。全局变量仅在一个地方定义，但在使用它们的任何其他文件中都需要声明❷。
- en: '[Listing 14-5](ch14.xhtml#ch14list5) shows the assembly language generated
    by the compiler for the `add_two` function.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-5](ch14.xhtml#ch14list5)显示了编译器为`add_two`函数生成的汇编语言。'
- en: '*add_two_global.s*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_two_global.s*'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 14-5: The compiler-generated assembly language for the function in
    [Listing 14-4](ch14.xhtml#ch14list4)*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-5：编译器为[清单14-4](ch14.xhtml#ch14list4)中的函数生成的汇编语言*'
- en: The `add_two` function declares the `x`, `y`, and `z` variables with an `extern`
    storage class specifier so it can access them, but it needs to use a different
    technique to load the addresses because they are defined in another file. The
    loader stores the addresses of the global variables in the global offset table
    (GOT), introduced in “The Linker” on [page 239](ch12.xhtml#ch12lev2sec7), when
    the program is loaded into memory for execution. The `:got:` operand modifier
    tells the loader to use the GOT containing the address of the variable when filling
    in the page offset from the `adrp` instruction ❶.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_two`函数声明了`x`、`y`和`z`变量，并使用`extern`存储类说明符以便它可以访问这些变量，但它需要使用另一种技术来加载这些变量的地址，因为这些变量在另一个文件中定义。加载器将全局变量的地址存储在全局偏移表（GOT）中，该表在程序加载到内存中执行时被引入，参见《链接器》章节中的[第239页](ch12.xhtml#ch12lev2sec7)。`:got:`操作数修饰符告诉加载器，在填充`adrp`指令❶中的页面偏移时，使用包含变量地址的GOT。'
- en: The `ldr` instruction here is using the page address of the GOT, in `x0`, for
    its base address ❷. The `:got_lo12:` operand modifier tells the loader to use
    the low-order 12 bits of the offset to where the variable’s address is stored
    in the GOT, thus overwriting the page address of the GOT with the variable’s address
    in `x0`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`ldr`指令使用了`x0`中的GOT页面地址作为其基址❷。`:got_lo12:`操作数修饰符告诉加载器使用偏移量的低12位来获取变量地址存储在GOT中的位置，从而用`x0`中变量的地址覆盖GOT的页面地址。
- en: '[Listing 14-5](ch14.xhtml#ch14list5) also contains a new instruction, the `nop`
    (pronounced “no-op”) ❸. It has no effect on the algorithm. The manual says it’s
    used for instruction alignment purposes:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-5](ch14.xhtml#ch14list5)还包含了一条新指令`nop`（读作“no-op”）❸。它对算法没有任何影响。手册中提到它用于指令对齐的目的：'
- en: nop**—No operation**
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: nop**—无操作**
- en: '`nop` adds 4 to the program counter with no other effect.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`nop`对程序计数器加4，且没有其他效果。'
- en: Although global variables are simple to work with in small programs, managing
    them is unwieldy in large programs. You need to keep track of exactly what each
    function in the program is doing with the global variables. Managing variables
    is much easier if you define them within a function and pass only what is needed
    to each subfunction. In the next section, I’ll show you how to maintain control
    over what gets passed to and from a subfunction.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在小型程序中全局变量使用起来比较简单，但在大型程序中管理它们非常笨重。你需要精确地追踪程序中每个函数如何操作全局变量。如果在函数内定义变量，并且仅将需要的内容传递给每个子函数，那么管理变量将变得容易得多。在接下来的章节中，我将向你展示如何控制传递给和从子函数返回的内容。
- en: '**Explicitly Passing Arguments**'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**显式传递参数**'
- en: When we restrict each function to using only those variables it needs, it’s
    much easier to isolate the inner workings of a function from other functions.
    This is a principle called *information hiding*. It means that you, the programmer,
    need to deal with only those variables and constants that a subfunction needs
    to do its specific job. Of course, most subfunctions will need to interact with
    some of the variables in their calling functions in one way or another. In this
    section, we’ll look at how a function uses the arguments explicitly passed to
    it to accept input, produce output, or update a variable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们限制每个函数只使用它所需要的变量时，隔离函数的内部工作与其他函数之间的关系变得更加容易。这是一个名为*信息隐藏*的原则。它意味着你，作为程序员，只需处理子函数完成其特定任务所需要的那些变量和常量。当然，大多数子函数都需要以某种方式与其调用函数中的一些变量进行交互。在本节中，我们将讨论一个函数如何使用显式传递给它的参数来接收输入、产生输出或更新变量。
- en: When a value serves only as input to the called function, we can pass a copy
    of the value to the called function. This is called *passing by value*. Passing
    by value prevents the called function from changing the value in the calling function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值仅作为输入传递给被调用函数时，我们可以将该值的副本传递给被调用函数。这被称为*按值传递*。按值传递可以防止被调用函数改变调用函数中的值。
- en: Receiving output from the called function is a bit more complex. One way to
    accomplish this is to use a *return value*, which in our environment is placed
    in the `w0` register. Using the `w0` register assumes the return value is an `int`.
    This technique is used in most of the example programs in this book. The `main`
    function almost always returns a 0 to the function in the operating system that
    called it. There are other rules for returning larger values, which we won’t go
    into in this book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从被调用函数接收输出有点复杂。实现这一点的一种方法是使用*返回值*，在我们的环境中，返回值被放置在`w0`寄存器中。使用`w0`寄存器假定返回值是一个`int`。这种技术在本书的大多数示例程序中都有使用。`main`函数几乎总是返回0给调用它的操作系统中的函数。对于返回较大值还有其他规则，但我们在本书中不涉及。
- en: The other techniques for the calling function to receive an output from the
    called function require that the calling function pass the called function the
    address of the place to store the output. This can be implemented in higher-level
    languages as either *pass by pointer* or *pass by reference*. The difference is
    that with pass by pointer, the program can change the pointer to point to another
    object, while with pass by reference, the program cannot change the pointer. C
    and C++ both support pass by pointer, but only C++ supports pass by reference.
    These are the same at the assembly language level; the address of the place to
    store the output is passed to the called function. The difference is enforced
    by the high-level language.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数接收被调用函数输出的其他技术要求调用函数传递给被调用函数一个用于存储输出的地址。这可以在高级语言中实现为*通过指针传递*或*通过引用传递*。它们的区别在于，使用指针传递时，程序可以改变指针指向另一个对象，而通过引用传递时，程序无法改变指针。C语言和C++都支持通过指针传递，但只有C++支持通过引用传递。这些在汇编语言级别是相同的；存储输出的地址会传递给被调用函数。区别由高级语言强制执行。
- en: Next, you’ll learn how C controls access to its local variables.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习C语言如何控制对其局部变量的访问。
- en: '***In C***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在C语言中***'
- en: In this section, I’ll write the same program as in [Listings 14-1](ch14.xhtml#ch14list1),
    [14-3](ch14.xhtml#ch14list3), and [14-4](ch14.xhtml#ch14list4), but this time
    I’ll define the variables as local variables in the `main` function and pass them
    as arguments to the subfunction. [Listing 14-6](ch14.xhtml#ch14list6) shows the
    new version of the `main` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将编写与[清单14-1](ch14.xhtml#ch14list1)、[14-3](ch14.xhtml#ch14list3)和[14-4](ch14.xhtml#ch14list4)中相同的程序，但这次我将把变量定义为`main`函数中的局部变量，并将它们作为参数传递给子函数。[清单14-6](ch14.xhtml#ch14list6)展示了新的`main`函数版本。
- en: '*sum_ints.c*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*sum_ints.c*'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 14-6: A* main *function that uses three local variables*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-6：一个* 使用三个局部变量的 *main* 函数 *'
- en: Defining the variables inside the body of the function ❶ makes them visible
    only to this function. The `add_two` function will store its result at the address
    we pass in as the first argument. We use the C address operator, `&`, to get the
    address of the `z` variable, giving `&z` ❷. The values of the `x` and `y` variables
    are inputs to the `add_two` function, so we pass copies of these variables.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内定义变量❶使得这些变量仅对该函数可见。`add_two`函数将在我们作为第一个参数传递的地址处存储其结果。我们使用C语言的地址操作符`&`来获取`z`变量的地址，从而得到`&z`❷。`x`和`y`变量的值是`add_two`函数的输入，因此我们传递这些变量的副本。
- en: '[Listing 14-7](ch14.xhtml#ch14list7) shows the header file for the `add_two`
    function.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-7](ch14.xhtml#ch14list7)展示了`add_two`函数的头文件。'
- en: '*add_two.h*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_two.h*'
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 14-7: The header file for the* add_two *function using local variables*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-7：使用局部变量的* add_two *函数的头文件*'
- en: '[Listing 14-8](ch14.xhtml#ch14list8) shows the definition of the `add_two`
    function.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-8](ch14.xhtml#ch14list8)展示了`add_two`函数的定义。'
- en: '*add_two.c*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_two.c*'
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 14-8: The* add_two *function using local variables*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-8：使用局部变量的* add_two *函数*'
- en: The first parameter in the argument list, `a`, is a pointer to an `int`. This
    means that `a` holds the address where we need to store the value of `sum`. To
    dereference `a`, we use the C *dereference operator*, `*`, giving `*a` ❶. This
    stores the result of the computation at the address passed in `a`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表中的第一个参数`a`是一个指向`int`的指针。这意味着`a`保存了我们需要存储`sum`值的地址。为了解除引用`a`，我们使用C语言的*解引用操作符*`*`，得到`*a`❶。这将在`a`传递的地址处存储计算结果。
- en: '***In Assembly Language***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在汇编语言中***'
- en: '[Listing 14-9](ch14.xhtml#ch14list9) shows the assembly language generated
    by the compiler for the `main` function in [Listing 14-6](ch14.xhtml#ch14list6).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-9](ch14.xhtml#ch14list9)展示了编译器为[清单14-6](ch14.xhtml#ch14list6)中的`main`函数生成的汇编语言。'
- en: '*sum_ints.s*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*sum_ints.s*'
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 14-9: The compiler-generated assembly language for the function in
    [Listing 14-6](ch14.xhtml#ch14list6)*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-9：编译器生成的函数汇编语言，[清单 14-6](ch14.xhtml#ch14list6)中的函数*'
- en: All three variables are automatic local variables, so the compiler allocates
    space for them in the stack frame ❶. Initialized automatic local variables are
    newly created each time the function is called, so they need to be actively initialized
    ❷.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个变量都是自动局部变量，因此编译器会在堆栈帧中为它们分配空间 ❶。初始化的自动局部变量在每次调用函数时都会重新创建，因此需要主动进行初始化 ❷。
- en: We pass the address of our `z` variable to the `add_two` function so it can
    store its output there ❸, and we send copies of the values in the `x` and `y`
    variables as inputs to the function ❹.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`z`变量的地址传递给`add_two`函数，这样它可以将输出存储在该地址 ❸，同时我们将`x`和`y`变量的值传递给函数作为输入 ❹。
- en: '[Listing 14-10](ch14.xhtml#ch14list10) shows the compiler-generated assembly
    language for the `add_two` function.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-10](ch14.xhtml#ch14list10)展示了编译器生成的`add_two`函数的汇编语言。'
- en: '*add_two.s*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_two.s*'
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 14-10: The compiler-generated assembly language for the function in
    [Listing 14-8](ch14.xhtml#ch14list8)*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-10：编译器生成的函数汇编语言，[清单 14-8](ch14.xhtml#ch14list8)中的函数*'
- en: The first thing you might notice about this function is that it does not save
    the contents of the link register, `lr`, and frame pointer, `fp` ❶. These two
    addresses make up the *frame record*. The address in `lr` provides the link back
    to the place where this function was called, while `fp` provides a link back to
    the frame record of the calling function. This chain of frame records can be useful
    in certain error situations, but I won’t get into the details in this book.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到这个函数的第一件事是，它没有保存链接寄存器`lr`和帧指针`fp`的内容 ❶。这两个地址组成了*帧记录*。`lr`中的地址提供了回到调用此函数的地方的链接，而`fp`提供了回到调用函数的帧记录的链接。在某些错误情况下，帧记录链可能会很有用，但我在本书中不会深入讨论这个细节。
- en: The AArch64 procedure call standard states that a small function that doesn’t
    call a function does not need a frame record, which explains why the compiler
    has omitted it. A function that does not call any functions is often called a
    *leaf function*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: AArch64过程调用标准规定，若一个小函数不调用其他函数，则不需要帧记录，这解释了编译器为什么省略了它。一个不调用任何函数的函数通常被称为*叶函数*。
- en: This function simply allocates a 32-byte stack frame, where it stores the three
    items that were passed to it ❷. You can probably tell this is not needed in this
    very simple function, but it might be in more complex functions. [Figure 14-1](ch14.xhtml#ch14fig1)
    gives a pictorial view of `add_two`’s stack frame.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数简单地分配了一个32字节的堆栈帧，并在其中存储传递给它的三个项 ❷。你可能会觉得在这个非常简单的函数中并不需要这么做，但在更复杂的函数中可能是必须的。[图
    14-1](ch14.xhtml#ch14fig1)给出了`add_two`堆栈帧的图示。
- en: '![Image](../images/pg308_Image_277.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg308_Image_277.jpg)'
- en: '*Figure 14-1: The stack frame for the* add_two *function in [Listing 14-10](ch14.xhtml#ch14list10)*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-1：* add_two *函数的堆栈帧，见[清单 14-10](ch14.xhtml#ch14list10)*'
- en: The values at `c` and `b` are inputs to this function, and `a` is the address
    where the output from the function will be stored.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`c`和`b`的值是此函数的输入，`a`是存储函数输出的地址。'
- en: '[Listing 14-11](ch14.xhtml#ch14list11) shows how I would probably write the
    `add_two` function in assembly language.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-11](ch14.xhtml#ch14list11)展示了我可能如何在汇编语言中编写`add_two`函数。'
- en: '*add_two.s*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_two.s*'
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 14-11: The* add_two *function written in assembly language*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-11：用汇编语言编写的* add_two *函数*'
- en: A stack frame is not required for this small leaf function, but I have created
    one here to show how to save registers for the calling function so we can use
    them as local variables. We first need to specify a location in the stack frame
    ❶. This leads to the stack frame shown in [Figure 14-2](ch14.xhtml#ch14fig2).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个小的叶函数，堆栈帧并不是必须的，但我在这里创建了一个堆栈帧，以展示如何为调用函数保存寄存器，以便将它们作为局部变量使用。我们首先需要在堆栈帧中指定一个位置
    ❶。这导致了[图 14-2](ch14.xhtml#ch14fig2)所示的堆栈帧。
- en: '![Image](../images/pg309_Image_278.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg309_Image_278.jpg)'
- en: '*Figure 14-2: The stack frame for the* add_two *function in [Listing 14-11](ch14.xhtml#ch14list11)*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：* add_two *函数的堆栈帧，见[清单 14-11](ch14.xhtml#ch14list11)*'
- en: Although the algorithm uses only the low-order word of the `x19` register, we
    need to save the entire 64 bits because our algorithm might change the high-order
    32 bits ❷. In fact, the `add` instruction here will zero the high-order 32 bits
    of `x19` ❸. Don’t forget that we need to restore the saved registers before undoing
    our stack frame ❹.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管算法只使用`x19`寄存器的低位字，我们需要保存整个64位，因为我们的算法可能会改变`x19`的高位32位❷。事实上，这里的`add`指令将把`x19`的高位32位清零❸。不要忘记，在撤销栈帧之前，我们需要恢复保存的寄存器❹。
- en: Comparing the stack frame for my assembly language version of the `add_two`
    function with the stack frame created by the compiler for the C version in [Figure
    14-1](ch14.xhtml#ch14fig1), notice that I’ve created a frame record at the top
    of my stack frame. I’ve then saved the `x19` and `x20` registers so I can use
    them for the computations in the function. If I later change my assembly language
    `add_two` function such that it calls another function, I don’t need to change
    its stack frame because it already has a frame record, and the standard says that
    the called function must preserve the values in the `x19` and `20` registers for
    the calling function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将我汇编语言版本的`add_two`函数的栈帧与编译器为C版本在[图14-1](ch14.xhtml#ch14fig1)中创建的栈帧进行比较，可以注意到我在栈帧的顶部创建了一个帧记录。然后我保存了`x19`和`x20`寄存器，以便在函数中进行计算。如果我后来修改我的汇编语言`add_two`函数，使其调用另一个函数，我不需要更改它的栈帧，因为它已经有了一个帧记录，而标准规定，调用的函数必须为调用函数保存`x19`和`x20`寄存器中的值。
- en: In the next section, you’ll see how the stack comes to our rescue when we want
    to pass more than the eight arguments we can pass in registers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将看到当我们想传递超过八个可以通过寄存器传递的参数时，栈是如何提供帮助的。
- en: '***With More Than Eight Arguments***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***传递超过八个参数***'
- en: Most functions take fewer than the eight arguments we can pass in registers,
    but sometimes a calling function needs to pass more than eight arguments to another
    function. In these cases, the arguments beyond the first eight are passed on the
    call stack. They are placed on the stack before the call to the function. I’ll
    use the program in [Listings 14-12](ch14.xhtml#ch14list12), [14-14](ch14.xhtml#ch14list14),
    and [14-15](ch14.xhtml#ch14list15) to show you how this works.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数传递的参数少于我们可以通过寄存器传递的八个参数，但有时调用函数需要向另一个函数传递超过八个参数。在这种情况下，超过前八个的参数会通过调用栈传递。它们会在调用函数之前被放置到栈上。我将使用[清单14-12](ch14.xhtml#ch14list12)、[14-14](ch14.xhtml#ch14list14)和[14-15](ch14.xhtml#ch14list15)中的程序来向你展示这一过程是如何工作的。
- en: '*sum11ints.c*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*sum11ints.c*'
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 14-12: A program passing more than eight arguments to a subfunction*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-12：一个程序向子函数传递超过八个参数*'
- en: This `main` function creates 11 integer variables and initializes them to the
    values 1 through 11\. It then calls the `add_eleven` function to compute the sum
    of the 11 numbers and prints the result.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`main`函数创建了11个整数变量，并将它们初始化为1到11的值。然后它调用`add_eleven`函数来计算这11个数字的和，并打印结果。
- en: '[Listing 14-13](ch14.xhtml#ch14list13) shows the assembly language generated
    by the compiler for the `main` function in [Listing 14-12](ch14.xhtml#ch14list12).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单14-13](ch14.xhtml#ch14list13)展示了编译器为[清单14-12](ch14.xhtml#ch14list12)中的`main`函数生成的汇编语言。'
- en: '*sum11ints.s*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*sum11ints.s*'
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 14-13: The compiler-generated assembly language for the function in
    [Listing 14-12](ch14.xhtml#ch14list12)*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-13：编译器为[清单14-12](ch14.xhtml#ch14list12)中的函数生成的汇编语言*'
- en: When this function creates its stack frame, it allocates memory on the stack
    for the additional arguments it needs to pass on the stack ❶. Before calling the
    `add_eleven` function, it works from right to left in the argument list. Since
    it can pass only eight arguments in registers, it needs to store the three excess
    arguments on the stack ❷. These arguments are stored at the top of our stack frame,
    where the AArch64 procedure call standard specifies the called function should
    expect them. [Figure 14-3](ch14.xhtml#ch14fig3) shows the state of the stack at
    this point.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个函数创建它的栈帧时，它在栈上为需要传递的额外参数分配内存❶。在调用`add_eleven`函数之前，它会从右到左处理参数列表。由于它只能通过寄存器传递八个参数，因此需要将三个多余的参数存储到栈上❷。这些参数存储在栈帧的顶部，这是AArch64程序调用标准所指定的，调用的函数应当预期这些参数。[图14-3](ch14.xhtml#ch14fig3)显示了此时栈的状态。
- en: '![Image](../images/pg312_Image_279.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg312_Image_279.jpg)'
- en: '*Figure 14-3: The stack frame for the* main *function in [Listing 14-12](ch14.xhtml#ch14list12),
    just before calling* add_eleven'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：在调用`add_eleven`之前，[清单14-12](ch14.xhtml#ch14list12)中`main`函数的栈帧*'
- en: '[Figure 14-3](ch14.xhtml#ch14fig3) shows that the stack pointer is pointing
    to the arguments that are being passed to `add_eleven` on the stack. The names
    in the arguments area in this figure, `nine`, `ten`, and `eleven`, are the corresponding
    parameter names used by the `add_eleven` function. The procedure call standard
    allows both `main` and `add_eleven` to access stack memory in the arguments area,
    but argument passing can only take place from caller to callee—that is, from `main`
    to `add_eleven` in this example.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-3](ch14.xhtml#ch14fig3)显示栈指针指向传递给`add_eleven`函数的参数。这张图中参数区域的名称`nine`、`ten`和`eleven`是`add_eleven`函数使用的对应参数名称。过程调用标准允许`main`和`add_eleven`都可以访问栈中参数区域的内存，但参数传递只能从调用者到被调用者——也就是在这个例子中从`main`到`add_eleven`。'
- en: Although we’re passing 4-byte `int`s, the AArch64 procedure call standard states
    that we must use 8 bytes for each stack argument, the same number of bytes as
    a register argument. Following this rule ensures you can use your assembly language
    functions with C functions. In [Figure 14-3](ch14.xhtml#ch14fig3), the compiler
    has stored the ninth, tenth, and eleventh arguments in the low-order 4 bytes of
    each argument slot on the stack. (Don’t forget that our memory order is little-endian.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们传递的是4字节的`int`类型，但AArch64过程调用标准规定，我们必须为每个栈参数使用8字节，与寄存器参数相同。遵循这个规则可以确保你可以将汇编语言函数与C语言函数一起使用。在[图
    14-3](ch14.xhtml#ch14fig3)中，编译器将第九、第十和第十一参数存储在栈中每个参数槽的低4字节中。（不要忘记我们的内存顺序是小端序。）
- en: With our stack frame set up for calling the `add_eleven` function, we now store
    the remaining eight arguments in registers ❸.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在为调用`add_eleven`函数设置好栈帧后，我们将剩余的八个参数存储在寄存器中❸。
- en: Let’s look at how the `add_eleven` function retrieves the arguments from the
    stack. I’ll start with the header file for the function, in [Listing 14-14](ch14.xhtml#ch14list14).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`add_eleven`函数是如何从栈中获取参数的。我将从该函数的头文件开始，见[清单 14-14](ch14.xhtml#ch14list14)。
- en: '*add_eleven.h*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_eleven.h*'
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 14-14: The header file for the* add_eleven *function*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-14：`add_eleven`函数的头文件*'
- en: The `add_eleven` function is defined in [Listing 14-15](ch14.xhtml#ch14list15).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_eleven`函数定义在[清单 14-15](ch14.xhtml#ch14list15)中。'
- en: '*add_eleven.c*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_eleven.c*'
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 14-15: A function that receives more than eight arguments from a calling
    function*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-15：一个从调用函数接收超过八个参数的函数*'
- en: '[Listing 14-16](ch14.xhtml#ch14list16) shows the assembly language generated
    by the compiler for the `add_eleven` function in [Listing 14-15](ch14.xhtml#ch14list15).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-16](ch14.xhtml#ch14list16)显示了编译器为[清单 14-15](ch14.xhtml#ch14list15)中的`add_eleven`函数生成的汇编语言。'
- en: '*add_eleven.s*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_eleven.s*'
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 14-16: The compiler-generated assembly language for the function in
    [Listing 14-15](ch14.xhtml#ch14list15)*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-16：编译器为[清单 14-15](ch14.xhtml#ch14list15)中的函数生成的汇编语言*'
- en: After creating a stack frame, the compiler saves the arguments that were passed
    in registers, because the call to another function might change their contents
    ❶. It does this near the beginning of the function so it doesn’t have to keep
    track of which ones have been saved when compiling the C statements in the function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建栈帧后，编译器会保存通过寄存器传递的参数，因为调用另一个函数可能会改变它们的内容❶。它会在函数开始时进行此操作，以便在编译函数中的C语句时无需跟踪哪些参数已经被保存。
- en: After loading each of these eight arguments from the stack and summing them,
    the function adds the remaining three arguments that are in the calling function’s
    stack frame ❷.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在从栈中加载这八个参数并对其求和后，函数将添加在调用函数的栈帧中的剩余三个参数❷。
- en: '[Figure 14-4](ch14.xhtml#ch14fig4) shows the stack frames belonging to the
    `main` and `add_eleven` functions.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-4](ch14.xhtml#ch14fig4)显示了`main`和`add_eleven`函数的栈帧。'
- en: '![Image](../images/pg315_Image_280.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg315_Image_280.jpg)'
- en: '*Figure 14-4: The stack frames after the* add_eleven *function has been called
    and has created its stack frame*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：调用`add_eleven`函数并创建其栈帧后的栈帧*'
- en: I mentioned on [page 279](ch14.xhtml#page_279) that the frame pointer points
    to the frame record, which points to the calling function’s frame record, and
    so forth. [Figure 14-4](ch14.xhtml#ch14fig4) shows this chain back to `main`’s
    frame record.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第279页](ch14.xhtml#page_279)中提到，帧指针指向帧记录，帧记录指向调用函数的帧记录，依此类推。[图 14-4](ch14.xhtml#ch14fig4)展示了这条链条一直回溯到`main`的帧记录。
- en: I’ve shown only the offsets from `sp` that should be used by `add_eleven`. This
    function knows that `sp` was pointing to three 32-bit arguments before it subtracted
    64 from `sp`, so the first argument on the stack is now +64 from `sp`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我只展示了`add_eleven`应使用的`sp`偏移量。这个函数知道在从`sp`减去64之前，`sp`指向三个32位的参数，因此栈上的第一个参数现在距离`sp`是+64。
- en: The procedure call standard allows the `add_eleven` function to store and load
    items to and from the area labeled “ `add_eleven` only” in [Figure 14-4](ch14.xhtml#ch14fig4).
    It allows the `add_eleven` function to use items in the stack area labeled “Both,”
    but it does not allow a called function to pass items back to the calling function
    in this area. The `add_eleven` function is not allowed to access the stack area
    labeled “`main` only.”
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 程序调用标准允许`add_eleven`函数将项存储到并从[图 14-4](ch14.xhtml#ch14fig4)中标记为“`add_eleven`
    only”的区域加载数据。它允许`add_eleven`函数使用标记为“Both”的栈区域中的项，但不允许被调用函数在该区域将项传递回调用函数。`add_eleven`函数不允许访问标记为“`main`
    only”的栈区域。
- en: The `main` function can store and load items to and from the area labeled “`main`
    only” in [Figure 14-4](ch14.xhtml#ch14fig4), but it is allowed only to store items
    to the stack area labeled “Both.”
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数可以将项存储到并从[图 14-4](ch14.xhtml#ch14fig4)中标记为“`main` only”的区域加载数据，但它仅被允许将项存储到标记为“Both”的栈区域。'
- en: '***Stack Frame Discipline***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***栈帧规则***'
- en: It’s essential that you follow the register usage and argument passing disciplines
    precisely when writing in assembly language. Any deviation can cause errors that
    are difficult to debug.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写汇编语言时，必须严格遵守寄存器使用和参数传递规则。任何偏离都会导致难以调试的错误。
- en: '[Figure 14-5](ch14.xhtml#ch14fig5) shows the overall pattern for a stack frame.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-5](ch14.xhtml#ch14fig5)展示了栈帧的整体结构。'
- en: '![Image](../images/pg316_Image_281.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg316_Image_281.jpg)'
- en: '*Figure 14-5: A stack frame*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：一个栈帧*'
- en: A stack frame doesn’t always include all the parts in [Figure 14-5](ch14.xhtml#ch14fig5).
    If the function never passes more than eight arguments to the functions it calls,
    the top box doesn’t exist. In this case, `sp` and `fp` both point to the frame
    record.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 栈帧并不总是包含[图 14-5](ch14.xhtml#ch14fig5)中的所有部分。如果函数从未向它调用的函数传递超过八个参数，则顶部框将不存在。在这种情况下，`sp`和`fp`都指向帧记录。
- en: Some functions may not have any local variables or saved register contents.
    If it’s a leaf function, we don’t even need a frame record.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数可能没有任何局部变量或保存的寄存器内容。如果它是一个叶函数，我们甚至不需要一个栈帧记录。
- en: If no more than eight arguments are passed to the function, then the bottom
    box in this diagram does not exist. The bottom box is the only area of the stack
    frame that both the current function and its calling function have access to.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数传递的参数不超过八个，那么图中的底部框将不存在。底部框是栈帧中唯一一个当前函数和调用函数都能访问的区域。
- en: Let’s write the `sum11ints` program in assembly language. Unless it’s a very
    simple function, I start my designs by drawing a diagram of the stack frame for
    each function, similar to [Figures 14-3](ch14.xhtml#ch14fig3) and [14-4](ch14.xhtml#ch14fig4).
    Then I use `.equ` directives to give symbolic names to the locations on the stack
    that I need to access in my code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用汇编语言编写`sum11ints`程序。除非是非常简单的函数，否则我通常从为每个函数绘制栈帧图开始，类似于[图 14-3](ch14.xhtml#ch14fig3)和[图
    14-4](ch14.xhtml#ch14fig4)。然后，我使用`.equ`指令为栈上需要访问的每个位置赋予符号名称。
- en: '[Listing 14-17](ch14.xhtml#ch14list17) shows how we can do this for the `main`
    function in our `sum11ints` program.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 14-17](ch14.xhtml#ch14list17)展示了我们如何为`sum11ints`程序中的`main`函数进行此操作。'
- en: '*sum11ints.s*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*sum11ints.s*'
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 14-17: The* sum11ints main *function written in assembly language*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14-17：用汇编语言编写的* sum11ints main *函数*'
- en: The list of `.equ` directives gives a good view of what our stack frame looks
    like ❶. Using the symbolic names for our variables makes it easy to read the assembly
    language code, because we don’t have to remember the numerical offset of each
    item on the stack ❸.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`.equ`指令的列表很好地展示了我们的栈帧是什么样子❶。使用符号名称来表示我们的变量，使得汇编语言代码更加易读，因为我们不必记住栈上每个项的数值偏移❸。'
- en: The algorithm for the function prologue needs to take into account that `main`
    will be passing arguments on the stack. We start by allocating space for our stack
    frame ❷. Then, we create the frame record after the area for passing arguments
    on the stack. This is easy once we have created our `.equ` view of the stack frame.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 函数序言的算法需要考虑到`main`将通过栈传递参数。我们首先为栈帧分配空间 ❷。然后，在传递参数的区域之后创建栈帧记录。一旦我们创建了栈帧的`.equ`视图，这个过程就变得简单了。
- en: Next, we’ll write the `add_eleven` function in assembly language, using the
    diagram in [Figure 14-4](ch14.xhtml#ch14fig4) to set the values of the `.equ`
    directives. The assembly language is shown in [Listing 14-18](ch14.xhtml#ch14list18).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在汇编语言中编写`add_eleven`函数，使用[图14-4](ch14.xhtml#ch14fig4)中的图示来设置`.equ`指令的值。汇编语言代码展示在[清单14-18](ch14.xhtml#ch14list18)中。
- en: '*add_eleven.s*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_eleven.s*'
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 14-18: The* add_eleven *function written in assembly language*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单14-18：用汇编语言编写的* add_eleven *函数*'
- en: We need to be careful to distinguish between the part of our stack frame being
    used only by this function and the arguments that were passed in by the calling
    function. Naming this boundary with a `.equ` directive ❶ makes it easy to create
    our stack frame ❷. As with the `main` function in [Listing 14-17](ch14.xhtml#ch14list17),
    the `.equ` directive names also make it easier to read the assembly language.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要小心区分栈帧中仅由当前函数使用的部分和由调用函数传入的参数。通过`.equ`指令❶命名这个边界，可以方便地创建我们的栈帧 ❷。与[清单14-17](ch14.xhtml#ch14list17)中的`main`函数一样，`.equ`指令的命名也使得汇编语言代码更易于阅读。
- en: The values in automatic local variables will be lost when exiting a function.
    There are times when you want the information provided by a local variable to
    be hidden, but you also want the content of the variable to remain the same between
    subsequent calls to the function. We’ll look next at how this can be done.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 自动局部变量的值在退出函数时会丢失。有时你希望局部变量提供的信息是隐藏的，但你也希望在后续调用函数时该变量的内容保持不变。接下来我们将讨论如何实现这一点。
- en: '**YOUR TURN**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的回合**'
- en: 14.1     Show that the assembly language `add_eleven` function in [Listing 14-18](ch14.xhtml#ch14list18)
    works with the C `main` function in [Listing 14-12](ch14.xhtml#ch14list12).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 14.1     展示在[清单14-18](ch14.xhtml#ch14list18)中的汇编语言`add_eleven`函数如何与[清单14-12](ch14.xhtml#ch14list12)中的C语言`main`函数一起工作。
- en: 14.2     Show that initializing the `sum` variable in [Listing 14-15](ch14.xhtml#ch14list15)
    is the same as doing the addition separately, like in [Listing 14-8](ch14.xhtml#ch14list8).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 14.2     展示初始化[清单14-15](ch14.xhtml#ch14list15)中的`sum`变量与单独进行加法运算（如在[清单14-8](ch14.xhtml#ch14list8)中所示）是相同的。
- en: 14.3     Write a program in assembly language that sums all the integers between
    two integers entered by the user.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 14.3     用汇编语言编写一个程序，求两个由用户输入的整数之间所有整数的和。
- en: '14.4     Write the three functions `write_char`, `write_str`, and `read_str`
    in assembly language. You’ll use these functions in exercises later in the book.
    Here are the specifications for each:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 14.4     用汇编语言编写三个函数：`write_char`、`write_str`和`read_str`。稍后在本书中的练习中你将使用这些函数。以下是每个函数的规格：
- en: (a)     `write_char` writes one character in the terminal window using the `write`
    system call. It takes one argument and returns 0.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: (a)     `write_char`通过`write`系统调用在终端窗口中写入一个字符。它接受一个参数并返回0。
- en: (b)     `write_str` writes text in the terminal window using the `write` system
    call. It takes one argument and returns the number of characters written.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: (b)     `write_str`通过`write`系统调用在终端窗口中写入文本。它接受一个参数，并返回写入的字符数。
- en: '(c)     `read_str` reads characters from the keyboard using the `read` system
    call and stores them in memory as a C-style text string, without the return character.
    It takes two arguments: a pointer to the memory location to store the text and
    the maximum number of characters to store. If the number of characters entered
    exceeds the maximum, it reads the remaining input but does not store it. It returns
    the number of characters entered, less the `NUL` terminating character.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: (c)     `read_str`通过`read`系统调用从键盘读取字符，并将它们存储在内存中作为C风格的文本字符串，不包括换行符。它接受两个参数：一个指向存储文本的内存位置的指针和最大存储字符数。如果输入的字符数超过最大值，它会读取剩余的输入，但不存储它。返回值是输入的字符数，减去`NUL`终止字符。
- en: Test the functions with the following C `main` function. Don’t forget to write
    the C header files for your assembly language functions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下C语言`main`函数测试这些函数。别忘了为你的汇编语言函数编写C头文件。
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Hint: Use a small number for `MAX` when testing your `read_str` function.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：测试`read_str`函数时使用一个较小的`MAX`值。
- en: '**Static Local Variables**'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**静态局部变量**'
- en: As discussed in [Chapter 11](ch11.xhtml), automatic local variables are created
    in a function’s prologue and get deleted in the function’s epilogue. This means
    the value stored in an automatic local variable will be lost in subsequent calls
    to the function. But in some cases, we might want to keep the value of a variable
    between function calls while still providing the information-hiding advantage
    of a local variable. For example, we might have a function that is called from
    several other functions and want to maintain a count of how many times it’s called.
    We could use a global variable, but a global variable doesn’t provide the information-hiding
    properties of a local variable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第11章](ch11.xhtml)中讨论的那样，自动局部变量在函数的前置代码中创建，并在函数的尾部删除。这意味着自动局部变量存储的值在后续调用函数时会丢失。但在某些情况下，我们可能希望在函数调用之间保持变量的值，同时仍然保持局部变量的信息隐藏优势。例如，我们可能有一个从多个其他函数中调用的函数，并且想要维护它被调用的次数。我们可以使用全局变量，但全局变量无法提供局部变量的信息隐藏特性。
- en: Instead, we can use a *static local variable*. Like an automatic local variable,
    a static local variable has local scope; however, like a global variable, it remains
    in memory throughout the lifetime of the entire program.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，我们可以使用*静态局部变量*。像自动局部变量一样，静态局部变量具有局部作用域；然而，像全局变量一样，它会在整个程序的生命周期内一直保留在内存中。
- en: '***In C***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在 C 中***'
- en: I’ll explain where static local variables are created in memory using the program
    in [Listings 14-19](ch14.xhtml#ch14list19), [14-20](ch14.xhtml#ch14list20), and
    [14-21](ch14.xhtml#ch14list21). These listings illustrate the differences between
    the visibility and persistence of an automatic local variable, a static local
    variable, and a global variable.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用[清单 14-19](ch14.xhtml#ch14list19)、[14-20](ch14.xhtml#ch14list20)和[14-21](ch14.xhtml#ch14list21)中的程序，解释静态局部变量在内存中是如何创建的。这些清单展示了自动局部变量、静态局部变量和全局变量在可见性和持久性上的区别。
- en: '*var_life.c*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*var_life.c*'
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 14-19: A program to compare automatic local, static local, and global
    variables*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-19：一个比较自动局部变量、静态局部变量和全局变量的程序*'
- en: 'This `main` function defines three `int` variables: the global variable `z`
    and the automatic local variables `x` and `y`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`main`函数定义了三个`int`变量：全局变量`z`和自动局部变量`x`、`y`。
- en: '[Listing 14-20](ch14.xhtml#ch14list20) shows the header file for the `add_const`
    function, which adds a constant value to an automatic local variable, a static
    local variable, and the global variable defined in `main`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-20](ch14.xhtml#ch14list20)展示了`add_const`函数的头文件，该函数将常量值添加到自动局部变量、静态局部变量和在`main`中定义的全局变量中。'
- en: '*add_const.h*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_const.h*'
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 14-20: The header file for the* add_const *function*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-20：`add_const`函数的头文件*'
- en: '[Listing 14-21](ch14.xhtml#ch14list21) is the definition of the `add_const`
    function.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-21](ch14.xhtml#ch14list21)是`add_const`函数的定义。'
- en: '*add_const.c*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_const.c*'
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 14-21: A function to add a constant value to three variables*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-21：一个将常量值添加到三个变量的函数*'
- en: The `add_const` function defines two local variables, `x` and `y`. The `y` variable
    is specified to be `static` ❶. This means it will be initialized to `INIT_Y` only
    the first time `add_const` is called. (If you don’t give an initial value to a
    static local variable, the compiler will initialize it to 0, but I recommend explicitly
    initializing it to 0 if that is your intention.) Any changes to `y` by `add_const`
    will persist through this call and all subsequent calls to the function. The `z`
    variable is declared with the `extern` modifier ❷ to show that it’s defined elsewhere
    in the program.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_const`函数定义了两个局部变量`x`和`y`。`y`变量被指定为`static` ❶。这意味着它只会在第一次调用`add_const`时被初始化为`INIT_Y`。（如果你没有给静态局部变量赋初值，编译器会将其初始化为0，但如果你的意图是这样，建议明确地初始化为0。）`add_const`对`y`所做的任何更改都会在此次调用及所有后续的调用中保持不变。`z`变量使用`extern`修饰符
    ❷ 声明，表示它在程序的其他地方定义。'
- en: The `add_const` function adds a constant value to each of the three variables
    declared in the function. The `printf` statement shows the values of the `x` and
    `y` local variables defined in `add_const` and the `z` global variable defined
    in `main` each time `add_const` is called.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_const`函数将一个常量值加到函数中声明的三个变量上。`printf`语句显示了每次调用`add_const`时，在`add_const`中定义的局部变量`x`和`y`，以及在`main`中定义的全局变量`z`的值。'
- en: 'Executing this program gives the following output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此程序会得到以下输出：
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, the `x` in `main` is different from the `x` in `add_const`.
    Each time `main` calls `add_const`, the `x` in `add_const` is initialized to 78
    and the function adds 1,000 to it ❶. This shows that a new `x` is automatically
    created each time `add_const` is called.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`main` 中的 `x` 与 `add_const` 中的 `x` 不同。每次 `main` 调用 `add_const` 时，`add_const`
    中的 `x` 都被初始化为 78，然后函数将其加上 1,000 ❶。这表明每次调用 `add_const` 时，都会自动创建一个新的 `x`。
- en: You can also see that the `y` in `main` is different from the `y` in `add_const`,
    but the behavior of the `x` and `y` variables in `add_const` is not the same.
    The first time `add_const` is called, it initializes its `y` variable to 90 and
    adds 1,000 to it. However, the result of this first call to `add_const` persists.
    The second call to `add_const` does not cause its `y` to be initialized again;
    the function simply adds 1,000 to the existing value in the static `y` ❷.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到 `main` 中的 `y` 与 `add_const` 中的 `y` 不同，但 `add_const` 中的 `x` 和 `y` 变量行为并不相同。第一次调用
    `add_const` 时，它将其 `y` 变量初始化为 90 并加上 1,000。然而，这次第一次调用 `add_const` 的结果会持续存在。第二次调用
    `add_const` 时，不会重新初始化 `y`；该函数只是将 1,000 加到静态 `y` 的现有值上 ❷。
- en: Although there are two `x`s and two `y`s in this program, there is only one
    `z`, which is defined in `main`. The output of the program shows that `main` gives
    `z` its initial value, 56, and `add_const` adds 1,000 to this each time the function
    is called ❸.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管程序中有两个 `x` 和两个 `y`，但只有一个 `z`，它是在 `main` 中定义的。程序的输出显示，`main` 给 `z` 赋予初始值 56，而每次调用
    `add_const` 函数时，`add_const` 都会将 1,000 加到该值上 ❸。
- en: '***In Assembly Language***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***汇编语言中的内容***'
- en: '[Listing 14-22](ch14.xhtml#ch14list22) shows the compiler-generated assembly
    language for the `main` function of the `var_life` program.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-22](ch14.xhtml#ch14list22) 显示了编译器为 `var_life` 程序中的 `main` 函数生成的汇编语言。'
- en: '*var_life.s*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*var_life.s*'
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 14-22: The compiler-generated assembly language for the function in
    [Listing 14-19](ch14.xhtml#ch14list19)*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-22：编译器为[清单 14-19](ch14.xhtml#ch14list19)中的函数生成的汇编语言*'
- en: Most of this code should look familiar to you. The one instance of `z` in this
    program is defined as a global in `main`, and the compiler uses our name to label
    the variable ❶. `main`’s `y` is created on the stack ❷.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的大部分内容应该对你来说是熟悉的。程序中的 `z` 实例在 `main` 中定义为全局变量，编译器使用我们的名字标记该变量 ❶。`main`
    中的 `y` 被创建在栈上 ❷。
- en: Let’s look at the assembly language the compiler generated for the `add_const`
    function, shown in [Listing 14-23](ch14.xhtml#ch14list23).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看编译器为 `add_const` 函数生成的汇编语言，如[清单 14-23](ch14.xhtml#ch14list23)所示。
- en: '*add_const.s*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_const.s*'
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 14-23: The compiler-generated assembly language for the* add_const
    *function in [Listing 14-21](ch14.xhtml#ch14list21)*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-23：编译器生成的汇编语言，用于[清单 14-21](ch14.xhtml#ch14list21)中的* add_const *函数*'
- en: The compiler allocated the `x` variable in the stack frame, so it knows the
    amount of the offset from the stack pointer ❶. As you learned in “Global Variables”
    on [page 271](ch14.xhtml#ch14lev1sec3), `add_const` needs to retrieve the address
    of the global variable `z` from the GOT ❸.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将 `x` 变量分配到栈帧中，因此它知道栈指针的偏移量 ❶。正如你在 [第 271 页](ch14.xhtml#ch14lev1sec3)的“全局变量”一节中学到的那样，`add_const`
    需要从 GOT 获取全局变量 `z` 的地址 ❸。
- en: The compiler treats the static local variable `y` a little differently than
    a global variable. It has changed our name to `y.0` ❷. This embellishment of our
    given name for the variable is called *name decoration* or *name mangling*. I
    prefer calling it decoration because it adds to our given name.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器处理静态局部变量 `y` 与全局变量略有不同。它将我们的名字改为 `y.0` ❷。这种对变量名字的修饰叫做 *名称修饰* 或 *名称重整*。我更喜欢称其为修饰，因为它是对我们原始名字的补充。
- en: A static local variable cannot exist in the stack frame. Like the global variable
    `z` defined in the `main` function (see [Listing 14-22](ch14.xhtml#ch14list22)),
    the static local variable `y` is allocated in the `.data` section ❹. It’s labeled
    with its decorated name and initialized with a `.word` assembler directive ❺.
    We get the address of our `y` variable using its decorated name ❷.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 静态局部变量不能存在于栈帧中。像在 `main` 函数中定义的全局变量 `z`（参见 [清单 14-22](ch14.xhtml#ch14list22)）一样，静态局部变量
    `y` 被分配在 `.data` 段 ❹。它被标记为其修饰后的名字，并通过 `.word` 汇编指令初始化 ❺。我们通过它的修饰名来获取 `y` 变量的地址
    ❷。
- en: The compiler needs to decorate names to satisfy the rules of C while also producing
    a valid assembly language file. As you might recall from the first section of
    this chapter ([page 270](ch14.xhtml#ch14lev1sec1)), the scope of a variable name
    in C extends only to the end of the block where it’s defined. That means we can
    use the same name to define another static variable in a different block that
    is not enclosed within the first one. But both variables result in labels in the
    assembly language, where they have file scope. The C compiler needs to distinguish
    between the two labels because the assembler requires that each label be unique
    within a file. It does this by decorating our static local variable names.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器需要装饰名称以满足C语言的规则，同时生成有效的汇编语言文件。正如你可能还记得从本章的第一部分（[第270页](ch14.xhtml#ch14lev1sec1)），C语言中变量名称的作用域仅扩展到它定义的块的结束。这意味着我们可以使用相同的名称在另一个不同的块中定义另一个静态变量，只要这个块不包含在第一个块内。但这两个变量都会在汇编语言中生成标签，且它们具有文件作用域。C编译器需要区分这两个标签，因为汇编器要求每个标签在文件内都是唯一的。它通过装饰我们的静态局部变量名称来实现这一点。
- en: When writing in assembly language, we can use more meaningful names to distinguish
    variables, making the code easier to read. [Listings 14-24](ch14.xhtml#ch14list24)
    and [14-25](ch14.xhtml#ch14list25) show how I would write this program in assembly
    language.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中编写程序时，我们可以使用更有意义的名称来区分变量，使代码更易于阅读。[清单 14-24](ch14.xhtml#ch14list24)和[14-25](ch14.xhtml#ch14list25)展示了我如何在汇编语言中编写这个程序。
- en: '*var_life.s*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*var_life.s*'
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 14-24: An assembly language program to compare automatic local, static
    local, and global variables*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-24：一个汇编语言程序，用于比较自动局部变量、静态局部变量和全局变量*'
- en: My assembly language `main` function is very similar to what the compiler did
    in [Listing 14-22](ch14.xhtml#ch14list22), but I used more meaningful names. Programs
    that use only terminal I/O tend to be very small, so I assumed that `z` will be
    within *±*1MB of the instruction and used the `adr` instruction to load its address
    ❶. The linker should warn us if this is not true, in which case we would need
    to use the `adrp/add` instruction sequence to load the address of `z`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我的汇编语言`main`函数与编译器在[清单 14-22](ch14.xhtml#ch14list22)中所做的非常相似，但我使用了更有意义的名称。只使用终端I/O的程序通常非常小，因此我假设`z`会位于指令的*±*1MB范围内，并使用`adr`指令加载它的地址❶。如果事实并非如此，链接器应该会警告我们，这时我们需要使用`adrp/add`指令序列来加载`z`的地址。
- en: '[Listing 14-25](ch14.xhtml#ch14list25) shows how I would write `add_const`
    in assembly language.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 14-25](ch14.xhtml#ch14list25)展示了我如何在汇编语言中编写`add_const`。'
- en: '*add_const.s*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_const.s*'
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 14-25: An assembly language function to add a constant value to three
    variables*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-25：一个汇编语言函数，用于将常量值加到三个变量上*'
- en: I have not decorated the name of the `y` variable ❶. As we saw earlier, the
    compiler decorates the names of static local variables to prevent a duplication
    of labels in the compiler-generated assembly language if we use the same static
    local name in another function in the same C source file. But writing in assembly
    language gives us more flexibility in choosing our label names. If we use `y`
    to label another memory location in the same file with the `add_const` function,
    the assembler will tell us about the error.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有装饰`y`变量的名称❶。正如我们之前看到的，编译器会装饰静态局部变量的名称，以防止如果我们在同一个C源文件的另一个函数中使用相同的静态局部名称时，编译器生成的汇编语言中出现标签重复的情况。但在汇编语言中编写代码使我们在选择标签名称时更加灵活。如果我们在同一文件中使用`y`来标记另一个内存位置，并使用`add_const`函数，汇编器会告诉我们错误。
- en: As with the `z` variable in the `main` function, I assume the `y` static variable
    will be close to the instructions that access it ❷.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 和`main`函数中的`z`变量一样，我假设`y`静态变量会接近访问它的指令❷。
- en: Next, I’ll give a brief summary of program memory characteristics.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将简要总结程序内存特性。
- en: '**Program Memory Characteristics**'
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**程序内存特性**'
- en: You learned about the different memory segments when we started programming
    in assembly language in [Chapter 10](ch10.xhtml). [Table 14-1](ch14.xhtml#ch14tab1)
    summarizes the memory characteristics of some of the most common components of
    a program, as well as which segment they are placed in.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第10章](ch10.xhtml)开始编写汇编语言程序时，你了解了不同的内存段。[表 14-1](ch14.xhtml#ch14tab1)总结了程序中一些最常见组件的内存特性，以及它们被放置的内存段。
- en: '**Table 14-1:** The Memory Characteristics of Common Program Components'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-1：常见程序组件的内存特性**'
- en: '| **Component** | **Memory segment** | **Access** | **Lifetime** |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| **组件** | **内存段** | **访问** | **生命周期** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Automatic local variable | Stack | Read and write | Function |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 自动局部变量 | 栈 | 读写 | 函数 |'
- en: '| Constant | Text | Read only | Program |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 文本 | 只读 | 程序 |'
- en: '| Instruction | Text | Read only | Program |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 文本 | 只读 | 程序 |'
- en: '| Static local variable | Data | Read and write | Program |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 静态局部变量 | 数据 | 读写 | 程序 |'
- en: '| Global variable | Data | Read and write | Program |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 全局变量 | 数据 | 读写 | 程序 |'
- en: '[Table 14-2](ch14.xhtml#ch14tab2) summarizes some of the more common assembler
    directives used to control where program components go in memory.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[Table 14-2](ch14.xhtml#ch14tab2)总结了常用的汇编指令，用于控制程序组件在内存中的位置。'
- en: '**Table 14-2:** Some Common Assembler Memory Directives'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**Table 14-2:** 一些常见的汇编内存指令'
- en: '| **Directive** | Memory segment | Effect |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | 内存段 | 效果 |'
- en: '| --- | --- | --- |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `.text` | Text | Instructions follow |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `.text` | 文本 | 指令跟随其后 |'
- en: '| `.rodata` | Text | Constant data follows |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `.rodata` | 文本 | 常量数据跟随其后 |'
- en: '| `.string "*string*", ...` | Text | Arrays of characters, each terminated
    by `NUL` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `.string "*string*", ...` | 文本 | 字符数组，每个字符由`NUL`结束 |'
- en: '| `.ascii "*string*", ...` | Text | Arrays of characters |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `.ascii "*string*", ...` | 文本 | 字符数组 |'
- en: '| `.asciz "*string*", ...` | Text | Arrays of characters, each terminated by
    `NUL` |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `.asciz "*string*", ...` | 文本 | 字符数组，每个字符由`NUL`结束 |'
- en: '| `.bss` | Data | Following data memory is initialized to zero |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `.bss` | 数据 | 后续数据内存初始化为零 |'
- en: '| `.data` | Data | Variable data follows |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `.data` | 数据 | 变量数据跟随其后 |'
- en: '| `.byte *expression*, ...` | Data | Initialize memory, 1 byte for each *`expression`*
    |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `.byte *expression*, ...` | 数据 | 初始化内存，每个*`expression`*占1字节 |'
- en: '| `.hword *expression*, ...` | Data | Initialize memory, 2 bytes for each *`expression`*
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `.hword *expression*, ...` | 数据 | 初始化内存，每个*`expression`*占2字节 |'
- en: '| `.word *expression*, ...` | Data | Initialize memory, 4 bytes for each *`expression`*
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `.word *expression*, ...` | 数据 | 初始化内存，每个*`expression`*占4字节 |'
- en: '| `.quad *expression*, ...` | Data | Initialize memory, 8 bytes for each *`expression`*
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `.quad *expression*, ...` | 数据 | 初始化内存，每个*`expression`*占8字节 |'
- en: The `.string`, `.ascii`, and `.asciz` directives can allocate more than one
    text string, each separated by a comma. The `.string` and `.asciz` directives
    add a `NUL` character to the end of the text string, while `.ascii` does not.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`.string`、`.ascii` 和 `.asciz` 指令可以分配多个文本字符串，每个字符串由逗号分隔。`.string` 和 `.asciz`
    指令会在文本字符串的末尾添加`NUL`字符，而`.ascii`则不会。'
- en: The `.byte`, `.hword`, `.word`, and `.quad` directives can apply to zero or
    more expressions, each of which must evaluate to an integral value. Multiple-byte
    values are stored in little-endian order. If there is no expression, no memory
    is allocated.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`.byte`、`.hword`、`.word` 和 `.quad` 指令可以应用于零个或多个表达式，每个表达式都必须计算为整数值。多字节值以小端顺序存储。如果没有表达式，则不会分配内存。'
- en: This is only a summary of these directives. For additional details, consult
    the `info` page for `as`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是这些指令的摘要。如需更多细节，请参考`as`的`info`页面。
- en: '**YOUR TURN**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的回合**'
- en: 14.5     Modify the program in [Listings 14-24](ch14.xhtml#ch14list24) and [14-25](ch14.xhtml#ch14list25)
    so that the `add_const` function prints the number of times it has been called.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 14.5     修改[Listings 14-24](ch14.xhtml#ch14list24)和[14-25](ch14.xhtml#ch14list25)中的程序，使得`add_const`函数能够打印出它被调用的次数。
- en: 14.6     Duplicate the `add_const` function in the file in [Listing 14-21](ch14.xhtml#ch14list21),
    naming the second copy `add_const2`. Modify the header file in [Listing 14-20](ch14.xhtml#ch14list20)
    accordingly. Modify the `main` function in [Listing 14-19](ch14.xhtml#ch14list19)
    so it calls both functions twice. How does this affect the name decorating in
    the `add_const` and `add_const2` functions ?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '| 14.6 | 在[Listing 14-21](ch14.xhtml#ch14list21)中的文件里复制`add_const`函数，命名第二个副本为`add_const2`。相应地修改[Listing
    14-20](ch14.xhtml#ch14list20)中的头文件。修改[Listing 14-19](ch14.xhtml#ch14list19)中的`main`函数，使其调用这两个函数两次。这样会如何影响`add_const`和`add_const2`函数中的名称修饰？'
- en: '**What You’ve Learned**'
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你所学到的**'
- en: '**Global variables** Persist throughout the entire life of the program (global
    scope).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局变量** 在程序的整个生命周期内保持存在（全局作用域）。'
- en: '**Automatic local variables** Created in their function when the function is
    called and deleted when the function is exited (function scope).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动局部变量** 在调用函数时创建，并在退出函数时删除（函数作用域）。'
- en: '**Static local variables** Initialized in the first call to their function.
    Their value, including any changes, persists between subsequent calls to the function
    (function scope).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态局部变量** 在第一次调用其函数时初始化。它们的值（包括任何更改）在随后的函数调用之间保持不变（函数作用域）。'
- en: '**Passing arguments** The first eight arguments are passed in registers. Any
    additional arguments are passed on the stack.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**传递参数** 前八个参数通过寄存器传递。任何额外的参数通过栈传递。'
- en: '**Pass by value** A copy of the value is passed.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**值传递** 传递的是值的副本。'
- en: '**Pass by pointer** The address of the variable is passed. The address can
    be changed in the called function.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**指针传递** 传递的是变量的地址。被调用函数中可以更改该地址。'
- en: '**Pass by reference** The address of the variable is passed. The address cannot
    be changed in the called function.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**引用传递** 传递的是变量的地址。被调用函数中无法更改该地址。'
- en: '**Stack frame** An area on the stack where a function’s frame record, local
    variables, saved register contents, and arguments to the function can be stored.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈帧** 栈上的一个区域，用于存储函数的帧记录、局部变量、保存的寄存器内容以及传递给函数的参数。'
- en: '**Frame pointer** A register containing the address of the frame record in
    the stack frame.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**帧指针** 一个寄存器，包含栈帧中帧记录的地址。'
- en: '**Frame record** Two addresses: the calling function’s frame pointer and the
    return address to the calling function.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**帧记录** 两个地址：调用函数的帧指针和返回地址。'
- en: Now that you’ve learned about the inner workings of functions, I’ll show you
    a couple of specialized uses of subfunctions in the next chapter.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了函数的内部工作原理，接下来我会在下一章展示一些子函数的特殊用法。
