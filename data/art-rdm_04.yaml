- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4'
- en: OPTIMIZE THE WORLD**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 优化世界**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: '*Optimization* is the process of finding the best set of something, usually
    of parameters defining a function or an algorithm. In mathematics, optimization
    typically involves functions and uses their derivatives to locate minima or maxima.
    In this chapter, we’ll take a different approach that involves randomness. The
    algorithms we’ll use fall into two broad categories: swarm intelligence and evolutionary
    algorithms. Collectively, these are known as *metaheuristics*.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*优化*是寻找某物最佳组合的过程，通常是定义一个函数或算法的参数。在数学中，优化通常涉及函数，并利用其导数来定位最小值或最大值。在本章中，我们将采用一种不同的方法，涉及随机性。我们将使用的算法分为两大类：群体智能和进化算法。统称为*元启发式算法*。'
- en: Optimizing with metaheuristics is more flexible than calculus-based optimization.
    What we’re optimizing doesn’t need to be a mathematical function; it could be
    an algorithm or another process. In fact, any problem that can be cast as locating
    the best position in a space, where the space represents the problem in some form,
    is amenable to swarm intelligence and evolutionary algorithms. I use both kinds
    of algorithms frequently for everything from curve fitting to evolving neural
    network architectures. Once you understand the process of formulating tasks as
    generic optimization problems, you’ll begin to see them everywhere.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元启发式算法进行优化比基于微积分的优化更灵活。我们优化的对象不必是数学函数；它可以是算法或其他过程。事实上，任何可以被视为在某个空间中定位最佳位置的问题，其中该空间以某种形式表示问题，都适用于群体智能和进化算法。我经常使用这两类算法，从曲线拟合到演化神经网络架构都有应用。一旦你理解了将任务表述为通用优化问题的过程，你会开始在各个领域看到它们。
- en: In this chapter, we’ll use swarm intelligence and evolutionary algorithms to
    fit data to a known function. Then, we’ll evolve the best fit function from scratch.
    We’ll begin, however, with a (very) short primer on swarm intelligence and evolutionary
    algorithms. We’ve already used an evolutionary algorithm, though it wasn’t named
    so at the time. The algorithm implemented in [Chapter 3](ch03.xhtml) to explore
    natural selection and genetic drift is a genetic algorithm, one of the two kinds
    of evolutionary algorithms we’ll encounter in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用群体智能和进化算法将数据拟合到已知的函数。然后，我们将从零开始演化出最佳拟合函数。然而，我们将首先简要介绍群体智能和进化算法的基础知识。我们已经使用过一种进化算法，尽管当时它并没有被称为进化算法。在[第3章](ch03.xhtml)中实现的算法用于探索自然选择和遗传漂变，它是一种遗传算法，是我们在本章中将遇到的两种进化算法之一。
- en: '**Optimization with Randomness**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**带有随机性的优化**'
- en: 'Imagine a large haystack where each position within the haystack corresponds
    to a possible solution to the problem. We wish to locate the part of the haystack
    that offers the best solution—that is, we want to find a needle. The question
    is: How do we go about finding it?'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个巨大的干草堆，其中每个位置代表问题的一个可能解决方案。我们希望找到干草堆中提供最佳解决方案的部分——也就是说，我们要找到针。问题是：我们该如何找到它？
- en: 'We’ll use the following generic algorithm to search the haystack:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下通用算法来搜索干草堆：
- en: A swarm (population) of “agents” are randomly scattered throughout the haystack.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一群（种群）“代理”随机分布在干草堆中。
- en: Each agent investigates its immediate location and assigns a number to how well
    that location solves the problem.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个代理调查其当前的位置，并给出该位置解决问题的优劣评分。
- en: The agents report their numbers to headquarters.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理将他们的数字报告给总部。
- en: After each agent has reported in, headquarters evaluates all the numbers and
    stores the best position currently known, updating it if, on this iteration, any
    agent finds a better position.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个代理报告完毕后，总部会评估所有数字并存储当前已知的最佳位置，如果在此迭代中有代理发现了更好的位置，则更新该位置。
- en: Headquarters then orders each agent to a new position in the haystack based
    on the information received.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总部根据收到的信息将每个代理指派到干草堆中的新位置。
- en: The process repeats from step 2 until a best position has been found or we’ve
    run out of time (iterations).
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程从步骤2开始重复，直到找到最佳位置或时间（迭代次数）耗尽。
- en: We have a lot of flexibility when it comes to possible implementations. Indeed,
    there are literally hundreds of published algorithms based on this approach. Many
    claim inspiration from nature, but such claims are often quite dubious and generally
    unnecessary.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施时，我们有很大的灵活性。事实上，基于这种方法的算法已被数百篇文章公开发布。许多人声称这些算法的灵感来源于自然，但这样的说法往往并不可靠，并且通常并非必要。
- en: 'Is this an example of a swarm intelligence algorithm or an evolutionary algorithm?
    It’s both. The difference between the two depends on what happens in step 4: the
    process headquarters uses to decide where the agents should go next. The distinction
    is vital for researchers but less so for us.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是群体智能算法的例子还是进化算法的例子？其实是两者兼具。这两者的区别在于第4步发生的事情：过程总部用来决定智能体下一步应该去哪里的方法。这个区分对于研究人员来说至关重要，但对我们来说重要性较低。
- en: In a swarm intelligence algorithm, the agents, called *particles*, work collectively
    to locate new positions in the space to explore. They are actively aware of each
    other and “learn” from each particle’s experiences to move the swarm, as a whole,
    to ever better places in the space, thereby locating increasingly better solutions
    to the problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在群体智能算法中，称为*粒子*的智能体共同工作，定位空间中的新位置进行探索。它们相互之间保持积极的意识，并从每个粒子的经验中“学习”，让整个群体不断朝着空间中越来越好的位置移动，从而找到越来越好的问题解决方案。
- en: An evolutionary algorithm, on the other hand, applies techniques like crossover
    and mutation to breed new agents (organisms). In [Chapter 3](ch03.xhtml), we defined
    an organism’s fitness as the distance between its genome and the genome of an
    ideal organism for the current environment. Here, fitness is a measure of how
    well the solution represented by the organism’s genome (position in the haystack)
    solves the problem. Generations of breeding fitter solutions, with a dash of random
    mutation, should move the population closer to the best solution to the problem.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，进化算法运用诸如交叉和变异等技术来繁殖新的智能体（生物体）。在[第3章](ch03.xhtml)中，我们将生物体的适应度定义为其基因组与当前环境中理想生物体基因组之间的距离。在这里，适应度是衡量生物体基因组所代表的解决方案（在大海捞针中的位置）如何解决问题的标准。通过几代繁殖更适应的解决方案，并辅以随机变异，应该能够让种群逐步接近问题的最佳解决方案。
- en: In practical terms, all we need to know is that the two kinds of algorithms
    search a space to find the best position in it. We’ll configure our problems such
    that the best position is translatable into a best solution.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，我们需要知道的就是这两种算法通过搜索空间来找到最佳位置。我们将配置我们的任务，使得最佳位置能够转化为最佳解决方案。
- en: With the hundreds of swarm and evolutionary algorithms out there, which ones
    should we use? Each algorithm has strengths and weaknesses, and might work best
    for certain kinds of problems. You need to try several.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在成千上万的群体智能和进化算法中，我们应该使用哪一种？每种算法都有其优缺点，可能更适用于某些特定类型的问题。你需要尝试几种。
- en: 'For this chapter, we’ll use five algorithms: two swarm intelligence, two evolutionary,
    and one that is so obvious many don’t consider it a swarm algorithm at all. We
    don’t have space to walk through each to understand the code; I’ll leave that
    as an exercise (as always, please contact me with questions). We’ll learn about
    the algorithms and the framework using them as we go.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用五种算法：两种群体智能算法，两种进化算法，以及一种显而易见但许多人并不认为是群体算法的算法。我们没有足够的篇幅逐一讲解每个算法的代码，留给你们作为练习（如果有问题，请随时联系我）。我们将边学习这些算法，边学习使用它们的框架。
- en: 'The two swarm intelligence algorithms are *particle swarm optimization (PSO)*
    and *Jaya*. PSO is the grandfather of swarm intelligence algorithms, and many
    nature-inspired algorithms are PSO in disguise. Jaya is a newer algorithm that
    has no parameters to adjust—either it works well or it doesn’t. Although there
    are many flavors of PSO, we’ll use two here: canonical and bare-bones.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种群体智能算法分别是*粒子群优化 (PSO)*和*Jaya*。PSO 是群体智能算法的鼻祖，许多受自然启发的算法都是PSO的变种。Jaya 是一种更新的算法，它没有需要调整的参数——要么它有效，要么它无效。尽管
    PSO 有许多变种，我们这里将使用其中两种：标准型和简化型。
- en: The two evolutionary algorithms are the *genetic algorithm (GA)*, a variation
    on what we used in [Chapter 3](ch03.xhtml), and *differential evolution (DE)*,
    another old-school and widely used technique. DE is one of my go-to algorithms,
    but it has the sometimes annoying habit of converging too quickly to local minima.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种进化算法分别是*遗传算法 (GA)*，它是我们在[第3章](ch03.xhtml)中使用的一种变体，以及*差分进化 (DE)*，另一种传统且广泛使用的技术。DE
    是我常用的算法之一，但它有时会有一个让人烦恼的习惯——过快地收敛到局部最小值。
- en: The last algorithm is *random optimization (RO)*. In RO, the particles don’t
    communicate; they conduct a local search and move to a new position whenever they
    find one, but are completely unaware of what other particles have discovered.
    Headquarters monitors each particle to track the best position found overall,
    but never issues orders based on that knowledge.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个算法是*随机优化（RO）*。在RO中，粒子之间不进行通信；它们进行局部搜索，并在找到新的位置时移动，但完全不知道其他粒子发现了什么。总部监视每个粒子，以跟踪整体上找到的最佳位置，但从不根据这些信息发布命令。
- en: We learn best by doing, so let’s begin fitting a function to data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实践学习得最好，所以让我们开始将一个函数拟合到数据中。
- en: '**Fitting with Swarms**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用群体进行拟合**'
- en: A common task in science and engineering is to fit a function to a set of measurements,
    where *fit* means finding the best set of parameters for a known type of function—the
    set that makes the function approximate the data as well as possible. For this
    task, we know the functional form; we need only to learn the parameter values
    to tailor the function to the data. In the next section, we’ll start with the
    data and let the swarms tell us what the best-fit function and parameters are
    (hopefully!). I’m using the word *swarms* in a general sense to mean both the
    swarm of particles manipulated by a swarm intelligence algorithm and the population
    bred and evolved by an evolutionary algorithm. Again, the distinction is minor
    for us.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学和工程中，一个常见的任务是将一个函数拟合到一组测量数据中，其中“拟合”意味着找到一组最佳的参数，使得已知类型的函数能够尽可能精确地逼近数据。对于这个任务，我们已经知道了函数的形式；我们只需要学习参数值，以便将函数调整到数据上。在下一节中，我们将从数据开始，利用群体智能算法来告诉我们最佳的拟合函数和参数是什么（希望如此！）。我在这里使用“群体”一词是广义的，既指通过群体智能算法操控的粒子群，也指通过进化算法培养和进化出的种群。对于我们来说，这种区分并不重要。
- en: 'Let’s start with a simple example: some data, a function, and the parameters
    that best fit the function to the data. The code for the example is in *curfit_example.py*.
    It generates a set of points from a quadratic function, with random noise added.
    Then, it uses NumPy’s `polyfit` routine to fit a quadratic: *ax*² + *bx* + *c*.
    [Figure 4-1](ch04.xhtml#ch04fig01) shows the plot and fit function.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始：一些数据，一个函数，以及最适合将函数拟合到数据的参数。该示例的代码在*curfit_example.py*中。它从一个二次函数生成一组带有随机噪声的点。然后，使用
    NumPy 的 `polyfit` 函数来拟合一个二次函数：*ax*² + *bx* + *c*。[图 4-1](ch04.xhtml#ch04fig01)展示了图表和拟合函数。
- en: '![Image](../images/04fig01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig01.jpg)'
- en: '*Figure 4-1: Fitting a polynomial to some data*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：将多项式拟合到一些数据*'
- en: With the fit function, we can approximate *y* for any *x*, which is typically
    why we fit the data in the first place.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用拟合函数，我们可以为任何* x *近似计算出*y*，这通常也是我们首先进行数据拟合的原因。
- en: You may be wondering why we’d bother with swarms if `polyfit` can fit the data.
    Unfortunately, `polyfit` fits only polynomials, or functions that are sums of
    powers of *x*. If your function isn’t a polynomial, there are other functions
    you could use, like SciPy’s `curve_fit`. However, we’re not solely interested
    in curve fitting; we’re using it as a warm-up exercise. SciPy won’t be of much
    use for the other optimization problems we’ll explore later in this chapter and
    in the next.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，如果`polyfit`能够拟合数据，为什么还要使用群体智能。遗憾的是，`polyfit`只适用于多项式，或者说是* x *的幂和的函数。如果你的函数不是多项式，还有其他函数可以使用，比如
    SciPy 的 `curve_fit`。然而，我们不仅仅是为了曲线拟合而使用它；我们将其作为热身练习。SciPy 对于我们将在本章和下一章中探讨的其他优化问题并不会有太大帮助。
- en: '***Curves***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***曲线***'
- en: Now that we have an idea of what curve fitting entails, let’s try it using a
    swarm. The code we want is in *curves.py*. We’ll use it first, then look at parts
    of it. I strongly recommend you read through the code to get a feel for things.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了曲线拟合的基本概念，接下来让我们用群体智能来实现它。我们需要的代码在*curves.py*中。我们将先使用它，然后再分析其中的部分内容。我强烈建议你通读这段代码，熟悉一下其中的内容。
- en: 'The code expects a datafile that contains the measured points along with the
    function to fit. We’ll use *curves.py* to fit the previous example. The input
    file we need is *curfit_example.txt*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代码需要一个包含测量点及拟合函数的数据文件。我们将使用*curves.py*来拟合前面的示例。我们需要的输入文件是*curfit_example.txt*：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line is the number of parameters followed by the function to fit.
    The function is given as Python code where the fit parameters are elements of
    a vector, `p`, and the data points are represented by `x`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是参数的数量，后面跟着拟合函数。该函数以Python代码的形式给出，其中拟合参数是向量`p`的元素，数据点用`x`表示。
- en: We want to fit a function like *ax*² + *bx* + *c*, a three-parameter function,
    so we use `p[0]*x**2+p[1]*x+p[2]`. If you want something like sin *x*, use `np.sin(x)`
    (use NumPy). Note that the data points are listed as *y* then *x*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望拟合一个类似*ax*² + *bx* + *c*的三参数函数，所以我们使用`p[0]*x**2+p[1]*x+p[2]`。如果你想要像sin *x*这样的函数，使用`np.sin(x)`（使用NumPy）。注意，数据点按*y*然后*x*列出。
- en: 'Let’s use *curves.py* and this file to fit the data using differential evolution:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用*curves.py*和这个文件通过差分进化来拟合数据：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The output tells us several things, but look first at the parameters. These
    are the elements of `p`, the best set of parameters found. Compare them with [Figure
    4-1](ch04.xhtml#ch04fig01). The fit is quite good.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉我们几个信息，但首先看一下参数。这些是`p`的元素，即找到的最佳参数集。将它们与[图 4-1](ch04.xhtml#ch04fig01)进行比较。拟合效果相当好。
- en: The generic algorithm says that particles need to evaluate where they are in
    the haystack to determine how good a solution their current position represents.
    There are three parameters in the fit function; therefore, our haystack is a three-dimensional
    space, and the particles are initially scattered randomly throughout this space.
    Each point in the three-dimensional space corresponds to a `p` vector, a set of
    three parameters. The best position found during the search is reported by *curves.py*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通用算法说，粒子需要评估它们在稻草堆中的位置，以确定当前位置表示的解决方案有多好。拟合函数中有三个参数；因此，我们的稻草堆是一个三维空间，粒子最初随机分布在这个空间中。三维空间中的每个点对应一个`p`向量，即一组三个参数。*curves.py*会报告在搜索过程中找到的最佳位置。
- en: 'For every particle, at every position in the haystack, we calculate the value
    of the *objective function*, the fitness function that tells us about the quality
    of the solution at that position. For curve fitting, our objective function measures
    the mean squared error between the measured points, (*x*, *y*), and the *y* values
    the function returns for the same *x* positions. If *ŷ* = *f*(*x*, ***p***) is
    the output of the function at *x* for some particle position, ***p***, then the
    *mean squared error (MSE)* is:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个粒子，在稻草堆中的每个位置，我们计算*目标函数*的值，这是一个适应度函数，用于告诉我们该位置解的质量。对于曲线拟合，我们的目标函数衡量的是测量点(*x*,
    *y*)与函数返回的同一*x*位置的*y*值之间的均方误差。如果*ŷ* = *f*(*x*, ***p***)是函数在*x*位置对某粒子位置***p***的输出，则*均方误差
    (MSE)*为：
- en: '![Image](../images/f0107-01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0107-01.jpg)'
- en: The sum is over all the measured points, (*x[i]*, *y[i]*).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 求和是针对所有测量点(*x[i]*, *y[i]*).
- en: The closer the MSE is to zero, the better the function is at fitting the measured
    data, meaning the particle position giving us the smallest MSE is the best fit
    found. The swarm algorithm keeps adjusting particle positions until it finds the
    minimum or we run out of iterations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: MSE越接近零，说明函数拟合测量数据的效果越好，这意味着给出最小MSE的粒子位置就是找到的最佳拟合位置。群体算法不断调整粒子的位置，直到找到最小值或我们耗尽迭代次数。
- en: 'The *curves.py* file accepts many command line parameters:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*curves.py*文件接受许多命令行参数：'
- en: curfit_example.txt   Datafile
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: curfit_example.txt   数据文件
- en: -10   Lower bound
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: -10   下界
- en: 20   Upper bound
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 20   上界
- en: 20   Number of particles
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 20   粒子数量
- en: 1000   Number of iterations
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 1000   迭代次数
- en: 0   Tolerance
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 0   容差
- en: DE   Algorithm (DE, Jaya, PSO, GA, RO)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: DE   算法（DE，Jaya，PSO，GA，RO）
- en: pcg64   Randomness source
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: pcg64   随机源
- en: The first argument is the name of the file that has the measured data points.
    Again, the first line is the number of parameters in the fit, followed by the
    code to implement the fit function. The remainder of the file are the actual data
    points, *y* then *x*, one pair per line.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是包含测量数据点的文件名。第一行是拟合的参数数量，接着是实现拟合函数的代码。文件的其余部分是实际的数据点，*y*然后是*x*，每一行一个数据对。
- en: The next two arguments specify the bounds of the search. These limit the size
    of the space the swarm can move through. Specifying a scalar applies that value
    to all dimensions; otherwise, specify each dimension separated by `x`. In this
    case, we tell *curves.py* to limit its search space to the cube from (–10, –10,
    –10) to (20, 20, 20). The bounds are often helpful, but must enclose the actual
    best values; otherwise, the search will return only the best position within the
    given bounds.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个参数指定搜索的边界。这些限制了群体可以移动的空间大小。指定标量值会将该值应用于所有维度；否则，需指定每个维度，用`x`分隔。在此案例中，我们告诉*curves.py*将其搜索空间限制为从（–10，–10，–10）到（20，20，20）的立方体。边界通常是有用的，但必须包含实际的最佳值；否则，搜索只会返回给定边界内的最佳位置。
- en: The following argument, also `20`, specifies the size of the swarm, or the number
    of particles to scatter throughout the haystack. It’s generally better to have
    a smaller swarm and more iterations—the next parameter, here 1,000—but that’s
    only a rule of thumb; exceptions abound.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下参数，也是`20`，指定了群体的大小，或者说是散布在干草堆中的粒子数量。通常，群体越小，迭代次数越多（这里是1,000次）效果更好，但这只是一个经验法则，例外情况很多。
- en: We are minimizing the MSE. The search stops early if the MSE is less than the
    given tolerance. By setting the tolerance to 0, we’re telling *curves.py* to search
    for 1,000 iterations of the swarm positions or to stop early if we find a position
    with no error. The last parameter is the randomness source for `RE`. A final parameter,
    the name of an output image file showing the data points and the fit, is also
    allowed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在最小化均方误差（MSE）。如果MSE小于给定的容差，搜索会提前停止。通过将容差设置为0，我们告诉*curves.py*搜索1,000次群体位置，或者如果找到没有误差的位置则提前停止。最后一个参数是`RE`的随机源。另一个参数是显示数据点和拟合结果的输出图像文件的名称，也可以提供。
- en: Swarm algorithms are stochastic, meaning they change their output from run to
    run because they randomly assign initial particle positions and use random values
    during the search. For many problems, the changes are subtle and inconsequential,
    but sometimes the swarm simply gets lost. Therefore, it’s best to repeat searches
    several times, if possible, to be sure the results are meaningful.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 群体算法是随机的，意味着它们的输出会因运行的不同而变化，因为它们在搜索过程中随机分配初始粒子位置，并使用随机值。对于许多问题，变化是微妙的，不太重要，但有时群体会迷失方向。因此，最好多次重复搜索（如果可能的话），以确保结果是有意义的。
- en: To try the other swarm algorithms—PSO, Jaya, GA, and RO—specify them by name.
    I suspect you will find that PSO, Jaya, and even RO give results as good as DE.
    GA, however, is another story. The output, numerically, is poor, though if you
    plot the result, it often looks at least somewhat reasonable. Does this mean GA
    is a flawed algorithm? No, it’s simply not well suited to this task. In general,
    GA is best for non-numerical optimization problems and problems with a higher
    number of dimensions (parameters). In this example, using GA means asking it to
    evolve a population of organisms with three genes each. That doesn’t leave much
    for evolution to work with.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试其他的群体算法—PSO、Jaya、GA和RO—请通过名称指定。我怀疑你会发现，PSO、Jaya甚至RO给出的结果和DE一样好。然而，GA是另一个问题。数值输出很差，虽然如果你绘制结果，图形看起来通常至少还算合理。这是否意味着GA是一个有缺陷的算法？不，它只是并不适合这个任务。一般来说，GA最适合非数值优化问题和维度（参数）较高的问题。在这个例子中，使用GA意味着要求它进化出一个每个基因有三个基因的有机体种群。这对于进化来说几乎没有什么可以工作的内容。
- en: 'Let’s look at one more curve fitting example. The function to fit is in *sinexp.txt*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个曲线拟合的例子。要拟合的函数在*sinexp.txt*文件中：
- en: '![Image](../images/f0109-01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0109-01.jpg)'
- en: 'This function is the sum of a sine and a normal curve and has five parameters:
    we’re in a five-dimensional search space and each particle is a point in this
    space. I can’t picture a five-dimensional haystack, but we’re looking for a needle
    in one regardless.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是正弦曲线和正态曲线的和，包含五个参数：我们处于一个五维的搜索空间中，每个粒子是该空间中的一个点。我无法想象一个五维的干草堆，但我们依然在这个空间中寻找针。
- en: 'Let’s try *curves.py* using Jaya:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试使用Jaya的*curves.py*：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first time I tried the code, the fit failed and returned a minimum MSE of
    0.1656, which is orders of magnitude larger than the previous fit. A plot of the
    good result is in [Figure 4-2](ch04.xhtml#ch04fig02).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次尝试代码时，拟合失败，返回了0.1656的最小MSE，比之前的拟合大了几个数量级。良好结果的图形见[图4-2](ch04.xhtml#ch04fig02)。
- en: '![Image](../images/04fig02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig02.jpg)'
- en: '*Figure 4-2: A fit to [Equation 4.2](ch04.xhtml#ch04equ2) using Jaya*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-2：使用Jaya对[方程4.2](ch04.xhtml#ch04equ2)的拟合*'
- en: 'The search used 20 particles and 1,000 iterations as before. I limited the
    search space to the range –3 to 20 in all five dimensions. In this case, the dataset
    was generated directly from the function with parameter values of 2, 3, 20, 8,
    and 0.6, respectively. This explains the extremely low MSE: there is no noise
    in the measurements.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索依然使用了20个粒子和1,000次迭代。我将搜索空间限制在了五个维度的-3到20之间。在这个例子中，数据集是直接从函数生成的，参数值分别为2、3、20、8和0.6。这也解释了极低的MSE：测量中没有噪声。
- en: '**NOTE**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You may encounter runtime warnings when using the code. These are the result
    of the swarm algorithm using parameter values that are too large for the exponential.
    Adding* -W ignore *to the command line after* python3 *will suppress the warnings.*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*在使用代码时，你可能会遇到运行时警告。这是由于群体算法使用了对指数函数来说过大的参数值。你可以在命令行中加上* -W ignore *，这样就能抑制这些警告。*'
- en: '***The curves.py Code***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***curves.py 代码***'
- en: 'Let’s look at some code to get a feel for what the swarm algorithms are doing;
    it will also help you see how to put the pieces together. Start at the bottom
    of *curves.py*. The essence of the code, as you’ll see when you read through it,
    is the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码，感受一下群体算法在做什么；它也将帮助你理解如何将各个部分组合在一起。从*curves.py*的底部开始。代码的本质，如你在阅读时会看到的，是以下内容：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line configures an instance of `RE` using the source given on the
    command line (`kind`). The next four lines set up the search for differential
    evolution. The code is the same for Jaya, PSO, RO, and GA, with the addition of
    one more argument to the constructor in the case of PSO. Let’s go line by line;
    these are the steps to configure any swarm search using the framework, so we’ll
    see them again as we proceed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用命令行给定的源（`kind`）配置一个`RE`的实例。接下来的四行配置差分进化的搜索。Jaya、PSO、RO和GA的代码是相同的，只有在PSO的情况下，构造函数中会多一个参数。让我们逐行看；这些是使用框架配置任何群体搜索的步骤，接下来我们会再次看到它们。
- en: First, swarm searches are bounded, so we need an instance of the `Bounds` class,
    or a subclass if we need to override one of its methods, typically `Validate`.
    The arguments are the lower and upper limits, the randomness source, and a parameter
    called `enforce` that’s set to `resample`. Referring back to the generic search
    algorithm, step 5 states that headquarters orders the agents to move to new positions
    based on the objective function values for their current positions. At times,
    these new positions might be outside the specified boundaries. The `enforce` parameter
    decides what to do in these cases. By setting it to `resample`, any particle dimension
    that is out of bounds is replaced by a randomly selected value along that dimension.
    The other option is `clip`, which clips the offending dimension to the minimum
    or maximum allowed. Most of the time, this isn’t what we want.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，群体搜索是有边界的，所以我们需要一个`Bounds`类的实例，或者如果需要重写其方法（通常是`Validate`），可以使用它的子类。参数包括下限和上限、随机源和一个名为`enforce`的参数，默认设置为`resample`。回顾一下通用的搜索算法，第5步表示总部指示代理根据当前位点的目标函数值移动到新位置。有时，这些新位置可能超出了指定的边界。`enforce`参数决定在这种情况下该怎么办。通过将其设置为`resample`，任何超出边界的粒子维度将被该维度上的随机选择值替代。另一个选项是`clip`，它将违规维度修剪为允许的最小值或最大值。大多数情况下，这并不是我们想要的。
- en: The `RandomInitializer` parameter provides an initializer to configure the swarm.
    It’s given the number of particles in the swarm (`npart`), the dimensionality
    of the search space (`ndim`), and the bounds configured in the previous line (`b`).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`RandomInitializer`参数提供了一个初始化器来配置群体。它接收群体中粒子的数量（`npart`）、搜索空间的维度（`ndim`）以及上一行配置的边界（`b`）。'
- en: The search also needs to know how to evaluate the objective function, an instance
    of `Objective`. For the curve fit example, `X` and `Y` are the measured points
    and `func` is the function to fit, all read from the datafile given on the command
    line. I’ll show you the objective function in a moment.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索还需要知道如何评估目标函数，这是一个`Objective`的实例。在曲线拟合示例中，`X`和`Y`是测量点，`func`是要拟合的函数，所有这些都从命令行给定的数据文件中读取。稍后我会展示目标函数。
- en: We’re now ready to create the swarm algorithm object (`swarm`), here an instance
    of `DE`. We give the objective function, number of particles, dimensions, initializer,
    and bounds, along with the randomness source. We also specify the tolerance (`tol`)
    and the number of iterations (`max_iter`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备创建群体算法对象（`swarm`），这里是`DE`的一个实例。我们提供目标函数、粒子数量、维度、初始化器、边界以及随机源。我们还指定了容忍度（`tol`）和迭代次数（`max_iter`）。
- en: 'Given all the configuration, using the swarm object is straightforward: call
    the `Optimize` method. When the call returns, the search is over. Call `Results`
    to return a dictionary with information about the search.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 给定所有的配置，使用群体对象是直接的：调用`Optimize`方法。当调用返回时，搜索结束。调用`Results`以返回一个包含搜索信息的字典。
- en: The most important elements of `res` are `gpos` and `gbest`. Both return lists
    tracing the collection of best positions the swarm found during its search. Therefore,
    the final element of these lists returns the best position (`gpos`) and the corresponding
    objective function value (`gbest`). The position is a vector with one value for
    each dimension of the search space; here each dimension is a parameter value for
    the function we’re fitting to the data. The `gbest` value is a scalar, the MSE
    for this set of parameters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`res` 中最重要的元素是 `gpos` 和 `gbest`。这两者都返回追踪群体在搜索过程中找到的最佳位置的列表。因此，这些列表的最终元素返回最佳位置（`gpos`）和相应的目标函数值（`gbest`）。该位置是一个向量，每个维度对应搜索空间中的一个值；这里每个维度是我们拟合数据的函数的一个参数值。`gbest`
    是一个标量，表示该组参数的均方误差（MSE）。'
- en: 'Let’s look at the `Objective` class. The object passed as the objective function
    must have, at a minimum, a method called `Evaluate`. The details aren’t very important,
    but because Python uses duck typing, any object with an `Evaluate` method that
    accepts a single argument is permitted. Here’s the code *curves.py* uses:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `Objective` 类。作为目标函数传递的对象至少需要有一个名为 `Evaluate` 的方法。具体细节并不重要，但因为 Python
    使用鸭子类型，所以任何具有接受单个参数的 `Evaluate` 方法的对象都可以接受。这里是 *curves.py* 使用的代码：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The constructor keeps references to the measured points, `x` and `y`, along
    with the string representing the function to fit (`func`). Many applications do
    not have ancillary information, in which case the constructor does nothing and
    need not be specified. Also, notice that `Objective` does not inherit from any
    other class, it needs only to implement `Evaluate` to be acceptable to the optimization
    framework.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数保持对测量点 `x` 和 `y` 的引用，并包含表示拟合函数的字符串 (`func`)。许多应用没有附加信息，在这种情况下，构造函数不做任何操作，也不需要指定。此外，请注意
    `Objective` 并没有继承任何其他类，它只需要实现 `Evaluate` 方法，就可以被优化框架接受。
- en: The `Evaluate` method is called by the swarm algorithms. The argument, `p`,
    is the current position of a particle in the swarm, that is, a vector of possible
    parameter values. The first line increments `fcount`, an internal counter of the
    number of times `Evaluate` was called. The final value of `fcount` is displayed
    when *curves.py* exits.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Evaluate` 方法由群体算法调用。参数 `p` 是粒子在群体中的当前位置，即一个可能的参数值向量。第一行增加了 `fcount`，这是 `Evaluate`
    被调用次数的内部计数器。*curves.py* 退出时会显示 `fcount` 的最终值。'
- en: 'The next line looks a little strange: it assigns the reference to the *x* data,
    `self.x`, to the local variable `x`. The following line uses Python’s `eval` function
    to evaluate the function value; because `eval` uses both `x` and `p` as variable
    names, we need those names to exist in `Evaluate`—hence the `x = self.x`. The
    calculated function values are in `y`. These are the *ŷ* values in [Equation 4.1](ch04.xhtml#ch04equ1).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行看起来有点奇怪：它将 `self.x`（即 *x* 数据）的引用赋值给局部变量 `x`。接下来的行使用 Python 的 `eval` 函数来计算函数值；因为
    `eval` 同时使用了 `x` 和 `p` 作为变量名，所以我们需要在 `Evaluate` 中存在这些变量名——因此需要 `x = self.x`。计算出的函数值保存在
    `y` 中。这些就是 [公式 4.1](ch04.xhtml#ch04equ1) 中的 *ŷ* 值。
- en: Finally, we calculate the MSE and return it to give the objective function value
    (or fitness value) for the supplied particle position in `p`. Notice there is
    no square root. I left it out to save a tiny bit of time. The smallest MSE is
    still the smallest even if the final square root is not applied.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算 MSE 并将其返回，作为给定粒子位置 `p` 的目标函数值（或适应度值）。注意这里没有取平方根。我省略了它，以节省一点时间。即使没有最终的平方根，最小的
    MSE 仍然是最小的。
- en: When the swarm algorithm runs, it calls `Evaluate` thousands of times to map
    particle positions to MSE values. The swarm algorithms are utterly ignorant of
    *what* the objective function is measuring; all they know is that they pass a
    vector representing a particle position in a multidimensional space to the objective
    function, and it returns a scalar value where lower values are better than higher
    values. This makes the framework generic and applicable to a wide range of problems.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当群体算法运行时，它会调用 `Evaluate` 数千次，将粒子位置映射到均方误差（MSE）值。群体算法完全不知道*目标函数*在衡量什么；它们只知道将表示粒子位置的向量传递给目标函数，目标函数返回一个标量值，较小的值比较大的值更好。这使得框架具有通用性，适用于广泛的问题。
- en: 'To recap, using the framework involves the following steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，使用框架的步骤如下：
- en: Determine how to map potential solutions to the problem to a position in a multidimensional
    space for the swarms to search.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定如何将潜在的解决方案映射到一个多维空间中的位置，供群体进行搜索。
- en: Use that mapping to create an objective function class supporting at least an
    `Evaluate` method to accept a candidate position vector and return a scalar representing
    the quality of the solution it represents. The framework always minimizes, so
    the smaller the return value, the better the solution. To maximize, return the
    negative of the fitness.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该映射创建一个目标函数类，支持至少一个`Evaluate`方法，用于接受一个候选位置向量并返回一个标量，表示该位置代表的解的质量。框架总是进行最小化，因此返回值越小，解越好。要进行最大化时，返回适应度值的负值。
- en: Create a `Bounds` object to set the limits of the search space and what to do
    if those limits are exceeded.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Bounds`对象，用于设置搜索空间的边界以及如果超出边界时的处理方式。
- en: Create an initializer (`RandomInitializer`) to supply the initial positions
    of the swarm particles.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个初始化器（`RandomInitializer`），用以提供群体粒子的初始位置。
- en: Create an instance of the swarm class, `DE`, `PSO`, `Jaya`, `RO`, or `GA`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个群体类的实例，`DE`、`PSO`、`Jaya`、`RO`或`GA`。
- en: Perform the search by calling `Optimize`, and use `Results` to return the outcome.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`Optimize`进行搜索，并使用`Results`返回结果。
- en: Our familiarity with the framework will grow with practice. For now, let’s review
    the swarm intelligence and evolutionary algorithms to understand how they differ
    from each other and where the randomness is. Randomness goes deeper than the initial
    configuration of the swarm particles in the search space; each algorithm depends
    critically on randomness for its operation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 随着实践的深入，我们将更熟悉这个框架。现在，让我们回顾一下群体智能和进化算法，以理解它们之间的差异以及随机性所在。随机性远不仅仅存在于群体粒子在搜索空间中的初始配置中；每种算法的操作都依赖于随机性。
- en: '***The Optimization Algorithms***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***优化算法***'
- en: There are hundreds of swarm optimization algorithms out there, but what distinguishes
    one from another? The short answer is the method used for searching, or how headquarters
    orders the agents to new locations on each iteration.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有成百上千种群体优化算法，但是什么使得它们彼此不同呢？简短的答案是：搜索方法，或者说总部在每次迭代中如何指挥代理到达新位置。
- en: The various algorithm approaches range from the most straightforward—RO, where
    the agents don’t communicate but wander from better position to better position
    independently—to sophisticated algorithms incorporating information about agents’
    current positions, histories, and associations into groups and neighborhoods.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 各种算法方法从最简单的RO开始——在RO中，代理之间不进行通信，而是独立地从一个更好的位置漂移到另一个更好的位置——到更复杂的算法，这些算法将代理的当前位置信息、历史记录以及群体和邻域的关联信息纳入考虑。
- en: 'In this section, I’ll summarize the essential operation of the five algorithms
    selected for the framework. In all cases, the essential operation is the same:
    scatter particles throughout the search space, evaluate the quality of each particle,
    decide where they go next, and repeat until a best position is found or time runs
    out. It’s the “decide where they go next” part that differentiates algorithms.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将总结框架中选择的五种算法的基本操作。在所有情况下，基本操作都是相同的：将粒子散布在整个搜索空间中，评估每个粒子的质量，决定它们下一步去哪里，并重复这个过程，直到找到最佳位置或时间耗尽。正是“决定它们下一步去哪里”这一部分区分了不同的算法。
- en: '**Random Optimization (RO)**'
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**随机优化（RO）**'
- en: Swarm particles are represented by a vector of floating-point numbers, ***x**[i]*,
    each component of which maps to a dimension of the search space. In other words,
    particles are points in the search space. On each iteration, particles construct
    a new position some distance from their current one and ask if the new position
    has a better fitness value, that is, if the objective function value is lower
    at the new position. If so, the particle moves to the new position; otherwise,
    it stays put. The new candidate position is
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 群体粒子通过一个浮点数向量`***x**[i]*`来表示，每个组件对应搜索空间中的一个维度。换句话说，粒子是搜索空间中的点。在每次迭代中，粒子会构造一个与当前距离一定的新的位置，并判断这个新位置是否具有更好的适应度值，也就是说，目标函数在新位置的值是否更低。如果是，粒子就移动到新位置；否则，它保持原地。新的候选位置是
- en: '![Image](../images/f0113-01.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0113-01.jpg)'
- en: where *η* (eta) is a scale parameter (*η* = 0.1) and ***N***(0, 1) is a vector
    of samples from a normal distribution with mean 0 and standard deviation 1\. If
    ![Image](../images/pg113-01.jpg) has a lower objective function value, then ![Image](../images/pg113-02.jpg);
    otherwise, the particle stays where it is for the next iteration. The particles
    make no use of what other particles have learned about the search space.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*η*（η）是一个比例参数（*η* = 0.1），***N***(0, 1)是一个从均值为0、标准差为1的正态分布中取样的向量。如果![Image](../images/pg113-01.jpg)的目标函数值较低，那么![Image](../images/pg113-02.jpg)；否则，粒子在下一次迭代中保持原位。粒子不会利用其他粒子对搜索空间的学习结果。
- en: '**Jaya**'
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Jaya**'
- en: Jaya, Sanskrit for “victory,” is a swarm intelligence algorithm that has no
    adjustable parameters. Swarm algorithms depend on heuristics, so they often have
    adjustable parameters to improve their performance in different situations. Jaya
    does not. It works or it doesn’t.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Jaya，梵语中意为“胜利”，是一种没有可调参数的群体智能算法。群体算法依赖启发式方法，因此通常会有可调参数来提高其在不同情况下的表现。而Jaya则不同，它要么有效，要么无效。
- en: On each iteration, the *i*th particle is updated via
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，第*i*个粒子通过以下方式更新：
- en: '![Image](../images/f0113-02.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0113-02.jpg)'
- en: where ***x***[best] and ***x***[worst] are the current best and worst positions
    of any particle in the swarm, and ***r***[1] and ***r***[2] are random vectors
    in [0, 1) per component. The vertical bars apply the absolute value to each component
    of the vector. In other words, Jaya moves particles toward the swarm’s best position
    and away from the swarm’s worst.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，***x***[best]和***x***[worst]是群体中任何粒子的当前最佳和最差位置，***r***[1]和***r***[2]是[0,
    1)之间的随机向量，逐项计算。竖线符号表示对向量的每个分量取绝对值。换句话说，Jaya将粒子移动到群体的最佳位置，远离群体的最差位置。
- en: '**Particle Swarm Optimization (PSO)**'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**粒子群优化（PSO）**'
- en: 'The update equations for PSO depend on the flavor. Our framework offers two:
    canonical and bare-bones. The *curves.py* file uses bare-bones, hence `bare=True`
    in the `PSO` constructor. However, it’s easier to begin with canonical PSO.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: PSO的更新公式取决于具体实现。我们的框架提供了两种：经典PSO和精简版PSO。*curves.py*文件使用的是精简版，因此在`PSO`构造函数中设置了`bare=True`。不过，建议从经典PSO开始。
- en: In canonical PSO, each particle (***x**[i]*) is associated with two other vectors.
    The first, ![Image](../images/xcap.jpg), is the best position in the search space
    that *that* particle has found, and the second, ***υ**[i]*, is the particle’s
    velocity, which controls how quickly and in which direction the particle moves
    through the search space.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典PSO中，每个粒子（***x**[i]*)与另外两个向量相关联。第一个，![Image](../images/xcap.jpg)，是该粒子在搜索空间中找到的最佳位置；第二个，***υ**[i]*，是粒子的速度，控制粒子在搜索空间中移动的速度和方向。
- en: 'The canonical PSO update rule is accomplished in two steps. First, the velocity
    is updated:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的PSO更新规则通过两个步骤完成。首先，速度更新：
- en: '![Image](../images/f0114-01.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0114-01.jpg)'
- en: Here, *ω* is the inertia factor multiplying the current velocity. It’s a scalar,
    usually in [0.5, 1), with a typical initial value of 0.9\. It decreases from iteration
    to iteration. This slows the particle as the search progresses, in theory, because
    the particle is likely moving closer to the best position. The second term calculates
    the difference between the particle’s best-known position so far, ![Image](../images/xcap.jpg),
    and its current position, ***x**[i]*. This value is multiplied, component by component,
    by ***c***[1] = *c*[1]***U***[0, 1), that is, a random vector in [0, 1) multiplied
    by a scalar, *c*[1]. We use 1.49, a typical value. The last term in the velocity
    update calculates the difference between the swarm’s best-known position, ***g***,
    and the particle’s current position, and multiplies it by vector ***c***[2] =
    *c*[2]***U***[0, 1). Usually, *c*[1] = *c*[2].
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*ω*是惯性因子，用来乘以当前速度。它是一个标量，通常在[0.5, 1)之间，典型的初始值为0.9。它会随着迭代逐步减小。理论上，这会随着搜索进展而减缓粒子的速度，因为粒子很可能正接近最佳位置。第二项计算粒子目前已知的最佳位置！[Image](../images/xcap.jpg)与其当前的位置***x**[i]*之间的差异。这个差值逐项乘以***c***[1]
    = *c*[1]***U***[0, 1)，即在[0, 1)之间的随机向量，再乘以标量*c*[1]。我们使用典型的值1.49。速度更新的最后一项计算群体当前最佳位置***g***与粒子当前位置之间的差异，并将其乘以向量***c***[2]
    = *c*[2]***U***[0, 1)。通常，*c*[1] = *c*[2]。
- en: 'Second, the particle position is updated using the newly calculated velocity:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，粒子的位置通过新计算出的速度进行更新：
- en: '***x**[i]* ← ***x**[i]* + ***υ**[i]*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '***x**[i]* ← ***x**[i]* + ***υ**[i]*'
- en: '**NOTE**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you have a physics background and are, like me, bothered by the addition
    of a velocity and a position, imagine a* Δ t = 1 *multiplying* **v***[i] where*
    Δ t *is the time step between iterations. Now the units are correct.*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你有物理学背景，并且像我一样，对速度和位置的相加感到困扰，可以想象一个* Δ t = 1 *乘以**v***[i]，其中* Δ t *是每次迭代之间的时间步长。现在单位是正确的。*'
- en: Bare-bones PSO, sometimes called BBPSO, does not use a velocity vector. Instead,
    particle positions are updated with samples from a normal distribution. If ***x**[i]*
    is the vector representing particle *i*’s current position, then ***x**[ij]* is
    the *j*th component of that vector. With that in mind, calculate
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 基础PSO，有时称为BBPSO，不使用速度向量。相反，粒子的位置通过从正态分布中抽取样本来更新。如果***x**[i]*是表示粒子*i*当前位置的向量，那么***x**[ij]*就是该向量的*
    j *分量。考虑到这一点，计算
- en: '![Image](../images/f0114-03.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0114-03.jpg)'
- en: if *p ∼ U*[0, 1) < *p[b]*, otherwise
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *p ∼ U*[0, 1) < *p[b]*，否则
- en: '![Image](../images/f0114-04.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0114-04.jpg)'
- en: for each component (*j*) of each particle (*i*). Here, ![Image](../images/f0114-05.jpg)
    means draw a sample from a normal distribution with mean ![Image](../images/x-bar.jpg)
    and standard deviation *σ*. Typically, *p[b]* = 0.5, so 50 percent of the time,
    on average, the particle’s *j*th component is calculated from the normal distribution,
    and 50 percent of the time it’s simply a copy of the corresponding component of
    the particle’s best position, ![Image](../images/xcap.jpg).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个粒子（*i*）的每个分量（*j*）。这里，![Image](../images/f0114-05.jpg)表示从均值为![Image](../images/x-bar.jpg)、标准差为*σ*的正态分布中抽取样本。通常，*p[b]*
    = 0.5，因此粒子* j *的分量有50%的几率从正态分布中计算得出，另外50%的几率只是简单复制粒子最佳位置的对应分量![Image](../images/xcap.jpg)。
- en: '**Genetic Algorithm (GA)**'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**遗传算法（GA）**'
- en: We know from our evolution experiments that a GA involves breeding (crossover)
    and random mutation. The code in *GA.py* follows this pattern, but fits with the
    overall optimization framework. In particular, *GA.py* manipulates floating-point
    values by default, not integers. You can alter this behavior by subclassing `Bounds`
    and implementing a `Validate` method to force integer values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的进化实验中我们知道，遗传算法（GA）涉及交叉（crossover）和随机变异。*GA.py*中的代码遵循这一模式，但与整体优化框架相契合。特别是，*GA.py*默认操作浮动值，而不是整数。如果需要，你可以通过子类化`Bounds`并实现`Validate`方法来强制使用整数值。
- en: The update rule for a particle, ***x**[i]*, involves crossover with a randomly
    chosen mate, where in this case the mate is selected from the top 50 percent best
    performing particles—see the `top` parameter of the `GA` constructor. Additionally,
    the current best-particle position, that is, the fittest particle, is passed to
    the next generation unaltered.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子的更新规则，***x**[i]*，涉及与随机选择的配偶进行交叉，在这种情况下，配偶是从表现最好的前50%的粒子中选择的——参见`GA`构造函数中的`top`参数。此外，当前的最佳粒子位置，即最优粒子，将未修改地传递到下一代。
- en: Our evolution experiments bred every individual, generation to generation. Here,
    individuals breed only if a random value is below the `CR` probability, 0.8 by
    default. When an individual breeds, it is replaced by the offspring. Whether ***x**[i]*
    breeds, there is a certain probability of a random mutation by assigning a randomly
    selected dimension a random value. Therefore, for any update, a particle may be
    replaced by its offspring, and it may undergo random mutation. The default mutation
    probability is 5 percent (`F` in the `GA` constructor).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的进化实验通过代际交配繁殖每个个体。这里，个体仅在随机值小于`CR`概率时才进行交配，默认值为0.8。当个体繁殖时，它将被后代替代。无论***x**[i]*是否交配，都会有一定概率发生随机变异，通过为一个随机选择的维度分配一个随机值。因此，对于任何更新，粒子可能会被其后代替代，并且可能会发生随机变异。默认的变异概率为5%（在`GA`构造函数中的`F`）。
- en: As a rule of thumb, the GA seems to work best for problems that aren’t mathematical
    (like curve fitting) and involve a higher number of dimensions to give evolution
    a larger “genome” to manipulate. Whether this has implications for biological
    evolution, I don’t know; regardless, another hallmark of the GA is slow convergence.
    You often need an order of magnitude more iterations (or even more) to reach a
    solution similar to that found far more quickly by Jaya or DE. Let’s turn there
    now.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验法则，GA似乎最适合那些非数学问题（如曲线拟合），并且涉及更多的维度，以便为进化提供更大的“基因组”进行操作。不知道这是否对生物进化有影响；无论如何，GA的另一个特点是收敛较慢。你通常需要更多数量级的迭代（甚至更多），才能得到一个与Jaya或DE快速找到的解相似的解。让我们现在转到那里。
- en: '**Differential Evolution (DE)**'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**差分进化（DE）**'
- en: DE was invented in 1995 by Price and Storn, the same year particle swarm optimization
    was invented by Kennedy and Eberhart. Like PSO, DE has stood the test of time
    and grown into a collection of similar approaches. DE is an evolutionary algorithm
    where particles are updated between iterations by a process involving crossover
    and mutation. However, unlike the straightforward crossover and mutation of the
    GA, DE replaces ***x**[i]* with a new vector that is, in a sense, the offspring
    of *four* parents. DE isn’t modeled on nature.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: DE由Price和Storn于1995年发明，与此同年，粒子群优化（PSO）由Kennedy和Eberhart发明。像PSO一样，DE经得起时间的考验，并已发展成一系列相似的方法。DE是一种进化算法，其中粒子在每次迭代之间通过交叉和突变的过程更新。然而，与遗传算法（GA）中直接的交叉和突变不同，DE用一个新向量替换***x**[i]*，从某种意义上说，这个新向量是*四个*父代的后代。DE并不是模仿自然的。
- en: 'To update particle ***x**[i]*, first select three other members of the swarm,
    unique and not ***x**[i]*. From these three, create a donor vector:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新粒子***x**[i]*，首先选择群体中其他三个成员，且它们不能是***x**[i]*。从这三个成员中创建一个捐赠向量：
- en: '***υ*** = ***υ***[1] + *F*(***υ***[2] – ***υ***[3])'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '***υ*** = ***υ***[1] + *F*(***υ***[2] – ***υ***[3])'
- en: Some variants of DE require that ***υ***[1] be the best performing member of
    the swarm instead of a randomly selected member. Here, *F* plays the role of mutation
    in the GA. In this case, the default value is *F* = 0.8.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 某些DE变种要求***υ***[1]是群体中表现最好的成员，而不是随机选择的成员。在这种情况下，*F*在遗传算法中起到突变的作用。此时，默认值为*F*
    = 0.8。
- en: The offspring of ***x**[i]* and ***υ*** is created component by component (gene
    by gene) where, with probability *CR*, the corresponding component of ***υ***
    is used; otherwise, the component of ***x**[i]* is retained. The default value
    is *CR* = 0.5, meaning the offspring of ***x**[i]* retains, on average, 50 percent
    of its existing values (genes).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '***x**[i]*和***υ***的后代是逐个分量（逐基因）创建的，其中，在概率*CR*下，使用***υ***的对应分量；否则，保留***x**[i]*的分量。默认值为*CR*
    = 0.5，意味着***x**[i]*的后代平均保留50%的现有值（基因）。'
- en: There are so many variants of DE that a nomenclature has arisen to describe
    them. The code in *DE.py* defaults to “DE/rand/1/bin,” meaning the donor vector
    uses three randomly selected vectors (“rand”), a single differential (***υ***[2]
    – ***υ***[3]), and a *Bernoulli* crossover (“bin”). A Bernoulli trial is a coin
    flip where the probability of success is *p* and that of failure 1 – *p*. Here,
    *p* = *CR* is the crossover probability.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: DE有很多变种，因此出现了专门的命名法来描述它们。*DE.py*中的代码默认为“DE/rand/1/bin”，这意味着捐赠向量使用三个随机选择的向量（“rand”），一个差分（***υ***[2]
    – ***υ***[3]），以及*伯努利*交叉（“bin”）。伯努利试验类似于掷硬币，其中成功的概率为*p*，失败的概率为1 – *p*。这里，*p* =
    *CR*是交叉概率。
- en: 'The `DE` class supports two additional types of selection and an additional
    type of crossover, should you wish to experiment with them. If one of the three
    vectors used to build the donor is always the current swarm best, then the label
    begins with “DE/best/1.” Additionally, a new selection mode is supported: DE/toggle/1,
    which toggles between “rand” and “best” every other update. Finally, Bernoulli
    crossover may be replaced with GA-style crossover, meaning the `DE` class supports
    six possible differential variants from the three different selection and two
    crossover types. Feel free to experiment with all of them. Do you notice anything
    different between them, especially how quickly the swarm converges? Hint: look
    at all the values in the `gbest` element of the dictionary returned by `DE`’s
    `Results` method combined with the `giter` element that tracks the iteration number
    for each new swarm best position (`gpos`) and objective function value (`gbest`).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`DE`类支持两种额外的选择类型和一种额外的交叉类型，如果你想尝试它们的话。如果用于构建捐赠向量的三个向量之一始终是当前群体中的最佳向量，则标签会以“DE/best/1”开头。此外，支持一种新的选择模式：DE/toggle/1，它在每次更新时在“rand”和“best”之间切换。最后，伯努利交叉可以替换为遗传算法风格的交叉，这意味着`DE`类支持来自三种不同选择和两种交叉类型的六种差分变体。你可以随意尝试它们。你注意到它们之间有什么不同吗，尤其是在群体收敛的速度上？提示：查看`DE`的`Results`方法返回的字典中`gbest`元素的所有值，以及跟踪每个新群体最佳位置（`gpos`）和目标函数值（`gbest`）的`giter`元素。'
- en: 'The goal of this section was to fit a known function to a dataset by minimizing
    the MSE between the data points and the function value at those points. We were
    after the parameters of the function, as we already knew the form we wanted. This
    raises the question: What if all we have is the data and we don’t know the functional
    form? There are several ways to answer this. One is to use a machine learning
    model—after all, that’s what they are designed to do: learn a model (function)
    from a set of data. We’ll do this in [Chapter 5](ch05.xhtml). Another is to evolve
    a piece of code that approximates the data. Let’s give this approach a shot.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是通过最小化数据点和函数值之间的均方误差（MSE），将已知函数拟合到数据集上。我们要寻找的是函数的参数，因为我们已经知道了我们想要的形式。这就引出了一个问题：如果我们只有数据，而不知道函数的形式怎么办？有几种方法可以解答这个问题。一个是使用机器学习模型——毕竟，机器学习模型的设计目的就是：从一组数据中学习一个模型（函数）。我们将在[第五章](ch05.xhtml)中讨论这个问题。另一种方法是进化出一段逼近数据的代码。让我们尝试这种方法。
- en: '**Fitting Data**'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**拟合数据**'
- en: Curve fitting had us searching for the parameters of a known function. In this
    section, all we have is the data and our goal is to evolve a piece of code approximating
    a function that fits the data. We still want *y* = *f*(*x*)—that is, for a given
    *x* we get an approximated *y*—but here *f*(*x*) is Python code. Evolving code
    is known as *genetic programming (GP)*, and it has a long history dating back
    to the early 1990s. A related term is *symbolic regression*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线拟合要求我们搜索已知函数的参数。在这一节中，我们只有数据，而我们的目标是进化出一段代码，使得它能够逼近一个拟合数据的函数。我们依然希望*y* = *f*(*x*)——也就是说，对于给定的*x*，我们得到一个近似的*y*——但这里的*f*(*x*)是Python代码。进化代码被称为*遗传编程（GP）*，它有着悠久的历史，追溯到1990年代初期。相关的术语是*符号回归*。
- en: As the name suggests, GP often uses the GA. Our implementation, however, uses
    the framework from the previous section so we can select any of the swarm intelligence
    and evolutionary algorithms. To use a swarm, we need to find a mapping between
    what we want (code) and a multidimensional space where each position in the space
    represents a possible solution. For curve fitting, the mapping was straightforward.
    If there were *n* parameters in the function, there were *n* parameters in the
    search space where each coordinate of a specific point was, literally, the parameter
    value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，GP通常使用GA。然而，我们的实现采用了前一节中的框架，因此我们可以选择任何一种群体智能和进化算法。为了使用群体算法，我们需要找到我们想要的（代码）和一个多维空间之间的映射关系，其中空间中的每个位置表示一个可能的解。对于曲线拟合，映射关系很直接。如果函数中有*n*个参数，那么在搜索空间中也有*n*个参数，每个特定点的坐标实际上就是该参数的值。
- en: Here, we have to be more clever. To identify the mapping, let’s think about
    how we want to represent the code of our function, and from there, the mapping
    might be somewhat easier to see.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要更聪明一点。为了识别映射关系，我们可以考虑如何表示我们函数的代码，从这个角度出发，映射关系可能会更容易理解。
- en: We want a function manipulating a scalar input value, *x*, to arrive at a scalar
    output value, *y*. So, we need math. We’ll make do with the standard arithmetic
    operations, plus negation, modulo, and powers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望一个函数能够处理标量输入值*x*，并得出标量输出值*y*。所以，我们需要进行数学运算。我们将使用标准的算术运算，另外加上取反、模运算和幂运算。
- en: Doing math implies mathematical expressions. Here things become murkier. Manipulating
    mathematical expressions is rather tricky, more tricky than we care to attack
    in a book like this. Traditional GP manipulates expressions using an evolutionary
    algorithm, complete with crossover and mutation, where crossover merges two expressions
    and mutation alters a term in the expression.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 做数学运算意味着数学表达式。在这里，事情变得更加复杂。操控数学表达式相当棘手，比我们在这本书中愿意讨论的还要复杂。传统的GP使用进化算法操作表达式，包含交叉和变异，交叉将两个表达式合并，而变异则改变表达式中的一个项。
- en: Fortunately, we can use a shortcut. If we have a stack and know about postfix
    notation, we have all we need to generate expressions and map code to a position
    in the search space. I’ll explain, but let’s make sure we’re on the same page
    when it comes to stacks and postfix notation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以使用一个捷径。如果我们有一个栈，并且了解后缀表示法，我们就可以具备生成表达式并将代码映射到搜索空间中的位置所需的一切。我将做详细解释，但在此之前，我们需要确保我们对栈和后缀表示法有一个清晰的认识。
- en: '***Introducing Stacks and Postfix Notation***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***介绍栈和后缀表示法***'
- en: Imagine a stack of cafeteria trays. As new trays are added to the stack, they
    rest on top of all the existing trays. When someone needs a tray, they take the
    top tray, meaning the last tray added to the stack is the first tray removed from
    it. *Stacks* are like cafeteria trays (though cleaner).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下自助餐厅托盘的堆叠。当新的托盘被添加到栈中时，它们会放在所有现有托盘的上面。当有人需要托盘时，他们拿取最上面的托盘，这意味着最后被添加到栈中的托盘是第一个被拿走的托盘。*栈*就像自助餐厅的托盘（虽然更干净）。
- en: 'Consider this example. We have three numbers: 1, 2, and 5\. We also have a
    stack that is currently empty. The first number we *push* on the stack is 1, then
    we push 2, and finally 5\. [Figure 4-3](ch04.xhtml#ch04fig03) shows what the stack
    looks like step by step, from left to right.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子。我们有三个数字：1、2和5。我们还有一个当前为空的栈。我们首先将1*推入*栈，然后推入2，最后推入5。*图 4-3*显示了栈的变化过程，从左到右。
- en: '![Image](../images/04fig03.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig03.jpg)'
- en: '*Figure 4-3: Stack manipulation*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-3：栈操作*'
- en: On the left, the stack is empty; then, moving right, we add 1, then 2, and finally
    5\. The stack is now three deep, with 1 at the bottom and 5 at the top.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，栈是空的；然后，向右移动，我们依次添加1、2，最后添加5。此时栈的深度为三，底部是1，顶部是5。
- en: Now it’s time to *pop* a value off the stack. What value do we get? In a queue,
    we would get 1, the first value in. For a stack, we get 5, the last value pushed.
    Pop the stack again and we get 2, and finally 1, leaving the stack empty. Values
    pop off a stack in reverse order compared to how they are pushed onto the stack.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候*弹出*栈中的一个值了。我们得到什么值？在队列中，我们会得到1，即第一个进入的值。而在栈中，我们得到5，即最后一个被推入的值。再次弹出栈，我们得到2，最后得到1，栈变为空。栈中的值是按相反顺序弹出的，与它们被推入栈的顺序相反。
- en: Stacks are natural structures for manipulating expressions in *postfix* form,
    that is, expressions where the operands come first, followed by the operation.
    For example, infix notation, our usual way of writing expressions, might say *a*
    + *b*, but in postfix notation, this becomes *a b* +. Postfix notation, also called
    reverse Polish notation (RPN), was developed in 1924 by Polish mathematician Jan
    Łukasiewicz. Postfix notation doesn’t require parentheses to alter operator precedence.
    Instead, it builds the expression piece by piece. Combine postfix notation with
    a stack, and it becomes straightforward to evaluate arbitrary expressions. This
    is precisely what we want.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是操作*后缀*形式表达式的自然结构，即操作数先出现，运算符跟在其后。例如，常用的中缀表示法，我们通常写作*a* + *b*，而在后缀表示法中，这变成了*a
    b* +。后缀表示法，也叫逆波兰表示法（RPN），是由波兰数学家扬·Łukasiewicz于1924年提出的。后缀表示法不需要括号来改变运算符的优先级。相反，它是逐步构建表达式的。将后缀表示法与栈结合起来，评估任意表达式变得非常简单。这正是我们所需要的。
- en: To better understand what I mean, let’s translate the infix expression *y* =
    *a*(*b* + *c*) – *d* to postfix notation and implement it using a stack and pseudocode
    statements. In postfix notation, it becomes *a b c* + × *d* –. To evaluate it,
    move from left to right until you hit an operator, here +. The operands are the
    two variables to the left, *b* and *c*. Compute *b* + *c* and replace “*b c* +”
    with the result, *t*[0]. The expression is now *a t*[0] × *d* –. Repeat to find
    × with operands *a* and *t*[0]. Compute the product and replace it with *t*[1]
    to get *t*[1] *d* –. Finally, evaluate *t*[1] – *d* to get the value of the expression,
    *y*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解我的意思，我们将中缀表达式*y* = *a*(*b* + *c*) – *d* 转换为后缀表示法，并使用栈和伪代码实现它。在后缀表示法中，它变成了*a
    b c* + × *d* –。要评估它，从左到右移动，直到遇到运算符，这里是+。操作数是左侧的两个变量，*b*和*c*。计算*b* + *c*并将“*b c*
    +”替换为结果*t*[0]。此时表达式变为*a t*[0] × *d* –。重复此过程以找到×，操作数为*a*和*t*[0]。计算乘积并将其替换为*t*[1]，得到*t*[1]
    *d* –。最后，评估*t*[1] – *d*，得到表达式的值*y*。
- en: 'Let’s implement this process in code using a stack to hold values. Consider
    the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中实现这个过程，使用栈来保存值。请考虑以下内容：
- en: '[PRE5]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The values on the right show the stack after each instruction with *t*[0] =
    *b* + *c*, *t*[1] = *a* × *t*[0], and *y* = *t*[1] – *d*. The expressions leave
    the answer, *y*, on the stack, and `push` places values on the stack. Binary operations
    like `add` pop two values off the stack, add them, and push the result back on
    the stack. Therefore, a linear sequence of statements and a stack are all we need
    to implement any function of *x* yielding *y*—at least, any function involving
    arithmetic operations, negation, and powers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的值显示了每条指令执行后栈的状态，其中*t*[0] = *b* + *c*，*t*[1] = *a* × *t*[0]，*y* = *t*[1] –
    *d*。这些表达式将结果*y*留在栈上，而`push`指令则将值压入栈中。像`add`这样的二元操作会从栈中弹出两个值，进行相加，并将结果重新压入栈中。因此，一系列的线性语句和栈就是我们实现任何关于*x*并得到*y*的函数所需的——至少，对于涉及算术运算、取反和幂运算的函数。
- en: Functions written in this way become sequences of instructions with no loops.
    If we find a way to map the sequences to floating-point vectors, we’re in business.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写的函数成为没有循环的指令序列。如果我们找到将这些序列映射到浮点向量的方法，那么我们就成功了。
- en: '***Mapping Code to Points***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码与点的映射***'
- en: 'To evolve code, we need the four basic arithmetic operations: addition (`add`),
    subtraction (`sub`), multiplication (`mul`), and division (`div`). We also need
    exponentiation (`pow`) and will throw in modulo for good measure (`mod`).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要演化代码，我们需要四种基本的算术运算：加法（`add`）、减法（`sub`）、乘法（`mul`）和除法（`div`）。我们还需要指数运算（`pow`），并且为了稳妥起见，我们还加入了取模运算（`mod`）。
- en: Postfix notation distinguishes the subtraction operator and negation, treating
    the latter as a different instruction, so we need negation (`neg`) as well, *x
    →* –*x*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀表示法区分了减法运算符和取反运算，后者被视为不同的指令，因此我们还需要取反（`neg`）指令，*x →* –*x*。
- en: 'Finally, we need two more instructions: `halt` and `push`. If `halt` is executed,
    the code stops and ignores any subsequent instructions. The `push` instruction
    pushes *x* or a number (a constant) on the stack.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要两条指令：`halt`和`push`。如果执行了`halt`，代码会停止，并忽略之后的任何指令。`push`指令会将*x*或一个数字（常数）压入栈中。
- en: We have nine instructions. We want a sequence of instructions executed in order,
    which reminds me of a vector where each element is an instruction, and we execute
    the instructions one at a time from index 0 to the end of the vector.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有九条指令。我们希望按顺序执行一系列指令，这让我想起一个向量，其中每个元素是一个指令，我们从索引0开始，一直到向量的末尾执行这些指令。
- en: Each instruction becomes a value, for example, `add` is 1 and `sub` is 2, so
    if a particle has a 2 in a particular component, then that component encodes a
    subtraction instruction. Particle positions are floating-point numbers, not integers,
    so we’ll keep only the integer part of each, meaning a component with a floating-point
    value of 2.718 is interpreted as a 2, implying a subtraction instruction.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每条指令都变成一个值，例如，`add`是1，`sub`是2，所以如果某个粒子的某个组件是2，那么这个组件就表示减法指令。粒子位置是浮点数，不是整数，所以我们只保留每个位置的整数部分，这意味着一个浮点值为2.718的组件会被解释为2，从而意味着减法指令。
- en: '[Table 4-1](ch04.xhtml#ch04tab01) has the mapping we’ll use for instructions
    (the integer part of a particle position).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[表4-1](ch04.xhtml#ch04tab01)包含了我们将用于指令的映射（粒子位置的整数部分）。'
- en: '**Table 4-1:** Mapping Particle Positions to Instructions'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-1：** 粒子位置与指令的映射'
- en: '| **Instruction** | **Number** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **编号** |'
- en: '| --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `add` | 1 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `add` | 1 |'
- en: '| `sub` | 2 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `sub` | 2 |'
- en: '| `mul` | 3 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `mul` | 3 |'
- en: '| `div` | 4 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `div` | 4 |'
- en: '| `mod` | 5 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `mod` | 5 |'
- en: '| `pow` | 6 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `pow` | 6 |'
- en: '| `neg` | 7 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `neg` | 7 |'
- en: '| `push(x)` | 8 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `push(x)` | 8 |'
- en: '| `halt` | 9 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `halt` | 9 |'
- en: All that remains is to handle pushing constants on the stack. If we can’t do
    this, we’re stuck evolving expressions of only *x*, like *xx* + *x* – *x* – *x*,
    which will get us nowhere.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是处理将常数压入栈中。如果我们不能做到这一点，我们就只能演化出类似*x*的表达式，比如*xx* + *x* – *x* – *x*，这将毫无意义。
- en: The instruction numbers begin with 1, not 0\. This is intentional. Numbering
    this way leaves vector components in the range [0, 1) available as that range
    is not associated with an instruction.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 指令编号从1开始，而不是0。这是故意为之。这样编号使得向量组件在[0, 1)范围内可用，因为这个范围没有与任何指令相关联。
- en: 'Let’s use this range to push arbitrary numbers on the stack. When we run a
    search, we’ll specify a lowest and highest number, like –1 and 11\. Then, we’ll
    map values in [0, 1) to [–1, 11). So, to push a constant of 3.1472 on the stack,
    we issue the instruction 0.3456 because:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个范围将任意数字压入栈中。当我们运行搜索时，我们会指定一个最小值和最大值，比如-1和11。然后，我们将[0, 1)范围内的值映射到[–1,
    11)范围。因此，要将常数3.1472压入栈中，我们发出指令0.3456，因为：
- en: '*a* + *f*(*b* – *a*) = –1 + 0.3456(11 – ^–1) = 3.1472'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* + *f*(*b* – *a*) = –1 + 0.3456(11 – ^–1) = 3.1472'
- en: Handling things this way lets us specify arbitrary constant values within the
    given range.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式处理，可以让我们在给定的范围内指定任意的常数值。
- en: For example, [Table 4-2](ch04.xhtml#ch04tab02) shows a segment of code generated
    by *gp.py*, the program we’re in the process of developing, along with the actual
    particle position values.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[表 4-2](ch04.xhtml#ch04tab02)展示了由 *gp.py* 生成的一段代码，该程序是我们正在开发的，同时也给出了实际的粒子位置值。
- en: '**Table 4-2:** An Evolved Code Sample'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-2：** 一个进化代码示例'
- en: '| **Instruction** | **Particle value** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **粒子值** |'
- en: '| --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `push(x)` | — |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `push(x)` | — |'
- en: '| `push(x)` | 8.5251446 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `push(x)` | 8.5251446 |'
- en: '| `push(3.00482)` | 0.6502409 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `push(3.00482)` | 0.6502409 |'
- en: '| `mul` | 3.3605457 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `mul` | 3.3605457 |'
- en: '| `push(7.07870)` | 0.8539350 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `push(7.07870)` | 0.8539350 |'
- en: '| `push(-9.09650)` | 0.0451748 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `push(-9.09650)` | 0.0451748 |'
- en: '| `mod` | 5.0708302 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `mod` | 5.0708302 |'
- en: '| `add` | 1.3708454 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `add` | 1.3708454 |'
- en: '| `halt` | 9.7707617 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `halt` | 9.7707617 |'
- en: '| `div` | 4.2693693 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `div` | 4.2693693 |'
- en: '| `sub` | 2.6309877 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `sub` | 2.6309877 |'
- en: '| `div` | 4.6783009 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `div` | 4.6783009 |'
- en: '| `pow` | 6.5429319 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `pow` | 6.5429319 |'
- en: The task was to fit a noisy set of points representing a line. The evolved function
    fit the data quite nicely. The number limit in this case was –10 to 10, and I
    told the search (bare-bones PSO) to use 12 instructions. All evolved functions
    begin with *x* on the stack, here represented by the first `push(x)`. Also, when
    the function exits, it returns the top stack value as *y*. Any remaining stack
    values are ignored.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是拟合一个表示直线的噪声数据集。进化后的函数很好地拟合了这些数据。这个案例中的数字限制是 –10 到 10，我让搜索（简单粒子群优化，PSO）使用
    12 条指令。所有进化后的函数都会以 *x* 开始，栈上最初表示的是 `push(x)`。此外，当函数退出时，它会返回栈顶的值作为 *y*，剩余的栈值会被忽略。
- en: If the particle value is ≥ 1, the integer part specifies an instruction, so
    8.525 *→* 8, which is the instruction to push *x*, just as 3.360 *→* 3 to indicate
    multiplication.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果粒子值 ≥ 1，则整数部分指定一个指令，所以 8.525 *→* 8，这表示推送 *x*，就像 3.360 *→* 3 表示乘法。
- en: 'Look at the second particle vector component, 0.6502409, which, with the number
    limits, becomes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下第二个粒子向量分量 0.6502409，它在数字限制下变为：
- en: –10 + 0.6502409(10 – ^–10) = 3.00482
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: –10 + 0.6502409(10 – ^–10) = 3.00482
- en: This number is multiplied by *x*, that is, the second and third instructions
    implement 3.00482*x*. The data points were generated by adding a small amount
    of random noise to the line 3*x* – 2\. The evolved function immediately implements
    3.00482*x*, which is quite encouraging.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字将与 *x* 相乘，即第二条和第三条指令实现了 3.00482*x*。这些数据点是通过给直线 3*x* – 2 添加少量随机噪声生成的。进化后的函数立即实现了
    3.00482*x*，这非常令人鼓舞。
- en: 'The next three instructions push 7.07870 then –9.09650 on the stack before
    executing `mod`. This seems like a strange thing to do, but consider what Python
    does with the expression:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三条指令将 7.07870 和 –9.09650 推入栈中，然后执行 `mod`。这看起来是一个奇怪的操作，但考虑一下 Python 对表达式的处理方式：
- en: '[PRE6]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These instructions leave –2.0178 on the stack.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令将 –2.0178 留在栈上。
- en: The next instruction is `add`. We add the top two stack values, which we just
    learned are 3.00482*x* and –2.0178\. Interestingly, this is equivalent to the
    infix expression 3.00482*x* – 2.0178, and earlier I stated that the data points
    were generated from 3*x* – 2\. The evolved code implements the expression used
    to create the data points in the first place.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的指令是 `add`。我们将栈顶的两个值相加，刚才我们得知它们是 3.00482*x* 和 –2.0178。有趣的是，这等价于中缀表达式 3.00482*x*
    – 2.0178，而我之前提到这些数据点是通过 3*x* – 2 生成的。进化后的代码实现了当初生成数据点时使用的表达式。
- en: The instruction following `add` is `halt`, which causes the function to exit
    with the sum on the stack. Instructions after `halt` are never executed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着 `add` 的指令是 `halt`，它使得函数退出，并将栈上的和作为结果。`halt` 之后的指令永远不会被执行。
- en: Fabulous! We have an approach, a way to map floating-point vectors to code to
    implement a function. It’s a bit odd, but we’ll run with it and see where we get.
    Our next task is to create *gp.py*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们有了一个方法，一种将浮点向量映射到代码以实现函数的方式。它有点奇怪，但我们将继续尝试，看看能走到哪里。接下来的任务是创建 *gp.py*。
- en: '***Creating gp.py***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建 gp.py***'
- en: If you haven’t already, read through *gp.py*. The essential framework pieces
    are all there, and we won’t discuss every line, so it will help to be familiar
    with it before we begin.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有阅读过 *gp.py*，请先浏览一遍。所有基本的框架部分都在那里，我们不会讨论每一行，所以在开始之前了解它将会有所帮助。
- en: The code imports all the framework components from the earlier curve fitting
    exercise; defines some helper functions (`GetData`, `Number StrExpression`) and
    the objective function class before the main code, which interprets the command
    line; constructs framework objects; and runs the search. Let’s review `Number`
    and the objective function class here. The main code mirrors that of the curve
    fitting code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 代码导入了之前曲线拟合练习中的所有框架组件；在主代码之前定义了一些辅助函数（`GetData`、`Number StrExpression`）和目标函数类，这些代码解释命令行；构造框架对象；并运行搜索。让我们在这里回顾
    `Number` 和目标函数类。主代码与曲线拟合代码相似。
- en: 'The `Number` function transforms particle values in [0, 1) to the range specified
    on the command line when *gp.py* is executed. Specifically:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number` 函数将粒子值从 [0, 1) 转换为在执行 *gp.py* 时命令行上指定的范围。具体而言：'
- en: '[PRE7]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It’s a direct implementation of the previous equation with `gmin` and `gmax`
    being the limits from the command line. These limits restrict the range of possible
    constants available to the evolved code; therefore, some experimentation might
    be necessary to find reasonable limits. For example, if you run a search and see
    constants at the limits, the specified range is likely too small, so double the
    size and try again. Remember, swarm intelligence and evolutionary algorithms are
    stochastic and heuristic. Parameters controlling their operation abound and must
    often be managed to produce good results.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对前面方程的直接实现，`gmin` 和 `gmax` 是命令行上传递的限制。这些限制约束了进化代码可用的常数范围；因此，可能需要一些实验来找到合理的限制。例如，如果你运行搜索并看到常数达到了限制，那么指定的范围可能太小，可以将其大小加倍再试一次。请记住，群体智能和进化算法是随机的和启发式的。控制它们操作的参数非常多，通常需要管理这些参数以获得好的结果。
- en: 'A successful swarm search utilizes an objective function that drives the swarm
    toward good solutions, here a piece of code minimizing the MSE between the known
    data points and the output of the code at those data points. Therefore, our next
    port of call is the objective function class, `Objective`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一次成功的群体搜索利用一个目标函数，引导群体朝着好的解决方案前进，这里是通过一段代码最小化已知数据点与这些数据点输出结果之间的均方误差（MSE）。因此，我们接下来的关注点是目标函数类
    `Objective`：
- en: '[PRE8]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are two methods, a constructor and `Evaluate`. The constructor keeps the
    data points and the number limits passed on the command line. It also initializes
    `fcount`, which tracks the number of times the objective function is evaluated.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该类有两个方法，一个是构造函数，另一个是 `Evaluate`。构造函数保存数据点和命令行传递的数字限制。它还初始化了 `fcount`，用于追踪目标函数被评估的次数。
- en: The `Evaluate` method accepts a particle position (`p`) and passes the *x*-coordinate
    of the data points through it to generate output vector `y`. It then returns the
    MSE between `y` and `self.y` as the objective function value.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Evaluate` 方法接受粒子位置（`p`），并通过它传递数据点的 *x* 坐标，生成输出向量 `y`。然后，它返回 `y` 和 `self.y`
    之间的均方误差（MSE）作为目标函数值。'
- en: Not every piece of code represented by a particle position is valid. It’s likely,
    especially early on in the search, that the randomly generated particle positions
    become failing blocks of code because they try impossible things like extracting
    values from an empty stack or dividing by zero. The NaN check in `Evaluate` captures
    such cases and ensures that a very high objective function value is returned.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是每个由粒子位置表示的代码都是有效的。尤其是在搜索初期，随机生成的粒子位置可能会变成失败的代码块，因为它们尝试做一些不可能的操作，比如从空栈中提取值或除以零。`Evaluate`
    中的 NaN 检查捕捉到这些情况，并确保返回一个非常高的目标函数值。
- en: The function `Expression` evaluates a particle position as code. It’s given
    the *x* values, the particle position (`p`), and the number range; see [Listing
    4-1](ch04.xhtml#ch04list01).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expression` 函数将粒子位置作为代码进行评估。它接受 *x* 值、粒子位置（`p`）和数字范围；请参见 [Listing 4-1](ch04.xhtml#ch04list01)。'
- en: '[PRE9]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 4-1: Interpreting a particle position as code*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-1：将粒子位置解释为代码*'
- en: '[Listing 4-1](ch04.xhtml#ch04list01) is the heart of *gp.py*. First, there
    is an embedded function, `BinaryOp` ➊, which implements all binary operations
    like addition and exponentiation. The stack (`s`), a standard Python list, is
    popped twice to get the operands. Note the order: if we want *a* – *b* and *b*
    is the top stack item, then the first pop returns *b*, not *a*. The second argument
    indexes the operation. A more compact implementation might use Python’s `eval`
    function. Still, we need to be as fast as possible, so we opt for the verbose
    but significantly faster compound `if`.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-1](ch04.xhtml#ch04list01)是*gp.py*的核心部分。首先，有一个嵌套函数`BinaryOp` ➊，它实现了所有二进制操作，如加法和指数运算。栈（`s`）是一个标准的Python列表，弹出两次以获取操作数。注意顺序：如果我们想要*a*
    - *b*，并且*b*是栈顶项，那么第一次弹出的是*b*，而不是*a*。第二个参数决定了操作类型。一种更紧凑的实现可能会使用Python的`eval`函数。然而，我们需要尽可能快，所以我们选择了冗长但显著更快的复合`if`结构。'
- en: The code initializes the stack with *x* ➋ and then begins a loop over the components
    of the particle position (`expr`) ➌. Everything is inside a `try` block to catch
    any errors. Errors return `bad` as the function value.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用*x* ➋初始化栈，然后开始对粒子位置（`expr`）的组件进行循环 ➌。所有内容都在`try`块内，以捕获任何错误。错误将返回`bad`作为函数值。
- en: If the particle component is less than 1.0, it pushes a constant, the output
    of `Number`, on the stack. Otherwise, the integer part of the value determines
    the operation. If less than 7, the appropriate binary operation is performed;
    otherwise, the instruction is either negation, push *x*, or halt, which breaks
    out of the loop, thereby ignoring the remaining particle components. Finally,
    the function returns the top stack item, if there is one, as the function value
    ➍.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果粒子组件小于1.0，它会将常量`Number`的输出压入栈中。否则，值的整数部分决定了操作。如果小于7，则执行适当的二进制操作；否则，指令是取反、推送*x*或停止，后者会跳出循环，从而忽略剩余的粒子组件。最后，函数返回栈顶项（如果有的话）作为函数值
    ➍。
- en: 'The remainder of *gp.py* is straightforward: parse the command line, create
    framework objects (`Bounds`, `RandomInitializer`, `Objective`), then, with the
    proper swarm object, call `Optimize` and `Results` to report how well the search
    went. If a final plot name is given, we generate it showing the data points and
    the fit.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*gp.py*的其余部分很简单：解析命令行，创建框架对象（`Bounds`、`RandomInitializer`、`Objective`），然后，使用适当的群体对象，调用`Optimize`和`Results`来报告搜索的效果。如果给定了最终的图表名称，我们将生成图表，展示数据点和拟合结果。'
- en: 'Our curve fitting code used bare-bones PSO. This code uses both bare-bones
    and canonical PSO:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的曲线拟合代码使用了基本的PSO。该代码同时使用了基本PSO和经典PSO：
- en: '[PRE10]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can differentiate between the two by passing either `PSO` or `BARE` on the
    command line. Note that PSO uses options we haven’t seen before. One is `LinearInertia`,
    which linearly decreases *ω* during the search from 0.9 down to 0.4\. Inertia
    is the coefficient multiplying the previous iteration’s velocity, per particle.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在命令行中传递`PSO`或`BARE`来区分这两者。请注意，PSO使用了一些我们之前没有见过的选项。其中之一是`LinearInertia`，它在线性下降的过程中将*ω*从0.9减少到0.4。惯性是每个粒子上一个迭代的速度与当前速度的乘积系数。
- en: There are three additional options. Two are `ring` and `neighbors`, which work
    together. A variation of canonical PSO includes the concept of a *neighborhood*,
    a collection of particles that coordinate with each other. The practical effect
    of a neighborhood is to replace the global best position, ***g***, with a neighborhood
    best. The arrangements of particles into neighborhoods is referred to as a *topology*.
    The `PSO` class supports a ring topology—the simplest. Imagine the particles forming
    a circle; then, for any particle, the `neighbors` particles to the left and right
    form the current particle’s neighborhood. As a challenge, try to modify *PSO.py*
    to accommodate von Neumann neighborhoods, which is frequently the best performing
    topology. Careful searching online will show you what a von Neumann topology entails.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个额外的选项。两个是`ring`和`neighbors`，它们一起工作。经典PSO的一种变体包括*邻域*的概念，邻域是相互协调的粒子集合。邻域的实际效果是将全局最佳位置***g***替换为邻域最佳位置。粒子安排成邻域的方式被称为*拓扑结构*。`PSO`类支持环形拓扑结构——最简单的一种。可以想象粒子形成一个圆圈；然后，对于任何粒子，左侧和右侧的`neighbors`粒子构成当前粒子的邻域。作为挑战，试着修改*PSO.py*以适应冯·诺依曼邻域，这是性能最佳的拓扑之一。通过在网上仔细搜索，你会发现冯·诺依曼拓扑的详细信息。
- en: The final new option is `vbounds`, which sets limits on the maximum velocity
    per particle component, much as `bounds` sets spatial limits on where the swarm
    can move within the search space. In the velocity case, `enforce` is `clip` to
    keep velocity components at the limits instead of resampling along that dimension.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的新选项是`vbounds`，它设置了每个粒子组件的最大速度限制，类似于`bounds`设置粒子群在搜索空间中的位置限制。在速度的情况下，`enforce`是`clip`，以保持速度组件在限制内，而不是沿该维度重新采样。
- en: The number of adjustable parameters makes it sometimes tricky to set up a successful
    canonical PSO search, even with neighborhoods. As a result, these values are more
    what you’d call “guidelines” than actual rules.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 可调参数的数量有时使得设置一个成功的标准PSO搜索变得棘手，即使有邻域的支持也是如此。因此，这些值更像是“指导方针”而不是实际规则。
- en: Now, let’s put *gp.py* through its paces to see what it can (and cannot) do
    for us.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下*gp.py*，看看它能为我们做什么（以及不能做什么）。
- en: '***Evolving Fit Functions***'
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***演化拟合函数***'
- en: Let’s put *gp.py* to the test with several experiments.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个实验来测试一下*gp.py*。
- en: '**Fitting a Line**'
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**拟合一条直线**'
- en: 'To run *gp.py*, use a command line like this one:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行*gp.py*，可以使用如下命令行：
- en: '[PRE11]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Illegal operations will likely happen early on in the search, so I recommend
    ignoring runtime errors by adding `-W ignore`. The command line uses the input
    file *x1_2n.txt*, which is the noisy line mentioned previously. Numbers are limited
    to [–5, 5), and the maximum program length is 22 instructions, though `halt` usually
    appears earlier.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 非法操作很可能会在搜索的早期发生，因此我建议通过添加`-W ignore`来忽略运行时错误。命令行使用了输入文件*x1_2n.txt*，这就是之前提到的嘈杂直线。数值被限制在[–5,
    5)范围内，程序的最大长度是22条指令，尽管`halt`通常会出现在更早的时候。
- en: 'The swarm has 20 particles and runs for 10,000 iterations using bare-bones
    PSO and the MINSTD randomness source. The result is written to *plot.png* with
    the code itself displayed:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子群有20个粒子，并运行10,000次迭代，使用基础的PSO算法和MINSTD随机数源。结果会写入*plot.png*，并且代码本身会显示出来：
- en: '[PRE12]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that `halt` appears as the ninth instruction (the initial `push(x)` is
    always present, so it’s not counted).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`halt`出现在第九条指令中（最初的`push(x)`始终存在，因此不算在内）。
- en: '[Figure 4-4](ch04.xhtml#ch04fig04) shows the original data points along with
    the fit function output.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-4](ch04.xhtml#ch04fig04)展示了原始数据点以及拟合函数的输出。'
- en: '![Image](../images/04fig04.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig04.jpg)'
- en: '*Figure 4-4: The evolved fit to a noisy line*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：拟合嘈杂的直线*'
- en: The fit is good, which is encouraging. If we can’t fit a line, we shouldn’t
    expect to fit more complex functions.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 拟合效果很好，这令人鼓舞。如果我们连一条直线都拟合不好，那么就不应该期待能拟合更复杂的函数。
- en: We now have two different solutions to fitting the line, but the evolutionary
    path followed to arrive at a solution was quite different. The first solution
    evolved
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了两种不同的拟合直线的方法，但达到解决方案的演化路径完全不同。第一个解决方案是演化得到的
- en: (*x*)(3.00482) + (7.07870 mod – 9.09650) = 3.00482*x* – 2.0178
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: (*x*)(3.00482) + (7.07870 mod – 9.09650) = 3.00482*x* – 2.0178
- en: 'but the second produced:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 但是第二个方案得到了：
- en: '*x* + *x* + *x* – (4.82483 / 2.39118) = 3*x* – 2.01776'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* + *x* + *x* – (4.82483 / 2.39118) = 3*x* – 2.01776'
- en: The second solution added *x* to itself three times instead of multiplying by
    a constant. Both solutions arrived at nearly identical intercepts, not by pushing
    a learned value but by implementing distinct binary operations with two learned
    values.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个解决方案将*x*与自身相加三次，而不是与一个常数相乘。两种解决方案都得到了几乎相同的截距，不是通过推动学习到的值，而是通过实施两个学习到的值的不同二进制操作。
- en: The *data* directory contains several datasets, many that are the output of
    *gpgen.py*, which you can use to create custom datasets, noisy polynomials up
    to degree five. Run *gpgen.py* without arguments to learn how it works. For now,
    let’s use a few of these datafiles to push *gp.py* to the limit.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*data*目录包含多个数据集，其中许多是*gpgen.py*的输出，您可以使用它们创建自定义数据集，生成最多五次幂的嘈杂多项式。运行*gpgen.py*而不带参数可以了解它的工作原理。现在，让我们使用其中的一些数据文件，推动*gp.py*的极限。'
- en: '**Fitting a Quadratic**'
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**拟合一个二次函数**'
- en: We evolved the equation of a line easily enough. What about a quadratic?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很容易就演化出了直线方程。那二次方程呢？
- en: '[PRE13]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For my run, this produced:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，运行结果是：
- en: '[PRE14]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Instructions after `halt` are ignored as they have no effect. I’ll do this consistently
    from now on. The resulting fit is in [Figure 4-5](ch04.xhtml#ch04fig05).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`halt`之后的指令会被忽略，因为它们没有任何效果。从现在开始，我会始终如一地这样做。得到的拟合结果见[图 4-5](ch04.xhtml#ch04fig05)。'
- en: '![Image](../images/04fig05.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig05.jpg)'
- en: '*Figure 4-5: The evolved fit to a noisy quadratic*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：拟合嘈杂的二次函数*'
- en: 'The evolved code is equivalent to:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 演化出的代码等价于：
- en: (*x*² – ^–2.97844) – *x*) – *x*) = *x*² – 2*x* + 2.97844
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: (*x*² – ^–2.97844) – *x*) – *x*) = *x*² – 2*x* + 2.97844
- en: The same dataset given to NumPy’s `polyfit` routine produces
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的数据集提供给 NumPy 的 `polyfit` 例程，结果为：
- en: '*x*² – 2.02*x* + 2.99'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*² – 2.02*x* + 2.99'
- en: giving us growing confidence in the evolutionary search.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们对进化搜索越来越有信心。
- en: '**Fitting a Quartic**'
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**拟合一个四次方程**'
- en: The previous examples all use bare-bones PSO, which seems well suited to this
    task. Let’s try a different dataset, a quartic, along with different algorithms.
    Are all of them equally effective?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子都使用了最基本的PSO，看起来它非常适合这个任务。让我们尝试不同的数据集，一个四次方程，并使用不同的算法。它们的效果是否一样好？
- en: 'Specifically, we’ll fit the points in *x4_-2x3_3x2_-4x_5_50n.txt*, a noisy
    version of the quartic, *y* = *x*⁴ – 2*x*³ + 3*x*² – 4*x* + 5\. The only parameter
    changing from run to run is the optimization algorithm. For example, here’s the
    command line for bare-bones PSO:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将拟合 *x4_-2x3_3x2_-4x_5_50n.txt* 中的点，这是一种四次方程的噪声版本，*y* = *x*⁴ – 2*x*³
    + 3*x*² – 4*x* + 5。唯一从一次运行到下一次运行变化的参数是优化算法。例如，这里是最基本的PSO命令行：
- en: '[PRE15]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To use differential evolution, change `bare` to `DE` and run again. We’ll examine
    the results for a single run of each algorithm.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用差分进化算法，只需将 `bare` 改为 `DE` 并重新运行。我们将查看每个算法的单次运行结果。
- en: 'The framework is designed for clarity, not speed. Since each particle evaluates
    the objective function independently of the others, opportunities for parallelization
    abound. Unfortunately, we take advantage of none of them, so patience is required
    to replicate the search for every algorithm: DE, bare-bones PSO, canonical PSO,
    Jaya, GA, and RO. Also, the framework does not use seed values, so your run of
    the code will produce different, though likely similar, output.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架的设计注重清晰性，而非速度。由于每个粒子独立评估目标函数，因此有很多并行化的机会。不幸的是，我们没有利用这些机会，因此需要耐心来复制每个算法的搜索过程：DE、最基本的PSO、典型PSO、Jaya、GA
    和 RO。此外，框架不使用种子值，因此你运行的代码将产生不同的输出，但可能相似。
- en: '[Figure 4-6](ch04.xhtml#ch04fig06) displays the fit for each algorithm, from
    DE on the upper left to RO on the lower right.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-6](ch04.xhtml#ch04fig06) 显示了每个算法的拟合情况，从左上角的DE到右下角的RO。'
- en: '![Image](../images/04fig06.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/04fig06.jpg)'
- en: '*Figure 4-6: The fits for each algorithm*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：每个算法的拟合结果*'
- en: It’s evident that not every algorithm hit the mark. [Table 4-3](ch04.xhtml#ch04tab03)
    shows us the equivalent equations they generated.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，并非每个算法都达到预期的效果。[表 4-3](ch04.xhtml#ch04tab03) 显示了它们生成的等效方程。
- en: '**Table 4-3:** The Fit Equations Evolved by Each Algorithm'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-3：** 每个算法进化得到的拟合方程'
- en: '| **Algorithm** | **Equivalent equation** |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **等效方程** |'
- en: '| --- | --- |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| NumPy | *y* = 1.01*x*⁴ – 2.01*x*³ + 2.76*x*² – 3.34*x* + 5.76 |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| NumPy | *y* = 1.01*x*⁴ – 2.01*x*³ + 2.76*x*² – 3.34*x* + 5.76 |'
- en: '| Differential evolution | *y* = *x*⁴ – 2.19254*x*³ + 3*x*² |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 差分进化 | *y* = *x*⁴ – 2.19254*x*³ + 3*x*² |'
- en: '| Bare-bones PSO | *y* = *x*⁴ – 2.23835*x*³ |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 最基本PSO | *y* = *x*⁴ – 2.23835*x*³ |'
- en: '| Canonical PSO | *y* = *x*^(4.09896) |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 典型PSO | *y* = *x*^(4.09896) |'
- en: '| Jaya | *y* = –*x*³ + 19.36026*x*² |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| Jaya | *y* = –*x*³ + 19.36026*x*² |'
- en: '| GA | *y* = 21.78212*x*² |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| GA | *y* = 21.78212*x*² |'
- en: '| RO | ![Image](../images/f0128-01.jpg) |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| RO | ![图片](../images/f0128-01.jpg) |'
- en: The first equation is the fit returned by NumPy’s `polyfit` routine. The data
    was generated from a quartic, so we expect the NumPy fit to be the best, and we’ll
    treat it as the gold standard.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方程是 NumPy 的 `polyfit` 例程返回的拟合结果。数据是从四次方程生成的，所以我们预计 NumPy 的拟合结果是最好的，我们将其视为黄金标准。
- en: Differential evolution produced the best-evolved fit function. Compare it to
    the NumPy fit. The DE fit recovered the first three terms of the polynomial, with
    coefficients in the same ballpark as the NumPy fit. Similarly, bare-bones PSO
    recovered the first two terms of the polynomial. Canonical PSO recovered only
    the first term, *x*⁴ (or thereabouts).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 差分进化算法（DE）得到了最优拟合的函数。将其与 NumPy 的拟合结果进行比较。DE 的拟合恢复了多项式的前三项，系数与 NumPy 的拟合结果差不多。类似地，最基本的PSO恢复了多项式的前两项。典型的PSO仅恢复了第一项，*x*⁴（或接近）。
- en: Jaya produced an exciting result. The two terms fight against each other, but
    their sum becomes a crude approximation of the dataset. As an exercise, try plotting
    –*x*³, 19.36*x*², and their sum to see what I mean.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Jaya 产生了一个令人兴奋的结果。两个项彼此相互作用，但它们的和成为了数据集的粗略近似。作为练习，试着绘制 –*x*³，19.36*x*² 及其和，看看我的意思。
- en: Both the GA and RO produced inferior output. The GA ended up with a quadratic,
    and whatever RO created fits only the left-hand set of dataset points, *x* < –3
    or so.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: GA 和 RO 都产生了较差的输出。GA 最终得到了一个二次方程，而RO无论如何拟合的只是左侧的数据集点，*x* < –3 左右。
- en: 'These results are from single runs. We know that swarm optimization algorithms
    are stochastic and vary from run to run. Perhaps we’re being a bit unfair, then.
    I ran the Jaya search five more times; here are the resulting equivalent equations:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果来自单次运行。我们知道，群体优化算法是随机的，并且每次运行的结果会有所不同。也许我们这样做有点不公平。于是我又进行了五次Jaya搜索，以下是得到的等效方程：
- en: '![Image](../images/f0129-01.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0129-01.jpg)'
- en: The results imply that Jaya isn’t converging well to a local minimum. It either
    captures the essential *x*⁴ aspect of the data or stops at a quadratic.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，Jaya算法并未很好地收敛到局部最小值。它要么捕捉到了数据的* x *⁴特征，要么停留在二次项上。
- en: Jaya isn’t the only algorithm we might be selling short. The GA and RO produced
    inferior results on our initial runs. What if we increase the swarm size and churn
    for more iterations? Intuitively, for these algorithms, it might make sense to
    do this. The more particles searching on their own, the more likely we’ll find
    a good position in the search space, so a larger swarm seems sensible for RO.
    For the GA, a larger population increases the size of the gene pool, so we should
    get better performance as well, much like the genetic drift example from [Chapter
    3](ch03.xhtml) where the larger population was better able to adapt to the environment
    after a catastrophe.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Jaya并不是唯一可能被低估的算法。GA和RO在初始运行时产生了较差的结果。如果我们增加群体规模并进行更多迭代，会怎么样呢？直观地说，这些算法可能确实适合这样做。搜索粒子越多，我们就越有可能在搜索空间中找到好的位置，因此RO使用较大的群体是有道理的。对于GA来说，较大的种群增加了基因库的规模，因此我们也应当能够获得更好的性能，这就像[第3章](ch03.xhtml)中基因漂变的例子，较大种群能在灾难发生后更好地适应环境。
- en: Running a swarm of 125 particles for 150,000 iterations using RO produced a
    function calculating 21.54962*x*², which is not encouraging as RO isn’t even capturing
    the quartic nature of the dataset. A run of the GA with 512 particles (organisms)
    for 30,000 iterations requiring all organisms to breed with a member of the best
    performing 20 percent (`top=0.2`) produced [Figure 4-7](ch04.xhtml#ch04fig07),
    which contains a graph showing the fit.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RO算法运行125个粒子的群体，进行150,000次迭代，得到了一个计算公式为21.54962*x*²的函数，但这并不令人鼓舞，因为RO甚至没有捕捉到数据集的四次项特性。使用512个粒子（有机体）运行GA算法，进行30,000次迭代，并要求所有有机体与表现最好的20%成员（`top=0.2`）进行繁殖，得到了[图4-7](ch04.xhtml#ch04fig07)，其中包含显示拟合结果的图表。
- en: '![Image](../images/04fig07.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig07.jpg)'
- en: '*Figure 4-7: The genetic algorithm’s solution for 512 organisms and 30,000
    generations*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-7：遗传算法对于512个有机体和30,000代的解决方案*'
- en: 'The evolved set of instructions are as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 演化出的指令集如下：
- en: '[PRE16]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The function is quite strange, and used all 22 possible instructions (the initial
    `push(x)` is always present), which is also quite different from the results found
    with other algorithms. The equivalent function is
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数相当奇怪，使用了所有22条可能的指令（初始的`push(x)`始终存在），这与其他算法得到的结果也有很大不同。等效的函数是
- en: '*y* = 23.76431*x*² – 21.60479*x* – 46.13863 – 24.96894(10.10315 mod *x*)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*y* = 23.76431*x*² – 21.60479*x* – 46.13863 – 24.96894(10.10315 mod *x*)'
- en: 'which makes more sense in this form: a quadratic with an additional term using
    modulo, thereby accounting for the strange-looking oscillations on top of the
    general quadratic form.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式更有意义：一个带有额外模运算项的二次函数，从而能够解释在一般二次形式上方出现的奇怪振荡。
- en: '**Fitting a Normal Curve**'
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**拟合正态曲线**'
- en: 'The previous examples attempted to evolve a function to match a polynomial.
    What happens if we try to fit a noisy normal (Gaussian) curve instead? The source
    function, before adding random noise, was:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子试图演化一个函数来匹配一个多项式。如果我们改为拟合一个噪声正态（高斯）曲线，会发生什么呢？在加入随机噪声之前，源函数为：
- en: '![Image](../images/f0131-01.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0131-01.jpg)'
- en: The noisy data points are in *noisy_exp.txt*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 含噪声的数据点在*noisy_exp.txt*中。
- en: I ran three searches, once each for DE, bare-bones PSO, and Jaya. The searches
    all used 25 particles and 20,000 iterations. I restricted numbers to [–25, 25],
    and gave the evolved functions a maximum of 22 instructions.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我进行了三次搜索，分别是DE、简化PSO和Jaya。所有搜索都使用了25个粒子和20,000次迭代。我将数值限制在[–25, 25]之间，并且对演化出的函数限制了最大指令数为22条。
- en: '[Figure 4-8](ch04.xhtml#ch04fig08) shows the resulting fits.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-8](ch04.xhtml#ch04fig08)展示了拟合结果。'
- en: '![Image](../images/04fig08.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/04fig08.jpg)'
- en: '*Figure 4-8: Evolving a function to fit a noisy normal curve*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-8：演化一个函数以拟合噪声正态曲线*'
- en: The DE and bare-bones PSO results are virtually identical and overlap. They
    fit the dataset well. As we’ve seen with other experiments, Jaya gets close but
    doesn’t produce as nice a fit as the others.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: DE 和裸骨 PSO 的结果几乎相同，并且重合。它们很好地拟合了数据集。正如我们在其他实验中看到的，Jaya 接近但没有产生像其他算法那样好的拟合。
- en: So, what were the evolved functions? In this case, not only is the equivalent
    function illustrative, but so is the form of the code, so we’ll consider both
    together; see [Table 4-4](ch04.xhtml#ch04tab04).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，演化出的函数是什么？在这种情况下，不仅等效的函数是具有示范性的，代码的形式也是如此，因此我们将一起考虑这两者；见 [表 4-4](ch04.xhtml#ch04tab04)。
- en: '**Table 4-4:** Comparing the Evolved Programs by Algorithm'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-4:** 按算法比较演化出的程序'
- en: '| **DE** | **Bare-bones PSO** | **Jaya** |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| **DE** | **裸骨 PSO** | **Jaya** |'
- en: '| --- | --- | --- |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `push(x)` | `push(x)` | `push(x)` |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `push(x)` | `push(x)` | `push(x)` |'
- en: '| `push(x)` | `push(x)` | `neg` |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `push(x)` | `push(x)` | `neg` |'
- en: '| `push(0.35484)` | `push(x)` | `push(7.95565)` |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `push(0.35484)` | `push(x)` | `push(7.95565)` |'
- en: '| `push(x)` | `push(2.80857)` | `push(x)` |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `push(x)` | `push(2.80857)` | `push(x)` |'
- en: '| `push(x)` | `push(x)` | `pow` |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `push(x)` | `push(x)` | `pow` |'
- en: '| `mul` | `neg` | `push(x)` |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `mul` | `neg` | `push(x)` |'
- en: '| `pow` | `push(x)` | `neg` |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `pow` | `push(x)` | `neg` |'
- en: '| `halt` | `mul` | `pow` |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `halt` | `mul` | `pow` |'
- en: '|  | `pow` | `halt` |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '|  | `pow` | `halt` |'
- en: '|  | `halt` |  |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '|  | `halt` |  |'
- en: The equivalent function evolved is *y* = 0.35484^(*x*²) (DE), *y* = 2.80857^(–*x*²)
    (bare-bones PSO), and *y* = 7.95565^(–*x*²) (Jaya). Again, the function we’re
    trying to recover from the noisy data is
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 演化出的等效函数是 *y* = 0.35484^(*x*²)（DE），*y* = 2.80857^(–*x*²)（裸骨 PSO），以及 *y* = 7.95565^(–*x*²)（Jaya）。再次强调，我们试图从噪声数据中恢复的函数是
- en: '![Image](../images/f0132-01.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0132-01.jpg)'
- en: where I’ve approximated *e* with the first five digits of its decimal expansion.
    Written this way, it’s clear that the bare-bones PSO search evolved almost exactly
    this function, so we should expect it to fit the data nicely.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里用 *e* 的前五位数字进行了近似。以这种方式写出来，很明显裸骨 PSO 搜索几乎精确地演化出了这个函数，所以我们应该期望它能够很好地拟合数据。
- en: The DE result seems odd at first. It’s an exponential function, but the base
    is 0.35484, not *e*, and the exponent is *x*², not –*x*². However, 1/*e* ≈ 0.36788,
    meaning DE evolved the same function as bare-bones PSO since
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: DE 结果一开始看起来很奇怪。它是一个指数函数，但底数是 0.35484，而不是 *e*，指数是 *x*²，而不是 –*x*²。然而，1/*e* ≈ 0.36788，这意味着
    DE 演化出了与裸骨 PSO 相同的函数，因为
- en: '![Image](../images/f0132-02.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0132-02.jpg)'
- en: and 0.35484 is quite close to 0.36788\. Finally, Jaya had the right idea, but
    didn’t converge to the correct base, 7.95565 > *e*.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 而且 0.35484 相当接近 0.36788。最后，Jaya 有正确的思路，但没有收敛到正确的底数，7.95565 > *e*。
- en: '**Exercises**'
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习**'
- en: 'Swarm algorithm applications are legion. Here are a few things you may wish
    to explore in more detail:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 群体算法的应用非常广泛。以下是你可能希望更详细探索的一些内容：
- en: In the *curves* directory you’ll find a *NIST* directory. It contains example
    curve fit datafiles from the National Institute of Standards and Technology (NIST),
    part of the United States Department of Commerce. I formatted the *.txt* versions
    so that they’ll work with *curves.py*. The original versions end with *.dat*.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *curves* 目录下，你会找到一个 *NIST* 目录。它包含了来自美国国家标准与技术研究院（NIST）的示例曲线拟合数据文件，NIST 是美国商务部的一部分。我已经将
    *.txt* 版本进行了格式化，以便它们能够与 *curves.py* 一起使用。原始版本以 *.dat* 结尾。
- en: These are challenging curve fitting test files meant to test high-performance
    curve fitting routines. Are any of the swarm algorithms up to the challenge? If
    so, which files can be fit, and which fail?
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是具有挑战性的曲线拟合测试文件，旨在测试高性能的曲线拟合程序。是否有任何群体算法能够接受这一挑战？如果可以，哪些文件能够拟合，哪些无法拟合？
- en: The `Results` method of a swarm object returns a dictionary, as we saw throughout
    the chapter. We can track the objective function value as a function of swarm
    iteration by using the `gbest` and `giter` dictionary values. The first is a list
    of each new global best objective function value, and the second is a list marking
    the iteration at which that value became the global best.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Results` 方法是群体对象的一部分，返回一个字典，正如我们在本章中所看到的那样。我们可以通过使用 `gbest` 和 `giter` 字典中的值，追踪目标函数值随群体迭代的变化。第一个是每个新的全局最优目标函数值的列表，第二个是标记该值成为全局最优的迭代次数的列表。'
- en: Examine the code in *plot_gbest_giter.py* to learn how to plot these values
    to track the swarm’s learning during a search. Capture the corresponding lists
    for other searches using the examples in the chapter to make similar plots. Do
    the swarms all converge at the same rate for the same problem?
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看*plot_gbest_giter.py*中的代码，了解如何绘制这些值以跟踪群体在搜索过程中的学习。使用本章中的示例捕获其他搜索的相应列表，绘制类似的图表。不同的群体是否在相同问题上以相同的速度收敛？
- en: The file *gaussian.py*, in the *micro* directory, runs a swarm search to minimize
    a two-dimensional function consisting of two inverted normal curves, that is,
    the function is *z* = *f*(*x*, *y*). The file *gaussians.png* shows a 3D plot
    of the function with two minima, one lower than the other. Since the function
    being minimized has two inputs, the search space is two-dimensional, making it
    possible to plot the position of every particle in the swarm and track them as
    they move during the search.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*gaussian.py*文件位于*micro*目录中，执行群体搜索，旨在最小化一个由两个倒转正态曲线构成的二维函数，即函数为*z* = *f*(*x*,
    *y*)。*gaussians.png*文件展示了该函数的三维图，函数有两个最小值，其中一个比另一个低。由于要最小化的函数有两个输入，因此搜索空间是二维的，这使得可以绘制群体中每个粒子的位置，并在搜索过程中追踪它们的移动。'
- en: Run *gaussian.py* without arguments to learn how to run a search and output
    images of the swarm at each step. Then, page through the images to watch the swarm
    search. The known best position is the empty box. The swarm’s current best position
    is the star. Change the algorithm to observe how each converges and traverses
    the space. Do the algorithms search the space in the same way? Do they converge
    on the global minimum, and, if so, at the same rate?
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行*gaussian.py*，不带任何参数，以了解如何进行搜索，并输出每一步群体的图像。然后，翻阅这些图像，观察群体如何搜索。已知的最佳位置是空框，群体当前的最佳位置是星号。修改算法，观察它们如何收敛并遍历空间。不同的算法搜索空间的方式一样吗？它们是否收敛到全局最小值，如果是，收敛的速度一样吗？
- en: The file *GWO.py*, also in the *micro* directory, implements the Grey Wolf Optimizer
    (GWO). GWO is a popular swarm intelligence algorithm, in theory, modeling the
    behavior of wolves as they hunt (I don’t buy it).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GWO.py*文件，也在*micro*目录下，实现了灰狼优化算法（Grey Wolf Optimizer，GWO）。GWO是一种流行的群体智能算法，理论上模拟了狼群狩猎时的行为（我并不认同这一点）。'
- en: Test GWO using *gaussian.py*, then adapt *curves.py* and *gp.py* to use it as
    well. A quick copy-paste is all that’s needed. How does GWO’s performance compare
    to DE, bare-bones PSO, and Jaya? It’s often claimed that GWO has no adjustable
    parameters, like Jaya. This is not strictly true. The `eta` parameter, which defaults
    to 2, can be adjusted, and this sometimes helps the search. If GWO isn’t performing
    well, adjust `eta`, perhaps to 3 or 4, and try again.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用*gaussian.py*测试GWO，然后将*curves.py*和*gp.py*改编为也使用GWO。只需要简单的复制粘贴。GWO的表现如何，与DE、简化版PSO和Jaya相比怎么样？通常有人声称，GWO没有可调参数，就像Jaya一样。这并不完全正确。`eta`参数，默认值为2，是可以调整的，有时调整它有助于搜索。如果GWO表现不好，可以调整`eta`，例如设置为3或4，再试一次。
- en: Consider the code in *MiCRO.py*, also in the *micro* directory. It implements
    a tongue-in-cheek swarm algorithm loosely based on grazing cattle that I call
    *Minimally Conscious Random Optimization*. It’s meant to show how easy it is to
    create a “novel,” “nature-inspired” swarm algorithm. The idea behind MiCRO is
    that the swarm is a herd of cattle, mindlessly grazing in complete ignorance of
    each other. With a set probability on any iteration, an animal might look up and
    consider another animal’s position that’s better than its own. If this happens,
    the animal jumps to the region around the better-off neighbor and continues to
    graze. So, the algorithm is RO with a slight probability of noticing a better
    performing neighbor; the swarm is *minimally conscious*.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑一下*MiCRO.py*中的代码，它也位于*micro*目录下。这个代码实现了一种带有讽刺意味的群体算法，灵感来源于放牧的牛群，我称之为*最小意识随机优化*（Minimally
    Conscious Random Optimization）。它旨在展示如何轻松地创建一个“新颖的”，“受自然启发”的群体算法。MiCRO背后的理念是，群体就像是一群牛，它们在完全无视彼此的情况下，毫无目的地放牧。每次迭代时，以一定的概率，某只动物可能会抬头，考虑另一个位置比它自己的位置更好。如果发生这种情况，这只动物就会跳到那个表现更好的邻居周围的区域，并继续放牧。所以，这个算法是RO（随机优化），但有一个轻微的概率能够注意到表现更好的邻居；因此，群体是*最小意识的*。
- en: Explore how MiCRO performs using *gaussian.py*, then invent your own swarm algorithm
    using the code in *RO.py* and *MiCRO.py* as guides. Does your algorithm work?
    Does it work well? Is it really inspired by nature, or is the nature “inspiration”
    an after-the-fact justification?
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用*gaussian.py*探索MiCRO的表现，然后利用*RO.py*和*MiCRO.py*中的代码作为指南，发明你自己的群体算法。你的算法有效吗？表现好不好？它真的是受自然启发的吗，还是这种“自然启发”只是事后的一种辩解？
- en: The code evolved by *gp.py* is restricted to arithmetic operations plus powers
    and modulo. Add sine, cosine, and tangent as available operators. Each consumes
    one item from the stack and returns one item to the stack.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*gp.py* 演化出的代码仅限于算术运算、幂运算和取模运算。请添加正弦、余弦和正切运算符作为可用操作符。每个操作符从栈中取出一个项，并返回一个项到栈中。'
- en: Try to fit the *cos.txt*, *sin.txt*, and *tan.txt* datasets in the *data* directory.
    Can the swarm algorithms do it?
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试拟合 *cos.txt*、*sin.txt* 和 *tan.txt* 数据集，这些文件位于 *data* 目录下。群体算法能做到吗？
- en: Recent work has demonstrated that GWO, along with several other popular nature-inspired
    algorithms, is not novel at all, but is older PSO ideas wrapped in often strained
    metaphors. That being the case, it’s fair to wonder why I included GWO here. The
    emphasis in this book is on practicality and ease of application. GWO is popular
    and works in terms of providing solutions to problems. In that sense, it doesn’t
    matter whether it’s novel. For the larger optimization field, it’s critically
    important to understand what is novel and what is not. I suspect, in the end,
    that many of the myriads of nature-inspired algorithms will prove to be alternate
    takes on well-known approaches. But, if GWO works, then it works, so we’ll keep
    it in our small collection of algorithms at the risk of alienating genuine optimization
    researchers.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的研究表明，GWO（灰狼优化算法）与其他几种流行的自然启发算法完全不新颖，它们不过是将旧的粒子群优化（PSO）思想包装在常常牵强的比喻中。既然如此，难免会有人好奇我为什么会把GWO列在这里。本书的重点是实用性和易于应用。GWO很受欢迎，并且在提供问题解决方案方面表现良好。从这个角度看，是否新颖并不重要。对于更广泛的优化领域，理解什么是新颖的，什么不是，至关重要。我怀疑，最终，许多自然启发算法会证明它们只是对已有方法的另类演绎。但是，如果GWO有效，那就有效，所以我们将它保留在我们的小算法集合中，尽管这可能会让真正的优化研究者感到不满。
- en: The file *nature-inspired_algorithms.pdf* lists dozens of nature- and physics-inspired
    swarm optimization algorithms. The list is by no means exhaustive.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *nature-inspired_algorithms.pdf* 列出了几十种自然启发和物理启发的群体优化算法。这个列表并不是详尽无遗的。
- en: '**Summary**'
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'This chapter introduced us to swarm intelligence and evolutionary algorithms.
    We used a software framework to develop two applications: one to fit data to a
    known functional form, that is, traditional curve fitting, and one to evolve code
    from scratch to implement a best fit function. We learned how to use the framework
    and explored each of the swarm algorithms to develop our intuition about how they
    work and are best applied. Each swarm algorithm critically depends on randomness,
    from the initial configuration of the particles to each update step that moves
    the particles throughout the search space.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了群体智能和进化算法。我们使用软件框架开发了两个应用程序：一个是将数据拟合到已知的函数形式，即传统的曲线拟合，另一个是从头开始演化代码以实现最佳拟合函数。我们学习了如何使用框架，并通过探索每种群体算法来发展直觉，了解它们是如何工作的，以及如何最好地应用。每种群体算法都严重依赖于随机性，从粒子初始化配置到每个更新步骤，它们都会在搜索空间中移动粒子。
- en: The experiments of this chapter fit data to functions by either locating the
    best parameters for a known functional form or evolving the function from scratch.
    Both attempts were successful, though not every algorithm performed equally well.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的实验通过定位已知函数形式的最佳参数或从头开始演化函数来拟合数据。两种尝试都取得了成功，尽管并不是每个算法的表现都同样出色。
- en: DE proved an excellent match to these tasks, further justifying it as a goto
    algorithm. However, I was surprised to see bare-bones PSO do so well. Canonical
    PSO wasn’t as effective, but it has more parameters to tweak, so it might be made
    better with some experimentation (you can adjust *c*[1], *c*[2], *ω*, the inertia
    parameter change over iterations, and so on).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: DE（差分进化）证明非常适合这些任务，进一步证明了它作为常用算法的价值。然而，我很惊讶看到最简单的PSO表现得这么好。标准PSO并没有那么有效，但它有更多的参数可以调整，因此可能通过一些实验来改进（你可以调整
    *c*[1]、*c*[2]、*ω*，即惯性参数的变化以及其他参数）。
- en: Jaya wasn’t a complete disappointment, but it performed similarly to other places
    where I’ve used it—not particularly good or bad. It was, at times, able to recover
    the essence of the functional form, but not the particulars, even allowing for
    many iterations. As a final example, I ran a search to fit the noisy normal function
    one more time using Jaya and 120,000 iterations, six times as many as before.
    The result was a worse fit than the first run with an equivalent function of
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Jaya 算法并非完全令人失望，但其表现与我在其他地方使用时相似——既不特别好也不特别差。它有时能够恢复函数形式的本质，但不能恢复其具体细节，即使允许多次迭代。作为最终的例子，我再次使用
    Jaya 算法运行了一个搜索，以拟合噪声正态函数，并进行了 120,000 次迭代，是之前的六倍。结果比第一次运行的拟合更差，后者的函数是
- en: '![Image](../images/f0135-01.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0135-01.jpg)'
- en: which looks vaguely similar to a normal curve but does not fit the data well.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数看起来与正态曲线有些相似，但并未很好地拟合数据。
- en: RO is not, strictly speaking, a swarm algorithm because the particles don’t
    influence each other. Still, the examples here, combined with experience in other
    areas, make RO worth trying in many cases. We’ll encounter RO again in [Chapter
    5](ch05.xhtml).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，RO（重置优化）并不是一种群体算法，因为粒子之间并不相互影响。不过，结合这里的示例和在其他领域的经验，RO 在许多情况下仍值得尝试。我们将在[第5章](ch05.xhtml)中再次遇到
    RO。
- en: Curve fitting is not the GA’s cup of tea. We learned in [Chapter 3](ch03.xhtml)
    that the GA is effective when simulating natural selection and genetic drift.
    Also, we barely explored some of its parameters, such as the fraction of top breeding
    organisms (`top`) or the particular mutation and crossover probabilities (*F*
    and *CR*, respectively).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线拟合并不是遗传算法（GA）的强项。我们在[第3章](ch03.xhtml)中了解到，当模拟自然选择和基因漂变时，遗传算法是有效的。此外，我们几乎没有深入探讨它的一些参数，比如顶级繁殖有机体的比例（`top`）或特定的变异和交叉概率（分别是*F*和*CR*）。
- en: We’re not through with swarm algorithms. Let’s leave curves and data-sets behind
    to apply swarm techniques to other areas, like image processing and in combination
    with a simulation.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有结束对群体算法的探讨。让我们暂时抛开曲线和数据集，将群体技术应用到其他领域，比如图像处理，或与仿真相结合。
