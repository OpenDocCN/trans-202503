- en: Chapter 4. Procedures
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章 程序
- en: 'This chapter explains how you can take a “divide and conquer” approach to programming.
    Rather than build your programs as one big piece, you’ll be able to write separate
    procedures that you then put together. Using procedures will make your programs
    both easier to write and easier to test and debug. In this chapter, you’ll learn
    how to:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释如何通过“分而治之”的方法进行编程。与其将程序作为一个大块来构建，不如编写单独的过程（函数），然后将它们组合在一起。使用过程将使得编写程序更简单，测试和调试也更容易。在本章中，你将学习如何：
- en: Use message broadcasting to coordinate the behavior of many sprites
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息广播来协调多个精灵的行为
- en: Use message broadcasting to implement procedures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息广播来实现过程
- en: Use the “build your own block” feature of Scratch 2
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scratch 2的“自定义模块”功能
- en: Use structured programming techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用结构化编程技术
- en: Most of the applications we’ve developed so far contain only one sprite, but
    most applications require multiple sprites that work together. An animated story,
    for example, might have several characters as well as different backgrounds. We
    need a way to synchronize the sprites’ assigned jobs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们开发的大多数应用程序只包含一个精灵，但大多数应用程序需要多个精灵协同工作。例如，一个动画故事可能有几个角色以及不同的背景。我们需要一种方法来同步精灵分配的任务。
- en: In this chapter, we’ll use Scratch’s message-broadcasting mechanism to coordinate
    work among several sprites (this was the only way to implement procedures in the
    previous version of Scratch). We’ll then discuss how to use Scratch 2’s “custom
    blocks” feature to structure large programs as smaller, more manageable pieces
    called *procedures*. A procedure is a sequence of commands that performs a specific
    function. For example, we can create procedures that cause sprites to draw shapes,
    perform complex computations, process user input, sequence musical notes, manage
    games, and do many other things. Once created, these procedures can serve as building
    blocks for constructing all sorts of useful applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Scratch的消息广播机制来协调多个精灵之间的工作（这是在Scratch的前一个版本中实现过程的唯一方式）。接着我们将讨论如何使用Scratch
    2的“自定义模块”功能，将大型程序结构化为较小、更易管理的部分，这些部分被称为*过程*。过程是一系列执行特定功能的命令。例如，我们可以创建过程来让精灵绘制图形、进行复杂的计算、处理用户输入、排列音乐音符、管理游戏等。创建完成后，这些过程可以作为构建各种有用应用程序的积木。
- en: Message Broadcasting and Receiving
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息广播与接收
- en: So how does the broadcast system in Scratch work in practice? Any sprite can
    broadcast a message (you can call this message anything you like) using the **broadcast**
    or **broadcast and wait** blocks (from the *Events* palette) shown in [Figure 4-1](ch04.html#you_can_use_the_message-broadcasting_and
    "Figure 4-1. You can use the message-broadcasting and receiving blocks to coordinate
    the work of multiple sprites."). This broadcast triggers all scripts in all sprites
    (including the broadcasting sprite itself) that begin with a matching **when I
    receive** trigger block. All sprites hear the broadcast, but they’ll only act
    on it if they have a corresponding **when I receive** block.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Scratch中的广播系统如何在实践中工作呢？任何精灵都可以使用**广播**或**广播并等待**模块（来自*事件*面板）（见[图4-1](ch04.html#you_can_use_the_message-broadcasting_and
    "Figure 4-1. You can use the message-broadcasting and receiving blocks to coordinate
    the work of multiple sprites.")）广播一条消息（你可以将这条消息命名为任何你喜欢的内容）。此广播会触发所有精灵（包括广播的精灵本身）中以匹配的**当我收到**触发模块开始的所有脚本。所有精灵都会听到广播，但只有在它们有对应的**当我收到**模块时才会响应。
- en: '![You can use the message-broadcasting and receiving blocks to coordinate the
    work of multiple sprites.](httpatomoreillycomsourcenostarchimages2134483.png.jpg)Figure 4-1. You
    can use the message-broadcasting and receiving blocks to coordinate the work of
    multiple sprites.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![你可以使用消息广播和接收模块来协调多个精灵的工作。](httpatomoreillycomsourcenostarchimages2134483.png.jpg)图4-1.
    你可以使用消息广播和接收模块来协调多个精灵的工作。'
- en: 'Consider [Figure 4-2](ch04.html#broadcast_message_is_received_by_all_spr "Figure 4-2. A
    broadcast message is received by all sprites, even by the sprite that sent the
    broadcast."). It shows four sprites: starfish, cat, frog, and bat. The starfish
    broadcasts the `jump` message, and that broadcast is sent to all sprites, including
    itself. In response to this message, both the cat and the frog will execute their
    `jump` scripts. Notice how each sprite jumps in its own way, executing a different
    script. The bat also receives the `jump` message, but it does not act on it because
    it was not told what to do when it receives this message. The cat in this figure
    knows how to `walk` and `jump`, the frog can only `jump`, and the bat was taught
    only to `fly`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[图 4-2](ch04.html#broadcast_message_is_received_by_all_spr "图 4-2. 广播消息被所有角色接收，包括发送广播的角色。")。图中显示了四个角色：海星、猫、青蛙和蝙蝠。海星广播了
    `jump` 消息，这个广播会发送到所有角色，包括它自己。响应这个消息时，猫和青蛙都会执行它们的 `jump` 脚本。注意每个角色以不同的方式跳跃，执行不同的脚本。蝙蝠也接收到了
    `jump` 消息，但由于没有指示它该如何处理该消息，它没有作出反应。图中的猫知道如何 `walk` 和 `jump`，青蛙只能 `jump`，而蝙蝠只被教会了
    `fly`。
- en: The **broadcast and wait** command works like the **broadcast** command, but
    it waits until all message recipients have finished executing their corresponding
    **when I receive** blocks before continuing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**广播并等待**命令与**广播**命令类似，但它会等到所有消息接收者执行完它们对应的**当我接收到**块后才会继续执行。'
- en: '![A broadcast message is received by all sprites, even by the sprite that sent
    the broadcast.](httpatomoreillycomsourcenostarchimages2134485.png.jpg)Figure 4-2. A
    broadcast message is received by all sprites, even by the sprite that sent the
    broadcast.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![广播消息被所有角色接收，包括发送广播的角色。](httpatomoreillycomsourcenostarchimages2134485.png.jpg)图
    4-2. 广播消息被所有角色接收，包括发送广播的角色。'
- en: Sending and Receiving Broadcasts
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送和接收广播
- en: '*SquareApp.sb2*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*SquareApp.sb2*'
- en: 'To demonstrate how message broadcasting and receiving work, let’s create a
    simple application that draws randomly colored squares. When the user clicks the
    left mouse button on the Stage, the Stage will detect this event (using its **when
    this sprite clicked** block) and broadcast a message that you’ll call `Square`
    (you can choose a different name if you want). When the only sprite in this application
    receives this message, it will move to the current mouse position and draw a square.
    Follow these steps to create the application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示消息广播和接收是如何工作的，让我们创建一个简单的应用程序，绘制随机颜色的方块。当用户点击舞台上的左键时，舞台会检测到这个事件（使用其**当此角色被点击**块），并广播一个消息，你可以将其命名为
    `Square`（如果你想，也可以选择其他名称）。当应用程序中的唯一角色接收到这个消息时，它会移动到当前的鼠标位置并绘制一个方块。按照以下步骤创建该应用程序：
- en: Start Scratch and then select **New** from the File menu to start a new application.
    Feel free to change the cat’s costume to anything you like.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Scratch，然后从文件菜单中选择 **新建** 来创建一个新的应用程序。你可以随意更改猫的服装，选择你喜欢的任何样式。
- en: Add the **when I receive** block (from the *Events* palette) to the Scripts
    Area of the sprite. Click the down arrow in this block and select **new message...**
    from the drop-down menu. In the dialog that appears, type `Square` and click **OK**.
    The name of the block should change to **when I receive Square**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向角色的脚本区添加**当我接收到**块（来自*事件*面板）。点击该块中的下拉箭头，并从下拉菜单中选择**新消息...**。在弹出的对话框中，输入 `Square`
    并点击 **确定**。该块的名称应更改为**当我接收到 Square**。
- en: Complete the script as shown in [Figure 4-3](ch04.html#square_message_handler
    "Figure 4-3. The Square message handler"). The sprite first lifts its pen and
    moves to the current mouse position, indicated by the **mouse x** and **mouse
    y** blocks (from the *Sensing* palette). It then picks a random pen color, lowers
    its pen, and draws a square.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成[图 4-3](ch04.html#square_message_handler "图 4-3. 方块消息处理器")所示的脚本。角色首先抬起笔，移动到当前的鼠标位置，这由**鼠标
    x**和**鼠标 y**块（来自*感知*面板）指示。接着它会随机选择一个笔的颜色，放下笔并绘制一个方块。
- en: The sprite is now ready to handle the `Square` message when it is received.
    The script in [Figure 4-3](ch04.html#square_message_handler "Figure 4-3. The Square
    message handler") can be called a *message handler* since its job is to handle
    (or process) a broadcast message.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当接收到 `Square` 消息时，角色准备好处理该消息。 [图 4-3](ch04.html#square_message_handler "图
    4-3. 方块消息处理器")中的脚本可以称为*消息处理器*，因为它的工作是处理（或处理）一个广播消息。
- en: '![The Square message handler](httpatomoreillycomsourcenostarchimages2134487.png.jpg)Figure 4-3. The
    *`Square`* message handler'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![方块消息处理器](httpatomoreillycomsourcenostarchimages2134487.png.jpg)图 4-3. *`Square`*
    消息处理器'
- en: Now, let’s go to the Stage and add the code to broadcast the `Square` message
    in response to a mouse click. Click the Stage in the Sprite List and add the two
    scripts shown in [Figure 4-4](ch04.html#two_scripts_for_the_stage_in_the_square
    "Figure 4-4. The two scripts for the Stage in the Square drawing application").
    The first script clears any pen marks from the Stage when the green flag is clicked.
    The second script, which is triggered when the user clicks the mouse on the Stage,
    uses the **broadcast** block to tell the sprite that it is time to draw.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入舞台并添加代码，以便在鼠标点击时广播`Square`消息。点击精灵列表中的舞台，并添加[图4-4](ch04.html#two_scripts_for_the_stage_in_the_square
    "图4-4。方形绘图应用中舞台的两个脚本")中显示的两个脚本。第一个脚本在点击绿色旗帜时清除舞台上的任何笔迹。第二个脚本在用户点击舞台上的鼠标时触发，使用**广播**模块通知精灵是时候绘制了。
- en: '![The two scripts for the Stage in the Square drawing application](httpatomoreillycomsourcenostarchimages2134489.png.jpg)Figure 4-4. The
    two scripts for the Stage in the *`Square`* drawing application'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![方形绘图应用中舞台的两个脚本](httpatomoreillycomsourcenostarchimages2134489.png.jpg)图4-4。方形绘图应用中舞台的两个脚本'
- en: The application is now complete. To test it, just click the mouse on the Stage.
    It should respond by drawing a square in response to each mouse click.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序现在已完成。要测试它，只需点击舞台上的鼠标。每次点击鼠标时，应用程序应通过绘制一个方形来响应。
- en: Message Broadcasting to Coordinate Multiple Sprites
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向多个精灵广播消息进行协调
- en: '*Flowers.sb2*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*Flowers.sb2*'
- en: To see multiple sprites respond to the same broadcast message, let’s create
    an application that draws several flowers on the Stage in response to a mouse
    click. The Flowers application contains five sprites (named `Flower1` through
    `Flower5`) that are responsible for drawing five flowers on the Stage. Each sprite
    has its own costume, as shown in [Figure 4-5](ch04.html#flowers_uses_these_five_petal_sprites_le
    "Figure 4-5. Flowers uses these five petal sprites (as shown in the Paint Editor).").
    Note how the background of each costume is transparent. Note also the location
    of the center of rotation for each costume (marked with the crossed lines).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到多个精灵响应相同的广播消息，我们将创建一个应用程序，在鼠标点击时在舞台上绘制几个花卉。花卉应用包含五个精灵（命名为`Flower1`到`Flower5`），它们负责在舞台上绘制五朵花。每个精灵都有自己的服装，如[图4-5](ch04.html#flowers_uses_these_five_petal_sprites_le
    "图4-5。花卉使用这五个花瓣精灵（如在画图编辑器中所示）")所示。请注意，每个服装的背景是透明的。同时注意每个服装的旋转中心位置（用交叉线标出）。
- en: '![Flowers uses these five petal sprites (as shown in the Paint Editor).](httpatomoreillycomsourcenostarchimages2134491.png.jpg)Figure 4-5. Flowers
    uses these five petal sprites (as shown in the Paint Editor).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![花卉使用这五个花瓣精灵（如在画图编辑器中所示）](httpatomoreillycomsourcenostarchimages2134491.png.jpg)图4-5。花卉使用这五个花瓣精灵（如在画图编辑器中所示）。'
- en: When a sprite receives a message to draw its flower, it will stamp multiple
    rotated copies of its costume on the Stage, as illustrated in [Figure 4-6](ch04.html#flowers_applicationapostrophes_drawing_p
    "Figure 4-6. The Flowers application’s drawing process (left) and some possible
    flowers (right)"). The figure also shows sample outputs from the flower-drawing
    script we’ll explore next.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个精灵收到绘制其花卉的消息时，它将在舞台上盖上多个旋转的服装副本，如[图4-6](ch04.html#flowers_applicationapostrophes_drawing_p
    "图4-6。花卉应用的绘制过程（左）和一些可能的花卉（右）")所示。该图还展示了我们接下来要探索的花卉绘制脚本的示例输出。
- en: '![The Flowers application’s drawing process (left) and some possible flowers
    (right)](httpatomoreillycomsourcenostarchimages2134493.png.jpg)Figure 4-6. The
    Flowers application’s drawing process (left) and some possible flowers (right)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![花卉应用的绘制过程（左）和一些可能的花卉（右）](httpatomoreillycomsourcenostarchimages2134493.png.jpg)图4-6。花卉应用的绘制过程（左）和一些可能的花卉（右）'
- en: When you click the mouse on the Stage, the Stage detects the mouse click using
    the **when this sprite clicked** block. In response, it clears its background
    and broadcasts a message called `Draw`. All five sprites respond to this message
    by executing a script similar to the one shown in [Figure 4-7](ch04.html#basic_script_used_by_each_of_the_five_sp
    "Figure 4-7. The basic script used by each of the five sprites").
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在舞台上点击鼠标时，舞台会通过**当该精灵被点击时**模块检测到鼠标点击。作为响应，它清除背景并广播一个名为`Draw`的消息。所有五个精灵都会响应这个消息，执行一个类似于[图4-7](ch04.html#basic_script_used_by_each_of_the_five_sp
    "图4-7。所有五个精灵使用的基本脚本")所示的脚本。
- en: '![The basic script used by each of the five sprites](httpatomoreillycomsourcenostarchimages2134495.png.jpg)Figure 4-7. The
    basic script used by each of the five sprites'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![五个角色使用的基本脚本](httpatomoreillycomsourcenostarchimages2134495.png.jpg)图 4-7.
    五个角色使用的基本脚本'
- en: The script starts by assigning random values to the color effect, brightness
    effect, and size to change the appearance of the drawn flower. It then moves to
    a random vertical position on the Stage and draws a flower by stamping rotated
    replicas of its costume.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先为颜色效果、亮度效果和大小赋予随机值，以改变绘制的花朵的外观。然后，它会移动到舞台上的一个随机垂直位置，并通过盖印旋转后的服装副本来绘制一朵花。
- en: Open this application (named *Flowers.sb2*) and run it to see how it works.
    Despite its simplicity, its output is intriguing. I encourage you to design different
    costumes to create different types of flowers. Change the costumes’ centers to
    discover even more interesting flower designs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 打开这个应用程序（名为*Flowers.sb2*），并运行它看看它是如何工作的。尽管它很简单，但它的输出却非常吸引人。我鼓励你设计不同的服装来创建不同类型的花朵。更改服装的中心位置，发现更有趣的花朵设计。
- en: Now that you understand how message broadcasting and receiving work, we’ll move
    on to introduce structured programming as a way to manage the complexity of large
    programs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了消息广播和接收的工作原理，我们将继续介绍结构化编程，作为管理大型程序复杂性的方式。
- en: Creating Large Programs in Small Steps
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以小步骤创建大型程序
- en: The scripts that you’ve written up to this point are relatively short and simple.
    Eventually, you’ll write longer, more complex scripts that contain hundreds of
    blocks, and understanding and maintaining them will become a real challenge.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你到目前为止写的脚本相对较短且简单。最终，你将编写更长、更复杂的脚本，其中包含数百个块，理解和维护它们将成为一个真正的挑战。
- en: An approach known as *structured programming* was developed in the mid-1960s
    to simplify the process of writing, understanding, and maintaining computer programs.
    Instead of having you write a single large program, this approach calls for dividing
    the program into smaller pieces, each of which solves one part of the overall
    task.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一种被称为*结构化编程*的方法是在1960年代中期发展起来的，目的是简化编写、理解和维护计算机程序的过程。这个方法要求将程序分解为较小的部分，每个部分解决整个任务的一部分，而不是让你编写一个单一的大程序。
- en: Consider, for example, the process of baking a cake. You may not think about
    the individual steps as you bake, but the process follows a precise recipe that
    lists the necessary steps. The recipe might include instructions like (1) mix
    4 eggs, 2 oz of flour, and 1 cup of water; (2) put the mixture in a pan; (3) put
    the pan in the oven; (4) bake for 1 hour at 350°F; and so on. In essence, the
    recipe breaks down the problem of baking a cake into distinct logical steps.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下烤蛋糕的过程。你可能在烘烤时不会考虑每一个步骤，但这个过程遵循一个精确的食谱，列出了必要的步骤。食谱可能包括这样的指示：（1）混合4个鸡蛋、2盎司面粉和1杯水；（2）将混合物放入平底锅；（3）将平底锅放入烤箱；（4）在350°F的温度下烘烤1小时；等等。从本质上讲，食谱将烤蛋糕的问题分解为几个明确的逻辑步骤。
- en: Similarly, when you design a solution for your programming problem, it helps
    to break the problem down into manageable, “mind-sized” bites. This approach helps
    you maintain a clear view of the whole program and the relationships between its
    component parts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当你为你的编程问题设计解决方案时，将问题分解成可管理的、适合思考的小块是有帮助的。这种方法帮助你保持对整个程序以及其各个组成部分之间关系的清晰视图。
- en: Consider [Figure 4-8](ch04.html#breaking_a_large_script_into_logical_par "Figure 4-8. Breaking
    a large script into logical parts that each complete one function"), which shows
    a long script that draws a shape on the Stage. You’ll see that you can divide
    this script into smaller logical blocks by function. The first six blocks, for
    example, initialize the sprite. The first **repeat** block draws a square, the
    second draws a triangle, and so on. Using the structured programming approach,
    we can group related blocks together under a representative name to form procedures.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[图 4-8](ch04.html#breaking_a_large_script_into_logical_par "图 4-8. 将一个大型脚本分解为每个完成一个功能的逻辑部分")，它展示了一个在舞台上绘制形状的长脚本。你会看到，可以通过功能将这个脚本分成更小的逻辑块。例如，前六个块用于初始化角色。第一个**repeat**块绘制一个正方形，第二个绘制一个三角形，依此类推。使用结构化编程方法，我们可以将相关的块组合在一起，给它们起一个代表性的名称，以形成过程。
- en: Once we write these procedures, we can call them in a certain sequence to solve
    our programming problem. [Figure 4-8](ch04.html#breaking_a_large_script_into_logical_par
    "Figure 4-8. Breaking a large script into logical parts that each complete one
    function") also shows how the separate procedures are put together to achieve
    the same function as the original script. Clearly, the script that uses procedures
    (right) is more modular and easier to understand than the original (left).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们写好了这些过程，我们就可以按照特定的顺序调用它们来解决编程问题。[图 4-8](ch04.html#breaking_a_large_script_into_logical_par
    "图 4-8. 将一个大脚本分解成每个完成一个功能的逻辑部分")也展示了如何将这些独立的过程组合在一起，实现与原始脚本相同的功能。显然，使用过程的脚本（右边）比原始脚本（左边）更加模块化，且更易于理解。
- en: Procedures can also help you avoid writing the same code twice. If a set of
    commands is executed in several places in a program, you can write a procedure
    that performs these commands and use it instead. This strategy to avoid duplicating
    code is referred to as *code reuse*. Note, for example, how the **Draw square**
    procedure was reused in [Figure 4-8](ch04.html#breaking_a_large_script_into_logical_par
    "Figure 4-8. Breaking a large script into logical parts that each complete one
    function").
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 过程还可以帮助你避免重复编写相同的代码。如果一组命令在程序中的多个地方执行，你可以编写一个过程来执行这些命令，并代替它使用。这种避免重复代码的策略被称为*代码重用*。例如，注意在[图
    4-8](ch04.html#breaking_a_large_script_into_logical_par "图 4-8. 将一个大脚本分解成每个完成一个功能的逻辑部分")中，**绘制正方形**过程是如何被重用的。
- en: 'Using procedures enables you to apply the “divide-and-conquer” strategy to
    solve complex problems. You divide a large and complex problem into subproblems
    and then conquer these simpler problems individually, testing each one in isolation.
    After solving all the subproblems in isolation, you put these pieces together
    in a way that solves the original problem. This is similar to our cake-baking
    strategy: Our recipe divided the problem into well-defined steps, and we executed
    these steps in the correct order to build the final product (our cake).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用过程可以让你应用“分治法”策略来解决复杂问题。你将一个大而复杂的问题分解成多个子问题，然后分别解决这些更简单的问题，逐一测试每个子问题。解决所有子问题后，你将这些部分组合在一起，从而解决原始问题。这类似于我们的蛋糕烘焙策略：我们的食谱将问题分解成了明确定义的步骤，我们按正确的顺序执行这些步骤，最终完成蛋糕。
- en: '![Breaking a large script into logical parts that each complete one function](httpatomoreillycomsourcenostarchimages2134497.png.jpg)Figure 4-8. Breaking
    a large script into logical parts that each complete one function'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![将一个大脚本分解成每个完成一个功能的逻辑部分](httpatomoreillycomsourcenostarchimages2134497.png.jpg)图
    4-8. 将一个大脚本分解成每个完成一个功能的逻辑部分'
- en: At this point, you might ask, “How do we create these procedures?” Before Scratch
    2, you couldn’t build the **Initialize** block shown in [Figure 4-8](ch04.html#breaking_a_large_script_into_logical_par
    "Figure 4-8. Breaking a large script into logical parts that each complete one
    function") and then call it from your script. The only way to emulate procedures
    and add some structure to a program was through Scratch’s *message-broadcasting*
    mechanism. This has changed in Scratch 2, which added the powerful “custom blocks”
    feature.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会问，“我们怎么创建这些过程？”在 Scratch 2 之前，你不能像[图 4-8](ch04.html#breaking_a_large_script_into_logical_par
    "图 4-8. 将一个大脚本分解成每个完成一个功能的逻辑部分")中显示的那样构建**初始化**块，并在脚本中调用它。模拟过程并为程序增加一些结构的唯一方法是通过
    Scratch 的*消息广播*机制。在 Scratch 2 中，这个问题得到了改变，新增了强大的“自定义块”功能。
- en: In this section, we’ll demonstrate the old way of doing things, because that’s
    what you’ll see in scripts created in an older version of Scratch. However, the
    build-your-own-block feature will be explained in the next section, and it will
    be used consistently throughout the rest of the book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将演示旧版的方法，因为这是你在旧版本的 Scratch 中创建的脚本所看到的方式。然而，创建自定义块的功能将在下一节中讲解，并将在本书的其余部分持续使用。
- en: Since sprites receive their own broadcast messages, we can implement procedures
    by having a sprite broadcast a message to itself and perform the desired task
    under the **when I receive** trigger block. We can use the **broadcast and wait**
    block to ensure that our procedures are called in the correct sequence, thus adding
    structure and modularity to our programs. Confused? Let’s see it in action.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于精灵可以接收自己的广播消息，我们可以通过让一个精灵向自己广播消息并在**当我接收到**触发块下执行所需任务来实现过程。我们可以使用**广播并等待**块来确保我们的过程按照正确的顺序被调用，从而为程序增加结构性和模块化。困惑了吗？让我们来看一下实际操作。
- en: Creating Procedures with Message Broadcasting
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用消息广播创建过程
- en: '*Flowers2.sb2*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*Flowers2.sb2*'
- en: We’ll explore how procedures work and how they can improve your code by re-creating
    the Flowers program from earlier.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨过程是如何工作的，以及它们如何通过重新创建之前的“Flowers”程序来改进你的代码。
- en: Open the file *Flowers2.sb2*, which contains the new version of the program.
    The script for the Stage is the same as before (the Stage broadcasts a `Draw`
    message when it detects a mouse click), but this time, our program uses only one
    sprite instead of five. This sprite has five costumes, `leaf1` through `leaf5`,
    and will call a procedure to draw a flower for each costume. Since we have a single
    sprite, we only need one copy of the drawing code (not the five duplicate scripts
    we had in our first version). This makes the program smaller and the code easier
    to understand. When the sprite in this application receives the `Draw` message,
    it executes the script shown in [Figure 4-9](ch04.html#when_the_sprite_receives_the_draw_messag
    "Figure 4-9. When the sprite receives the Draw message, it calls DrawFlower five
    times (in a loop) to draw five flowers.").
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件*Flowers2.sb2*，其中包含程序的新版本。舞台的脚本与之前相同（当它检测到鼠标点击时，舞台会广播`Draw`消息），但这一次，我们的程序只使用一个角色，而不是五个。这个角色有五个服装，`leaf1`到`leaf5`，并将在每个服装上调用一个过程来绘制一朵花。由于我们只有一个角色，因此只需要一份绘图代码（而不是我们第一版中五个重复的脚本）。这使得程序更小，代码也更容易理解。当应用程序中的角色接收到`Draw`消息时，它会执行[图4-9](ch04.html#when_the_sprite_receives_the_draw_messag
    "图4-9. 当角色接收到Draw消息时，它会调用DrawFlower五次（在循环中）来绘制五朵花。")中显示的脚本。
- en: '![When the sprite receives the Draw message, it calls DrawFlower five times
    (in a loop) to draw five flowers.](httpatomoreillycomsourcenostarchimages2134499.png.jpg)Figure 4-9. When
    the sprite receives the *`Draw`* message, it calls *`DrawFlower`* five times (in
    a loop) to draw five flowers.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![当角色接收到Draw消息时，它会调用DrawFlower五次（在循环中）来绘制五朵花。](httpatomoreillycomsourcenostarchimages2134499.png.jpg)图4-9.
    当角色接收到*`Draw`*消息时，它会调用*`DrawFlower`*五次（在循环中）来绘制五朵花。'
- en: The script sets the *x*-coordinate and the costume for drawing the first flower
    and then enters a loop to draw five flowers. On each pass, the loop sets the *y*-coordinate
    for the flower and calls `DrawFlower` by broadcasting a message to itself. This
    call halts the script’s execution until `DrawFlower` is done. When this happens,
    the `Draw` script resumes execution, adjusting the *x*-coordinate and changing
    the costume in preparation for drawing the next flower.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本设置了* x *坐标和服装，用于绘制第一朵花，然后进入一个循环来绘制五朵花。在每次循环中，循环设置花朵的* y *坐标，并通过广播消息调用`DrawFlower`。这个调用会暂停脚本的执行，直到`DrawFlower`完成。当这种情况发生时，`Draw`脚本会恢复执行，调整*
    x *坐标并更改服装，为绘制下一朵花做准备。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can name a procedure anything you like, but I recommend selecting a name
    that reflects that procedure’s purpose. This is especially helpful when you revisit
    a program that you wrote months ago. For example, if you want to show players
    how many points they have in a game, you might create a procedure named* `ShowScore`*.
    Naming this procedure* `Mary` *or* `Alfred` *certainly won’t remind you (or anyone
    else reading your program) what the procedure does.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以随意为过程命名，但我建议选择一个能反映该过程目的的名称。这在你回顾几个月前写的程序时尤其有帮助。例如，如果你想在游戏中展示玩家的分数，你可以创建一个名为*`ShowScore`*的过程。将这个过程命名为*`Mary`*或*`Alfred`*显然不会提醒你（或任何阅读你程序的人）这个过程的作用。*'
- en: The `DrawFlower` procedure is shown in [Figure 4-10](ch04.html#drawflower_procedure
    "Figure 4-10. The DrawFlower procedure"). It sets random values for the color
    effect, brightness, and sprite size before stamping rotated versions of the current
    costume to draw a flower.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawFlower`过程如[图4-10](ch04.html#drawflower_procedure "图4-10. DrawFlower过程")所示。它在绘制一朵花之前设置了颜色效果、亮度和角色大小的随机值，然后将当前服装的旋转版本进行印章操作。'
- en: While the first version of the program contained five sprites and five repeated
    scripts, the second version achieves the same result using a single sprite that
    calls one procedure for drawing all five flowers. Open *Flowers.sb2* and *Flowers2.sb2*
    in two tabs of your browser and compare them. Isn’t the new version much simpler
    to follow? Using procedures lets you make smaller programs that are easier to
    understand and maintain. This will become more beneficial as you write programs
    to perform more complex tasks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的第一个版本中包含了五个精灵和五个重复的脚本，而第二个版本则使用一个精灵调用一个过程来绘制所有五朵花，达到了相同的结果。打开*Flowers.sb2*和*Flowers2.sb2*并在浏览器的两个标签中进行比较。新的版本是不是更简洁易懂？使用过程可以让你编写更小的程序，便于理解和维护。当你编写更复杂任务的程序时，这将变得更加有益。
- en: '![The DrawFlower procedure](httpatomoreillycomsourcenostarchimages2134501.png.jpg)Figure 4-10. The
    *`DrawFlower`* procedure'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![DrawFlower 过程](httpatomoreillycomsourcenostarchimages2134501.png.jpg)图4-10.
    *`DrawFlower`* 过程'
- en: Building Your Own Block
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建你自己的块
- en: As of Scratch 2, you can also create your own custom blocks. After you make
    a custom block, it should appear in the *More Blocks* palette, where you can use
    it as you would any other Scratch block.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从Scratch 2开始，你也可以创建自己的自定义块。创建自定义块后，它应该出现在*更多块*调色板中，你可以像使用其他Scratch块一样使用它。
- en: To show you how to create and use these blocks, we’ll modify the Flowers2 program
    we discussed in the last section to use a custom block for the `DrawFlower` procedure.
    The following steps will guide you through creating this new version of the application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向你展示如何创建和使用这些块，我们将修改上一节中讨论的Flowers2程序，使用一个自定义块来替代`DrawFlower`过程。以下步骤将指导你创建这个新版本的应用程序。
- en: First, open the *Flowers2.sb2* file that you looked at in the previous section.
    Select **File** ▸ **Download to your computer** from the File menu and save the
    file as *Flowers3.sb2*. You can pick a different name if you prefer.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开你在上一节中查看的*Flowers2.sb2*文件。从文件菜单中选择**文件** ▸ **下载到你的计算机**，并将文件保存为*Flowers3.sb2*。如果你愿意，可以选择不同的名称。
- en: Click the thumbnail of the `Flower` sprite to select it. Then select the *More
    Blocks* palette and click **Make a Block**. You should see the dialog shown in
    [Figure 4-11](ch04.html#new_block_dialog_and_the_blocks_that_app "Figure 4-11. The
    New Block dialog and the blocks that appear after creating the DrawFlower custom
    block") (left). Type `DrawFlower` for the block’s name and click **OK**. A new
    function block called **DrawFlower** should appear under the *More Blocks* palette,
    and a **define DrawFlower** block should appear in the Scripts Area as shown in
    the figure (right).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Flower`精灵的缩略图以选择它。然后选择*更多块*调色板，并点击**创建一个块**。你应该会看到如[图4-11](ch04.html#new_block_dialog_and_the_blocks_that_app
    "图4-11. 创建 DrawFlower 自定义块后出现的新块对话框")所示的对话框（左侧）。为该块输入`DrawFlower`作为名称，然后点击**确定**。一个名为**DrawFlower**的新功能块应该会出现在*更多块*调色板中，同时一个**定义
    DrawFlower**块应该会出现在脚本区域，如图中所示（右侧）。
- en: '![The New Block dialog and the blocks that appear after creating the DrawFlower
    custom block](httpatomoreillycomsourcenostarchimages2134503.png.jpg)Figure 4-11. The
    New Block dialog and the blocks that appear after creating the *DrawFlower* custom
    block'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![创建 DrawFlower 自定义块后出现的新块对话框](httpatomoreillycomsourcenostarchimages2134503.png.jpg)图4-11.
    创建 DrawFlower 自定义块后出现的新块对话框'
- en: Detach the script connected to the **when I receive DrawFlower** block and connect
    it to the **define DrawFlower** block, as shown in [Figure 4-12](ch04.html#drawflower_procedure_implemented_as_a_cu
    "Figure 4-12. The DrawFlower procedure implemented as a custom block"). This results
    in a new procedure, called **DrawFlower**, that is implemented as a custom block.
    Delete the **when I receive DrawFlower** block because it is no longer needed.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将与**当我接收到 DrawFlower**块连接的脚本分离，并将其连接到**定义 DrawFlower**块，如[图4-12](ch04.html#drawflower_procedure_implemented_as_a_cu
    "图4-12. 作为自定义块实现的 DrawFlower 过程")所示。这样会创建一个名为**DrawFlower**的新过程，它作为自定义块实现。删除**当我接收到
    DrawFlower**块，因为它不再需要。
- en: '![The DrawFlower procedure implemented as a custom block](httpatomoreillycomsourcenostarchimages2134505.png.jpg)Figure 4-12. The
    *DrawFlower* procedure implemented as a custom block'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![作为自定义块实现的 DrawFlower 过程](httpatomoreillycomsourcenostarchimages2134505.png.jpg)图4-12.
    作为自定义块实现的*DrawFlower*过程'
- en: Now that we’ve created a **DrawFlower** procedure, we just need to call it from
    the `Draw` message handler. Modify the `Draw` message handler as shown in [Figure 4-13](ch04.html#calling_drawflower_from_the_draw_message
    "Figure 4-13. Calling DrawFlower from the Draw message handler"). Note that we
    only replaced the **broadcast DrawFlower and wait** block with our new **DrawFlower**
    custom block.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个**DrawFlower**过程，我们只需要在`Draw`消息处理器中调用它。按照[图4-13](ch04.html#calling_drawflower_from_the_draw_message
    "图4-13. 从Draw消息处理器调用DrawFlower")所示修改`Draw`消息处理器。注意，我们只是将**广播DrawFlower并等待**积木替换为新的**DrawFlower**自定义积木。
- en: '![Calling DrawFlower from the Draw message handler](httpatomoreillycomsourcenostarchimages2134507.png.jpg)Figure 4-13. Calling
    *DrawFlower* from the *`Draw`* message handler'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![从Draw消息处理器调用DrawFlower](httpatomoreillycomsourcenostarchimages2134507.png.jpg)图4-13.
    从*`Draw`*消息处理器调用*DrawFlower*'
- en: The program is now complete, and you can test it. Click the mouse on the Stage
    to verify that the program still works as before. See [Running without Screen
    Refresh](ch04.html#running_without_screen_refresh "Running without Screen Refresh")
    to learn how you can speed up the execution of this program.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 程序现在已经完成，你可以进行测试。点击舞台上的鼠标，验证程序是否像之前一样运行。查看[运行时不刷新屏幕](ch04.html#running_without_screen_refresh
    "运行时不刷新屏幕")了解如何加速程序的执行。
- en: Now that you know the basics behind custom blocks, you can take them a step
    further by making blocks that can accept inputs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了自定义积木的基本知识，你可以更进一步，制作可以接受输入的积木。
- en: Running without Screen Refresh
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时不刷新屏幕
- en: 'Implementing the **DrawFlower** procedure with custom blocks brings up another
    feature that can shorten the execution time of the drawing script. To demonstrate,
    perform the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义积木实现**DrawFlower**过程引出了另一个可以缩短绘图脚本执行时间的功能。为演示，请执行以下操作：
- en: Right-click the **DrawFlower** block under the *More Blocks* palette and select
    **edit** from the pop-up menu. This should bring up the dialog from [Figure 4-11](ch04.html#new_block_dialog_and_the_blocks_that_app
    "Figure 4-11. The New Block dialog and the blocks that appear after creating the
    DrawFlower custom block"), except that the title will be *Edit Block* instead
    of *New Block*.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击*更多积木*调色板下的**DrawFlower**积木，并从弹出菜单中选择**编辑**。这将弹出一个对话框，如[图4-11](ch04.html#new_block_dialog_and_the_blocks_that_app
    "图4-11. 新积木对话框和创建DrawFlower自定义积木后出现的积木")所示，只是标题将是*编辑积木*而非*新积木*。
- en: Click the arrow next to Options, check the **Run without screen refresh** box
    and click **OK** (see [Figure 4-15](ch04.html#adding_a_number_input_to_the_square_bloc
    "Figure 4-15. Adding a number input to the Square block")).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击选项旁的箭头，勾选**运行时不刷新屏幕**框并点击**确定**（见[图4-15](ch04.html#adding_a_number_input_to_the_square_bloc
    "图4-15. 向Square积木添加数字输入")）。
- en: Now, click the mouse on the Stage and see what happens. Instead of seeing the
    individual rotating and stamping steps as the five flowers are drawn, you should
    see them appear on the Stage *almost* at once. Here is an explanation of what’s
    happening.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击舞台上的鼠标，看看会发生什么。你应该会看到五朵花几乎同时出现在舞台上，而不是看到单独的旋转和印章步骤。这是发生了什么的解释。
- en: The **DrawFlower** procedure contains many blocks that change a sprite’s appearance,
    including **set color**, **set brightness**, **set size**, and **stamp**. After
    executing such a block, Scratch normally pauses for a while to *refresh* (that
    is, redraw) the screen. This is why we were able to see the drawing progress when
    the application ran before.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**DrawFlower**过程包含了许多改变精灵外观的积木，包括**设置颜色**、**设置亮度**、**设置大小**和**印章**。在执行这样的积木后，Scratch通常会暂停一会儿以*刷新*（即重新绘制）屏幕。这就是我们在程序运行时能看到绘图进度的原因。'
- en: If you select the Run without screen refresh option, the blocks will run without
    pausing to refresh the screen, allowing the procedure to run much faster. The
    screen will refresh after Scratch executes the entire procedure.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择“运行时不刷新屏幕”选项，积木将在不暂停刷新屏幕的情况下运行，这样可以使过程运行得更快。Scratch执行完整个过程后，屏幕将刷新。
- en: In addition to speeding up a procedure, the Run without screen refresh option
    helps to prevent the flickering that repeated redrawing can cause.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加速过程外，运行时不刷新屏幕选项还帮助防止反复重绘所导致的闪烁。
- en: Passing Parameters to Custom Blocks
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向自定义积木传递参数
- en: Let’s start by creating a custom block named **Square**, which draws a square
    whose side length is 100 pixels, as shown in [Figure 4-14](ch04.html#square_procedure_that_draws_a_fixed-size
    "Figure 4-14. A Square procedure that draws a fixed-size square").
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为**Square**的自定义积木开始，它绘制一个边长为 100 像素的正方形，如[图 4-14](ch04.html#square_procedure_that_draws_a_fixed-size
    "图 4-14. 绘制固定大小正方形的 Square 程序")所示。
- en: '![A Square procedure that draws a fixed-size square](httpatomoreillycomsourcenostarchimages2134509.png.jpg)Figure 4-14. A
    *Square* procedure that draws a fixed-size square'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![绘制固定大小正方形的 Square 程序](httpatomoreillycomsourcenostarchimages2134509.png.jpg)图
    4-14. 一个绘制固定大小正方形的*Square*程序'
- en: The **Square** procedure has limited capabilities, because the drawn square
    size is fixed once and for all. What if you want to draw squares with different
    side lengths, such as 50, 75, or 200? You could define several custom blocks named
    **Square50**, **Square75**, and **Square200**, but creating multiple blocks that
    do essentially the same thing is, in most cases, a bad idea; if you need to make
    a change, then you have to track down all the copies and change those as well.
    A better solution is to have a single **Square** block that allows the user to
    specify the desired side length when calling it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**Square**程序的功能是有限的，因为绘制的正方形的大小一成不变。如果你想绘制边长不同的正方形，例如 50、75 或 200，怎么办？你可以定义多个名为**Square50**、**Square75**和**Square200**的自定义积木，但在大多数情况下，创建多个基本相同的积木并不是一个好主意；如果需要做出更改，你还得找到所有副本并修改它们。一个更好的解决方案是使用一个单一的**Square**积木，允许用户在调用时指定所需的边长。'
- en: You’ve actually been applying this concept since [Chapter 1](ch01.html "Chapter 1. Getting
    Started"). For example, Scratch provides a single **move** block that allows you
    to specify how many steps a sprite will move by entering that number in a parameter
    slot. That way, Scratch doesn’t have to provide a new block for every possible
    move distance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你其实从[第 1 章](ch01.html "第 1 章. 入门")开始就已经在应用这个概念了。例如，Scratch 提供了一个单一的**move**积木，允许你通过在参数框中输入数字来指定精灵移动的步数。通过这种方式，Scratch
    不需要为每一个可能的移动距离提供一个新的积木。
- en: What we need to do, therefore, is add a parameter slot to our **Square** block
    where the user can enter the side length. [Figure 4-15](ch04.html#adding_a_number_input_to_the_square_bloc
    "Figure 4-15. Adding a number input to the Square block") illustrates how to modify
    the **Square** block.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要做的是在**Square**积木中添加一个参数输入框，供用户输入边长。[图 4-15](ch04.html#adding_a_number_input_to_the_square_bloc
    "图 4-15. 向 Square 积木添加数字输入")展示了如何修改**Square**积木。
- en: '![Adding a number input to the Square block](httpatomoreillycomsourcenostarchimages2134511.png.jpg)Figure 4-15. Adding
    a number input to the *Square* block'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![向 Square 积木添加数字输入](httpatomoreillycomsourcenostarchimages2134511.png.jpg)图
    4-15. 向*Square*积木添加数字输入'
- en: First, right-click the **Square** block in the *More Blocks* palette (or the
    **define Square** block in the Scripts Area) and select **edit** from the pop-up
    menu to bring up the Edit Block dialog ①. Click the small arrow next to Options
    to expand the dialog and see the available options.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，右键点击**Square**积木（或脚本区中的**定义 Square**积木），从弹出菜单中选择**编辑**，以打开编辑积木对话框①。点击选项旁边的小箭头，展开对话框并查看可用的选项。
- en: We want our **Square** block to accept the desired side length of a square,
    which is a number, so click **Add number input** ② to add a number slot to the
    block. A number slot named `number1` should be added to the **Square** block.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的**Square**积木接受一个正方形的边长，这是一个数字，因此点击**添加数字输入**②，向积木中添加一个数字输入框。应该向**Square**积木添加一个名为`number1`的数字输入框。
- en: To indicate that the new slot is intended to carry the side length of the square,
    change the default name from `number1` to something meaningful ③, such as `side`,
    `length`, or `sideLength`. (Again, although Scratch doesn’t care what label you
    use, you do! Pick a name that reflects the meaning of the parameter.) Let’s use
    the name `side` for this example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表明这个新输入框用于接收正方形的边长，我们将默认名称从`number1`改为一个有意义的名称③，像是`side`、`length`或`sideLength`。（再次提醒，尽管
    Scratch 对你使用的标签不关心，但你自己会！选择一个能反映参数含义的名称。）在这个示例中，我们使用`side`作为名称。
- en: Technically, that’s all what we need to do to add a number slot to our procedure.
    If we click OK, we’ll have a **Square** block that takes a number as input. We
    could drag this block into our scripts and specify the desired length in the parameter
    slot, as in **Square 50**. But how would a user know what the number passed to
    **Square** means? Does it mean an area of 50, a diagonal of 50, a side length
    is 50, or something else?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这就是我们需要做的，向我们的过程添加一个数字插槽。如果我们点击确定，我们将得到一个**正方形**块，它接受一个数字作为输入。我们可以将这个块拖到脚本中，并在参数插槽中指定所需的长度，如**正方形
    50**。但用户如何知道传递给**正方形**的数字代表什么呢？是表示50的面积，50的对角线，50的边长，还是其他什么？
- en: 'Imagine if Scratch’s **glide** block were designed like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Scratch的**滑行**块是这样设计的：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134513.png.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages2134513.png.jpg)'
- en: 'How would you know that the first slot represents time (in seconds) and the
    second and third slots represent the *x*- and *y*-coordinates of the target glide
    point? The Scratch designers made the **glide** block easier to understand and
    use by adding labels to these slots as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道第一个插槽表示时间（以秒为单位），第二个和第三个插槽表示目标滑行点的 *x* 和 *y* 坐标呢？Scratch设计者通过为这些插槽添加标签，使得**滑行**块更加易于理解和使用，具体如下：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134515.png.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages2134515.png.jpg)'
- en: Let’s do the same thing for our **Square** block by adding text that describes
    the meaning (or usage) of the parameter slot. Click **Add label text** ④, as shown
    in [Figure 4-15](ch04.html#adding_a_number_input_to_the_square_bloc "Figure 4-15. Adding
    a number input to the Square block"), to add a label after the `side` parameter.
    Type **steps** for the label text and click **OK**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加文本来描述参数插槽的意义（或用途），对我们的**正方形**块进行相同的操作。点击**添加标签文本**④，如[图4-15](ch04.html#adding_a_number_input_to_the_square_bloc
    "图4-15. 向正方形块添加数字输入")所示，在`side`参数后添加标签。输入**steps**作为标签文本，然后点击**确定**。
- en: Now, if you examine the definition of the **Square** procedure in the Scripts
    Area, you’ll see a small block (named `side`) added to its header, as illustrated
    in [Figure 4-16](ch04.html#modifying_the_square_procedure_to_use_th "Figure 4-16. Modifying
    the Square procedure to use the side parameter") (left). The **move** block still
    has the fixed number 100 inside it, but all we need to do now is drag the `side`
    block from the header of the **Square** method and drop it over the parameter
    slot of the **move** block to replace the number 100, as shown in [Figure 4-16](ch04.html#modifying_the_square_procedure_to_use_th
    "Figure 4-16. Modifying the Square procedure to use the side parameter") (right).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你检查脚本区域中**正方形**过程的定义，你会看到一个小块（名为`side`）被添加到其头部，如[图4-16](ch04.html#modifying_the_square_procedure_to_use_th
    "图4-16. 修改正方形过程以使用边长参数")（左）所示。**移动**块中仍然包含固定数字100，但现在我们需要做的只是将`side`块从**正方形**方法的头部拖动，并将其放置到**移动**块的参数插槽中，替换数字100，如[图4-16](ch04.html#modifying_the_square_procedure_to_use_th
    "图4-16. 修改正方形过程以使用边长参数")（右）所示。
- en: '![Modifying the Square procedure to use the side parameter](httpatomoreillycomsourcenostarchimages2134517.png.jpg)Figure 4-16. Modifying
    the *Square* procedure to use the *`side`* parameter'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![修改正方形过程以使用边长参数](httpatomoreillycomsourcenostarchimages2134517.png.jpg)图4-16.
    修改*正方形*过程以使用*`边长`*参数'
- en: The label, `side`, that appears in the header of the **Square** procedure is
    called a *parameter*. You can think of a parameter as a named placeholder. We
    wanted our **Square** procedure to be able to draw squares of any size, so instead
    of hard-coding a fixed number inside our procedure, we used a general parameter
    named `side`. Users will specify the exact value of `side` when they call the
    **Square** procedure. Let’s illustrate this point by modifying the script in [Figure 4-14](ch04.html#square_procedure_that_draws_a_fixed-size
    "Figure 4-14. A Square procedure that draws a fixed-size square") to use the new
    version of our **Square** procedure. The required changes are illustrated in [Figure 4-17](ch04.html#calling_the_square_procedure_with_side_s
    "Figure 4-17. Calling the Square procedure with side set to 100").
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Square**过程的头部出现的标签`side`被称为*参数*。你可以把参数看作是一个命名的占位符。我们希望**Square**过程能够绘制任意大小的正方形，因此我们没有在过程内部硬编码一个固定的数字，而是使用了一个名为`side`的通用参数。当用户调用**Square**过程时，会指定`side`的具体值。让我们通过修改[图4-14](ch04.html#square_procedure_that_draws_a_fixed-size
    "Figure 4-14. A Square procedure that draws a fixed-size square")中的脚本来说明这一点，使用我们新版本的**Square**过程。所需的更改在[图4-17](ch04.html#calling_the_square_procedure_with_side_s
    "Figure 4-17. Calling the Square procedure with side set to 100")中有展示。
- en: '![Calling the Square procedure with side set to 100](httpatomoreillycomsourcenostarchimages2134519.png.jpg)Figure 4-17. Calling
    the *Square* procedure with *`side`* set to 100'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![调用设置为100的Square过程](httpatomoreillycomsourcenostarchimages2134519.png.jpg)图4-17。调用*Square*过程，并将*`side`*设置为100'
- en: Here, the number 100 (called an *argument*) is passed to the **Square** procedure.
    When **Square** is executed, its `side` parameter is set to 100, and this value
    is used to replace all occurrences of the `side` block inside the procedure. As
    you can see, the ability to specify different arguments to a procedure is a powerful
    feature that adds a lot of flexibility to our programs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数字100（称为*实参*）被传递给**Square**过程。当执行**Square**时，它的`side`参数被设置为100，并且这个值会替换过程内部所有出现的`side`块。正如你所看到的，能够为过程指定不同的实参是一个强大的特性，它为我们的程序增加了很多灵活性。
- en: We can enhance our **Square** procedure even further by making it accept the
    square’s color as a second parameter, as shown in [Figure 4-18](ch04.html#this_version_of_square_takes_the_desired
    "Figure 4-18. This version of Square takes the desired color as a second parameter.").
    Here, we added a second input parameter, called `clrNum` (short for color number),
    which indicates the desired color of the square. The procedure now sets the pen
    color to the value specified by `clrNum` before executing the drawing loop. Edit
    the **Square** block to implement the changes shown in the figure.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使**Square**过程接受正方形的颜色作为第二个参数来进一步增强其功能，如[图4-18](ch04.html#this_version_of_square_takes_the_desired
    "Figure 4-18. This version of Square takes the desired color as a second parameter.")所示。在这里，我们添加了一个第二个输入参数，称为`clrNum`（即颜色编号），它表示正方形的期望颜色。现在，该过程在执行绘制循环之前，会将笔的颜色设置为`clrNum`指定的值。编辑**Square**块以实现图中所示的更改。
- en: Parameters vs. Arguments
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 参数与实参
- en: Although many programmers use the terms *parameter* and *argument* inter-changeably,
    the two terms are in fact different. To clarify, consider the **Average** procedure
    shown below, which computes the average of two numbers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多程序员将*参数*和*实参*这两个术语交替使用，但实际上它们是不同的。为了解释清楚，考虑下面的**Average**过程，它计算两个数字的平均值。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134521.png.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2134521.png.jpg)'
- en: As defined, this procedure has two parameters named `num1` and `num2`. A *parameter*
    defines an input to a procedure. You’d call this procedure with the block shown
    at the left and specify some values or expressions inside the available slots.
    The values 100 and 50 in the above example are called *arguments* of the procedure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如定义所示，这个过程有两个名为`num1`和`num2`的参数。*参数*定义了过程的输入。你将使用左侧显示的块调用这个过程，并在可用的插槽内指定一些值或表达式。在上面的例子中，100和50被称为该过程的*实参*。
- en: Of course, the number of arguments in the procedure call must match the number
    of parameters in the procedure’s definition. When you call **Average**, the parameters
    `num1` and `num2` receive the values 100 and 50, respectively, because arguments
    and parameters are matched by position.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，过程调用中的参数数量必须与过程定义中的参数数量匹配。当你调用**Average**时，参数`num1`和`num2`分别接收值100和50，因为参数和实参是通过位置来匹配的。
- en: '![This version of Square takes the desired color as a second parameter.](httpatomoreillycomsourcenostarchimages2134523.png.jpg)Figure 4-18. This
    version of *Square* takes the desired color as a second parameter.Try It Out 4-1'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![这个版本的Square将所需颜色作为第二个参数。](httpatomoreillycomsourcenostarchimages2134523.png.jpg)图4-18。这个版本的*Square*将所需颜色作为第二个参数。尝试练习
    4-1'
- en: What about the thickness of the square’s border? Modify the **Square** procedure
    to take a third parameter, called `penSize`, that specifies the size of the pen
    to be used in drawing the square.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，正方形边框的粗细如何呢？修改**Square**过程，增加一个名为`penSize`的第三个参数，用于指定绘制正方形时使用的笔的大小。
- en: 'Let’s conclude this section with some useful tips for dealing with custom blocks:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些有用的技巧来结束这一节，帮助你处理自定义积木：
- en: Custom blocks can’t be shared among sprites. If you create a custom block for,
    let’s say, `Sprite1`, then only `Sprite1` can use that block. Similarly, a custom
    block defined for the Stage can only be called by scripts that belong to the Stage.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义积木不能在精灵之间共享。如果你为`Sprite1`创建了一个自定义积木，那么只有`Sprite1`可以使用该积木。同样，为舞台定义的自定义积木只能被属于舞台的脚本调用。
- en: Give your parameters meaningful names that indicate what they’re used for.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给你的参数起一个有意义的名字，表明它们的用途。
- en: To delete a custom block, just drag its **define** block (that is, the hat block)
    from the Scripts Area and drop it over the Palettes area. You can only delete
    a **define** block if your project doesn’t contain any stack blocks associated
    with it, so remove all uses of a custom block from your scripts before trying
    to delete it.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除自定义积木，只需将其**define**积木（即帽子积木）从脚本区拖动并放到调色板区。只有当你的项目中没有与该积木关联的堆栈积木时，你才能删除**define**积木，因此在尝试删除之前，先从你的脚本中移除所有自定义积木的使用。
- en: To delete a parameter of a custom block, click the parameter’s name in the Edit
    Block dialog and then click the small *X* icon that appears above the parameter’s
    slot.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除自定义积木的参数，在编辑积木对话框中点击参数的名称，然后点击出现在参数槽上方的小*X*图标。
- en: In addition to number inputs, you can also add string and Boolean parameters.
    We’ll talk more about data types when we discuss variables in the next chapter.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了数字输入外，你还可以添加字符串和布尔型参数。我们将在下一章讨论变量时深入讲解数据类型。
- en: 'Now, you might wonder: Can a procedure call another procedure? In the next
    section, you’ll learn about how to use nested procedure calls to extend the power
    and usefulness of existing procedures.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会问：一个过程能否调用另一个过程？在下一节中，你将了解如何使用嵌套过程调用来扩展现有过程的功能和实用性。
- en: Using Nested Procedures
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用嵌套过程
- en: As we noted earlier, a procedure should be designed to perform a single, well-defined
    task. To execute multiple tasks, it is perfectly legal—and in many cases desirable—to
    have one procedure call another as part of its execution path. Nesting procedures
    this way gives you great flexibility in structuring and organizing your programs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一个过程应该设计成执行一个单一的、明确定义的任务。为了执行多个任务，调用另一个过程作为其执行路径的一部分是完全合法的——在许多情况下也是很有用的。通过这种方式嵌套过程，你可以在构建和组织程序时获得极大的灵活性。
- en: '*RotatedSquares.sb2*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*RotatedSquares.sb2*'
- en: To see this in action, let’s start with the **Square** procedure we wrote in
    the previous section (see [Figure 4-17](ch04.html#calling_the_square_procedure_with_side_s
    "Figure 4-17. Calling the Square procedure with side set to 100")). Now, we’ll
    create a new procedure, called **Squares**, that draws four stretched squares,
    as illustrated in [Figure 4-19](ch04.html#squares_procedure_and_its_output "Figure 4-19. The
    Squares procedure and its output"). It does so by calling the **Square** procedure
    four times. Each call uses a different argument, and the output is four squares
    that share a corner.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解其实际应用，我们从上一节中编写的**Square**过程开始（参见[图4-17](ch04.html#calling_the_square_procedure_with_side_s
    "图4-17。调用Square过程，边长设置为100")）。现在，我们将创建一个新的过程，名为**Squares**，它绘制四个拉伸的正方形，如[图4-19](ch04.html#squares_procedure_and_its_output
    "图4-19。Squares过程及其输出")所示。它通过调用**Square**过程四次来实现，每次调用使用不同的参数，最终输出四个共享一个角的正方形。
- en: '![The Squares procedure and its output](httpatomoreillycomsourcenostarchimages2134525.png.jpg)Figure 4-19. The
    *Squares* procedure and its output'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![Squares过程及其输出](httpatomoreillycomsourcenostarchimages2134525.png.jpg)图4-19。*Squares*过程及其输出'
- en: We can now use **Squares** to create some interesting art. [Figure 4-20](ch04.html#rotatedsquares_procedure_and_some_possib
    "Figure 4-20. The RotatedSquares procedure and some possible outputs") shows another
    procedure, called **RotatedSquares**, which calls the **Squares** procedure several
    times, turning the shapes by some angle after each call.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用**Squares**来创建一些有趣的艺术作品。[图4-20](ch04.html#rotatedsquares_procedure_and_some_possib
    "图4-20. RotatedSquares过程和一些可能的输出")展示了另一个过程，叫做**RotatedSquares**，它多次调用**Squares**过程，并在每次调用后旋转图形一定角度。
- en: '![The RotatedSquares procedure and some possible outputs](httpatomoreillycomsourcenostarchimages2134527.png.jpg)Figure 4-20. The
    *RotatedSquares* procedure and some possible outputs'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![RotatedSquares过程和一些可能的输出](httpatomoreillycomsourcenostarchimages2134527.png.jpg)图4-20.
    *RotatedSquares*过程和一些可能的输出'
- en: 'In this procedure, the `count` parameter is used twice: once to determine the
    number of repetitions and again to calculate the turn angle after calling **Squares**.
    Setting `count` to `5`, for example, will result in repeating the square pattern
    of [Figure 4-20](ch04.html#rotatedsquares_procedure_and_some_possib "Figure 4-20. The
    RotatedSquares procedure and some possible outputs") five times with a 72° (that
    is, 360° / 5) right turn after each call. Experiment with different values to
    discover new patterns.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，`count`参数被使用了两次：第一次用于确定重复次数，第二次在调用**Squares**后计算转动角度。例如，将`count`设置为`5`，将会导致重复[图4-20](ch04.html#rotatedsquares_procedure_and_some_possib
    "图4-20. RotatedSquares过程和一些可能的输出")中的方形模式五次，每次调用后旋转72°（即360° / 5）。你可以尝试不同的值以发现新的模式。
- en: '*Checkers.sb2*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*Checkers.sb2*'
- en: 'Let’s work out another example that demonstrates the power of nested procedures:
    We’ll start with the **Square** procedure of [Figure 4-16](ch04.html#modifying_the_square_procedure_to_use_th
    "Figure 4-16. Modifying the Square procedure to use the side parameter") and end
    up with a checkerboard.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来做一个展示嵌套过程强大功能的例子：我们将从[图4-16](ch04.html#modifying_the_square_procedure_to_use_th
    "图4-16. 修改Square过程以使用side参数")中的**Square**过程开始，最终得到一个棋盘格。
- en: Create a new procedure (called **Row**) that draws a single row of squares,
    as illustrated in [Figure 4-21](ch04.html#row_procedure "Figure 4-21. The Row
    procedure"). Note that the number of squares to draw is specified as a parameter.
    To keep things simple, we’ve fixed the size of the individual squares at 20 steps
    instead of defining the size as a second parameter to the **Row** procedure.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的过程（叫做**Row**），如[图4-21](ch04.html#row_procedure "图4-21. Row过程")所示，画出一排方形。请注意，画多少个方形是作为参数指定的。为了简化起见，我们将每个方形的大小固定为20步，而不是将大小定义为**Row**过程的第二个参数。
- en: '![The Row procedure](httpatomoreillycomsourcenostarchimages2134529.png.jpg)Figure 4-21. The
    *Row* procedure'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![Row过程](httpatomoreillycomsourcenostarchimages2134529.png.jpg)图4-21. *Row*过程'
- en: '[Figure 4-21](ch04.html#row_procedure "Figure 4-21. The Row procedure") also
    illustrates the result of calling **Row** with an argument of `4`, which makes
    the procedure call **Square 20 steps** four times in a loop. The sprite’s position
    is adjusted after drawing each square to set the initial position for the next
    square. After drawing the four squares, the last command returns the sprite to
    its initial position.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-21](ch04.html#row_procedure "图4-21. Row过程")还展示了调用**Row**并传入`4`作为参数的结果，这会使过程在循环中调用**Square
    20步**四次。在每次画完一个方形后，角色的位置会进行调整，以为下一个方形设定初始位置。画完四个方形后，最后一条命令会将角色返回到其初始位置。'
- en: To draw another row of squares below the one shown in [Figure 4-21](ch04.html#row_procedure
    "Figure 4-21. The Row procedure"), we just need to move the sprite down 20 steps
    and then call the **Row** procedure again. We can repeat this to draw as many
    rows as we want. Our **Checkers** procedure, shown in [Figure 4-22](ch04.html#checkers_procedure_and_its_output
    "Figure 4-22. The Checkers procedure and its output"), does just that.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要在[图4-21](ch04.html#row_procedure "图4-21. Row过程")中显示的方形下方画出另一行方形，我们只需将角色下移20步，然后再次调用**Row**过程。我们可以重复这个操作，画出任意多行。我们的**Checkers**过程，如[图4-22](ch04.html#checkers_procedure_and_its_output
    "图4-22. Checkers过程及其输出")所示，就是这么做的。
- en: '![The Checkers procedure and its output](httpatomoreillycomsourcenostarchimages2134531.png.jpg)Figure 4-22. The
    Checkers procedure and its output'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![Checkers过程及其输出](httpatomoreillycomsourcenostarchimages2134531.png.jpg)图4-22.
    Checkers过程及其输出'
- en: 'This procedure takes two parameters: the number of rows and the number of columns
    for the desired checkerboard. After drawing each row, the procedure moves the
    sprite down 20 steps to prepare to draw the next row of squares.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程有两个参数：所需棋盘的行数和列数。每绘制完一行后，过程会将精灵向下移动 20 步，为绘制下一行方格做准备。
- en: The examples presented in this section show how procedures can help you divide
    a program into smaller, more manageable pieces. Once you’ve written and tested
    your procedures, you can use them as building blocks for more complex procedures
    without worrying much about the low-level implementation details. You can then
    focus on the important task of putting together the whole application using these
    procedures as building blocks.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例展示了过程如何帮助你将程序分解为更小、更易于管理的部分。写完并测试好你的过程后，你可以将它们作为构建更复杂过程的积木，而无需过多担心底层的实现细节。你可以专注于使用这些过程作为构建块来组装整个应用程序这一重要任务。
- en: Try It Out 4-2
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实践练习 4-2
- en: What do you think will happen if you set the initial direction to 0° (up) instead
    of 90° (right)? Will the script work? If not, how could you fix it? Make this
    change and run the script to test your answer.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将初始方向设置为 0°（上）而不是 90°（右），你认为会发生什么？脚本会正常工作吗？如果不行，你怎么修复它？做出这个更改并运行脚本来测试你的答案。
- en: Working with Procedures
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与过程一起工作
- en: Now that you know why it’s important to break your program down into smaller
    parts and tackle them one at a time, let’s discuss how to perform this division.
    Every problem is different, and there is no “one size fits all” solution—but that’s
    what makes this a fun puzzle!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了将程序分解成更小的部分并逐一处理的重要性，让我们讨论如何进行这种分解。每个问题都不同，没有“万能”的解决方案——这也正是让它成为一个有趣难题的原因！
- en: 'In this section, we’ll first explore the *top-down process* of dividing a large
    program into modular pieces with a clear logical structure. We’ll then discuss
    another way of building complex programs: the *bottom-up process* of combining
    existing procedures. [Figure 4-23](ch04.html#illustrating_top-down_left_parenthesisle
    "Figure 4-23. Illustrating top-down (left) and bottom-up (right) approaches")
    shows a high-level view of these two approaches.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先探讨将大型程序分解为具有清晰逻辑结构的模块化部分的*自上而下过程*。然后我们将讨论另一种构建复杂程序的方法：通过组合现有过程的*自下而上过程*。[图
    4-23](ch04.html#illustrating_top-down_left_parenthesisle "图 4-23. 说明自上而下（左）和自下而上（右）方法")展示了这两种方法的高层次视图。
- en: '![Illustrating top-down (left) and bottom-up (right) approaches](httpatomoreillycomsourcenostarchimages2134533.png.jpg)Figure 4-23. Illustrating
    top-down (left) and bottom-up (right) approaches'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![说明自上而下（左）和自下而上（右）方法](httpatomoreillycomsourcenostarchimages2134533.png.jpg)图
    4-23. 说明自上而下（左）和自下而上（右）方法'
- en: In both diagrams, the problem we want to solve is at the top, and the individual
    steps that build our solution are at the bottom. You can start from whichever
    level makes sense to you.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个图中，我们想要解决的问题在顶部，构建我们解决方案的各个步骤在底部。你可以从任何一个对你有意义的层次开始。
- en: Breaking Programs Down into Procedures
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将程序分解为过程
- en: The first step in solving any programming problem is to fully understand the
    problem. After that, you can plan a general solution and divide it into major
    tasks. There is no right or wrong way to go about dividing up any particular program,
    and with experience, you will get better at deciding what “major” means. Working
    from the general solution down to its specifics ensures that, at least, the overall
    logic of the program is correct.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 解决任何编程问题的第一步是充分理解问题。在此之后，你可以规划一个通用的解决方案，并将其分解为主要任务。没有一种“正确”或“错误”的方法来分解任何特定的程序，随着经验的积累，你会更好地判断“主要”的含义。从通用解决方案到具体细节的分解，至少能确保程序的整体逻辑是正确的。
- en: '*House.sb2*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*House.sb2*'
- en: To demonstrate this problem-solving strategy, let’s consider how we would draw
    a house similar to that shown in [Figure 4-24](ch04.html#we_can_draw_this_house_by_dividing_the_t
    "Figure 4-24. We can draw this house by dividing the task into several smaller
    pieces and handling each piece individually.").
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这种解决问题的策略，我们来考虑如何绘制一个类似于[图 4-24](ch04.html#we_can_draw_this_house_by_dividing_the_t
    "图 4-24. 我们可以通过将任务分解成几个小部分并单独处理每个部分来绘制这座房子")中所示的房子。
- en: '![We can draw this house by dividing the task into several smaller pieces and
    handling each piece individually.](httpatomoreillycomsourcenostarchimages2134535.png.jpg)Figure 4-24. We
    can draw this house by dividing the task into several smaller pieces and handling
    each piece individually.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![我们可以通过将任务分解成若干个小块，并逐个处理每个小块，来绘制这座房子。](httpatomoreillycomsourcenostarchimages2134535.png.jpg)图4-24。我们可以通过将任务分解成若干个小块，并逐个处理每个小块，来绘制这座房子。'
- en: 'On one hand, working on this simple problem allows us to focus on the solution
    strategy without getting bogged down in a lot of detail. On the other hand, despite
    its apparent simplicity, the problem lends itself to many different solutions.
    Here are some possibilities:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，处理这个简单问题让我们可以专注于解决策略，而不会被许多细节困扰。另一方面，尽管问题看似简单，但它能够衍生出许多不同的解决方案。以下是一些可能性：
- en: We can view the house as made up of straight lines. In this case, drawing each
    line is a major task.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将房子看作由直线组成。在这种情况下，绘制每一条线都是一个主要任务。
- en: 'We can view the house as made up of six independent shapes: side 1, side 2,
    two doors, a triangle, and a parallelogram. Drawing each shape constitutes a major
    task.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将房子看作由六个独立的形状组成：侧面1、侧面2、两扇门、一个三角形和一个平行四边形。绘制每个形状构成了一个主要任务。
- en: Since the two doors are identical, we can define one major task for drawing
    a door and invoke that task twice.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于两扇门是相同的，我们可以定义一个绘制门的主要任务，并调用该任务两次。
- en: We can view the triangle and the parallelogram at the top of the house as one
    unit, the roof. In this case, one major task is to draw the roof.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将房子顶部的三角形和平行四边形视为一个单元，即屋顶。在这种情况下，一个主要任务就是绘制屋顶。
- en: We can view side 1 and its door as one unit, the front side. In this case, one
    major task is to draw the front side.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将侧面1及其门视为一个单元，即前侧。这样，一个主要任务就是绘制前侧。
- en: There are many other possibilities, but that’s enough to illustrate the point.
    The idea is to group tasks into small, understandable pieces that you can deal
    with and then focus on one piece at a time. If you find similar pieces, try to
    come up with a common solution and apply it to all those pieces.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的可能性，但这些已经足够说明问题了。关键是将任务分解为小的、易于理解的部分，并逐一处理每个部分。如果发现类似的部分，尝试提出一个通用解决方案并将其应用于所有这些部分。
- en: With that in mind, our plan for drawing the house is also outlined in [Figure 4-24](ch04.html#we_can_draw_this_house_by_dividing_the_t
    "Figure 4-24. We can draw this house by dividing the task into several smaller
    pieces and handling each piece individually."). This plan assumes that the sprite
    starts facing right at point A. All we need to do is create a script that matches
    the steps outlined in the plan. We’ll write a procedure (called **Side1**) to
    draw the left side of the house as specified in step 1\. We will also write three
    procedures (called **Door**, **Side2**, and **Roof**) to draw the two doors, the
    right side of the house, and the roof (as specified in steps 2, 3, 4, and 6),
    and we will connect all these procedures with appropriate motion commands.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，我们绘制房子的计划也在[图4-24](ch04.html#we_can_draw_this_house_by_dividing_the_t "图4-24。我们可以通过将任务分解成若干个小块，并逐个处理每个小块，来绘制这座房子。")中概述。该计划假设精灵从A点朝右开始。我们需要做的就是创建一个脚本，按照计划中概述的步骤进行操作。我们将编写一个过程（名为**Side1**）来绘制房子的左侧，如步骤1所示。我们还将编写三个过程（分别称为**Door**、**Side2**和**Roof**）来绘制两扇门、房子的右侧和屋顶（如步骤2、3、4和6所示），并将所有这些过程与适当的运动命令连接起来。
- en: Our **House** procedure is shown in [Figure 4-25](ch04.html#house_proceduredot_note_how_the_major_ta
    "Figure 4-25. The House procedure. Note how the major tasks align with the drawing
    plan.") alongside the drawing steps that correspond to each procedure call. The
    procedure takes a single parameter (called **scale**) that specifies the unit
    length (that is, a scaling factor) for drawing the house. Note how the **Door**
    procedure was reused twice. Note also that the **Roof** procedure is responsible
    for drawing the entire roof, and that it may contain different sub-procedures
    for drawing the individual components of the roof.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**House**过程如[图4-25](ch04.html#house_proceduredot_note_how_the_major_ta "图4-25。House过程。注意主要任务如何与绘图计划对齐。")所示，图中还展示了与每个过程调用对应的绘图步骤。该过程接受一个参数（称为**scale**），用于指定绘制房子的单位长度（即缩放因子）。请注意，**Door**过程被重复调用了两次。同时请注意，**Roof**过程负责绘制整个屋顶，它可能包含不同的子过程，用于绘制屋顶的各个组成部分。
- en: '![The House procedure. Note how the major tasks align with the drawing plan.](httpatomoreillycomsourcenostarchimages2134537.png.jpg)Figure 4-25. The
    *House* procedure. Note how the major tasks align with the drawing plan.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![房屋过程。注意主要任务如何与绘图计划对齐。](httpatomoreillycomsourcenostarchimages2134537.png.jpg)图4-25.
    *House*过程。注意主要任务如何与绘图计划对齐。'
- en: The individual procedures for drawing the house are shown in [Figure 4-26](ch04.html#procedures_for_drawing_the_house_in_figu
    "Figure 4-26. Procedures for drawing the house in Figure 4-24"). These procedures
    draw simple geometric shapes using the same techniques you learned in [Chapter 2](ch02.html
    "Chapter 2. Motion and Drawing").
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制房屋的各个过程如[图4-26](ch04.html#procedures_for_drawing_the_house_in_figu "图4-26.
    绘制房屋的过程")所示。这些过程使用你在[第2章](ch02.html "第2章. 运动与绘图")中学到的相同技巧来绘制简单的几何形状。
- en: The **Side1**, **Door**, and **Side2** procedures draw 3×5, 1×2, and 9×5 rectangles
    (scaled by the factor `scale`), respectively. The **Roof** procedure has two sub-procedures
    (named **Triangle** and **Parallelogram**) for drawing the two parts of the roof.
    Note that the scaling factor `scale` was used consistently in all these procedures.
    This allows us to draw larger or smaller houses by calling the **House** procedure
    with a different argument.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**Side1**、**Door**和**Side2**过程分别绘制3×5、1×2和9×5的矩形（根据`scale`因子进行缩放）。**Roof**过程有两个子过程（分别命名为**Triangle**和**Parallelogram**），用于绘制屋顶的两个部分。请注意，所有这些过程都一致使用了缩放因子`scale`。这使得我们能够通过传递不同的参数调用**House**过程，绘制更大或更小的房屋。'
- en: Try It Out 4-3
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 动手试一试 4-3
- en: Did you notice that the **Side1**, **Door**, and **Side2** procedures use almost
    identical code? Create a new procedure named **Rectangle** that takes the length,
    width, and scale as parameters and draws a rectangle of the specified dimensions.
    Modify the **Side1**, **Door**, and **Side2** procedures to call the new **Rectangle**
    procedure.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到**Side1**、**Door**和**Side2**过程使用几乎相同的代码吗？创建一个名为**Rectangle**的新过程，它接受长度、宽度和缩放作为参数，并绘制指定尺寸的矩形。修改**Side1**、**Door**和**Side2**过程，以调用新的**Rectangle**过程。
- en: '![Procedures for drawing the house in](httpatomoreillycomsourcenostarchimages2134539.png.jpg)Figure 4-26. Procedures
    for drawing the house in [Figure 4-24](ch04.html#we_can_draw_this_house_by_dividing_the_t
    "Figure 4-24. We can draw this house by dividing the task into several smaller
    pieces and handling each piece individually.")'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![绘制房屋的过程](httpatomoreillycomsourcenostarchimages2134539.png.jpg)图4-26. 绘制房屋的过程如[图4-24](ch04.html#we_can_draw_this_house_by_dividing_the_t
    "图4-24. 我们可以通过将任务分解为若干较小部分并单独处理每一部分来绘制这座房屋。")'
- en: Building Up with Procedures
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过过程构建
- en: '*FlowerFlake.sb2*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*FlowerFlake.sb2*'
- en: Another way to deal with a large problem is to focus on the smaller details
    first. If you solve a large problem’s smaller pieces (or find solutions that already
    exist), you can then assemble the results from the bottom up to reach a total
    solution.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 解决大问题的另一种方法是先关注较小的细节。如果你先解决了大问题中的小部分（或找到已经存在的解决方案），然后你可以从下到上组合这些结果，最终达到完整的解决方案。
- en: To demonstrate this problem-solving technique, let’s start with a simple procedure
    (called **Leaf**) that draws a single leaf as shown in [Figure 4-27](ch04.html#leaf_procedure_and_its_output
    "Figure 4-27. The Leaf procedure and its output"). The procedure contains a **repeat**
    loop that runs twice to draw the two halves of the leaf. Each half is drawn as
    a series of 15 short line segments with a 6° turn angle between them. This is
    similar to the method of drawing polygons we used in [Chapter 2](ch02.html "Chapter 2. Motion
    and Drawing").
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个问题解决技巧，让我们从一个简单的过程（称为**Leaf**）开始，该过程绘制一个如[图4-27](ch04.html#leaf_procedure_and_its_output
    "图4-27. Leaf过程及其输出")所示的单个叶子。该过程包含一个**repeat**循环，循环执行两次以绘制叶子的两半。每一半都是通过15个短线段绘制而成，线段之间有6°的转角。这类似于我们在[第2章](ch02.html
    "第2章. 运动与绘图")中使用的绘制多边形的方法。
- en: '![The Leaf procedure and its output](httpatomoreillycomsourcenostarchimages2134541.png.jpg)Figure 4-27. The
    *Leaf* procedure and its output'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![Leaf过程及其输出](httpatomoreillycomsourcenostarchimages2134541.png.jpg)图4-27.
    *Leaf*过程及其输出'
- en: Using this procedure as a starting point, we can now draw a slightly more complex
    shape that contains five leaves. Our new procedure, called **Leaves**, and its
    output are shown in [Figure 4-28](ch04.html#leaves_procedure_calls_the_leaf_procedur
    "Figure 4-28. The Leaves procedure calls the Leaf procedure five times with 72°
    turn angle between each call."). As you can see, we only had to call the **Leaf**
    procedure in a **repeat** loop with an appropriate turn angle in between.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个过程为起点，我们现在可以绘制一个稍微复杂一些的图形，包含五片叶子。我们新建的过程叫做**Leaves**，其输出如[图4-28](ch04.html#leaves_procedure_calls_the_leaf_procedur
    "图4-28。“Leaves”过程在每次调用之间以72°的转角调用“Leaf”过程五次。")所示。如你所见，我们只需要在**repeat**循环中调用**Leaf**过程，并在每次调用之间使用适当的转角。
- en: '![The Leaves procedure calls the Leaf procedure five times with 72° turn angle
    between each call.](httpatomoreillycomsourcenostarchimages2134543.png.jpg)Figure 4-28. The
    *Leaves* procedure calls the *Leaf* procedure five times with 72° turn angle between
    each call.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![“Leaves”过程在每次调用之间以72°的转角调用“Leaf”过程五次。](httpatomoreillycomsourcenostarchimages2134543.png.jpg)图4-28。*Leaves*过程在每次调用之间以72°的转角调用*Leaf*过程五次。'
- en: 'We can now use **Leaf** and **Leaves** to build up something that is even more
    complex: a branch with leaves on it. Our **Branch** procedure and its output are
    illustrated in [Figure 4-29](ch04.html#branch_procedure_and_its_output "Figure 4-29. The
    Branch procedure and its output"). The sprite moves forward 40 steps, draws a
    single leaf (by calling the **Leaf** procedure), moves an additional 50 steps
    forward, draws five leaves (by calling the **Leaves** procedure), and finally
    returns to its starting position.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用**Leaf**和**Leaves**来构建一个更复杂的东西：一个带有叶子的树枝。我们的**Branch**过程及其输出如[图4-29](ch04.html#branch_procedure_and_its_output
    "图4-29。Branch过程及其输出")所示。精灵向前移动40步，画出一片叶子（通过调用**Leaf**过程），再向前移动50步，画出五片叶子（通过调用**Leaves**过程），最后返回起始位置。
- en: '![The Branch procedure and its output](httpatomoreillycomsourcenostarchimages2134545.png.jpg)Figure 4-29. The
    *Branch* procedure and its output'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![Branch过程及其输出](httpatomoreillycomsourcenostarchimages2134545.png.jpg)图4-29。*Branch*过程及其输出'
- en: Let’s take this up another notch. How about using the **Branch** procedure to
    create a complex drawing of a flower? Our new procedure, called **Flower**, and
    its output are shown in [Figure 4-30](ch04.html#flower_procedure_and_its_output
    "Figure 4-30. The Flower procedure and its output"). The procedure simply calls
    the **Branch** procedure six times in a loop with 60° turn angle in between.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再进一步。如何使用**Branch**过程来绘制一朵复杂的花朵图案？我们新建的过程叫做**Flower**，其输出如[图4-30](ch04.html#flower_procedure_and_its_output
    "图4-30。Flower过程及其输出")所示。这个过程简单地在循环中调用**Branch**过程六次，每次之间转角60°。
- en: '![The Flower procedure and its output](httpatomoreillycomsourcenostarchimages2134547.png.jpg)Figure 4-30. The
    *Flower* procedure and its output'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![Flower过程及其输出](httpatomoreillycomsourcenostarchimages2134547.png.jpg)图4-30。*Flower*过程及其输出'
- en: We can keep going on and on, but the idea should now be clear. We started with
    a simple procedure called **Leaf** and used it in a new procedure (called **Leaves**)
    to create a complex pattern. The **Branch** procedure relied on these two procedures
    to create something more complicated. The **Flower** procedure then used **Branch**
    to draw an even more complex pattern. If we wanted to, we could create a procedure
    that draws an entire tree of flowers and yet another to draw a garden full of
    trees.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续下去，但现在应该明白了这个思路。我们从一个简单的过程**Leaf**开始，并将它用于一个新的过程（叫做**Leaves**）来创建一个复杂的图案。**Branch**过程依赖这两个过程来创建更复杂的东西。然后，**Flower**过程利用**Branch**绘制了一个更复杂的图案。如果我们想的话，我们还可以创建一个绘制整棵花树的过程，再创建一个绘制满是树的花园的过程。
- en: The point to take away from this example is that, regardless of the complexity
    of the problem we are trying to solve, we can always build the solution by gluing
    together a number of smaller, more manageable pieces. Using this problem-solving
    technique, we start with short procedures that solve very simple problems and
    then use them to create more sophisticated procedures.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们可以得到的要点是，无论我们要解决的问题有多复杂，我们总能通过将许多更小、更易管理的部分拼接在一起来构建解决方案。使用这种问题解决技巧，我们从解决非常简单问题的短小过程开始，然后利用它们创建更复杂的过程。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced a number of fundamental concepts that will be
    used extensively in the remainder of this book. First, we explained the concept
    of message broadcasting for intersprite communication and synchronization. After
    that, we introduced structured programming and discussed how to use message broadcasting
    to implement procedures. We then demonstrated the build-your-own-block feature
    of Scratch 2.0 and explained how to pass arguments to procedures to make the procedures
    more flexible. We went over several examples that demonstrated dividing a large
    problem into smaller, more manageable pieces and explained how to use procedures
    as the basic building blocks for creating large programs. Last, we examined a
    bottom-up problem-solving technique, in which we put together known solutions
    to smaller pieces of a problem to solve the big problem.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些基础概念，这些概念将在本书的剩余部分中得到广泛应用。首先，我们解释了用于交互式通信和同步的消息广播的概念。接着，我们介绍了结构化编程，并讨论了如何使用消息广播来实现程序。然后，我们演示了Scratch
    2.0的自定义模块功能，并解释了如何向程序传递参数，以使程序更加灵活。我们通过几个示例展示了将大问题拆解成更小、更易管理的部分，并解释了如何使用程序作为创建大型程序的基本构建块。最后，我们考察了一种自下而上的问题解决技巧，在该技巧中，我们将已知的小问题的解决方案拼凑在一起，来解决大问题。
- en: 'In the next chapter, you’ll learn about the most important concept in any programming
    language: *variables*. This introduction to variables will be an essential next
    step in becoming a proficient programmer.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习任何编程语言中最重要的概念：*变量*。对变量的介绍将是成为一名熟练程序员的重要一步。
- en: Problems
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: '| **Q:** | 1\. Write different procedures to draw each letter of your name.
    Name each procedure for the letter that it draws. Then write a script that calls
    these procedures so you can draw your name on the Stage. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 1\. 编写不同的程序来绘制你名字中的每个字母。为每个字母命名相应的程序。然后编写一个脚本，调用这些程序，让你能在舞台上绘制出你的名字。
    |'
- en: '| **Q:** | 2\. Create the program shown below, run it, and explain how it works.![image
    with no caption](httpatomoreillycomsourcenostarchimages2134549.png.jpg) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 2\. 创建如下所示的程序，运行它，并解释它是如何工作的。![image with no caption](httpatomoreillycomsourcenostarchimages2134549.png.jpg)
    |'
- en: '| **Q:** | 3\. Write a procedure that converts degrees Celsius to degrees Fahrenheit
    as shown below. Have the script round the answer to the nearest integer. Test
    your procedure for different temperatures. (Hint: °*F* = (9 / 5) × °*C* + 32.)![image
    with no caption](httpatomoreillycomsourcenostarchimages2134551.png.jpg) |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 3\. 编写一个程序，将摄氏度转换为华氏度，如下所示。让脚本将答案四舍五入到最接近的整数。测试不同温度下的程序。（提示：°*F*
    = (9 / 5) × °*C* + 32。）![image with no caption](httpatomoreillycomsourcenostarchimages2134551.png.jpg)
    |'
- en: '| **Q:** | 4\. Write a procedure to create the house shown on the right. Start
    by writing small procedures that draw small parts of the house (for example, door,
    roof, windows, and so on). Then combine these procedures to create the entire
    house.![image with no caption](httpatomoreillycomsourcenostarchimages2134553.png)
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 4\. 编写一个程序来创建右侧显示的房子。首先编写绘制房子小部分（例如门、屋顶、窗户等）的程序。然后将这些程序组合起来，创建整个房子。![image
    with no caption](httpatomoreillycomsourcenostarchimages2134553.png) |'
- en: '| **Q:** | 5\. Write a procedure to compute the area of a circle (A = πr²)
    given its radius, as shown below. Use π = 3.14.![image with no caption](httpatomoreillycomsourcenostarchimages2134555.png.jpg)
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 5\. 编写一个程序来计算圆的面积（A = πr²），给定其半径，如下所示。使用π = 3.14。![image with no
    caption](httpatomoreillycomsourcenostarchimages2134555.png.jpg) |'
- en: '| **Q:** | 6\. In this exercise, you’ll simulate the pressure experienced by
    fish under water. Assume that the pressure *P* (in atmospheres) felt by a fish
    is related to its depth *d* (in meters from the surface) by the relation: *P*
    = 0.1*d* + 1\. *PressureUnderWater_NoSolution.sb2* contains a partial implementation
    of this simulation. Finish the script so that the fish says the pressure it feels
    while swimming, as illustrated below:*PressureUnderWater_NoSolution.sb2*![image
    with no caption](httpatomoreillycomsourcenostarchimages2134557.png.jpg) |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| **问：** | 6\. 在本练习中，你将模拟鱼在水下所承受的压力。假设鱼所受的压力*P*（以大气压为单位）与其深度*d*（距离水面多少米）之间的关系为：*P*
    = 0.1*d* + 1\. *PressureUnderWater_NoSolution.sb2*包含了这个模拟的部分实现。完成脚本，使得鱼在游动时说出它所感受到的压力，如下所示：*PressureUnderWater_NoSolution.sb2*![image
    with no caption](httpatomoreillycomsourcenostarchimages2134557.png.jpg) |'
