- en: '**12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12  '
- en: DEADLOCKS AND RACE CONDITIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '死锁与竞态条件  '
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)  '
- en: We’ve talked about *multitasking*, or computers doing more than one thing at
    a time. Originally we were just pretending that computers could do this, because
    really there was only one computer switching between tasks. But now that multicore
    processors are the norm, computers *are* actually doing more than one thing at
    a time. Multiprocessing isn’t a particularly new concept; single-core processors
    have long been connected together to achieve higher performance. It’s just easier
    and more common now. A multiprocessor system isn’t an expensive special-purpose
    machine anymore—it’s your phone.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '我们之前谈到过*多任务处理*，即计算机同时执行多项任务。最初，我们只是装作计算机能够做到这一点，因为实际上只有一台计算机在任务之间切换。但现在多核处理器已成为常态，计算机*确实*可以同时做多件事。多处理器并不是一个特别新的概念；单核处理器早已被连接起来以提高性能。现在只是更容易实现、更常见了。多处理器系统不再是昂贵的专用机器——它就是你的手机。  '
- en: Sometimes the order in which things are done is important. For example, let’s
    say you have a joint bank account (one that you share with someone else) that
    has a balance of $100\. The other account owner goes to an ATM to withdraw $75
    at the same time that you go into the bank to withdraw $50\. This is what’s known
    as a *race condition*. The bank software needs to be able to *lock* one of you
    out so that only one withdrawal can be processed at a time to prevent the account
    from becoming overdrawn. This essentially means turning off multitasking for certain
    operations. It’s tricky to do that without losing the benefits of multitasking,
    however, as this chapter will show.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '有时候，事情的执行顺序非常重要。例如，假设你有一个联名银行账户（你与他人共享），账户余额为100美元。另一个账户持有人去自动取款机取款75美元，而你同时去银行取款50美元。这就是所谓的*竞态条件*。银行软件需要能够*锁定*其中一个人，以便一次只处理一个取款操作，从而防止账户透支。这本质上意味着在某些操作中关闭多任务处理。然而，正如本章所展示的那样，在不失去多任务处理的好处的情况下做到这一点是非常棘手的。  '
- en: '**What Is a Race Condition?**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是竞态条件？**  '
- en: A race condition occurs when two (or more) programs access the same resource
    and the outcome is dependent on timing. Take a look at [Figure 12-1](ch12.xhtml#ch12fig01),
    where two programs are trying to deposit money into a bank account.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件发生在两个（或更多）程序访问相同的资源时，且结果取决于时机。请查看[图12-1](ch12.xhtml#ch12fig01)，其中两个程序试图将钱存入银行账户。
- en: '![Image](../images/12fig01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/12fig01.jpg)  '
- en: '*Figure 12-1: Race condition example*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-1：竞态条件示例*  '
- en: The *shared resource* in this example is the account balance. As you can see,
    the result depends on the timing of the two programs accessing this resource.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '这个例子中的*共享资源*是账户余额。如你所见，结果取决于两个程序访问该资源的时机。  '
- en: Another way of looking at it is best expressed by the T-shirt shown in [Figure
    12-2](ch12.xhtml#ch12fig02).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '另一种看待问题的方式最好通过[图12-2](ch12.xhtml#ch12fig02)中的T恤来表达。  '
- en: '![Image](../images/12fig02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/12fig02.jpg)  '
- en: '*Figure 12-2: Racing attire*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-2：竞速服装*  '
- en: '**Shared Resources**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**共享资源**  '
- en: What resources can be shared? Pretty much anything. In the previous section,
    we saw memory being shared. Memory is always involved in sharing, even if the
    end result of the sharing isn’t memory. That’s because there must be some indication
    that a shared resource is in use. This memory may not be what we typically think
    of as memory; it may just be a bit in some piece of input/output (I/O) device
    hardware.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '什么资源可以共享？几乎任何东西。在前一节中，我们看到了内存共享。即使共享的最终结果不是内存，内存总是与共享相关的。因为必须有某种方式表明某个共享资源正在使用中。这些内存可能并不是我们通常所认为的内存，它可能只是某个输入/输出（I/O）设备硬件中的一个位。  '
- en: Sharing I/O devices is also very common—for example, sharing a printer. It obviously
    wouldn’t work very well to mix pieces of different documents together. I mentioned
    back in “[System and User Space](ch05.xhtml#ch05lev1sec8)” on [page 133](ch05.xhtml#page_133)
    that operating systems handle I/O for user programs. That really only applies
    to I/O devices that are part of the machine, like the USB controller. While the
    operating system ensures that USB-connected devices communicate correctly, it
    often leaves the control of these devices up to user programs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '共享I/O设备也是很常见的——例如，分享打印机。如果将不同文档的部分混合在一起，显然效果不会很好。我在“[系统空间与用户空间](ch05.xhtml#ch05lev1sec8)”中提到过，在[第133页](ch05.xhtml#page_133)，操作系统为用户程序处理I/O。这实际上只适用于机器本身的一些I/O设备，如USB控制器。虽然操作系统确保USB连接的设备能够正确通信，但它通常将这些设备的控制交给用户程序。  '
- en: '*Field-programmable gate arrays*, or *FPGAs* (see “[Hardware vs. Software](ch03.xhtml#ch03lev1sec6)”
    on [page 90](ch03.xhtml#page_90)), are an exciting frontier in resource sharing.
    You might want to program an FPGA to provide a special hardware function to speed
    up a particular piece of software. You’d want to make sure that nothing replaces
    the hardware programming that’s expected by the software.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*现场可编程门阵列*（*FPGAs*）（参见 “[硬件与软件](ch03.xhtml#ch03lev1sec6)” 的 [第90页](ch03.xhtml#page_90)）是资源共享的一个令人兴奋的前沿领域。你可能希望编程一个FPGA来提供一个特殊的硬件功能，从而加速某个特定的软件。你需要确保不会有任何东西替代软件所期望的硬件编程。'
- en: It’s less obvious that programs running on different computers communicating
    with each other can also share resources.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行在不同计算机上时，它们之间的通信也能共享资源，这一点不那么明显。
- en: '**Processes and Threads**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进程与线程**'
- en: How can multiple programs get access to the same data? We briefly touched on
    operating systems back in “[Relative Addressing](ch05.xhtml#ch05lev1sec5)” on
    [page 128](ch05.xhtml#page_128). One of the functions of an operating system is
    to manage multiple tasks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 多个程序如何访问相同的数据？我们在 “[相对寻址](ch05.xhtml#ch05lev1sec5)” 的 [第128页](ch05.xhtml#page_128)
    中简要提到过操作系统。操作系统的一个功能是管理多个任务。
- en: Operating systems manage *processes*, which are programs running in *user space*
    (see “[System and User Space](ch05.xhtml#ch05lev1sec8)” on [page 133](ch05.xhtml#page_133)).
    Multiple programs can be running simultaneously with multicore processors, but
    that’s not enough for a race condition by itself—programs must have shared resources.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统管理*进程*，即在*用户空间*中运行的程序（参见 “[系统与用户空间](ch05.xhtml#ch05lev1sec8)” 的 [第133页](ch05.xhtml#page_133)）。在多核处理器上，多个程序可以同时运行，但这本身并不足以产生竞争条件——程序必须有共享资源。
- en: There’s no magic way, at least since Thor took the Tesseract back to Asgard,
    for processes to share resources; they must have some kind of arrangement to do
    so. This implies that processes sharing resources must somehow communicate, and
    this communication can take many forms. It must be prearranged either by being
    built into a program or via some sort of configuration information.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 至少自从托尔把宇宙魔方带回阿斯加德后，就没有魔法方法让进程共享资源；它们必须有某种方式来实现这一点。这意味着共享资源的进程必须以某种方式进行通信，而这种通信可以采取多种形式。它必须是预先安排好的，可能是通过内置于程序中或通过某种配置信息来实现。
- en: Sometimes a process needs to pay attention to multiple things. A good example
    is a *print server*—a program that other programs can communicate with to get
    things printed. Before networking, it was difficult to use a printer that wasn’t
    connected to an I/O port on the machine you wanted to print from. The networking
    code developed in the 1980s at the University of California, Berkeley, made it
    easier to for computers to communicate with each other by adding several system
    calls. In essence, a program could wait for incoming activity from multiple sources
    and run the appropriate handler code. This approach worked pretty well, mainly
    because the handler code was fairly simple and was run before waiting for the
    next activity. Print server code could print an entire document before worrying
    about the next one.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，进程需要同时关注多个事项。一个很好的例子是*打印服务器*——一个其他程序可以与之通信以进行打印的程序。在网络出现之前，使用没有连接到你想要打印的机器上的I/O端口的打印机是很困难的。1980年代加利福尼亚大学伯克利分校开发的网络代码使得计算机之间的通信变得更加容易，通过添加几个系统调用。实质上，一个程序可以等待来自多个来源的活动，并运行相应的处理代码。这种方法运作得相当好，主要是因为处理代码相对简单，并且在等待下一次活动之前运行。打印服务器代码可以在担心下一个任务之前完成整个文档的打印。
- en: Interactive programs with graphical user interfaces changed all that. Activity
    handlers were no longer simple tasks that ran from start to finish; they may have
    to pause and wait for user input in multiple places. Although programs could be
    implemented as a swarm of cooperating processes, that’s pretty cumbersome because
    they need to share a lot of data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 带有图形用户界面的交互式程序改变了这一切。活动处理器不再是简单的从头到尾运行的任务；它们可能需要在多个地方暂停并等待用户输入。尽管程序可以作为合作进程的群体来实现，但这相当繁琐，因为它们需要共享大量数据。
- en: What’s needed is a way for handlers to be interruptible—that is, for them to
    be able to stop where they are, saving their state so that they can resume execution
    where they left off at a later time. Well, this is nothing new. Where is that
    state? On the stack. Problem is, there’s only one stack per process, and it sounds
    like we need one for every handler in a process. Enter threads of execution. We
    saw how operating systems arrange process memory in “[Arranging Data in Memory](ch05.xhtml#ch05lev1sec11)”
    on [page 136](ch05.xhtml#page_136). A *thread* is a piece of a program that shares
    the static data and heap but has its own stack, as shown in [Figure 12-3](ch12.xhtml#ch12fig03).
    Each thread believes it has sole access to the CPU registers, so the *thread scheduler*
    must save and restore them when switching from one thread to another, in a manner
    similar to what the OS does when switching from one process to another. Threads
    are also called *lightweight processes* because they have much less context than
    a regular process, so switching between threads is faster than switching between
    processes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的是一种让处理程序可以被中断的方法——也就是说，它们能够在当前位置停下，保存其状态，以便稍后能够从停下的地方恢复执行。这个想法并不新鲜。那么，这个状态在哪呢？就在栈上。问题是，每个进程只有一个栈，而我们似乎需要为每个处理程序在进程中都准备一个栈。于是，执行线程应运而生。我们在[第136页](ch05.xhtml#page_136)的“[内存中的数据布局](ch05.xhtml#ch05lev1sec11)”一节中看到，操作系统是如何安排进程内存的。一个*线程*是程序的一部分，它共享静态数据和堆，但有自己的栈，如[图12-3](ch12.xhtml#ch12fig03)所示。每个线程都认为它对CPU寄存器有独占访问权限，因此*线程调度程序*在从一个线程切换到另一个线程时，必须保存和恢复这些寄存器，方式类似于操作系统在进程之间切换时的做法。线程也被称为*轻量级进程*，因为它们的上下文比常规进程少得多，所以在线程之间切换比在进程之间切换要快。
- en: '![Image](../images/12fig03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/12fig03.jpg)'
- en: '*Figure 12-3: Memory layout for threads*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-3：线程的内存布局*'
- en: Early implementations of threads involved some custom assembly language code
    that was by definition machine specific. Threads turned out to be sufficiently
    useful that a machine-independent API was standardized. Threads are interesting
    to us here because they make race conditions within a single process possible.
    Not only is this an issue in low-level C programs, but JavaScript event handlers
    are also threads.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的早期实现涉及一些特定机器的自定义汇编语言代码。后来，线程被证明非常有用，以至于标准化了一个与机器无关的API。线程在这里对我们很重要，因为它们使得在单一进程中可能出现竞争条件。这不仅是低级C程序中的问题，JavaScript事件处理程序也是线程。
- en: But just because threads exist doesn’t mean they’re the right solution for everything.
    Thread abuse is responsible for a lot of bad user experience. When Microsoft first
    introduced Windows, it was a program that ran on top of MS-DOS, which was not
    a state-of-the-art operating system that supported multitasking. As a result,
    Microsoft built parts of an operating system into each of its applications so
    that users could, for example, have several documents open at once. Unfortunately,
    some people brought this approach to programs running on complete operating systems.
    This method shows up in tabbed applications (for example, LibreOffice and Firefox)
    and user interfaces (for example, GNOME).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，仅仅因为线程存在，并不意味着它们是解决所有问题的正确方案。线程滥用是许多糟糕用户体验的根源。当微软首次推出Windows时，它是一个运行在MS-DOS之上的程序，而MS-DOS并不是一个支持多任务的现代操作系统。因此，微软将操作系统的部分功能集成到每个应用程序中，例如，用户可以同时打开多个文档。不幸的是，一些人将这种方法带到了完全的操作系统上。这种方法出现在带标签的应用程序（例如LibreOffice和Firefox）和用户界面（例如GNOME）中。
- en: Why is that a bad idea? First of all, threads share data, so it’s a security
    issue. Second, as you’ve probably experienced, a bug or problem with one tab often
    kills the entire process, resulting in lost work in what should be unrelated tasks.
    Third, as you’ve also likely experienced, a thread that takes a long time to complete
    prevents all other threads from running, so, for example, a slow-loading web page
    often hangs multiple browser instances.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这不是一个好主意？首先，线程共享数据，这就带来了安全问题。其次，正如你可能经历过的，一个标签页中的错误或问题往往会导致整个进程崩溃，造成本不相关任务的工作丢失。第三，正如你可能也经历过的，一个长时间运行的线程会阻止其他线程的执行，例如，一个加载缓慢的网页往往会使多个浏览器实例挂起。
- en: The moral of the story here is to code smartly. Use the operating system; that’s
    why it’s there. If it doesn’t perform as needed or is missing a critical feature,
    fix that. Don’t make a mess of everything else.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 故事的寓意是，聪明地编写代码。使用操作系统；它存在的目的就是为了这个。如果它没有按预期执行，或者缺少关键特性，就去修复它。不要把其他的事情搞得一团糟。
- en: '**Locks**'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**锁**'
- en: The problem at hand isn’t really sharing resources. It’s how to make operations
    *atomic* (that is, indivisible, uninterruptible) when they’re made up of a series
    of smaller operations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的问题并不完全是共享资源，而是如何使操作*原子化*（即不可分割、不可中断），当这些操作由一系列较小的操作组成时。
- en: We wouldn’t be having this discussion if computers had instructions like `adjust
    the bank balance`. But of course they don’t, because we’d need an infinite number
    of such instructions. Instead, we have to make critical sections of code appear
    atomic using some sort of *mutual exclusion* mechanism. We do that by creating
    *advisory locks* that programs follow to avoid conflicts (see [Figure 12-4](ch12.xhtml#ch12fig04)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算机有类似`调整银行余额`的指令，我们就不需要讨论这些问题了。但显然没有这样的指令，因为我们需要无限多的这类指令。相反，我们必须通过某种*互斥*机制，使关键代码部分看起来像是原子操作。我们通过创建*顾问锁*来实现这一点，程序通过这些锁避免冲突（参见[图
    12-4](ch12.xhtml#ch12fig04)）。
- en: '![Image](../images/12fig04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/12fig04.jpg)'
- en: '*Figure 12-4: Advisory lock*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-4: 顾问锁*'
- en: As you can see in [Figure 12-4](ch12.xhtml#ch12fig04), the upper program grabbed
    the lock first, so the lower program had to wait until the lock was released.
    The lock is *advisory* because it’s up to the programs to follow it; there is
    no enforcement mechanism. This might seem pretty useless because it wouldn’t stop
    anyone from robbing a bank. But it’s a matter of where the lock resides. As you
    can see in [Figure 12-5](ch12.xhtml#ch12fig05), the lock is at the bank, which
    does the enforcement, so that makes it work.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 12-4](ch12.xhtml#ch12fig04)所示，上面的程序首先获取了锁，因此下面的程序必须等到锁被释放才能继续。这个锁是*顾问性*的，因为是否遵循锁规则取决于程序本身；没有强制执行机制。这看起来可能没什么用，因为它无法阻止任何人抢劫银行。但问题在于锁的位置。如[图
    12-5](ch12.xhtml#ch12fig05)所示，锁是在银行，由银行进行执行，因此这就能起作用。
- en: '![Image](../images/12fig05.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/12fig05.jpg)'
- en: '*Figure 12-5: Lock location*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-5: 锁的位置*'
- en: 'This solves one problem but creates others. What happens if the communication
    between program #1 and the bank is slow? Clearly, program #2 is going to have
    to wait a while, which means we’re losing some of the benefits of multitasking.
    And what happens if program #1 dies or just behaves badly and never releases the
    lock? What does program #2 do while it’s waiting?'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '这解决了一个问题，但也带来了其他问题。如果程序 #1 与银行之间的通信很慢，怎么办？显然，程序 #2 将不得不等待一段时间，这意味着我们失去了一些多任务处理的好处。那么如果程序
    #1 崩溃或行为异常，永远不释放锁，该怎么办？程序 #2 在等待时该做什么？'
- en: We’ll look at these issues in the next few sections.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几个部分讨论这些问题。
- en: '***Transactions and Granularity***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***事务和粒度***'
- en: 'Every operation performed by program #1 in [Figure 12-5](ch12.xhtml#ch12fig05)
    requires some sort of communication with the bank. This needs to be two-way communication
    because we need to know whether or not each operation succeeds before doing the
    next. The easy way to improve the performance is to bundle the set of operations
    into a *transaction*, which is a group of operations that either all succeed or
    all fail (see [Figure 12-6](ch12.xhtml#ch12fig06)). The term *transaction* stems
    from the database world. Rather than sending each operation separately, we’ll
    bundle them.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '程序 #1 在[图 12-5](ch12.xhtml#ch12fig05)中执行的每个操作都需要与银行进行某种形式的通信。这需要双向通信，因为我们需要知道每个操作是否成功，才能进行下一个操作。提高性能的简单方法是将一组操作捆绑成一个*事务*，它是一个要么全部成功，要么全部失败的操作集合（参见[图
    12-6](ch12.xhtml#ch12fig06)）。术语*事务*源自数据库领域。我们不会单独发送每个操作，而是将它们捆绑在一起。'
- en: '![Image](../images/12fig06.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/12fig06.jpg)'
- en: '*Figure 12-6: Transactions*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-6: 事务*'
- en: An obvious guideline is to minimize the amount of time in which something is
    locked, because that reduces concurrency. One guideline that’s not quite so obvious,
    however, is to minimize the *granularity* of locks—that is, the amount of stuff
    covered by the lock. We’re locking the balance in our example; it’s implied that
    we’re just locking the balance of one account. Locking the entire bank every time
    one customer needs to update a balance would not be a great solution. The X Window
    System is an example of poorly designed locking. Although it has many types of
    locks, there are many instances where locking everything is the only option, but
    that eliminates concurrency.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的准则是尽量减少锁定的时间，因为这会减少并发性。然而，有一个不太明显的准则是减少锁的*粒度*——即锁覆盖的内容量。在我们的例子中，我们锁定的是余额；这里隐含的是我们只是锁定一个账户的余额。如果每次一个客户需要更新余额时都锁定整个银行，那将不是一个很好的解决方案。X窗口系统就是一个锁定设计不良的例子。尽管它有许多种锁，但有很多情况下，锁定所有内容是唯一的选择，这样会消除并发性。
- en: Locks that cover a small part of a system are called *fine-grained*; locks covering
    larger parts are called *coarse-grained*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖系统小部分的锁称为*细粒度*锁；覆盖较大部分的锁称为*粗粒度*锁。
- en: '**NOTE**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Processor interrupt handling includes a locking mechanism. When an interrupt
    is received, a* mask *is set that prevents the processor from receiving any more
    interrupts of the same type, unless explicitly allowed, until the interrupt handler
    is done.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*处理器中断处理包括一种锁机制。当接收到中断时，*掩码* *会被设置，防止处理器接收任何相同类型的中断，除非明确允许，直到中断处理程序完成。*'
- en: '***Waiting for a Lock***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***等待锁***'
- en: It doesn’t do a lot of good to use transactions and fine-grained locks if a
    program waiting for a lock can’t do anything useful while waiting. After all,
    the “multi” is the whole point of multitasking.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序在等待锁时不能做任何有用的事情，那么使用事务和细粒度锁并没有太大意义。毕竟，“多任务”就是多任务的核心所在。
- en: Sometimes there’s nothing useful to do while waiting for a lock, which is why
    you have to stand in the rain waiting for an ATM to respond. There are two ways
    of doing nothing, though. We can *spin*, which means we can try the lock over
    and over until we successfully grab it. Spinning often involves using a timer
    to space out the tries. Going full speed on a machine chews up a lot of power
    unnecessarily. Going full speed on a network can be like having a mob of people
    trying to get into a store on Black Friday. In some circumstances—and this is
    the second way of doing nothing—an entity requesting a lock can *register* that
    request with the lock authority and *get notified* when the request is granted.
    This allows the requestor to go do something more useful while waiting. This approach
    doesn’t scale particularly well and is explicitly not supported by the architecture
    of the internet, although it can be layered on top.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在等待锁时没有什么有用的事情可以做，这就是为什么你得站在雨中等待ATM机响应的原因。不过，做“什么都不做”有两种方式。我们可以*旋转*，这意味着我们可以反复尝试锁，直到成功获取它。旋转通常涉及使用定时器来间隔尝试。在机器上全速运转会不必要地消耗大量电力。在网络上全速运行可能就像黑色星期五时一群人涌入商店。在某些情况下——这就是做“什么都不做”的第二种方式——请求锁的实体可以*注册*这个请求，并在请求被授予时*收到通知*。这样，请求者可以在等待时去做更有用的事情。这种方法扩展性不强，且显然不被互联网架构所支持，尽管它可以被加层使用。
- en: We learned in [Chapter 6](ch06.xhtml#ch06) that Ethernet takes an interesting
    approach to waiting. It doesn’t have locks, but if multiple devices collide while
    trying to access the shared resource (the wire), they each wait a random amount
    of time and then try again.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第六章](ch06.xhtml#ch06)中了解到，以太网采取了一种有趣的等待方式。它没有使用锁，但如果多个设备在尝试访问共享资源（电缆）时发生冲突，它们会各自等待一段随机时间，然后再试一次。
- en: Some operating systems provide locking functionality, usually associated with
    a handle similar to a file descriptor. Locking can be attempted in blocking or
    nonblocking modes. *Blocking* means that the system suspends the calling program
    (that is, stops it from executing) until the lock is available. *Nonblocking*
    means that the program keeps running and receives some indication that it did
    not get the lock.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作系统提供锁定功能，通常与类似于文件描述符的句柄相关联。锁定可以在阻塞模式或非阻塞模式下进行。*阻塞*意味着系统会暂停调用程序（即停止它的执行），直到锁可用。*非阻塞*意味着程序会继续运行，并收到未获得锁的提示。
- en: '***Deadlocks***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***死锁***'
- en: You’ve seen that programs must do some sort of waiting around when they need
    locks that aren’t available. Complicated systems often have multiple locks, though,
    so what happens in the case shown in [Figure 12-7](ch12.xhtml#ch12fig07)?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，当程序需要锁而锁不可用时，必须进行某种形式的等待。然而，复杂的系统通常有多个锁，那么在[图 12-7](ch12.xhtml#ch12fig07)所示的情况下会发生什么呢？
- en: 'Program #1 successfully grabs Lock A, and program #2 successfully grabs Lock
    B. Next, program #1 tries to grab Lock B but can’t because program #2 has it.
    Likewise, program #2 tries to grab Lock A but can’t because program #1 has it.
    Neither program can proceed to the point where it releases the locks it holds.
    This is situation is called a *deadlock*, which is not a multi-threaded hairstyle.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '程序 #1 成功获取锁 A，程序 #2 成功获取锁 B。接下来，程序 #1 尝试获取锁 B，但因为程序 #2 已经拥有它，所以无法获得。类似地，程序
    #2 尝试获取锁 A，但因为程序 #1 已经拥有它，因此无法获得。两个程序都无法继续到释放它们所持有的锁的步骤。这种情况被称为*死锁*，这不是一种多线程的发型。'
- en: '![Image](../images/12fig07.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/12fig07.jpg)'
- en: '*Figure 12-7: Deadlock*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-7：死锁*'
- en: There are few great solutions to deadlocks other than to write code well. In
    some situations, it’s possible to manually clear a lock without causing a lot
    of damage. You’ve probably come across some situation where a program refuses
    to run because it can’t get a lock and prompts you as to whether or not you’d
    like to clear it. This situation arises when a program that holds a lock croaks
    unexpectedly without releasing it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编写良好的代码之外，解决死锁问题几乎没有其他伟大的解决方案。在某些情况下，可以手动清除锁而不会造成太大损害。你可能遇到过某种情况，程序因为无法获取锁而拒绝运行，并询问你是否希望清除该锁。这个情况通常发生在持有锁的程序意外崩溃且没有释放锁时。
- en: '***Short-Term Lock Implementation***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***短期锁实现***'
- en: There is really only one way to implement locks, but there are many ways to
    present them to programs. Lock implementation requires hardware support in the
    form of special instructions to support locking. Software solutions designed decades
    ago no longer work due to advances in processor technology, such as out-of-order
    execution and multiple cores.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，只有一种方式来实现锁，但有许多方法可以将锁呈现给程序。锁的实现需要硬件支持，通常是通过特殊指令来支持锁定。几十年前设计的软件解决方案如今已经不再有效，因为处理器技术的进步，如乱序执行和多核处理。
- en: Many processors have a *test and set* instruction that exists explicitly for
    locking. This is an atomic instruction that tests to see whether a memory location
    is `0` and sets it to `1` if it isn’t. It returns a `1` if it was successful in
    changing the value and `0` otherwise. Thus, it directly implements a lock.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 许多处理器都有一个*测试并设置*指令，专门用于锁定。该指令是一个原子操作，测试某个内存位置是否为 `0`，如果不是，则将其设置为 `1`。如果成功更改值，它返回
    `1`，否则返回 `0`。因此，它直接实现了锁。
- en: An alternate version that works better in situations where lots of programs
    are contending for a lock is *compare and swap*. This instruction is similar to
    test and set, but instead of just using a single value, the invoker provides both
    an old and a new value. If the old value matches what’s in the memory location,
    it’s replaced by the new value and the lock is grabbed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多程序争夺锁的情况下，一种更有效的替代实现方式是*比较与交换*。该指令类似于测试并设置，但不同的是，调用者不仅提供一个旧值，还提供一个新值。如果旧值与内存位置中的值匹配，则用新值替换，并且锁被抢占。
- en: Use of these instructions is usually restricted to system mode, so they’re not
    available to user programs. Some of the more recent language standards, such as
    C11, have added user-level support for atomic operations. Various locking operations
    have also been standardized and made available in libraries.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的使用通常仅限于系统模式，因此用户程序无法使用。一些较新的语言标准，如 C11，已经为原子操作提供了用户级支持。各种锁操作也已被标准化，并在库中提供。
- en: Additional code can be attached to locks to make them more efficient. For example,
    queues can be associated with locks to register programs waiting for locks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在锁上附加额外的代码以提高其效率。例如，可以将队列与锁关联，以注册等待锁的程序。
- en: '***Long-Term Lock Implementation***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***长期锁实现***'
- en: We’ve mostly been talking about locks that are held for as short a time as possible,
    but sometimes we want to hold a lock for a long time. This is usually in situations
    where access by multiple programs is never permitted—for example, a word processor
    that’s designed to prevent multiple parties from editing the same document at
    the same time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数时候讨论的是尽可能短时间内持有的锁，但有时我们需要长时间持有一个锁。这通常出现在多个程序无法同时访问的情况——例如，设计用来防止多人同时编辑同一文档的文字处理软件。
- en: Long-term locks need to be kept in more persistent storage than memory. They’re
    often implemented through files. System calls exist that allow exclusive file
    creation, and whatever program gets there first succeeds. This is equivalent to
    acquiring a lock. Note that system calls are a high-level abstraction that uses
    atomic instructions underneath the hood.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 长期锁需要保存在比内存更持久的存储中。它们通常通过文件实现。存在系统调用，允许独占文件创建，先到的程序成功。这相当于获得一个锁。需要注意的是，系统调用是一种高级抽象，底层使用原子指令。
- en: '**Browser JavaScript**'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**浏览器 JavaScript**'
- en: Writing JavaScript programs that run in a browser is the first place where,
    as a new programmer, you’re likely to have to pay attention to concurrency. This
    may sound surprising if you’ve read any JavaScript documentation, because JavaScript
    is defined as single-threaded. So how can concurrency be an issue?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 编写在浏览器中运行的 JavaScript 程序是新程序员最初可能需要注意并发的地方。如果你读过任何 JavaScript 文档，这可能会让你感到惊讶，因为
    JavaScript 被定义为单线程的。那么并发问题怎么可能存在呢？
- en: The reason is that JavaScript wasn’t originally designed for the uses it’s being
    put to today. One of its original purposes was to provide faster user feedback
    and to reduce internet traffic, back when the internet was much slower. For example,
    imagine a web page containing a field for a credit card number. Before JavaScript,
    the number would have to be sent to a web server that would verify that it contained
    only digits and either send an error response or further process the number if
    it was okay. JavaScript allowed the credit card number to be checked for digits
    in the web browser. This meant that the user didn’t have to wait in the event
    of a typo and that no internet traffic was required in order to detect and report
    the typo. Of course, there’s still lots of bad JavaScript out there that can’t
    handle spaces in card numbers, as you’ve probably discovered.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是 JavaScript 最初并不是为了现在的用途而设计的。它最初的目的是提供更快的用户反馈并减少互联网流量，那时互联网速度较慢。例如，想象一个包含信用卡号码字段的网页。在没有
    JavaScript 之前，号码必须发送到一个 web 服务器，该服务器会验证号码是否仅包含数字，并在号码合格时进行进一步处理，或者如果有错误则返回错误响应。JavaScript
    使得可以在网页浏览器中检查信用卡号码是否为数字。这意味着用户在输入错误时不必等待，并且无需通过互联网流量来检测和报告错误。当然，仍然有很多糟糕的 JavaScript
    无法处理卡号中的空格，正如你可能已经发现的那样。
- en: Since JavaScript was created to run short programs in response to user events,
    it’s implemented using an *event loop* model, the workings of which are shown
    in [Figure 12-8](ch12.xhtml#ch12fig08).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 是为响应用户事件运行短小程序而创建的，它采用了 *事件循环* 模型，其工作原理如[图 12-8](ch12.xhtml#ch12fig08)所示。
- en: '![Image](../images/12fig08.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/12fig08.jpg)'
- en: '*Figure 12-8: JavaScript event loop*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-8：JavaScript 事件循环*'
- en: What happens is that tasks to be performed are added to the *event queue*. JavaScript
    pulls these tasks from the queue one at a time and executes them. These tasks
    are not interruptible because JavaScript is single-threaded. But you as the programmer
    don’t have control over the order in which events are added to the queue. For
    example, say you have an event handler for each mouse button. You don’t control
    the order in which mouse buttons are clicked, so you can’t control the ordering
    of events. Your program must reliably deal with events in any order.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是，待执行的任务被添加到 *事件队列* 中。JavaScript 会一次从队列中拉取一个任务并执行。这些任务是不可中断的，因为 JavaScript
    是单线程的。但作为程序员的你无法控制事件加入队列的顺序。例如，假设你为每个鼠标按钮都有一个事件处理程序。你不能控制鼠标按钮点击的顺序，因此也无法控制事件的顺序。你的程序必须能够可靠地处理任何顺序的事件。
- en: Asynchronous communications weren’t designed into JavaScript when it debuted
    in 1995\. Up until that point, browsers submitted forms and servers returned web
    pages. Two things changed that. First came the publication of the Document Object
    Model (DOM) in 1997, although it didn’t become stable (more or less) until around
    2004\. The DOM allowed existing web pages to be modified instead of just being
    replaced. Second, the XMLHttpRequest (XHR) arrived on the scene in 2000, which
    became the basis of AJAX. It provided background browser-server communications
    outside of the existing “load a page” model.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JavaScript 在 1995 年首次发布时，并未设计异步通信。在那之前，浏览器提交表单，服务器返回网页。两件事改变了这一点。首先是 1997
    年发布的文档对象模型（DOM），尽管它直到 2004 年左右才稳定（或多或少）。DOM 允许现有的网页进行修改，而不仅仅是替换。第二个变化是在 2000 年出现了
    XMLHttpRequest（XHR），它成为了 AJAX 的基础。它提供了超出“加载页面”模型的浏览器与服务器之间的后台通信。
- en: These changes triggered a dramatic increase in the complexity of web pages.
    Much more JavaScript was written, making it a mainstream programming language.
    Web pages became increasingly reliant on background asynchronous communication
    with servers. There were a lot of growing pains, because this wasn’t something
    JavaScript was designed to do, especially because the single-threaded model was
    at odds with asynchronous communications.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化引发了网页复杂性的急剧增加。写了更多的 JavaScript，使其成为了一种主流编程语言。网页越来越依赖与服务器的后台异步通信。由于这不是 JavaScript
    设计之初的目标，尤其是因为单线程模型与异步通信存在冲突，导致了许多成长的痛苦。
- en: Let’s contrive a simple web application to display the art for an album by an
    artist. We’ll use some hypothetical website that first requires us to convert
    the album and artist name into an album identifier and then uses that identifier
    to fetch the album art. You may try writing the program as shown in [Listing 12-1](ch12.xhtml#ch12list01),
    where the code in italics is supplied by the user.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计一个简单的 web 应用来显示艺术家的专辑封面。我们将使用一个假设的网站，该网站首先要求我们将专辑和艺术家的名称转换为专辑标识符，然后使用该标识符来获取专辑封面。你可以尝试编写如
    [Listing 12-1](ch12.xhtml#ch12list01) 中所示的程序，其中斜体部分是用户提供的代码。
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 12-1: First-try album art program*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-1：第一次尝试的专辑封面程序*'
- en: The jQuery `post` function sends the data from the second argument to the URL
    in the first argument, and calls the function that’s the third argument when it
    gets a response. Note that it doesn’t really call the function—it adds the function
    to the event queue, so that the function gets called when it reaches the front.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 的 `post` 函数将第二个参数的数据发送到第一个参数指定的 URL，并在收到响应时调用第三个参数指定的函数。需要注意的是，它并不是直接调用这个函数，而是将该函数添加到事件队列中，以便当队列中的函数到达队首时被调用。
- en: This seems like a nice, simple, orderly program. But it won’t work reliably.
    Why not? Let’s look at what’s happening in detail. Check out [Figure 12-9](ch12.xhtml#ch12fig09).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是一个不错、简单、井然有序的程序。但是它并不会可靠地工作。为什么呢？让我们仔细看看发生了什么。请查看 [图 12-9](ch12.xhtml#ch12fig09)。
- en: '![Image](../images/12fig09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/12fig09.jpg)'
- en: '*Figure 12-9: Album art program flow*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-9：专辑封面程序流程*'
- en: As you can see, the program doesn’t execute in order. The `post` operations
    start threads internally that wait for the server to respond. When the response
    is received, the callback functions are added to the event queue. The program
    shows the second post responding first, but it could just as easily be the first
    post responding first; that’s out of our control.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，程序并不是按顺序执行的。`post` 操作会在内部启动线程，等待服务器响应。当响应到达时，回调函数会被添加到事件队列中。程序首先显示第二个
    `post` 响应，但也可能是第一个 `post` 先响应；这超出了我们的控制范围。
- en: 'There’s a good chance, then, that our program will request the album art before
    it obtains the `album_id` from the first post. And it’s almost guaranteed that
    it will append the image to the web page before it obtains the `album_art_url`.
    That’s because, although JavaScript itself is single-threaded, we have concurrent
    interactions with web servers. Put another way: although the JavaScript interpreter
    presents a single-threaded model to the programmer, it’s actually multithreaded
    internally.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的程序很有可能在获取第一个 `post` 的 `album_id` 之前请求专辑封面。几乎可以肯定的是，它会在获取 `album_art_url`
    之前就将图片附加到网页上。这是因为，尽管 JavaScript 本身是单线程的，但我们与 web 服务器的交互是并发的。换句话说：尽管 JavaScript
    解释器向程序员展示的是单线程模型，但它在内部实际上是多线程的。
- en: '[Listing 12-2](ch12.xhtml#ch12list02) shows a working version.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 12-2](ch12.xhtml#ch12list02) 展示了一个工作版本。'
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 12-2: Second-try album art program*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-2: 第二次尝试的专辑封面程序*'
- en: Now we’ve moved the image `append` to be inside of the second `post` callback,
    and we’ve moved the second `post` callback to be inside of the first `post` callback.
    This means we won’t make the second `post` until the first one has completed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已将图像的 `append` 移动到第二个 `post` 回调内部，并且将第二个 `post` 回调移动到第一个 `post` 回调内部。这意味着我们不会在第一个
    `post` 完成之前发出第二个 `post`。
- en: As you can see, nesting is required to ensure that the dependencies are met.
    And it gets uglier with error handling, which I didn’t show. The next section
    covers a different way to approach this issue.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，嵌套是确保依赖关系满足的必要条件。而且，错误处理会使其变得更加难看，我没有展示这一点。下一节将介绍另一种处理此问题的方法。
- en: '**Asynchronous Functions and Promises**'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**异步函数和 Promises**'
- en: There’s absolutely nothing wrong with the program in [Listing 12-2](ch12.xhtml#ch12list02).
    It works correctly because jQuery implemented the `post` function correctly. But
    just because jQuery did it correctly doesn’t mean other libraries do, especially
    in the Node.js world, where bad libraries are being created at an astonishing
    rate. Programs that use libraries that don’t properly implement callbacks are
    very difficult to debug. That’s become a problem because, as I mentioned in the
    book’s introduction, so much of programming is now taught as if it’s just the
    process of gluing together functions in libraries.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 12-2](ch12.xhtml#ch12list02) 中的程序完全没有问题。它运行正常，因为 jQuery 正确实现了 `post`
    函数。但仅仅因为 jQuery 做得对，并不意味着其他库也能做到，特别是在 Node.js 世界中，糟糕的库正以惊人的速度涌现。使用那些没有正确实现回调的库的程序非常难以调试。这已经成为一个问题，因为正如我在本书的介绍中提到的那样，现在很多编程都被教导成将函数在库中拼接的过程。
- en: JavaScript has recently addressed this by adding a new construct called a *promise*.
    The computing concept of a promise stems from the mid-1970s and is having a renaissance
    since its addition to JavaScript. Promises move the mechanics of asynchronous
    callbacks into the language proper so that libraries can’t screw them up. Of course,
    it’s a moving target because you can’t add to the language every time a programmer
    makes a mistake. This particular case, however, seemed common enough to be worthwhile.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 最近通过添加一种新的构造体，叫做 *promise*，解决了这个问题。promise 的计算概念源自上世纪70年代中期，自从被加入到
    JavaScript 中后，正经历着一场复兴。Promises 将异步回调的机制引入到语言本身，这样库就无法搞砸它们。当然，这仍然是一个不断变化的目标，因为你不能每次程序员犯错时就修改语言。然而，这个特定的情况似乎足够常见，值得解决。
- en: Explanations of JavaScript promises can be hard to understand because two independent
    things are jumbled together. Promises are easier to understand if these components
    are separated out. The important part is that there’s a better chance that libraries
    for asynchronous operations will function correctly if they use promises. The
    less important part, which gets talked about more, is a change in the programming
    paradigm. There’s a lot of “religion” around programming paradigms, which I talk
    about more in the final chapter. At some level, the promise construct is *syntactic
    sugar*, a sweetener that makes certain types of programming easier at the expense
    of fattening the programming language.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript promises 的解释可能很难理解，因为两个独立的东西被混合在一起。如果将这些组件分开，promises 会更容易理解。重要的一点是，如果异步操作的库使用
    promises，它们更有可能正确地工作。次要的部分，更常被提到的是编程范式的变化。编程范式中有很多“宗教”色彩，我在最后一章中会更多地讨论。某种程度上，promise
    构造体是 *语法糖*，一种甜味剂，它使某些类型的编程变得更容易，但以让编程语言变得更臃肿为代价。
- en: Taken to extremes, code for JavaScript asynchronous requests starts to look
    like what some call the *pyramid of doom*, as shown in [Listing 12-3](ch12.xhtml#ch12list03).
    I personally don’t see anything wrong with writing code this way. If indenting
    offends you, then stay away from the Python programming language; it’ll bite your
    legs off.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果推至极限，JavaScript 异步请求的代码开始看起来像某些人所称的 *毁灭金字塔*，如 [Listing 12-3](ch12.xhtml#ch12list03)
    所示。我个人认为用这种方式编写代码并没有问题。如果缩进让你不悦，那就远离 Python 编程语言吧，它会让你头痛。
- en: '[PRE2]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 12-3: Pyramid of doom*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-3: 毁灭金字塔*'
- en: Of course, some of this results from the way the program was written. The anonymous
    functions require all the code to be written inline. These can be eliminated,
    as shown in [Listing 12-4](ch12.xhtml#ch12list04), which eliminates the pyramid
    of doom but is harder to follow.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这部分内容的产生与程序的编写方式有关。匿名函数要求所有的代码都必须内联编写。正如在[清单 12-4](ch12.xhtml#ch12list04)中所示，这些匿名函数可以被消除，从而消除了“死亡金字塔”，但代码变得更难理解。
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 12-4: Rewrite eliminating anonymous functions*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-4：重写以消除匿名函数*'
- en: What programmers really want is a more straightforward way of writing code.
    This is easy in many other programming languages but difficult in JavaScript because
    of its single-threaded model. In a hypothetical multithreaded version of JavaScript,
    we would just create a new thread to run the code in [Listing 12-5](ch12.xhtml#ch12list05).
    This code assumes that the `post` blocks until completed; it’s synchronous instead
    of asynchronous. The code is clear and easy to follow.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员真正希望的是一种更直接的写代码方式。许多其他编程语言中这很容易实现，但在 JavaScript 中却很困难，因为它是单线程模型。如果有一个假设中的多线程
    JavaScript 版本，我们只需创建一个新的线程来运行[清单 12-5](ch12.xhtml#ch12list05)中的代码。这个代码假设 `post`
    会阻塞直到完成；它是同步的，而非异步的。代码清晰且易于理解。
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 12-5: Hypothetical blocking JavaScript example*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-5：假设的阻塞 JavaScript 示例*'
- en: If you could write code like this in JavaScript, it wouldn’t work well. The
    single-threaded nature of JavaScript would prevent other code from running while
    the `post`s were waiting, which means that event handlers for mouse clicks and
    other user interactions wouldn’t get run in a timely manner.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 JavaScript 中能够像这样编写代码，它将无法正常工作。JavaScript 的单线程特性会阻止其他代码在 `post` 等待期间执行，这意味着鼠标点击和其他用户交互的事件处理程序将无法及时运行。
- en: JavaScript promises have some similarity to [Listing 12-4](ch12.xhtml#ch12list04)
    in that the definition of a promise is akin to the function definitions; the definition
    of a promise is separated out from its execution.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的 Promise 与[清单 12-4](ch12.xhtml#ch12list04)有一些相似之处，因为 Promise 的定义类似于函数定义；Promise
    的定义被分离出来，与其执行分开。
- en: A promise is created as shown in [Listing 12-6](ch12.xhtml#ch12list06). Although
    this doesn’t look much different from other JavaScript code, such as a jQuery
    `post` that takes a function as an argument, the function is not executed. This
    is the setup phase of a promise.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单 12-6](ch12.xhtml#ch12list06)所示，创建一个 Promise。虽然这看起来与其他 JavaScript 代码（例如接受函数作为参数的
    jQuery `post`）没有太大区别，但这个函数并不会立即执行。这是 Promise 的设置阶段。
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 12-6: Promise creation*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-6：Promise 创建*'
- en: 'Let’s look at this in more detail. You supply the promise with a function that
    performs some asynchronous operation. That function has two arguments that are
    also functions: one (`resolve` in [Listing 12-6](ch12.xhtml#ch12list06)) that’s
    appended to the JavaScript event queue when the asynchronous operation completes
    successfully, and one (`reject` in [Listing 12-6](ch12.xhtml#ch12list06)) that’s
    added to the JavaScript event queue if the asynchronous operation fails.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下。你为 Promise 提供一个执行某些异步操作的函数。这个函数有两个参数，它们也是函数：一个是 (`resolve` 在[清单 12-6](ch12.xhtml#ch12list06)中)，当异步操作成功完成时，该函数会被添加到
    JavaScript 事件队列中；另一个是 (`reject` 在[清单 12-6](ch12.xhtml#ch12list06)中)，当异步操作失败时，该函数会被添加到
    JavaScript 事件队列中。
- en: The program executes a promise using its `then` method, as shown in [Listing
    12-7](ch12.xhtml#ch12list07). This method takes a pair of functions as arguments
    that are matched to the `resolve` and `reject` functions supplied during promise
    creation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通过 `then` 方法执行 Promise，如[清单 12-7](ch12.xhtml#ch12list07)所示。此方法接受一对函数作为参数，这些函数与在
    Promise 创建时提供的 `resolve` 和 `reject` 函数相匹配。
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 12-7: Promise execution*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-7：Promise 执行*'
- en: This isn’t very exciting. We could write code to do this without using promises,
    as we did before. So why bother? Promises come with a bit of syntactic sugar called
    *chaining*. It allows code to be written in a something`().`then`().`then`().`then`()`
    . . . style. This works because the `then` method returns another promise. Note
    that, in a manner similar to exceptions, the second argument to `then` can be
    omitted and errors can be fielded with a `catch`. [Listing 12-8](ch12.xhtml#ch12list08)
    shows the album art program rewritten using promise chaining.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不令人兴奋。我们本可以在不使用 Promise 的情况下编写代码，正如我们之前做的那样。那么为什么还要使用 Promise 呢？Promise 带有一些语法糖，称为
    *链式调用*。它允许代码以 something`().`then`().`then`().`then`()` . . . 的风格编写。之所以能够这样工作，是因为
    `then` 方法会返回另一个 Promise。请注意，类似于异常的处理方式，`then` 的第二个参数可以省略，错误可以通过 `catch` 来捕获。[清单
    12-8](ch12.xhtml#ch12list08)展示了使用 Promise 链式调用重写的专辑艺术程序。
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 12-8: Album art program using promise chaining*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-8：使用 promise 链接的专辑封面程序*'
- en: 'Now, I don’t find this code easier to follow than the pyramid-of-doom version,
    but you may feel differently. The versions of code in [Listings 12-2](ch12.xhtml#ch12list02)
    and [12-8](ch12.xhtml#ch12list08) raise another point about the art of programming:
    trading off the ease of code development versus maintenance. In the grand scheme
    of a product’s lifecycle, maintainability is more important than writing code
    in some personally preferred style. I talk about this a little more in [Chapter
    15](ch15.xhtml#ch15). Promise chaining allows you to write code in a function`().`function`().`function`()`
    . . . style instead of the pyramid-of-doom style. While the first style makes
    keeping track of parentheses slightly easier, JavaScript—unlike Ruby, for example—was
    designed with the second style, and having two styles in the same language likely
    increases confusion, resulting in decreased programmer productivity. Although
    promises might reduce the instances of one class of programming errors, don’t
    mistake them as a cure-all for poorly written code.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我不觉得这段代码比“死亡金字塔”式的代码更易于理解，但你可能有不同的看法。[清单 12-2](ch12.xhtml#ch12list02) 和 [12-8](ch12.xhtml#ch12list08)
    中的代码版本提出了编程艺术的另一个问题：在代码开发的简易性与可维护性之间进行权衡。在产品生命周期的宏观视角下，可维护性比写出某种个人偏好风格的代码更为重要。我在[第
    15 章](ch15.xhtml#ch15)中对此进行了更多讨论。Promise 链接使你能够以 `().`function`().`function`()`
    . . .` 的方式编写代码，而不是“死亡金字塔”式的代码风格。虽然第一种风格在保持括号跟踪方面稍微更容易，但 JavaScript——与 Ruby 等语言不同——是为了第二种风格设计的，并且在同一语言中同时使用两种风格可能会增加混乱，导致程序员生产力下降。尽管
    promises 可能减少某类编程错误的发生，但不要误以为它们是解决编写不良代码的万能法宝。
- en: 'Promises are syntactic sugar that reduce the amount of nesting. But if we really
    want code that’s easier to follow, we want something more like [Listing 12-5](ch12.xhtml#ch12list05).
    JavaScript includes yet another way to write “asynchronous” programs that builds
    on promises but mirrors the synchronous coding style: `async` and `await`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Promises 是一种语法糖，可以减少嵌套的数量。但如果我们真的希望代码更易于理解，我们希望采用更像是[清单 12-5](ch12.xhtml#ch12list05)的方式。JavaScript
    还提供了另一种编写“异步”程序的方式，它建立在 promises 的基础上，但模仿同步编码风格：`async` 和 `await`。
- en: '[Listing 12-9](ch12.xhtml#ch12list09) shows an implementation of the album
    art program using `async` and `await`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 12-9](ch12.xhtml#ch12list09)展示了使用 `async` 和 `await` 实现专辑封面程序的代码。'
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 12-9: Album art program using async and await*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-9：使用 async 和 await 的专辑封面程序*'
- en: To me, this looks more straightforward than [Listing 12-8](ch12.xhtml#ch12list08).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这看起来比[清单 12-8](ch12.xhtml#ch12list08)更直接。
- en: Of course, what’s going on here is that the single-threaded JavaScript model
    has been severely bent, if not broken. Asynchronous functions are essentially
    threads that are not interruptible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里发生的事情是，单线程的 JavaScript 模型已经被严重扭曲，甚至可以说是被破坏了。异步函数本质上是不可中断的线程。
- en: '**Summary**'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned about some of the issues that result from using
    shared resources. You learned about race conditions and deadlocks, and about processes
    and threads. You also learned a little bit about concurrency in JavaScript and
    new ways in which it’s being approached. At this point, we’ve covered the basics.
    We’ll move on to one of our two advanced topics—security—in the next chapter,
    which uses many of the technologies that you’ve learned about so far.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了使用共享资源时可能会遇到的一些问题。你学习了竞争条件和死锁，以及进程和线程的概念。你还了解了一些 JavaScript 中的并发概念，以及它如何以新的方式被实现。目前为止，我们已经覆盖了基础内容。在下一章中，我们将讨论两个高级话题之一——安全性——其中涉及了你目前为止学习的许多技术。
