- en: 'Chapter 20. Signals: Fundamental Concepts'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第20章：信号：基本概念
- en: This chapter and the next two chapters discuss signals. Although the fundamental
    concepts are simple, our discussion is quite lengthy, since there are many details
    to cover.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以及接下来的两章将讨论信号。虽然基本概念简单，但我们的讨论相当冗长，因为有许多细节需要涵盖。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: the various different signals and their purposes;
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种不同的信号及其用途；
- en: the circumstances in which the kernel may generate a signal for a process, and
    the system calls that one process may use to send a signal to another process;
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核在什么情况下可能会为进程生成信号，以及一个进程可以使用哪些系统调用来向另一个进程发送信号；
- en: how a process responds to a signal by default, and the means by which a process
    can change its response to a signal, in particular, through the use of a signal
    handler, a programmer-defined function that is automatically invoked on receipt
    of a signal;
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，进程如何响应信号，以及进程如何改变对信号的响应，特别是通过使用信号处理程序，这是一种在接收到信号时自动调用的程序员定义的函数；
- en: the use of the process signal mask to block signals, and the associated notion
    of pending signals; and
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用进程信号屏蔽来阻塞信号，以及与之相关的待处理信号的概念；
- en: how a process can suspend execution and wait for the delivery of a signal.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程如何挂起执行并等待信号的到达。
- en: Concepts and Overview
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念和概述
- en: A *signal* is a notification to a process that an event has occurred. Signals
    are sometimes described as *software interrupts*. Signals are analogous to hardware
    interrupts in that they interrupt the normal flow of execution of a program; in
    most cases, it is not possible to predict exactly when a signal will arrive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*信号*是通知进程某个事件发生的机制。信号有时被描述为*软件中断*。信号类似于硬件中断，它们中断了程序的正常执行流程；在大多数情况下，无法预测信号何时到达。'
- en: 'One process can (if it has suitable permissions) send a signal to another process.
    In this use, signals can be employed as a synchronization technique, or even as
    a primitive form of interprocess communication (IPC). It is also possible for
    a process to send a signal to itself. However, the usual source of many signals
    sent to a process is the kernel. Among the types of events that cause the kernel
    to generate a signal for a process are the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程可以（如果它有适当的权限）向另一个进程发送信号。在这种用法中，信号可以用作同步技术，甚至作为进程间通信（IPC）的原始形式。进程也可以向自身发送信号。然而，许多发送给进程的信号通常来自内核。导致内核为进程生成信号的事件类型包括以下内容：
- en: A hardware exception occurred, meaning that the hardware detected a fault condition
    that was notified to the kernel, which in turn sent a corresponding signal to
    the process concerned. Examples of hardware exceptions include executing a malformed
    machine-language instruction, dividing by 0, or referencing a part of memory that
    is inaccessible.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生硬件异常，这意味着硬件检测到故障条件并将其通知给内核，内核随后向相关进程发送相应的信号。硬件异常的示例包括执行格式错误的机器语言指令、除以0或引用无法访问的内存区域。
- en: The user typed one of the terminal special characters that generate signals.
    These characters include the *interrupt* character (usually *Control-C*) and the
    *suspend* character (usually *Control-Z*).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入了一个会生成信号的终端特殊字符。这些字符包括*中断*字符（通常是*Control-C*）和*挂起*字符（通常是*Control-Z*）。
- en: A software event occurred. For example, input became available on a file descriptor,
    the terminal window was resized, a timer went off, the process’s CPU time limit
    was exceeded, or a child of this process terminated.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生了软件事件。例如，文件描述符上有了输入，终端窗口被调整大小，定时器触发，进程的CPU时间限制被超出，或者该进程的一个子进程终止。
- en: Each signal is defined as a unique (small) integer, starting sequentially from
    1. These integers are defined in `<signal.h>` with symbolic names of the form
    `SIGxxxx`. Since the actual numbers used for each signal vary across implementations,
    it is these symbolic names that are always used in programs. For example, when
    the user types the *interrupt* character, `SIGINT` (signal number 2) is delivered
    to a process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个信号都被定义为一个唯一的（小的）整数，从1开始按顺序排列。这些整数在`<signal.h>`中定义，并具有`SIGxxxx`格式的符号名称。由于每个信号使用的实际数字在不同的实现中有所不同，因此程序中总是使用这些符号名称。例如，当用户输入*中断*字符时，`SIGINT`（信号号2）会被送达进程。
- en: Signals fall into two broad categories. The first set constitutes the *traditional*
    or *standard* signals, which are used by the kernel to notify processes of events.
    On Linux, the standard signals are numbered from 1 to 31\. We describe the standard
    signals in this chapter. The other set of signals consists of the *realtime* signals,
    whose differences from standard signals are described in Section 22.8.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 信号可以分为两大类。第一类是*传统的*或*标准的*信号，用于内核通知进程事件。在Linux系统中，标准信号的编号从1到31。我们将在本章描述标准信号。另一类信号是*实时*信号，标准信号和实时信号的区别在22.8节中有详细描述。
- en: A signal is said to be *generated* by some event. Once generated, a signal is
    later *delivered* to a process, which then takes some action in response to the
    signal. Between the time it is generated and the time it is delivered, a signal
    is said to be *pending*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 信号被称为由某些事件*生成*。一旦生成，信号会稍后*送达*进程，进程将根据该信号采取相应的行动。在信号生成和送达之间，信号被称为*挂起*。
- en: Normally, a pending signal is delivered to a process as soon as it is next scheduled
    to run, or immediately if the process is already running (e.g., if the process
    sent a signal to itself). Sometimes, however, we need to ensure that a segment
    of code is not interrupted by the delivery of a signal. To do this, we can add
    a signal to the process’s *signal mask*—a set of signals whose delivery is currently
    *blocked*. If a signal is generated while it is blocked, it remains pending until
    it is later unblocked (removed from the signal mask). Various system calls allow
    a process to add and remove signals from its signal mask.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当一个挂起的信号被送达时，它会在进程下一次调度运行时立即送达，或者如果进程已经在运行（例如进程向自己发送信号），则会立刻送达。然而，有时我们需要确保某段代码在信号传递过程中不被中断。为了做到这一点，我们可以将信号添加到进程的*信号屏蔽*中——这是一组当前*被阻塞*的信号。如果在信号被阻塞时生成了信号，它会保持挂起状态，直到以后解除阻塞（从信号屏蔽中移除）。各种系统调用允许进程添加或移除信号屏蔽中的信号。
- en: 'Upon delivery of a signal, a process carries out one of the following default
    actions, depending on the signal:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在信号传递时，进程根据信号执行以下默认操作之一：
- en: The signal is *ignored*; that is, it is discarded by the kernel and has no effect
    on the process. (The process never even knows that it occurred.)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号被*忽略*；即它被内核丢弃，对进程没有任何影响。（进程甚至不知道信号的发生。）
- en: The process is *terminated* (killed). This is sometimes referred to as *abnormal
    process termination*, as opposed to the normal process termination that occurs
    when a process terminates using *exit()*.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程被*终止*（杀死）。这有时被称为*异常进程终止*，与使用*exit()*终止进程时的正常终止相对。
- en: A *core dump file* is generated, and the process is terminated. A core dump
    file contains an image of the virtual memory of the process, which can be loaded
    into a debugger in order to inspect the state of the process at the time that
    it terminated.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个*核心转储文件*，并且进程被终止。核心转储文件包含进程的虚拟内存映像，可以加载到调试器中，以便检查进程终止时的状态。
- en: The process is *stopped*—execution of the process is suspended.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程被*停止*——进程的执行被暂停。
- en: Execution of the process is *resumed* after previously being stopped.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进程被暂停后，执行被*恢复*。
- en: 'Instead of accepting the default for a particular signal, a program can change
    the action that occurs when the signal is delivered. This is known as setting
    the *disposition* of the signal. A program can set one of the following dispositions
    for a signal:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以通过改变信号到达时的处理方式，而不接受特定信号的默认处理方式。这被称为设置信号的*处置*。程序可以为信号设置以下几种处置方式：
- en: The *default action* should occur. This is useful to undo an earlier change
    of the disposition of the signal to something other than its default.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该执行*默认操作*。这对于撤销之前将信号处置更改为非默认行为时非常有用。
- en: The signal is *ignored*. This is useful for a signal whose default action would
    be to terminate the process.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号被*忽略*。对于默认行为是终止进程的信号，这种做法非常有用。
- en: A *signal handler* is executed.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个*信号处理程序*。
- en: A signal handler is a function, written by the programmer, that performs appropriate
    tasks in response to the delivery of a signal. For example, the shell has a handler
    for the `SIGINT` signal (generated by the *interrupt* character, *Control-C*)
    that causes it to stop what it is currently doing and return control to the main
    input loop, so that the user is once more presented with the shell prompt. Notifying
    the kernel that a handler function should be invoked is usually referred to as
    *installing* or *establishing* a signal handler. When a signal handler is invoked
    in response to the delivery of a signal, we say that the signal has been *handled*
    or, synonymously, *caught*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理程序是由程序员编写的函数，用于响应信号的传递并执行适当的任务。例如，shell 有一个处理 `SIGINT` 信号的处理程序（该信号由 *中断*
    字符 *Control-C* 生成），它使得 shell 停止当前操作并将控制权返回到主输入循环，从而使用户重新看到 shell 提示符。通知内核应调用某个处理程序函数通常被称为
    *安装* 或 *建立* 信号处理程序。当信号处理程序在响应信号传递时被调用时，我们称该信号已被 *处理* 或同义地称为 *捕获*。
- en: 'Note that it isn’t possible to set the disposition of a signal to *terminate*
    or *dump core* (unless one of these is the default disposition of the signal).
    The nearest we can get to this is to install a handler for the signal that then
    calls either *exit()* or *abort()*. The *abort()* function ([Terminating a Process
    Abnormally: *abort()*](ch21.html#terminating_a_process_abnormally_colon_a "Terminating
    a Process Abnormally: abort()")) generates a `SIGABRT` signal for the process,
    which causes it to dump core and terminate.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不能将信号的处置设置为 *终止* 或 *生成核心转储*（除非其中之一是该信号的默认处置方式）。我们最接近的方法是安装一个处理程序，处理程序调用 *exit()*
    或 *abort()* 函数。*abort()* 函数（[异常终止进程：*abort()*](ch21.html#terminating_a_process_abnormally_colon_a
    "异常终止进程：abort()")）为进程生成一个 `SIGABRT` 信号，导致进程生成核心转储并终止。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Linux-specific `/proc/`*PID*`/status` file contains various bit-mask fields
    that can be inspected to determine a process’s treatment of signals. The bit masks
    are displayed as hexadecimal numbers, with the least significant bit representing
    signal 1, the next bit to the left representing signal 2, and so on. These fields
    are *SigPnd* (per-thread pending signals), *ShdPnd* (process-wide pending signals;
    since Linux 2.6), *SigBlk* (blocked signals), *SigIgn* (ignored signals), and
    *SigCgt* (caught signals). (The difference between the *SigPnd* and *ShdPnd* fields
    will become clear when we describe the handling of signals in multithreaded processes
    in Section 33.2.) The same information can also be obtained using various options
    to the *ps(1)* command.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 特定的 `/proc/`*PID*`/status` 文件包含了各种位掩码字段，可以用来检查进程如何处理信号。这些位掩码以十六进制数字显示，最低有效位表示信号
    1，左边的下一个位表示信号 2，依此类推。这些字段包括 *SigPnd*（每线程待处理信号）、*ShdPnd*（进程范围内的待处理信号；自 Linux 2.6
    起）、*SigBlk*（被阻塞的信号）、*SigIgn*（被忽略的信号）和 *SigCgt*（已捕获的信号）。(我们将在第 33.2 节中描述多线程进程中信号的处理时，*SigPnd*
    和 *ShdPnd* 字段之间的区别将变得更加清晰。) 使用 *ps(1)* 命令的各种选项也可以获得相同的信息。
- en: Signals appeared in very early UNIX implementations, but have gone through some
    significant changes since their inception. In early implementations, signals could
    be lost (i.e., not delivered to the target process) in certain circumstances.
    Furthermore, although facilities were provided to block delivery of signals while
    critical code was executed, in some circumstances, blocking was not reliable.
    These problems were remedied in 4.2BSD, which provided so-called *reliable signals*.
    (One further BSD innovation was the addition of extra signals to support shell
    job control, which we describe in Section 34.7.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 信号在早期的 UNIX 实现中就已出现，但自其诞生以来经历了一些重大变化。在早期实现中，信号可能会丢失（即，在某些情况下不会传递给目标进程）。此外，尽管提供了阻止信号传递的设施，以便在执行关键代码时保护代码，但在某些情况下，这种阻止机制并不可靠。这些问题在
    4.2BSD 中得到了修复，4.2BSD 提供了所谓的 *可靠信号*。（另一个 BSD 创新是增加了额外的信号以支持 shell 作业控制，我们将在第 34.7
    节中描述这一点。）
- en: System V also added reliable semantics to signals, but employed a model incompatible
    with BSD. These incompatibilities were resolved only with the arrival of the POSIX.1-1990
    standard, which adopted a specification for reliable signals largely based on
    the BSD model.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: System V 也为信号添加了可靠的语义，但采用了一种与 BSD 不兼容的模型。这些不兼容之处直到 POSIX.1-1990 标准发布时才得以解决，该标准采用了基于
    BSD 模型的大部分可靠信号规范。
- en: We consider the details of reliable and unreliable signals in [Implementation
    and Portability of *signal()*](ch22.html#implementation_and_portability_of_signal
    "Implementation and Portability of signal()"), and briefly describe the older
    BSD and System V signal APIs in [Earlier Signal APIs (System V and BSD)](ch22.html#earlier_signal_apis_open_parenthesis_sys
    "Earlier Signal APIs (System V and BSD)").
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[signal()的实现与可移植性](ch22.html#implementation_and_portability_of_signal "signal()的实现与可移植性")中考虑了可靠信号和不可靠信号的详细信息，并在[早期信号API（System
    V和BSD）](ch22.html#earlier_signal_apis_open_parenthesis_sys "早期信号API（System V和BSD）")中简要描述了旧的BSD和System
    V信号API。
- en: Signal Types and Default Actions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号类型和默认动作
- en: 'Earlier, we mentioned that the standard signals are numbered from 1 to 31 on
    Linux. However, the Linux *signal(7)* manual page lists more than 31 signal names.
    The excess names can be accounted for in a variety of ways. Some of the names
    are simply synonyms for other names, and are defined for source compatibility
    with other UNIX implementations. Other names are defined but unused. The following
    list describes the various signals:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到，标准信号在Linux中编号从1到31。然而，Linux的*signal(7)*手册页面列出了超过31个信号名称。超出的信号名称有多种解释方式。其中一些名称只是其他名称的同义词，为了与其他UNIX实现的源兼容而定义。其他名称则是定义了但未使用的。以下列表描述了各种信号：
- en: '`SIGABRT`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGABRT`'
- en: 'A process is sent this signal when it calls the *abort()* function ([Terminating
    a Process Abnormally: *abort()*](ch21.html#terminating_a_process_abnormally_colon_a
    "Terminating a Process Abnormally: abort()")). By default, this signal terminates
    the process with a core dump. This achieves the intended purpose of the *abort()*
    call: to produce a core dump for debugging.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程调用*abort()*函数时，会发送此信号（[异常终止进程：*abort()*](ch21.html#terminating_a_process_abnormally_colon_a
    "异常终止进程：abort()")）。默认情况下，此信号会终止进程并生成核心转储。此操作实现了*abort()*调用的预期目的：生成用于调试的核心转储。
- en: '`SIGALRM`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGALRM`'
- en: The kernel generates this signal upon the expiration of a real-time timer set
    by a call to *alarm()* or *setitimer()*. A real-time timer is one that counts
    according to wall clock time (i.e., the human notion of elapsed time). For further
    details, see Section 23.1.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 内核在由*alarm()*或*setitimer()*调用设置的实时计时器到期时生成此信号。实时计时器是按照墙钟时间（即人类的时间概念）计数的计时器。更多详细信息，请参见第23.1节。
- en: '`SIGBUS`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGBUS`'
- en: This signal (“bus error”) is generated to indicate certain kinds of memory-access
    errors. One such error can occur when using memory mappings created with *mmap()*,
    if we attempt to access an address that lies beyond the end of the underlying
    memory-mapped file, as described in [Boundary Cases](ch49.html#boundary_cases
    "Boundary Cases").
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此信号（“总线错误”）是为了表示某些类型的内存访问错误而生成的。例如，使用* mmap()*创建的内存映射时，如果尝试访问超出底层内存映射文件末尾的地址，就可能发生此类错误，具体内容请参见[边界情况](ch49.html#boundary_cases
    "边界情况")。
- en: '`SIGCHLD`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGCHLD`'
- en: This signal is sent (by the kernel) to a parent process when one of its children
    terminates (either by calling *exit()* or as a result of being killed by a signal).
    It may also be sent to a process when one of its children is stopped or resumed
    by a signal. We consider `SIGCHLD` in detail in Section 26.3.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个子进程终止时（无论是通过调用*exit()*，还是由于被信号终止），内核会向父进程发送此信号（由内核发送）。当子进程被信号停止或恢复时，内核也会发送此信号。我们在第26.3节中详细讨论了`SIGCHLD`。
- en: '`SIGCLD`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGCLD`'
- en: This is a synonym for `SIGCHLD`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`SIGCHLD`的同义词。
- en: '`SIGCONT`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGCONT`'
- en: When sent to a stopped process, this signal causes the process to resume (i.e.,
    to be rescheduled to run at some later time). When received by a process that
    is not currently stopped, this signal is ignored by default. A process may catch
    this signal, so that it carries out some action when it resumes. This signal is
    covered in more detail in [Special Cases for Delivery, Disposition, and Handling](ch22.html#special_cases_for_delivery_comma_disposi
    "Special Cases for Delivery, Disposition, and Handling") and [Job Control](ch34.html#job_control
    "Job Control").
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送到一个停止的进程时，此信号会导致该进程恢复（即重新调度并在稍后的时间运行）。当接收到一个当前未停止的进程时，此信号默认会被忽略。进程可以捕获此信号，以便在恢复时执行某些操作。此信号在[交付、处置和处理的特殊情况](ch22.html#special_cases_for_delivery_comma_disposi
    "交付、处置和处理的特殊情况")和[作业控制](ch34.html#job_control "作业控制")中有更详细的介绍。
- en: '`SIGEMT`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGEMT`'
- en: In UNIX systems generally, this signal is used to indicate an implementation-dependent
    hardware error. On Linux, this signal is used only in the Sun SPARC implementation.
    The suffix `EMT` derives from *emulator trap*, an assembler mnemonic on the Digital
    PDP-11.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般的UNIX系统中，此信号用于表示与实现相关的硬件错误。在Linux中，仅在Sun SPARC实现中使用此信号。后缀`EMT`来源于*模拟器陷阱*，这是Digital
    PDP-11上的汇编语言助记符。
- en: '`SIGFPE`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGFPE`'
- en: This signal is generated for certain types of arithmetic errors, such as divide-by-zero.
    The suffix `FPE` is an abbreviation for *floating-point exception*, although this
    signal can also be generated for integer arithmetic errors. The precise details
    of when this signal is generated depend on the hardware architecture and the settings
    of CPU control registers. For example, on x86-32, integer divide-by-zero always
    yields a `SIGFPE`, but the handling of floating-point divide-by-zero depends on
    whether the `FE_DIVBYZERO` exception has been enabled. If this exception is enabled
    (using *feenableexcept()*), then a floating-point divide-by-zero generates `SIGFPE`;
    otherwise, it yields the IEEE-standard result for the operands (a floating-point
    representation of infinity). See the *fenv(3)* manual page and `<fenv.h>` for
    further information.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该信号由某些类型的算术错误生成，例如除以零。后缀`FPE`是*浮点异常*的缩写，尽管此信号也可以因整数算术错误而生成。此信号生成的精确细节取决于硬件架构和CPU控制寄存器的设置。例如，在x86-32架构上，整数除以零总是会产生`SIGFPE`，但浮点数除以零的处理则取决于是否启用了`FE_DIVBYZERO`异常。如果启用了此异常（使用*feenableexcept()*），则浮点数除以零会生成`SIGFPE`；否则，它会生成操作数的IEEE标准结果（浮点表示的无穷大）。有关详细信息，请参见*fenv(3)*手册页面和`<fenv.h>`。
- en: '`SIGHUP`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGHUP`'
- en: When a terminal disconnect (hangup) occurs, this signal is sent to the controlling
    process of the terminal. We describe the concept of a controlling process and
    the various circumstances in which `SIGHUP` is sent in Section 34.6\. A second
    use of `SIGHUP` is with daemons (e.g., *init*, *httpd*, and *inetd*). Many daemons
    are designed to respond to the receipt of `SIGHUP` by reinitializing themselves
    and rereading their configuration files. The system administrator triggers these
    actions by manually sending `SIGHUP` to the daemon, either by using an explicit
    *kill* command or by executing a program or script that does the same.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当终端断开连接（挂起）时，系统会向终端的控制进程发送此信号。我们在第34.6节中描述了控制进程的概念以及`SIGHUP`信号发送的各种情况。`SIGHUP`的第二种用途是与守护进程（例如*init*、*httpd*和*inetd*）一起使用。许多守护进程在收到`SIGHUP`信号时会通过重新初始化自己并重新读取配置文件来响应。系统管理员可以通过手动向守护进程发送`SIGHUP`，无论是通过显式的*kill*命令，还是通过执行一个执行相同操作的程序或脚本，来触发这些操作。
- en: '`SIGILL`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGILL`'
- en: This signal is sent to a process if it tries to execute an illegal (i.e., incorrectly
    formed) machine-language instruction.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程尝试执行非法（即格式错误的）机器语言指令时，会向其发送此信号。
- en: '`SIGINFO`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGINFO`'
- en: On Linux, this signal name is a synonym for `SIGPWR`. On BSD systems, the `SIGINFO`
    signal, generated by typing *Control-T*, is used to obtain status information
    about the foreground process group.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，此信号名称是`SIGPWR`的同义词。在BSD系统中，通过输入*Control-T*生成的`SIGINFO`信号用于获取前台进程组的状态信息。
- en: '`SIGINT`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGINT`'
- en: When the user types the terminal *interrupt* character (usually *Control-C*),
    the terminal driver sends this signal to the foreground process group. The default
    action for this signal is to terminate the process.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入终端*中断*字符（通常是*Control-C*）时，终端驱动程序会将此信号发送给前台进程组。此信号的默认动作是终止进程。
- en: '`SIGIO`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGIO`'
- en: Using the *fcntl()* system call, it is possible to arrange for this signal to
    be generated when an I/O event (e.g., input becoming available) occurs on certain
    types of open file descriptors, such as those for terminals and sockets. This
    feature is described further in Section 63.3.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*fcntl()*系统调用，可以安排在某些类型的打开文件描述符（如终端和套接字）上发生I/O事件（例如输入变得可用）时生成此信号。此功能在第63.3节中有进一步的描述。
- en: '`SIGIOT`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGIOT`'
- en: On Linux, this is a synonym for `SIGABRT`. On some other UNIX implementations,
    this signal indicates an implementation-defined hardware fault.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，这是`SIGABRT`的同义词。在某些其他UNIX实现中，此信号表示实现定义的硬件故障。
- en: '`SIGKILL`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGKILL`'
- en: This is the sure *kill* signal. It can’t be blocked, ignored, or caught by a
    handler, and thus always terminates a process.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是确定的*终止*信号。它无法被阻止、忽略或被处理程序捕获，因此始终会终止一个进程。
- en: '`SIGLOST`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGLOST`'
- en: This signal name exists on Linux, but is unused. On some other UNIX implementations,
    the NFS client sends this signal to local processes holding locks if the NSF client
    fails to regain locks held by the those processes following the recovery of a
    remote NFS server that crashed. (This feature is not standardized in NFS specifications.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信号名称在Linux上存在，但未被使用。在一些其他UNIX实现中，如果NFS客户端在恢复崩溃的远程NFS服务器后未能重新获取由本地进程持有的锁，则NFS客户端会向这些本地进程发送此信号。（此功能在NFS规范中未标准化。）
- en: '`SIGPIPE`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGPIPE`'
- en: This signal is generated when a process tries to write to a pipe, a FIFO, or
    a socket for which there is no corresponding reader process. This normally occurs
    because the reading process has closed its file descriptor for the IPC channel.
    See [Creating and Using Pipes](ch44.html#creating_and_using_pipes "Creating and
    Using Pipes") for further details.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程尝试写入一个没有对应读取进程的管道、FIFO或套接字时，会生成此信号。通常，这是因为读取进程已经关闭了该IPC通道的文件描述符。有关详细信息，请参见[创建和使用管道](ch44.html#creating_and_using_pipes
    "Creating and Using Pipes")。
- en: '`SIGPOLL`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGPOLL`'
- en: This signal, which is derived from System V, is a synonym for `SIGIO` on Linux.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信号源自System V，在Linux上是`SIGIO`的同义词。
- en: '`SIGPROF`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGPROF`'
- en: The kernel generates this signal upon the expiration of a profiling timer set
    by a call to *setitimer()* ([Interval Timers](ch23.html#interval_timers "Interval
    Timers")). A profiling timer is one that counts the CPU time used by a process.
    Unlike a virtual timer (see `SIGVTALRM` below), a profiling timer counts CPU time
    used in both user mode and kernel mode.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当由*setitimer()*调用设置的性能计时器到期时，内核会生成此信号（[Interval Timers](ch23.html#interval_timers
    "Interval Timers")）。性能计时器是用来计数进程使用的CPU时间的计时器。与虚拟计时器（见`SIGVTALRM`）不同，性能计时器计数在用户模式和内核模式下使用的CPU时间。
- en: '`SIGPWR`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGPWR`'
- en: This is the *power failure* signal. On systems that have an uninterruptible
    power supply (UPS), it is possible to set up a daemon process that monitors the
    backup battery level in the event of a power failure. If the battery power is
    about to run out (after an extended power outage), then the monitoring process
    sends `SIGPWR` to the *init* process, which interprets this signal as a request
    to shut down the system in a quick and orderly fashion.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*电源故障*信号。在具有不间断电源供应（UPS）的系统中，可以设置一个守护进程，监控电池备份电量，以应对电源故障。如果电池电量即将耗尽（经过一段时间的停电），则监控进程会向*init*进程发送`SIGPWR`信号，*init*进程将该信号解释为请求快速而有序地关闭系统。
- en: '`SIGQUIT`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGQUIT`'
- en: When the user types the *quit* character (usually *Control-\*) on the keyboard,
    this signal is sent to the foreground process group. By default, this signal terminates
    a process and causes it to produce a core dump, which can then be used for debugging.
    Using `SIGQUIT` in this manner is useful with a program that is stuck in an infinite
    loop or is otherwise not responding. By typing *Control-\* and then loading the
    resulting core dump with the *gdb* debugger and using the *backtrace* command
    to obtain a stack trace, we can find out which part of the program code was executing.
    ([Matloff, 2008] describes the use of *gdb*.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在键盘上输入*quit*字符（通常是*Control-\*），该信号会发送到前台进程组。默认情况下，这个信号会终止一个进程，并导致其生成核心转储（core
    dump），然后可以用来调试。以这种方式使用`SIGQUIT`在程序陷入无限循环或无法响应时非常有用。通过输入*Control-\*，然后使用*gdb*调试器加载生成的核心转储，并使用*backtrace*命令获取堆栈跟踪，我们可以找出程序代码的哪一部分正在执行。（[Matloff,
    2008]描述了如何使用*gdb*。）
- en: '`SIGSEGV`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGSEGV`'
- en: 'This very popular signal is generated when a program makes an invalid memory
    reference. A memory reference may be invalid because the referenced page doesn’t
    exist (e.g., it lies in an unmapped area somewhere between the heap and the stack),
    the process tried to update a location in read-only memory (e.g., the program
    text segment or a region of mapped memory marked read-only), or the process tried
    to access a part of kernel memory while running in user mode ([The Core Operating
    System: The Kernel](ch02.html#the_core_operating_system_colon_the_kern "The Core
    Operating System: The Kernel")). In C, these events often result from dereferencing
    a pointer containing a bad address (e.g., an uninitialized pointer) or passing
    an invalid argument in a function call. The name of this signal derives from the
    term *segmentation violation*.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常常见的信号是在程序做出无效内存引用时生成的。内存引用可能是无效的，因为引用的页面不存在（例如，它位于堆栈和堆之间的未映射区域），进程试图更新只读内存中的位置（例如，程序文本段或标记为只读的映射内存区域），或者进程试图在用户模式下访问内核内存的一部分（参见[核心操作系统：内核](ch02.html#the_core_operating_system_colon_the_kern
    "核心操作系统：内核")）。在C语言中，这些事件通常是由于解引用包含错误地址（例如，未初始化的指针）或在函数调用中传递无效参数所导致。该信号的名称源自术语*段错误*。
- en: '`SIGSTKFLT`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGSTKFLT`'
- en: Documented in *signal(7)* as “stack fault on coprocessor,” this signal is defined,
    but is unused on Linux.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在*signal(7)*中记录为“协处理器上的堆栈故障”，该信号已定义，但在Linux上未使用。
- en: '`SIGSTOP`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGSTOP`'
- en: This is the *sure stop* signal. It can’t be blocked, ignored, or caught by a
    handler; thus, it always stops a process.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*强制停止*信号。它不能被阻止、忽略或通过处理程序捕获；因此，它总是会停止一个进程。
- en: '`SIGSYS`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGSYS`'
- en: This signal is generated if a process makes a “bad” system call. This means
    that the process executed an instruction that was interpreted as a system call
    trap, but the associated system call number was not valid (refer to [System Calls](ch03.html#system_calls
    "System Calls")).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个进程发出了“错误”的系统调用，将会生成此信号。这意味着进程执行了一条被解释为系统调用陷阱的指令，但关联的系统调用编号无效（参见[系统调用](ch03.html#system_calls
    "系统调用")）。
- en: '`SIGTERM`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGTERM`'
- en: This is the standard signal used for terminating a process and is the default
    signal sent by the *kill* and *killall* commands. Users sometimes explicitly send
    the `SIGKILL` signal to a process using *kill -KILL* or *kill -9*. However, this
    is generally a mistake. A well-designed application will have a handler for `SIGTERM`
    that causes the application to exit gracefully, cleaning up temporary files and
    releasing other resources beforehand. Killing a process with `SIGKILL` bypasses
    the `SIGTERM` handler. Thus, we should always first attempt to terminate a process
    using `SIGTERM`, and reserve `SIGKILL` as a last resort for killing runaway processes
    that don’t respond to `SIGTERM`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是终止进程的标准信号，也是*kill*和*killall*命令默认发送的信号。用户有时会显式地向进程发送`SIGKILL`信号，例如通过*kill -KILL*或*kill
    -9*命令。然而，这通常是一个错误。设计良好的应用程序会为`SIGTERM`设置一个处理程序，使应用程序优雅地退出，提前清理临时文件并释放其他资源。使用`SIGKILL`终止进程会绕过`SIGTERM`处理程序。因此，我们应该始终首先尝试使用`SIGTERM`终止进程，并将`SIGKILL`保留为最后的手段，用于杀死那些未响应`SIGTERM`的失控进程。
- en: '`SIGTRAP`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGTRAP`'
- en: This signal is used to implement debugger breakpoints and system call tracing,
    as performed by *strace(1)* ([Appendix A](apa.html "Appendix A. Tracing System
    Calls")). See the *ptrace(2)* manual page for further information.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该信号用于实现调试器断点和系统调用追踪，例如*strace(1)*所执行的操作（[附录A](apa.html "附录A. 跟踪系统调用")）。有关更多信息，请参阅*ptrace(2)*手册页。
- en: '`SIGTSTP`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGTSTP`'
- en: This is the job-control *stop* signal, sent to stop the foreground process group
    when the user types the *suspend* character (usually *Control-Z*) on the keyboard.
    [Chapter 34](ch34.html "Chapter 34. Process Groups, Sessions, and Job Control")
    describes process groups (jobs) and job control in detail, as well as details
    of when and how a program may need to handle this signal. The name of this signal
    derives from “terminal stop.”
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是作业控制的*停止*信号，当用户在键盘上输入*suspend*字符（通常是*Control-Z*）时，发送该信号以停止前台进程组。[第34章](ch34.html
    "第34章. 进程组、会话和作业控制")详细描述了进程组（作业）和作业控制，以及程序何时和如何处理该信号的细节。该信号的名称源自“终端停止”。
- en: '`SIGTTIN`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGTTIN`'
- en: When running under a job-control shell, the terminal driver sends this signal
    to a background process group when it attempts to *read()* from the terminal.
    This signal stops a process by default.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在作业控制的shell中运行时，当后台进程组试图从终端进行*read()*操作时，终端驱动程序会向其发送此信号。此信号默认会停止进程。
- en: '`SIGTTOU`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGTTOU`'
- en: This signal serves an analogous purpose to `SIGTTIN`, but for terminal output
    by background jobs. When running under a job-control shell, if the `TOSTOP` (*terminal
    output stop*) option has been enabled for the terminal (perhaps via the command
    *stty tostop*), the terminal driver sends `SIGTTOU` to a background process group
    when it attempts to *write()* to the terminal (see [Using Job Control Within the
    Shell](ch34.html#using_job_control_within_the_shell "Using Job Control Within
    the Shell")). This signal stops a process by default.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信号与`SIGTTIN`的作用类似，但用于后台作业的终端输出。当在作业控制Shell下运行时，如果启用了`TOSTOP`（*终端输出停止*）选项（可能通过命令*stty
    tostop*启用），当终端驱动程序尝试向终端写入时，它会向后台进程组发送`SIGTTOU`（参见[在Shell中使用作业控制](ch34.html#using_job_control_within_the_shell
    "Using Job Control Within the Shell")）。此信号默认会停止进程。
- en: '`SIGUNUSED`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGUNUSED`'
- en: As the name implies, this signal is unused. On Linux 2.4 and later, this signal
    name is synonymous with `SIGSYS` on many architectures. In other words, this signal
    number is no longer unused on those architectures, although the signal name remains
    for backward compatibility.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如名称所示，这个信号未被使用。在Linux 2.4及更高版本中，这个信号的名称与`SIGSYS`在许多架构上是同义的。换句话说，这个信号编号在这些架构上不再是未使用的，尽管为了向后兼容，信号名称仍然存在。
- en: '`SIGURG`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGURG`'
- en: This signal is sent to a process to indicate the presence of *out-of-band* (also
    known as *urgent*) data on a socket ([Out-of-Band Data](ch61.html#out-of-band_data
    "Out-of-Band Data")).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信号会发送到进程，表示套接字上存在*带外*（也称为*紧急*）数据（[带外数据](ch61.html#out-of-band_data "Out-of-Band
    Data")）。
- en: '`SIGUSR1`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGUSR1`'
- en: This signal and `SIGUSR2` are available for programmer-defined purposes. The
    kernel never generates these signals for a process. Processes may use these signals
    to notify one another of events or to synchronize with each other. In early UNIX
    implementations, these were the only two signals that could be freely used in
    applications. (In fact, processes can send one another any signal, but this has
    the potential for confusion if the kernel also generates one of the signals for
    a process.) Modern UNIX implementations provide a large set of realtime signals
    that are also available for programmer-defined purposes ([Realtime Signals](ch22.html#realtime_signals
    "Realtime Signals")).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信号和`SIGUSR2`可用于程序员定义的目的。内核从不为进程生成这些信号。进程可以使用这些信号来通知彼此事件或进行同步。在早期的UNIX实现中，这两个信号是唯一可以在应用程序中自由使用的信号。（实际上，进程可以向彼此发送任何信号，但如果内核也为进程生成了某个信号，这可能会导致混淆。）现代UNIX实现提供了一大组实时信号，这些信号也可用于程序员定义的目的（[实时信号](ch22.html#realtime_signals
    "Realtime Signals")）。
- en: '`SIGUSR2`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGUSR2`'
- en: See the description of `SIGUSR1`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 参见`SIGUSR1`的描述。
- en: '`SIGVTALRM`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGVTALRM`'
- en: The kernel generates this signal upon expiration of a virtual timer set by a
    call to *setitimer()* ([Interval Timers](ch23.html#interval_timers "Interval Timers")).
    A virtual timer is one that counts the user-mode CPU time used by a process.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 内核在虚拟定时器过期时生成此信号，虚拟定时器是通过调用*setitimer()*设置的（[间隔定时器](ch23.html#interval_timers
    "Interval Timers")）。虚拟定时器是计算进程使用的用户模式CPU时间的定时器。
- en: '`SIGWINCH`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGWINCH`'
- en: In a windowing environment, this signal is sent to the foreground process group
    when the terminal window size changes (as a consequence either of the user manually
    resizing it, or of a program resizing it via a call to *ioctl()*, as described
    in [Terminal Window Size](ch62.html#terminal_window_size "Terminal Window Size")).
    By installing a handler for this signal, programs such as *vi* and *less* can
    know to redraw their output after a change in window size.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口环境中，当终端窗口大小变化时，向前台进程组发送此信号（可能是由于用户手动调整大小，或者程序通过调用*ioctl()*调整大小，如在[终端窗口大小](ch62.html#terminal_window_size
    "Terminal Window Size")中所述）。通过为此信号安装处理程序，程序（如*vi*和*less*）可以在窗口大小更改后知道重新绘制它们的输出。
- en: '`SIGXCPU`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGXCPU`'
- en: This signal is sent to a process when it exceeds its CPU time resource limit
    (`RLIMIT_CPU`, described in [Details of Specific Resource Limits](ch36.html#details_of_specific_resource_limits
    "Details of Specific Resource Limits")).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程超过其CPU时间资源限制（`RLIMIT_CPU`，在[具体资源限制的详细信息](ch36.html#details_of_specific_resource_limits
    "Details of Specific Resource Limits")中描述）时，发送此信号。
- en: '`SIGXFSZ`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGXFSZ`'
- en: This signal is sent to a process if it attempts (using *write()* or *truncate()*)
    to increase the size of a file beyond the process’s file size resource limit (`RLIMIT_FSIZE`,
    described in [Details of Specific Resource Limits](ch36.html#details_of_specific_resource_limits
    "Details of Specific Resource Limits")).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进程尝试通过 *write()* 或 *truncate()* 操作将文件大小增加到超过进程的文件大小资源限制（`RLIMIT_FSIZE`，在[特定资源限制的详细信息](ch36.html#details_of_specific_resource_limits
    "特定资源限制的详细信息")中描述），则该信号会发送给该进程。
- en: '[Table 20-1](ch20.html#linux_signals "Table 20-1. Linux signals") summarizes
    a range of information about signals on Linux. Note the following points about
    this table:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 20-1](ch20.html#linux_signals "表格 20-1. Linux 信号") 汇总了有关 Linux 信号的一系列信息。请注意以下几点：'
- en: The *signal number* column shows the number assigned to this signal on various
    hardware architectures. Except where otherwise indicated, signals have the same
    number on all architectures. Architectural differences in signal numbers are indicated
    in parentheses, and occur on the Sun SPARC and SPARC64 (S), HP/Compaq/Digital
    Alpha (A), MIPS (M), and HP PA-RISC (P) architectures. In this column, *undef*
    indicates that a symbol is undefined on the indicated architectures.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信号编号* 列显示在各种硬件架构上分配给该信号的编号。除非另有说明，否则所有架构上的信号编号是相同的。架构间信号编号的差异会在括号中指明，并出现在
    Sun SPARC 和 SPARC64 (S)、HP/Compaq/Digital Alpha (A)、MIPS (M) 以及 HP PA-RISC (P)
    架构中。在此列中，*undef* 表示在指定架构上符号未定义。'
- en: The *SUSv3* column indicates whether the signal is standardized in SUSv3.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SUSv3* 列表示该信号是否在 SUSv3 中进行了标准化。'
- en: 'The *Default* column indicates the default action of the signal: *term* means
    that the signal terminates the process, *core* means that the process produces
    a core dump file and terminates, *ignore* means that the signal is ignored, *stop*
    means that the signal stops the process, and *cont* means that the signal resumes
    a stopped process.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*默认行为* 列表示信号的默认操作：*term* 表示信号终止进程，*core* 表示进程生成核心转储文件并终止，*ignore* 表示忽略该信号，*stop*
    表示信号停止进程，*cont* 表示信号恢复停止的进程。'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Certain of the signals listed previously are not shown in [Table 20-1](ch20.html#linux_signals
    "Table 20-1. Linux signals"): `SIGCLD` (synonym for `SIGCHLD`), `SIGINFO` (unused),
    `SIGIOT` (synonym for `SIGABRT`), `SIGLOST` (unused), and `SIGUNUSED` (synonym
    for `SIGSYS` on many architectures).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 之前列出的某些信号未显示在[表格 20-1](ch20.html#linux_signals "表格 20-1. Linux 信号")中：`SIGCLD`（`SIGCHLD`的同义词），`SIGINFO`（未使用），`SIGIOT`（`SIGABRT`的同义词），`SIGLOST`（未使用），以及
    `SIGUNUSED`（在许多架构上是 `SIGSYS` 的同义词）。
- en: Table 20-1. Linux signals
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 20-1. Linux 信号
- en: '| Name | Signal number | Description | SUSv3 | Default |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 信号编号 | 描述 | SUSv3 | 默认行为 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `SIGABRT` | 6 | Abort process | • | core |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `SIGABRT` | 6 | 中止进程 | • | core |'
- en: '| `SIGALRM` | 14 | Real-time timer expired | • | term |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `SIGALRM` | 14 | 实时定时器超时 | • | term |'
- en: '| `SIGBUS` | 7 (SAMP=10) | Memory access error | • | core |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `SIGBUS` | 7 (SAMP=10) | 内存访问错误 | • | core |'
- en: '| `SIGCHLD` | 17 (SA=20, MP=18) | Child terminated or stopped | • | ignore
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `SIGCHLD` | 17 (SA=20, MP=18) | 子进程终止或停止 | • | ignore |'
- en: '| `SIGCONT` | 18 (SA=19, M=25, P=26) | Continue if stopped | • | cont |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `SIGCONT` | 18 (SA=19, M=25, P=26) | 如果停止，则继续 | • | cont |'
- en: '| `SIGEMT` | undef (SAMP=7) | Hardware fault |   | term |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `SIGEMT` | undef (SAMP=7) | 硬件故障 |   | term |'
- en: '| `SIGFPE` | 8 | Arithmetic exception | • | core |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `SIGFPE` | 8 | 算术异常 | • | core |'
- en: '| `SIGHUP` | 1 | Hangup | • | term |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `SIGHUP` | 1 | 挂起 | • | term |'
- en: '| `SIGILL` | 4 | Illegal instruction | • | core |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `SIGILL` | 4 | 非法指令 | • | core |'
- en: '| `SIGINT` | 2 | Terminal interrupt | • | term |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `SIGINT` | 2 | 终端中断 | • | term |'
- en: '| `SIGIO`/`SIGPOLL` | 29 (SA=23, MP=22) | I/O possible | • | term |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `SIGIO`/`SIGPOLL` | 29 (SA=23, MP=22) | I/O 可用 | • | term |'
- en: '| `SIGKILL` | 9 | Sure kill | • | term |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `SIGKILL` | 9 | 强制终止 | • | term |'
- en: '| `SIGPIPE` | 13 | Broken pipe | • | term |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `SIGPIPE` | 13 | 管道破损 | • | term |'
- en: '| `SIGPROF` | 27 (M=29, P=21) | Profiling timer expired | • | term |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `SIGPROF` | 27 (M=29, P=21) | 性能分析定时器超时 | • | term |'
- en: '| `SIGPWR` | 30 (SA=29, MP=19) | Power about to fail |   | term |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `SIGPWR` | 30 (SA=29, MP=19) | 电源即将故障 |   | term |'
- en: '| `SIGQUIT` | 3 | Terminal quit | • | core |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `SIGQUIT` | 3 | 终端退出 | • | core |'
- en: '| `SIGSEGV` | 11 | Invalid memory reference | • | core |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `SIGSEGV` | 11 | 无效的内存引用 | • | core |'
- en: '| `SIGSTKFLT` | 16 (SAM=undef, P=36) | Stack fault on coprocessor |   | term
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `SIGSTKFLT` | 16 (SAM=undef, P=36) | 协处理器栈故障 |   | term |'
- en: '| `SIGSTOP` | 19 (SA=17, M=23, P=24) | Sure stop | • | stop |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `SIGSTOP` | 19 (SA=17, M=23, P=24) | 确定停止 | • | stop |'
- en: '| `SIGSYS` | 31 (SAMP=12) | Invalid system call | • | core |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `SIGSYS` | 31 (SAMP=12) | 无效的系统调用 | • | core |'
- en: '| `SIGTERM` | 15 | Terminate process | • | term |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `SIGTERM` | 15 | 终止进程 | • | term |'
- en: '| `SIGTRAP` | 5 | Trace/breakpoint trap | • | core |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `SIGTRAP` | 5 | 跟踪/断点陷阱 | • | 核心 |'
- en: '| `SIGTSTP` | 20 (SA=18, M=24, P=25) | Terminal stop | • | stop |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `SIGTSTP` | 20 (SA=18, M=24, P=25) | 终端停止 | • | 停止 |'
- en: '| `SIGTTIN` | 21 (M=26, P=27) | Terminal read from BG | • | stop |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `SIGTTIN` | 21 (M=26, P=27) | 来自后台的终端读操作 | • | 停止 |'
- en: '| `SIGTTOU` | 22 (M=27, P=28) | Terminal write from BG | • | stop |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `SIGTTOU` | 22 (M=27, P=28) | 来自后台的终端写操作 | • | 停止 |'
- en: '| `SIGURG` | 23 (SA=16, M=21, P=29) | Urgent data on socket | • | ignore |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `SIGURG` | 23 (SA=16, M=21, P=29) | 套接字上有紧急数据 | • | 忽略 |'
- en: '| `SIGUSR1` | 10 (SA=30, MP=16) | User-defined signal 1 | • | term |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `SIGUSR1` | 10 (SA=30, MP=16) | 用户定义信号 1 | • | 终止 |'
- en: '| `SIGUSR2` | 12 (SA=31, MP=17) | User-defined signal 2 | • | term |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `SIGUSR2` | 12 (SA=31, MP=17) | 用户定义信号 2 | • | 终止 |'
- en: '| `SIGVTALRM` | 26 (M=28, P=20) | Virtual timer expired | • | term |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `SIGVTALRM` | 26 (M=28, P=20) | 虚拟定时器到期 | • | 终止 |'
- en: '| `SIGWINCH` | 28 (M=20, P=23) | Terminal window size change |   | ignore |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `SIGWINCH` | 28 (M=20, P=23) | 终端窗口大小更改 |   | 忽略 |'
- en: '| `SIGXCPU` | 24 (M=30, P=33) | CPU time limit exceeded | • | core |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `SIGXCPU` | 24 (M=30, P=33) | 超过 CPU 时间限制 | • | 核心 |'
- en: '| `SIGXFSZ` | 25 (M=31, P=34) | File size limit exceeded | • | core |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `SIGXFSZ` | 25 (M=31, P=34) | 文件大小超限 | • | 核心 |'
- en: 'Note the following points regarding the default behavior shown for certain
    signals in [Table 20-1](ch20.html#linux_signals "Table 20-1. Linux signals"):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下关于某些信号默认行为的说明，详见 [表 20-1](ch20.html#linux_signals "表 20-1. Linux 信号")：
- en: On Linux 2.2, the default action for the signals `SIGXCPU`, `SIGXFSZ`, `SIGSYS`,
    and `SIGBUS` is to terminate the process without producing a core dump. From kernel
    2.4 onward, Linux conforms to the requirements of SUSv3, with these signals causing
    termination with a core dump. On several other UNIX implementations, `SIGXCPU`
    and `SIGXFSZ` are treated in the same way as on Linux 2.2.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 2.2 中，信号 `SIGXCPU`、`SIGXFSZ`、`SIGSYS` 和 `SIGBUS` 的默认动作是终止进程并不产生核心转储。从内核
    2.4 版本开始，Linux 遵循 SUSv3 的要求，导致这些信号会导致进程终止并生成核心转储。在其他一些 UNIX 实现中，`SIGXCPU` 和 `SIGXFSZ`
    的处理方式与 Linux 2.2 相同。
- en: '`SIGPWR` is typically ignored by default on those other UNIX implementations
    where it appears.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGPWR` 通常在这些其他 UNIX 实现中默认被忽略，其中它会出现。'
- en: '`SIGIO` is ignored by default on several UNIX implementations (particularly
    BSD derivatives).'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGIO` 在多个 UNIX 实现中默认被忽略（尤其是 BSD 衍生版本）。'
- en: Although not specified by any standards, `SIGEMT` appears on most UNIX implementations.
    However, this signal typically results in termination with a core dump on other
    implementations.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管没有任何标准明确规定，`SIGEMT` 出现在大多数 UNIX 实现中。然而，在其他实现中，这个信号通常会导致终止并生成核心转储。
- en: In SUSv1, the default action for `SIGURG` was specified as process termination,
    and this is the default in some older UNIX implementations. SUSv2 adopted the
    current specification (ignore).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SUSv1 中，`SIGURG` 的默认动作是进程终止，这也是一些旧版本 UNIX 实现中的默认行为。SUSv2 采用了当前的规范（忽略）。
- en: 'Changing Signal Dispositions: *signal()*'
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改信号处理方式：*signal()*
- en: 'UNIX systems provide two ways of changing the disposition of a signal: *signal()*
    and *sigaction()*. The *signal()* system call, which is described in this section,
    was the original API for setting the disposition of a signal, and it provides
    a simpler interface than *sigaction()*. On the other hand, *sigaction()* provides
    functionality that is not available with *signal()*. Furthermore, there are variations
    in the behavior of *signal()* across UNIX implementations ([Implementation and
    Portability of *signal()*](ch22.html#implementation_and_portability_of_signal
    "Implementation and Portability of signal()")), which mean that it should never
    be used for establishing signal handlers in portable programs. Because of these
    portability issues, *sigaction()* is the (strongly) preferred API for establishing
    a signal handler. After we explain the use of *sigaction()* in [Changing Signal
    Dispositions: *sigaction()*](ch20.html#changing_signal_dispositions_colon_sigac
    "Changing Signal Dispositions: sigaction()"), we’ll always employ that call when
    establishing signal handlers in our example programs.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 'UNIX系统提供了两种更改信号处置的方法：*signal()*和*sigaction()*。*signal()*系统调用，如本节所述，是设置信号处置的原始API，它提供了比*sigaction()*更简单的接口。另一方面，*sigaction()*提供了*signal()*无法提供的功能。此外，由于*signal()*在不同UNIX实现中的行为存在差异（[*signal()*的实现与可移植性](ch22.html#implementation_and_portability_of_signal
    "Implementation and Portability of signal()")），因此它不应在可移植程序中用于设置信号处理程序。由于这些可移植性问题，*sigaction()*是（强烈）推荐的API，用于建立信号处理程序。在我们解释了[更改信号处置：*sigaction()*](ch20.html#changing_signal_dispositions_colon_sigac
    "Changing Signal Dispositions: sigaction()")中的*sigaction()*的使用后，我们将在示例程序中始终使用该调用来建立信号处理程序。'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although documented in section 2 of the Linux manual pages, *signal()* is actually
    implemented in *glibc* as a library function layered on top of the *sigaction()*
    system call.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在Linux手册页的第2节中有文档说明，*signal()*实际上是在*glibc*中作为一个库函数实现的，该库函数是在*sigaction()*系统调用之上封装的。
- en: '[PRE0]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns previous signal disposition on success, or `SIG_ERR` on error
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，则返回先前的信号处置，出错时返回`SIG_ERR`
- en: 'The function prototype for *signal()* requires some decoding. The first argument,
    *sig*, identifies the signal whose disposition we wish to change. The second argument,
    *handler*, is the address of the function that should be called when this signal
    is delivered. This function returns nothing (*void*) and takes one integer argument.
    Thus, a signal handler has the following general form:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*signal()*的函数原型需要一些解码。第一个参数，*sig*，标识我们希望更改其处置的信号。第二个参数，*handler*，是当信号被传递时应该调用的函数的地址。该函数不返回任何值（*void*），并且接受一个整数参数。因此，信号处理程序具有以下通用形式：'
- en: '[PRE1]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We describe the purpose of the *sig* argument to the handler function in Section
    20.4.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第20.4节中描述*sig*参数的用途，传递给处理程序函数。
- en: 'The return value of *signal()* is the previous disposition of the signal. Like
    the *handler* argument, this is a pointer to a function returning nothing and
    taking one integer argument. In other words, we could write code such as the following
    to temporarily establish a handler for a signal, and then reset the disposition
    of the signal to whatever it was previously:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*signal()*的返回值是信号的先前处置。像*handler*参数一样，这是一个指向返回空值并接受一个整数参数的函数的指针。换句话说，我们可以编写如下代码来暂时建立一个信号处理程序，然后将信号的处置重置为其之前的状态：'
- en: '[PRE2]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is not possible to use *signal()* to retrieve the current disposition of
    a signal without at the same time changing that disposition. To do that, we must
    use *sigaction()*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能使用*signal()*来检索信号的当前处置，而不同时改变该处置。要做到这一点，我们必须使用*sigaction()*。
- en: 'We can make the prototype for *signal()* much more comprehensible by using
    the following type definition for a pointer to a signal handler function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用以下类型定义为指向信号处理程序函数的指针，来使*signal()*的原型更易理解：
- en: '[PRE3]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This enables us to rewrite the prototype for *signal()* as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够将*signal()*的原型重写为如下形式：
- en: '[PRE4]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the `_GNU_SOURCE` feature test macro is defined, then *glibc* exposes the
    nonstandard *sighandler_t* data type in the `<signal.h>` header file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了`_GNU_SOURCE`特性测试宏，那么*glibc*会在`<signal.h>`头文件中暴露非标准的*sighandler_t*数据类型。
- en: 'Instead of specifying the address of a function as the *handler* argument of
    *signal()*, we can specify one of the following values:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定以下值之一来替代作为*signal()*的*handler*参数指定一个函数的地址：
- en: '`SIG_DFL`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIG_DFL`'
- en: Reset the disposition of the signal to its default ([Table 20-1](ch20.html#linux_signals
    "Table 20-1. Linux signals")). This is useful for undoing the effect of an earlier
    call to *signal()* that changed the disposition for the signal.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将信号的处理方式重置为默认值（[表 20-1](ch20.html#linux_signals "表 20-1. Linux 信号")）。这对于撤销先前调用
    *signal()* 更改信号处理方式的效果非常有用。
- en: '`SIG_IGN`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIG_IGN`'
- en: Ignore the signal. If the signal is generated for this process, the kernel silently
    discards it. The process never even knows that the signal occurred.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略信号。如果为此进程生成信号，内核会静默丢弃它。该进程甚至不知道信号已经发生。
- en: A successful call to *signal()* returns the previous disposition of the signal,
    which may be the address of a previously installed handler function, or one of
    the constants `SIG_DFL` or `SIG_IGN`. On error, *signal()* returns the value `SIG_ERR`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用 *signal()* 会返回信号的先前处理方式，这可能是一个先前安装的处理程序函数的地址，或者是常量 `SIG_DFL` 或 `SIG_IGN`。如果出错，*signal()*
    会返回 `SIG_ERR`。
- en: Introduction to Signal Handlers
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号处理程序介绍
- en: 'A *signal handler* (also called a *signal catcher*) is a function that is called
    when a specified signal is delivered to a process. We describe the fundamentals
    of signal handlers in this section, and then go into the details in [Chapter 21](ch21.html
    "Chapter 21. Signals: Signal Handlers").'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*信号处理程序*（也称为*信号捕捉器*）是一个函数，当指定的信号传递给进程时会被调用。本节中我们介绍信号处理程序的基本原理，然后在[第 21 章](ch21.html
    "第 21 章. 信号：信号处理程序")中详细讨论。'
- en: Invocation of a signal handler may interrupt the main program flow at any time;
    the kernel calls the handler on the process’s behalf, and when the handler returns,
    execution of the program resumes at the point where the handler interrupted it.
    This sequence is illustrated in [Figure 20-1](ch20.html#signal_delivery_and_handler_execution
    "Figure 20-1. Signal delivery and handler execution").
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理程序的调用可能会在任何时候打断主程序的执行流；内核代表进程调用处理程序，当处理程序返回时，程序会从中断它的地方继续执行。此过程在[图 20-1](ch20.html#signal_delivery_and_handler_execution
    "图 20-1. 信号传递和处理程序执行")中进行了说明。
- en: '![Signal delivery and handler execution](figs/web/20-1_SIG-A-handling.png.jpg)Figure 20-1. Signal
    delivery and handler execution'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![信号传递和处理程序执行](figs/web/20-1_SIG-A-handling.png.jpg)图 20-1. 信号传递和处理程序执行'
- en: Although signal handlers can do virtually anything, they should, in general,
    be designed to be as simple as possible. We expand on this point in Section 21.1.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管信号处理程序几乎可以做任何事情，但一般来说，它们应该设计得尽可能简单。我们在第 21.1 节中扩展了这一点。
- en: Example 20-1. Installing a handler for `SIGINT`
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-1. 安装 `SIGINT` 的处理程序
- en: '[PRE5]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Example 20-1](ch20.html#installing_a_handler_for_sigint "Example 20-1. Installing
    a handler for SIGINT") (in [Sending Signals: *kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "Sending Signals: kill()")) shows a simple example of a signal handler function
    and a main program that establishes it as the handler for the `SIGINT` signal.
    (The terminal driver generates this signal when we type the terminal *interrupt*
    character, usually *Control-C*.) The handler simply prints a message and returns.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20-1](ch20.html#installing_a_handler_for_sigint "示例 20-1. 安装 SIGINT 的处理程序")（在[发送信号：*kill()*](ch20.html#sending_signals_colon_kill_open_parenthe
    "发送信号：kill()")中）展示了一个简单的信号处理程序函数示例和一个主程序，该程序将其作为 `SIGINT` 信号的处理程序。（当我们输入终端的*中断*字符，通常是*控制-C*时，终端驱动程序会生成此信号。）该处理程序仅打印一条消息并返回。'
- en: 'The main program continuously loops. On each iteration, the program increments
    a counter whose value it prints, and then the program sleeps for a few seconds.
    (To sleep in this manner, we use the *sleep()* function, which suspends the execution
    of its caller for a specified number of seconds. We describe this function in
    [Low-Resolution Sleeping: *sleep()*](ch23.html#low-resolution_sleeping_colon_sleep_open
    "Low-Resolution Sleeping: sleep()").)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序不断循环。在每次迭代时，程序增加一个计数器并打印其值，然后程序休眠几秒钟。（为了以这种方式休眠，我们使用*sleep()*函数，它会暂停调用者的执行一段指定的时间。我们在[低分辨率睡眠：*sleep()*](ch23.html#low-resolution_sleeping_colon_sleep_open
    "低分辨率睡眠：sleep()")中描述了这个函数。）
- en: 'When we run the program in [Example 20-1](ch20.html#installing_a_handler_for_sigint
    "Example 20-1. Installing a handler for SIGINT"), we see the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行[示例 20-1](ch20.html#installing_a_handler_for_sigint "示例 20-1. 安装 SIGINT
    的处理程序")中的程序时，我们会看到以下内容：
- en: '[PRE6]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the kernel invokes a signal handler, it passes the number of the signal
    that caused the invocation as an integer argument to the handler. (This is the
    *sig* argument in the handler of [Example 20-1](ch20.html#installing_a_handler_for_sigint
    "Example 20-1. Installing a handler for SIGINT")). If a signal handler catches
    only one type of signal, then this argument is of little use. We can, however,
    establish the same handler to catch different types of signals and use this argument
    to determine which signal caused the handler to be invoked.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核调用信号处理程序时，它将导致调用的信号编号作为整数参数传递给处理程序。（这就是 [示例 20-1](ch20.html#installing_a_handler_for_sigint
    "示例 20-1. 安装 SIGINT 处理程序") 中的 *sig* 参数）。如果一个信号处理程序只捕获一种类型的信号，那么这个参数的作用就不大。然而，我们可以建立相同的处理程序来捕获不同类型的信号，并利用这个参数来确定是哪种信号导致了处理程序的调用。
- en: 'This is illustrated in [Example 20-2](ch20.html#establishing_the_same_handler_for_two_di
    "Example 20-2. Establishing the same handler for two different signals"), a program
    that establishes the same handler for `SIGINT` and `SIGQUIT`. (`SIGQUIT` is generated
    by the terminal driver when we type the terminal *quit* character, usually *Control-\*.)
    The code of the handler distinguishes the two signals by examining the *sig* argument,
    and takes different actions for each signal. In the *main()* function, we use
    *pause()* (described in [Waiting for a Signal: *pause()*](ch20.html#waiting_for_a_signal_colon_pause_open_pa
    "Waiting for a Signal: pause()")) to block the process until a signal is caught.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点在 [示例 20-2](ch20.html#establishing_the_same_handler_for_two_di "示例 20-2.
    为两个不同信号建立相同的处理程序") 中进行了说明，这是一个为 `SIGINT` 和 `SIGQUIT` 建立相同处理程序的程序。(`SIGQUIT` 是当我们输入终端的
    *quit* 字符时，由终端驱动程序生成的信号，通常是 *Control-\*.) 处理程序的代码通过检查 *sig* 参数来区分这两个信号，并对每个信号采取不同的动作。在
    *main()* 函数中，我们使用 *pause()*（在 [等待信号：*pause()*](ch20.html#waiting_for_a_signal_colon_pause_open_pa
    "等待信号：pause()") 中描述）来阻塞进程，直到捕获到信号。
- en: 'The following shell session log demonstrates the use of this program:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 shell 会话日志，演示了这个程序的使用：
- en: '[PRE7]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In [Example 20-1](ch20.html#installing_a_handler_for_sigint "Example 20-1. Installing
    a handler for SIGINT") and [Example 20-2](ch20.html#establishing_the_same_handler_for_two_di
    "Example 20-2. Establishing the same handler for two different signals"), we use
    *printf()* to display the message from the signal handler. For reasons that we
    discuss in [Reentrant and Async-Signal-Safe Functions](ch21.html#reentrant_and_async-signal-safe_function
    "Reentrant and Async-Signal-Safe Functions"), real-world applications should generally
    never call stdio functions from within a signal handler. However, in various example
    programs, we’ll nevertheless call *printf()* from a signal handler as a simple
    means of seeing when the handler is called.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 20-1](ch20.html#installing_a_handler_for_sigint "示例 20-1. 安装 SIGINT 处理程序")
    和 [示例 20-2](ch20.html#establishing_the_same_handler_for_two_di "示例 20-2. 为两个不同信号建立相同的处理程序")
    中，我们使用 *printf()* 来显示信号处理程序的消息。由于我们在 [可重入和异步信号安全函数](ch21.html#reentrant_and_async-signal-safe_function
    "可重入和异步信号安全函数") 中讨论过的原因，现实中的应用程序通常不应从信号处理程序中调用 stdio 函数。然而，在各种示例程序中，我们仍然会从信号处理程序中调用
    *printf()*，作为一种简单的方式来查看何时调用了处理程序。
- en: Example 20-2. Establishing the same handler for two different signals
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-2. 为两个不同信号建立相同的处理程序
- en: '[PRE8]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Sending Signals: *kill()*'
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送信号：*kill()*
- en: One process can send a signal to another process using the *kill()* system call,
    which is the analog of the *kill* shell command. (The term *kill* was chosen because
    the default action of most of the signals that were available on early UNIX implementations
    was to terminate the process.)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程可以使用 *kill()* 系统调用向另一个进程发送信号，这与 *kill* shell 命令类似。（之所以选择 *kill* 这个术语，是因为在早期
    UNIX 实现中，大多数可用信号的默认动作是终止进程。）
- en: '[PRE9]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: 'The *pid* argument identifies one or more processes to which the signal specified
    by *sig* is to be sent. Four different cases determine how *pid* is interpreted:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*pid* 参数标识要发送指定 *sig* 信号的一个或多个进程。四种不同的情况决定了如何解释 *pid*：'
- en: If *pid* is greater than 0, the signal is sent to the process with the process
    ID specified by *pid*.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *pid* 大于 0，信号将发送到由 *pid* 指定的进程 ID 的进程。
- en: If *pid* equals 0, the signal is sent to every process in the same process group
    as the calling process, including the calling process itself. (SUSv3 states that
    the signal should be sent to all processes in the same process group, excluding
    an “unspecified set of system processes” and adds the same qualification to each
    of the remaining cases.)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*pid*等于0，信号会发送到与调用进程属于同一进程组的所有进程，包括调用进程本身。（SUSv3规定，信号应发送到同一进程组的所有进程，但排除了“未指定的一组系统进程”，并对其余情况做出相同的规定。）
- en: If *pid is* less than -1, the signal is sent to all of the processes in the
    process group whose ID equals the absolute value of *pid*. Sending a signal to
    all of the processes in a process group finds particular use in shell job control
    ([Job Control](ch34.html#job_control "Job Control")).
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*pid*小于-1，信号会发送到进程组ID等于*pid*绝对值的所有进程。向进程组中的所有进程发送信号在Shell作业控制中有特定用途（[作业控制](ch34.html#job_control
    "作业控制")）。
- en: If *pid* equals -1, the signal is sent to every process for which the calling
    process has permission to send a signal, except *init* (process ID 1) and the
    calling process. If a privileged process makes this call, then all processes on
    the system will be signaled, except for these last two. For obvious reasons, signals
    sent in this way are sometimes called *broadcast signals*. (SUSv3 doesn’t require
    that the calling process be excluded from receiving the signal; Linux follows
    the BSD semantics in this regard.)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*pid*等于-1，信号会发送到调用进程有权限发送信号的所有进程，但不包括*init*（进程ID 1）和调用进程。如果是特权进程发出此调用，则系统上的所有进程都会收到信号，除了这两个进程。出于显而易见的原因，这种方式发送的信号有时被称为*广播信号*。（SUSv3并不要求排除调用进程接收信号；在这方面，Linux遵循BSD的语义。）
- en: If no process matches the specified *pid*, *kill()* fails and sets *errno* to
    `ESRCH` (“No such process”).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有进程与指定的*pid*匹配，*kill()*会失败，并将*errno*设置为`ESRCH`（“没有这样的进程”）。
- en: 'A process needs appropriate permissions to be able send a signal to another
    process. The permission rules are as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 进程需要适当的权限才能向另一个进程发送信号。权限规则如下：
- en: A privileged (`CAP_KILL`) process may send a signal to any process.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个特权（`CAP_KILL`）进程可以向任何进程发送信号。
- en: The *init* process (process ID 1), which runs with user and group of *root*,
    is a special case. It can be sent only signals for which it has a handler installed.
    This prevents the system administrator from accidentally killing *init*, which
    is fundamental to the operation of the system.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*init*进程（进程ID 1），以*root*的用户和组身份运行，是一个特例。它只能接收有安装处理程序的信号。这可以防止系统管理员不小心终止*init*进程，因为它对于系统的运行至关重要。'
- en: 'An unprivileged process can send a signal to another process if the real or
    effective user ID of the sending process matches the real user ID or saved set-user-ID
    of the receiving process, as shown in [Figure 20-2](ch20.html#permissions_required_for_an_unprivileged
    "Figure 20-2. Permissions required for an unprivileged process to send a signal").
    This rule allows users to send signals to set-user-ID programs that they have
    started, regardless of the current setting of the target process’s effective user
    ID. Excluding the effective user ID of the target from the check serves a complementary
    purpose: it prevents one user from sending signals to another user’s process that
    is running a set-user-ID program belonging to the user trying to send the signal.
    (SUSv3 mandates the rules shown in [Figure 20-2](ch20.html#permissions_required_for_an_unprivileged
    "Figure 20-2. Permissions required for an unprivileged process to send a signal"),
    but Linux followed slightly different rules in kernel versions before 2.0, as
    described in the *kill(2)* manual page.)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发送进程的真实用户ID或有效用户ID与接收进程的真实用户ID或保存的设置用户ID匹配，则一个非特权进程可以向另一个进程发送信号，如[图20-2](ch20.html#permissions_required_for_an_unprivileged
    "图20-2. 非特权进程发送信号所需权限")所示。此规则允许用户向他们启动的设置用户ID程序发送信号，而不管目标进程的当前有效用户ID设置如何。将目标进程的有效用户ID排除在检查之外，具有补充作用：它防止一个用户向另一个用户的进程发送信号，后者正在运行一个属于尝试发送信号的用户的设置用户ID程序。（SUSv3强制执行[图20-2](ch20.html#permissions_required_for_an_unprivileged
    "图20-2. 非特权进程发送信号所需权限")中显示的规则，但Linux在2.0版本之前的内核中遵循了略有不同的规则，具体见*kill(2)*手册页。）
- en: The `SIGCONT` signal is treated specially. An unprivileged process may send
    this signal to any other process in the same session, regardless of user ID checks.
    This rule allows job-control shells to restart stopped jobs (process groups),
    even if the processes of the job have changed their user IDs (i.e., they are privileged
    processes that have used the system calls described in [Retrieving and Modifying
    Process Credentials](ch09.html#retrieving_and_modifying_process_credent "Retrieving
    and Modifying Process Credentials") to change their credentials).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGCONT` 信号有特殊处理。普通进程可以向同一会话中的任何其他进程发送此信号，而不需要检查用户 ID。这一规则允许作业控制 shell 重启停止的作业（进程组），即使作业中的进程已更改其用户
    ID（即它们是使用[检索和修改进程凭据](ch09.html#retrieving_and_modifying_process_credent "检索和修改进程凭据")中描述的系统调用来更改凭据的特权进程").'
- en: '![Permissions required for an unprivileged process to send a signal](figs/web/20-2_SIG-A-perms-scale90.png.jpg)Figure 20-2. Permissions
    required for an unprivileged process to send a signal'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![普通进程发送信号所需的权限](figs/web/20-2_SIG-A-perms-scale90.png.jpg)图 20-2. 普通进程发送信号所需的权限'
- en: If a process doesn’t have permissions to send a signal to the requested *pid*,
    then *kill()* fails, setting *errno* to `EPERM`. Where *pid* specifies a set of
    processes (i.e., *pid* is negative), *kill()* succeeds if at least one of them
    could be signaled.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进程没有权限向指定的*pid* 发送信号，则 *kill()* 调用失败，并将 *errno* 设置为 `EPERM`。当*pid* 指定一组进程（即*pid*
    为负数）时，如果至少有一个进程能够接收信号，则 *kill()* 调用成功。
- en: We demonstrate the use of *kill()* in [Example 20-3](ch20.html#using_the_kill_open_parenthesis_close_pa
    "Example 20-3. Using the kill() system call").
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[示例 20-3](ch20.html#using_the_kill_open_parenthesis_close_pa "示例 20-3. 使用
    kill() 系统调用")中演示了如何使用 *kill()*。
- en: Checking for the Existence of a Process
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查进程是否存在
- en: The *kill()* system call can serve another purpose. If the *sig* argument is
    specified as 0 (the so-called *null signal*), then no signal is sent. Instead,
    *kill()* merely performs error checking to see if the process can be signaled.
    Read another way, this means we can use the null signal to test if a process with
    a specific process ID exists. If sending a null signal fails with the error `ESRCH`,
    then we know the process doesn’t exist. If the call fails with the error `EPERM`
    (meaning the process exists, but we don’t have permission to send a signal to
    it) or succeeds (meaning we do have permission to send a signal to the process),
    then we know that the process exists.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*kill()* 系统调用可以用于另一个目的。如果*sig* 参数指定为 0（所谓的*空信号*），则不会发送任何信号。相反，*kill()* 仅执行错误检查，以查看是否可以向进程发送信号。换句话说，我们可以使用空信号来测试某个特定进程
    ID 的进程是否存在。如果发送空信号时出现错误`ESRCH`，则说明该进程不存在。如果调用失败并出现错误`EPERM`（意味着进程存在，但我们没有权限向其发送信号）或成功（意味着我们有权限向该进程发送信号），则说明该进程存在。'
- en: Verifying the existence of a particular process ID doesn’t guarantee that a
    particular program is still running. Because the kernel recycles process IDs as
    processes are born and die, the same process ID may, over time, refer to a different
    process. Furthermore, a particular process ID may exist, but be a zombie (i.e.,
    a process that has died, but whose parent has not yet performed a *wait()* to
    obtain its termination status, as described in [Orphans and Zombies](ch26.html#orphans_and_zombies
    "Orphans and Zombies")).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 验证某个特定进程 ID 是否存在并不能保证该程序仍在运行。因为内核在进程出生和死亡时会回收进程 ID，随着时间的推移，相同的进程 ID 可能会指向一个不同的进程。此外，某个特定进程
    ID 可能存在，但它是一个僵尸进程（即已终止的进程，但其父进程尚未执行*wait()* 来获取其终止状态，详见[孤儿进程和僵尸进程](ch26.html#orphans_and_zombies
    "孤儿进程和僵尸进程")）。
- en: 'Various other techniques can also be used to check whether a particular process
    is running, including the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用其他各种技术来检查某个特定进程是否在运行，包括以下方法：
- en: '*The wait() system calls*: These calls are described in [Chapter 26](ch26.html
    "Chapter 26. Monitoring Child Processes"). They can be employed only if the monitored
    process is a child of the caller.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*wait()* 系统调用：这些调用在[第26章](ch26.html "第26章。监控子进程")中有描述。它们只能在被监控的进程是调用者的子进程时使用。'
- en: '*Semaphores and exclusive file locks*: If the process that is being monitored
    continuously holds a semaphore or a file lock, then, if we can acquire the semaphore
    or lock, we know the process has terminated. We describe semaphores in [Chapter 47](ch47.html
    "Chapter 47. System V Semaphores") and [Chapter 53](ch53.html "Chapter 53. POSIX
    Semaphores") and file locks in [Chapter 55](ch55.html "Chapter 55. File Locking").'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信号量和独占文件锁*：如果被监控的进程持续持有一个信号量或文件锁，那么，如果我们能够获取该信号量或锁，就可以知道该进程已终止。我们在[第 47 章](ch47.html
    "第 47 章. System V 信号量")和[第 53 章](ch53.html "第 53 章. POSIX 信号量")中描述了信号量，在[第 55
    章](ch55.html "第 55 章. 文件锁")中描述了文件锁。'
- en: '*IPC channels such as pipes and FIFOs*: We set up the monitored process so
    that it holds a file descriptor open for writing on the channel as long as it
    is alive. Meanwhile, the monitoring process holds open a read descriptor for the
    channel, and it knows that the monitored process has terminated when the write
    end of the channel is closed (because it sees end-of-file). The monitoring process
    can determine this either by reading from its file descriptor or by monitoring
    the descriptor using one of the techniques described in [Chapter 63](ch63.html
    "Chapter 63. Alternative I/O Models").'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IPC 通道，如管道和 FIFO*：我们设置被监控的进程，使其在存活期间始终保持一个用于写入的文件描述符打开。与此同时，监控进程保持一个读取描述符打开，并且当通道的写入端关闭时（因为它看到文件结束），它就知道被监控进程已经终止。监控进程可以通过读取文件描述符或使用[第
    63 章](ch63.html "第 63 章. 替代 I/O 模型")中描述的技术来监视该描述符，从而确定这一点。'
- en: '*The* `/proc/`*PID interface*: For example, if a process with the process ID
    12345 exists, then the directory `/proc/12345` will exist, and we can check this
    using a call such as *stat()*.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`/proc/`PID 接口*：例如，如果存在进程 ID 为 12345 的进程，那么目录 `/proc/12345` 会存在，我们可以使用 *stat()*
    等调用来检查这一点。'
- en: All of these techniques, except the last, are unaffected by recycling of process
    IDs.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后一种方法，所有这些技术都不受进程 ID 回收的影响。
- en: '[Example 20-3](ch20.html#using_the_kill_open_parenthesis_close_pa "Example 20-3. Using
    the kill() system call") demonstrates the use of *kill()*. This program takes
    two command-line arguments, a signal number and a process ID, and uses *kill()*
    to send the signal to the specified process. If signal 0 (the null signal) is
    specified, then the program reports on the existence of the target process.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20-3](ch20.html#using_the_kill_open_parenthesis_close_pa "示例 20-3. 使用 kill()
    系统调用") 演示了 *kill()* 的使用。这个程序接受两个命令行参数，一个是信号编号，另一个是进程 ID，并使用 *kill()* 将信号发送到指定的进程。如果指定信号
    0（空信号），程序会报告目标进程是否存在。'
- en: 'Other Ways of Sending Signals: *raise()* and *killpg()*'
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送信号的其他方式：*raise()* 和 *killpg()*
- en: Sometimes, it is useful for a process to send a signal to itself. (We see an
    example of this in [Handling Job-Control Signals](ch34.html#handling_job-control_signals
    "Handling Job-Control Signals").) The *raise()* function performs this task.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，进程需要向自己发送信号。（我们在[处理作业控制信号](ch34.html#handling_job-control_signals "处理作业控制信号")中看到过这个例子。）*raise()*
    函数执行此任务。
- en: '[PRE10]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or nonzero on error
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回非零值。
- en: 'In a single-threaded program, a call to *raise()* is equivalent to the following
    call to *kill()*:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在单线程程序中，调用 *raise()* 等同于以下调用 *kill()*：
- en: '[PRE11]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On a system that supports threads, *raise(sig)* is implemented as:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持线程的系统中，*raise(sig)* 的实现方式如下：
- en: '[PRE12]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We describe the *pthread_kill()* function in [Sending a Signal to a Thread](ch33.html#sending_a_signal_to_a_thread
    "Sending a Signal to a Thread"), but for now it is sufficient to say that this
    implementation means that the signal will be delivered to the specific thread
    that called *raise()*. By contrast, the call *kill(getpid(), sig)* sends a signal
    to the calling *process*, and that signal may be delivered to any thread in the
    process.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[发送信号到线程](ch33.html#sending_a_signal_to_a_thread "发送信号到线程")中描述了 *pthread_kill()*
    函数，但现在可以简单地说，这个实现意味着信号将被发送到调用 *raise()* 的特定线程。相反，调用 *kill(getpid(), sig)* 会将信号发送到调用的
    *进程*，该信号可能会被传递到进程中的任何线程。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *raise()* function originates from C89\. The C standards don’t cover operating
    system details such as process IDs, but *raise()* can be specified within the
    C standard because it doesn’t require reference to process IDs.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*raise()* 函数源自 C89。C 标准没有涵盖操作系统的细节，如进程 ID，但 *raise()* 可以在 C 标准中指定，因为它不需要引用进程
    ID。'
- en: When a process sends itself a signal using *raise()* (or *kill()*), the signal
    is delivered immediately (i.e., before *raise()* returns to the caller).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程使用 *raise()*（或 *kill()*）向自己发送信号时，信号会立即传递（即在 *raise()* 返回给调用者之前）。
- en: Note that *raise()* returns a nonzero value (not necessarily -1) on error. The
    only error that can occur with *raise()* is `EINVAL`, because *sig* was invalid.
    Therefore, where we specify one of the `SIGxxxx` constants, we don’t check the
    return status of this function.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*raise()* 在出错时会返回一个非零值（不一定是 -1）。*raise()* 唯一可能发生的错误是 `EINVAL`，因为 *sig* 无效。因此，在我们指定一个
    `SIGxxxx` 常量时，通常不检查此函数的返回状态。
- en: Example 20-3. Using the *kill()* system call
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-3. 使用 *kill()* 系统调用
- en: '[PRE13]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The *killpg()* function sends a signal to all of the members of a process group.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*killpg()* 函数会向进程组中的所有成员发送信号。'
- en: '[PRE14]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: 'A call to *killpg()* is equivalent to the following call to *kill()*:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 *killpg()* 等同于以下调用 *kill()*：
- en: '[PRE15]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If *pgrp* is specified as 0, then the signal is sent to all processes in the
    same process group as the caller. SUSv3 leaves this point unspecified, but most
    UNIX implementations interpret this case in the same way as Linux.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *pgrp* 被指定为 0，则信号会发送给与调用者处于同一进程组的所有进程。SUSv3 没有对这一点做出说明，但大多数 UNIX 实现将此情况与
    Linux 解释相同。
- en: Displaying Signal Descriptions
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示信号描述
- en: Each signal has an associated printable description. These descriptions are
    listed in the array *sys_siglist*. For example, we can refer to *sys_siglist[SIGPIPE]*
    to get the description for `SIGPIPE` (broken pipe). However, rather than using
    the *sys_siglist* array directly, the *strsignal()* function is preferable.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 每个信号都有一个关联的可打印描述。这些描述列在 *sys_siglist* 数组中。例如，我们可以通过 *sys_siglist[SIGPIPE]* 来获取
    `SIGPIPE`（管道破裂）的描述。然而，与直接使用 *sys_siglist* 数组相比，使用 *strsignal()* 函数更为推荐。
- en: '[PRE16]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to signal description string
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向信号描述字符串的指针
- en: The *strsignal()* function performs bounds checking on the *sig* argument, and
    then returns a pointer to a printable description of the signal, or a pointer
    to an error string if the signal number was invalid. (On some other UNIX implementations,
    *strsignal()* returns `NULL` if *sig* is invalid.)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*strsignal()* 函数对 *sig* 参数执行边界检查，然后返回指向信号可打印描述的指针，或者如果信号号码无效，则返回指向错误字符串的指针。（在一些其他
    UNIX 实现中，如果 *sig* 无效，*strsignal()* 返回 `NULL`。）'
- en: Aside from bounds checking, another advantage of *strsignal()* over the direct
    use of *sys_siglist* is that *strsignal()* is locale-sensitive ([Locales](ch10.html#locales
    "Locales")), so that signal descriptions will be displayed in the local language.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 除了边界检查之外，*strsignal()* 相对于直接使用 *sys_siglist* 的另一个优点是，*strsignal()* 是受区域设置影响的（[区域设置](ch10.html#locales
    "Locales")），因此信号描述会以本地语言显示。
- en: An example of the use of *strsignal()* is shown in [Example 20-4](ch20.html#functions_for_displaying_signal_sets
    "Example 20-4. Functions for displaying signal sets").
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *strsignal()* 的示例见 [示例 20-4](ch20.html#functions_for_displaying_signal_sets
    "示例 20-4. 显示信号集的函数")。
- en: The *psignal()* function displays (on standard error) the string given in its
    argument *msg*, followed by a colon, and then the signal description corresponding
    to *sig*. Like *strsignal()*, *psignal()* is locale-sensitive.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*psignal()* 函数会在标准错误输出上显示其参数 *msg* 中给定的字符串，后跟冒号，然后是与 *sig* 对应的信号描述。像 *strsignal()*
    一样，*psignal()* 是受区域设置影响的。'
- en: '[PRE17]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Although *psignal()*, *strsignal()*, and *sys_siglist* are not standardized
    as part of SUSv3, they are nevertheless available on many UNIX implementations.
    (SUSv4 adds specifications for *psignal()* and *strsignal()*.)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 *psignal()*、*strsignal()* 和 *sys_siglist* 并未在 SUSv3 中标准化，但它们在许多 UNIX 实现中是可用的。（SUSv4
    为 *psignal()* 和 *strsignal()* 添加了规范。）
- en: Signal Sets
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号集
- en: Many signal-related system calls need to be able to represent a group of different
    signals. For example, *sigaction()* and *sigprocmask()* allow a program to specify
    a group of signals that are to be blocked by a process, while *sigpending()* returns
    a group of signals that are currently pending for a process. (We describe these
    system calls shortly.)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 许多与信号相关的系统调用需要能够表示一组不同的信号。例如，*sigaction()* 和 *sigprocmask()* 允许程序指定一组信号，这些信号会被进程阻塞，而
    *sigpending()* 返回一个当前正在等待的信号组。（我们稍后会描述这些系统调用。）
- en: Multiple signals are represented using a data structure called a *signal set*,
    provided by the system data type *sigset_t*. SUSv3 specifies a range of functions
    for manipulating signal sets, and we now describe these functions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 多个信号使用一种名为*信号集*的数据结构表示，该数据结构由系统数据类型*sigset_t*提供。SUSv3规定了一系列用于操作信号集的函数，我们现在将介绍这些函数。
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, as on most UNIX implementations, the *sigset_t* data type is a bit
    mask. However, SUSv3 doesn’t require this. A signal set could conceivably be represented
    using some other kind of structure. SUSv3 requires only that the type of *sigset_t*
    be assignable. Thus, it must be implemented using either some scalar type (e.g.,
    an integer) or a C structure (perhaps containing an array of integers).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，与大多数UNIX实现一样，*sigset_t*数据类型是一个位掩码。然而，SUSv3并不要求这一点。信号集也可以使用其他类型的结构来表示。SUSv3只要求*sigset_t*的类型是可赋值的。因此，它必须使用标量类型（例如整数）或C结构体（可能包含整数数组）来实现。
- en: The *sigemptyset()* function initializes a signal set to contain no members.
    The *sigfillset()* function initializes a set to contain all signals (including
    all realtime signals).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigemptyset()*函数初始化一个信号集，使其不包含任何成员。*sigfillset()*函数初始化一个信号集，使其包含所有信号（包括所有实时信号）。'
- en: '[PRE18]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: One of *sigemptyset()* or *sigaddset() must* be used to initialize a signal
    set. This is because C doesn’t initialize automatic variables, and the initialization
    of static variables to 0 can’t portably be relied upon as indicating an empty
    signal set, since signal sets may be implemented using structures other than bit
    masks. (For the same reason, it is incorrect to use *memset(3)* to zero the contents
    of a signal set in order to mark it as empty.)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用*sigemptyset()*或*sigaddset()*来初始化信号集。这是因为C语言不会自动初始化变量，而静态变量初始化为0不能可靠地用于标记一个空的信号集，因为信号集可能会使用除位掩码之外的其他结构来实现。（出于同样的原因，使用*memset(3)*将信号集内容置零以标记其为空是不正确的。）
- en: After initialization, individual signals can be added to a set using *sigaddset()*
    and removed using *sigdelset()*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，可以使用*sigaddset()*将单个信号添加到集合中，使用*sigdelset()*将信号从集合中移除。
- en: '[PRE19]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: For both *sigaddset()* and *sigdelset()*, the *sig* argument is a signal number.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*sigaddset()*和*sigdelset()*，*sig*参数是一个信号编号。
- en: The *sigismember()* function is used to test for membership of a set.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigismember()*函数用于测试集合的成员资格。'
- en: '[PRE20]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 1 if *sig* is a member of *set*, otherwise 0
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*sig*是*set*的成员，返回1；否则返回0
- en: The *sigismember()* function returns 1 (true) if *sig* is a member of *set*,
    and 0 (false) otherwise.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigismember()*函数如果*sig*是*set*的成员，返回1（真）；否则返回0（假）。'
- en: The GNU C library implements three nonstandard functions that perform tasks
    that are complementary to the standard signal set functions just described.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C库实现了三个非标准函数，这些函数执行的任务是标准信号集函数的补充。
- en: '[PRE21]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return 0 on success, or -1 on error
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: '[PRE22]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 1 if *sig* is empty, otherwise 0
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*sig*为空，返回1；否则返回0
- en: 'These functions perform the following tasks:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数执行以下任务：
- en: '*sigandset()* places the intersection of the sets *left* and *right* in the
    set *dest*;'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sigandset()*将*left*和*right*集合的交集放入*dest*集合中；'
- en: '*sigorset()* places the union of the sets *left* and *right* in the set *dest*;
    and'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sigorset()*将*left*和*right*集合的并集放入*dest*集合中；并且'
- en: '*sigisemptyset()* returns true if *set* contains no signals.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sigisemptyset()*如果*set*不包含任何信号，则返回真。'
- en: Example program
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: Using the functions described in this section, we can write the functions shown
    in [Example 20-4](ch20.html#functions_for_displaying_signal_sets "Example 20-4. Functions
    for displaying signal sets"), which we employ in various later programs. The first
    of these, *printSigset()*, displays the signals that are members of the specified
    signal set. This function uses the `NSIG` constant, which is defined in `<signal.h>`
    to be one greater than the highest signal number. We use `NSIG` as the upper bound
    in a loop that tests all signal numbers for membership of a set.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本节中描述的函数，我们可以编写在[示例20-4](ch20.html#functions_for_displaying_signal_sets "示例20-4：显示信号集的函数")中展示的函数，这些函数在后续程序中被广泛使用。其中第一个，*printSigset()*，显示指定信号集中的信号成员。该函数使用`NSIG`常量，它在`<signal.h>`中定义，值比最高信号编号大1。我们在一个循环中使用`NSIG`作为上限，测试所有信号编号是否属于某个集合。
- en: Note
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although `NSIG` is not specified in SUSv3, it is defined on most UNIX implementations.
    However, it may be necessary to use implementation-specific compiler options to
    make it visible. For example, on Linux, we must define one of the feature test
    macros `_BSD_SOURCE`, `_SVID_SOURCE`, or `_GNU_SOURCE`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`NSIG`在SUSv3中没有明确规定，但它在大多数UNIX实现中都有定义。然而，可能需要使用特定于实现的编译器选项来使其可见。例如，在Linux上，我们必须定义以下某个特性测试宏：`_BSD_SOURCE`、`_SVID_SOURCE`或`_GNU_SOURCE`。
- en: The *printSigMask()* and *printPendingSigs()* functions employ *printSigset()*
    to display, respectively, the process signal mask and the set of currently pending
    signals. The *printSigMask()* and *printPendingSigs()* functions use the *sigprocmask()*
    and *sigpending()* system calls, respectively. We describe the *sigprocmask()*
    and *sigpending()* system calls in [The Signal Mask (Blocking Signal Delivery)](ch20.html#the_signal_mask_open_parenthesis_blockin
    "The Signal Mask (Blocking Signal Delivery)") and [Pending Signals](ch20.html#pending_signals
    "Pending Signals").
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*printSigMask()*和*printPendingSigs()*函数使用*printSigset()*分别显示进程信号屏蔽字和当前挂起的信号集合。*printSigMask()*和*printPendingSigs()*函数分别使用*sigprocmask()*和*sigpending()*系统调用。我们在[信号屏蔽字（阻塞信号传递）](ch20.html#the_signal_mask_open_parenthesis_blockin
    "The Signal Mask (Blocking Signal Delivery)")和[挂起的信号](ch20.html#pending_signals
    "Pending Signals")中描述了*sigprocmask()*和*sigpending()*系统调用。'
- en: Example 20-4. Functions for displaying signal sets
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-4. 显示信号集的函数
- en: '[PRE23]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Signal Mask (Blocking Signal Delivery)
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号屏蔽字（阻塞信号传递）
- en: For each process, the kernel maintains a *signal mask*—a set of signals whose
    delivery to the process is currently blocked. If a signal that is blocked is sent
    to a process, delivery of that signal is delayed until it is unblocked by being
    removed from the process signal mask. (In [How the UNIX Signal Model Maps to Threads](ch33.html#how_the_unix_signal_model_maps_to_thread
    "How the UNIX Signal Model Maps to Threads"), we’ll see that the signal mask is
    actually a per-thread attribute, and that each thread in a multithreaded process
    can independently examine and modify its signal mask using the *pthread_sigmask()*
    function.)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个进程，内核维护一个*信号屏蔽字*—一个当前阻塞传递给该进程的信号集合。如果向进程发送一个被阻塞的信号，信号的传递会被延迟，直到它通过从进程信号屏蔽字中移除而被解锁。（在[UNIX信号模型如何映射到线程](ch33.html#how_the_unix_signal_model_maps_to_thread
    "How the UNIX Signal Model Maps to Threads")中，我们将看到信号屏蔽字实际上是每个线程的属性，并且在多线程进程中，每个线程可以独立检查和修改其信号屏蔽字，方法是使用*pthread_sigmask()*函数。）
- en: 'A signal may be added to the signal mask in the following ways:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 信号可以通过以下方式添加到信号屏蔽字中：
- en: When a signal handler is invoked, the signal that caused its invocation can
    be automatically added to the signal mask. Whether or not this occurs depends
    on the flags used when the handler is established using *sigaction()*.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当信号处理程序被调用时，触发该调用的信号可以自动添加到信号屏蔽字中。是否发生这种情况取决于在使用*sigaction()*建立处理程序时所使用的标志。
- en: When a signal handler is established with *sigaction()*, it is possible to specify
    an additional set of signals that are to be blocked when the handler is invoked.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用*sigaction()*建立信号处理程序时，可以指定在处理程序调用时需要阻塞的额外信号集。
- en: The *sigprocmask()* system call can be used at any time to explicitly add signals
    to, and remove signals from, the signal mask.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以随时使用*sigprocmask()*系统调用显式地将信号添加到信号屏蔽字中，或从信号屏蔽字中移除信号。
- en: 'We delay discussion of the first two cases until we examine *sigaction()* in
    [Changing Signal Dispositions: *sigaction()*](ch20.html#changing_signal_dispositions_colon_sigac
    "Changing Signal Dispositions: sigaction()"), and discuss *sigprocmask()* now.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将延迟讨论前两个情况，直到我们在[更改信号分配：*sigaction()*](ch20.html#changing_signal_dispositions_colon_sigac
    "Changing Signal Dispositions: sigaction()")中讨论*sigaction()*，现在讨论*sigprocmask()*。'
- en: '[PRE24]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: 'We can use *sigprocmask()* to change the process signal mask, to retrieve the
    existing mask, or both. The *how* argument determines the changes that *sigprocmask()*
    makes to the signal mask:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*sigprocmask()*来改变进程的信号屏蔽字，获取当前的屏蔽字，或两者兼顾。*how*参数决定了*sigprocmask()*对信号屏蔽字所做的更改：
- en: '`SIG_BLOCK`'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIG_BLOCK`'
- en: The signals specified in the signal set pointed to by *set* are added to the
    signal mask. In other words, the signal mask is set to the union of its current
    value and *set*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 指定在*set*指向的信号集中的信号将被添加到信号屏蔽字中。换句话说，信号屏蔽字将被设置为其当前值与*set*的并集。
- en: '`SIG_UNBLOCK`'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIG_UNBLOCK`'
- en: The signals in the signal set pointed to by *set* are removed from the signal
    mask. Unblocking a signal that is not currently blocked doesn’t cause an error
    to be returned.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 指向*set*的信号集中的信号会从信号掩码中移除。解除对一个当前未被阻塞的信号的阻塞并不会导致错误返回。
- en: '`SIG_SETMASK`'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIG_SETMASK`'
- en: The signal set pointed to by *set* is assigned to the signal mask.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 指向*set*的信号集会被赋值到信号掩码中。
- en: In each case, if the *oldset* argument is not `NULL`, it points to a *sigset_t*
    buffer that is used to return the previous signal mask.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，如果*oldset*参数不为`NULL`，它指向一个*sigset_t*缓冲区，用于返回先前的信号掩码。
- en: If we want to retrieve the signal mask without changing it, then we can specify
    `NULL` for the *set* argument, in which case the *how* argument is ignored.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望检索信号掩码而不做任何修改，那么可以为*set*参数指定`NULL`，在这种情况下，*how*参数会被忽略。
- en: To temporarily prevent delivery of a signal, we can use the series of calls
    shown in [Example 20-5](ch20.html#temporarily_blocking_delivery_of_a_signa "Example 20-5. Temporarily
    blocking delivery of a signal") to block the signal, and then unblock it by resetting
    the signal mask to its previous state.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了暂时阻止信号的传递，我们可以使用[示例20-5](ch20.html#temporarily_blocking_delivery_of_a_signa
    "示例20-5. 暂时阻止信号传递")中所示的一系列调用来阻塞信号，然后通过将信号掩码重置为之前的状态来解除阻塞。
- en: Example 20-5. Temporarily blocking delivery of a signal
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 示例20-5. 暂时阻止信号传递
- en: '[PRE25]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: SUSv3 specifies that if any pending signals are unblocked by a call to *sigprocmask()*,
    then at least one of those signals will be delivered before the call returns.
    In other words, if we unblock a pending signal, it is delivered to the process
    immediately.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规定，如果通过调用*sigprocmask()*解除阻塞任何待处理信号，那么至少有一个信号会在调用返回之前被传递。换句话说，如果我们解除阻塞一个待处理信号，它会立即传递给进程。
- en: 'Attempts to block `SIGKILL` and `SIGSTOP` are silently ignored. If we attempt
    to block these signals, *sigprocmask()* neither honors the request nor generates
    an error. This means that we can use the following code to block all signals except
    `SIGKILL` and `SIGSTOP`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试阻塞`SIGKILL`和`SIGSTOP`会被默默忽略。如果我们尝试阻塞这些信号，*sigprocmask()*既不会遵从请求，也不会生成错误。这意味着我们可以使用以下代码阻塞所有信号，除了`SIGKILL`和`SIGSTOP`：
- en: '[PRE26]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Pending Signals
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 待处理信号
- en: If a process receives a signal that it is currently blocking, that signal is
    added to the process’s set of pending signals. When (and if) the signal is later
    unblocked, it is then delivered to the process. To determine which signals are
    pending for a process, we can call *sigpending()*.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个进程接收到一个它当前正在阻塞的信号，该信号会被添加到进程的待处理信号集中。当（如果）该信号后来被解除阻塞时，它会被传递给进程。要确定一个进程的待处理信号，我们可以调用*sigpending()*。
- en: '[PRE27]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 成功返回0，错误返回-1
- en: The *sigpending()* system call returns the set of signals that are pending for
    the calling process in the *sigset_t* structure pointed to by *set*. We can then
    examine *set* using the *sigismember()* function described in Section 20.9.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigpending()*系统调用会返回调用进程的待处理信号集，存储在*set*指向的*sigset_t*结构中。然后我们可以使用第20.9节中描述的*sigismember()*函数来检查*set*。'
- en: If we change the disposition of a pending signal, then, when the signal is later
    unblocked, it is handled according to its new disposition. Although not often
    used, one application of this technique is to prevent the delivery of a pending
    signal by setting its disposition to `SIG_IGN`, or to `SIG_DFL` if the default
    action for the signal is *ignore*. As a result, the signal is removed from the
    process’s set of pending signals and thus not delivered.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更改一个待处理信号的处置方式，那么当该信号后续被解除阻塞时，它会根据新的处置方式来处理。虽然这种方法不常用，但其中一个应用是通过将信号的处置方式设置为`SIG_IGN`来防止待处理信号的传递，或者如果该信号的默认行为是*忽略*，则设置为`SIG_DFL`。这样，信号就会从进程的待处理信号集中移除，从而不再传递。
- en: Signals Are Not Queued
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号不会排队
- en: The set of pending signals is only a mask; it indicates whether or not a signal
    has occurred, but not how many times it has occurred. In other words, if the same
    signal is generated multiple times while it is blocked, then it is recorded in
    the set of pending signals, and later delivered, just once. (One of the differences
    between standard and realtime signals is that realtime signals are queued, as
    discussed in Section 22.8.)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 待处理信号集只是一个掩码；它仅表示某个信号是否已经发生，但不表示信号发生的次数。换句话说，如果在信号被阻塞期间同一个信号被多次生成，它会被记录在待处理信号集中，之后仅会传递一次。（标准信号和实时信号之间的一个区别是，实时信号是排队的，如第22.8节所讨论的。）
- en: '[Example 20-6](ch20.html#sending_multiple_signals "Example 20-6. Sending multiple
    signals") and [Example 20-7](ch20.html#catching_and_counting_signals "Example 20-7. Catching
    and counting signals") show two programs that can be used to observe that signals
    are not queued. The program in [Example 20-6](ch20.html#sending_multiple_signals
    "Example 20-6. Sending multiple signals") takes up to four command-line arguments,
    as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20-6](ch20.html#sending_multiple_signals "示例 20-6. 发送多个信号")和[示例 20-7](ch20.html#catching_and_counting_signals
    "示例 20-7. 捕获和计数信号")展示了可以用来观察信号不会排队的两个程序。[示例 20-6](ch20.html#sending_multiple_signals
    "示例 20-6. 发送多个信号")中的程序最多接受四个命令行参数，具体如下：'
- en: '[PRE28]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first argument is the process ID of a process to which the program should
    send signals. The second argument specifies the number of signals to be sent to
    the target process. The third argument specifies the signal number that is to
    be sent to the target process. If a signal number is supplied as the fourth argument,
    then the program sends one instance of that signal after sending the signals specified
    by the previous arguments. In the example shell session below, we use this final
    argument to send a `SIGINT` signal to the target process; the purpose of sending
    this signal will become clear in a moment.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是程序应该向其发送信号的进程ID。第二个参数指定要发送给目标进程的信号数量。第三个参数指定要发送给目标进程的信号编号。如果第四个参数提供了一个信号编号，那么程序会在发送前面参数指定的信号后，发送该信号编号的一个实例。在下面的示例
    Shell 会话中，我们使用这个最终参数向目标进程发送`SIGINT`信号；稍后发送此信号的目的将变得清晰。
- en: Example 20-6. Sending multiple signals
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-6. 发送多个信号
- en: '[PRE29]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The program shown in [Example 20-7](ch20.html#catching_and_counting_signals
    "Example 20-7. Catching and counting signals") is designed to catch and report
    statistics on signals sent by the program in [Example 20-6](ch20.html#sending_multiple_signals
    "Example 20-6. Sending multiple signals"). This program performs the following
    steps:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 20-7](ch20.html#catching_and_counting_signals "示例 20-7. 捕获和计数信号")中展示的程序旨在捕获并报告由[示例
    20-6](ch20.html#sending_multiple_signals "示例 20-6. 发送多个信号")中的程序发送的信号统计信息。此程序执行以下步骤：
- en: The program sets up a single handler to catch all signals ![](figs/web/U002.png).
    (It isn’t possible to catch `SIGKILL` and `SIGSTOP`, but we ignore the error that
    occurs when trying to establish a handler for these signals.) For most types of
    signals, the handler ![](figs/web/U001.png) simply counts the signal using an
    array. If `SIGINT` is received, the handler sets a flag (*gotSigint*) that causes
    the program to exit its main loop (the `while` loop described below). (We explain
    the use of the `volatile` qualifier and the *sig_atomic_t* data type used to declare
    the *gotSigint* variable in [Global Variables and the *sig_atomic_t* Data Type](ch21.html#global_variables_and_the_sig_underscore
    "Global Variables and the sig_atomic_t Data Type").)
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序设置了一个处理程序来捕获所有信号 ![](figs/web/U002.png)。 （无法捕获`SIGKILL`和`SIGSTOP`信号，但我们忽略尝试为这些信号建立处理程序时发生的错误。）对于大多数类型的信号，处理程序
    ![](figs/web/U001.png) 仅使用数组对信号进行计数。如果接收到`SIGINT`，处理程序会设置一个标志（*gotSigint*），使得程序退出其主循环（下面描述的`while`循环）。
    （我们将在[全局变量和*sig_atomic_t*数据类型](ch21.html#global_variables_and_the_sig_underscore
    "全局变量和sig_atomic_t数据类型")中解释`volatile`限定符和用于声明*gotSigint*变量的*sig_atomic_t*数据类型的使用。）
- en: If a command-line argument was supplied to the program, then the program blocks
    all signals for the number of seconds specified by that argument, and then, prior
    to unblocking the signals, displays the set of pending signals ![](figs/web/U003.png).
    This allows us to send signals to the process before it commences the following
    step.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果程序接收到命令行参数，那么程序会在该参数指定的秒数内屏蔽所有信号，随后在解除屏蔽信号之前，显示挂起信号的集合 ![](figs/web/U003.png)。这允许我们在程序开始执行下一步之前向其发送信号。
- en: 'The program executes a `while` loop that consumes CPU time until *gotSigint*
    is set ![](figs/web/U004.png). ([Waiting for a Signal: *pause()*](ch20.html#waiting_for_a_signal_colon_pause_open_pa
    "Waiting for a Signal: pause()") and [Waiting for a Signal Using a Mask: *sigsuspend()*](ch22.html#waiting_for_a_signal_using_a_mask_colon
    "Waiting for a Signal Using a Mask: sigsuspend()") describe the use of *pause()*
    and *sigsuspend()*, which are more CPU-efficient ways of waiting for the arrival
    of a signal.)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序执行一个`while`循环，消耗 CPU 时间，直到*gotSigint* 被设置为 ![](figs/web/U004.png)。([等待信号：*pause()*](ch20.html#waiting_for_a_signal_colon_pause_open_pa)
    和 [使用屏蔽等待信号：*sigsuspend()*](ch22.html#waiting_for_a_signal_using_a_mask_colon)
    描述了使用 *pause()* 和 *sigsuspend()*，它们是等待信号到达时更节省 CPU 的方法。)
- en: After exiting the `while` loop, the program displays counts of all signals received
    ![](figs/web/U005.png).
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出`while`循环后，程序会显示所有接收到的信号的计数 ![](figs/web/U005.png)。
- en: We first use these two programs to illustrate that a blocked signal is delivered
    only once, no matter how many times it is generated. We do this by specifying
    a sleep interval for the receiver and sending all signals before the sleep interval
    completes.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用这两个程序来说明，阻塞的信号只有在生成多次的情况下也只会被传递一次。我们通过为接收方指定一个睡眠间隔，并在睡眠间隔完成之前发送所有信号来实现这一点。
- en: '[PRE30]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The command-line arguments to the sending program specified the `SIGUSR1` and
    `SIGINT` signals, which are signals 10 and 2, respectively, on Linux/x86.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 发送程序的命令行参数指定了`SIGUSR1`和`SIGINT`信号，它们分别是 Linux/x86 上的信号 10 和 2。
- en: From the output above, we can see that even though one million signals were
    sent, only one was delivered to the receiver.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出可以看出，尽管发送了百万个信号，但只有一个信号被传递给接收方。
- en: 'Even if a process doesn’t block signals, it may receive fewer signals than
    are sent to it. This can happen if the signals are sent so fast that they arrive
    before the receiving process has a chance to be scheduled for execution by the
    kernel, with the result that the multiple signals are recorded just once in the
    process’s pending signal set. If we execute the program in [Example 20-7](ch20.html#catching_and_counting_signals
    "Example 20-7. Catching and counting signals") with no command-line arguments
    (so that it doesn’t block signals and sleep), we see the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 即使进程没有阻塞信号，它也可能接收到的信号数量少于发送给它的信号数量。如果信号发送得太快，以至于它们在接收进程被内核调度执行之前就到达，那么多个信号将只在进程的待处理信号集里记录一次。如果我们在没有命令行参数的情况下执行[示例
    20-7](ch20.html#catching_and_counting_signals)（这样它不会阻塞信号和睡眠），我们会看到以下结果：
- en: '[PRE31]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Of the million signals sent, just 52 were caught by the receiving process. (The
    precise number of signals caught will vary depending on the vagaries of decisions
    made by the kernel scheduling algorithm.) The reason for this is that each time
    the sending program is scheduled to run, it sends multiple signals to the receiver.
    However, only one of these signals is marked as pending and then delivered when
    the receiver has a chance to run.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送的百万个信号中，只有 52 个被接收进程捕获。（被捕获的信号的准确数量会根据内核调度算法的决定变化。）出现这种情况的原因是，每次发送程序被调度执行时，它会向接收方发送多个信号。然而，只有一个信号会被标记为待处理，并且在接收方有机会运行时被传递。
- en: Example 20-7. Catching and counting signals
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 20-7. 捕获和计数信号
- en: '[PRE32]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Changing Signal Dispositions: *sigaction()*'
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变信号处置：*sigaction()*
- en: The *sigaction()* system call is an alternative to *signal()* for setting the
    disposition of a signal. Although *sigaction()* is somewhat more complex to use
    than *signal()*, in return it provides greater flexibility. In particular, *sigaction()*
    allows us to retrieve the disposition of a signal without changing it, and to
    set various attributes controlling precisely what happens when a signal handler
    is invoked. Additionally, as we’ll elaborate in [Implementation and Portability
    of *signal()*](ch22.html#implementation_and_portability_of_signal "Implementation
    and Portability of signal()"), *sigaction()* is more portable than *signal()*
    when establishing a signal handler.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigaction()* 系统调用是设置信号处置的 *signal()* 的替代方案。尽管 *sigaction()* 的使用比 *signal()*
    略复杂，但它提供了更大的灵活性。特别是，*sigaction()* 允许我们在不改变信号处置的情况下检索它，并且可以设置控制信号处理程序调用时具体发生什么的各种属性。此外，正如我们在[信号的实现与可移植性](ch22.html#implementation_and_portability_of_signal)中将详细阐述的那样，*sigaction()*
    在建立信号处理程序时比 *signal()* 更具可移植性。'
- en: '[PRE33]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: The *sig* argument identifies the signal whose disposition we want to retrieve
    or change. This argument can be any signal except `SIGKILL` or `SIGSTOP`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*sig* 参数标识了我们想要检索或更改其处理方式的信号。此参数可以是任何信号，除了 `SIGKILL` 或 `SIGSTOP`。'
- en: 'The *act* argument is a pointer to a structure specifying a new disposition
    for the signal. If we are interested only in finding the existing disposition
    of the signal, then we can specify `NULL` for this argument. The *oldact* argument
    is a pointer to a structure of the same type, and is used to return information
    about the signal’s previous disposition. If we are not interested in this information,
    then we can specify `NULL` for this argument. The structures pointed to by *act*
    and *oldact* are of the following type:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*act* 参数是指向一个结构体的指针，该结构体指定了信号的新处理方式。如果我们只关心获取信号的当前处理方式，那么可以为此参数指定 `NULL`。*oldact*
    参数是指向同一类型结构体的指针，用于返回信号先前处理方式的信息。如果我们不关心这些信息，那么可以为此参数指定 `NULL`。*act* 和 *oldact*
    所指向的结构体类型如下：'
- en: '[PRE34]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *sigaction* structure is actually somewhat more complex than shown here.
    We consider further details in Section 21.4.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigaction* 结构体实际上比这里所示的更为复杂。我们将在第 21.4 节中进一步讨论细节。'
- en: The *sa_handler* field corresponds to the *handler* argument given to *signal()*.
    It specifies the address of a signal handler, or one of the constants `SIG_IGN`
    or `SIG_DFL`. The *sa_mask* and *sa_flags* fields, which we discuss in a moment,
    are interpreted only if *sa_handler* is the address of a signal handler—that is,
    a value other than `SIG_IGN` or `SIG_DFL`. The remaining field, *sa_restorer*,
    is not intended for use in applications (and is not specified by SUSv3).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '*sa_handler* 字段对应于传递给 *signal()* 的 *handler* 参数。它指定了信号处理程序的地址，或者是常量 `SIG_IGN`
    或 `SIG_DFL`。*sa_mask* 和 *sa_flags* 字段，稍后我们将讨论，只有在 *sa_handler* 是信号处理程序地址时才会被解释——也就是说，当其值不是
    `SIG_IGN` 或 `SIG_DFL` 时。剩余字段 *sa_restorer* 并不打算在应用程序中使用（并且在 SUSv3 中未指定）。'
- en: Note
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *sa_restorer* field is used internally to ensure that on completion of a
    signal handler, a call is made to the special-purpose *sigreturn()* system call,
    which restores the process’s execution context so that it can continue execution
    at the point where it was interrupted by the signal handler. An example of this
    usage can be found in the *glibc* source file `sysdeps/unix/sysv/linux/i386/sigaction.c`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '*sa_restorer* 字段在内部使用，确保在信号处理程序完成后，调用特殊目的的 *sigreturn()* 系统调用，以恢复进程的执行上下文，使其能够继续执行在被信号处理程序中断的位置。可以在
    *glibc* 源文件 `sysdeps/unix/sysv/linux/i386/sigaction.c` 中找到这种用法的示例。'
- en: The *sa_mask* field defines a set of signals that are to be blocked during invocation
    of the handler defined by *sa_handler*. When the signal handler is invoked, any
    signals in this set that are not currently part of the process signal mask are
    automatically added to the mask before the handler is called. These signals remain
    in the process signal mask until the signal handler returns, at which time they
    are automatically removed. The *sa_mask* field allows us to specify a set of signals
    that aren’t permitted to interrupt execution of this handler. In addition, the
    signal that caused the handler to be invoked is automatically added to the process
    signal mask. This means that a signal handler won’t recursively interrupt itself
    if a second instance of the same signal arrives while the handler is executing.
    Because blocked signals are not queued, if any of these signals are repeatedly
    generated during the execution of the handler, they are (later) delivered only
    once.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '*sa_mask* 字段定义了一组信号，在调用由 *sa_handler* 定义的处理程序时，这些信号会被阻塞。当信号处理程序被调用时，任何当前不在进程信号屏蔽中的信号都会自动添加到该屏蔽中。这些信号会在信号处理程序返回时自动从进程信号屏蔽中移除。*sa_mask*
    字段允许我们指定一组信号，这些信号在执行该处理程序时不允许中断执行。此外，导致调用信号处理程序的信号也会自动添加到进程信号屏蔽中。这意味着，如果在信号处理程序执行期间同一信号的第二次实例到达，信号处理程序不会递归中断自己。由于被阻塞的信号不会被排队，如果在信号处理程序执行期间这些信号反复生成，它们将在稍后（只）被送达一次。'
- en: 'The *sa_flags* field is a bit mask specifying various options controlling how
    the signal is handled. The following bits may be ORed (`|`) together in this field:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*sa_flags* 字段是一个位掩码，用于指定控制信号处理方式的各种选项。以下位可以在此字段中进行按位或 (`|`) 操作：'
- en: '`SA_NOCLDSTOP`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`SA_NOCLDSTOP`'
- en: If *sig* is `SIGCHLD`, don’t generate this signal when a child process is stopped
    or resumed as a consequence of receiving a signal. Refer to [Delivery of `SIGCHLD`
    for Stopped Children](ch26.html#delivery_of_sigchld_for_stopped_children "Delivery
    of SIGCHLD for Stopped Children").
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*sig*是`SIGCHLD`，当子进程因接收到信号而被停止或恢复时，不生成此信号。参见[为停止的子进程投递`SIGCHLD`](ch26.html#delivery_of_sigchld_for_stopped_children
    "为停止的子进程投递SIGCHLD")。
- en: '`SA_NOCLDWAIT`'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`SA_NOCLDWAIT`'
- en: (since Linux 2.6) If *sig* is `SIGCHLD`, don’t transform children into zombies
    when they terminate. For further details, see [Ignoring Dead Child Processes](ch26.html#ignoring_dead_child_processes
    "Ignoring Dead Child Processes").
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: （自Linux 2.6起）如果*sig*是`SIGCHLD`，在子进程终止时，不将其转变为僵尸进程。更多细节，请参见[忽略死掉的子进程](ch26.html#ignoring_dead_child_processes
    "忽略死掉的子进程")。
- en: '`SA_NODEFER`'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`SA_NODEFER`'
- en: When this signal is caught, don’t automatically add it to the process signal
    mask while the handler is executing. The name `SA_NOMASK` is provided as a historical
    synonym for `SA_NODEFER`, but the latter name is preferable because it is standardized
    in SUSv3.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当捕获到此信号时，在处理程序执行时，不要自动将其添加到进程的信号掩码中。`SA_NOMASK`这个名称是`SA_NODEFER`的历史同义词，但后者更为推荐，因为它已在SUSv3中标准化。
- en: '`SA_ONSTACK`'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`SA_ONSTACK`'
- en: Invoke the handler for this signal using an alternate stack installed by *sigaltstack()*.
    Refer to Section 21.3.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*sigaltstack()*安装的备用栈调用此信号的处理程序。参见第21.3节。
- en: '`SA_RESETHAND`'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`SA_RESETHAND`'
- en: When this signal is caught, reset its disposition to the default (i.e., `SIG_DFL`)
    before invoking the handler. (By default, a signal handler remains established
    until it is explicitly disestablished by a further call to *sigaction()*.) The
    name `SA_ONESHOT` is provided as a historical synonym for `SA_RESETHAND`, but
    the latter name is preferable because it is standardized in SUSv3.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当捕获到此信号时，在调用处理程序之前，将其处置方式重置为默认值（即，`SIG_DFL`）。(默认情况下，信号处理程序保持有效，直到通过再次调用*sigaction()*显式取消)。`SA_ONESHOT`这个名称是`SA_RESETHAND`的历史同义词，但后者更为推荐，因为它已在SUSv3中标准化。
- en: '`SA_RESTART`'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`SA_RESTART`'
- en: Automatically restart system calls interrupted by this signal handler. See Section
    21.5.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 自动重启被此信号处理程序中断的系统调用。请参见第21.5节。
- en: '`SA_SIGINFO`'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`SA_SIGINFO`'
- en: Invoke the signal handler with additional arguments providing further information
    about the signal. We describe this flag in Section 21.4.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 使用附加参数调用信号处理程序，提供关于信号的更多信息。我们将在第21.4节中描述此标志。
- en: All of the above options are specified in SUSv3.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 以上所有选项都在SUSv3中进行了规定。
- en: An example of the use of *sigaction()* is shown in [Example 21-1](ch21.html#calling_a_nonreentrant_function_from_bot
    "Example 21-1. Calling a nonreentrant function from both main() and a signal handler").
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*sigaction()*的一个示例见于[示例 21-1](ch21.html#calling_a_nonreentrant_function_from_bot
    "示例 21-1. 从main()和信号处理程序同时调用非重入函数")。
- en: 'Waiting for a Signal: *pause()*'
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待信号：*pause()*
- en: Calling *pause()* suspends execution of the process until the call is interrupted
    by a signal handler (or until an unhandled signal terminates the process).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 调用*pause()*会暂停进程的执行，直到该调用被信号处理程序中断（或者直到未处理的信号终止进程）。
- en: '[PRE35]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always returns -1 with *errno* set to `EINTR`
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 始终返回-1，且将*errno*设置为`EINTR`
- en: When a signal is handled, *pause()* is interrupted and always returns -1 with
    *errno* set to `EINTR`. (We say more about the `EINTR` error in Section 21.5.)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当信号被处理时，*pause()*会被中断，并始终返回-1，且将*errno*设置为`EINTR`。(我们在第21.5节中更详细地讨论了`EINTR`错误。)
- en: An example of the use of *pause()* is provided in [Example 20-2](ch20.html#establishing_the_same_handler_for_two_di
    "Example 20-2. Establishing the same handler for two different signals").
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*pause()*的一个示例见于[示例 20-2](ch20.html#establishing_the_same_handler_for_two_di
    "示例 20-2. 为两个不同信号建立相同的处理程序")。
- en: 'In [Waiting for a Signal Using a Mask: *sigsuspend()*](ch22.html#waiting_for_a_signal_using_a_mask_colon
    "Waiting for a Signal Using a Mask: sigsuspend()"), [Synchronously Waiting for
    a Signal](ch22.html#synchronously_waiting_for_a_signal "Synchronously Waiting
    for a Signal"), and [Fetching Signals via a File Descriptor](ch22.html#fetching_signals_via_a_file_descriptor
    "Fetching Signals via a File Descriptor"), we look at various other ways that
    a program can suspend execution while waiting for a signal.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在[使用掩码等待信号：*sigsuspend()*](ch22.html#waiting_for_a_signal_using_a_mask_colon
    "使用掩码等待信号：sigsuspend()")、[同步等待信号](ch22.html#synchronously_waiting_for_a_signal
    "同步等待信号")和[通过文件描述符获取信号](ch22.html#fetching_signals_via_a_file_descriptor "通过文件描述符获取信号")中，我们探讨了程序在等待信号时暂停执行的其他方式。
- en: Summary
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: A signal is a notification that some kind of event has occurred, and may be
    sent to a process by the kernel, by another process, or by itself. There is a
    range of standard signal types, each of which has a unique number and purpose.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是一种通知，表示某种事件已发生，并且可以由内核、另一个进程或进程本身发送给一个进程。信号有多种标准类型，每种类型都有一个唯一的编号和用途。
- en: Signal delivery is typically asynchronous, meaning that the point at which the
    signal interrupts execution of the process is unpredictable. In some cases (e.g.,
    hardware-generated signals), signals are delivered synchronously, meaning that
    delivery occurs predictably and reproducibly at a certain point in the execution
    of a program.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 信号传递通常是异步的，这意味着信号中断进程执行的时刻是不可预测的。在某些情况下（例如硬件生成的信号），信号是同步传递的，这意味着信号在程序执行的某个特定时刻可预测且可重复地传递。
- en: By default, a signal either is ignored, terminates a process (with or without
    a core dump), stops a running process, or restarts a stopped process. The particular
    default action depends on the signal type. Alternatively, a program can use *signal()*
    or *sigaction()* to explicitly ignore a signal or to establish a programmer-defined
    signal handler function that is invoked when the signal is delivered. For portability
    reasons, establishing a signal handler is best performed using *sigaction()*.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，一个信号要么被忽略，要么终止一个进程（有无核心转储），要么停止一个运行中的进程，或者重新启动一个已停止的进程。特定的默认行为取决于信号类型。或者，程序可以使用*signal()*或*sigaction()*显式忽略一个信号，或者建立一个程序员定义的信号处理函数，该函数在信号到达时被调用。出于可移植性的考虑，最好使用*sigaction()*来建立信号处理程序。
- en: A process (with suitable permissions) can send a signal to another process using
    *kill()*. Sending the null signal (0) is a way of determining if a particular
    process ID is in use.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程（具有适当权限）可以使用*kill()*向另一个进程发送信号。发送空信号（0）是一种确定特定进程 ID 是否正在使用的方法。
- en: Each process has a signal mask, which is the set of signals whose delivery is
    currently blocked. Signals can be added to and removed from the signal mask using
    *sigprocmask()*.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个信号屏蔽字，它是当前被阻塞的信号集合。可以使用*sigprocmask()*向信号屏蔽字中添加或移除信号。
- en: If a signal is received while it is blocked, then it remains pending until it
    is unblocked. Standard signals can’t be queued; that is, a signal can be marked
    as pending (and thus later delivered) only once. A process can use the *sigpending()*
    system call to retrieve a signal set (a data structure used to represent multiple
    different signals) identifying the signals that it has pending.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果信号在被阻塞时接收，它将保持挂起状态，直到解锁。标准信号不能排队；也就是说，信号只能标记为挂起（并因此稍后传递）一次。一个进程可以使用*sigpending()*系统调用检索一个信号集（表示多个不同信号的数据结构），以标识它挂起的信号。
- en: The *sigaction()* system call provides more control and flexibility than *signal()*
    when setting the disposition of a signal. First, we can specify a set of additional
    signals to be blocked when a handler is invoked. In addition, various flags can
    be used to control the actions that occur when a signal handler is invoked. For
    example, there are flags that select the older unreliable signal semantics (not
    blocking the signal causing invocation of a handler, and having the disposition
    of the signal reset to its default before the handler is called).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '*sigaction()*系统调用在设置信号的处理方式时提供比*signal()*更多的控制和灵活性。首先，我们可以指定一组额外的信号，当处理程序被调用时将被阻塞。此外，还可以使用各种标志来控制信号处理程序调用时发生的操作。例如，有些标志可以选择较旧的不可靠信号语义（即不阻塞导致处理程序调用的信号，并且在调用处理程序之前将信号的处理方式重置为默认值）。'
- en: Using *pause()*, a process can suspend execution until a signal arrives.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*pause()*，一个进程可以暂停执行，直到接收到信号。
- en: Further information
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多信息
- en: '[Bovet & Cesati, 2005] and [Maxwell, 1999] provide background on the implementation
    of signals in Linux. [Goodheart & Cox, 1994] details the implementation of signals
    on System V Release 4\. The GNU C library manual (available online at [http://www.gnu.org/](http://www.gnu.org/))
    contains an extensive description of signals.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '[Bovet & Cesati, 2005] 和 [Maxwell, 1999] 提供了 Linux 中信号实现的背景资料。[Goodheart &
    Cox, 1994] 详细介绍了 System V Release 4 上信号的实现。GNU C 库手册（在线提供，网址为 [http://www.gnu.org/](http://www.gnu.org/)）包含了关于信号的广泛描述。'
- en: Exercises
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'As noted in [Changing Signal Dispositions: *signal()*](ch20.html#changing_signal_dispositions_colon_signa
    "Changing Signal Dispositions: signal()"), *sigaction()* is more portable than
    *signal()* for establishing a signal handler. Replace the use of *signal()* by
    *sigaction()* in the program in [Example 20-7](ch20.html#catching_and_counting_signals
    "Example 20-7. Catching and counting signals") (`sig_receiver.c`).'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如在[更改信号处理：*signal()*](ch20.html#changing_signal_dispositions_colon_signa "更改信号处理：signal()")中所述，*sigaction()*在设置信号处理程序时比*signal()*更具可移植性。在[示例20-7](ch20.html#catching_and_counting_signals
    "示例20-7. 捕获并计数信号")(`sig_receiver.c`)的程序中，将*signal()*替换为*sigaction()*。
- en: Write a program that shows that when the disposition of a pending signal is
    changed to be `SIG_IGN`, the program never sees (catches) the signal.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，演示当待处理信号的处理方式被更改为`SIG_IGN`时，程序永远不会看到（捕获）该信号。
- en: Write programs that verify the effect of the `SA_RESETHAND` and `SA_NODEFER`
    flags when establishing a signal handler with *sigaction()*.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写程序，验证在使用*sigaction()*设置信号处理程序时，`SA_RESETHAND`和`SA_NODEFER`标志的作用。
- en: Implement the *siginterrupt()* function described in [Interruption and Restarting
    of System Calls](ch21.html#interruption_and_restarting_of_system_ca "Interruption
    and Restarting of System Calls") using *sigaction()*.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*sigaction()*实现[系统调用的中断与重启](ch21.html#interruption_and_restarting_of_system_ca
    "系统调用的中断与重启")中描述的*siginterrupt()*函数。
