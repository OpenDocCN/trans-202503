- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 18 IMMUTABILITY AND FUNCTIONAL DATA STRUCTURES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18 不变性与函数式数据结构
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'We’ve now considered several abstract data types (ADTs), data structures, and
    algorithms. Let’s finish the book by considering an aspect that’s not only relevant
    to functional programming but also to the everyday usage of libraries such as
    Redux for React web page developers. How do we work with data structures and not
    make changes to them, but instead produce new ones, in a true functional style?
    To do this, we’ll need to consider a new concept: *persistent* (or *functional*)
    *data structures* that we can update without needing to clone everything for high
    performance and that also allow us to view the “history” of previous states and
    roll back changes if needed.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经考虑了几个抽象数据类型（ADT）、数据结构和算法。让我们通过考虑一个不仅与函数式编程相关，而且与像 Redux 这样的库在 React 页面开发者中的日常使用相关的方面来结束这本书。我们如何处理数据结构，而不是对它们进行更改，而是以真正的函数式风格生成新的数据结构？为了做到这一点，我们需要考虑一个新概念：*持久性*（或*函数式*）*数据结构*，通过这种方式，我们可以在不需要克隆所有内容以获得高性能的情况下更新它们，并且它们还允许我们查看以前状态的“历史”，如果需要的话，还能回滚更改。
- en: '### Functional Data Structures'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### 函数式数据结构'
- en: 'Let’s start with a couple of definitions. *Persistent data structures* have
    the interesting property that you can update them while keeping previous versions
    intact, without changes. This property automatically implies that these structures
    are ideal for purely functional programming languages, which do not allow for
    side effects, as mentioned in [Chapter 2](chapter2.xhtml). It means they are also
    *functional data structures*: if you don’t modify a data structure but produce
    a new one instead, you’ll have both the previous and the new versions available.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从几个定义开始。*持久性数据结构*有一个有趣的属性，你可以在保持先前版本不变的情况下更新它们。这一属性自动意味着这些结构非常适合纯函数式编程语言，这些语言不允许副作用，正如在[第
    2 章](chapter2.xhtml)中提到的。它意味着它们也是*函数式数据结构*：如果你不修改数据结构，而是生成一个新的数据结构，那么你将同时拥有旧版本和新版本。
- en: Let’s analyze several data structures, most of which we already covered in the
    book, to see whether we can make them functional.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析几种数据结构，其中大多数我们已经在书中讨论过，看看我们是否可以使它们变得函数式。
- en: Arrays (and Hash Tables)
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组（和哈希表）
- en: We’ll start with bad news first. Arrays are essentially mutable data structures,
    and there’s no simple way to implement a functional equivalent with the same level
    of performance, which is namely *O*(1) for accessing and updating array elements.
    Arrays support destructive updates, and such updates can’t be reversed. Once you
    modify some position in an array, there’s no way to retrieve the previous value.
    Arrays are the opposite of a persistent data structure, in fact.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从坏消息开始。数组本质上是可变的数据结构，并且没有简单的方法可以实现一个具有相同性能水平的函数式等效物，即*O*(1)用于访问和更新数组元素。数组支持破坏性更新，而这种更新是无法撤销的。一旦你修改了数组中的某个位置，就无法找回先前的值。事实上，数组与持久性数据结构是完全相反的。
- en: To get around this limitation, a common technique is to use a balanced binary
    search tree, with indices as keys, but doing so requires *O*(log *n*) time instead.
    Other far more complex techniques have been explored, but the performance is still
    not the same as for straightforward arrays. If you’d like to learn more about
    it, do an online search for Melissa O’Neill and F. Warren Burton’s method (it
    won’t be an easy read).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个限制，一种常见的技术是使用平衡二叉搜索树，以索引作为键，但这样做需要*O*(log *n*)的时间。其他一些更复杂的技术已经被探索过，但其性能仍然与直接使用数组不同。如果你想了解更多内容，可以在线搜索梅丽莎·奥尼尔（Melissa
    O’Neill）和 F. 华伦·伯顿（F. Warren Burton）的方法（这不会是一本容易阅读的书）。
- en: A related conclusion from this result for arrays is that you won’t have a good
    equivalent for hash tables, or their many variants, making them another structure
    that you’ll have to replace with a potentially slower one.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对数组得出的一个相关结论是，你不会有哈希表或其多种变体的良好等效物，这使得它们成为另一个需要用潜在较慢的结构来替换的结构。
- en: This beginning of our study of functional data structures may seem depressing,
    but rest assured that we’ll be able to find equivalences for many of the structures
    previously considered in this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究函数式数据结构的开始可能会让人感到沮丧，但请放心，我们将能够找到许多之前在本书中考虑过的结构的等效物。
- en: Functional Lists
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数式列表
- en: Now consider the simplest structure, linked lists, from [Chapter 10](chapter10.xhtml).
    Some types of lists are quite amenable to the functional style of work. Others
    (like queues) require a “conversion” to make them functional, and some lists have
    no functional equivalent.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑最简单的结构，链表，来自[第10章](chapter10.xhtml)。一些类型的列表非常适合函数式工作风格。其他类型（如队列）需要“转换”才能使其函数化，还有一些列表没有函数式的等效物。
- en: Common Lists
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 普通列表
- en: When we defined lists (see the section “Basic Lists” on page 178), given a position,
    you wanted to be able to either add a new value at that spot or remove whatever
    was there. Consider the first operation. You can achieve that by replicating the
    initial part of the list. [Figure 18-1](chapter18.xhtml#fig18-1) shows a list
    you looked at in [Chapter 10](chapter10.xhtml), and then the same list where you
    add an 80 value at position 3\. (Remember, position 0 is first, as with arrays.)
    The operation involves adding a node and modifying a pointer in an already existing
    node.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义列表时（参见第178页的“基本列表”部分），给定一个位置，你希望能够在该位置添加一个新值或删除已有的值。考虑第一个操作。你可以通过复制列表的初始部分来实现这一点。[图18-1](chapter18.xhtml#fig18-1)展示了你在[第10章](chapter10.xhtml)中查看的一个列表，然后是你在位置3添加80值后的列表。（记住，位置0是第一个位置，就像数组一样。）该操作涉及到添加一个节点并修改已经存在的节点中的指针。
- en: '![](../images/Figure18-1.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-1.jpg)'
- en: 'Figure 18-1: Inserting a node in a list requires that you change an original
    node, namely the one pointing to the new node.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-1：在列表中插入一个节点需要更改原始节点，即指向新节点的那个节点。
- en: With functional structures in mind, [Figure 18-2](chapter18.xhtml#fig18-2) shows
    the way to do it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到函数式结构，[图18-2](chapter18.xhtml#fig18-2)展示了实现方式。
- en: '![](../images/Figure18-2.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-2.jpg)'
- en: 'Figure 18-2: Doing an insertion functionally replicates some nodes but leaves
    the original ones unchanged.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-2：以函数式方式进行插入会复制一些节点，但保持原始节点不变。
- en: In addition to the new node with the 80 value, you have some nodes that duplicate
    values in the previous list, but you keep part of the list unchanged. You didn’t
    have to redo the whole list. New nodes and links have bolder lines, and discarded
    nodes are shown in faded gray.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了具有80值的新节点外，还有一些节点重复了先前列表中的值，但你保持了列表的一部分不变。你不需要重新做整个列表。新节点和链接有较粗的线条，而被丢弃的节点则以淡灰色显示。
- en: 'The code to work in this way uses recursion:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式工作的代码使用递归：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If adding an element at the first position ❶, return a node that has the new
    value and points to the previous list. This also works if the list was originally
    empty. Otherwise, when the list isn’t empty and you want to add the value at a
    position other than zero, create a new node ❷ with the same value at the head
    of the list and a link to the result of adding the new value to the tail of the
    original list.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在第一个位置❶添加元素，返回一个包含新值并指向原始列表的节点。如果列表最初为空，这也适用。否则，当列表不为空且你想在零位置之外的其他位置添加值时，创建一个新节点❷，该节点具有相同的值，位于列表头部，并链接到在原始列表尾部添加新值的结果。
- en: Now, consider removing elements from a list. Going back to the initial list,
    say you want to remove the 60 at position 2\. [Figure 18-3](chapter18.xhtml#fig18-3)
    shows the before and after lists.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑从列表中删除元素。回到最初的列表，假设你想删除位置2的60。 [图18-3](chapter18.xhtml#fig18-3)展示了删除前后的列表。
- en: '![](../images/Figure18-3.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-3.jpg)'
- en: 'Figure 18-3: Removing a node from a list also implies modifying some original
    node.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-3：从列表中删除一个节点也意味着修改某个原始节点。
- en: To work in a functional way, replicate the initial part of the list, as shown
    in [Figure 18-4](chapter18.xhtml#fig18-4).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以函数式方式工作，复制列表的初始部分，如[图18-4](chapter18.xhtml#fig18-4)所示。
- en: '![](../images/Figure18-4.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-4.jpg)'
- en: 'Figure 18-4: The same kind of solution used for insertions helps deal with
    deletions in a functional way.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-4：用于插入的相同解决方案也有助于以函数式的方式处理删除操作。
- en: 'As with list additions, some nodes (in faded gray) are no longer included.
    Part of the list is formed by new nodes (with bold lines), and part of the list
    remains as it was, without re-creating the whole structure. Consider the following
    implementation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表添加一样，一些节点（以淡灰色显示）不再包含在内。列表的一部分由新节点（粗线条）组成，另一部分保持不变，没有重新创建整个结构。考虑以下实现：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using recursion makes the logic clear. If you want to remove an element from
    an empty list ❶, you can’t do anything; return the null list as is. If the list
    isn’t empty and you want to remove its first element ❷, the new list is the one
    that starts with the element just after the first. Finally, if the list is not
    empty and you want to remove some element other than the first one, construct
    a new list ❸ that has the same value as the head of the list and points to the
    result of removing the value from the rest of the list.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归使得逻辑更加清晰。如果你想从空列表中移除一个元素❶，你什么也做不了；直接返回空列表。如果列表不为空，且你想移除第一个元素❷，新列表将是以原来第一个元素后面的元素为开头的列表。最后，如果列表不为空，且你想移除第一个以外的元素，构造一个新列表❸，它的头部元素与原列表的头部相同，并指向从剩余列表中移除该元素后的结果。
- en: As for performance, we again find that all operations are *O*(*n*), although
    the additional creation of nodes probably implies a slower implementation. Also,
    given that we still have plain lists, other methods that we saw earlier (like
    finding the value at a position or calculating the list’s size) work exactly as
    before. In order to implement a functional version of common linked lists, you
    just had to change the two methods that actually modify the list.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 至于性能，我们再次发现所有操作都是*O*(*n*)，尽管创建节点的额外操作可能意味着实现会变慢。此外，由于我们仍然使用的是普通链表，之前看到的其他方法（如查找指定位置的值或计算列表大小）仍然像以前一样有效。为了实现常见链表的函数式版本，你只需更改实际修改列表的两个方法。
- en: Let’s move on to more specialized versions of lists used for other ADTs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论用于其他ADT（抽象数据类型）的更专业版本的列表。
- en: Stacks
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 栈
- en: The first variation of lists that we considered were stacks, which have the
    restriction that all additions (“pushes”) and removals (“pops”) occur at an extremity
    of the list, at its “top.” It will be a nice surprise to realize that our earlier
    implementation already made a functional data structure. Review the diagrams from
    [Chapter 10](chapter10.xhtml). When pushing a value, you had the situation shown
    in [Figure 18-5](chapter18.xhtml#fig18-5).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑的第一个列表变体是栈，它的限制是所有的添加（“推送”）和移除（“弹出”）操作都发生在列表的一端，即它的“顶部”。回顾一下，我们之前的实现已经是一个功能性的数据结构，看到这一点会是一个惊喜。复习一下[第10章](chapter10.xhtml)中的图示。当你推送一个值时，你会遇到[图18-5](chapter18.xhtml#fig18-5)所示的情况。
- en: '![](../images/Figure18-5.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-5.jpg)'
- en: 'Figure 18-5: Stacks already do pushes in functional ways ...'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-5：栈已经以函数式的方式执行推送操作...
- en: The updated stack shares most of the structure; the only difference is the new
    top element. Popping the top value has a similar behavior, as shown in [Figure
    18-6](chapter18.xhtml#fig18-6).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的栈共享大部分结构；唯一的区别是新的顶部元素。弹出顶部值的行为类似，如[图18-6](chapter18.xhtml#fig18-6)所示。
- en: '![](../images/Figure18-6.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-6.jpg)'
- en: 'Figure 18-6: ... and that also goes for pops.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-6：...弹出操作也适用于此。
- en: As with pushing, you updated the stack without modifying any values or pointers
    in it. The original implementation already was fully functional. The performance
    of both operations is still *O*(1), so it can’t be enhanced. However, we won’t
    always be so lucky.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与推送操作一样，你更新了栈而没有修改其中的任何值或指针。原始实现已经完全可以使用。这两个操作的性能仍然是*O*(1)，因此不能进一步增强。然而，我们并不总是如此幸运。
- en: Queues
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 队列
- en: 'Queues pose a challenge. They also restrict operations to the extremities of
    a list: you *enqueued* (entered) values at one extreme (the “back” of the queue)
    and *dequeued* (exited) them from the other extreme (the “front” of the queue).
    You also used a linked list as the basis for the queue, as shown in [Figure 18-7](chapter18.xhtml#fig18-7).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 队列存在挑战。它们也将操作限制在列表的两端：你在一端（队列的“尾部”）*入队*（插入）值，并从另一端（队列的“前端”）*出队*（删除）它们。你还使用了链表作为队列的基础，如[图18-7](chapter18.xhtml#fig18-7)所示。
- en: '![](../images/Figure18-7.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-7.jpg)'
- en: 'Figure 18-7: You can dequeue a node functionally, the same way you pop a stack.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-7：你可以以函数式的方式出队一个节点，就像弹出栈一样。
- en: Dequeueing the front element (22) is exactly the same as popping a value from
    a stack, so that would work. The updated queue would just have its front element
    removed, and its first element now becomes what originally was the second (09).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从队列中移除前端元素（22）与从栈中弹出一个值完全相同，因此这是可行的。更新后的队列将仅移除其前端元素，原本的第二个元素（09）将成为新的第一个元素。
- en: 'However, enqueueing a new value in this example causes a problem. You have
    to modify the node with the 56, and that requires modifying the node with the
    04, and so on, so you end up creating a whole copy of the queue. (This would be
    equivalent to adding a value at the end of a simple list, as described earlier
    in the section “Common Lists” on [page 470](chapter18.xhtml#pg_470).) Can we do
    better? The answer is yes, but we’ll need an ingenious trick: use a pair of stacks
    to represent a queue.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在此示例中，排入新值会导致问题。您必须修改包含56的节点，而这需要修改包含04的节点，以此类推，最终您将不得不创建队列的整个副本。（这等同于在之前“常见列表”一节中描述的[第470页](chapter18.xhtml#pg_470)中，在简单列表的末尾添加一个值。）我们能做得更好吗？答案是肯定的，但我们需要一个巧妙的技巧：使用一对栈来表示队列。
- en: Consider how a queue with five values, A (first) through E (last), might look
    at a certain moment, as shown in [Figure 18-8](chapter18.xhtml#fig18-8). (See
    also question 18.1.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想在某一时刻，包含五个值A（第一个）到E（最后一个）的队列会是什么样子，如[图18-8](chapter18.xhtml#fig18-8)所示。（参见问题18.1。）
- en: '![](../images/Figure18-8.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-8.jpg)'
- en: 'Figure 18-8: You can do functional queues, but you’ll need two stacks for that:
    “back” and “front.”'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-8：您可以做功能性队列，但需要两个栈：“后端”和“前端”。
- en: The queue is split in two stacks. Consider how you could have gotten here. You
    enter the queue by pushing into the “back” of the stack and exit by popping the
    “front” stack. For example, if F were to enter the queue, you’d get the situation
    shown in [Figure 18-9](chapter18.xhtml#fig18-9).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 队列被分成两个栈。考虑一下您是如何到达这一状态的。您通过将元素推入栈的“后端”来进入队列，通过从“前端”栈弹出元素来退出队列。例如，如果F要进入队列，您会得到[图18-9](chapter18.xhtml#fig18-9)中显示的情况。
- en: '![](../images/Figure18-9.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-9.jpg)'
- en: 'Figure 18-9: New nodes are queued by pushing them to the “back” stack.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-9：新节点通过推入“后端”栈来排队。
- en: You can push into a stack functionally, as you saw previously, so everything’s
    fine. If a value were to leave the queue, you’d pop it and get the status shown
    in [Figure 18-10](chapter18.xhtml#fig18-10).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，您可以在栈中按功能方式推入元素，所以一切正常。如果某个值要离开队列，您可以弹出它并查看[图18-10](chapter18.xhtml#fig18-10)中显示的状态。
- en: '![](../images/Figure18-10.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-10.jpg)'
- en: 'Figure 18-10: Dequeueing a node means popping from the “front” stack, so that’s
    also functional.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-10：出队一个节点意味着从“前端”栈弹出，所以这也是按功能方式完成的。
- en: Popping a stack is also done functionally, so everything is still fine. After
    doing another exit, you’d have the situation in [Figure 18-11](chapter18.xhtml#fig18-11),
    and there’s the problem—the front stack is empty.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出栈也是按功能方式完成的，所以一切依然正常。在进行另一次退出后，您会得到[图18-11](chapter18.xhtml#fig18-11)中显示的情况，而问题就出现了——前栈为空。
- en: '![](../images/Figure18-11.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-11.jpg)'
- en: 'Figure 18-11: How do you dequeue a node if the “front” stack is empty?'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-11：如果“前端”栈为空，您如何出队一个节点？
- en: 'How would we handle the next exit, now that the front stack is empty? The key
    to this representation for queues is as follows: if you need to exit the queue
    and the front queue is empty, pop all the values off the back queue and push them
    into the front queue (see [Figure 18-12](chapter18.xhtml#fig18-12)).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 既然前栈为空，我们如何处理下一个退出操作呢？这种队列表示法的关键如下：如果您需要退出队列，而前队列为空，请将所有值从后队列弹出并推入前队列（参见[图18-12](chapter18.xhtml#fig18-12)）。
- en: '![](../images/Figure18-12.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-12.jpg)'
- en: 'Figure 18-12: Pop everything from the “back” stack onto the “front” stack.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-12：将所有元素从“后端”栈弹出到“前端”栈。
- en: After this procedure (which reverses the back stack), you’ll be able to keep
    exiting the queue, and all operations will be done in the correct order. It seems
    like a bit of trickery, but it works, and since all of the involved operations
    are done in a functional way, the result is a functional data structure for representing
    queues.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程之后（反转了后端栈），您将能够继续退出队列，并且所有操作都会按正确的顺序完成。这看起来像是一个小把戏，但它有效，并且由于所有涉及的操作都是按功能方式完成的，最终结果是一个用于表示队列的功能性数据结构。
- en: 'We’re representing queues with two stacks, so the basic methods to build a
    queue and check whether it’s empty are as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用两个栈来表示队列，因此构建队列和检查队列是否为空的基本方法如下：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A new queue ❶ consists of two empty stacks, and testing whether it’s empty ❷
    simply requires verifying whether the two tops of the stack are null.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的队列❶由两个空栈组成，测试队列是否为空❷只需要验证两个栈的顶部是否为null。
- en: 'You can enter a new value at the back end of the queue by pushing into that
    list, which you already know how to do:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将新值推入列表的后端来进入队列，您已经知道如何做到这一点：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You return a new queue, with the new value pushed onto the back end of the stack
    ❶ and an unchanged frontend ❷.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你返回一个新的队列，将新值推入栈的后端❶，前端❷保持不变。
- en: 'Things get a bit more hairy when exiting the queue. As described, if the front
    part isn’t empty, just pop its first element, but if the list is empty, push the
    whole back part, element by element, into the front:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当退出队列时，情况变得有些复杂。如前所述，如果前端不为空，只需弹出第一个元素；但是如果列表为空，就将整个后端逐个元素推入前端：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Start by checking whether the queue is empty ❶, because in that case there’s
    nothing to do; you’ll return the very same unchanged queue. If it’s not empty
    ❷, check whether the front stack is empty. If it is ❸, you need to do a loop ❹,
    popping values from the back stack and pushing them onto the front stack. At the
    end, now knowing that the frontend isn’t empty ❺, you just return a new queue
    with the (possibly emptied) back part and the result of popping the top element
    off the front part.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查队列是否为空❶，因为如果为空，就没有操作需要进行；你会返回相同的未改变的队列。如果不为空❷，检查前端栈是否为空。如果为空❸，你需要执行一个循环❹，从后端栈弹出值并将其推入前端栈。最后，确认前端不为空❺，你只需返回一个新的队列，其中包含（可能已清空的）后端和弹出前端部分顶部元素的结果。
- en: How’s the performance of this stack-based queue? Entering the queue is always
    *O*(1), but exiting the queue may be either *O*(1) or *O*(*n*). However, in amortized
    terms, you can see that each item will be pushed once (at the back), popped once
    (from the back), pushed once again (at the front), and eventually popped once
    again (from the front), which are four constant-time operations. Over the history
    of many operations, the amortized performance is *O*(1), because each value will
    pass through four *O*(1) operations. The *O*(*n*) cost of popping from the back
    and pushing to the front is “diluted” because after once pushing *n* values to
    an empty front, the next *n* exits will be *O*(1). The final average is *O*(1).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于栈的队列性能如何？进入队列始终是*O*(1)，但退出队列可能是*O*(1)或*O*(*n*)。然而，从摊销角度来看，你可以看到每个项目将被推入一次（在后端），弹出一次（从后端），再次推入一次（在前端），并最终再次弹出一次（从前端），这些都是四个常数时间操作。在许多操作的历史中，摊销性能是*O*(1)，因为每个值将通过四个*O*(1)的操作。弹出后端并推入前端的*O*(*n*)成本被“稀释”了，因为在第一次将*n*个值推入空前端后，接下来的*n*次退出将是*O*(1)。最终的平均时间是*O*(1)。
- en: There was an extra operation, front(...), to access the value at the front of
    the queue; see question 18.2.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个额外的操作，front(...)，用于访问队列前端的值；见第18.2题。
- en: Other Lists
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 其他列表
- en: We’ve considered several kinds of lists, but what about the rest? We’ll have
    no functional equivalent for deques (or, more generally, doubly linked lists)
    or circular lists because modifying a single node implies that at least one other
    node must be modified, and that again implies other nodes must change, and so
    on. Trying to update those structures in a functional way ends with creating a
    complete copy, which isn’t very efficient.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经考虑了几种类型的列表，那么其他类型呢？我们无法为双端队列（或更一般的双向链表）或循环列表提供函数式等价物，因为修改一个节点意味着至少另一个节点必须被修改，而这又意味着其他节点必须变化，依此类推。尝试以函数式方式更新这些结构最终会创建一个完整的副本，这样效率不高。
- en: Functional Trees
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数式树
- en: 'In [Chapters 12](chapter12.xhtml) through [16](chapter16.xhtml) we explored
    varieties of trees: binary search trees, general trees, heaps of several styles,
    and so on. Some of these (not all, alas) allow for working in functional ways.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](chapter12.xhtml)到[第16章](chapter16.xhtml)中，我们探索了各种树结构：二叉搜索树、普通树、几种风格的堆等等。其中一些（但并非全部，遗憾的是）允许以函数式方式工作。
- en: Binary Search Trees
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: How can we manage to make binary search trees behave in a functional way? In
    general, we apply the exact same type of solution that we used for lists and create
    some new nodes wherever necessary. Start by considering how to add a new value
    to a tree from [Chapter 12](chapter12.xhtml) (see [Figure 18-13](chapter18.xhtml#fig18-13)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何才能使二叉搜索树以函数式方式运作呢？通常，我们会应用与列表相同的解决方法，在需要的地方创建新的节点。首先考虑如何将新值添加到来自[第12章](chapter12.xhtml)的树中（参见[图18-13](chapter18.xhtml#fig18-13)）。
- en: '![](../images/Figure18-13.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-13.jpg)'
- en: 'Figure 18-13: A binary search tree that you want to maintain in a functional
    way'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-13：一个你希望以函数式方式维护的二叉搜索树
- en: In [Chapter 12](chapter12.xhtml) you added a new 34 value, which became the
    right child of the 24 node. You can do the same here without modifying the existing
    tree. The solution lies in adding a few new nodes, as shown in [Figure 18-14](chapter18.xhtml#fig18-14).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](chapter12.xhtml)中，你添加了一个新的34值，它成为了24节点的右子节点。你可以在这里做同样的操作，而不需要修改现有的树。解决方案在于添加一些新的节点，如[图18-14](chapter18.xhtml#fig18-14)所示。
- en: '![](../images/Figure18-14.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-14.jpg)'
- en: 'Figure 18-14: Adding a new value implies creating a few new nodes.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-14：添加一个新值意味着创建一些新的节点。
- en: There’s a new root, and you also have new nodes all the way to the added node
    itself, but otherwise, the rest of the tree remains the same. There also are some
    nodes (shown in gray) that are no longer part of the tree, as they were duplicated
    by new ones. Accessing the tree through its new root, you find the newly added
    34 value, whereas accessing the tree through its old root results in the very
    same structure as before. You’ve managed to create a new tree, with the additional
    value, but without modifying the original structure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有了新的根节点，并且你也有新的节点，一直到新增的节点本身，但树的其余部分保持不变。还有一些节点（以灰色显示）不再是树的一部分，因为它们被新的节点替代了。通过新根访问树时，你会找到新添加的34值，而通过旧根访问树时，得到的结构与之前完全相同。你成功创建了一个新的树，增加了新的值，但没有修改原有结构。
- en: 'Adding a new value in this functional way requires little code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种功能性方式添加新值所需的代码很少：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want to add a value to an empty tree ❶, you just need a new node with
    the value. (As a reminder, see the following newNode(...) function.) If you want
    to add a key that goes in the left subtree ❷, return a new tree that has the same
    value as the current root, a recursively updated left subtree, and the same right
    subtree as before. If the new value has to go into the right subtree ❸, the result
    is similar: you’ll return a new tree with the same value and the same left subtree
    as the current node and an updated right subtree:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想向一棵空树添加一个值❶，你只需要一个带有该值的新节点。（提醒一下，参见下面的newNode(...)函数。）如果你想添加一个键值到左子树❷，你需要返回一棵新树，它的值与当前根节点相同，左子树是递归更新后的，右子树保持不变。如果新值需要进入右子树❸，结果类似：你会返回一棵新树，值与当前节点相同，左子树与当前节点相同，右子树是更新后的：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, you’ll turn to removing nodes and consider the most complex case: removing
    a node that has two children (you can work out the simpler cases). [Figure 18-15](chapter18.xhtml#fig18-15)
    shows the original tree (the same one used to show adding a node).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将开始考虑删除节点，并讨论最复杂的情况：删除一个有两个子节点的节点（你可以处理更简单的情况）。[图18-15](chapter18.xhtml#fig18-15)展示了原始树（与添加节点时使用的是同一棵树）。
- en: '![](../images/Figure18-15.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-15.jpg)'
- en: 'Figure 18-15: Removing a node is a bit trickier if a node (such as 9) has two
    children.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-15：如果一个节点（如9）有两个子节点，删除它会稍微复杂一些。
- en: To remove node 9, you have to find the next greater key (10, in this case) and
    change its place. It needs to be removed from its current position and take the
    place of the 9\. Working in functional terms, you again create some new nodes,
    as shown in [Figure 18-16](chapter18.xhtml#fig18-16).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除节点9，你必须找到下一个更大的键值（在此案例中是10），并交换它的位置。它需要从当前位置删除，并取代9的位置。以功能化的方式工作时，你再次创建一些新的节点，如[图18-16](chapter18.xhtml#fig18-16)所示。
- en: '![](../images/Figure18-16.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-16.jpg)'
- en: 'Figure 18-16: Removing a node with two children requires re-creating nodes
    from the root.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-16：删除一个有两个子节点的节点需要从根节点重新创建节点。
- en: 'You have a new root, and you also re-created nodes in the path to the node
    that you eliminate. To remove the 10 from its tree, you also applied a functional
    method, so in that subtree (the one with root 11), you had to create some new
    nodes too. The code for removing nodes has several cases:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个新的根节点，并且你也重新创建了到达你要删除的节点路径上的节点。为了从树中删除10，你也应用了功能化方法，因此在该子树（根节点是11的子树）中，你也需要创建一些新的节点。删除节点的代码有几种情况：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code tightly parallels what you saw in [Chapter 12](chapter12.xhtml), but
    you always return new trees instead of modifying nodes. If the tree is empty ❶,
    return it as is. If the value to remove is less than the current node’s value
    ❷, return a new tree with the node’s value and right child, but with its left
    child pointing at a new tree, which is the result of deleting the value in the
    left subtree. Similarly, if the value to remove is greater than the current node’s
    value ❸, proceed symmetrically: return a new tree with the node’s value and left
    child, but with a right child pointing at the result of deleting the value in
    the right subtree. When you’ve found the node to delete and it’s a leaf ❹, just
    return an empty tree. If it isn’t a leaf but it has only one child (if a right
    child ❺, and if a left one ❻), return a tree that consists of only the nonempty
    child, omitting the removed node. Finally, in the most difficult case, if you
    have to remove a node with two non-null subtrees ❼, find the minimum value in
    its right subtree ❽ and return a tree built with that value at the root, the original
    node’s left subtree on the left, and the result of removing the minimum value
    from the original node’s right subtree on the right ❾.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与你在[第12章](chapter12.xhtml)看到的非常相似，但每次你都会返回新的树，而不是修改节点。如果树为空 ❶，直接返回原树。如果要删除的值小于当前节点的值
    ❷，返回一个新树，包含当前节点的值和右子节点，但其左子节点指向一个新树，这个新树是删除左子树中的值后的结果。类似地，如果要删除的值大于当前节点的值 ❸，按对称方式进行：返回一个新树，包含当前节点的值和左子节点，但其右子节点指向删除右子树中值后的结果。当你找到要删除的节点并且它是叶节点
    ❹时，直接返回一个空树。如果它不是叶节点但只有一个子节点（如果是右子节点 ❺，左子节点 ❻），返回一个只有非空子节点的树，去掉被删除的节点。最后，在最复杂的情况下，如果你需要删除一个有两个非空子树的节点
    ❼，找到其右子树中的最小值 ❽，并返回一个以该值为根的新树，原节点的左子树在左侧，删除右子树中最小值后的结果在右侧 ❾。
- en: 'You have already seen an implementation of minKey(...), the function that finds
    the minimum value in a binary search tree, but consider a new version, just for
    the sake of variety (plus a one-liner is hard to resist):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到过minKey(...)函数的实现，它可以找到二叉搜索树中的最小值，但考虑一种新版本的实现，仅为增加一些变化（再加上简短的一行代码实在让人无法抗拒）：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For all the varieties of trees that we’ve seen (AVL trees, red-black trees,
    splay trees, and so on), you can apply some variant of the methods shown in the
    previous removal code. After adding or removing a key, the new tree will end with
    a new root and several new nodes, but many parts of it remain the same, with no
    changes. The order of the performance of the processes will also be the same as
    before, so at the cost of some added complexity, we can have functional versions
    of all those trees.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们看到的所有树的变种（如AVL树、红黑树、伸展树等），你可以应用一些变体的方法，类似于前面删除代码中展示的方法。在添加或删除一个键后，新的树将以新的根节点和几个新节点结束，但其中许多部分保持不变，没有变化。处理过程的执行顺序也将与之前相同，因此，虽然增加了一些复杂性，但我们可以得到所有这些树的功能版本。
- en: Other Trees
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 其他树
- en: We also considered other kinds of trees; in particular, [Chapters 14](chapter14.xhtml)
    and [15](chapter15.xhtml) were devoted to heaps, which are basically binary trees
    or variations thereof. A simple version was built upon arrays, so we’re stuck
    there with no easy solution. For other heaps (treaps, skew heaps, Fibonacci heaps,
    and so on) that are based on dynamic memory using pointers, we can apply the same
    kind of solution as for objects and binary trees.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还考虑了其他种类的树；特别地，[第14章](chapter14.xhtml)和[第15章](chapter15.xhtml)专门讲解了堆，它们基本上是二叉树或其变种。一个简单的版本是基于数组构建的，因此我们在这里陷入了困境，没有简单的解决方案。对于其他基于动态内存和指针的堆（如treap、skew
    heap、Fibonacci heap等），我们可以像处理对象和二叉树一样，应用相同类型的解决方案。
- en: What about digital trees, including tries, object-based tries, radix trees,
    and ternary trees? Tries had arrays in each node, with pointers to all the children
    of the node, but in essence, it’s the same as binary trees having two pointers.
    The same kind of solution we saw for binary trees will work, and when updating
    a trie, you’ll end with a new structure that has some new nodes but shares most
    of the previous ones. [Figure 18-17](chapter18.xhtml#fig18-17) shows this solution
    with a trie that you saw in [Chapter 17](chapter17.xhtml).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，数字树（包括trie树、基于对象的trie树、基数树和三叉树）怎么办呢？Trie树在每个节点中都有一个数组，指向该节点的所有子节点，但本质上，它与二叉树具有两个指针是一样的。我们为二叉树看到的相同类型的解决方案同样适用，更新trie树时，你将得到一个新的结构，包含一些新节点，但大多数节点是共享的。[图18-17](chapter18.xhtml#fig18-17)展示了这个解决方案，其中的trie树是你在[第17章](chapter17.xhtml)看到的。
- en: '![](../images/Figure18-17.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-17.jpg)'
- en: 'Figure 18-17: You can also maintain a trie in a functional way.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18-17：你也可以以函数式方式维护字典树。
- en: In [Chapter 17](chapter17.xhtml), we showed how the trie would be modified if
    we added an ABE word. Working functionally, you’d have a new root and some new
    nodes elsewhere. [Figure 18-18](chapter18.xhtml#fig18-18) shows the result.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第17章](chapter17.xhtml)，我们展示了如果添加单词 ABE，字典树会如何被修改。以函数式方式操作时，你会有一个新的根节点，并且其他地方也有一些新的节点。[图
    18-18](chapter18.xhtml#fig18-18)展示了结果。
- en: You have a new root, a couple of new nodes (with a darker border), and some
    new links, but most of the structure is still as before. Two old nodes (in gray)
    are no longer part of it, in the same way as with binary trees, but that’s it.
    The basic procedure is the same, and it also works for radix trees and ternary
    trees, but you won’t see it here. It’s always the same kind of solution.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个新的根节点，一些新的节点（带有较深的边框）以及一些新的链接，但大部分结构仍然和之前一样。两个旧的节点（灰色的）不再是字典树的一部分，就像二叉树一样，但仅此而已。基本过程是相同的，它同样适用于基数树和三叉树，但在这里不会显示。它始终是相同类型的解决方案。
- en: '![](../images/Figure18-18.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-18.jpg)'
- en: 'Figure 18-18: Adding a new word requires creating some new nodes, but it keeps
    most of the trie unchanged.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18-18：添加一个新词需要创建一些新的节点，但大部分字典树结构保持不变。
- en: Finally, for object-based tries that were based on JavaScript objects, you can
    simply apply the same ideas that were described for lists and trees earlier in
    this chapter. In [Chapter 16](chapter16.xhtml) you considered an example of an
    object-based trie; [Figure 18-19](chapter18.xhtml#fig18-19) revisits it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于基于 JavaScript 对象的字典树，你可以简单地应用本章前面描述的关于列表和树的相同思路。在[第16章](chapter16.xhtml)中，你考虑了一个基于对象的字典树示例；[图
    18-19](chapter18.xhtml#fig18-19)再次展示了它。
- en: '![](../images/Figure18-19.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-19.jpg)'
- en: 'Figure 18-19: You can also update an object-based trie in a functional way.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18-19：你也可以以函数式方式更新基于对象的字典树。
- en: In [Chapter 16](chapter16.xhtml) we saw, among other examples, how to add the
    word ABE to the trie. You did this by modifying several objects; now you’ll do
    it functionally by adding a few new ones and keeping most of the old structure
    unchanged, as shown in [Figure 18-20](chapter18.xhtml#fig18-20).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第16章](chapter16.xhtml)中，我们看到了如何将单词 ABE 添加到字典树中。你是通过修改多个对象来实现的；现在你将通过添加一些新对象，并保持大部分旧结构不变的方式，以函数式方法完成此操作，正如[图
    18-20](chapter18.xhtml#fig18-20)所示。
- en: '![](../images/Figure18-20.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure18-20.jpg)'
- en: 'Figure 18-20: Adding a new word and re-creating some objects'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18-20：添加一个新词并重新创建一些对象
- en: 'As with the previous trie example, new nodes have darker borders, and borders
    of the dropped nodes are a lighter gray. Most of the trie didn’t need to change
    at all. Thus, you’re able to implement several varieties (although not all) of
    heaps and all sorts of digital trees by varying the update algorithms a bit, but
    always along the same lines that we already applied.  ### Summary'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '和之前的字典树示例一样，新的节点有较深的边框，而被删除的节点的边框则是较浅的灰色。大部分的字典树结构并不需要改变。因此，你可以通过稍微调整更新算法来实现各种类型（虽然不是所有）的堆和各种数字树，但始终沿用我们已经应用过的相同思路。  ###
    总结'
- en: In this chapter, we’ve finished our overview of data structures and algorithms
    by considering functional data structures, which may be updated without side effects
    and produce new versions in an efficient way.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经通过考虑函数式数据结构来完成了数据结构和算法的概述，这些结构可以在没有副作用的情况下进行更新，并以高效的方式生成新版本。
- en: Working with functional data structures represents a possibly difficult balance.
    On one hand, there are advantages in terms of clarity and maintainability, because
    it’s clear when and where data structures are changed. On the other hand, however,
    we may find some operations that originally had great performance are now replaced
    by slower ones.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数式数据结构可能需要保持一定的平衡。一方面，在清晰度和可维护性上具有优势，因为数据结构何时何地被修改是明确的。然而，另一方面，我们可能会发现一些原本具有良好性能的操作被较慢的操作所替代。
- en: Is there a way to avoid those problems? Unfortunately, not easily. As mentioned
    previously, the aim is to apply functional programming in a pragmatic way, so
    we’ll use functional data structures when possible but accept “common” modifiable
    structures when needed. For instance, working with arrays is quite often necessary,
    and a lower-performing solution could have a great impact on performance. You
    must be flexible and know when and what to choose.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有办法避免这些问题？不幸的是，这并不容易。如前所述，目标是以务实的方式应用函数式编程，因此我们将在可能的情况下使用函数式数据结构，但在需要时接受“常见的”可修改结构。例如，处理数组通常是必需的，性能较低的解决方案可能会对性能产生很大影响。你必须灵活应对，知道何时选择什么。
- en: Questions
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: '**18.1  Getting Here**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**18.1  到达这里**'
- en: What’s the minimum sequence of operations entering and exiting the queue that
    would produce the diagram shown in [Figure 18-7](chapter18.xhtml#fig18-7)?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 进入和退出队列的最小操作序列是什么，这个序列能生成[图18-7](chapter18.xhtml#fig18-7)中所示的图形？
- en: '**18.2  With Apologies to Abbott and Costello, Who’s on Front?**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**18.2  向阿博特和科斯特罗道歉，谁在前面？**'
- en: Can you implement the front(q) method that will produce the front value of a
    functional-style q queue?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你能实现一个`front(q)`方法，用于返回函数式风格队列q的前端值吗？
- en: '**18.3  No Change Needed**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**18.3  无需更改**'
- en: When removing a key from a binary search tree, the algorithm will produce a
    new tree even if the required key didn’t exist. Can you modify it so that it returns
    the original unchanged tree in that case?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在从二叉搜索树中移除一个键时，即使该键不存在，算法也会生成一个新的树。你能修改它，使得在这种情况下返回原始未改变的树吗？
- en: '**18.4  A New Minimum**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**18.4  新的最小值**'
- en: Can you explain how the new version of minKey(...) in the section “Binary Search
    Trees” on page 478 works?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你能解释一下第478页“二叉搜索树”章节中minKey(...)新版本是如何工作的？
