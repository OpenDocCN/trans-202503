- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: CRYPTOGRAPHY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: '*Cryptography*, the science of protecting the confidentiality and integrity
    of data, is a key part of the vast set of transactions that take place over your
    devices daily. You use cryptography when you have conversations on your cell phones,
    check your email, buy things from online retailers, and file your taxes, among
    other activities. Without the ability to protect the information you send over
    such channels, your Internet-based activities would be much riskier.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*密码学*是保护数据的机密性和完整性的科学，它是你日常通过设备进行大量交易的关键部分。你在用手机通话、查看电子邮件、在线购买商品以及报税等活动中都会用到密码学。如果没有保护你通过这些渠道发送信息的能力，你的互联网活动将变得更加危险。'
- en: In cryptography, *encryption* is the process of transforming readable data,
    called *plaintext* or *cleartext*, into an unreadable form, called *ciphertext.
    Decryption* is the process of recovering the plaintext message from the ciphertext.
    You encrypt the plaintext or decrypt the ciphertext using a specific computational
    procedure called a *cryptographic algorithm*. You’ll explore several examples
    of these in this chapter. Cryptographic algorithms generally use a *key*, or multiple
    keys, to encrypt or decrypt the message. You can think of a key as a password
    that you can apply to the algorithm to retrieve the message.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学中，*加密*是将可读数据（即*明文*或*清文*）转换为不可读的形式（即*密文*）的过程。*解密*是从密文中恢复明文的过程。你通过使用一种特定的计算程序，称为*密码算法*，来加密明文或解密密文。在本章中，你将探索几种此类算法的例子。密码算法通常使用*密钥*，或多个密钥来加密或解密消息。你可以把密钥看作是一个密码，通过它可以在算法中检索出消息。
- en: In this chapter, you’ll look at some of the earliest examples of cryptography
    and then dive into modern cryptographic practices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将首先了解一些早期的密码学实例，然后深入探讨现代密码学实践。
- en: The History of Cryptography
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码学的历史
- en: Some of the oldest examples of cryptography date back to ancient Greece and
    Rome. To hide information, Greeks and Romans used codes, as well as unorthodox
    methods such as tattooing information on the shaved heads of messengers and allowing
    hair to grow over it. Enough historical information about cryptography exists
    to fill an entire volume, and indeed many books have been written on the subject,
    so I’ll go over just a few highlights.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最古老的密码学实例可以追溯到古希腊和古罗马。为了隐藏信息，希腊人和罗马人使用了密码，还采用了非常规的方法，比如在信使的剃光头上刺入信息，然后让头发长出来。关于密码学的历史资料多得足以写成一本书，实际上已经有许多书籍涉及这一主题，因此我将仅介绍其中的几个亮点。
- en: '*The Caesar Cipher*'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*凯撒密码*'
- en: The Caesar cipher, a classic example of ancient cryptography, is said to have
    been used by Julius Caesar. The Caesar cipher involves shifting each letter of
    the plaintext message by a certain number of spaces in the alphabet, historically
    three, as shown in [Figure 5-1](#ch5fig1). After the shift, you would write the
    letter *A* as *D*, the letter *B* as *E*, and so on. To decrypt the ciphertext,
    you would apply the same number of shifts in the opposite direction.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码，作为古代密码学的经典例子，据说曾被尤利乌斯·凯撒使用。凯撒密码的原理是将明文中的每个字母按照字母表中的位置向右移动一定的位数，历史上通常是三位，如[图
    5-1](#ch5fig1)所示。经过移动后，字母*A*变为*D*，字母*B*变为*E*，依此类推。为了破解密文，你需要将字母向相反方向移动相同的位数。
- en: '![Image](../images/05fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig01.jpg)'
- en: '*Figure 5-1: Encrypting the phrase “secret message” with the Caesar cipher*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：使用凯撒密码加密短语“秘密消息”*'
- en: We call this type of encryption a *substitution cipher*, because it substitutes
    each letter in the alphabet with a different one. A more recent variation of the
    Caesar cipher is the ROT13 cipher, which uses the same mechanism as the Caesar
    cipher but moves each letter 13 places forward in the alphabet. Moving each letter
    by 13 places makes the message convenient to decrypt, because all you have to
    do to retrieve the original is apply another round of encryption with ROT13; two
    rotations will return each letter to its original starting place in the alphabet.
    Utilities for performing ROT13 are part of the basic set of tools that ship with
    many Linux and UNIX operating systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这种类型的加密为*替代密码*，因为它将字母表中的每个字母替换为另一个字母。凯撒密码的一个更新变种是ROT13密码，它与凯撒密码使用相同的机制，但每个字母在字母表中向前移动13个位置。将每个字母移动13个位置使得消息便于解密，因为你只需要再应用一轮ROT13加密就能恢复原文；两轮加密后，每个字母将回到其字母表中的原始位置。执行ROT13的工具是许多Linux和UNIX操作系统中自带的基本工具之一。
- en: '*Cryptographic Machines*'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*加密机器*'
- en: Before the advent of the modern computer, people used machines to simplify encryption
    and make more complex encryption schemes feasible. Initially, such devices were
    basic mechanical machines, but as technology progressed, they began to include
    electronics and considerably more complex systems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代计算机问世之前，人们使用机器来简化加密并使更复杂的加密方案成为可能。最初，这些设备是基本的机械机器，但随着技术的发展，它们开始加入电子元件，并且系统变得更加复杂。
- en: The Jefferson Disk, invented by Thomas Jefferson in 1795, is a purely mechanical
    cryptographic machine. It is composed of 36 disks, each marked with the letters
    *A* through *Z* in a circle around its rim, as shown in [Figure 5-2](#ch5fig2).[¹](notes.xhtml#ch05fn1)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 杰斐逊圆盘是托马斯·杰斐逊在1795年发明的纯机械加密机器。它由36个圆盘组成，每个圆盘的边缘上标有从*A*到*Z*的字母，如[图 5-2](#ch5fig2)所示。[¹](notes.xhtml#ch05fn1)
- en: Each disk represents one character in a message. The letters on each disk are
    arranged in a different order, and each disk is marked with a unique identifier
    so you can tell them apart.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个圆盘代表消息中的一个字符。每个圆盘上的字母排列顺序不同，每个圆盘都标有独特的标识符，便于区分它们。
- en: To encrypt a message, you line up the characters in a row across the set of
    disks so they spell out the message in plaintext, like in row A of [Figure 5-3](#ch5fig3).
    Then you choose a different row of characters to use as the ciphertext, as shown
    in row B.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要加密消息，你需要将字符排列在一排，使其拼写出明文消息，就像在[图 5-3](#ch5fig3)的A行那样。然后，你选择不同的一行字符作为密文，就像在B行所示。
- en: '![Image](../images/05fig02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig02.jpg)'
- en: '*Figure 5-2: The Jefferson Disk, one of the earliest crypto-graphic machines*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：杰斐逊圆盘，最早的加密机器之一*'
- en: '![Image](../images/05fig03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig03.jpg)'
- en: '*Figure 5-3: Encrypting the message “Meeting is a go” using the Jefferson Disk*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：使用杰斐逊圆盘加密“会议开始”消息*'
- en: The key to this cipher is in the order of the disks. If the encrypting and decrypting
    devices arrange their disks in the same order, all you need to do to decrypt the
    message is rewrite the ciphertext using the disks and then look at all the rows
    until you find the plaintext message. This is, of course, merely a more complex
    version of a substitution cipher, made possible using a mechanical aid, in which
    the substitution changes with each letter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该密码的关键在于圆盘的顺序。如果加密和解密设备以相同的顺序排列它们的圆盘，那么你所需要做的就是使用圆盘重新写出密文，然后查看所有行直到找到明文消息。当然，这只不过是替代密码的一个更复杂版本，通过机械辅助使得每个字母的替代方式都不同。
- en: A more intricate example of a cryptographic machine is the German-made Enigma
    machine ([Figure 5-4](#ch5fig4)).[²](notes.xhtml#ch05fn2) Created by Arthur Scherbius
    in 1923, the Enigma secured German communications during World War II.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的加密机器实例是德国制造的恩尼格玛机（[图 5-4](#ch5fig4)）。[²](notes.xhtml#ch05fn2) 恩尼格玛机由阿图尔·谢比乌斯于1923年设计，在第二次世界大战期间保护了德国的通讯。
- en: '![Image](../images/05fig04.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig04.jpg)'
- en: '*Figure 5-4: An Enigma machine*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：恩尼格玛机*'
- en: Conceptually, the Enigma resembles the Jefferson Disk. It’s based on a series
    of wheels, or rotors, each with 26 letters and 26 electrical contacts. It also
    has a keyboard for entering the plaintext message and a set of 26 characters above
    the keyboard, which light up to indicate the encrypted equivalent. When you press
    a key on the Enigma keyboard, one or more of the rotors physically rotates, changing
    the orientation of the electrical contacts between them. Current flows through
    the entire series of disks and then back through them again to the original disk,
    lighting up the scrambled version of each letter on the series of characters above
    the keyboard.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，恩尼格玛（Enigma）类似于杰斐逊圆盘（Jefferson Disk）。它基于一系列轮子或转子，每个转子上有26个字母和26个电气接触点。它还配有一个键盘，用于输入明文信息，以及一个位于键盘上方的26个字符的显示区，这些字符会亮起，以指示加密后的等效字符。当你在恩尼格玛的键盘上按下一个键时，一个或多个转子会物理旋转，改变它们之间电气接触点的方向。电流会通过整套圆盘，然后再次通过它们返回到原始圆盘，在键盘上方的字符显示区显示出每个字母的加密版本。
- en: For two Enigma machines to communicate during the war, they needed to have the
    same configuration. This took a lot of work since both the rotors and the rings
    marked with the alphabet on each rotor needed to be identical and in the same
    position, and any cables plugged in needed to be set up in the same fashion. Once
    the message was encrypted, it would be sent via Morse code to the receiving end.
    When the receiver got the encrypted Morse code message, they would enter the equivalent
    characters on the keyboard, and presuming everything was set up properly, the
    decrypted character would light up.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让两台恩尼格玛机器在战争期间进行通信，它们必须拥有相同的配置。这需要大量的工作，因为转子和每个转子上标有字母的环必须完全相同并处于相同的位置，任何插入的电缆也需要以相同的方式设置。一旦消息被加密，它将通过莫尔斯电码发送到接收端。当接收者收到加密的莫尔斯电码消息时，他们会在键盘上输入相应的字符，如果一切设置正确，解密后的字符就会亮起。
- en: There were several models of Enigma machine and a variety of accessories and
    add-ons you could attach to them. To add further possible variations, some models
    had a patch panel, allowing you to swap some or all the letters by plugging cables
    into different positions. On each rotor, the ring containing the letters of the
    alphabet could also be rotated independently of the electrical contacts to change
    the relationship between the character selected and the character output.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 恩尼格玛机器有多个型号，并且可以附加各种配件和附加组件。一些型号还配有补丁面板，允许通过将电缆插入不同的位置来交换一些或所有字母。每个转子上的字母环也可以独立于电气接触点旋转，以改变选定字符与输出字符之间的关系。
- en: Between the inherent strengths of the device and the knowledge of the required
    configuration needed for decryption, the Enigma posed quite a difficult task for
    those attempting to break the messages generated by it. But a large portion of
    the device’s strength was in the secrecy surrounding the equipment and the configurations
    used for specific messages; this is a strategy we call *security through obscurity*
    in the security field. Once these secrets became exposed, the encrypted messages
    were no longer as secure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设备本身的固有优势和解密所需配置的知识，恩尼格玛对于试图破解其生成消息的人来说是一项相当艰巨的任务。但是，设备的强大之处在于它的机密性以及用于特定消息的配置；这在安全领域被称为*通过模糊性确保安全*。一旦这些机密被暴露，加密的消息就不再那么安全了。
- en: In 1939, when cryptographers at Bletchley Park, a British code-breaking base
    during World War II, were given an Enigma to study, they were able to construct
    a computer called the Bombe that decoded a large portion of the Germans’ messages,
    even though they didn’t have access to the Enigma settings rotated on a daily
    basis.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 1939年，当二战期间英国的破译基地——布莱切利公园的密码学家们获得一台恩尼格玛进行研究时，他们能够构建一个名为“博贝”（Bombe）的计算机，解码了大量德国的消息，尽管他们没有访问每日更新的恩尼格玛设置。
- en: '**MORE ON THE ENIGMA MACHINE**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于恩尼格玛机器的更多信息**'
- en: 'Anyone interested in getting hands-on experience with a classic item of cryptographic
    history can interact with the Enigma in several ways. The DIY inclined can purchase
    a kit that re-creates the functionality of the Enigma using modern electronics
    components.[³](notes.xhtml#ch05fn3) Additionally, a variety of software-based
    Enigma simulators exist.[⁴](notes.xhtml#ch05fn4) These are particularly useful
    for representing the relationship between the rotors and the paths running through
    them, which change with each character entered. A great many books have also been
    written on this topic, but a particularly good one is *The German Enigma Cipher
    Machine: Beginnings, Success, and Ultimate Failure* by Brian J. Winkel, Cipher
    Deavours, David Kahn, and Louis Kruh. *Seizing the Enigma: The Race to Break the
    German U-Boat Codes, 1933–1945* by David Kahn is another excellent source for
    further detail on some of this work.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些有兴趣亲身体验经典密码学历史的人来说，可以通过多种方式与恩尼格玛（Enigma）进行互动。喜欢DIY的人可以购买一个套件，利用现代电子组件重现恩尼格玛的功能。[³](notes.xhtml#ch05fn3)
    此外，还有各种基于软件的恩尼格玛模拟器。[⁴](notes.xhtml#ch05fn4) 这些模拟器特别有用，可以展示转子与通过它们的路径之间的关系，这些关系会随着每个字符的输入而变化。关于这个主题，已经写了很多书籍，其中一本特别优秀的是布赖恩·J·温克尔（Brian
    J. Winkel）、赛弗·德沃尔（Cipher Deavours）、大卫·坎（David Kahn）和路易斯·克鲁赫（Louis Kruh）合著的《德国恩尼格玛密码机：起源、成功与最终失败》。大卫·坎的《夺取恩尼格玛：破解德国U型潜艇密码的竞赛，1933-1945》是另一部详细介绍这一工作的优秀来源。
- en: '*Kerckhoffs’s Principles*'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*凯尔科夫原则*'
- en: In 1883, the *Journal des Sciences Militaires* published an article by Auguste
    Kerckhoffs, a Dutch linguist and cryptographer, titled “La cryptographie militaire.”
    In the article, Kerckhoffs outlined six principles he thought should serve as
    a basis for all cryptographic systems.[⁵](notes.xhtml#ch05fn5)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 1883年，《军事科学杂志》刊登了荷兰语言学家和密码学家奥古斯特·凯尔科夫（Auguste Kerckhoffs）的一篇文章，题为《军事密码学》。在这篇文章中，凯尔科夫概述了他认为应作为所有加密系统基础的六项原则。[⁵](notes.xhtml#ch05fn5)
- en: The system must be substantially, if not mathematically, undecipherable.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统必须在实质上（即使不是数学上）是无法破译的。
- en: The system must not require secrecy; even if stolen by the enemy, the system
    should remain secure.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统不应依赖于保密性；即使被敌人窃取，系统仍应保持安全。
- en: The keys must be easy to communicate and remember without written notes, and
    they must be easy to change or modify to use with different participants.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密钥必须易于传递和记忆，无需书面记录，而且必须易于更改或修改，以便与不同的参与者一起使用。
- en: The system ought to be compatible with communication via telegraph.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统应当与电报通信兼容。
- en: The system must be portable, and its use must not require more than one person.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统必须是便于携带的，且使用不应要求超过一个人。
- en: Finally, the system must be easy to use, requiring neither complex thinking
    nor the knowledge of a long series of rules.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，系统必须易于使用，不需要复杂的思维或掌握一长串规则。
- en: Although several of these principles, such as requiring the system to support
    telegraph use or be physically portable, became outmoded once people started using
    computers for cryptography, the second principle remains a key tenet of modern
    cryptographic algorithms. Claude Shannon, an American mathematician and cryptographer,
    later restated the idea as “the enemy knows the system”;[⁶](notes.xhtml#ch05fn6)
    in other words, cryptographic algorithms should be robust enough that even if
    people know every bit of the encryption process except for the key itself, they
    should still not be able to break the encryption. This idea represents the opposite
    approach to security through obscurity.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其中一些原则，例如要求系统支持电报使用或必须便于携带，随着人们开始使用计算机进行加密而变得过时，但第二原则仍然是现代加密算法的核心准则。美国数学家和密码学家克劳德·香农（Claude
    Shannon）后来重新阐述了这一思想：“敌人知道系统”；[⁶](notes.xhtml#ch05fn6)换句话说，加密算法应该足够强大，即使人们知道除了密钥之外的加密过程中的每一位，也仍然无法破解加密。这一思想代表了与通过模糊性进行安全保护的相反方法。
- en: Modern Cryptographic Tools
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现代加密工具
- en: Although efficient electromechanical cryptographic systems like Enigma enabled
    highly secure means of communication for a period, the increasing complexity of
    computers quickly rendered these systems obsolete. One reason was that the systems
    were not completely compliant with Kerckhoffs’s second principle and still largely
    depended on security through obscurity to protect the data they processed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管像恩尼格玛（Enigma）这样的高效机电加密系统曾在一段时间内提供了高度安全的通信手段，但计算机的复杂性迅速使这些系统过时。一个原因是这些系统并未完全符合凯尔科夫第二原则（Kerckhoffs’s
    second principle），仍然在很大程度上依赖于通过模糊性来保护其处理的数据。
- en: Modern cryptographic algorithms used by computers are truly open, meaning you
    can understand the encryption process and still not be able to break the cipher.
    These algorithms depend on difficult mathematical problems, sometimes referred
    to as *one-way problems*. One-way problems are easy to perform in one direction
    but difficult to perform in the other direction. Factorization of large numbers
    is an example of a one-way problem; it’s easy to create an algorithm that returns
    a product of multiple integers, but it’s much more difficult to create one that
    does the inverse of that operation—finding the factors of a given integer—especially
    if that number is very large. Such problems form the basis of many modern cryptographic
    systems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机使用的加密算法是真正开放的，这意味着你可以理解加密过程，却仍然无法破解密码。这些算法依赖于一些难度很高的数学问题，有时称为*单向问题*。单向问题在一个方向上很容易执行，但在另一个方向上非常困难。大数因式分解就是一个单向问题的例子；创建一个返回多个整数乘积的算法很容易，但要创建一个能够执行反向操作——找到给定整数的因数——尤其是当这个数字非常大的时候，就会变得非常困难。这样的难题构成了许多现代加密系统的基础。
- en: '*Keyword Ciphers and One-Time Pads*'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*关键字密码和一次性密码本*'
- en: Two technologies, keyword ciphers and one-time pads, helped bridge the gap between
    older cryptographic methods and modern ones. Although simpler than the algorithms
    used today, these techniques increasingly met the standard set by Kerckhoffs’s
    second principle.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 两种技术，关键字密码和一次性密码本，帮助弥合了旧有加密方法和现代加密方法之间的差距。尽管比今天使用的算法更简单，这些技术逐渐符合了凯尔霍夫第二原则设定的标准。
- en: Keyword Ciphers
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关键字密码
- en: '*Keyword ciphers* are substitution ciphers, like the Caesar cipher discussed
    earlier in the chapter. But, unlike the Caesar cipher, they use a key to determine
    what to substitute for each letter of the message. Rather than shifting all letters
    by the same number of spaces in the alphabet, you’d shift each letter to match
    the corresponding letter in the keyword. For example, if you use the keyword MYSECRET,
    you’d have the substitution shown in [Figure 5-5](#ch5fig5).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*关键字密码* 是一种替换密码，类似于本章前面讨论的凯撒密码。但与凯撒密码不同的是，它们使用密钥来决定每个字母的替换方式。你不会将所有字母按相同的位移数移动，而是将每个字母移动到与密钥中对应字母的位置。例如，如果你使用密钥MYSECRET，你将得到[图
    5-5](#ch5fig5)中所示的替换方式。'
- en: '![Image](../images/05fig05.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig05.jpg)'
- en: '*Figure 5-5: Encryption using a keyword cipher*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：使用关键字密码进行加密*'
- en: The letter *A* turns into the letter *M*, which is the first letter in the key;
    the letter *B* turns into the letter *Y*, which is the second letter in the key.
    You continue like this, removing any repeating letters in the key—notice the second
    *E* in SECRET is missing—and once the keyword ends, you assign the rest of the
    characters are in alphabetical order, minus any letter used in the key. If you
    started with the plaintext THE QUICK BROWN FOX, you’d get the ciphertext PAC LQBSF
    YNJVI RJW.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 字母* A *变成字母* M *，这是密钥中的第一个字母；字母* B *变成字母* Y *，这是密钥中的第二个字母。你可以继续这样做，去掉密钥中重复的字母——注意到SECRET中的第二个*
    E *已经被去掉——一旦密钥用完，你就按照字母表的顺序为剩余字符分配，去除密钥中使用过的字母。如果你从明文THE QUICK BROWN FOX开始，你将得到密文PAC
    LQBSF YNJVI RJW。
- en: Ciphers such as this one have weaknesses. Like all the other historical ciphers
    we’ve discussed, they’re vulnerable to *frequency analysis*, which means you can
    make guesses about what the message contents might be based on the frequency of
    characters used, where those characters appear in words, and when they’re repeated.
    For example, the letter *E* is the most commonly used letter in the English alphabet,
    so you could assume that the most frequent letter in the substitution might be
    an *E*, as well, and work from there to decrypt the message.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的密码存在弱点。像我们讨论过的所有其他历史密码一样，它们容易受到*频率分析*的攻击，这意味着你可以根据字符使用的频率、这些字符在单词中的位置以及它们的重复情况，来猜测信息内容是什么。例如，字母*
    E *是英语字母表中最常用的字母，因此你可以假设替换中最常见的字母可能也是* E *，然后从这个假设出发解密信息。
- en: To fix this flaw, cryptographers invented the one-time pad.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个缺陷，加密学家发明了**一次性密码本**。
- en: One-Time Pads
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一次性密码本
- en: The *one-time pad*, also known as the Vernam cipher, is an unbreakable cipher
    when used properly. To use it, you create two copies of the same pad of paper
    containing a completely random set of numbers, known as *shifts*, and give one
    copy to each party. These pads are the key. To encrypt the message, you use the
    shifts to move each letter of the message forward. Like with the keyword cipher,
    if the first number on the pad were 4, you’d shift the first letter of your message
    by 4 spots, and if the second number were 6, you’d shift the second letter of
    the message by 6 spots. [Figure 5-6](#ch5fig6) shows an example of this.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*一次性密码本*，也称为维尔纳密码，是一种当正确使用时无法破解的密码。使用一次性密码本时，你需要制作两份相同的纸张，每份纸张包含一组完全随机的数字，这些数字被称为*偏移*，并将其中一份交给每一方。这些纸张就是密钥。为了加密消息，你使用这些偏移量将每个字母向前移动。就像关键词密码一样，如果密码本上的第一个数字是4，你就将消息的第一个字母向前移动4个位置，如果第二个数字是6，你就将消息的第二个字母向前移动6个位置。[图
    5-6](#ch5fig6)展示了这个例子的加密过程。'
- en: '![Image](../images/05fig06.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig06.jpg)'
- en: '*Figure 5-6: Encryption using a one-time pad*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：使用一次性密码本加密*'
- en: In this example, you’d send the message ATTACKATDAWN as EYGBPMOMJXEP. The receiving
    party would consult their one-time pad and then perform the relative shifts backward
    to decrypt the message.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将发送消息ATTACKATDAWN，经过加密后变为EYGBPMOMJXEP。接收方将查阅他们的一次性密码本，然后执行相对的向后移动来解密消息。
- en: The encrypted text could generate an infinite number of possible plaintext messages.
    In the case of the Caesar cipher, where you shift the entire message by the same
    number of characters, there are only 26 possible combinations. *Brute forcing*,
    or testing every possible key to retrieve the original message, takes little time,
    and you’ll likely have no trouble recognizing the correct message when you’ve
    succeeded. But since the one-time pad uses a different shift for each letter,
    the message could contain any combination of letters or words that fits the message
    length. From the previous example, you could just as easily decrypt the incorrect
    messages ATTACKATNOON or NODONTATTACK.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 加密后的文本可能会生成无限多种可能的明文消息。在凯撒密码的情况下，其中你将整个消息按相同的字符数量移动，只有26种可能的组合。*暴力破解*，即测试每一个可能的密钥以恢复原始消息，所需的时间非常短，而且当你成功时，很可能能毫不费力地识别出正确的消息。但由于一次性密码本对每个字母使用不同的偏移，消息可能包含任何适合消息长度的字母或单词组合。从前面的例子来看，你同样可以解密错误的消息，如ATTACKATNOON或NODONTATTACK。
- en: The one-time pad is a primitive version of a stream cipher, which we’ll come
    back to shortly. You can use it with more complex pads and mathematical operations,
    and modern methods of encryption and key exchange use some of these same concepts.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密码本是流密码的原始版本，稍后我们将回到流密码的内容。你可以使用更复杂的密码本和数学运算，现代的加密和密钥交换方法使用了这些相同的概念。
- en: '*Symmetric and Asymmetric Cryptography*'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*对称加密与非对称加密*'
- en: 'Today, we can separate most cryptographic algorithms into two types: symmetric
    and asymmetric. In this section, I will discuss each type, as well as a few specific
    examples of each.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们可以将大多数密码算法分为两种类型：对称加密和非对称加密。在本节中，我将讨论每种类型，并举出一些具体的例子。
- en: Symmetric Cryptography
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对称加密
- en: Also known as private key cryptography, *symmetric key cryptography* uses a
    single key to both encrypt the plaintext and decrypt the ciphertext. Technically,
    the ciphers we’ve explored so far in this chapter use symmetric keys; to decode
    the Caesar cipher, for example, you would apply the same key to the message as
    the one used to encrypt it. That means you must share the key between the sender
    and the receiver. This process, known as *key exchange*, constitutes an entire
    subtopic of cryptography. I’ll discuss key exchange at greater length later in
    this chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 也被称为私钥加密，*对称密钥加密*使用一个密钥来加密明文和解密密文。从技术上讲，我们到目前为止在本章探讨的密码都使用了对称密钥；例如，要解码凯撒密码，你将应用与加密时相同的密钥来解密消息。这意味着你必须在发送方和接收方之间共享密钥。这个过程被称为*密钥交换*，是密码学的一个重要子主题。我将在本章后面详细讨论密钥交换。
- en: The fact that you must share a single key among all users of the system is one
    of the chief weaknesses of symmetric key cryptography. If attackers gain access
    to the key, they could decrypt the message—or, worse yet, decrypt it, alter it,
    and then encrypt it once more and pass it on to the receiver in place of the original
    message (a tactic called a *man-in-the-middle attack*).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在系统所有用户之间共享一个密钥，这是对称密钥加密的一大弱点。如果攻击者获得了这个密钥，他们就能解密消息——更糟糕的是，解密后篡改消息，再重新加密，并将其作为原始消息传递给接收者（这种策略称为*中间人攻击*）。
- en: Block vs. Stream Ciphers
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分组密码与流密码
- en: 'Symmetric key cryptography in the digital age makes use of two types of ciphers:
    block ciphers and stream ciphers. A *block cipher* takes a predetermined number
    of bits (or binary digits, which are either a 1 or a 0), known as a *block*, and
    encrypts that block. Blocks typically have 64 bits, but they can be larger or
    smaller depending on the algorithm used and the various modes the algorithm can
    operate in. A *stream cipher* encrypts each bit in the plaintext message one bit
    at a time. You can make a block cipher act as a stream cipher by setting the block
    size to one bit.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 数字时代的对称密钥加密使用了两种类型的密码：分组密码和流密码。*分组密码*以预定的位数（或二进制数字，分别为1或0），称为*块*，对该块进行加密。块通常为64位，但根据所使用的算法和算法可操作的不同模式，块的大小可能更大或更小。*流密码*则是逐位加密明文消息。你可以通过将分组大小设置为一个位，使分组密码像流密码一样工作。
- en: The majority of the encryption algorithms currently in use are block ciphers.
    Although block ciphers are often slower than stream ciphers, they tend to be more
    versatile. Since block ciphers operate on larger blocks of the message at a time,
    they’re usually more resource intensive and more complex to implement. They’re
    also more susceptible to errors in the encryption process. For example, an error
    in block cipher encryption would render a large segment of data unusable, whereas
    in a stream cipher, an error would corrupt only a single bit. You can generally
    use specific block modes to detect and compensate for such errors. A *block mode*
    defines the specific processes and operations that the cipher uses. You’ll learn
    more about these modes in the next section when I discuss the algorithms that
    use them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当前使用的大多数加密算法都是分组密码。尽管分组密码通常比流密码慢，但它们往往更具多功能性。由于分组密码一次处理较大的消息块，它们通常更加消耗资源且实现更为复杂。同时，它们也更容易在加密过程中发生错误。例如，分组密码加密中的一个错误会导致一大段数据无法使用，而流密码中的错误只会破坏一个位。通常可以使用特定的分组模式来检测并补偿这些错误。*分组模式*定义了加密算法使用的具体过程和操作。你将在下一节中了解更多关于这些模式的信息，我将讨论使用这些模式的算法。
- en: Typically, block ciphers work better with messages whose sizes are fixed or
    known in advance, such as files, or messages whose sizes are reported in protocol
    headers. It’s generally better to use stream ciphers when encrypting data of an
    unknown size or data in a continuous stream, such as information moving over a
    network, where the kind of data being sent and received is variable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，分组密码更适合用于大小固定或事先已知的消息，例如文件，或在协议头中报告大小的消息。在加密未知大小的数据或持续流动的数据（如网络传输中的信息，数据的类型和接收内容是可变的）时，通常更适合使用流密码。
- en: Symmetric Key Algorithms
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对称密钥算法
- en: Some of the most well-known cryptographic algorithms are symmetric key algorithms.
    The US government has used several of these, such as DES, 3DES, and AES, as standard
    algorithms for protecting highly sensitive data. I’ll discuss these three examples
    in this section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最著名的加密算法是对称密钥算法。美国政府已将其中几种算法，如DES、3DES和AES，作为保护高度敏感数据的标准算法。我将在本节中讨论这三种算法。
- en: '*DES* is a block cipher that uses a 56-bit key (meaning the key used by its
    cryptographic algorithm is 56 bits long). As you saw when discussing keyword ciphers,
    the length of the key determines the strength of the algorithm, because the longer
    the key is, the more possible keys there are. For example, an 8-bit key has a
    keyspace (range of possible keys) of 2⁸. DES has a keyspace of 2^(56)—that’s 72057594037927936
    possible keys attackers must test.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*DES*是一种分组密码，使用56位的密钥（这意味着其加密算法使用的密钥长度为56位）。正如你在讨论关键词密码时所见，密钥的长度决定了算法的强度，因为密钥越长，可能的密钥数就越多。例如，8位密钥的密钥空间（可能密钥的范围）为2⁸。DES的密钥空间为2^(56)——即72057594037927936个可能的密钥，攻击者必须逐一测试。'
- en: DES first came into use in 1976 in the United States and has since spread globally.
    People considered it very secure until 1999, when a distributed computing project
    attempted to break a DES key by testing every possible key in the entire keyspace.
    They succeeded in a little more than 22 hours. It turned out the keyspace was
    too short; to compensate for this, cryptographers began using *3DES* (pronounced
    “triple DES”), which is simply DES used to encrypt each block three times, with
    three different keys.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: DES于1976年首次在美国使用，并随后传播到全球。人们认为它非常安全，直到1999年，一个分布式计算项目尝试通过测试整个密钥空间中的每一个可能的密钥来破解DES密钥。它们成功了，只用了22个小时多一点。事实证明，密钥空间太短；为了解决这个问题，密码学家开始使用*3DES*（发音为“三重DES”），它实际上是使用DES对每个块进行三次加密，每次使用不同的密钥。
- en: 'Eventually, the US government replaced DES with *AES*, a set of symmetric block
    ciphers. AES uses three different ciphers: one with a 128-bit key, one with a
    192-bit key, and one with a 256-bit key, all of which encrypt blocks of 128 bits.
    Briefly, there are a few key differences between AES and 3DES.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，美国政府用*AES*（一组对称分组密码）替代了DES。AES使用三种不同的密码：一种使用128位密钥，一种使用192位密钥，一种使用256位密钥，所有这些都加密128位的块。简而言之，AES和3DES之间有一些关键的区别。
- en: 3DES is three rounds of DES, while AES uses a newer and completely different
    algorithm developed in 2000.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3DES是DES的三轮变种，而AES使用的是2000年开发的全新且完全不同的算法。
- en: AES uses longer and stronger keys than 3DES, as well as a longer block length,
    making AES harder to attack.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AES使用比3DES更长且更强的密钥，以及更长的分组长度，使得AES更难被攻击。
- en: 3DES is slower than AES.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3DES比AES慢。
- en: Hackers have attempted a variety of attacks against AES, most of them against
    the encryption using the 128-bit key. Most of these have either failed or had
    only partial success. At the time of this writing, the US government still considers
    AES to be secure.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客们对AES进行了一系列攻击，主要集中在使用128位密钥进行加密的攻击。大多数攻击要么失败，要么仅部分成功。在撰写本文时，美国政府仍然认为AES是安全的。
- en: Other well-known symmetric block ciphers include Twofish, Serpent, Blowfish,
    CAST5, RC6, and IDEA. Popular stream ciphers include RC4, ORYX, and SEAL.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 其他著名的对称分组密码包括Twofish、Serpent、Blowfish、CAST5、RC6和IDEA。流密码的常见例子包括RC4、ORYX和SEAL。
- en: Asymmetric Cryptography
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 非对称密码学
- en: 'Martin Hellman and Whitfield Diffie first described asymmetric cryptography
    in their 1976 paper, “New Directions in Cryptography.”[⁷](notes.xhtml#ch05fn7)
    While symmetric key cryptography makes use of only one key, *asymmetric key cryptography*,
    also known as public key cryptography, uses two keys: a public key and a private
    key. You use the public key to encrypt data, and anyone can access the public
    key. You can see them included in email signatures or posted on servers that exist
    specifically to host public keys. Private keys, used to decrypt messages, are
    carefully guarded by the receiver. Cryptographers use complex mathematical operations
    to create the private and public keys. These operations—which typically involve
    factorizing very large prime numbers, as I discussed earlier in the chapter—are
    difficult enough that, currently, no method exists to discover the private key
    by using the public key.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁·赫尔曼和惠特菲尔德·迪菲在他们1976年的论文《密码学的新方向》中首次描述了非对称密码学。[⁷](notes.xhtml#ch05fn7) 与对称密钥密码学只使用一个密钥不同，*非对称密钥密码学*，也称为公钥密码学，使用两个密钥：一个公钥和一个私钥。你使用公钥来加密数据，任何人都可以访问公钥。你可以在电子邮件签名中看到它们，或者它们可以发布在专门用于托管公钥的服务器上。私钥用于解密消息，由接收者严格保管。密码学家使用复杂的数学运算来生成私钥和公钥。这些运算——通常涉及因式分解非常大的质数，如我在本章前面讨论的——足够复杂，以至于目前没有方法能够通过使用公钥来发现私钥。
- en: The main advantage of asymmetric key cryptography over symmetric key cryptography
    is that you no longer need to distribute the key. In symmetric key cryptography,
    as discussed, the message sender needs to find a way of sharing the key with whomever
    they want to communicate with. They might do this by exchanging keys in person,
    sending a key in an email, or repeating it verbally over the phone, but the method
    must be secure enough to ensure the key isn’t intercepted. But with asymmetric
    key cryptography, you don’t have to share a secret key. You simply make your public
    key available, and anyone who needs to send you an encrypted message can use it
    without compromising the security of the system.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称密钥加密相对于对称密钥加密的主要优势在于你不再需要分发密钥。正如前文所述，在对称密钥加密中，消息发送者需要找到一种与接收方共享密钥的方法。他们可能通过面对面交换密钥、通过电子邮件发送密钥，或通过电话口头传递密钥，但方法必须足够安全，以确保密钥不被截获。而在非对称密钥加密中，你无需共享私密密钥。你只需提供公钥，任何需要向你发送加密消息的人都可以使用它，而不会危及系统的安全性。
- en: Asymmetric Key Algorithms
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 非对称密钥算法
- en: The *RSA* algorithm, named after the initials of its creators, Ron Rivest, Adi
    Shamir, and Leonard Adleman, is an asymmetric algorithm used across the world,
    including in the Secure Sockets Layer (SSL) protocol. (*Protocols* are the rules
    that define communication between devices. SSL secures many common transactions,
    such as web and email traffic.) Created in 1977, RSA is still one of the most
    widely used algorithms in the world to this day.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*RSA* 算法以其创始人 Ron Rivest、Adi Shamir 和 Leonard Adleman 的名字首字母命名，是一种在全球范围内使用的非对称算法，包括在安全套接层（SSL）协议中。（*协议*
    是定义设备间通信规则的标准。SSL 用于保护许多常见的交易，如网页和电子邮件流量。）RSA 于1977年创建，至今仍是世界上最广泛使用的算法之一。'
- en: '*Elliptic curve cryptography (ECC)* is a class of cryptographic algorithms,
    although people sometimes refer to it as though it were a single algorithm. Named
    for the type of mathematical problem on which its cryptographic functions are
    based, elliptic curve cryptography has several advantages over other types of
    algorithms.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*椭圆曲线加密（ECC）* 是一类加密算法，尽管人们有时将其视为单一的算法。椭圆曲线加密以其加密功能所基于的数学问题命名，相较于其他类型的算法，椭圆曲线加密具有几个优点。'
- en: ECC can use short keys while maintaining a higher cryptographic strength than
    many other types of algorithms. It’s also a fast and efficient type of algorithm
    that allows us to easily implement it on hardware that has less processing power
    and memory, such as a cell phone or portable device. A variety of cryptographic
    algorithms, including the Secure Hash Algorithm 2 (SHA-2) and Elliptic Curve Digital
    Signature Algorithm (ECDSA), use ECC.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ECC 能够在使用较短的密钥时，保持比许多其他算法更强的加密强度。它也是一种快速高效的算法，可以轻松地在处理能力和内存较少的硬件上实现，比如手机或便携设备。多种加密算法，包括安全哈希算法
    2（SHA-2）和椭圆曲线数字签名算法（ECDSA），都使用 ECC。
- en: Other asymmetric algorithms include ElGamal, Diffie–Hellman, and Digital Signature
    Standard (DSS). Many protocols and applications are based on asymmetric cryptography,
    including Pretty Good Privacy (PGP) for securing messages and files, SSL and Transport
    Layer Security (TLS) for common internet traffic, and some voice over IP (VoIP)
    protocols for voice conversations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 其他非对称算法包括 ElGamal、Diffie–Hellman 和数字签名标准（DSS）。许多协议和应用程序基于非对称加密技术，包括用于保护消息和文件的
    Pretty Good Privacy（PGP）、用于常见互联网流量的 SSL 和传输层安全性（TLS）、以及一些用于语音通话的语音通信协议（VoIP）。
- en: '**PGP**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**PGP**'
- en: PGP, created by Phil Zimmerman, was one of the first strong encryption tools
    to reach the eye of the public and the media. Created in the early 1990s, the
    original release of PGP was based on a symmetric algorithm, and you could use
    it to secure data such as communications and files. The original version of PGP
    was given away as free software, including the source code. At the time of its
    release, PGP was regulated as munitions under the US International Traffic in
    Arms Regulations (ITAR) law. Zimmerman spent several years under investigation
    for criminal activities when he was suspected of exporting PGP out of the country,
    which was illegal at the time and considered to be arms trafficking.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: PGP是由Phil Zimmerman创建的，它是最早引起公众和媒体注意的强加密工具之一。PGP创建于1990年代初期，最初版本基于对称加密算法，可以用来保护数据，如通讯和文件。PGP的原始版本作为免费软件发布，包括源代码。在发布时，PGP被美国《国际军火贸易条例》（ITAR）法规定为军火。Zimmerman曾因涉嫌将PGP出口到国外而被调查，这在当时是非法的，且被视为武器走私，Zimmerman因此经历了数年的刑事调查。
- en: '*Hash Functions*'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*哈希函数*'
- en: '*Hash functions* represent a third type of modern cryptography, which we call
    keyless cryptography. Instead of using a key, hash functions, or message digests,
    convert the plaintext into a largely unique and fixed-length value, commonly referred
    to as a *hash*. You can think of these hash values as fingerprints because they’re
    unique identifiers of a message. Moreover, hashes of similar messages look completely
    different. [Figure 5-7](#ch5fig7) shows some hashes.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*哈希函数*代表了现代密码学的第三种类型，我们称之为无密钥密码学。与使用密钥不同，哈希函数或消息摘要将明文转换为大致唯一且固定长度的值，通常称为*哈希*。你可以将这些哈希值视为指纹，因为它们是消息的唯一标识符。此外，相似消息的哈希看起来完全不同。[图5-7](#ch5fig7)展示了一些哈希。'
- en: '![Image](../images/05fig07.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig07.jpg)'
- en: '*Figure 5-7: A hash function generates a unique value for every message, no
    matter how similar the messages are.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-7：哈希函数为每条消息生成唯一的值，无论消息多么相似。*'
- en: Notice that the message we’re hashing in B differs from message A by only a
    single word, but it produces a completely different hash. The same is true for
    message C, which removes only a single space from the original message but still
    generates a unique hash. You can’t use hashes to discover the contents of the
    original message, or any of its other characteristics, but you can use it to determine
    whether the message has changed. This means that if you’re distributing files
    or sending communications, you can send the hash with the message so that the
    receiver can verify its integrity. To do this, the receiver simply hashes the
    message again using the same algorithm and then compares the two hashes. If the
    hashes match, the message has not changed. If they don’t match, the message has
    been altered.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，消息B与消息A只有一个单词的不同，但它生成了一个完全不同的哈希值。消息C也是如此，它仅删除了原始消息中的一个空格，但仍然生成了一个独特的哈希值。你不能通过哈希值发现原始消息的内容或其他特征，但可以用它来判断消息是否发生了变化。这意味着，如果你在分发文件或发送通讯时，可以将哈希值与消息一起发送，以便接收方验证其完整性。为此，接收方只需使用相同的算法重新计算消息的哈希值，然后比较两个哈希值。如果哈希值匹配，消息未发生变化；如果不匹配，消息已被篡改。
- en: Although it’s theoretically possible to engineer a matching hash for two different
    sets of data, called a *collision*, this is difficult and generally happens only
    if you’re using a broken hashing algorithm. Some algorithms, such as Message-Digest
    algorithm 5 (MD5) and Secure Hash Algorithm 1 (SHA-1), have been attacked in this
    fashion, although it’s uncommon ([Figure 5-8](#ch5fig8)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从理论上讲，可以为两组不同的数据工程出匹配的哈希值，这种现象称为*碰撞*，但这很困难，通常只有在使用破损的哈希算法时才会发生。一些算法，如消息摘要算法5（MD5）和安全哈希算法1（SHA-1），曾经以这种方式受到攻击，尽管这种情况不常见（[图5-8](#ch5fig8)）。
- en: '![Image](../images/05fig08.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/05fig08.jpg)'
- en: '*Figure 5-8: In a hash collision, two distinct messages produce the same hash.*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-8：在哈希碰撞中，两条不同的消息产生相同的哈希值。*'
- en: When collisions occur, you generally stop using the compromised algorithm. Those
    who require stringent hash security have mostly stopped using MD5 and replaced
    it with SHA-2 and SHA-3.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生碰撞时，通常会停止使用受损的算法。需要严格哈希安全的用户大多已经停止使用MD5，并用SHA-2和SHA-3替代。
- en: Other hash algorithms include MD2, MD4, and RACE.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其他哈希算法包括MD2、MD4和RACE。
- en: '*Digital Signatures*'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*数字签名*'
- en: Another way to use asymmetric algorithms and their associated public and private
    keys is to create digital signatures. A *digital signature* allows you to sign
    a message so that others can detect any changes to the message after you’ve sent
    it, ensure that the message was legitimately sent by the expected party, and prevent
    the sender from denying that they sent the message (a principle known as *nonrepudiation*,
    covered in [Chapter 4](ch04.xhtml)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非对称算法及其相关的公钥和私钥的另一种方式是创建数字签名。*数字签名*允许你签署一条消息，以便其他人能够检测消息在你发送之后是否发生了任何变化，确保消息确实由预期的发送方发出，并防止发送方否认他们发送了该消息（这一原则被称为*不可否认性*，详见[第4章](ch04.xhtml)）。
- en: To digitally sign a message, the sender generates a hash of the message and
    then uses their private key to encrypt the hash. The sender then sends this digital
    signature along with the message, usually by appending it to the message itself.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对消息进行数字签名，发送方首先生成消息的哈希值，然后使用其私钥对哈希值进行加密。接着，发送方将数字签名与消息一起发送，通常是将其附加到消息本身。
- en: When the message arrives at the receiving end, the receiver uses the public
    key corresponding to the sender’s private key to decrypt the digital signature,
    thus restoring the original hash of the message. The receiver can then verify
    the message’s integrity by hashing the message again and comparing the two hashes.
    This may sound like a considerable amount of work just to verify the integrity
    of the message, but software applications usually do it for you, so the process
    is typically invisible to the user.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息到达接收端时，接收方使用与发送方私钥对应的公钥来解密数字签名，从而恢复原始的消息哈希值。接收方可以通过再次对消息进行哈希处理并比较这两个哈希值来验证消息的完整性。这听起来似乎需要不少工作来验证消息的完整性，但通常软件应用程序会为你完成这些工作，因此这个过程通常对用户是透明的。
- en: '*Certificates*'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*证书*'
- en: In addition to hashes and digital signatures, you can use digital certificates
    to sign your messages. *Digital certificates*, as shown in [Figure 5-9](#ch5fig9),
    link a public key to an individual by validating that the key belongs to the proper
    owner, and they’re often used as a form of electronic identification for that
    person.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了哈希值和数字签名之外，你还可以使用数字证书对消息进行签名。*数字证书*，如[图 5-9](#ch5fig9)所示，通过验证公钥是否属于正确的所有者，将公钥与个人关联起来，通常作为该人的电子身份识别形式。
- en: '![Image](../images/05fig09.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig09.jpg)'
- en: '*Figure 5-9: A digital certificate*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-9：数字证书*'
- en: You typically create a certificate by taking the public key and identifying
    information, such as a name and address, and having them signed by a trusted entity
    that handles digital certificates, called a *certificate authority*. A certificate
    authority is the entity that issues certificates. It acts as a trusted third party
    to both sides of transactions that involve certificates by signing the certificate
    to begin with and later verifying that it is still valid. One well-known certificate
    authority is VeriSign. Some large organizations, such as the US Department of
    Defense, may choose to implement their own certificate authority to keep costs
    down.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以通过将公钥和身份信息（例如姓名和地址）进行结合，并由处理数字证书的可信实体（称为*证书颁发机构*）进行签名，从而创建证书。证书颁发机构是颁发证书的实体。它充当交易双方之间的可信第三方，最初签署证书并在后续验证证书是否仍然有效。一家知名的证书颁发机构是
    VeriSign。一些大型组织，如美国国防部，可能会选择建立自己的证书颁发机构，以降低成本。
- en: A certificate allows you to verify that a public key is truly associated with
    an individual. In the case of the digital signature discussed in the preceding
    section, someone might have falsified the keys used to sign the message; maybe
    those keys did not actually belong to the original sender. If the sender had a
    digital certificate, you could easily check with the certificate authority to
    ensure that the public key for the sender is legitimate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 证书允许你验证公钥是否真正与某个个人相关联。在前一节讨论的数字签名中，可能有人伪造了用来签署消息的密钥；这些密钥可能并不属于原始发送者。如果发送者有数字证书，你可以轻松地向证书颁发机构查询，确保发送者的公钥是合法的。
- en: 'A certificate authority is only a small part of the infrastructure that you
    can put in place to handle certificates on a large scale. This infrastructure
    is known as a *public key infrastructure (PKI)*. A PKI usually has two main components:
    the certificate authorities that issue and verify certificates, and the registration
    authorities that verify the identity of the individual associated with the certificate,
    although some organizations may separate some functions out into more than just
    these.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 证书授权机构只是你可以建立的基础设施中的一小部分，用于大规模处理证书。这个基础设施被称为*公钥基础设施（PKI）*。PKI通常有两个主要组成部分：发行和验证证书的证书授权机构，以及验证与证书关联的个人身份的注册机构，尽管一些组织可能将一些功能分离为不止这些。
- en: A PKI might also revoke certificates if they reach their expiration date, are
    compromised, or shouldn’t be used for some other reason. In this case, the certificate
    will likely be added to a certificate revocation list, which is generally a public
    list that holds all an organization’s revoked certificates for a time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥基础设施（PKI）也可能会撤销证书，如果证书达到过期日期、遭到泄露或因其他原因不应继续使用。在这种情况下，证书很可能会被加入到证书撤销列表中，该列表通常是一个公开的列表，保存着所有被撤销的证书一段时间。
- en: Protecting Data at Rest, in Motion, and in Use
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护静态数据、传输中的数据和使用中的数据
- en: 'You can divide the practical uses of cryptography into three major categories:
    protecting data at rest, protecting data in motion, and protecting data in use.
    Data at rest includes the large amount of stored data on devices such as backup
    tapes, flash drives, and hard drives in portable devices such as laptops. Data
    in motion is the enormous amount of information sent over the internet, including
    financial transactions, medical information, tax filings, and other similarly
    sensitive exchanges. Data in use is data actively being accessed.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将密码学的实际应用分为三个主要类别：保护静态数据、保护传输中的数据和保护使用中的数据。静态数据包括存储在设备上的大量数据，如备份磁带、闪存驱动器以及便携设备（如笔记本电脑）中的硬盘。传输中的数据是通过互联网传送的大量信息，包括财务交易、医疗信息、税务申报和其他类似敏感的交换数据。使用中的数据是指正在被主动访问的数据。
- en: '*Protecting Data at Rest*'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*保护静态数据*'
- en: People often neglect to protect *data at rest*, which is data on a storage device
    of some kind that isn’t moving over a network, through a protocol, or across some
    other communication platform.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常常忽视保护*静态数据*，即存储在某种设备上的数据，这些数据没有通过网络、协议或其他通信平台进行传输。
- en: Somewhat illogically, data at rest can also, technically, be in motion. For
    example, you might ship a load of backup tapes containing sensitive data, carry
    a flash drive containing a copy of your tax forms in your pocket, or leave a laptop
    containing the contents of a customer database in the back seat of your car.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上讲，静态数据也可以技术上算作是传输中的数据。例如，你可能会邮寄一批包含敏感数据的备份磁带，随身携带包含税表副本的闪存驱动器，或者将包含客户数据库内容的笔记本电脑留在汽车的后座。
- en: Attackers exploit this fact on a regular basis. For example, in 2017, someone
    found a USB flash drive in the street outside Heathrow Airport in London and discovered
    it contained information about the routes and security measures used to protect
    Queen Elizabeth II, as well as other high-ranking officials and dignitaries, when
    they move through the airport.[⁸](notes.xhtml#ch05fn8)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者经常利用这一事实。例如，2017年，有人发现了一只USB闪存驱动器，掉落在伦敦希思罗机场外的街道上，并发现它包含了关于女王伊丽莎白二世及其他高级官员和重要人物在机场活动时使用的路线和安保措施的信息。[⁸](notes.xhtml#ch05fn8)
- en: Had necessary steps been taken to protect the flash drive’s data at rest by
    encrypting it, the security incident would not have occurred (and authorities
    would not have had to publicly disclose that the incident had occurred, saving
    them from quite a bit of embarrassment).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果采取必要的步骤通过加密来保护闪存驱动器上的静态数据，这起安全事件就不会发生（当局也不必公开披露事件的发生，这为他们避免了不少尴尬）。
- en: Data Security
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据安全
- en: We primarily use encryption to protect data at rest, particularly when we know
    that the device containing the data could be physically stolen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要通过加密来保护静态数据，特别是在我们知道包含数据的设备可能会被物理盗窃时。
- en: An enormous number of commercial products provide encryption for portable devices.
    These often target hard drives and portable storage devices, including products
    from large companies such as Intel and Symantec, to name a few. These commercial
    products often encrypt entire hard disks (a process known as *full disk encryption*)
    and a variety of removable media, and they report back to centralized management
    servers or other security and administrative features. There are also several
    free or open source encryption products on the market, such as VeraCrypt,[⁹](notes.xhtml#ch05fn9)
    BitLocker[^(10)](notes.xhtml#ch05fn10) (which ships with some versions of Windows),
    and dm-crypt[^(11)](notes.xhtml#ch05fn11) (which is specific to Linux).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 许多商业产品提供便携设备加密，这些产品通常针对硬盘和便携存储设备，包括像英特尔和赛门铁克等大公司提供的产品。这些商业产品通常会加密整个硬盘（这一过程被称为*全盘加密*），以及各种可移动媒体，并将数据报告回集中管理服务器或其他安全与管理功能。市场上也有一些免费的或开源的加密产品，例如VeraCrypt，[⁹](notes.xhtml#ch05fn9)、BitLocker[^(10)](notes.xhtml#ch05fn10)（一些版本的Windows附带此工具）和dm-crypt[^(11)](notes.xhtml#ch05fn11)（这是Linux专用的）。
- en: Physical Security
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 物理安全
- en: Physical security, which I’ll discuss at length in [Chapter 9](ch09.xhtml),
    is an important part of protecting data at rest. If you make it more difficult
    for attackers to physically access or steal the storage media that contains sensitive
    data, you have solved a large portion of your problem.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 物理安全，我将在[第9章](ch09.xhtml)中详细讨论，是保护静态数据的重要组成部分。如果你能让攻击者更难以物理访问或窃取存储介质中包含的敏感数据，那么你就解决了大部分问题。
- en: In many cases, large businesses have databases, file servers, and workstations
    that contain customer information, sales forecasts, business strategy documents,
    network diagrams, and other kinds of data they want to keep from becoming public
    or falling into the hands of their competitors. If the physical security at the
    building that houses the data is weak, an attacker might be able to simply enter
    the building, steal a device, and walk right out with the data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，大型企业拥有包含客户信息、销售预测、商业战略文档、网络图等数据的数据库、文件服务器和工作站，这些数据是他们希望避免公开或落入竞争对手手中的。如果存储这些数据的大楼的物理安全性较弱，攻击者可能仅需进入建筑物，窃取设备，便能轻松带着数据离开。
- en: You also need to be aware of the areas you cannot physically protect and limit
    the data that leaves your protected spaces. In an office building, you could apply
    extra layers of physical security to the data center containing your servers,
    for example. Once sensitive data leaves such areas, your ability to protect it
    becomes more limited. In the case of the Heathrow flash drive that I discussed
    earlier, officials might have kept this sensitive data from being copied to an
    external drive to prevent it from walking out the door and being lost in the street.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要意识到一些无法物理保护的区域，并限制离开受保护区域的数据。例如，在一座办公楼中，你可以对包含服务器的数据中心应用额外的物理安全措施。一旦敏感数据离开这些区域，你的保护能力就会变得更加有限。就像我之前讨论过的希思罗机场的U盘事件，官员们可能会防止敏感数据被复制到外部驱动器上，以避免数据被带出门外并丢失在街头。
- en: '*Protecting Data in Motion*'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*保护传输中的数据*'
- en: Often, data travels over networks, whether it be a closed wide area network
    (WAN) or local area network (LAN), a wireless network, or the internet. To protect
    data exposed on a network, you will usually choose to either encrypt the data
    itself or encrypt the entire connection.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通常通过网络传输，无论是封闭的广域网（WAN）、局域网（LAN）、无线网络，还是互联网。为了保护暴露在网络上的数据，你通常会选择加密数据本身或加密整个连接。
- en: Protecting the Data Itself
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 保护数据本身
- en: You can take a variety of approaches to encrypting the data you are sending
    over the network, depending on the kind of data you are sending and the protocols
    over which you are sending it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你发送的数据类型和所使用的协议，你可以采取多种方式来加密网络传输的数据。
- en: You will often use SSL and TLS to encrypt a connection between two systems communicating
    over a network. SSL is TLS’s predecessor, although the terms are often used interchangeably,
    and they are nearly identical. SSL and TLS operate in conjunction with other protocols,
    such as Internet Message Access Protocol (IMAP) and Post Office Protocol (POP)
    for email, Hypertext Transfer Protocol (HTTP) for web traffic, and VoIP for voice
    conversations and instant messaging.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你将经常使用 SSL 和 TLS 来加密两个系统之间的连接，这两个系统通过网络进行通信。SSL 是 TLS 的前身，尽管这两个术语通常可以互换使用，它们几乎是一样的。SSL
    和 TLS 与其他协议协同工作，如互联网邮件访问协议（IMAP）和邮局协议（POP）用于电子邮件，超文本传输协议（HTTP）用于网页流量，语音通信和即时消息使用
    VoIP。
- en: However, SSL and TLS protections generally apply to only a single application
    or protocol, so although you might be using them to encrypt your communications
    with the server that holds your email, this doesn’t necessarily mean the connections
    made through your web browser have the same level of security. Many common applications
    are capable of supporting SSL and TLS, but you generally need to configure them
    to do so independently.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，SSL 和 TLS 保护通常只适用于单一的应用程序或协议，因此，尽管你可能在加密与服务器之间的通信时使用它们，例如与存储你电子邮件的服务器进行通信，但这并不意味着通过你的网页浏览器建立的连接也具有相同的安全级别。许多常见的应用程序支持
    SSL 和 TLS，但通常需要单独配置才能使用。
- en: Protecting the Connection
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 保护连接
- en: Another approach to protecting data in motion is encrypting all your network
    traffic with a virtual private network (VPN) connection. VPN connections use a
    variety of protocols to create a secure connection between two systems. You might
    use a VPN when you’re accessing data from a potentially insecure network, such
    as the wireless connection in a hotel.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 保护数据传输的另一种方法是通过虚拟私人网络（VPN）连接加密你所有的网络流量。VPN 连接使用多种协议在两个系统之间创建安全连接。当你从一个可能不安全的网络访问数据时，例如酒店的无线连接时，你可能会使用
    VPN。
- en: The two most common protocols currently used to secure VPNs are Internet Protocol
    Security (IPsec) and SSL. You can configure these two types of VPN connections
    to have a nearly identical set of features and functionality, from the perspective
    of the user, but they require a slightly different set of hardware and software
    to set up.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当前最常用的两种安全 VPN 的协议是互联网协议安全（IPsec）和 SSL。从用户的角度来看，你可以将这两种类型的 VPN 连接配置为具有几乎相同的功能和特性，但它们需要稍微不同的硬件和软件来进行设置。
- en: Typically, an IPsec VPN requires a more complex hardware configuration on the
    back end, as well as a software client you have to install, whereas an SSL VPN
    often operates from a lightweight plug-in downloaded from a web page and a less
    complex hardware configuration on the back end. From a security standpoint, the
    two methods have relatively similar levels of encryption. One weakness of the
    SSL VPN client, however, is that you could download it to a public computer or
    other random insecure device and provide an avenue for data leakage or an attack.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，IPsec VPN 在后台需要更复杂的硬件配置，并且你需要安装一个软件客户端，而 SSL VPN 通常通过从网页下载的轻量级插件运行，并且后台硬件配置较为简单。从安全角度来看，这两种方法的加密水平相对相似。然而，SSL
    VPN 客户端的一个弱点是，你可能会将其下载到公共计算机或其他随机的不安全设备上，从而为数据泄露或攻击提供了途径。
- en: '*Protecting Data in Use*'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*保护使用中的数据*'
- en: The last category of data to protect is the data currently being used. Although
    we can use encryption to protect data while it’s stored or moving across a network,
    we are somewhat limited in our ability to protect data while legitimate entities
    have access to it. Authorized users can print files, move them to other machines
    or storage devices, email them, share them on peer-to-peer file-sharing networks,
    and generally make a mockery of our meticulous security measures.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一类需要保护的数据是当前正在使用的数据。尽管我们可以通过加密来保护存储的数据或在网络上传输的数据，但在合法实体可以访问数据时，我们在保护数据方面的能力受到了一定限制。授权用户可以打印文件、将文件转移到其他计算机或存储设备、通过电子邮件发送文件、在点对点文件共享网络上分享文件，并且通常会使我们精心制定的安全措施形同虚设。
- en: In June 2013, the public discovered that a government contractor named Edward
    Snowden had deliberately leaked classified information containing details about
    the US National Security Agency PRISM program, which was ostensibly designed to
    collect and review terrorism-related communications.[^(12)](notes.xhtml#ch05fn12)
    Although this incident occurred more than five years ago at the time of this writing,
    the US intelligence community is still cleaning up after it and working to prevent
    another such incident.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年6月，公众发现一名名为爱德华·斯诺登的政府承包商故意泄露了包含有关美国国家安全局PRISM项目细节的机密信息，该项目表面上旨在收集和审查与恐怖主义相关的通信。[^(12)](notes.xhtml#ch05fn12)尽管此事件发生在本文撰写时已经超过五年，但美国情报界仍在清理此事件的后果，并致力于防止类似事件的再次发生。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Cryptography has existed in one form or another for most of recorded history.
    Early cryptographic practices varied in complexity, from the simple substitution
    ciphers of the Roman era to the complex electromechanical machines used before
    the invention of modern computing systems. Although such primitive cryptographic
    methods would not protect against modern cryptographic attacks, they form the
    basis for our modern algorithms.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 加密学自有记录的历史以来，几乎以某种形式存在。早期的加密实践在复杂性上有所不同，从罗马时代的简单替换密码到现代计算机系统发明之前使用的复杂电机械设备。尽管这些原始的加密方法无法防御现代加密攻击，但它们为我们现代的算法奠定了基础。
- en: 'Today, you conduct cryptography by using computers to create complex algorithms
    that encrypt your data. There are three main kinds of cryptographic algorithms:
    symmetric key cryptography, asymmetric key cryptography, and hash functions. In
    symmetric key cryptography, you encrypt and decrypt data with the same key, to
    which all parties operating on the plaintext or ciphertext have access. In asymmetric
    cryptography, you use both a public and a private key. The sender encrypts the
    message with the receiver’s public key, and the receiver decrypts the message
    with their private key. This resolves the problem of having to find a secure way
    to share a single private key between the receiver and the sender. Hash functions
    don’t use a key at all; they create a (theoretically) unique fingerprint of the
    message so that we can tell if the message has been altered from its original
    form.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，您通过使用计算机创建复杂的算法来加密您的数据，从而进行加密操作。加密算法主要有三种类型：对称密钥加密、非对称密钥加密和哈希函数。在对称密钥加密中，您使用相同的密钥对数据进行加密和解密，所有操作明文或密文的参与方都可以访问该密钥。在非对称加密中，您使用公钥和私钥。发送方使用接收方的公钥加密消息，接收方使用自己的私钥解密消息。这解决了必须找到一种安全方式在接收方和发送方之间共享单个私钥的问题。哈希函数根本不使用密钥；它们创建一个（理论上）独特的消息指纹，以便我们能够判断消息是否被篡改。
- en: Digital signatures are an extension of hash functions that allow you to not
    only create a hash to ensure that the message has not been altered but also encrypt
    the hash with the public key of an asymmetric algorithm to ensure that the message
    was sent by the expected party and to ensure nonrepudiation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名是哈希函数的扩展，允许您不仅创建哈希以确保消息没有被篡改，还可以使用非对称算法的公钥加密哈希，以确保消息确实由预期的方发送，并确保不可否认性。
- en: Certificates allow you to link a public key to an identity so that you can ensure
    that an encrypted message really represents a communication from a particular
    individual. The receiver can check with the issuer of the certificate—the certificate
    authority—to determine whether the certificate presented is, in fact, legitimate.
    Behind the certificate, you may find a PKI, which issues, verifies, and revokes
    certificates.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 证书使您能够将公钥与身份关联，从而确保加密消息确实代表某个特定个人的通信。接收方可以向证书颁发机构——证书授权机构查询，以确定所提供的证书是否确实有效。在证书背后，您可能会发现一个公钥基础设施（PKI），它负责颁发、验证和撤销证书。
- en: In general, cryptography provides a mechanism to protect data at rest, data
    in motion, and, to a certain extent, data in use. It provides the core of many
    of the basic security mechanisms that enable you to communicate and carry out
    transactions when the data involved is of a sensitive nature.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，加密学提供了一种机制，用于保护静态数据、传输中的数据，并在某种程度上保护使用中的数据。它提供了许多基本安全机制的核心，使您能够在数据涉及敏感内容时进行通信和交易。
- en: Exercises
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: What type of cipher is a Caesar cipher?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 凯撒密码是哪种类型的密码？
- en: What is the difference between a block and a stream cipher?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块密码和流密码之间有什么区别？
- en: ECC is classified as which type of cryptographic algorithm?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ECC属于哪种类型的加密算法？
- en: What is the key point of Kerckhoffs’s second principle?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kerckhoffs的第二原则的关键点是什么？
- en: What is a substitution cipher?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是替换密码？
- en: What are the main differences between symmetric and asymmetric key cryptography?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对称加密和非对称加密的主要区别是什么？
- en: Explain how 3DES differs from DES.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释一下3DES与DES的区别。
- en: How does public key cryptography work?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公钥加密是如何工作的？
- en: 'Try to decrypt this message using the information in this chapter: V qb abg
    srne pbzchgref. V srne gur ynpx bs gurz. —Vfnnp Nfvzbi.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用本章中的信息解密此消息：V qb abg srne pbzchgref. V srne gur ynpx bs gurz. —Vfnnp Nfvzbi.
- en: How is physical security important when discussing the cryptographic security
    of data?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在讨论数据的加密安全性时，物理安全为何如此重要？
