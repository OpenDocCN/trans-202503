- en: Chapter 63. Alternative I/O Models
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第63章 替代I/O模型
- en: 'This chapter discusses three alternatives to the conventional file I/O model
    that we have employed in most programs shown in this book:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了三种替代传统文件I/O模型的方法，这些方法在本书中展示的大多数程序中都有应用：
- en: I/O multiplexing (the *select()* and *poll()* system calls);
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O复用（*select()* 和 *poll()* 系统调用）；
- en: signal-driven I/O; and
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号驱动I/O；
- en: the Linux-specific *epoll* API.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于Linux的*epoll* API。
- en: Overview
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Most of the programs that we have presented so far in this book employ an I/O
    model under which a process performs I/O on just one file descriptor at a time,
    and each I/O system call blocks until the data is transferred. For example, when
    reading from a pipe, a *read()* call normally blocks if no data is currently present
    in the pipe, and a *write()* call blocks if there is insufficient space in the
    pipe to hold the data to be written. Similar behavior occurs when performing I/O
    on various other types of files, including FIFOs and sockets.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中展示的大多数程序都采用了一个I/O模型，其中一个进程一次只能对一个文件描述符进行I/O操作，每个I/O系统调用会阻塞，直到数据被传输。例如，在从管道中读取数据时，如果管道中没有数据，*read()*调用通常会阻塞；而*write()*调用则会在管道中没有足够空间存储待写入的数据时阻塞。在执行其他各种类型的文件（包括FIFO和套接字）的I/O操作时，也会发生类似的行为。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注解
- en: Disk files are a special case. As described in [Chapter 13](ch13.html "Chapter 13. File
    I/O Buffering"), the kernel employs the buffer cache to speed disk I/O requests.
    Thus, a *write()* to a disk returns as soon as the requested data has been transferred
    to the kernel buffer cache, rather than waiting until the data is written to disk
    (unless the `O_SYNC` flag was specified when opening the file). Correspondingly,
    a *read()* transfers data from the buffer cache to a user buffer, and if the required
    data is not in the buffer cache, then the kernel puts the process to sleep while
    a disk read is performed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘文件是一个特殊的情况。如[第13章](ch13.html "第13章 文件I/O缓冲")所述，内核使用缓冲区缓存来加速磁盘I/O请求。因此，向磁盘写入*write()*调用会在请求的数据传输到内核缓冲区缓存后立即返回，而不是等到数据写入磁盘（除非在打开文件时指定了`O_SYNC`标志）。相应地，*read()*会将数据从缓冲区缓存传输到用户缓冲区，如果所需数据不在缓冲区缓存中，内核会将进程挂起，直到完成磁盘读取。
- en: 'The traditional blocking I/O model is sufficient for many applications, but
    not all. In particular, some applications need to able to do one or both of the
    following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的阻塞I/O模型对于许多应用程序来说是足够的，但并非所有情况都适用。特别是一些应用程序需要能够做到以下一项或两项：
- en: Check whether I/O is possible on a file descriptor without blocking if it is
    not possible.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查文件描述符上是否可以进行I/O操作，如果不行，则不阻塞。
- en: Monitor multiple file descriptors to see if I/O is possible on any of them.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控多个文件描述符，看看是否可以对其中任何一个进行I/O操作。
- en: 'We have already encountered two techniques that can be used to partially address
    these needs: nonblocking I/O and the use of multiple processes or threads.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经遇到过两种可以部分解决这些需求的技术：非阻塞I/O和使用多个进程或线程。
- en: We described nonblocking I/O in some detail in [Nonblocking I/O](ch05.html#nonblocking_i_solidus_o
    "Nonblocking I/O") and [Nonblocking I/O](ch44.html#nonblocking_i_solidus_o-id1
    "Nonblocking I/O"). If we place a file descriptor in nonblocking mode by enabling
    the `O_NONBLOCK` open file status flag, then an I/O system call that can’t be
    immediately completed returns an error instead of blocking. Nonblocking I/O can
    be employed with pipes, FIFOs, sockets, terminals, pseudoterminals, and some other
    types of devices.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[非阻塞I/O](ch05.html#nonblocking_i_solidus_o "Nonblocking I/O")和[非阻塞I/O](ch44.html#nonblocking_i_solidus_o-id1
    "Nonblocking I/O")中详细描述了非阻塞I/O。如果我们通过启用`O_NONBLOCK`打开文件状态标志将文件描述符设置为非阻塞模式，那么一个无法立即完成的I/O系统调用会返回错误，而不是阻塞。非阻塞I/O可以用于管道、FIFO、套接字、终端、伪终端和其他一些类型的设备。
- en: Nonblocking I/O allows us to periodically check (“poll”) whether I/O is possible
    on a file descriptor. For example, we can make an input file descriptor nonblocking,
    and then periodically perform nonblocking reads. If we need to monitor multiple
    file descriptors, then we mark them all nonblocking, and poll each of them in
    turn. However, polling in this manner is usually undesirable. If polling is done
    only infrequently, then the latency before an application responds to an I/O event
    may be unacceptably long; on the other hand, polling in a tight loop wastes CPU
    time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞 I/O 允许我们定期检查（“轮询”）某个文件描述符是否可以执行 I/O 操作。例如，我们可以将一个输入文件描述符设置为非阻塞，然后定期进行非阻塞读取。如果我们需要监视多个文件描述符，那么可以将它们都设置为非阻塞，并依次轮询每个文件描述符。然而，以这种方式进行轮询通常是不可取的。如果轮询的频率太低，那么应用程序响应
    I/O 事件的延迟可能会过长；另一方面，紧密的轮询循环会浪费 CPU 时间。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, we use the word *poll* in two distinct ways. One of these is
    as the name of the I/O multiplexing system call, *poll()*. In the other use, we
    mean “performing a nonblocking check on the status of a file descriptor.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 *poll* 一词有两种不同的含义。其中一种是作为 I/O 多路复用系统调用的名称，即 *poll()*。另一种意思是“执行一个非阻塞的文件描述符状态检查”。
- en: If we don’t want a process to block when performing I/O on a file descriptor,
    we can instead create a new process to perform the I/O. The parent process can
    then carry on to perform other tasks, while the child process blocks until the
    I/O is complete. If we need to handle I/O on multiple file descriptors, we can
    create one child for each descriptor. The problems with this approach are expense
    and complexity. Creating and maintaining processes places a load on the system,
    and, typically, the child processes will need to use some form of IPC to inform
    the parent about the status of I/O operations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望进程在执行文件描述符的 I/O 操作时被阻塞，我们可以创建一个新的进程来执行 I/O 操作。父进程可以继续执行其他任务，而子进程则阻塞直到
    I/O 操作完成。如果我们需要处理多个文件描述符的 I/O 操作，我们可以为每个描述符创建一个子进程。此方法的问题是代价高昂且复杂。创建和维护进程会对系统造成负担，通常，子进程需要使用某种形式的进程间通信（IPC）来通知父进程
    I/O 操作的状态。
- en: Using multiple threads instead of processes is less demanding of resources,
    but the threads will probably still need to communicate information to one another
    about the status of I/O operations, and the programming can be complex, especially
    if we are using thread pools to minimize the number of threads used to handle
    large numbers of simultaneous clients. (One place where threads can be particularly
    useful is if the application needs to call a third-party library that performs
    blocking I/O. An application can avoid blocking in this case by making the library
    call in a separate thread.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个线程而不是进程对资源的需求较低，但线程之间可能仍然需要相互传递有关 I/O 操作状态的信息，且编程可能会很复杂，尤其是在使用线程池来最小化处理大量同时连接的线程数量时。（线程特别有用的一个场景是，当应用程序需要调用一个执行阻塞
    I/O 的第三方库时。在这种情况下，应用程序可以通过在单独的线程中进行库调用来避免阻塞。）
- en: 'Because of the limitations of both nonblocking I/O and the use of multiple
    threads or processes, one of the following alternatives is often preferable:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于非阻塞 I/O 和使用多个线程或进程的局限性，以下替代方案之一通常是更为可取的：
- en: '*I/O multiplexing* allows a process to simultaneously monitor multiple file
    descriptors to find out whether I/O is possible on any of them. The *select()*
    and *poll()* system calls perform I/O multiplexing.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*I/O 多路复用* 允许进程同时监控多个文件描述符，以确定是否可以在其中任何一个上执行 I/O 操作。*select()* 和 *poll()* 系统调用执行
    I/O 多路复用。'
- en: '*Signal-driven I/O* is a technique whereby a process requests that the kernel
    send it a signal when input is available or data can be written on a specified
    file descriptor. The process can then carry on performing other activities, and
    is notified when I/O becomes possible via receipt of the signal. When monitoring
    large numbers of file descriptors, signal-driven I/O provides significantly better
    performance than *select()* and *poll()*.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信号驱动的 I/O* 是一种技术，其中进程请求内核在输入可用或可以在指定的文件描述符上写入数据时发送信号给它。进程可以继续执行其他操作，并在通过接收到信号时被通知
    I/O 操作已可进行。在监视大量文件描述符时，信号驱动的 I/O 比 *select()* 和 *poll()* 提供显著更好的性能。'
- en: The *epoll* API is a Linux-specific feature that first appeared in Linux 2.6\.
    Like the I/O multiplexing APIs, the *epoll* API allows a process to monitor multiple
    file descriptors to see if I/O is possible on any of them. Like signal-driven
    I/O, the *epoll* API provides much better performance when monitoring large numbers
    of file descriptors.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*epoll* API 是一个 Linux 特有的功能，首次出现在 Linux 2.6 中。与 I/O 多路复用 API 类似，*epoll* API
    允许进程监视多个文件描述符，查看是否可以在其中任何一个上执行 I/O。与信号驱动 I/O 类似，*epoll* API 在监视大量文件描述符时提供了更好的性能。'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the remainder of this chapter, we’ll generally frame the discussion of the
    above techniques in terms of processes. However, these techniques can also be
    employed in multithreaded applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将通常从进程的角度框定上述技术的讨论。然而，这些技术也可以应用于多线程应用程序。
- en: In effect, I/O multiplexing, signal-driven I/O, and *epoll* are all methods
    of achieving the same result—monitoring one or, commonly, several file descriptors
    simultaneously to see if they are *ready* to perform I/O (to be precise, to see
    whether an I/O system call could be performed without blocking). The transition
    of a file descriptor into a ready state is triggered by some type of I/O *event*,
    such as the arrival of input, the completion of a socket connection, or the availability
    of space in a previously full socket send buffer after TCP transmits queued data
    to the socket peer. Monitoring multiple file descriptors is useful in applications
    such as network servers that must simultaneously monitor multiple client sockets,
    or applications that must simultaneously monitor input from a terminal and a pipe
    or socket.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，I/O 多路复用、信号驱动 I/O 和 *epoll* 都是实现相同结果的方法——同时监视一个或多个文件描述符，以查看它们是否*准备好*执行 I/O（准确地说，是查看是否可以在不阻塞的情况下执行
    I/O 系统调用）。文件描述符进入就绪状态的转换是由某种类型的 I/O *事件*触发的，例如输入的到来、套接字连接的完成，或者在 TCP 将排队的数据传输到套接字对端后，先前满的套接字发送缓冲区中空间的可用性。监视多个文件描述符在某些应用中非常有用，例如网络服务器必须同时监视多个客户端套接字，或必须同时监视来自终端和管道或套接字的输入的应用。
- en: Note that none of these techniques performs I/O. They merely tell us that a
    file descriptor is ready. Some other system call must then be used to actually
    perform the I/O.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些技术都不执行 I/O 操作。它们只是告诉我们某个文件描述符已经就绪。然后必须使用其他系统调用来实际执行 I/O。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One I/O model that we don’t describe in this chapter is POSIX asynchronous I/O
    (AIO). POSIX AIO allows a process to queue an I/O operation to a file and then
    later be notified when the operation is complete. The advantage of POSIX AIO is
    that the initial I/O call returns immediately, so that the process is not tied
    up waiting for data to be transferred to the kernel or for the operation to complete.
    This allows the process to perform other tasks in parallel with the I/O (which
    may include queuing further I/O requests). For certain types of applications,
    POSIX AIO can provide useful performance benefits. Currently, Linux provides a
    threads-based implementation of POSIX AIO within *glibc*. At the time of writing,
    work is ongoing toward providing an in-kernel implementation of POSIX AIO, which
    should provide better scaling performance. POSIX AIO is described in [Gallmeister,
    1995], [Robbins & Robbins, 2003], and the *aio(7)* manual page.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有描述的一种 I/O 模型是 POSIX 异步 I/O（AIO）。POSIX AIO 允许进程将 I/O 操作排队到一个文件，然后在操作完成时得到通知。POSIX
    AIO 的优势在于初始的 I/O 调用会立即返回，因此进程不会被挂起等待数据传输到内核或操作完成。这使得进程能够在执行 I/O 的同时执行其他任务（这可能包括排队进一步的
    I/O 请求）。对于某些类型的应用，POSIX AIO 可以提供有用的性能优势。目前，Linux 在 *glibc* 中提供了基于线程的 POSIX AIO
    实现。在写作时，正在进行中的工作是提供内核中的 POSIX AIO 实现，这应该能提供更好的扩展性能。POSIX AIO 在 [Gallmeister, 1995]、[Robbins
    & Robbins, 2003] 和 *aio(7)* 手册页面中有描述。
- en: Which technique?
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择哪种技术？
- en: 'During the course of this chapter, we’ll consider the reasons we may choose
    one of these techniques rather than another. In the meantime, we summarize a few
    points:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑选择某种技术而非其他技术的原因。与此同时，我们总结了几个要点：
- en: The *select()* and *poll()* system calls are long-standing interfaces that have
    been present on UNIX systems for many years. Compared to the other techniques,
    their primary advantage is portability. Their main disadvantage is that they don’t
    scale well when monitoring large numbers (hundreds or thousands) of file descriptors.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*select()* 和 *poll()* 系统调用是长期存在的接口，在 UNIX 系统上已存在多年。与其他技术相比，它们的主要优点是可移植性。它们的主要缺点是，当监控大量（数百或数千）文件描述符时，扩展性较差。'
- en: The key advantage of the *epoll* API is that it allows an application to efficiently
    monitor large numbers of file descriptors. Its primary disadvantage is that it
    is a Linux-specific API.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*epoll* API 的主要优点是它允许应用程序高效地监控大量文件描述符。它的主要缺点是它是一个 Linux 特有的 API。'
- en: Note
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some other UNIX implementations provide (nonstandard) mechanisms similar to
    *epoll*. For example, Solaris provides the special `/dev/poll` file (described
    in the Solaris *poll(7d)* manual page), and some of the BSDs provide the *kqueue*
    API (which provides a more general-purpose monitoring facility than *epoll*).
    [Stevens et al., 2004] briefly describes these two mechanisms; a longer discussion
    of *kqueue* can be found in [Lemon, 2001].
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他一些 UNIX 实现提供了类似于 *epoll* 的（非标准）机制。例如，Solaris 提供了特殊的 `/dev/poll` 文件（详见 Solaris
    *poll(7d)* 手册页），一些 BSD 系统提供了 *kqueue* API（该 API 提供了比 *epoll* 更通用的监控功能）。[Stevens
    等人，2004] 简要描述了这两种机制；关于 *kqueue* 的更详细讨论可以在 [Lemon, 2001] 中找到。
- en: 'Like *epoll*, signal-driven I/O allows an application to efficiently monitor
    large numbers of file descriptors. However, *epoll* provides a number of advantages
    over signal-driven I/O:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 *epoll* 类似，信号驱动 I/O 也允许应用程序高效地监控大量文件描述符。然而，*epoll* 提供了比信号驱动 I/O 更多的优点：
- en: We avoid the complexities of dealing with signals.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们避免了处理信号的复杂性。
- en: We can specify the kind of monitoring that we want to perform (e.g., ready for
    reading or ready for writing).
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以指定希望执行的监控类型（例如，准备好读取或准备好写入）。
- en: We can select either level-triggered or edge-triggered notification (described
    in [Which technique?](ch63.html#which_technique_question-id1 "Which technique?")).
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以选择级别触发或边缘触发通知（详见[哪种技术？](ch63.html#which_technique_question-id1 "Which technique?")）。
- en: Furthermore, taking full advantage of signal-driven I/O requires the use of
    nonportable, Linux-specific features, and if we do this, signal-driven I/O is
    no more portable than *epoll*.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，充分利用信号驱动 I/O 需要使用不可移植的 Linux 特有功能，如果我们这样做，信号驱动 I/O 的可移植性与 *epoll* 一样差。
- en: Because, on the one hand, *select()* and *poll()* are more portable, while signal-driven
    I/O and *epoll* deliver better performance, for some applications, it can be worthwhile
    writing an abstract software layer for monitoring file descriptor events. With
    such a layer, portable programs can employ *epoll* (or a similar API) on systems
    that provide it, and fall back to the use of *select()* or *poll()* on other systems.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 *select()* 和 *poll()* 更具可移植性，而信号驱动 I/O 和 *epoll* 提供了更好的性能，对于某些应用程序，编写一个抽象的软件层来监控文件描述符事件是值得的。有了这样的层，便携式程序可以在提供
    *epoll*（或类似 API）的系统上使用它，并在其他系统上回退到使用 *select()* 或 *poll()*。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The *libevent* library is a software layer that provides an abstraction for
    monitoring file descriptor events. It has been ported to a number of UNIX systems.
    As its underlying mechanism, *libevent* can (transparently) employ any of the
    techniques described in this chapter: *select()*, *poll()*, signal-driven I/O,
    or *epoll*, as well as the Solaris specific `/dev/poll` interface or the BSD *kqueue*
    interface. (Thus, *libevent* also serves as an example of how to use each of these
    techniques.) Written by Niels Provos, *libevent* is available at [http://monkey.org/~provos/libevent/](http://monkey.org/~provos/libevent/).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*libevent* 库是一个软件层，提供了一个监控文件描述符事件的抽象。它已移植到多个 UNIX 系统。作为其底层机制，*libevent* 可以（透明地）使用本章中描述的任何技术：*select()*、*poll()*、信号驱动
    I/O 或 *epoll*，以及 Solaris 特有的 `/dev/poll` 接口或 BSD 的 *kqueue* 接口。（因此，*libevent*
    也作为如何使用这些技术的示例。）由 Niels Provos 编写，*libevent* 可在 [http://monkey.org/~provos/libevent/](http://monkey.org/~provos/libevent/)
    获得。'
- en: Level-Triggered and Edge-Triggered Notification
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 级别触发与边缘触发通知
- en: 'Before discussing the various alternative I/O mechanisms in detail, we need
    to distinguish two models of readiness notification for a file descriptor:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细讨论各种替代 I/O 机制之前，我们需要区分两种文件描述符就绪通知模型：
- en: '*Level-triggered notification*: A file descriptor is considered to be ready
    if it is possible to perform an I/O system call without blocking.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等级触发通知*：如果能够执行 I/O 系统调用而不阻塞，则认为文件描述符已准备好。'
- en: '*Edge-triggered notification*: Notification is provided if there is I/O activity
    (e.g., new input) on a file descriptor since it was last monitored.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*边缘触发通知*：如果自上次监控以来文件描述符上发生了 I/O 活动（例如，有新的输入），则会提供通知。'
- en: '[Table 63-1](ch63.html#use_of_level-triggered_and_edge-triggere "Table 63-1. Use
    of level-triggered and edge-triggered notification models") summarizes the notification
    models employed by I/O multiplexing, signal-driven I/O, and *epoll*. The *epoll*
    API differs from the other two I/O models in that it can employ both level-triggered
    notification (the default) and edge-triggered notification.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 63-1](ch63.html#use_of_level-triggered_and_edge-triggere "表 63-1. 使用等级触发和边缘触发通知模型")
    总结了 I/O 多路复用、信号驱动 I/O 和 *epoll* 所采用的通知模型。与其他两种 I/O 模型不同，*epoll* API 可以同时使用等级触发通知（默认）和边缘触发通知。'
- en: Table 63-1. Use of level-triggered and edge-triggered notification models
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表 63-1. 使用等级触发和边缘触发通知模型
- en: '| I/O model | Level-triggered? | Edge-triggered? |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| I/O 模型 | 等级触发？ | 边缘触发？ |'
- en: '| --- | --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *select()*, *poll()* | • |   |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| *select()*, *poll()* | • |   |'
- en: '| Signal-driven I/O |   | • |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 信号驱动的 I/O |   | • |'
- en: '| *epoll* | • | • |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| *epoll* | • | • |'
- en: Details of the differences between these two notification models will become
    clearer during the course of the chapter. For now, we describe how the choice
    of notification model affects the way we design a program.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种通知模型之间的差异将在本章过程中变得更加清晰。现在，我们先描述通知模型的选择如何影响程序设计。
- en: When we employ level-triggered notification, we can check the readiness of a
    file descriptor at any time. This means that when we determine that a file descriptor
    is ready (e.g., it has input available), we can perform some I/O on the descriptor,
    and then repeat the monitoring operation to check if the descriptor is still ready
    (e.g., it still has more input available), in which case we can perform more I/O,
    and so on. In other words, because the level-triggered model allows us to repeat
    the I/O monitoring operation at any time, it is not necessary to perform as much
    I/O as possible (e.g., read as many bytes as possible) on the file descriptor
    (or even perform any I/O at all) each time we are notified that a file descriptor
    is ready.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用等级触发通知时，可以随时检查文件描述符的准备情况。这意味着，当我们确认文件描述符已准备好（例如，有可用输入）时，可以对该描述符执行某些 I/O
    操作，然后重复监控操作，检查描述符是否仍然准备好（例如，仍然有更多输入可用），此时我们可以执行更多 I/O，依此类推。换句话说，由于等级触发模型允许我们随时重复进行
    I/O 监控操作，因此每次收到文件描述符准备就绪的通知时，不需要尽可能多地执行 I/O 操作（例如，读取尽可能多的字节），甚至可以不执行任何 I/O 操作。
- en: 'By contrast, when we employ edge-triggered notification, we receive notification
    only when an I/O event occurs. We don’t receive any further notification until
    another I/O event occurs. Furthermore, when an I/O event is notified for a file
    descriptor, we usually don’t know how much I/O is possible (e.g., how many bytes
    are available for reading). Therefore, programs that employ edge-triggered notification
    are usually designed according to the following rules:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，当我们使用边缘触发通知时，只有在发生 I/O 事件时才会收到通知。在另一个 I/O 事件发生之前，我们不会收到进一步的通知。此外，当某个文件描述符的
    I/O 事件被通知时，我们通常不知道可能进行多少 I/O 操作（例如，有多少字节可以读取）。因此，使用边缘触发通知的程序通常遵循以下规则进行设计：
- en: After notification of an I/O event, the program should—at some point—perform
    as much I/O as possible (e.g., read as many bytes as possible) on the corresponding
    file descriptor. If the program fails to do this, then it might miss the opportunity
    to perform some I/O, because it would not be aware of the need to operate on the
    file descriptor until another I/O event occurred. This could lead to spurious
    data loss or blockages in a program. We said “at some point,” because sometimes
    it may not be desirable to perform all of the I/O immediately after we determine
    that the file descriptor is ready. The problem is that we may starve other file
    descriptors of attention if we perform a large amount of I/O on one file descriptor.
    We consider this point in more detail when we describe the edge-triggered notification
    model for *epoll* in [Edge-Triggered Notification](ch63.html#edge-triggered_notification
    "Edge-Triggered Notification").
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在收到 I/O 事件通知后，程序应该在某个时刻对相应的文件描述符执行尽可能多的 I/O 操作（例如，尽可能多地读取字节）。如果程序未能做到这一点，那么它可能会错过执行某些
    I/O 的机会，因为直到发生另一个 I/O 事件，它才会意识到需要对文件描述符进行操作。这可能导致程序中的虚假数据丢失或阻塞。我们说“在某个时刻”，因为有时在确认文件描述符已准备好后，立即执行所有
    I/O 操作并不一定是理想的。问题在于，如果我们对一个文件描述符执行大量 I/O 操作，可能会使其他文件描述符得不到足够的关注。我们在描述 *epoll*
    的边缘触发通知模型时，会更详细地考虑这一点，见 [Edge-Triggered Notification](ch63.html#edge-triggered_notification
    "Edge-Triggered Notification")。
- en: If the program employs a loop to perform as much I/O as possible on the file
    descriptor, and the descriptor is marked as blocking, then eventually an I/O system
    call will block when no more I/O is possible. For this reason, each monitored
    file descriptor is normally placed in nonblocking mode, and after notification
    of an I/O event, I/O operations are performed repeatedly until the relevant system
    call (e.g., *read()* or *write()*) fails with the error `EAGAIN` or `EWOULDBLOCK`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果程序使用循环来尽可能多地在文件描述符上执行 I/O 操作，而描述符被标记为阻塞，那么最终在没有更多 I/O 可执行时，I/O 系统调用将会阻塞。出于这个原因，每个监视的文件描述符通常会被设置为非阻塞模式，在收到
    I/O 事件通知后，会重复执行 I/O 操作，直到相关的系统调用（例如，*read()* 或 *write()*）由于错误 `EAGAIN` 或 `EWOULDBLOCK`
    而失败。
- en: Employing Nonblocking I/O with Alternative I/O Models
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用非阻塞 I/O 与其他 I/O 模型
- en: 'Nonblocking I/O (the `O_NONBLOCK` flag) is often used in conjunction with the
    I/O models described in this chapter. Some examples of why this can be useful
    are the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞 I/O（`O_NONBLOCK` 标志）通常与本章描述的 I/O 模型一起使用。以下是一些此方式可能有用的示例：
- en: As explained in the previous section, nonblocking I/O is usually employed in
    conjunction with I/O models that provide edge-triggered notification of I/O events.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如上一节所述，非阻塞 I/O 通常与提供边缘触发 I/O 事件通知的 I/O 模型一起使用。
- en: If multiple processes (or threads) are performing I/O on the same open file
    descriptions, then, from a particular process’s point of view, a descriptor’s
    readiness may change between the time the descriptor was notified as being ready
    and the time of the subsequent I/O call. Consequently, a blocking I/O call could
    block, thus preventing the process from monitoring other file descriptors. (This
    can occur for all of the I/O models that we describe in this chapter, regardless
    of whether they employ level-triggered or edge-triggered notification.)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果多个进程（或线程）在同一打开的文件描述符上执行 I/O 操作，那么从某个特定进程的角度来看，文件描述符的就绪状态可能会在描述符被通知为就绪和随后的
    I/O 调用之间发生变化。因此，一个阻塞的 I/O 调用可能会阻塞，进而阻止该进程监视其他文件描述符。（这种情况可能发生在我们本章描述的所有 I/O 模型中，无论它们是否使用了水平触发或边缘触发通知。）
- en: Even after a level-triggered API such as *select()* or *poll()* informs us that
    a file descriptor for a stream socket is ready for writing, if we write a large
    enough block of data in a single *write()* or *send()*, then the call will nevertheless
    block.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在像 *select()* 或 *poll()* 这样的水平触发 API 告知我们流套接字的文件描述符已准备好写入后，如果我们在单个 *write()*
    或 *send()* 中写入足够大的数据块，那么调用仍然会阻塞。
- en: In rare cases, level-triggered APIs such as *select()* and *poll()* can return
    spurious readiness notifications—they can falsely inform us that a file descriptor
    is ready. This could be caused by a kernel bug or be expected behavior in an uncommon
    scenario.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在少数情况下，像 *select()* 和 *poll()* 这样的水平触发 API 可能会返回虚假的就绪通知——它们可能错误地告知我们某个文件描述符已经准备就绪。这可能是由内核漏洞引起的，或者是某种不常见情境下的预期行为。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Section 16.6 of [Stevens et al., 2004] describes one example of spurious readiness
    notifications on BSD systems for a listening socket. If a client connects to a
    server’s listening socket and then resets the connection, a *select()* performed
    by the server between these two events will indicate the listening socket as being
    readable, but a subsequent *accept()* that is performed after the client’s reset
    will block.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[Stevens 等人，2004年] 的第16.6节描述了在 BSD 系统上监听套接字出现虚假就绪通知的一个例子。如果客户端连接到服务器的监听套接字并且随后重置连接，服务器在这两个事件之间执行的
    *select()* 会将监听套接字标记为可读，但在客户端重置之后执行的 *accept()* 将会阻塞。'
- en: I/O Multiplexing
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O 多路复用
- en: I/O multiplexing allows us to simultaneously monitor multiple file descriptors
    to see if I/O is possible on any of them. We can perform I/O multiplexing using
    either of two system calls with essentially the same functionality. The first
    of these, *select()*, appeared along with the sockets API in BSD. This was historically
    the more widespread of the two system calls. The other system call, *poll()*,
    appeared in System V. Both *select()* and *poll()* are nowadays required by SUSv3.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 多路复用允许我们同时监视多个文件描述符，以查看是否可以在其中任何一个上进行 I/O。我们可以通过两种系统调用来执行 I/O 多路复用，它们具有基本相同的功能。这两个系统调用中的第一个是
    *select()*，它与 BSD 中的套接字 API 一起出现。历史上，这是这两个系统调用中使用更广泛的一个。另一个系统调用是 *poll()*，它出现在
    System V 中。如今，*select()* 和 *poll()* 都是 SUSv3 的要求。
- en: We can use *select()* and *poll()* to monitor file descriptors for regular files,
    terminals, pseudoterminals, pipes, FIFOs, sockets, and some types of character
    devices. Both system calls allow a process either to block indefinitely waiting
    for file descriptors to become ready or to specify a timeout on the call.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 *select()* 和 *poll()* 来监视常规文件、终端、伪终端、管道、FIFOs、套接字以及一些字符设备类型的文件描述符。这两个系统调用允许进程要么无限期阻塞，等待文件描述符变为就绪，要么指定一个超时时间。
- en: The *select()* System Call
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*select()* 系统调用'
- en: The *select()* system call blocks until one or more of a set of file descriptors
    becomes ready.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*select()* 系统调用会阻塞，直到一组文件描述符中的一个或多个变为就绪。'
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of ready file descriptors, 0 on timeout, or -1 on error
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 返回已就绪文件描述符的数量，超时时返回 0，错误时返回 -1
- en: The *nfds*, *readfds*, *writefds*, and *exceptfds* arguments specify the file
    descriptors that *select()* is to monitor. The *timeout* argument can be used
    to set an upper limit on the time for which *select()* will block. We describe
    each of these arguments in detail below.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*nfds*、*readfds*、*writefds* 和 *exceptfds* 参数指定了 *select()* 要监视的文件描述符。*timeout*
    参数可用于设置 *select()* 阻塞的最大时间。我们将在下面详细描述这些参数。'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the prototype for *select()* shown above, we include `<sys/time.h>` because
    that was the header specified in SUSv2, and some UNIX implementations require
    this header. (The `<sys/time.h>` header is present on Linux, and including it
    does no harm.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面展示的 *select()* 原型中，我们包含了 `<sys/time.h>` 头文件，因为这是 SUSv2 中指定的头文件，而且一些 UNIX
    实现要求包含此头文件。（在 Linux 上，`<sys/time.h>` 头文件是存在的，包含它并不会有任何不良影响。）
- en: File descriptor sets
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件描述符集合
- en: 'The *readfds*, *writefds*, and *exceptfds* arguments are pointers to *file
    descriptor sets*, represented using the data type *fd_set*. These arguments are
    used as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*readfds*、*writefds* 和 *exceptfds* 参数是指向 *文件描述符集合* 的指针，使用 *fd_set* 数据类型表示。这些参数的使用方式如下：'
- en: '*readfds* is the set of file descriptors to be tested to see if input is possible;'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*readfds* 是用于测试是否可以进行输入的文件描述符集合；'
- en: '*writefds* is the set of file descriptors to be tested to see if output is
    possible; and'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*writefds* 是用于测试是否可以进行输出的文件描述符集合；'
- en: '*exceptfds* is the set of file descriptors to be tested to see if an exceptional
    condition has occurred.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*exceptfds* 是用于测试文件描述符集合，以检查是否发生了异常情况。'
- en: 'The term *exceptional condition* is often misunderstood to mean that some sort
    of error condition has arisen on the file descriptor. This is not the case. An
    exceptional condition occurs in just two circumstances on Linux (other UNIX implementations
    are similar):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常情况* 这个术语通常被误解为表示文件描述符上发生了某种错误情况。实际上并非如此。在 Linux 中（其他 UNIX 实现也类似），异常情况仅在两种情况下发生：'
- en: A state change occurs on a pseudoterminal slave connected to a master that is
    in packet mode (Section 64.5).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当伪终端从属设备连接到处于数据包模式下的主设备时，会发生状态变化（参见第64.5节）。
- en: Out-of-band data is received on a stream socket ([Out-of-Band Data](ch61.html#out-of-band_data
    "Out-of-Band Data")).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带外数据通过流套接字接收（[带外数据](ch61.html#out-of-band_data "带外数据")）。
- en: 'Typically, the *fd_set* data type is implemented as a bit mask. However, we
    don’t need to know the details, since all manipulation of file descriptor sets
    is done via four macros: `FD_ZERO()`, `FD_SET()`, `FD_CLR()`, and `FD_ISSET()`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*fd_set*数据类型实现为位掩码。然而，我们无需了解细节，因为所有文件描述符集的操作都是通过四个宏完成的：`FD_ZERO()`、`FD_SET()`、`FD_CLR()`和`FD_ISSET()`。
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns true (1) if *fd* is in *fdset*, or false (0) otherwise
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*fd*在*fdset*中，返回true（1），否则返回false（0）。
- en: 'These macros operate as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏的操作方式如下：
- en: '`FD_ZERO()` initializes the set pointed to by *fdset* to be empty.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FD_ZERO()`将由*fdset*指向的集合初始化为空。'
- en: '`FD_SET()` adds the file descriptor *fd* to the set pointed to by *fdset*.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FD_SET()`将文件描述符*fd*添加到由*fdset*指向的集合中。'
- en: '`FD_CLR()` removes the file descriptor *fd* from the set pointed to by *fdset*.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FD_CLR()`从由*fdset*指向的集合中移除文件描述符*fd*。'
- en: '`FD_ISSET()` returns true if the file descriptor *fd* is a member of the set
    pointed to by *fdset*.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FD_ISSET()`返回true，如果文件描述符*fd*是由*fdset*指向的集合的成员。'
- en: A file descriptor set has a maximum size, defined by the constant `FD_SETSIZE`.
    On Linux, this constant has the value 1024\. (Other UNIX implementations have
    similar values for this limit.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符集有一个最大大小，由常量`FD_SETSIZE`定义。在Linux中，这个常量的值为1024。（其他UNIX实现也有类似的值作为此限制。）
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even though the `FD_*` macros are operating on user-space data structures, and
    the kernel implementation of *select()* can handle descriptor sets with larger
    sizes, *glibc* provides no simple way of modifying the definition of `FD_SETSIZE`.
    If we want to change this limit, we must modify the definition in the *glibc*
    header files. However, for reasons that we describe later in this chapter, if
    we need to monitor large numbers of descriptors, then using *epoll* is probably
    preferable to the use of *select()*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`FD_*`宏作用于用户空间数据结构，并且*select()*的内核实现可以处理更大尺寸的描述符集，*glibc*并没有提供一种简单的方式来修改`FD_SETSIZE`的定义。如果我们想要改变这个限制，就必须在*glibc*头文件中修改定义。然而，正如本章后面所描述的那样，如果我们需要监视大量描述符，那么使用*epoll*可能比使用*select()*更合适。
- en: The *readfds*, *writefds*, and *exceptfds* arguments are all value-result. Before
    the call to *select()*, the *fd_set* structures pointed to by these arguments
    must be initialized (using `FD_ZERO()` and `FD_SET()`) to contain the set of file
    descriptors of interest. The *select()* call modifies each of these structures
    so that, on return, they contain the set of file descriptors that are ready. (Since
    these structures are modified by the call, we must ensure that we reinitialize
    them if we are repeatedly calling *select()* from within a loop.) The structures
    can then be examined using `FD_ISSET()`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*readfds*、*writefds*和*exceptfds*参数都是值结果类型。在调用*select()*之前，这些参数指向的*fd_set*结构必须先初始化（使用`FD_ZERO()`和`FD_SET()`），以包含感兴趣的文件描述符集合。*select()*调用会修改这些结构，使得它们在返回时包含就绪的文件描述符集合。（由于这些结构会被调用修改，我们必须确保在循环中重复调用*select()*时重新初始化它们。）然后，可以使用`FD_ISSET()`检查这些结构。'
- en: If we are not interested in a particular class of events, then the corresponding
    *fd_set* argument can be specified as `NULL`. We say more about the precise meaning
    of each of the three event types in [When Is a File Descriptor Ready?](ch63.html#when_is_a_file_descriptor_ready_question
    "When Is a File Descriptor Ready?").
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对某类事件不感兴趣，那么可以将相应的*fd_set*参数指定为`NULL`。关于每种事件类型的具体含义，请参阅[文件描述符何时准备好？](ch63.html#when_is_a_file_descriptor_ready_question
    "文件描述符何时准备好？")。
- en: The *nfds* argument must be set one greater than the highest file descriptor
    number included in any of the three file descriptor sets. This argument allows
    *select()* to be more efficient, since the kernel then knows not to check whether
    file descriptor numbers higher than this value are part of each file descriptor
    set.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*nfds*参数必须设置为比所有三个文件描述符集中的最大文件描述符号大1。这个参数使得*select()*更加高效，因为内核可以知道不需要检查比这个值更高的文件描述符号是否是每个文件描述符集的一部分。'
- en: The *timeout* argument
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*timeout*参数'
- en: 'The *timeout* argument controls the blocking behavior of *select()*. It can
    be specified either as `NULL`, in which case *select()* blocks indefinitely, or
    as a pointer to a *timeval* structure:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*timeout*参数控制*select()*的阻塞行为。它可以指定为`NULL`，在这种情况下，*select()*会无限期地阻塞，或者指定为指向*timeval*结构的指针：'
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If both fields of *timeout* are 0, then *select()* doesn’t block; it simply
    polls the specified file descriptors to see which ones are ready and returns immediately.
    Otherwise, *timeout* specifies an upper limit on the time for which *select()*
    is to wait.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *timeout* 的两个字段都为 0，则 *select()* 不会阻塞；它会立即轮询指定的文件描述符，查看哪些已准备好，并立即返回。否则，*timeout*
    指定了 *select()* 等待的最大时间。
- en: Although the *timeval* structure affords microsecond precision, the accuracy
    of the call is limited by the granularity of the software clock (Section 10.6).
    SUSv3 specifies that the timeout is rounded upward if it is not an exact multiple
    of this granularity.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 *timeval* 结构提供微秒级精度，但调用的准确性受限于软件时钟的粒度（第 10.6 节）。SUSv3 规定，如果超时时间不是该粒度的精确倍数，则超时会向上舍入。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: SUSv3 requires that the maximum permissible timeout interval be at least 31
    days. Most UNIX implementations allow a considerably higher limit. Since Linux/x86-32
    uses a 32-bit integer for the *time_t* type, the upper limit is many years.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 要求最大允许的超时间隔至少为 31 天。大多数 UNIX 实现允许更高的限制。由于 Linux/x86-32 使用 32 位整数表示 *time_t*
    类型，最大限制为多年。
- en: 'When *timeout* is `NULL`, or points to a structure containing nonzero fields,
    *select()* blocks until one of the following occurs:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *timeout* 为 `NULL`，或指向包含非零字段的结构时，*select()* 会阻塞，直到以下情况之一发生：
- en: at least one of the file descriptors specified in *readfds*, *writefds*, or
    *exceptfds* becomes ready;
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*readfds*、*writefds* 或 *exceptfds* 中指定的至少一个文件描述符变为就绪；'
- en: the call is interrupted by a signal handler; or
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用被信号处理程序中断；或
- en: the amount of time specified by *timeout* has passed.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*timeout* 指定的时间已过去。'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: In older UNIX implementations that lacked a sleep call with subsecond precision
    (e.g., *nanosleep()*), *select()* was used to emulate this functionality by specifying
    *nfds* as 0; *readfds*, *writefds*, and *exceptfds* as `NULL`; and the desired
    sleep interval in *timeout*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有子秒精度的睡眠调用的旧版 UNIX 实现中（例如，*nanosleep()*），通过将 *nfds* 设置为 0，*readfds*、*writefds*
    和 *exceptfds* 设置为 `NULL`，以及在 *timeout* 中指定所需的睡眠间隔，*select()* 被用来模拟这一功能。
- en: On Linux, if *select()* returns because one or more file descriptors became
    ready, and if *timeout* was non-`NULL`, then *select()* updates the structure
    to which *timeout* points to indicate how much time remained until the call would
    have timed out. However, this behavior is implementation-specific. SUSv3 also
    allows the possibility that an implementation leaves the structure pointed to
    by *timeout* unchanged, and most other UNIX implementations *don’t* modify this
    structure. Portable applications that employ *select()* within a loop should always
    ensure that the structure pointed to by *timeout* is initialized before each *select()*
    call, and should ignore the information returned in the structure after the call.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，如果 *select()* 返回，因为一个或多个文件描述符已变为就绪，并且 *timeout* 非 `NULL`，则 *select()*
    会更新 *timeout* 所指向的结构体，以指示如果不发生超时，剩余的时间。然而，这种行为是特定实现的。SUSv3 也允许实现可能保持 *timeout*
    所指向的结构体不变，且大多数其他 UNIX 实现**不会**修改该结构体。在循环中使用 *select()* 的可移植应用程序应始终确保在每次调用 *select()*
    之前初始化 *timeout* 所指向的结构体，并在调用后忽略结构体中返回的信息。
- en: SUSv3 states that the structure pointed to by *timeout* may be modified only
    on a successful return from *select()*. However, on Linux, if *select()* is interrupted
    by a signal handler (so that it fails with the error `EINTR`), then the structure
    is modified to indicate the time remaining until a timeout would have occurred
    (i.e., like a successful return).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 规定，*timeout* 所指向的结构体只能在 *select()* 成功返回后进行修改。然而，在 Linux 上，如果 *select()*
    被信号处理程序中断（导致其因错误 `EINTR` 失败），则该结构体会被修改，以指示直到超时发生时剩余的时间（即，像成功返回一样）。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: If we use the Linux-specific *personality()* system call to set a personality
    that includes the `STICKY_TIMEOUTS` personality bit, then *select()* doesn’t modify
    the structure pointed to by *timeout*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 Linux 特有的 *personality()* 系统调用设置包含 `STICKY_TIMEOUTS` 个性位的个性，则 *select()*
    不会修改 *timeout* 所指向的结构体。
- en: Return value from *select()*
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*select()* 的返回值'
- en: 'As its function result, *select()* returns one of the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其函数结果，*select()* 返回以下之一：
- en: A return value of -1 indicates that an error occurred. Possible errors include
    `EBADF` and `EINTR`. `EBADF` indicates that one of the file descriptors in `readfds`,
    *writefds*, or *exceptfds* is invalid (e.g., not currently open). `EINTR`, indicates
    that the call was interrupted by a signal handler. (As noted in Section 21.5,
    *select()* is never automatically restarted if interrupted by a signal handler.)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值为 -1 表示发生了错误。可能的错误包括 `EBADF` 和 `EINTR`。`EBADF` 表示 `readfds`、*writefds* 或
    *exceptfds* 中的一个文件描述符无效（例如，当前未打开）。`EINTR` 表示调用被信号处理程序中断。（如第 21.5 节所述，如果被信号处理程序中断，*select()*
    永远不会自动重新启动。）
- en: A return value of 0 means that the call timed out before any file descriptor
    became ready. In this case, each of the returned file descriptor sets will be
    empty.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值为 0 表示在任何文件描述符变为准备好之前调用已经超时。在这种情况下，每个返回的文件描述符集将为空。
- en: A positive return value indicates that one or more file descriptors is ready.
    The return value is the number of ready descriptors. In this case, each of the
    returned file descriptor sets must be examined (using `FD_ISSET()`) in order to
    find out which I/O events occurred. If the same file descriptor is specified in
    more than one of *readfds*, *writefds*, and *exceptfds*, it is counted multiple
    times if it is ready for more than one event. In other words, *select()* returns
    the total number of file descriptors marked as ready in all three returned sets.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正返回值表示一个或多个文件描述符已经准备好。返回值是已准备好的描述符数量。在这种情况下，必须检查每个返回的文件描述符集（使用`FD_ISSET()`）以找出发生了哪些
    I/O 事件。如果相同的文件描述符在 *readfds*、*writefds* 和 *exceptfds* 中被指定多次，并且它准备好了多个事件，则会被多次计数。换句话说，*select()*
    返回的是在所有三个返回的集合中标记为准备好的文件描述符的总数。
- en: Example program
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: The program in [Example 63-1](ch63.html#using_select_open_parenthesis_close_pare
    "Example 63-1. Using select() to monitor multiple file descriptors") demonstrates
    the use of *select()*. Using command-line arguments, we can specify the *timeout*
    and the file descriptors that we wish to monitor. The first command-line argument
    specifies the *timeout* for *select()*, in seconds. If a hyphen (-) is specified
    here, then *select()* is called with a timeout of `NULL`, meaning block indefinitely.
    Each of the remaining command-line arguments specifies the number of a file descriptor
    to be monitored, followed by letters indicating the operations for which the descriptor
    is to be checked. The letters we can specify here are *r* (ready for read) and
    *w* (ready for write).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 63-1](ch63.html#using_select_open_parenthesis_close_pare "示例 63-1. 使用 select()
    监控多个文件描述符") 中的程序演示了如何使用 *select()*。通过命令行参数，我们可以指定 *超时* 和我们希望监控的文件描述符。第一个命令行参数指定
    *select()* 的 *超时*（单位为秒）。如果在此处指定了一个短横线（-），则表示 *select()* 被调用时的超时值为 `NULL`，即无限期阻塞。其余命令行参数指定了要监控的文件描述符的编号，后面跟着表示要检查的操作的字母。我们可以在这里指定的字母是
    *r*（准备好读取）和 *w*（准备好写入）。'
- en: Example 63-1. Using *select()* to monitor multiple file descriptors
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 63-1. 使用 *select()* 监控多个文件描述符
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the following shell session log, we demonstrate the use of the program in
    [Example 63-1](ch63.html#using_select_open_parenthesis_close_pare "Example 63-1. Using
    select() to monitor multiple file descriptors"). In the first example, we make
    a request to monitor file descriptor 0 for input with a 10-second *timeout*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的 shell 会话日志中，我们演示了在[示例 63-1](ch63.html#using_select_open_parenthesis_close_pare
    "示例 63-1. 使用 select() 监控多个文件描述符")中使用该程序。在第一个示例中，我们请求监控文件描述符 0 的输入，设置 10 秒的 *超时*：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The above output shows us that *select()* determined that one file descriptor
    was ready. This was file descriptor 0, which was ready for reading. We can also
    see that the *timeout* was modified. The final line of output, consisting of just
    the shell `$` prompt, appeared because the *t_select* program didn’t read the
    newline character that made file descriptor 0 ready, and so that character was
    read by the shell, which responded by printing another prompt.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示 *select()* 确定有一个文件描述符已准备好。这个文件描述符是 0，它已准备好读取。我们还可以看到 *超时* 被修改了。最后一行输出仅显示
    shell 的 `$` 提示符，是因为 *t_select* 程序没有读取使文件描述符 0 准备好的换行符，因此该字符被 shell 读取，shell 通过打印另一个提示符来响应。
- en: 'In the next example, we again monitor file descriptor 0 for input, but this
    time with a *timeout* of 0 seconds:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们再次监控文件描述符 0 的输入，但这次设置的 *超时* 为 0 秒：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The *select()* call returned immediately, and found no file descriptor was ready.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*select()* 调用立即返回，并且没有发现任何文件描述符已经准备好。'
- en: 'In the next example, we monitor two file descriptors: descriptor 0, to see
    if input is available, and descriptor 1, to see if output is possible. In this
    case, we specify the *timeout* as `NULL` (the first command-line argument is a
    hyphen), meaning infinity:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们监控两个文件描述符：描述符0，用于查看是否有输入，和描述符1，用于查看是否可以输出。在这种情况下，我们将*timeout*指定为`NULL`（第一个命令行参数是一个破折号），表示无限：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The *select()* call returned immediately, informing us that output was possible
    on file descriptor 1.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*select()*调用立即返回，通知我们文件描述符1上的输出是可能的。'
- en: The *poll()* System Call
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*poll()*系统调用'
- en: The *poll()* system call performs a similar task to *select()*. The major difference
    between the two system calls lies in how we specify the file descriptors to be
    monitored. With *select()*, we provide three sets, each marked to indicate the
    file descriptors of interest. With *poll()*, we provide a list of file descriptors,
    each marked with the set of events of interest.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*poll()*系统调用执行的任务与*select()*类似。这两个系统调用之间的主要区别在于我们如何指定要监控的文件描述符。使用*select()*时，我们提供三个集合，每个集合标记以指示感兴趣的文件描述符。使用*poll()*时，我们提供一个文件描述符列表，每个文件描述符都标记了感兴趣的事件集。'
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of ready file descriptors, 0 on timeout, or -1 on error
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 返回准备就绪的文件描述符数，超时时返回0，出错时返回-1
- en: The *fds* argument and the *pollfd* array (*nfds*) specify the file descriptors
    that *poll()* is to monitor. The *timeout* argument can be used to set an upper
    limit on the time for which *poll()* will block. We describe each of these arguments
    in detail below.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*fds*参数和*pollfd*数组（*nfds*）指定了*poll()*要监控的文件描述符。*timeout*参数可用于设置*poll()*阻塞的最大时间。我们将在下面详细描述这些参数。'
- en: The *pollfd* array
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*pollfd*数组'
- en: 'The *fds* argument lists the file descriptors to be monitored by *poll()*.
    This argument is an array of *pollfd* structures, defined as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*fds*参数列出了*poll()*要监控的文件描述符。这个参数是一个*pollfd*结构体数组，定义如下：'
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The *nfds* arguments specifies the number of items in the *fds* array. The *nfds_t*
    data type used to type the *nfds* argument is an unsigned integer type.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*nfds*参数指定*fds*数组中的项数。用于类型化*nfds*参数的*nfds_t*数据类型是无符号整数类型。'
- en: The *events* and *revents* fields of the *pollfd* structure are bit masks. The
    caller initializes *events* to specify the events to be monitored for the file
    descriptor *fd*. Upon return from *poll()*, *revents* is set to indicate which
    of those events actually occurred for this file descriptor.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*pollfd*结构的*events*和*revents*字段是位掩码。调用者初始化*events*以指定要监控的文件描述符*fd*的事件。在从*poll()*返回时，*revents*被设置以指示此文件描述符上实际发生的事件。'
- en: '[Table 63-2](ch63.html#bit-mask_values_for_events_and_revents_f "Table 63-2. Bit-mask
    values for events and revents fields of the pollfd structure") lists the bits
    that may appear in the *events* and *revents* fields. The first group of bits
    in this table (`POLLIN`, `POLLRDNORM`, `POLLRDBAND`, `POLLPRI`, and `POLLRDHUP`)
    are concerned with input events. The next group of bits (`POLLOUT`, `POLLWRNORM`,
    and `POLLWRBAND`) are concerned with output events. The third group of bits (`POLLERR`,
    `POLLHUP`, and `POLLNVAL`) are set in the *revents* field to return additional
    information about the file descriptor. If specified in the *events* field, these
    three bits are ignored. The final bit (`POLLMSG`) is unused by *poll()* on Linux.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[表63-2](ch63.html#bit-mask_values_for_events_and_revents_f "表63-2. pollfd结构的events和revents字段的位掩码值")列出了可能出现在*events*和*revents*字段中的位。表中的第一组位（`POLLIN`，`POLLRDNORM`，`POLLRDBAND`，`POLLPRI`和`POLLRDHUP`）与输入事件有关。接下来的位（`POLLOUT`，`POLLWRNORM`和`POLLWRBAND`）与输出事件有关。第三组位（`POLLERR`，`POLLHUP`和`POLLNVAL`）在*revents*字段中设置，用于返回有关文件描述符的附加信息。如果在*events*字段中指定，这三个位将被忽略。最后一个位（`POLLMSG`）在Linux中不被*poll()*使用。'
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On UNIX implementations providing STREAMS devices, `POLLMSG` indicates that
    a message containing a `SIGPOLL` signal has reached the head of the stream. `POLLMSG`
    is unused on Linux, because Linux doesn’t implement STREAMS.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供STREAMS设备的UNIX实现中，`POLLMSG`表示包含`SIGPOLL`信号的消息已到达流的头部。`POLLMSG`在Linux中未使用，因为Linux不实现STREAMS。
- en: Table 63-2. Bit-mask values for *events* and *revents* fields of the *pollfd*
    structure
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 表63-2. *pollfd*结构的*events*和*revents*字段的位掩码值
- en: '| Bit | Input in *events*? | Returned in *revents*? | Description |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 位 | *events*中输入？ | 在*revents*中返回？ | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `POLLIN` | • | • | Data other than high-priority data can be read |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `POLLIN` | • | • | 可以读取除高优先级数据之外的数据 |'
- en: '| `POLLRDNORM` | • | • | Equivalent to `POLLIN` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `POLLRDNORM` | • | • | 等同于`POLLIN` |'
- en: '| `POLLRDBAND` | • | • | Priority data can be read (unused on Linux) |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `POLLRDBAND` | • | • | 可以读取优先数据（在Linux上未使用） |'
- en: '| `POLLPRI` | • | • | High-priority data can be read |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `POLLPRI` | • | • | 可以读取高优先级数据 |'
- en: '| `POLLRDHUP` | • | • | Shutdown on peer socket |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `POLLRDHUP` | • | • | 对等方套接字关闭 |'
- en: '| `POLLOUT` | • | • | Normal data can be written |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `POLLOUT` | • | • | 可以写入正常数据 |'
- en: '| `POLLWRNORM` | • | • | Equivalent to `POLLOUT` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `POLLWRNORM` | • | • | 等同于`POLLOUT` |'
- en: '| `POLLWRBAND` | • | • | Priority data can be written |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `POLLWRBAND` | • | • | 可以写入优先数据 |'
- en: '| `POLLERR` |   | • | An error has occurred |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `POLLERR` |   | • | 发生了错误 |'
- en: '| `POLLHUP` |   | • | A hangup has occurred |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `POLLHUP` |   | • | 发生了挂起 |'
- en: '| `POLLNVAL` |   | • | File descriptor is not open |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `POLLNVAL` |   | • | 文件描述符未打开 |'
- en: '| `POLLMSG` |   |   | Unused on Linux (and unspecified in SUSv3) |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `POLLMSG` |   |   | 在Linux上未使用（在SUSv3中未指定） |'
- en: It is permissible to specify *events* as 0 if we are not interested in events
    on a particular file descriptor. Furthermore, specifying a negative value for
    the *fd* field (e.g., negating its value if nonzero) causes the corresponding
    *events* field to be ignored and the *revents* field always to be returned as
    0\. Either of these techniques can be used to (perhaps temporarily) disable monitoring
    of a single file descriptor, without needing to rebuild the entire *fds* list.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对特定文件描述符的事件不感兴趣，可以将*events*指定为0。此外，指定负值给*fd*字段（例如，如果非零则取其相反值）会导致对应的*events*字段被忽略，并且*revents*字段始终返回为0。可以使用这些技术（或许是暂时的）禁用单个文件描述符的监视，而不需要重新构建整个*fds*列表。
- en: 'Note the following further points regarding the Linux implementation of *poll()*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下有关Linux实现*poll()*的进一步要点：
- en: Although defined as separate bits, `POLLIN` and `POLLRDNORM` are synonymous.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管被定义为单独的位，`POLLIN`和`POLLRDNORM`是同义的。
- en: Although defined as separate bits, `POLLOUT` and `POLLWRNORM` are synonymous.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管被定义为单独的位，`POLLOUT`和`POLLWRNORM`是同义的。
- en: '`POLLRDBAND` is generally unused; that is, it is ignored in the *events* field
    and not set in *revents*.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POLLRDBAND`通常未使用；也就是说，它在*events*字段中被忽略，并且在*revents*中未被设置。'
- en: Note
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: The only place where `POLLRDBAND` is set is in code implementing the (obsolete)
    DECnet networking protocol.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 唯一设置`POLLRDBAND`的地方是在实现（已废弃的）DECnet网络协议的代码中。
- en: Although set for sockets in certain circumstances, `POLLWRBAND` conveys no useful
    information. (There are no circumstances in which `POLLWRBAND` is set when `POLLOUT`
    and `POLLWRNORM` are not also set.)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管在某些情况下为套接字设置了`POLLWRBAND`，但它并未传达有用信息。（没有任何情况会在未设置`POLLOUT`和`POLLWRNORM`的情况下设置`POLLWRBAND`。）
- en: Note
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '`POLLRDBAND` and `POLLWRBAND` are meaningful on implementations that provide
    System V STREAMS (which Linux does not). Under STREAMS, a message can be assigned
    a nonzero priority, and such messages are queued to the receiver in decreasing
    order of priority, in a band ahead of normal (priority 0) messages.'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`POLLRDBAND`和`POLLWRBAND`在提供System V STREAMS的实现中有意义（而Linux不支持）。在STREAMS下，一条消息可以被分配一个非零优先级，并且这些消息会按优先级递减的顺序排队到接收者，位于普通（优先级0）消息之前的一个带内。'
- en: The `_XOPEN_SOURCE` feature test macro must be defined in order to obtain the
    definitions of the constants `POLLRDNORM`, `POLLRDBAND`, `POLLWRNORM`, and `POLLWRBAND`
    from `<poll.h>`.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须定义`_XOPEN_SOURCE`特性测试宏，才能从`<poll.h>`中获取常量`POLLRDNORM`、`POLLRDBAND`、`POLLWRNORM`和`POLLWRBAND`的定义。
- en: '`POLLRDHUP` is a Linux-specific flag available since kernel 2.6.17\. In order
    to obtain this definition from `<poll.h>`, the `_GNU_SOURCE` feature test macro
    must be defined.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POLLRDHUP`是一个Linux特定的标志，自内核2.6.17版本起可用。为了从`<poll.h>`中获得该定义，必须定义`_GNU_SOURCE`特性测试宏。'
- en: '`POLLNVAL` is returned if the specified file descriptor was closed at the time
    of the *poll()* call.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在执行*poll()*调用时，指定的文件描述符已关闭，则返回`POLLNVAL`。
- en: Summarizing the above points, the *poll()* flags of real interest are `POLLIN`,
    `POLLOUT`, `POLLPRI`, `POLLRDHUP`, `POLLHUP`, and `POLLERR`. We consider the meanings
    of these flags in greater detail in [When Is a File Descriptor Ready?](ch63.html#when_is_a_file_descriptor_ready_question
    "When Is a File Descriptor Ready?").
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 总结以上要点，真实有意义的*poll()*标志是`POLLIN`、`POLLOUT`、`POLLPRI`、`POLLRDHUP`、`POLLHUP`和`POLLERR`。我们将在[何时文件描述符准备好？](ch63.html#when_is_a_file_descriptor_ready_question
    "何时文件描述符准备好？")中更详细地讨论这些标志的含义。
- en: The *timeout* argument
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*timeout*参数'
- en: 'The *timeout* argument determines the blocking behavior of *poll()* as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*timeout*参数决定了*poll()*的阻塞行为，如下所示：'
- en: If *timeout* equals -1, block until one of the file descriptors listed in the
    *fds* array is ready (as defined by the corresponding *events* field) or a signal
    is caught.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *timeout* 等于 -1，则阻塞直到 *fds* 数组中的某个文件描述符准备好（根据相应的 *events* 字段定义）或捕获到信号。
- en: If *timeout* equals 0, do not block—just perform a check to see which file descriptors
    are ready.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *timeout* 等于 0，则不阻塞——只进行检查，看看哪些文件描述符已经准备好。
- en: If *timeout* is greater than 0, block for up to *timeout* milliseconds, until
    one of the file descriptors in *fds* is ready, or until a signal is caught.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *timeout* 大于 0，则最多阻塞 *timeout* 毫秒，直到 *fds* 中的某个文件描述符准备好，或捕获到信号。
- en: As with *select()*, the accuracy of *timeout* is limited by the granularity
    of the software clock (Section 10.6), and SUSv3 specifies that *timeout* is always
    rounded upward if it is not an exact multiple of the clock granularity.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *select()* 一样，*timeout* 的准确性受到软件时钟粒度的限制（见第 10.6 节），并且 SUSv3 规定，如果 *timeout*
    不是时钟粒度的精确倍数，*timeout* 总是会向上舍入。
- en: Return value from *poll()*
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*poll()*的返回值'
- en: 'As its function result, *poll()* returns one of the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其函数结果，*poll()*返回以下之一：
- en: A return value of -1 indicates that an error occurred. One possible error is
    `EINTR`, indicating that the call was interrupted by a signal handler. (As noted
    in Section 21.5, *poll()* is never automatically restarted if interrupted by a
    signal handler.)
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值为 -1 表示发生了错误。一种可能的错误是 `EINTR`，表示调用被信号处理程序中断。（如第 21.5 节所述，*poll()* 在被信号处理程序中断时从不自动重新启动。）
- en: A return of 0 means that the call timed out before any file descriptor became
    ready.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值为 0 表示调用在任何文件描述符准备好之前已超时。
- en: A positive return value indicates that one or more file descriptors are ready.
    The returned value is the number of *pollfd* structures in the *fds* array that
    have a nonzero *revents* field.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正值返回值表示一个或多个文件描述符已准备好。返回的值是 *fds* 数组中具有非零 *revents* 字段的 *pollfd* 结构体的数量。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the slightly different meaning of a positive return value from *select()*
    and *poll()*. The *select()* system call counts a file descriptor multiple times
    if it occurs in more than one returned file descriptor set. The *poll()* system
    call returns a count of ready file descriptors, and a file descriptor is counted
    only once, even if multiple bits are set in the corresponding *revents* field.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 *select()* 和 *poll()* 返回值的稍微不同含义。*select()* 系统调用会在文件描述符出现在多个返回的文件描述符集中时，多次计数该文件描述符。*poll()*
    系统调用返回准备好的文件描述符的数量，且即使相应的 *revents* 字段中设置了多个位，文件描述符也只计数一次。
- en: Example program
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 63-2](ch63.html#using_poll_open_parenthesis_close_parent "Example 63-2. Using
    poll() to monitor multiple file descriptors") provides a simple demonstration
    of the use of *poll()*. This program creates a number of pipes (each pipe uses
    a consecutive pair of file descriptors), writes bytes to the write ends of randomly
    selected pipes, and then performs a *poll()* to see which pipes have data available
    for reading.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 63-2](ch63.html#using_poll_open_parenthesis_close_parent "示例 63-2. 使用 poll()
    来监控多个文件描述符") 提供了一个关于 *poll()* 使用的简单演示。该程序创建了多个管道（每个管道使用一对连续的文件描述符），向随机选择的管道的写端写入字节，然后执行
    *poll()* 以查看哪些管道有数据可供读取。'
- en: The following shell session shows an example of what we see when running this
    program. The command-line arguments to the program specify that ten pipes should
    be created, and writes should be made to three randomly selected pipes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的 shell 会话展示了运行此程序时我们所看到的示例。程序的命令行参数指定了应该创建十个管道，并且向三个随机选择的管道写入数据。
- en: '[PRE9]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From the above output, we can see that *poll()* found two pipes had data available
    for reading.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出中，我们可以看到 *poll()* 发现有两个管道有数据可以读取。
- en: Example 63-2. Using *poll()* to monitor multiple file descriptors
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 63-2. 使用 *poll()* 来监控多个文件描述符
- en: '[PRE10]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When Is a File Descriptor Ready?
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件描述符何时准备好？
- en: 'Correctly using *select()* and *poll()* requires an understanding of the conditions
    under which a file descriptor indicates as being ready. SUSv3 says that a file
    descriptor (with `O_NONBLOCK` clear) is considered to be ready if a call to an
    I/O function would not block, *regardless of whether the function would actually
    transfer data*. The key point is italicized: *select()* and *poll()* tell us whether
    an I/O operation would not block, rather than whether it would successfully transfer
    data. In this light, let us consider how these system calls operate for different
    types of file descriptors. We show this information in tables containing two columns:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用 *select()* 和 *poll()* 需要了解文件描述符指示为就绪的条件。SUSv3 规定，如果对 I/O 函数的调用不会阻塞（*无论该函数是否实际传输数据*），则认为文件描述符（`O_NONBLOCK`
    未设置）是就绪的。关键点已被斜体标出：*select()* 和 *poll()* 告诉我们 I/O 操作是否不会阻塞，而不是它是否会成功传输数据。从这个角度来看，我们来看看这些系统调用如何在不同类型的文件描述符上运行。我们将这些信息展示在包含两列的表格中：
- en: The *select()* column indicates whether a file descriptor is marked as readable
    (`r`), writable (`w`), or having an exceptional condition (`x`).
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*select()* 列指示文件描述符是否被标记为可读（`r`）、可写（`w`）或具有异常条件（`x`）。'
- en: The *poll()* column indicates the bit(s) returned in the *revents* field. In
    these tables, we omit mention of `POLLRDNORM`, `POLLWRNORM`, `POLLRDBAND`, and
    `POLLWRBAND`. Although some of these flags may be returned in *revents* in various
    circumstances (if they are specified in *events*), they convey no useful information
    beyond that provided by `POLLIN`, `POLLOUT`, `POLLHUP`, and `POLLERR`.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*poll()* 列指示在 *revents* 字段中返回的位。 在这些表中，我们省略了 `POLLRDNORM`、`POLLWRNORM`、`POLLRDBAND`
    和 `POLLWRBAND` 的提及。虽然在某些情况下（如果在 *events* 中指定了它们），这些标志可能会在 *revents* 中返回，但它们传达的信息并没有超出
    `POLLIN`、`POLLOUT`、`POLLHUP` 和 `POLLERR` 提供的信息。'
- en: Regular files
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常规文件
- en: 'File descriptors that refer to regular files are always marked as readable
    and writable by *select()*, and returned with `POLLIN` and `POLLOUT` set in *revents*
    for *poll()*, for the following reasons:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 引用常规文件的文件描述符始终会被 *select()* 标记为可读和可写，并且在 *poll()* 中返回 `POLLIN` 和 `POLLOUT` 设置在
    *revents* 中，原因如下：
- en: A *read()* will always immediately return data, end-of-file, or an error (e.g.,
    the file was not opened for reading).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*read()* 操作将始终立即返回数据、文件结束符或错误（例如，文件没有以可读方式打开）。'
- en: A *write()* will always immediately transfer data or fail with some error.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*write()* 操作将始终立即传输数据或因某些错误而失败。'
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 says that *select()* should also mark a descriptor for a regular file
    as having an exceptional condition (though this has no obvious meaning for regular
    files). Only some implementations do this; Linux is one of those that do not.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 规定，*select()* 也应该将常规文件的描述符标记为具有异常条件（尽管这对常规文件没有明显意义）。只有一些实现会这么做；Linux 是其中之一，没有这样做的实现。
- en: Terminals and pseudoterminals
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 终端和伪终端
- en: '[Table 63-3](ch63.html#select_open_parenthesis_close_parenthesi "Table 63-3. select()
    and poll() indications for terminals and pseudoterminals") summarizes the behavior
    of *select()* and *poll()* for terminals and pseudoterminals ([Chapter 64](ch64.html
    "Chapter 64. Pseudoterminals")).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 63-3](ch63.html#select_open_parenthesis_close_parenthesi "表 63-3. select()
    和 poll() 对终端和伪终端的指示") 总结了 *select()* 和 *poll()* 对终端和伪终端的行为（[第 64 章](ch64.html
    "第 64 章. 伪终端")）。'
- en: When one half of a pseudoterminal pair is closed, the *revents* setting returned
    by *poll()* for the other half of the pair depends on the implementation. On Linux,
    at least the `POLLHUP` flag is set. However, other implementations return various
    flags to indicate this event—for example, `POLLHUP`, `POLLERR`, or `POLLIN`. Furthermore,
    on some implementations, the flags that are set depend on whether it is the master
    or the slave device that is being monitored.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当伪终端对的一半关闭时，*poll()* 返回的另一半对的 *revents* 设置取决于实现。在 Linux 中，至少设置 `POLLHUP` 标志。然而，其他实现返回不同的标志来表示此事件——例如，`POLLHUP`、`POLLERR`
    或 `POLLIN`。此外，在某些实现中，设置的标志取决于是主设备还是从设备被监视。
- en: Table 63-3. *select()* and *poll()* indications for terminals and pseudoterminals
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 表 63-3. *select()* 和 *poll()* 对终端和伪终端的指示
- en: '| Condition or event | *select()* | *poll()* |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 条件或事件 | *select()* | *poll()* |'
- en: '| --- | --- | --- |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Input available | `r` | `POLLIN` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 输入可用 | `r` | `POLLIN` |'
- en: '| Output possible | `w` | `POLLOUT` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 输出可能 | `w` | `POLLOUT` |'
- en: '| After *close()* by pseudoterminal peer | `rw` | See text |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 伪终端对关闭后 | `rw` | 见正文 |'
- en: '| Pseudoterminal master in packet mode detects slave state change | `x` | `POLLPRI`
    |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 伪终端主设备在数据包模式下检测从设备状态变化 | `x` | `POLLPRI` |'
- en: Pipes and FIFOs
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管道和 FIFO
- en: '[Table 63-4](ch63.html#select_open_parenthesis_close_parent "Table 63-4. select()
    and poll() indications for the read end of a pipe or FIFO") summarizes the details
    for the read end of a pipe or FIFO. The *Data in pipe?* column indicates whether
    the pipe has at least 1 byte of data available for reading. In this table, we
    assume that `POLLIN` was specified in the *events* field for *poll()*.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[表63-4](ch63.html#select_open_parenthesis_close_parent "表63-4. select() 和 poll()
    在管道或 FIFO 的读端指示") 总结了管道或 FIFO 的读端的详细信息。*管道中有数据？* 列指示管道中是否至少有 1 个字节的数据可供读取。在此表中，我们假设在
    *poll()* 的 *events* 字段中指定了 `POLLIN`。'
- en: On some other UNIX implementations, if the write end of a pipe is closed, then,
    instead of returning with `POLLHUP` set, *poll()* returns with the `POLLIN` bit
    set (since a *read()* will return immediately with end-of-file). Portable applications
    should check to see if either bit is set in order to know if a *read()* will block.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些其他 UNIX 实现中，如果管道的写端关闭，则 *poll()* 返回时不会设置 `POLLHUP`，而是设置 `POLLIN` 位（因为 *read()*
    会立即返回文件结束标志）。便携式应用程序应检查是否设置了这两个位，以确定 *read()* 是否会阻塞。
- en: '[Table 63-5](ch63.html#select_open_parenthesis_close_paren "Table 63-5. select()
    and poll() indications for the write end of a pipe or FIFO") summarizes the details
    for the write end of a pipe. In this table, we assume that `POLLOUT` was specified
    in the *events* field for *poll()*. The *Space for PIPE_BUF bytes?* column indicates
    whether the pipe has room to atomically write `PIPE_BUF` bytes without blocking.
    This is the criterion on which Linux considers a pipe ready for writing. Some
    other UNIX implementations use the same criterion; others consider a pipe writable
    if even a single byte can be written. (In Linux 2.6.10 and earlier, the capacity
    of a pipe is the same as `PIPE_BUF`. This means that a pipe is considered unwritable
    if it contains even a single byte of data.)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[表63-5](ch63.html#select_open_parenthesis_close_paren "表63-5. select() 和 poll()
    在管道或 FIFO 的写端指示") 总结了管道写端的详细信息。在此表中，我们假设在 *poll()* 的 *events* 字段中指定了 `POLLOUT`。*是否有足够空间写入
    PIPE_BUF 字节？* 列指示管道是否有空间原子性地写入 `PIPE_BUF` 字节而不阻塞。这是 Linux 判断管道是否准备好写入的标准。一些其他
    UNIX 实现使用相同的标准；而其他一些则认为只要管道能够写入一个字节，就认为管道是可写的。（在 Linux 2.6.10 及更早版本中，管道的容量等于 `PIPE_BUF`。这意味着，如果管道中有一个字节数据，管道就被认为是不可写的。）'
- en: On some other UNIX implementations, if the read end of a pipe is closed, then,
    instead of returning with `POLLERR` set, *poll()* returns with either the `POLLOUT`
    bit or the `POLLHUP` bit set. Portable applications need to check to see if any
    of these bits is set to determine if a *write()* will block.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些其他 UNIX 实现中，如果管道的读端关闭，则 *poll()* 返回时不会设置 `POLLERR`，而是设置 `POLLOUT` 位或 `POLLHUP`
    位。便携式应用程序需要检查是否设置了这些位中的任何一位，以确定 *write()* 是否会阻塞。
- en: Table 63-4. *select()* and *poll()* indications for the read end of a pipe or
    FIFO
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 表63-4. *select()* 和 *poll()* 在管道或 FIFO 的读端指示
- en: '| Condition or event | *select()* | *poll()* |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 条件或事件 | *select()* | *poll()* |'
- en: '| --- | --- | --- |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Data in pipe? | Write end open? |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 管道中有数据？ | 写端打开？ |'
- en: '| --- | --- |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| no | no | `r` | `POLLHUP` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| no | no | `r` | `POLLHUP` |'
- en: '| yes | yes | `r` | `POLLIN` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| yes | yes | `r` | `POLLIN` |'
- en: '| yes | no | `r` | `POLLIN &#124; POLLHUP` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| yes | no | `r` | `POLLIN &#124; POLLHUP` |'
- en: Table 63-5. *select()* and *poll()* indications for the write end of a pipe
    or FIFO
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 表63-5. *select()* 和 *poll()* 在管道或 FIFO 的写端指示
- en: '| Condition or event | *select()* | *poll()* |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 条件或事件 | *select()* | *poll()* |'
- en: '| --- | --- | --- |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Space for `PIPE_BUF` bytes? | Read end open? |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 是否有足够空间写入 `PIPE_BUF` 字节？ | 读端打开？ |'
- en: '| --- | --- |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| no | no | `w` | `POLLERR` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| no | no | `w` | `POLLERR` |'
- en: '| yes | yes | `w` | `POLLOUT` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| yes | yes | `w` | `POLLOUT` |'
- en: '| yes | no | `w` | `POLLOUT &#124; POLLERR` |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| yes | no | `w` | `POLLOUT &#124; POLLERR` |'
- en: Sockets
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 套接字
- en: '[Table 63-6](ch63.html#select_open_parenthesis_close_paren-id1 "Table 63-6. select()
    and poll() indications for sockets") summarizes the behavior of *select()* and
    *poll()* for sockets. For the *poll()* column, we assume that *events* was specified
    as `(POLLIN | POLLOUT | POLLPRI)`. For the *select()* column, we assume that the
    file descriptor is being tested to see if input is possible, output is possible,
    or an exceptional condition occurred (i.e., the file descriptor is specified in
    all three sets passed to *select()*). This table covers just the common cases,
    not all possible scenarios.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[表63-6](ch63.html#select_open_parenthesis_close_paren-id1 "表63-6. select()和poll()的套接字指示")总结了*select()*和*poll()*在套接字上的行为。对于*poll()*列，我们假设*events*指定为`(POLLIN
    | POLLOUT | POLLPRI)`。对于*select()*列，我们假设正在测试文件描述符以查看是否可以输入、是否可以输出或是否发生了异常情况（即，文件描述符在传递给*select()*的所有三个集合中都有指定）。此表仅涵盖常见情况，并非所有可能的场景。'
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Linux *poll()* behavior for UNIX domain sockets after a peer *close()* differs
    from that shown in [Table 63-6](ch63.html#select_open_parenthesis_close_paren-id1
    "Table 63-6. select() and poll() indications for sockets"). As well as the other
    flags, *poll()* additionally returns `POLLHUP` in *revents*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的*poll()*行为与UNIX域套接字的*close()*操作后的行为与[表63-6](ch63.html#select_open_parenthesis_close_paren-id1
    "表63-6. select()和poll()的套接字指示")中的行为不同。除了其他标志外，*poll()*还会在*revents*中返回`POLLHUP`。
- en: Table 63-6. *select()* and *poll()* indications for sockets
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 表63-6. *select()*和*poll()*在套接字上的指示
- en: '| Condition or event | *select()* | *poll()* |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 条件或事件 | *select()* | *poll()* |'
- en: '| --- | --- | --- |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Input available | `r` | `POLLIN` |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 输入可用 | `r` | `POLLIN` |'
- en: '| Output possible | `w` | `POLLOUT` |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 输出可能 | `w` | `POLLOUT` |'
- en: '| Incoming connection established on listening socket | `r` | `POLLIN` |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 在监听套接字上建立的传入连接 | `r` | `POLLIN` |'
- en: '| Out-of-band data received (TCP only) | `x` | `POLLPRI` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 接收到带外数据（仅TCP） | `x` | `POLLPRI` |'
- en: '| Stream socket peer closed connection or executed *shutdown(SHUT_WR)* | `rw`
    | `POLLIN &#124; POLLOUT &#124; POLLRDHUP` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 流套接字的对等端关闭了连接或执行了*shutdown(SHUT_WR)* | `rw` | `POLLIN &#124; POLLOUT &#124;
    POLLRDHUP` |'
- en: The Linux-specific `POLLRDHUP` flag (available since Linux 2.6.17) needs a little
    further explanation. This flag—actually in the form of `EPOLLRDHUP`—is designed
    primarily for use with the edge-triggered mode of the *epoll* API (Section 63.4).
    It is returned when the remote end of a stream socket connection has shut down
    the writing half of the connection. The use of this flag allows an application
    that uses the *epoll* edge-triggered interface to employ simpler code to recognize
    a remote shutdown. (The alternative is for the application to note that the `POLLIN`
    flag is set and then perform a *read()*, which indicates the remote shutdown with
    a return of 0.)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Linux特有的`POLLRDHUP`标志（自Linux 2.6.17开始提供）需要进一步解释。这个标志——实际上是`EPOLLRDHUP`的形式——主要用于*epoll*
    API的边缘触发模式（第63.4节）。当流套接字连接的远程端关闭了连接的写入端时，将返回此标志。使用此标志可以让使用*epoll*边缘触发接口的应用程序使用更简单的代码来识别远程关闭。（另一种方法是应用程序注意到`POLLIN`标志已设置，然后执行*read()*，通过返回0来指示远程关闭。）
- en: Comparison of *select()* and *poll()*
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*select()*与*poll()*比较'
- en: In this section, we consider some similarities and differences between *select()*
    and *poll()*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们考虑*select()*和*poll()*之间的一些相似性和差异。
- en: Implementation details
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现细节
- en: Within the Linux kernel, *select()* and *poll()* both employ the same set of
    kernel-internal *poll* routines. These *poll* routines are distinct from the *poll()*
    system call itself. Each routine returns information about the readiness of a
    single file descriptor. This readiness information takes the form of a bit mask
    whose values correspond to the bits returned in the *revents* field by the *poll()*
    system call ([Table 63-2](ch63.html#bit-mask_values_for_events_and_revents_f "Table 63-2. Bit-mask
    values for events and revents fields of the pollfd structure")). The implementation
    of the *poll()* system call involves calling the kernel *poll* routine for each
    file descriptor and placing the resulting information in the corresponding *revents*
    field.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核中，*select()*和*poll()*都使用相同的一组内核内部的*poll*例程。这些*poll*例程与*poll()*系统调用本身是不同的。每个例程返回有关单个文件描述符准备情况的信息。这些准备情况的信息以位掩码的形式返回，其值对应于*poll()*系统调用中*revents*字段返回的位（[表63-2](ch63.html#bit-mask_values_for_events_and_revents_f
    "表63-2. pollfd结构的事件和revents字段的位掩码值")）。*poll()*系统调用的实现涉及为每个文件描述符调用内核的*poll*例程，并将结果信息放入相应的*revents*字段中。
- en: 'To implement *select()*, a set of macros is used to convert the information
    returned by the kernel *poll* routines into the corresponding event types returned
    by *select()*:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 实现*select()*时，使用一组宏将内核*poll*例程返回的信息转换为*select()*返回的相应事件类型：
- en: '[PRE11]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These macro definitions reveal the semantic correspondence between the information
    returned by *select()* and *poll()*. (If we look at the *select()* and *poll()*
    columns in the tables in [When Is a File Descriptor Ready?](ch63.html#when_is_a_file_descriptor_ready_question
    "When Is a File Descriptor Ready?"), we see that the indications provided by each
    system call are consistent with the above macros.) The only additional information
    we need to complete the picture is that *poll()* returns `POLLNVAL` in the *revents*
    field if one of the monitored file descriptors was closed at the time of the call,
    while *select()* returns -1 with *errno* set to `EBADF`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏定义揭示了*select()*和*poll()*返回的信息之间的语义对应关系。（如果我们查看[文件描述符何时准备好？](ch63.html#when_is_a_file_descriptor_ready_question
    "文件描述符何时准备好？")中的*select()*和*poll()*列，我们会发现每个系统调用提供的指示与上述宏一致。）我们需要补充的唯一信息是，如果被监控的文件描述符在调用时被关闭，*poll()*会在*revents*字段中返回`POLLNVAL`，而*select()*会返回-1并将*errno*设置为`EBADF`。
- en: API differences
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: API差异
- en: 'The following are some differences between the *select()* and *poll()* APIs:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*select()*和*poll()* API的一些差异：
- en: The use of the *fd_set* data type places an upper limit (`FD_SETSIZE`) on the
    range of file descriptors that can be monitored by *select()*. By default, this
    limit is 1024 on Linux, and changing it requires recompiling the application.
    By contrast, *poll()* places no intrinsic limit on the range of file descriptors
    that can be monitored.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*fd_set*数据类型为*select()*能够监控的文件描述符范围设定了一个上限（`FD_SETSIZE`）。在Linux中，默认情况下，这个上限为1024，修改该值需要重新编译应用程序。相比之下，*poll()*对可以监控的文件描述符范围没有内在的限制。
- en: Because the *fd_set* arguments of *select()* are value-result, we must reinitialize
    them if making repeated *select()* calls from within a loop. By using separate
    *events* (input) and *revents* (output) fields, *poll()* avoids this requirement.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于*select()*的*fd_set*参数是值结果类型，我们必须在循环中反复调用*select()*时重新初始化它们。通过使用独立的*events*（输入）和*revents*（输出）字段，*poll()*避免了这一要求。
- en: The *timeout* precision afforded by *select()* (microseconds) is greater than
    that afforded by *poll()* (milliseconds). (The accuracy of the timeouts of both
    of these system calls is nevertheless limited by the software clock granularity.)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*select()*提供的*timeout*精度（微秒）大于*poll()*提供的精度（毫秒）。（不过，这两个系统调用的超时准确性都受软件时钟粒度的限制。）'
- en: If one of the file descriptors being monitored was closed, then *poll()* informs
    us exactly which one, via the `POLLNVAL` bit in the corresponding *revents* field.
    By contrast, *select()* merely returns -1 with *errno* set to `EBADF`, leaving
    us to determine which file descriptor is closed by checking for an error when
    performing an I/O system call on the descriptor. However, this is typically not
    an important difference, since an application can usually keep track of which
    file descriptors it has closed.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果被监控的文件描述符之一被关闭，*poll()*会通过相应*revents*字段中的`POLLNVAL`位告诉我们具体是哪一个。相比之下，*select()*只是返回-1，并将*errno*设置为`EBADF`，我们需要通过在对描述符进行I/O系统调用时检查错误来确定哪个文件描述符已关闭。然而，这通常不是一个重要的区别，因为应用程序通常可以跟踪它已关闭的文件描述符。
- en: Portability
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可移植性
- en: Historically, *select()* was more widely available than *poll()*. Nowadays,
    both interfaces are standardized by SUSv3 and widely available on contemporary
    implementations. However, there is some variation in the behavior of *poll()*
    across implementations, as noted in [When Is a File Descriptor Ready?](ch63.html#when_is_a_file_descriptor_ready_question
    "When Is a File Descriptor Ready?").
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，*select()*比*poll()*更广泛可用。如今，两个接口都已被SUSv3标准化，并在当代实现中广泛可用。然而，正如在[文件描述符何时准备好？](ch63.html#when_is_a_file_descriptor_ready_question
    "文件描述符何时准备好？")中所提到的，*poll()*在不同实现中的行为有所不同。
- en: Performance
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 性能
- en: 'The performance of *poll()* and *select()* is similar if either of the following
    is true:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下任一条件为真，则*poll()*和*select()*的性能相似：
- en: The range of file descriptors to be monitored is small (i.e., the maximum file
    descriptor number is low).
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控的文件描述符范围较小（即，最大文件描述符号较低）。
- en: A large number of file descriptors are being monitored, but they are densely
    packed (i.e., most or all of the file descriptors from 0 up to some limit are
    being monitored).
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在监视大量文件描述符，但它们是密集排列的（即，大部分或所有从0到某个限制的文件描述符都在被监视）。
- en: However, the performance of *select()* and *poll()* can differ noticeably if
    the set of file descriptors to be monitored is sparse; that is, the maximum file
    descriptor number, N, is large, but only one or a few descriptors in the range
    0 to *N* are being monitored. In this case, *poll()* can perform better than *select()*.
    We can understand the reasons for this by considering the arguments passed to
    the two system calls. With *select()*, we pass one or more file descriptor sets
    and an integer, *nfds*, which is one greater than the maximum file descriptor
    to be examined in each set. The *nfds* argument has the same value, regardless
    of whether we are monitoring all file descriptors in the range 0 to *(nfds - 1)*
    or only the descriptor *(nfds - 1)*. In both cases, the kernel must examine *nfds*
    elements in each set in order to check exactly which file descriptors are to be
    monitored. By contrast, when using *poll()*, we specify only the file descriptors
    of interest to us, and the kernel checks only those descriptors.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果要监视的文件描述符集是稀疏的，即最大文件描述符编号N很大，但在范围0到*N*之间只有一个或少数几个描述符被监视，*select()*和*poll()*的性能差异可能会明显不同。在这种情况下，*poll()*可能比*select()*表现得更好。我们可以通过考虑这两个系统调用的参数来理解其原因。对于*select()*，我们传递一个或多个文件描述符集以及一个整数*nfds*，该整数比每个集合中要检查的最大文件描述符大1。无论我们监视的是范围0到*(nfds
    - 1)*中的所有文件描述符，还是仅监视描述符*(nfds - 1)*，*nfds*参数的值都是相同的。在这两种情况下，内核必须检查每个集合中的*nfds*个元素，以确切地检查哪些文件描述符需要被监视。相比之下，使用*poll()*时，我们仅指定我们感兴趣的文件描述符，内核只检查这些描述符。
- en: Note
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The difference in performance for *poll()* and *select()* with sparse descriptor
    sets was quite significant in Linux 2.4\. Some optimizations in Linux 2.6 have
    narrowed the performance gap considerably.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 2.4 中，*poll()*和*select()*在稀疏描述符集下的性能差异相当显著。Linux 2.6中的一些优化大大缩小了性能差距。
- en: We consider the performance of *select()* and *poll()* further in [Performance
    of *epoll* Versus I/O Multiplexing](ch63.html#performance_of_epoll_versus_i_solidus_o
    "Performance of epoll Versus I/O Multiplexing"), where we compare the performance
    of these system calls against *epoll*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[《*epoll* 与 I/O 多路复用性能对比》](ch63.html#performance_of_epoll_versus_i_solidus_o
    "Performance of epoll Versus I/O Multiplexing")中进一步讨论了*select()*和*poll()*的性能，那里我们将这些系统调用的性能与*epoll*进行了对比。
- en: Problems with *select()* and *poll()*
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*select()*和*poll()*的问题'
- en: 'The *select()* and *poll()* system calls are the portable, long-standing, and
    widely used methods of monitoring multiple file descriptors for readiness. However,
    these APIs suffer some problems when monitoring a large number of file descriptors:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*select()*和*poll()*系统调用是便携式的、历史悠久且广泛使用的多文件描述符就绪监视方法。然而，在监视大量文件描述符时，这些API存在一些问题：'
- en: On each call to *select()* or *poll()*, the kernel must check all of the specified
    file descriptors to see if they are ready. When monitoring a large number of file
    descriptors that are in a densely packed range, the time required for this operation
    greatly outweighs the time required for the next two operations.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次调用*select()*或*poll()*时，内核必须检查所有指定的文件描述符，看看它们是否准备好。当监视大量位于密集范围内的文件描述符时，这个操作所需的时间远远超过了接下来的两个操作所需的时间。
- en: In each call to *select()* or *poll()*, the program must pass a data structure
    to the kernel describing all of the file descriptors to be monitored, and, after
    checking the descriptors, the kernel returns a modified version of this data structure
    to the program. (Furthermore, for *select()*, we must initialize the data structure
    before each call.) For *poll()*, the size of the data structure increases with
    the number of file descriptors being monitored, and the task of copying it from
    user to kernel space and back again consumes a noticeable amount of CPU time when
    monitoring many file descriptors. For *select()*, the size of the data structure
    is fixed by `FD_SETSIZE`, regardless of the number of file descriptors being monitored.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次调用*select()*或*poll()*时，程序必须向内核传递一个数据结构，描述所有需要监视的文件描述符，检查完描述符后，内核会返回一个修改过的版本的这个数据结构给程序。（此外，对于*select()*，我们必须在每次调用之前初始化这个数据结构。）对于*poll()*，数据结构的大小会随着被监视的文件描述符数量的增加而增大，当监视大量文件描述符时，从用户空间到内核空间再返回的复制任务会消耗相当多的CPU时间。而对于*select()*，数据结构的大小由`FD_SETSIZE`固定，不受监视的文件描述符数量的影响。
- en: After the call to *select()* or *poll()*, the program must inspect every element
    of the returned data structure to see which file descriptors are ready.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用*select()*或*poll()*之后，程序必须检查返回的数据结构的每个元素，以查看哪些文件描述符已经准备就绪。
- en: The consequence of the above points is that the CPU time required by *select()*
    and *poll()* increases with the number of file descriptors being monitored (see
    [Performance of *epoll* Versus I/O Multiplexing](ch63.html#performance_of_epoll_versus_i_solidus_o
    "Performance of epoll Versus I/O Multiplexing") for more details). This creates
    problems for programs that monitor large numbers of file descriptors.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 上述几点的结果是，*select()*和*poll()*所需的CPU时间会随着被监视的文件描述符数量的增加而增加（有关更多细节，请参见[性能对比：*epoll*与I/O多路复用](ch63.html#performance_of_epoll_versus_i_solidus_o
    "Performance of epoll Versus I/O Multiplexing")）。这对监视大量文件描述符的程序来说，会带来问题。
- en: 'The poor scaling performance of *select()* and *poll()* stems from a simple
    limitation of these APIs: typically, a program makes repeated calls to monitor
    the same set of file descriptors; however, the kernel doesn’t remember the list
    of file descriptors to be monitored between successive calls.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*select()*和*poll()*的扩展性差是由这些API的一个简单限制引起的：通常，程序会重复调用来监视相同的一组文件描述符；然而，内核不会在连续的调用之间记住要监视的文件描述符列表。'
- en: Signal-driven I/O and *epoll*, which we examine in the following sections, are
    both mechanisms that allow the kernel to record a persistent list of file descriptors
    in which a process is interested. Doing this eliminates the performance scaling
    problems of *select()* and *poll()*, yielding solutions that scale according to
    the number of I/O events that occur, rather than according to the number of file
    descriptors being monitored. Consequently, signal-driven I/O and *epoll* provide
    superior performance when monitoring large numbers of file descriptors.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 信号驱动I/O和*epoll*（我们将在接下来的章节中讨论），都是允许内核记录进程感兴趣的文件描述符持久列表的机制。这样做消除了*select()*和*poll()*的性能扩展问题，提供了根据发生的I/O事件数量而非监视的文件描述符数量扩展的解决方案。因此，当监视大量文件描述符时，信号驱动I/O和*epoll*提供了更好的性能。
- en: Signal-Driven I/O
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号驱动I/O
- en: 'With I/O multiplexing, a process makes a system call (*select()* or *poll()*)
    in order to check whether I/O is possible on a file descriptor. With signal-driven
    I/O, a process requests that the kernel send it a signal when I/O is possible
    on a file descriptor. The process can then perform any other activity until I/O
    is possible, at which time the signal is delivered to the process. To use signal-driven
    I/O, a program performs the following steps:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用I/O多路复用时，进程会进行系统调用（*select()*或*poll()*），以检查某个文件描述符上是否可以进行I/O操作。而在信号驱动I/O中，进程请求内核在文件描述符上可以进行I/O操作时发送信号给它。进程可以在此期间进行其他活动，直到I/O操作可用，届时信号会发送到进程。要使用信号驱动I/O，程序需要执行以下步骤：
- en: Establish a handler for the signal delivered by the signal-driven I/O mechanism.
    By default, this notification signal is `SIGIO`.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为由信号驱动的I/O机制发送的信号建立一个处理程序。默认情况下，这个通知信号是`SIGIO`。
- en: 'Set the *owner* of the file descriptor—that is, the process or process group
    that is to receive signals when I/O is possible on the file descriptor. Typically,
    we make the calling process the owner. The owner is set using an *fcntl()* `F_SETOWN`
    operation of the following form:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置文件描述符的*所有者*——即在文件描述符上I/O操作可用时应接收信号的进程或进程组。通常，我们将调用进程设置为所有者。所有者通过*fcntl()*
    `F_SETOWN`操作来设置，格式如下：
- en: '[PRE12]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Enable nonblocking I/O by setting the `O_NONBLOCK` open file status flag.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置`O_NONBLOCK`打开文件状态标志来启用非阻塞I/O。
- en: 'Enable signal-driven I/O by turning on the `O_ASYNC` open file status flag.
    This can be combined with the previous step, since they both require the use of
    the *fcntl()* `F_SETFL` operation (Section 5.3), as in the following example:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过启用`O_ASYNC`打开文件状态标志来启用信号驱动I/O。这可以与前一步骤结合使用，因为它们都需要使用*fcntl()* `F_SETFL`操作（第5.3节），如下所示：
- en: '[PRE13]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The calling process can now perform other tasks. When I/O becomes possible,
    the kernel generates a signal for the process and invokes the signal handler established
    in step 1.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用进程现在可以执行其他任务。当I/O变得可用时，内核会为进程生成一个信号，并调用在步骤1中建立的信号处理程序。
- en: Signal-driven I/O provides edge-triggered notification ([Which technique?](ch63.html#which_technique_question-id1
    "Which technique?")). This means that once the process has been notified that
    I/O is possible, it should perform as much I/O (e.g., read as many bytes) as possible.
    Assuming a nonblocking file descriptor, this means executing a loop that performs
    I/O system calls until a call fails with the error `EAGAIN` or `EWOULDBLOCK`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信号驱动I/O提供了边缘触发的通知（[哪种技术？](ch63.html#which_technique_question-id1 "哪种技术？")）。这意味着一旦进程被通知I/O可用，它应该尽可能地执行I/O操作（例如，读取尽可能多的字节）。假设文件描述符是非阻塞的，这意味着执行一个循环，进行I/O系统调用，直到调用因错误`EAGAIN`或`EWOULDBLOCK`而失败。
- en: On Linux 2.4 and earlier, signal-driven I/O can be employed with file descriptors
    for sockets, terminals, pseudoterminals, and certain other types of devices. Linux
    2.6 additionally allows signal-driven I/O to be employed with pipes and FIFOs.
    Since Linux 2.6.25, signal-driven I/O can also be used with *inotify* file descriptors.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux 2.4及更早版本中，可以通过文件描述符使用信号驱动I/O，适用于套接字、终端、伪终端和某些其他类型的设备。Linux 2.6还允许信号驱动I/O用于管道和FIFO。从Linux
    2.6.25开始，信号驱动I/O还可以用于*inotify*文件描述符。
- en: In the following pages, we first present an example of the use of signal-driven
    I/O, and then explain some of the above steps in greater detail.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的页面中，我们首先展示一个使用信号驱动I/O的示例，然后更详细地解释上述一些步骤。
- en: Note
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Historically, signal-driven I/O was sometimes referred to as *asynchronous I/O*,
    and this is reflected in the name (`O_ASYNC`) of the associated open file status
    flag. However, nowadays, the term *asynchronous I/O* is used to refer to the type
    of functionality provided by the POSIX AIO specification. Using POSIX AIO, a process
    requests the kernel to perform an I/O operation, and the kernel *initiates* the
    operation, but immediately passes control back to the calling process; the process
    is then later notified when the I/O operation completes or an error occurs.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，信号驱动I/O有时被称为*异步I/O*，这也反映在与之关联的打开文件状态标志（`O_ASYNC`）的名称中。然而，现在，*异步I/O*一词通常用于指代POSIX
    AIO规范所提供的功能类型。使用POSIX AIO时，进程请求内核执行I/O操作，内核*启动*操作，但立即将控制权返回给调用进程；进程随后会在I/O操作完成或发生错误时得到通知。
- en: '`O_ASYNC` was specified in POSIX.1g, but was not included in SUSv3 because
    the specification of the required behavior for this flag was deemed insufficient.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`O_ASYNC`在POSIX.1g中有所规定，但由于该标志的行为规范被认为不足，因此未包含在SUSv3中。'
- en: Several UNIX implementations, especially older ones, don’t define the `O_ASYNC`
    constant for use with *fcntl()*. Instead, the constant is named `FASYNC`, and
    *glibc* defines this latter name as a synonym for `O_ASYNC`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一些UNIX实现，尤其是较老的实现，没有定义用于*fcntl()*的`O_ASYNC`常量。相反，该常量被命名为`FASYNC`，并且*glibc*将此名称定义为`O_ASYNC`的同义词。
- en: Example program
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 63-3](ch63.html#using_signal-driven_i_solidus_o_on_a_ter "Example 63-3. Using
    signal-driven I/O on a terminal") provides a simple example of the use of signal-driven
    I/O. This program performs the steps described above for enabling signal-driven
    I/O on standard input, and then places the terminal in cbreak mode ([Cooked, Cbreak,
    and Raw Modes](ch62.html#cooked_comma_cbreak_comma_and_raw_modes "Cooked, Cbreak,
    and Raw Modes")), so that input is available a character at a time. The program
    then enters an infinite loop, performing the “work” of incrementing a variable,
    *cnt*, while waiting for input to become available. Whenever input becomes available,
    the `SIGIO` handler sets a flag, *gotSigio*, that is monitored by the main program.
    When the main program sees that this flag is set, it reads all available input
    characters and prints them along with the current value of *cnt*. If a hash character
    (`#`) is read in the input, the program terminates.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 63-3](ch63.html#using_signal-driven_i_solidus_o_on_a_ter "示例 63-3. 使用信号驱动
    I/O 在终端上") 提供了一个简单的信号驱动 I/O 使用例子。该程序执行了上述启用标准输入信号驱动 I/O 的步骤，然后将终端设置为 cbreak 模式（[Cooked,
    Cbreak, 和 Raw 模式](ch62.html#cooked_comma_cbreak_comma_and_raw_modes "Cooked, Cbreak,
    和 Raw 模式")），使得输入可以逐个字符地读取。然后，程序进入无限循环，在等待输入可用时执行“工作”，即递增一个变量 *cnt*。每当输入变得可用时，`SIGIO`
    处理程序会设置一个标志 *gotSigio*，主程序会监控这个标志。当主程序看到该标志被设置时，它会读取所有可用的输入字符，并打印出它们及当前的 *cnt*
    值。如果输入中读取到哈希符号（`#`），程序将终止。'
- en: 'Here is an example of what we see when we run this program and type the *x*
    character a number of times, followed by a hash (`#`) character:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们运行该程序并输入字符 *x* 多次，然后输入哈希符号（`#`）时看到的例子：
- en: '[PRE14]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Example 63-3. Using signal-driven I/O on a terminal
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 63-3. 使用信号驱动 I/O 在终端上
- en: '[PRE15]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Establish the signal handler before enabling signal-driven I/O
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在启用信号驱动 I/O 之前，先建立信号处理程序
- en: Because the default action of `SIGIO` is to terminate the process, we should
    enable the handler for `SIGIO` before enabling signal-driven I/O on a file descriptor.
    If we enable signal-driven I/O before establishing the `SIGIO` handler, then there
    is a time window during which, if I/O becomes possible, delivery of `SIGIO` will
    terminate the process.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `SIGIO` 的默认操作是终止进程，我们应该在启用文件描述符上的信号驱动 I/O 之前，启用 `SIGIO` 的处理程序。如果在建立 `SIGIO`
    处理程序之前启用了信号驱动 I/O，那么就会有一个时间窗口，在这个时间窗口内，如果 I/O 变得可用，`SIGIO` 的传递会终止进程。
- en: Note
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On some UNIX implementations, `SIGIO` is ignored by default.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些 UNIX 实现中，默认情况下会忽略 `SIGIO`。
- en: Setting the file descriptor owner
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置文件描述符所有者
- en: 'We set the file descriptor owner using an *fcntl()* operation of the following
    form:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 *fcntl()* 操作来设置文件描述符的所有者，操作形式如下：
- en: '[PRE16]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We may specify that either a single process or all of the processes in a process
    group are to be signaled when I/O is possible on the file descriptor. If *pid*
    is positive, it is interpreted as a process ID. If *pid* is negative, its absolute
    value specifies a process group ID.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定在文件描述符上的 I/O 可用时，单个进程或进程组中的所有进程应接收到信号。如果*pid*是正数，则它被解释为进程 ID。如果*pid*是负数，则其绝对值指定一个进程组
    ID。
- en: Note
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On older UNIX implementations, an *ioctl()* operation—either `FIOSETOWN` or
    `SIOCSPGRP`—was used to achieve the same effect as `F_SETOWN`. For compatibility,
    these *ioctl()* operations are also provided on Linux.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在较老的 UNIX 实现中，*ioctl()* 操作——`FIOSETOWN` 或 `SIOCSPGRP`——用于实现与 `F_SETOWN` 相同的效果。为了兼容，Linux
    上也提供了这些 *ioctl()* 操作。
- en: Typically, *pid* is specified as the process ID of the calling process (so that
    the signal is sent to the process that has the file descriptor open). However,
    it is possible to specify another process or a process group (e.g., the caller’s
    process group), and signals will be sent to that target, subject to the permission
    checks described in Section 20.5, where the sending process is considered to be
    the process that does the `F_SETOWN`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*pid* 被指定为调用进程的进程 ID（以便将信号发送到打开文件描述符的进程）。然而，也可以指定其他进程或进程组（例如调用者的进程组），信号会发送到该目标，前提是符合第
    20.5 节中描述的权限检查，其中发送信号的进程被视为执行 `F_SETOWN` 的进程。
- en: 'The *fcntl()* `F_GETOWN` operation returns the ID of the process or process
    group that is to receive signals when I/O is possible on a specified file descriptor:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*fcntl()* `F_GETOWN` 操作返回当文件描述符上 I/O 可用时，应该接收信号的进程或进程组的 ID：'
- en: '[PRE17]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A process group ID is returned as a negative number by this call.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用返回一个负数，表示进程组 ID。
- en: Note
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *ioctl()* operation that corresponds to `F_GETOWN` on older UNIX implementations
    was `FIOGETOWN` or `SIOCGPGRP`. Both of these *ioctl()* operations are also provided
    on Linux.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在较老的 UNIX 实现中，与 `F_GETOWN` 对应的 *ioctl()* 操作是 `FIOGETOWN` 或 `SIOCGPGRP`。这两个 *ioctl()*
    操作在 Linux 上也可以使用。
- en: A limitation in the system call convention employed on some Linux architectures
    (notably, x86) means that if a file descriptor is owned by a process group ID
    less than 4096, then, instead of returning that ID as a negative function result
    from the *fcntl()* `F_GETOWN` operation, *glibc* misinterprets it as a system
    call error. Consequently, the *fcntl()* wrapper function returns -1, and *errno*
    contains the (positive) process group ID. This is a consequence of the fact that
    the kernel system call interface indicates errors by returning a negative *errno*
    value as a function result, and there are a few cases where it is necessary to
    distinguish such results from a successful call that returns a valid negative
    value. To make this distinction, *glibc* interprets negative system call returns
    in the range -1 to -4095 as indicating an error, copies this (absolute) value
    into *errno*, and returns -1 as the function result for the application program.
    This technique is generally sufficient for dealing with the few system call service
    routines that can return a valid negative result; the *fcntl()* `F_GETOWN` operation
    is the only practical case where it fails. This limitation means that an application
    that uses process groups to receive “I/O possible” signals (which is unusual)
    can’t reliably use `F_GETOWN` to discover which process group owns a file descriptor.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 Linux 架构（尤其是 x86）上使用的系统调用约定存在一个限制：如果文件描述符由进程组 ID 小于 4096 的进程所有，那么在执行 *fcntl()*
    `F_GETOWN` 操作时，*glibc* 并不会将该 ID 返回为负值的函数结果，而是误将其解释为系统调用错误。因此，*fcntl()* 封装函数会返回
    -1，*errno* 中包含（正值）进程组 ID。这是因为内核系统调用接口通过返回负的 *errno* 值作为函数结果来指示错误，在某些情况下需要区分这种错误结果和返回有效负值的成功调用。为了做出这个区分，*glibc*
    将 -1 到 -4095 范围内的负系统调用返回值解释为表示错误，并将该（绝对）值复制到 *errno* 中，然后将 -1 作为函数结果返回给应用程序。这个技术通常足以处理少数可以返回有效负值的系统调用服务例程；但
    *fcntl()* `F_GETOWN` 操作是唯一一个无法正确处理的实际情况。这个限制意味着使用进程组接收“ I/O 可能”信号的应用程序（这种情况不常见）不能可靠地使用
    `F_GETOWN` 来发现哪个进程组拥有文件描述符。
- en: Note
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since *glibc* version 2.11, the *fcntl()* wrapper function fixes the problem
    of `F_GETOWN` with process group IDs less than 4096\. It does this by implementing
    `F_GETOWN` in user space using the `F_GETOWN_EX` operation ([When Is “I/O Possible”
    Signaled?](ch63.html#when_is_quotation_mark_i_solidus "When Is “I/O Possible”
    Signaled?")), which is provided by Linux 2.6.32 and later.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *glibc* 版本 2.11 开始，*fcntl()* 封装函数修复了进程组 ID 小于 4096 时的 `F_GETOWN` 问题。它通过在用户空间实现
    `F_GETOWN`，使用由 Linux 2.6.32 及更高版本提供的 `F_GETOWN_EX` 操作（[“I/O 可能”何时被信号化？](ch63.html#when_is_quotation_mark_i_solidus
    "When Is “I/O Possible” Signaled?")）来解决此问题。
- en: When Is “I/O Possible” Signaled?
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “I/O 可能”何时被信号化？
- en: We now consider the details of when “I/O possible” is signaled for various file
    types.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论何时为各种文件类型信号化“ I/O 可能”。
- en: Terminals and pseudoterminals
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 终端和伪终端
- en: For terminals and pseudoterminals, a signal is generated whenever new input
    becomes available, even if previous input has not yet been read. “Input possible”
    is also signaled if an end-of-file condition occurs on a terminal (but not on
    a pseudoterminal).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 对于终端和伪终端，每当有新输入可用时，即使之前的输入尚未读取，也会生成信号。如果终端发生文件结束条件，也会发出“输入可能”信号（但伪终端不会）。
- en: There is no “output possible” signaling for terminals. A terminal disconnect
    is also not signaled.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 终端没有“输出可能”信号，也没有终端断开信号。
- en: Starting with kernel 2.4.19, Linux provides “output possible” signaling for
    the slave side of a pseudoterminal. This signal is generated whenever input is
    consumed on the master side of the pseudoterminal.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核版本 2.4.19 开始，Linux 为伪终端的从端提供“输出可能”信号。每当伪终端主端的输入被消费时，都会生成此信号。
- en: Pipes and FIFOs
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 管道和 FIFO
- en: 'For the read end of a pipe or FIFO, a signal is generated in these circumstances:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于管道或 FIFO 的读端，在以下情况下会生成信号：
- en: Data is written to the pipe (even if there was already unread input available).
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据被写入管道（即使已存在未读的输入）。
- en: The write end of the pipe is closed.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道的写端被关闭时。
- en: 'For the write end of a pipe or FIFO, a signal is generated in these circumstances:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于管道或 FIFO 的写端，在以下情况下会生成信号：
- en: A read from the pipe increases the amount of free space in the pipe so that
    it is now possible to write `PIPE_BUF` bytes without blocking.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从管道读取增加了管道中的空闲空间，使得现在可以写入 `PIPE_BUF` 字节而不阻塞。
- en: The read end of the pipe is closed.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道的读端已关闭。
- en: Sockets
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 套接字
- en: 'Signal-driven I/O works for datagram sockets in both the UNIX and the Internet
    domains. A signal is generated in the following circumstances:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 信号驱动 I/O 适用于 UNIX 域和 Internet 域中的数据报套接字。在以下情况下会生成信号：
- en: An input datagram arrives on the socket (even if there were already unread datagrams
    waiting to be read).
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字上收到一个输入数据报（即使已经有未读的数据报等待读取）。
- en: An asynchronous error occurs on the socket.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字上发生了异步错误。
- en: 'Signal-driven I/O works for stream sockets in both the UNIX and the Internet
    domains. A signal is generated in the following circumstances:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 信号驱动 I/O 适用于 UNIX 域和 Internet 域中的流套接字。在以下情况下会生成信号：
- en: A new connection is received on a listening socket.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个监听套接字上接收到一个新的连接。
- en: A TCP *connect()* request completes; that is, the active end of a TCP connection
    entered the ESTABLISHED state, as shown in [Figure 61-5](ch61.html#three-way_handshake_for_tcp_connection_e
    "Figure 61-5. Three-way handshake for TCP connection establishment") (page 1272).
    The analogous condition is not signaled for UNIX domain sockets.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP *connect()* 请求完成；即，TCP 连接的主动端进入了 ESTABLISHED 状态，如 [图 61-5](ch61.html#three-way_handshake_for_tcp_connection_e
    "图 61-5. TCP 连接建立的三次握手")（第 1272 页）所示。对于 UNIX 域套接字，不会触发类似的信号。
- en: New input is received on the socket (even if there was already unread input
    available).
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字上收到新的输入数据（即使之前已经有未读输入数据）。
- en: The peer closes its writing half of the connection using *shutdown()*, or closes
    its socket altogether using *close()*.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对端使用 *shutdown()* 关闭连接的写入半部分，或者使用 *close()* 完全关闭其套接字。
- en: Output is possible on the socket (e.g., space has become available in the socket
    send buffer).
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字上可以进行输出操作（例如，套接字发送缓冲区中已腾出空间）。
- en: An asynchronous error occurs on the socket.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字上发生了异步错误。
- en: '*inotify* file descriptors'
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*inotify* 文件描述符'
- en: A signal is generated when the *inotify* file descriptor becomes readable—that
    is, when an event occurs for one of the files monitored by the *inotify* file
    descriptor.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *inotify* 文件描述符变为可读时，会生成一个信号——即，当 *inotify* 文件描述符监控的文件之一发生事件时。
- en: Refining the Use of Signal-Driven I/O
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 精细化信号驱动 I/O 的使用
- en: In applications that need to simultaneously monitor very large numbers (i.e.,
    thousands) of file descriptors—for example, certain types of network servers—signal-driven
    I/O can provide significant performance advantages by comparison with *select()*
    and *poll()*. Signal-driven I/O offers superior performance because the kernel
    “remembers” the list of file descriptors to be monitored, and signals the program
    only when I/O events actually occur on those descriptors. As a result, the performance
    of a program employing signal-driven I/O scales according to the number of I/O
    events that occur, rather than the number of file descriptors being monitored.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要同时监控大量（即数千个）文件描述符的应用程序中——例如，某些类型的网络服务器——信号驱动 I/O 相比于 *select()* 和 *poll()*，可以提供显著的性能优势。信号驱动
    I/O 提供了优越的性能，因为内核“记住”了需要监控的文件描述符列表，并且只有在这些描述符上发生 I/O 事件时才会向程序发送信号。因此，使用信号驱动 I/O
    的程序性能是根据发生的 I/O 事件数量来扩展的，而不是根据被监控的文件描述符数量。
- en: 'To take full advantage of signal-driven I/O, we must perform two steps:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用信号驱动 I/O，我们必须执行两个步骤：
- en: Employ a Linux-specific *fcntl()* operation, `F_SETSIG`, to specify a realtime
    signal that should be delivered instead of `SIGIO` when I/O is possible on a file
    descriptor.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Linux 特定的 *fcntl()* 操作 `F_SETSIG`，指定一个实时信号，当文件描述符上有 I/O 可用时，应该传递该信号而不是 `SIGIO`。
- en: Specify the `SA_SIGINFO` flag when using *sigaction()* to establish the handler
    for the realtime signal employed in the previous step (see Section 21.4).
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用 *sigaction()* 建立实时信号的处理程序时，指定 `SA_SIGINFO` 标志（参见第 21.4 节）。
- en: 'The *fcntl()* `F_SETSIG` operation specifies an alternative signal that should
    be delivered instead of `SIGIO` when I/O is possible on a file descriptor:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*fcntl()* `F_SETSIG` 操作指定一个替代信号，在文件描述符上有 I/O 可用时，应该传递该信号而不是 `SIGIO`：'
- en: '[PRE18]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `F_GETSIG` operation performs the converse of `F_SETSIG`, retrieving the
    signal currently set for a file descriptor:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`F_GETSIG` 操作执行 `F_SETSIG` 的反向操作，检索当前为文件描述符设置的信号：'
- en: '[PRE19]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: (In order to obtain the definitions of the `F_SETSIG` and `F_GETSIG` constants
    from `<fcntl.h>`, we must define the `_GNU_SOURCE` feature test macro.)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: （为了从`<fcntl.h>`中获取`F_SETSIG`和`F_GETSIG`常量的定义，我们必须定义`_GNU_SOURCE`功能测试宏。）
- en: 'Using `F_SETSIG` to change the signal used for “I/O possible” notification
    serves two purposes, both of which are needed if we are monitoring large numbers
    of I/O events on multiple file descriptors:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`F_SETSIG`更改用于“ I/O 可能”通知的信号有两个目的，这两个目的都是必需的，如果我们正在监视多个文件描述符上的大量I/O事件：
- en: The default “I/O possible” signal, `SIGIO`, is one of the standard, nonqueuing
    signals. If multiple I/O events are signaled while `SIGIO` is blocked—perhaps
    because the `SIGIO` handler is already invoked—all notifications except the first
    will be lost. If we use `F_SETSIG` to specify a realtime signal as the “I/O possible”
    signal, multiple notifications can be queued.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的“I/O 可能”信号`SIGIO`是标准的、非排队信号之一。如果在`SIGIO`被阻塞时发生多个I/O事件——可能是因为`SIGIO`处理程序已经被调用——除第一个通知外，所有通知都会丢失。如果我们使用`F_SETSIG`指定一个实时信号作为“I/O
    可能”信号，则可以排队多个通知。
- en: If the handler for the signal is established using a *sigaction()* call in which
    the `SA_SIGINFO` flag is specified in the *sa.sa_flags* field, then a *siginfo_t*
    structure is passed as the second argument to the signal handler (Section 21.4).
    This structure contains fields identifying the file descriptor on which the event
    occurred, as well as the type of event.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果信号的处理程序是通过在*sa.sa_flags*字段中指定`SA_SIGINFO`标志的*sigaction()*调用建立的，则*siginfo_t*结构体作为第二个参数传递给信号处理程序（第21.4节）。该结构体包含识别事件发生的文件描述符以及事件类型的字段。
- en: Note that the use of *both* `F_SETSIG` and `SA_SIGINFO` is required in order
    for a valid *siginfo_t* structure to be passed to the signal handler.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，必须同时使用*both* `F_SETSIG`和`SA_SIGINFO`，才能有效地将*siginfo_t*结构体传递给信号处理程序。
- en: 'If we perform an `F_SETSIG` operation specifying *sig* as 0, then we return
    to the default behavior: `SIGIO` is delivered, and a *siginfo_t* argument is not
    supplied to the handler.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行`F_SETSIG`操作，并将*sig*设置为0，则我们将恢复默认行为：`SIGIO`被传递，并且不会向处理程序提供*siginfo_t*参数。
- en: 'For an “I/O possible” event, the fields of interest in the *siginfo_t* structure
    passed to the signal handler are as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“ I/O 可能”事件，传递给信号处理程序的*siginfo_t*结构体中感兴趣的字段如下：
- en: '*si_signo*: the number of the signal that caused the invocation of the handler.
    This value is the same as the first argument to the signal handler.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*si_signo*：导致调用处理程序的信号的编号。这个值与信号处理程序的第一个参数相同。'
- en: '*si_fd*: the file descriptor for which the I/O event occurred.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*si_fd*：发生I/O事件的文件描述符。'
- en: '*si_code*: a code indicating the type of event that occurred. The values that
    can appear in this field, along with their general descriptions, are shown in
    [Table 63-7](ch63.html#si_underscore_code_and_si_underscore_ban "Table 63-7. si_code
    and si_band values in the siginfo_t structure for “I/O possible” events").'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*si_code*：指示发生的事件类型的代码。该字段中可能出现的值及其一般描述如下所示：[表63-7](ch63.html#si_underscore_code_and_si_underscore_ban
    "表63-7。*si_code*和*si_band*值在*siginfo_t*结构体中的‘I/O 可能’事件")。'
- en: '*si_band*: a bit mask containing the same bits as are returned in the *revents*
    field by the *poll()* system call. The value set in *si_code* has a one-to-one
    correspondence with the bit-mask setting in *si_band*, as shown in [Table 63-7](ch63.html#si_underscore_code_and_si_underscore_ban
    "Table 63-7. si_code and si_band values in the siginfo_t structure for “I/O possible”
    events").'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*si_band*：一个位掩码，包含与*poll()*系统调用中*revents*字段返回的相同位。*si_code*中设置的值与*si_band*中的位掩码设置具有一一对应关系，如[表63-7](ch63.html#si_underscore_code_and_si_underscore_ban
    "表63-7。*si_code*和*si_band*值在*siginfo_t*结构体中的‘I/O 可能’事件")所示。'
- en: Table 63-7. *si_code* and *si_band* values in the *siginfo_t* structure for
    “I/O possible” events
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表63-7。*si_code*和*si_band*值在*siginfo_t*结构体中的“ I/O 可能”事件
- en: '| *si_code* | *si_band* mask value | Description |'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| *si_code* | *si_band*掩码值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `POLL_IN` | `POLLIN &#124; POLLRDNORM` | Input available; end-of-file condition
    |'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `POLL_IN` | `POLLIN &#124; POLLRDNORM` | 输入可用；文件结尾条件 |'
- en: '| `POLL_OUT` | `POLLOUT &#124; POLLWRNORM &#124; POLLWRBAND` | Output possible
    |'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `POLL_OUT` | `POLLOUT &#124; POLLWRNORM &#124; POLLWRBAND` | 输出可能 |'
- en: '| `POLL_MSG` | `POLLIN &#124; POLLRDNORM &#124; POLLMSG` | Input message available
    (unused) |'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `POLL_MSG` | `POLLIN &#124; POLLRDNORM &#124; POLLMSG` | 输入消息可用（未使用） |'
- en: '| `POLL_ERR` | `POLLERR` | I/O error |'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `POLL_ERR` | `POLLERR` | I/O 错误 |'
- en: '| `POLL_PRI` | `POLLPRI &#124; POLLRDNORM` | High-priority input available
    |'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `POLL_PRI` | `POLLPRI &#124; POLLRDNORM` | 高优先级输入可用 |'
- en: '| `POLL_HUP` | `POLLHUP &#124; POLLERR` | Hangup occurred |'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `POLL_HUP` | `POLLHUP &#124; POLLERR` | 挂起发生 |'
- en: In an application that is purely input-driven, we can further refine the use
    of `F_SETSIG`. Instead of monitoring I/O events via a signal handler, we can block
    the nominated “I/O possible” signal, and then accept the queued signals via calls
    to *sigwaitinfo()* or *sigtimedwait()* (Section 22.10). These system calls return
    a *siginfo_t* structure that contains the same information as is passed to a signal
    handler established with `SA_SIGINFO`. Accepting signals in this manner returns
    us to a synchronous model of event processing, but with the advantage that we
    are much more efficiently notified about the file descriptors on which I/O events
    have occurred than if we use *select()* or *poll()*.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完全由输入驱动的应用程序中，我们可以进一步优化 `F_SETSIG` 的使用。我们可以阻止指定的“ I/O 可能”信号，而不是通过信号处理程序来监视
    I/O 事件，然后通过调用 *sigwaitinfo()* 或 *sigtimedwait()*（第 22.10 节）接受排队的信号。这些系统调用返回一个
    *siginfo_t* 结构，包含与通过 `SA_SIGINFO` 设置的信号处理程序传递的信息相同的内容。通过这种方式接受信号使我们回到了同步事件处理模型，但有一个优势，就是与使用
    *select()* 或 *poll()* 相比，我们可以更高效地收到有关发生 I/O 事件的文件描述符的通知。
- en: Handling signal-queue overflow
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理信号队列溢出
- en: We saw in Section 22.8 that there is a limit on the number of realtime signals
    that may be queued. If this limit is reached, the kernel reverts to delivering
    the default `SIGIO` signal for “I/O possible” notifications. This informs the
    process that a signal-queue overflow occurred. When this happens, we lose information
    about which file descriptors have I/O events, because `SIGIO` is not queued. (Furthermore,
    the `SIGIO` handler doesn’t receive a *siginfo_t* argument, which means that the
    signal handler can’t determine the file descriptor that generated the signal.)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 22.8 节中看到，实时信号队列的数量是有限制的。如果达到这个限制，内核将恢复使用默认的 `SIGIO` 信号来通知“ I/O 可能”。这会通知进程发生了信号队列溢出。当发生这种情况时，我们无法知道哪些文件描述符发生了
    I/O 事件，因为 `SIGIO` 并未被排队。（此外，`SIGIO` 处理程序不会接收到 *siginfo_t* 参数，这意味着信号处理程序无法确定哪个文件描述符产生了信号。）
- en: We can reduce the likelihood of signal-queue overflows by increasing the limit
    on the number of realtime signals that can be queued, as described in Section
    22.8\. However, this doesn’t eliminate the need to handle the possibility of an
    overflow. A properly designed application using `F_SETSIG` to establish a realtime
    signal as the “I/O possible” notification mechanism must also establish a handler
    for `SIGIO`. If `SIGIO` is delivered, then the application can drain the queue
    of realtime signals using *sigwaitinfo()* and temporarily revert to the use of
    *select()* or *poll()* to obtain a complete list of file descriptors with outstanding
    I/O events.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过增加实时信号队列的数量限制来减少信号队列溢出的可能性，如第 22.8 节所述。然而，这并不能消除处理溢出可能性的必要性。一个使用 `F_SETSIG`
    来建立实时信号作为“ I/O 可能”通知机制的合理设计应用程序，还必须为 `SIGIO` 建立一个处理程序。如果 `SIGIO` 被传递，则应用程序可以使用
    *sigwaitinfo()* 来清空实时信号队列，并暂时恢复使用 *select()* 或 *poll()* 来获得所有发生 I/O 事件的文件描述符的完整列表。
- en: Using signal-driven I/O with multithreaded applications
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用信号驱动的 I/O 与多线程应用
- en: 'Starting with kernel 2.6.32, Linux provides two new, nonstandard *fcntl()*
    operations that can be used to set the target for “I/O possible” signals: `F_SETOWN_EX`
    and `F_GETOWN_EX`.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核版本 2.6.32 开始，Linux 提供了两个新的非标准 *fcntl()* 操作，可以用来设置“ I/O 可能”信号的目标：`F_SETOWN_EX`
    和 `F_GETOWN_EX`。
- en: 'The `F_SETOWN_EX` operation is like `F_SETOWN`, but as well as allowing the
    target to be specified as a process or process group, it also permits a thread
    to be specified as the target for “I/O possible” signals. For this operation,
    the third argument of *fcntl()* is a pointer to a structure of the following form:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`F_SETOWN_EX` 操作类似于 `F_SETOWN`，但除了允许指定目标为进程或进程组外，还允许指定一个线程作为“ I/O 可能”信号的目标。对于此操作，*fcntl()*
    的第三个参数是指向以下结构的指针：'
- en: '[PRE20]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The *type* field defines the meaning of the *pid* field, and has one of the
    following values:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '*type* 字段定义了 *pid* 字段的含义，并且它有以下几种值：'
- en: '`F_OWNER_PGRP`'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`F_OWNER_PGRP`'
- en: The *pid* field specifies the ID of a process group that is to be the target
    of “I/O possible” signals. Unlike with `F_SETOWN`, a process group ID is specified
    as a positive value.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*pid* 字段指定了将成为“ I/O 可能”信号目标的进程组的 ID。与 `F_SETOWN` 不同，进程组 ID 被指定为正值。'
- en: '`F_OWNER_PID`'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`F_OWNER_PID`'
- en: The *pid* field specifies the ID of a process that is to be the target of “I/O
    possible” signals.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*pid* 字段指定了将成为“ I/O 可能”信号目标的进程的 ID。'
- en: '`F_OWNER_TID`'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`F_OWNER_TID`'
- en: The *pid* field specifies the ID of a thread that is to be the target of “I/O
    possible” signals. The ID specified in *pid* is a value returned by *clone()*
    or *gettid()*.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '*pid* 字段指定将成为“ I/O 可用”信号目标的线程的 ID。*pid* 中指定的 ID 是通过 *clone()* 或 *gettid()*
    返回的值。'
- en: The `F_GETOWN_EX` operation is the converse of the `F_GETOWN_EX` operation.
    It uses the *f_owner_ex* structure pointed to by the third argument of *fcntl()*
    to return the settings defined by a previous `F_SETOWN_EX` operation.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`F_GETOWN_EX` 操作是 `F_SETOWN_EX` 操作的逆操作。它使用 *fcntl()* 的第三个参数所指向的 *f_owner_ex*
    结构，返回由先前的 `F_SETOWN_EX` 操作定义的设置。'
- en: Note
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because the `F_SETOWN_EX` and `F_GETOWN_EX` operations represent process group
    IDs as positive values, `F_GETOWN_EX` doesn’t suffer the problem described earlier
    for `F_GETOWN` when using process group IDs less than 4096.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `F_SETOWN_EX` 和 `F_GETOWN_EX` 操作表示进程组 ID 为正值，因此 `F_GETOWN_EX` 在使用小于 4096
    的进程组 ID 时不会遇到 `F_GETOWN` 中描述的问题。
- en: The *epoll* API
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*epoll* API'
- en: 'Like the I/O multiplexing system calls and signal-driven I/O, the Linux *epoll*
    (event poll) API is used to monitor multiple file descriptors to see if they are
    ready for I/O. The primary advantages of the *epoll* API are the following:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 与 I/O 多路复用系统调用和信号驱动 I/O 类似，Linux 的 *epoll*（事件轮询）API 用于监控多个文件描述符，查看它们是否准备好进行
    I/O 操作。*epoll* API 的主要优势如下：
- en: The performance of *epoll* scales much better than *select()* and *poll()* when
    monitoring large numbers of file descriptors.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当监控大量文件描述符时，*epoll* 的性能比 *select()* 和 *poll()* 要好得多。
- en: The *epoll* API permits either level-triggered or edge-triggered notification.
    By contrast, *select()* and *poll()* provide only level-triggered notification,
    and signal-driven I/O provides only edge-triggered notification.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*epoll* API 支持触发模式为水平触发或边缘触发的通知。相比之下，*select()* 和 *poll()* 仅提供水平触发通知，而信号驱动
    I/O 仅提供边缘触发通知。'
- en: 'The performance of *epoll* and signal-driven I/O is similar. However, *epoll*
    has some advantages over signal-driven I/O:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '*epoll* 和信号驱动 I/O 的性能类似。然而，*epoll* 相比信号驱动 I/O 有一些优势：'
- en: We avoid the complexities of signal handling (e.g., signal-queue overflow).
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们避免了信号处理的复杂性（例如，信号队列溢出）。
- en: We have greater flexibility in specifying what kind of monitoring we want to
    perform (e.g., checking to see if a file descriptor for a socket is ready for
    reading, writing, or both).
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在指定希望执行的监控类型时具有更大的灵活性（例如，检查某个套接字的文件描述符是否准备好进行读取、写入或两者兼有）。
- en: The *epoll* API is Linux-specific, and is new in Linux 2.6.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '*epoll* API 是 Linux 特有的，且在 Linux 2.6 中新增。'
- en: 'The central data structure of the *epoll* API is an *epoll instance*, which
    is referred to via an open file descriptor. This file descriptor is not used for
    I/O. Instead, it is a handle for kernel data structures that serve two purposes:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '*epoll* API 的核心数据结构是 *epoll 实例*，通过一个打开的文件描述符来引用该实例。这个文件描述符不用于 I/O 操作，而是作为内核数据结构的句柄，具有两个用途：'
- en: recording a list of file descriptors that this process has declared an interest
    in monitoring—the *interest list*; and
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录此进程声明希望监控的文件描述符列表——*兴趣列表*；以及
- en: maintaining a list of file descriptors that are ready for I/O—the *ready list*.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护一个准备好进行 I/O 操作的文件描述符列表——*就绪列表*。
- en: The membership of the ready list is a subset of the interest list.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 准备就绪列表的成员是兴趣列表的一个子集。
- en: For each file descriptor monitored by *epoll*, we can specify a bit mask indicating
    events that we are interested in knowing about. These bit masks correspond closely
    to the bit masks used with *poll()*.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个由 *epoll* 监控的文件描述符，我们可以指定一个位掩码，表示我们希望了解的事件。这些位掩码与 *poll()* 使用的位掩码非常相似。
- en: 'The *epoll* API consists of three system calls:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '*epoll* API 包含三个系统调用：'
- en: The *epoll_create()* system call creates an *epoll* instance and returns a file
    descriptor referring to the instance.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*epoll_create()* 系统调用创建一个 *epoll* 实例并返回一个引用该实例的文件描述符。'
- en: The *epoll_ctl()* system call manipulates the interest list associated with
    an *epoll* instance. Using *epoll_ctl()*, we can add a new file descriptor to
    the list, remove an existing descriptor from the list, and modify the mask that
    determines which events are to be monitored for a descriptor.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*epoll_ctl()* 系统调用用于操作与 *epoll* 实例相关联的兴趣列表。通过 *epoll_ctl()*，我们可以将一个新的文件描述符添加到列表中，移除现有描述符，或修改用于监控某个描述符的事件掩码。'
- en: The *epoll_wait()* system call returns items from the ready list associated
    with an *epoll* instance.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*epoll_wait()* 系统调用返回与 *epoll* 实例关联的准备就绪列表中的项目。'
- en: 'Creating an *epoll* Instance: *epoll_create()*'
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 *epoll* 实例：*epoll_create()*
- en: The *epoll_create()* system call creates a new *epoll* instance whose interest
    list is initially empty.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '*epoll_create()* 系统调用创建一个新的 *epoll* 实例，其兴趣列表最初为空。'
- en: '[PRE21]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns file descriptor on success, or -1 on error
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件描述符，错误时返回 -1
- en: The *size* argument specifies the number of file descriptors that we expect
    to monitor via the *epoll* instance. This argument is not an upper limit, but
    rather a hint to the kernel about how to initially dimension internal data structures.
    (Since Linux 2.6.8, the *size* argument must be greater than zero but is otherwise
    ignored, because changes in the implementation meant that the information it provided
    is no longer required.)
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '*size* 参数指定我们期望通过 *epoll* 实例监视的文件描述符数量。该参数不是上限，而是向内核提供的提示，指示如何初始分配内部数据结构。（从
    Linux 2.6.8 开始，*size* 参数必须大于零，但否则会被忽略，因为实现的变化意味着该信息已不再需要。）'
- en: As its function result, *epoll_create()* returns a file descriptor referring
    to the new *epoll* instance. This file descriptor is used to refer to the *epoll*
    instance in other *epoll* system calls. When the file descriptor is no longer
    required, it should be closed in the usual way, using *close()*. When all file
    descriptors referring to an *epoll* instance are closed, the instance is destroyed
    and its associated resources are released back to the system. (Multiple file descriptors
    may refer to the same *epoll* instance as a consequence of calls to *fork()* or
    descriptor duplication using *dup()* or similar.)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 作为其功能结果，*epoll_create()* 返回一个文件描述符，指向新的 *epoll* 实例。该文件描述符用于在其他 *epoll* 系统调用中引用
    *epoll* 实例。当不再需要该文件描述符时，应按常规方式使用 *close()* 关闭。当所有引用 *epoll* 实例的文件描述符被关闭时，该实例将被销毁，并且其相关资源将被释放回系统。（由于调用
    *fork()* 或使用 *dup()* 或类似方法进行描述符复制，多个文件描述符可能会引用同一个 *epoll* 实例。）
- en: Note
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Starting with kernel 2.6.27, Linux supports a new system call, *epoll_create1()*.
    This system call performs the same task as *epoll_create()*, but drops the obsolete
    *size* argument and adds a flags argument that can be used to modify the behavior
    of the system call. One flag is currently supported: `EPOLL_CLOEXEC`, which causes
    the kernel to enable the close-on-exec flag `(FD_CLOEXEC)` for the new file descriptor.
    This flag is useful for the same reasons as the *open()* `O_CLOEXEC` flag described
    in [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()").'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核 2.6.27 开始，Linux 支持一个新的系统调用 *epoll_create1()*。该系统调用执行与 *epoll_create()* 相同的任务，但去除了过时的
    *size* 参数，并添加了一个 flags 参数，用于修改系统调用的行为。目前支持的一个标志是 `EPOLL_CLOEXEC`，它使内核为新的文件描述符启用
    close-on-exec 标志 `(FD_CLOEXEC)`。这个标志与 *open()* 的 `O_CLOEXEC` 标志类似，原因请参见 [由 *open()*
    返回的文件描述符号](ch04.html#file_descriptor_number_returned_by-id1 "由 open() 返回的文件描述符号")。
- en: 'Modifying the *epoll* Interest List: *epoll_ctl()*'
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改 *epoll* 兴趣列表：*epoll_ctl()*
- en: The *epoll_ctl()* system call modifies the interest list of the *epoll* instance
    referred to by the file descriptor *epfd*.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '*epoll_ctl()* 系统调用修改由文件描述符 *epfd* 引用的 *epoll* 实例的兴趣列表。'
- en: '[PRE22]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: The *fd* argument identifies which of the file descriptors in the interest list
    is to have its settings modified. This argument can be a file descriptor for a
    pipe, FIFO, socket, POSIX message queue, *inotify* instance, terminal, device,
    or even another *epoll* descriptor (i.e., we can build a kind of hierarchy of
    monitored descriptors). However, *fd* can’t be a file descriptor for a regular
    file or a directory (the error `EPERM` results).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '*fd* 参数标识兴趣列表中要修改设置的文件描述符。此参数可以是管道、FIFO、套接字、POSIX 消息队列、*inotify* 实例、终端、设备，甚至是另一个
    *epoll* 描述符的文件描述符（即，我们可以构建一个监视描述符的层次结构）。然而，*fd* 不能是常规文件或目录的文件描述符（会导致错误 `EPERM`）。'
- en: 'The *op* argument specifies the operation to be performed, and has one of the
    following values:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '*op* 参数指定要执行的操作，并具有以下值之一：'
- en: '`EPOLL_CTL_ADD`'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`EPOLL_CTL_ADD`'
- en: Add the file descriptor *fd* to the interest list for *epfd*. The set of events
    that we are interested in monitoring for *fd* is specified in the buffer pointed
    to by *ev*, as described below. If we attempt to add a file descriptor that is
    already in the interest list, *epoll_ctl()* fails with the error `EEXIST`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件描述符 *fd* 添加到 *epfd* 的兴趣列表中。我们希望监视 *fd* 的事件集合在 *ev* 指向的缓冲区中指定，如下所述。如果我们尝试添加一个已经在兴趣列表中的文件描述符，*epoll_ctl()*
    会因错误 `EEXIST` 而失败。
- en: '`EPOLL_CTL_MOD`'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`EPOLL_CTL_MOD`'
- en: Modify the events setting for the file descriptor *fd*, using the information
    specified in the buffer pointed to by *ev*. If we attempt to modify the settings
    of a file descriptor that is not in the interest list for *epfd*, *epoll_ctl()*
    fails with the error `ENOENT`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 修改文件描述符 *fd* 的事件设置，使用 *ev* 指向的缓冲区中指定的信息。如果我们尝试修改一个不在 *epfd* 兴趣列表中的文件描述符的设置，*epoll_ctl()*
    会因错误 `ENOENT` 而失败。
- en: '`EPOLL_CTL_DEL`'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`EPOLL_CTL_DEL`'
- en: Remove the file descriptor *fd* from the interest list for *epfd*. The *ev*
    argument is ignored for this operation. If we attempt to remove a file descriptor
    that is not in the interest list for *epfd*, *epoll_ctl()* fails with the error
    `ENOENT`. Closing a file descriptor automatically removes it from all of the epoll
    interest lists of which it is a member.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *epfd* 的兴趣列表中移除文件描述符 *fd*。此操作忽略 *ev* 参数。如果我们尝试移除一个不在 *epfd* 兴趣列表中的文件描述符，*epoll_ctl()*
    会因错误 `ENOENT` 而失败。关闭文件描述符会自动将其从所有包含它的 epoll 兴趣列表中移除。
- en: 'The *ev* argument is a pointer to a structure of type *epoll_event*, defined
    as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '*ev* 参数是指向类型为 *epoll_event* 的结构体的指针，其定义如下：'
- en: '[PRE23]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The *data* field of the *epoll_event* structure is typed as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '*epoll_event* 结构体的 *data* 字段的类型如下：'
- en: '[PRE24]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The *ev* argument specifies settings for the file descriptor *fd*, as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '*ev* 参数指定文件描述符 *fd* 的设置，具体如下：'
- en: The *events* subfield is a bit mask specifying the set of events that we are
    interested in monitoring for *fd*. We say more about the bit values that can be
    used in this field in the next section.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*events* 子字段是一个位掩码，指定我们感兴趣的文件描述符 *fd* 的事件集合。在下一节中，我们将详细说明可以在此字段中使用的位值。'
- en: The *data* subfield is a union, one of whose members can be used to specify
    information that is passed back to the calling process (via *epoll_wait()*) if
    *fd* later becomes ready.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*data* 子字段是一个联合体，其成员之一可以用来指定如果 *fd* 后来变为就绪状态时，通过 *epoll_wait()* 返回给调用进程的信息。'
- en: '[Example 63-4](ch63.html#using_epoll_underscore_create_open_paren "Example 63-4. Using
    epoll_create() and epoll_ctl()") shows an example of the use of *epoll_create()*
    and *epoll_ctl()*.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 63-4](ch63.html#using_epoll_underscore_create_open_paren "示例 63-4. 使用 epoll_create()
    和 epoll_ctl()") 展示了 *epoll_create()* 和 *epoll_ctl()* 的使用示例。'
- en: Example 63-4. Using *epoll_create()* and *epoll_ctl()*
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 63-4. 使用 *epoll_create()* 和 *epoll_ctl()*
- en: '[PRE25]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `max_user_watches` limit
  id: totrans-447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`max_user_watches` 限制'
- en: Because each file descriptor registered in an *epoll* interest list requires
    a small amount of nonswappable kernel memory, the kernel provides an interface
    that defines a limit on the total number of file descriptors that each user can
    register in all *epoll* interest lists. The value of this limit can be viewed
    and modified via `max_user_watches`, a Linux-specific file in the `/proc/sys/fs/epoll`
    directory. The default value of this limit is calculated based on available system
    memory (see the *epoll(7)* manual page).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在 *epoll* 兴趣列表中注册的每个文件描述符都需要少量不可交换的内核内存，内核提供了一个接口，定义了每个用户可以在所有 *epoll* 兴趣列表中注册的文件描述符的总数的限制。此限制的值可以通过
    `/proc/sys/fs/epoll` 目录中的一个 Linux 特有的文件 `max_user_watches` 查看和修改。此限制的默认值是根据可用的系统内存计算的（请参阅
    *epoll(7)* 手册页）。
- en: 'Waiting for Events: *epoll_wait()*'
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等待事件：*epoll_wait()*
- en: The *epoll_wait()* system call returns information about ready file descriptors
    from the *epoll* instance referred to by the file descriptor *epfd*. A single
    *epoll_wait()* call can return information about multiple ready file descriptors.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '*epoll_wait()* 系统调用返回有关文件描述符 *epfd* 所引用的 *epoll* 实例中就绪文件描述符的信息。单次 *epoll_wait()*
    调用可以返回多个就绪文件描述符的信息。'
- en: '[PRE26]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of ready file descriptors, 0 on timeout, or -1 on error
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 返回就绪文件描述符的数量，超时时返回 0，出错时返回 -1。
- en: The information about ready file descriptors is returned in the array of *epoll_event*
    structures pointed to by *evlist*. (The *epoll_event* structure was described
    in the previous section.) The *evlist* array is allocated by the caller, and the
    number of elements it contains is specified in *maxevents*.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 有关就绪文件描述符的信息通过 *evlist* 指向的 *epoll_event* 结构体数组返回。（*epoll_event* 结构体在上一节中已描述。）*evlist*
    数组由调用者分配，其包含的元素数量由 *maxevents* 指定。
- en: Each item in the array *evlist* returns information about a single ready file
    descriptor. The *events* subfield returns a mask of the events that have occurred
    on this descriptor. The *data* subfield returns whatever value was specified in
    *ev.data* when we registered interest in this file descriptor using *epoll_ctl()*.
    Note that the *data* field provides the only mechanism for finding out the number
    of the file descriptor associated with this event. Thus, when we make the *epoll_ctl()*
    call that places a file descriptor in the interest list, we should either set
    *ev.data.fd* to the file descriptor number (as shown in [Example 63-4](ch63.html#using_epoll_underscore_create_open_paren
    "Example 63-4. Using epoll_create() and epoll_ctl()")) or set *ev.data.ptr* to
    point to a structure that contains the file descriptor number.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 数组*evlist*中的每一项返回关于单个就绪文件描述符的信息。*events*子字段返回该描述符上发生的事件的掩码。*data*子字段返回在我们使用*epoll_ctl()*注册对该文件描述符的兴趣时，指定的任何值。请注意，*data*字段是唯一能让我们找出与此事件相关联的文件描述符号的机制。因此，当我们调用*epoll_ctl()*将文件描述符添加到兴趣列表时，我们应该将*ev.data.fd*设置为文件描述符号（如[示例63-4](ch63.html#using_epoll_underscore_create_open_paren
    "示例63-4. 使用epoll_create()和epoll_ctl()")所示），或者将*ev.data.ptr*设置为指向包含文件描述符号的结构体。
- en: 'The *timeout* argument determines the blocking behavior of *epoll_wait()*,
    as follows:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '*timeout*参数决定了*epoll_wait()*的阻塞行为，如下所示：'
- en: If *timeout* equals -1, block until an event occurs for one of the file descriptors
    in the interest list for *epfd* or until a signal is caught.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*timeout*等于-1，阻塞直到一个事件发生在*epfd*的兴趣列表中的某个文件描述符上，或者直到捕获到信号。
- en: If *timeout* equals 0, perform a nonblocking check to see which events are currently
    available on the file descriptors in the interest list for *epfd*.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*timeout*等于0，执行非阻塞检查，查看*epfd*的兴趣列表中哪些事件当前可用。
- en: If *timeout* is greater than 0, block for up to *timeout* milliseconds, until
    an event occurs on one of the file descriptors in the interest list for *epfd*,
    or until a signal is caught.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*timeout*大于0，则阻塞最多*timeout*毫秒，直到在*epfd*的兴趣列表中的某个文件描述符上发生事件，或者直到捕获到信号。
- en: On success, *epoll_wait()* returns the number of items that have been placed
    in the array *evlist*, or 0 if no file descriptors were ready within the interval
    specified by *timeout*. On error, *epoll_wait()* returns -1, with *errno* set
    to indicate the error.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，*epoll_wait()*返回已放入数组*evlist*中的项目数，或者如果在*timeout*指定的时间间隔内没有文件描述符准备好，则返回0。如果发生错误，*epoll_wait()*返回-1，并将*errno*设置为指示错误。
- en: In a multithreaded program, it is possible for one thread to use *epoll_ctl()*
    to add file descriptors to the interest list of an epoll instance that is already
    being monitored by *epoll_wait()* in another thread. These changes to the interest
    list will be taken into account immediately, and the *epoll_wait()* call will
    return readiness information about the newly added file descriptors.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程程序中，可能有一个线程使用*epoll_ctl()*将文件描述符添加到已由另一个线程的*epoll_wait()*监视的epoll实例的兴趣列表中。这些对兴趣列表的更改会立即生效，*epoll_wait()*调用将返回关于新添加的文件描述符的就绪信息。
- en: '*epoll* events'
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*epoll*事件'
- en: The bit values that can be specified in *ev.events* when we call *epoll_ctl()*
    and that are placed in the *evlist[].events* fields returned by *epoll_wait()*
    are shown in [Table 63-8](ch63.html#bit-mask_values_for_the_epoll_events_fie "Table 63-8. Bit-mask
    values for the epoll events field"). With the addition of an `E` prefix, most
    of these bits have names that are the same as the corresponding event bits used
    with *poll()*. (The exceptions are `EPOLLET` and `EPOLLONESHOT`, which we describe
    in more detail below.) The reason for this correspondence is that, when specified
    as input to *epoll_ctl()* or returned as output via *epoll_wait()*, these bits
    convey exactly the same meaning as the corresponding *poll()* event bits.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在调用*epoll_ctl()*时可以指定的位值，以及*epoll_wait()*返回的*evlist[].events*字段中放置的值，见[表63-8](ch63.html#bit-mask_values_for_the_epoll_events_fie
    "表63-8. epoll事件字段的位掩码值")。通过添加`E`前缀，大部分这些位与*poll()*中使用的相应事件位名称相同。（例外的是`EPOLLET`和`EPOLLONESHOT`，我们将在下面更详细地描述它们。）这种对应关系的原因是，当这些位作为输入指定给*epoll_ctl()*，或者通过*epoll_wait()*返回作为输出时，它们传达的含义与相应的*poll()*事件位完全相同。
- en: Table 63-8. Bit-mask values for the *epoll events* field
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 表63-8. *epoll事件*字段的位掩码值
- en: '| Bit | Input to *epoll_ctl()?* | Returned by *epoll_wait()?* | Description
    |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| 位 | 输入到*epoll_ctl()*? | *epoll_wait()*返回? | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `EPOLLIN` | • | • | Data other than high-priority data can be read |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| `EPOLLIN` | • | • | 可以读取除高优先级数据外的其他数据 |'
- en: '| `EPOLLPRI` | • | • | High-priority data can be read |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| `EPOLLPRI` | • | • | 可以读取高优先级数据 |'
- en: '| `EPOLLRDHUP` | • | • | Shutdown on peer socket (since Linux 2.6.17) |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| `EPOLLRDHUP` | • | • | 对等套接字的关闭（自Linux 2.6.17起） |'
- en: '| `EPOLLOUT` | • | • | Normal data can be written |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| `EPOLLOUT` | • | • | 可以写入正常数据 |'
- en: '| `EPOLLET` | • |   | Employ edge-triggered event notification |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| `EPOLLET` | • |   | 使用边缘触发事件通知 |'
- en: '| `EPOLLONESHOT` | • |   | Disable monitoring after event notification |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| `EPOLLONESHOT` | • |   | 事件通知后禁用监控 |'
- en: '| `EPOLLERR` |   | • | An error has occurred |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| `EPOLLERR` |   | • | 发生错误 |'
- en: '| `EPOLLHUP` |   | • | A hangup has occurred |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| `EPOLLHUP` |   | • | 发生挂起 |'
- en: The EPOLLONESHOT flag
  id: totrans-475
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`EPOLLONESHOT`标志'
- en: By default, once a file descriptor is added to an *epoll* interest list using
    the *epoll_ctl()* `EPOLL_CTL_ADD` operation, it remains active (i.e., subsequent
    calls to *epoll_wait()* will inform us whenever the file descriptor is ready)
    until we explicitly remove it from the list using the *epoll_ctl()* `EPOLL_CTL_DEL`
    operation. If we want to be notified only once about a particular file descriptor,
    then we can specify the `EPOLLONESHOT` flag (available since Linux 2.6.2) in the
    *ev.events* value passed in *epoll_ctl()*. If this flag is specified, then, after
    the next *epoll_wait()* call that informs us that the corresponding file descriptor
    is ready, the file descriptor is marked inactive in the interest list, and we
    won’t be informed about its state by future *epoll_wait()* calls. If desired,
    we can subsequently reenable monitoring of this file descriptor using the *epoll_ctl()*
    `EPOLL_CTL_MOD` operation. (We can’t use the `EPOLL_CTL_ADD` operation for this
    purpose, because the inactive file descriptor is still part of the *epoll* interest
    list.)
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，一旦使用*epoll_ctl()*的`EPOLL_CTL_ADD`操作将文件描述符添加到*epoll*兴趣列表中，它将保持活跃状态（即，后续调用*epoll_wait()*时，会在文件描述符准备好时通知我们），直到我们明确使用*epoll_ctl()*的`EPOLL_CTL_DEL`操作将其从列表中移除。如果我们只希望收到一次特定文件描述符的通知，可以在传递给*epoll_ctl()*的*ev.events*值中指定`EPOLLONESHOT`标志（自Linux
    2.6.2版本起提供）。如果指定了此标志，那么，在下次*epoll_wait()*调用通知我们对应的文件描述符已准备好之后，文件描述符将被标记为非活动状态，后续的*epoll_wait()*调用将不会再通知它的状态。如果需要，我们可以使用*epoll_ctl()*的`EPOLL_CTL_MOD`操作重新启用对该文件描述符的监控。（我们不能使用`EPOLL_CTL_ADD`操作来达到这个目的，因为非活动的文件描述符仍然是*epoll*兴趣列表的一部分。）
- en: Example program
  id: totrans-477
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 63-5](ch63.html#using_the_epoll_api "Example 63-5. Using the epoll
    API") demonstrates the use of the *epoll* API. As command-line arguments, this
    program expects the pathnames of one or more terminals or FIFOs. The program performs
    the following steps:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 63-5](ch63.html#using_the_epoll_api "示例 63-5. 使用epoll API")演示了如何使用*epoll*
    API。作为命令行参数，程序期望一个或多个终端或FIFO的路径名。程序执行以下步骤：'
- en: Create an *epoll* instance ![](figs/web/U001.png).
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个*epoll*实例！[](figs/web/U001.png)。
- en: Open each of the files named on the command line for input ![](figs/web/U002.png)
    and add the resulting file descriptor to the interest list of the *epoll* instance
    ![](figs/web/U003.png), specifying the set of events to be monitored as `EPOLLIN`.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开命令行中指定的每个文件进行输入！[](figs/web/U002.png)，并将结果文件描述符添加到*epoll*实例的兴趣列表中！[](figs/web/U003.png)，同时指定要监控的事件集为`EPOLLIN`。
- en: 'Execute a loop ![](figs/web/U004.png) that calls *epoll_wait()* ![](figs/web/U005.png)
    to monitor the interest list of the *epoll* instance and handles the returned
    events from each call. Note the following points about this loop:'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个循环！[](figs/web/U004.png)，该循环调用*epoll_wait()*！[](figs/web/U005.png)来监控*epoll*实例的兴趣列表，并处理每次调用返回的事件。请注意以下几点：
- en: After the *epoll_wait()* call, the program checks for an `EINTR` return ![](figs/web/U006.png),
    which may occur if the program was stopped by a signal in the middle of the *epoll_wait()*
    call and then resumed by `SIGCONT`. (Refer to Section 21.5.) If this occurs, the
    program restarts the *epoll_wait()* call.
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*epoll_wait()*调用之后，程序会检查是否返回`EINTR`！[](figs/web/U006.png)，这种情况可能发生在程序在*epoll_wait()*调用的过程中被信号中断，随后通过`SIGCONT`信号恢复运行时。（参见第21.5节。）如果发生这种情况，程序将重新启动*epoll_wait()*调用。
- en: It the *epoll_wait()* call was successful, the program uses a further loop to
    check each of the ready items in *evlist* ![](figs/web/U007.png). For each item
    in *evlist*, the program checks the *events* field for the presence of not just
    `EPOLLIN` ![](figs/web/U008.png), but also `EPOLLHUP` and `EPOLLERR` ![](figs/web/U009.png).
    These latter events can occur if the other end of a FIFO was closed or a terminal
    hangup occurred. If `EPOLLIN` was returned, then the program reads some input
    from the corresponding file descriptor and displays it on standard output. Otherwise,
    if either `EPOLLHUP` or `EPOLLERR` occurred, the program closes the corresponding
    file descriptor ![](figs/web/U010.png) and decrements the counter of open files
    (*numOpenFds*).
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*epoll_wait()*调用成功，程序会使用一个进一步的循环检查*evlist*中的每个就绪项 ![](figs/web/U007.png)。对于*evlist*中的每个项，程序会检查*events*字段，不仅检查是否存在`EPOLLIN`
    ![](figs/web/U008.png)，还会检查是否存在`EPOLLHUP`和`EPOLLERR` ![](figs/web/U009.png)。这些事件可能发生在FIFO的另一端被关闭或发生终端挂起时。如果返回了`EPOLLIN`，则程序会从相应的文件描述符读取一些输入并显示到标准输出上。否则，如果发生了`EPOLLHUP`或`EPOLLERR`，程序会关闭相应的文件描述符
    ![](figs/web/U010.png) 并减少打开文件的计数器（*numOpenFds*）。
- en: The loop terminates when all open file descriptors have been closed (i.e., when
    *numOpenFds* equals 0).
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有打开的文件描述符都被关闭时（即当*numOpenFds*等于0时），循环终止。
- en: The following shell session logs demonstrate the use of the program in [Example 63-5](ch63.html#using_the_epoll_api
    "Example 63-5. Using the epoll API"). We use two terminal windows. In one window,
    we use the program in [Example 63-5](ch63.html#using_the_epoll_api "Example 63-5. Using
    the epoll API") to monitor two FIFOs for input. (Each open of a FIFO for reading
    by this program will complete only after another process has opened the FIFO for
    writing, as described in Section 44.7.) In the other window, we run instances
    of *cat(1)* that write data to these FIFOs.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Shell会话日志演示了[示例63-5](ch63.html#using_the_epoll_api "示例63-5. 使用epoll API")中程序的使用方法。我们使用两个终端窗口。在一个窗口中，我们使用[示例63-5](ch63.html#using_the_epoll_api
    "示例63-5. 使用epoll API")中的程序来监视两个FIFO的输入。（本程序对FIFO进行读取的每一次打开，只有在另一个进程已打开FIFO进行写入之后才能完成，正如第44.7节所述。）在另一个窗口中，我们运行*cat(1)*实例，将数据写入这些FIFO。
- en: '[PRE27]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Above, we suspended our monitoring program so that we can now generate input
    on both FIFOs, and close the write end of one of them:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容中，我们暂停了监控程序，以便现在可以在两个FIFO上生成输入，并关闭其中一个的写入端：
- en: '[PRE28]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we resume our monitoring program by bringing it into the foreground, at
    which point *epoll_wait()* returns two events:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过将监控程序带到前台来恢复它的运行，此时*epoll_wait()*返回两个事件：
- en: '[PRE29]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The two blank lines in the above output are the newlines that were read by the
    instances of *cat*, written to the FIFOs, and then read and echoed by our monitoring
    program.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出中的两个空行是由*cat*的实例读取后写入FIFO，再由我们的监控程序读取并回显的换行符。
- en: 'Now we type *Control-D* in the second terminal window in order to terminate
    the remaining instance of *cat*, which causes *epoll_wait()* to once more return,
    this time with a single event:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在第二个终端窗口中输入*Control-D*，以终止剩余的*cat*实例，这会导致*epoll_wait()*再次返回，这次只有一个事件：
- en: '[PRE30]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Example 63-5. Using the *epoll* API
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 63-5. 使用*epoll* API
- en: '[PRE31]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A Closer Look at *epoll* Semantics
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更深入地了解*epoll*语义
- en: We now look at some subtleties of the interaction of open files, file descriptors,
    and *epoll*. For the purposes of this discussion, it is worth reviewing [Figure 5-2](ch05.html#relationship_between_file_descriptors_co
    "Figure 5-2. Relationship between file descriptors, open file descriptions, and
    i-nodes") (page 95), which shows the relationship between file descriptors, open
    file descriptions, and the system-wide file i-node table.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在来看一下打开文件、文件描述符和*epoll*交互的细微之处。为了讨论的需要，值得回顾一下[图 5-2](ch05.html#relationship_between_file_descriptors_co
    "图 5-2. 文件描述符、打开文件描述符和i节点之间的关系")（第95页），该图展示了文件描述符、打开的文件描述符和系统范围的文件i节点表之间的关系。
- en: 'When we create an *epoll* instance using *epoll_create()*, the kernel creates
    a new in-memory i-node and open file description, and allocates a new file descriptor
    in the calling process that refers to the open file description. The interest
    list for an *epoll* instance is associated with the open file description, not
    with the *epoll* file descriptor. This has the following consequences:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用*epoll_create()*创建一个*epoll*实例时，内核会创建一个新的内存中的i节点和打开的文件描述符，并在调用进程中分配一个新的文件描述符，该文件描述符指向打开的文件描述符。*epoll*实例的兴趣列表与打开的文件描述符关联，而不是与*epoll*文件描述符关联。这有以下几个后果：
- en: If we duplicate an *epoll* file descriptor using *dup()* (or similar), then
    the duplicated descriptor refers to the same *epoll* interest and ready lists
    as the original descriptor. We may modify the interest list by specifying either
    file descriptor as the *epfd* argument in a call to *epoll_ctl()*. Similarly,
    we can retrieve items from the ready list by specifying either file descriptor
    as the *epfd* argument in a call to *epoll_wait()*.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用*dup()*（或类似方法）复制一个*epoll*文件描述符，那么该复制的描述符将指向与原始描述符相同的*epoll*兴趣列表和就绪列表。我们可以通过在调用*epoll_ctl()*时将任一文件描述符指定为*epfd*参数来修改兴趣列表。同样，我们可以通过在调用*epoll_wait()*时将任一文件描述符指定为*epfd*参数来从就绪列表中检索项目。
- en: The preceding point also applies after a call to *fork()*. The child inherits
    a duplicate of the parent’s *epoll* file descriptor, and this duplicate descriptor
    refers to the same *epoll* data structures.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前述的情况在调用*fork()*后也适用。子进程继承父进程的*epoll*文件描述符的副本，并且这个副本描述符指向相同的*epoll*数据结构。
- en: 'When we perform an *epoll_ctl()* `EPOLL_CTL_ADD` operation, the kernel adds
    an item to the *epoll* interest list that records both the number of the monitored
    file descriptor and a reference to the corresponding open file description. For
    the purpose of *epoll_wait()* calls, the kernel monitors the open file description.
    This means that we must refine our earlier statement that when a file descriptor
    is closed, it is automatically removed from any *epoll* interest lists of which
    it is a member. The refinement is this: an open file description is removed from
    the *epoll* interest list once all file descriptors that refer to it have been
    closed. This means that if we create duplicate descriptors referring to an open
    file—using *dup()* (or similar) or *fork()*—then the open file will be removed
    only after the original descriptor and all of the duplicates have been closed.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行*epoll_ctl()*的`EPOLL_CTL_ADD`操作时，内核会将一个项目添加到*epoll*兴趣列表中，记录被监视的文件描述符的编号以及对相应打开文件描述符的引用。为了*epoll_wait()*调用的目的，内核监视打开的文件描述符。这意味着我们需要完善之前的说法，即当文件描述符关闭时，它会自动从所有包含它的*epoll*兴趣列表中移除。完善后的说法是：只有当所有指向某个打开文件描述符的文件描述符都关闭时，打开文件描述符才会从*epoll*兴趣列表中移除。这意味着，如果我们创建指向一个打开文件的重复描述符——使用*dup()*（或类似方法）或*fork()*——那么只有在原始描述符和所有重复描述符都关闭之后，打开文件才会从*epoll*兴趣列表中移除。
- en: These semantics can lead to some behavior that at first appears surprising.
    Suppose that we execute the code shown in [Example 63-6](ch63.html#semantics_of_epoll_with_duplicate_file_d
    "Example 63-6. Semantics of epoll with duplicate file descriptors"). The *epoll_wait()*
    call in this code will tell us that the file descriptor *fd1* is ready (in other
    words, *evlist[0].data.fd* will be equal to *fd1*), even though *fd1* has been
    closed. This is because there is still one open file descriptor, *fd2*, referring
    to the open file description contained in the *epoll* interest list. A similar
    scenario occurs when two processes hold duplicate descriptors for the same open
    file description (typically, as a result of a *fork()*), and the process performing
    the *epoll_wait()* has closed its file descriptor, but the other process still
    holds the duplicate descriptor open.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语义可能导致一些初看起来令人惊讶的行为。假设我们执行[示例63-6](ch63.html#semantics_of_epoll_with_duplicate_file_d
    "示例63-6. 具有重复文件描述符的epoll语义")中显示的代码。在这段代码中，*epoll_wait()*调用会告诉我们文件描述符*fd1*已就绪（换句话说，*evlist[0].data.fd*将等于*fd1*），尽管*fd1*已经被关闭。这是因为仍然存在一个打开的文件描述符*fd2*，它指向*epoll*兴趣列表中包含的打开文件描述符。当两个进程持有指向相同打开文件描述符的重复描述符时（通常是通过*fork()*的结果），并且执行*epoll_wait()*的进程已关闭其文件描述符，但另一个进程仍然保持着重复描述符打开时，会发生类似的情况。
- en: Example 63-6. Semantics of *epoll* with duplicate file descriptors
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 示例63-6. 具有重复文件描述符的*epoll*语义
- en: '[PRE32]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Performance of *epoll* Versus I/O Multiplexing
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*epoll*与I/O多路复用的性能'
- en: '[Table 63-9](ch63.html#times_taken_by_poll_open_parenthesis_clo "Table 63-9. Times
    taken by poll(), select(), and epoll for 100,000 monitoring operations") shows
    the results (on Linux 2.6.25) when we monitor *N* contiguous file descriptors
    in the range *0* to *N - 1* using *poll()*, *select()*, and *epoll*. (The test
    was arranged such that during each monitoring operation, exactly one randomly
    selected file descriptor is ready.) From this table, we see that as the number
    of file descriptors to be monitored grows large, *poll()* and *select()* perform
    poorly. By contrast, the performance of *epoll* hardly declines as *N* grows large.
    (The small decline in performance as *N* increases is possibly a result of reaching
    CPU caching limits on the test system.)'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '[表63-9](ch63.html#times_taken_by_poll_open_parenthesis_clo "Table 63-9. Times
    taken by poll(), select(), and epoll for 100,000 monitoring operations")显示了在Linux
    2.6.25上，使用*poll()*、*select()*和*epoll*监控从*0*到*N - 1*范围内的*N*个连续文件描述符时的结果。（该测试的安排是每次监控操作中，恰好一个随机选中的文件描述符变为就绪。）从表中可以看出，随着监控的文件描述符数量的增加，*poll()*和*select()*的性能表现较差。相比之下，*epoll*的性能几乎不会随着*N*的增大而下降。（*N*增大时性能的轻微下降，可能是由于测试系统达到了CPU缓存的限制。）'
- en: Note
  id: totrans-507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the purposes of this test, `FD_SETSIZE` was changed to 16,384 in the *glibc*
    header files to allow the test program to monitor large numbers of file descriptors
    using *select()*.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在此测试中，`FD_SETSIZE`在*glibc*头文件中被更改为16,384，以允许测试程序使用*select()*监控大量文件描述符。
- en: Table 63-9. Times taken by *poll()*, *select()*, and *epoll* for 100,000 monitoring
    operations
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 表63-9. *poll()*、*select()*和*epoll*在100,000次监控操作中的耗时
- en: '| Number of descriptors monitored (*N*) | *poll()* CPU time (seconds) | *select()*
    CPU time (seconds) | *epoll* CPU time (seconds) |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| 监控的描述符数量（*N*） | *poll()* CPU时间（秒） | *select()* CPU时间（秒） | *epoll* CPU时间（秒）
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `10` | `0.61` | `0.73` | `0.41` |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| `10` | `0.61` | `0.73` | `0.41` |'
- en: '| `100` | `2.9` | `3.0` | `0.42` |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| `100` | `2.9` | `3.0` | `0.42` |'
- en: '| `1000` | `35` | `35` | `0.53` |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| `1000` | `35` | `35` | `0.53` |'
- en: '| `10000` | `990` | `930` | `0.66` |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| `10000` | `990` | `930` | `0.66` |'
- en: 'In [Problems with *select()* and *poll()*](ch63.html#problems_with_select_open_parenthesis_cl
    "Problems with select() and poll()"), we saw why *select()* and *poll()* perform
    poorly when monitoring large numbers of file descriptors. We now look at the reasons
    why *epoll* performs better:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在[问题与*select()*和*poll()*](ch63.html#problems_with_select_open_parenthesis_cl
    "Problems with select() and poll()")中，我们已经看到为什么*select()*和*poll()*在监控大量文件描述符时性能较差。接下来我们来探讨为什么*epoll*表现更好的原因：
- en: On each call to *select()* or *poll()*, the kernel must check all of the file
    descriptors specified in the call. By contrast, when we mark a descriptor to be
    monitored with *epoll_ctl()*, the kernel records this fact in a list associated
    with the underlying open file description, and whenever an I/O operation that
    makes the file descriptor ready is performed, the kernel adds an item to the ready
    list for the *epoll* descriptor. (An I/O event on a single open file description
    may cause multiple file descriptors associated with that description to become
    ready.) Subsequent *epoll_wait()* calls simply fetch items from the ready list.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次调用*select()*或*poll()*时，内核必须检查调用中指定的所有文件描述符。相比之下，当我们使用*epoll_ctl()*标记一个描述符以进行监控时，内核会将这一事实记录在与底层打开文件描述符相关联的列表中，并且每当执行使文件描述符变为就绪的I/O操作时，内核会将一个条目添加到*epoll*描述符的就绪列表中。（对单个打开文件描述符的I/O事件可能导致与该描述符相关联的多个文件描述符变为就绪。）随后的*epoll_wait()*调用仅从就绪列表中提取条目。
- en: Each time we call *select()* or *poll()*, we pass a data structure to the kernel
    that identifies all of the file descriptors that are to be monitored, and, on
    return, the kernel passes back a data structure describing the readiness of all
    of these descriptors. By contrast, with *epoll*, we use *epoll_ctl()* to build
    up a data structure *in kernel space* that lists the set of file descriptors to
    be monitored. Once this data structure has been built, each later call to *epoll_wait()*
    doesn’t need to pass any information about file descriptors to the kernel, and
    the call returns information about only those descriptors that are ready.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次我们调用*select()*或*poll()*时，我们都会向内核传递一个数据结构，用于标识所有需要监控的文件描述符，并且在返回时，内核会返回一个描述所有这些描述符就绪状态的数据结构。相比之下，使用*epoll*时，我们使用*epoll_ctl()*在*内核空间*构建一个数据结构，列出需要监控的文件描述符集合。一旦构建了这个数据结构，后续的每次*epoll_wait()*调用都不需要向内核传递任何关于文件描述符的信息，调用返回的信息仅涉及那些已经就绪的描述符。
- en: Note
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In addition to the above points, for *select()*, we must initialize the input
    data structure prior to each call, and for both *select()* and *poll()*, we must
    inspect the returned data structure to find out which of the *N* file descriptors
    are ready. However, some testing showed that the time required for these other
    steps was insignificant compared to the time required for the system call to monitor
    *N* descriptors. [Table 63-9](ch63.html#times_taken_by_poll_open_parenthesis_clo
    "Table 63-9. Times taken by poll(), select(), and epoll for 100,000 monitoring
    operations") doesn’t include the times for the inspection step.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述几点，对于*select()*，我们必须在每次调用之前初始化输入数据结构；对于*select()*和*poll()*，我们必须检查返回的数据结构，以找出哪些*N*文件描述符已准备就绪。然而，一些测试表明，除了系统调用监视*N*个描述符所需的时间外，其他步骤所需的时间是微不足道的。[表63-9](ch63.html#times_taken_by_poll_open_parenthesis_clo
    "表63-9. poll()、select()和epoll在100,000次监控操作中的耗时")中未包括检查步骤的时间。
- en: Very roughly, we can say that for large values of *N* (the number of file descriptors
    being monitored), the performance of *select()* and *poll()* scales linearly with
    *N*. We start to see this behavior for the *N = 100* and *N = 1000* cases in [Table 63-9](ch63.html#times_taken_by_poll_open_parenthesis_clo
    "Table 63-9. Times taken by poll(), select(), and epoll for 100,000 monitoring
    operations"). By the time we reach *N = 10000*, the scaling has actually become
    worse than linear.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 非常粗略地说，对于大值的*N*（被监视的文件描述符数量），*select()*和*poll()*的性能随着*N*线性扩展。我们在[表63-9](ch63.html#times_taken_by_poll_open_parenthesis_clo
    "表63-9. poll()、select()和epoll在100,000次监控操作中的耗时")中的*N = 100*和*N = 1000*案例中开始看到这种行为。到*N
    = 10000*时，扩展性实际上已经变得比线性更差。
- en: 'By contrast, *epoll* scales (linearly) according to the number of I/O events
    that occur. The *epoll* API is thus particularly efficient in a scenario that
    is common in servers that handle many simultaneous clients: of the many file descriptors
    being monitored, most are idle; only a few descriptors are ready.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，*epoll*的扩展性（线性）与发生的I/O事件数量相关。因此，*epoll* API在一个典型的服务器场景中尤其高效，该场景中服务器需要处理许多同时连接的客户端：在被监视的众多文件描述符中，大部分是空闲的，只有少数描述符已准备就绪。
- en: Edge-Triggered Notification
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边缘触发通知
- en: By default, the *epoll* mechanism provides *level-triggered* notification. By
    this, we mean that *epoll* tells us whether an I/O operation can be performed
    on a file descriptor without blocking. This is the same type of notification as
    is provided by *poll()* and *select()*.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，*epoll*机制提供*电平触发*通知。这里指的是，*epoll*会告诉我们是否可以在文件描述符上执行I/O操作而不发生阻塞。这与*poll()*和*select()*提供的通知类型相同。
- en: The *epoll* API also allows for *edge-triggered* notification—that is, a call
    to *epoll_wait()* tells us if there has been I/O activity on a file descriptor
    since the previous call to *epoll_wait()* (or since the descriptor was opened,
    if there was no previous call). Using *epoll* with edge-triggered notification
    is semantically similar to signal-driven I/O, except that if multiple I/O events
    occur, *epoll* coalesces them into a single notification returned via *epoll_wait()*;
    with signal-driven I/O, multiple signals may be generated.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '*epoll* API还允许进行*边缘触发*通知——即，调用*epoll_wait()*告诉我们自上次调用*epoll_wait()*以来（如果没有上次调用，则自描述符打开以来）文件描述符是否发生了I/O活动。使用带有边缘触发通知的*epoll*语义上类似于信号驱动的I/O，区别在于，如果发生多个I/O事件，*epoll*将它们合并为通过*epoll_wait()*返回的单个通知；而信号驱动I/O可能会生成多个信号。'
- en: 'To employ edge-triggered notification, we specify the `EPOLLET` flag in *ev.events*
    when calling *epoll_ctl()*:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用边缘触发通知，我们在调用*epoll_ctl()*时在*ev.events*中指定`EPOLLET`标志：
- en: '[PRE33]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We illustrate the difference between level-triggered and edge-triggered *epoll*
    notification using an example. Suppose that we are using *epoll* to monitor a
    socket for input (`EPOLLIN`), and the following steps occur:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个例子来说明*电平触发*和*边缘触发*的*epoll*通知之间的区别。假设我们使用*epoll*来监视一个套接字的输入（`EPOLLIN`），并且发生了以下步骤：
- en: Input arrives on the socket.
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入数据到达套接字。
- en: We perform an *epoll_wait()*. This call will tell us that the socket is ready,
    regardless of whether we are employing level-triggered or edge-triggered notification.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们执行*epoll_wait()*。无论是使用电平触发还是边缘触发通知，这次调用都会告诉我们套接字已准备就绪。
- en: We perform a second call to *epoll_wait()*.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们进行第二次调用*epoll_wait()*。
- en: If we are employing level-triggered notification, then the second *epoll_wait()*
    call will inform us that the socket is ready. If we are employing edge-triggered
    notification, then the second call to *epoll_wait()* will block, because no new
    input has arrived since the previous call to *epoll_wait()*.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是基于级别的通知，那么第二次调用*epoll_wait()*将告知我们该套接字已准备好。如果我们使用的是基于边缘的通知，则第二次调用*epoll_wait()*会被阻塞，因为自上次调用*epoll_wait()*以来没有新的输入到达。
- en: 'As we noted in , edge-triggered notification is usually employed in conjunction
    with nonblocking file descriptors. Thus, the general framework for using edge-triggered
    *epoll* notification is as follows:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在中所指出的，基于边缘的通知通常与非阻塞文件描述符一起使用。因此，使用基于边缘的*epoll*通知的通用框架如下：
- en: Make all file descriptors that are to be monitored nonblocking.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有需要被监控的文件描述符设置为非阻塞模式。
- en: Build the *epoll* interest list using *epoll_ctl()*.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*epoll_ctl()*构建*epoll*兴趣列表。
- en: 'Handle I/O events using the following loop:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下循环处理 I/O 事件：
- en: Retrieve a list of ready descriptors using *epoll_wait()*.
  id: totrans-537
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*epoll_wait()*获取已准备好的描述符列表。
- en: For each file descriptor that is ready, process I/O until the relevant system
    call (e.g., *read()*, *write()*, *recv()*, *send()*, or *accept()*) returns with
    the error *EAGAIN* or `EWOULDBLOCK`.
  id: totrans-538
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个准备好的文件描述符，进行 I/O 操作，直到相关的系统调用（例如，*read()*, *write()*, *recv()*, *send()*,
    或 *accept()*）返回错误 *EAGAIN* 或 `EWOULDBLOCK`。
- en: Preventing file-descriptor starvation when using edge-triggered notification
  id: totrans-539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 防止在使用基于边缘的通知时出现文件描述符饿死问题
- en: 'Suppose that we are monitoring multiple file descriptors using edge-triggered
    notification, and that a ready file descriptor has a large amount (perhaps an
    endless stream) of input available. If, after detecting that this file descriptor
    is ready, we attempt to consume all of the input using nonblocking reads, then
    we risk starving the other file descriptors of attention (i.e., it may be a long
    time before we again check them for readiness and perform I/O on them). One solution
    to this problem is for the application to maintain a list of file descriptors
    that have been notified as being ready, and execute a loop that continuously performs
    the following actions:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在使用基于边缘的通知监控多个文件描述符，并且一个准备好的文件描述符有大量（可能是无尽的）输入可用。如果在检测到该文件描述符准备好之后，我们试图通过非阻塞读取消耗所有输入，那么我们可能会导致其他文件描述符得不到关注（即可能需要很长时间才能再次检查它们的准备状态并对它们进行
    I/O 操作）。解决这个问题的一种方法是让应用程序维护一个已通知为准备好的文件描述符列表，并执行一个循环，持续执行以下操作：
- en: Monitor the file descriptors using *epoll_wait()* and add ready descriptors
    to the application list. If any file descriptors are already registered as being
    ready in the application list, then the timeout for this monitoring step should
    be small or 0, so that if no new file descriptors are ready, the application can
    quickly proceed to the next step and service any file descriptors that are already
    known to be ready.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*epoll_wait()*监控文件描述符，并将准备好的描述符添加到应用程序列表中。如果应用程序列表中已经注册了准备好的文件描述符，则该监控步骤的超时时间应该设置得较小或为
    0，这样如果没有新的文件描述符准备好，应用程序可以迅速进入下一个步骤，并处理已知为准备好的文件描述符。
- en: Perform a limited amount of I/O on those file descriptors registered as being
    ready in the application list (perhaps cycling through them in round-robin fashion,
    rather than always starting from the beginning of the list after each call to
    *epoll_wait()*). A file descriptor can be removed from the application list when
    the relevant nonblocking I/O system call fails with the `EAGAIN` or `EWOULDBLOCK`
    error.
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对那些在应用程序列表中标记为准备好的文件描述符执行有限的 I/O 操作（可以采用轮询的方式循环遍历它们，而不是每次调用*epoll_wait()*后都从列表开头开始）。当相关的非阻塞
    I/O 系统调用因 `EAGAIN` 或 `EWOULDBLOCK` 错误失败时，可以将文件描述符从应用程序列表中移除。
- en: Although it requires extra programming work, this approach offers other benefits
    in addition to preventing file-descriptor starvation. For example, we can include
    other steps in the above loop, such as handling timers and accepting signals with
    *sigwaitinfo()* (or similar).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法需要额外的编程工作，但它除了防止文件描述符饿死问题外，还带来了其他好处。例如，我们可以在上述循环中包含其他步骤，比如处理定时器和使用*sigwaitinfo()*（或类似方法）接收信号。
- en: Starvation considerations can also apply when using signal-driven I/O, since
    it also presents an edge-triggered notification mechanism. By contrast, starvation
    considerations don’t necessarily apply in applications employing a level-triggered
    notification mechanism. This is because we can employ blocking file descriptors
    with level-triggered notification and use a loop that continuously checks descriptors
    for readiness, and then performs *some* I/O on the ready descriptors before once
    more checking for ready file descriptors.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用信号驱动的 I/O 时，也可能会出现饿死问题，因为它同样提供了一个边沿触发的通知机制。相比之下，饿死问题在采用水平触发通知机制的应用中并不一定适用。这是因为我们可以在使用水平触发通知的情况下，采用阻塞文件描述符，并使用一个循环不断检查描述符是否准备好，然后对准备好的描述符执行
    *某些* I/O 操作，再次检查文件描述符是否准备好。
- en: Waiting on Signals and File Descriptors
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待信号和文件描述符
- en: Sometimes, a process needs to simultaneously wait for I/O to become possible
    on one of a set of file descriptors or for the delivery of a signal. We might
    attempt to perform such an operation using *select()*, as shown in [Example 63-7](ch63.html#incorrect_method_of_unblocking_signals_a
    "Example 63-7. Incorrect method of unblocking signals and calling select()").
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，进程需要同时等待一组文件描述符中的某个文件描述符是否可以进行 I/O 操作，或者等待信号的传递。我们可能会尝试使用 *select()* 来执行这样的操作，如
    [示例 63-7](ch63.html#incorrect_method_of_unblocking_signals_a "示例 63-7. 错误的解除信号阻塞方法与调用
    select()") 中所示。
- en: Example 63-7. Incorrect method of unblocking signals and calling *select()*
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 63-7. 错误的解除信号阻塞方法与调用 *select()*
- en: '[PRE34]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The problem with this code is that if the signal (`SIGUSR1` in this example)
    arrives after establishing the handler but before *select()* is called, then the
    *select()* call will nevertheless block. (This is a form of race condition.) We
    now look at some solutions to this problem.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码的问题在于，如果信号（在本例中为 `SIGUSR1`）在建立处理程序之后但在调用 *select()* 之前到达，那么 *select()* 调用仍然会被阻塞。（这是一种竞争条件。）接下来我们将查看解决此问题的一些方法。
- en: Note
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Since version 2.6.27, Linux provides a further technique that can be used to
    simultaneously wait on signals and file descriptors: the *signalfd* mechanism
    described in Section 22.11\. Using this mechanism, we can receive signals via
    a file descriptor that is monitored (along with other file descriptors) using
    *select()*, *poll()*, or *epoll_wait()*.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 2.6.27 起，Linux 提供了一种新技术，可以同时等待信号和文件描述符：*signalfd* 机制，详见第 22.11 节。通过此机制，我们可以通过文件描述符接收信号，并使用
    *select()*、*poll()* 或 *epoll_wait()* 监控该描述符（以及其他文件描述符）。
- en: The *pselect()* System Call
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*pselect()* 系统调用'
- en: The *pselect()* system call performs a similar task to *select()*. The main
    semantic difference is an additional argument, *sigmask*, that specifies a set
    of signals to be unmasked while the call is blocked.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '*pselect()* 系统调用执行的任务与 *select()* 类似，主要的语义差异是一个额外的参数 *sigmask*，它指定在调用被阻塞期间要解除屏蔽的信号集。'
- en: '[PRE35]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of ready file descriptors, 0 on timeout, or -1 on error
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 返回准备好的文件描述符数量，超时时返回 0，出错时返回 -1
- en: 'More precisely, suppose we have the following *pselect()* call:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，假设我们有以下的 *pselect()* 调用：
- en: '[PRE36]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This call is equivalent to *atomically* performing the following steps:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 该调用相当于原子性地执行以下步骤：
- en: '[PRE37]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using *pselect()*, we can recode the first part of the body of our main program
    in [Example 63-7](ch63.html#incorrect_method_of_unblocking_signals_a "Example 63-7. Incorrect
    method of unblocking signals and calling select()") as shown in [Example 63-8](ch63.html#using_pselect_open_parenthesis_close_par
    "Example 63-8. Using pselect()").
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *pselect()*，我们可以将主程序主体的第一部分重写为 [示例 63-7](ch63.html#incorrect_method_of_unblocking_signals_a
    "示例 63-7. 错误的解除信号阻塞方法与调用 select()") 中的内容，如 [示例 63-8](ch63.html#using_pselect_open_parenthesis_close_par
    "示例 63-8. 使用 pselect()") 所示。
- en: 'Aside from the *sigmask* argument, *select()* and *pselect()* differ in the
    following ways:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 *sigmask* 参数外，*select()* 和 *pselect()* 在以下几个方面有所不同：
- en: 'The *timeout* argument to *pselect()* is a *timespec* structure ([High-Resolution
    Sleeping: *nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep "High-Resolution
    Sleeping: nanosleep()")), which allows the timeout to be specified with nanosecond
    (instead of microsecond) precision.'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*timeout* 参数传递给 *pselect()* 时使用的是 *timespec* 结构体（[高精度休眠：*nanosleep()*](ch23.html#high-resolution_sleeping_colon_nanosleep
    "高精度休眠：nanosleep()")），它允许以纳秒（而非微秒）精度指定超时时间。'
- en: SUSv3 explicitly states that *pselect()* doesn’t modify the *timeout* argument
    on return.
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SUSv3 明确指出，*pselect()* 在返回时不会修改 *timeout* 参数。
- en: If we specify the *sigmask* argument of *pselect()* as `NULL`, then *pselect()*
    is equivalent to *select()* (i.e., it performs no manipulation of the process
    signal mask), except for the differences just noted.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将*pselect()*的*sigmask*参数指定为`NULL`，则*pselect()*相当于*select()*（即，它不对进程信号屏蔽做任何操作），除了刚才提到的差异。
- en: The *pselect()* interface is an invention of POSIX.1g, and is nowadays incorporated
    in SUSv3\. It is not available on all UNIX implementations, and was added to Linux
    only in kernel 2.6.16.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '*pselect()*接口是POSIX.1g的发明，现已纳入SUSv3。它并非所有UNIX实现都支持，并且仅在内核2.6.16中才添加到Linux。'
- en: Note
  id: totrans-567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Previously, a *pselect()* library function was provided by *glibc*, but this
    implementation didn’t provide the atomicity guarantees that are required for the
    correct operation of the call. Such guarantees can be provided only by a kernel
    implementation of *pselect()*.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，*pselect()*库函数由*glibc*提供，但该实现未能提供正确操作调用所需的原子性保证。只有*pselect()*的内核实现才能提供这种保证。
- en: Example 63-8. Using *pselect()*
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 示例63-8. 使用*pselect()*
- en: '[PRE38]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The *ppoll()* and *epoll_pwait()* system calls
  id: totrans-571
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*ppoll()*和*epoll_pwait()*系统调用'
- en: Linux 2.6.16 also added a new, nonstandard system call, *ppoll()*, whose relationship
    to *poll()* is analogous to the relationship of *pselect()* to *select()*. Similarly,
    starting with kernel 2.6.19, Linux also includes *epoll_pwait()*, providing an
    analogous extension to *epoll_wait()*. See the *ppoll(2)* and *epoll_pwait(2)*
    manual pages for details.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 2.6.16还添加了一个新的非标准系统调用*ppoll()*，它与*poll()*的关系类似于*pselect()*与*select()*的关系。同样，从内核2.6.19开始，Linux还包括*epoll_pwait()*，为*epoll_wait()*提供了类似的扩展。有关详细信息，请参见*ppoll(2)*和*epoll_pwait(2)*手册页面。
- en: The Self-Pipe Trick
  id: totrans-573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自管道技巧
- en: 'Since *pselect()* is not widely implemented, portable applications must employ
    other strategies to avoid race conditions when simultaneously waiting for signals
    and calling *select()* on a set of file descriptors. One common solution is the
    following:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*pselect()*并未广泛实现，因此可移植的应用程序必须采用其他策略，以避免在同时等待信号和在一组文件描述符上调用*select()*时出现竞态条件。一个常见的解决方案是：
- en: Create a pipe, and mark its read and write ends as nonblocking.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个管道，并将其读写端标记为非阻塞。
- en: As well as monitoring all of the other file descriptors that are of interest,
    include the read end of the pipe in the *readfds* set given to *select()*.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了监视所有其他感兴趣的文件描述符外，还应将管道的读端包括在传递给*select()*的*readfds*集合中。
- en: 'Install a handler for the signal that is of interest. When this signal handler
    is called, it writes a byte of data to the pipe. Note the following points about
    the signal handler:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为感兴趣的信号安装一个处理程序。当此信号处理程序被调用时，它会向管道写入一个字节的数据。请注意以下几点：
- en: The write end of the pipe was marked as nonblocking in the first step to prevent
    the possibility that signals arrive so rapidly that repeated invocations of the
    signal handler fill the pipe, with the result that the signal handler’s *write()*
    (and thus the process itself) is blocked. (It doesn’t matter if a write to a full
    pipe fails, since the previous writes will already have indicated the delivery
    of the signal.)
  id: totrans-578
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一步中，管道的写端被标记为非阻塞，以防止信号到达得过快，导致信号处理程序的多次调用填满管道，从而导致信号处理程序的*write()*（进程本身）被阻塞。（如果写入已满的管道失败也无关紧要，因为之前的写入已经表示信号的传递。）
- en: The signal handler is installed after creating the pipe, in order to prevent
    the race condition that would occur if a signal was delivered before the pipe
    was created.
  id: totrans-579
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号处理程序是在创建管道后安装的，以防止在管道创建之前信号被传递，从而引发竞态条件。
- en: It is safe to use *write()* inside the signal handler, because it is one of
    the async-signal-safe functions listed in [Table 21-1](ch21.html#functions_required_to_be_async-signal-sa
    "Table 21-1. Functions required to be async-signal-safe by POSIX.1-1990, SUSv2,
    and SUSv3"), in [Standard async-signal-safe functions](ch21.html#standard_async-signal-safe_functions
    "Standard async-signal-safe functions").
  id: totrans-580
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在信号处理程序中使用*write()*是安全的，因为它是[表21-1](ch21.html#functions_required_to_be_async-signal-sa
    "表21-1. POSIX.1-1990、SUSv2和SUSv3要求异步信号安全的函数")中列出的异步信号安全函数之一，参见[标准异步信号安全函数](ch21.html#standard_async-signal-safe_functions
    "标准异步信号安全函数")。
- en: Place the *select()* call in a loop, so that it is restarted if interrupted
    by a signal handler. (Restarting in this fashion is not strictly necessary; it
    merely means that we can check for the arrival of a signal by inspecting *readfds*,
    rather than checking for an `EINTR` error return.)
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *select()* 调用放入循环中，以便在被信号处理程序中断时重新启动。（以这种方式重新启动并非严格必要；它仅意味着我们可以通过检查 *readfds*
    来检查信号是否到达，而不是检查 `EINTR` 错误返回。）
- en: On successful completion of the *select()* call, we can determine whether a
    signal arrived by checking if the file descriptor for the read end of the pipe
    is set in *readfds*.
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *select()* 调用成功完成后，我们可以通过检查管道读端的文件描述符是否设置在 *readfds* 中来判断信号是否到达。
- en: Whenever a signal has arrived, read all bytes that are in the pipe. Since multiple
    signals may arrive, employ a loop that reads bytes until the (nonblocking) *read()*
    fails with the error `EAGAIN`. After draining the pipe, perform whatever actions
    must be taken in response to delivery of the signal.
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当信号到达时，读取管道中的所有字节。由于可能会有多个信号到达，使用一个循环，持续读取字节，直到（非阻塞）*read()*由于错误`EAGAIN`而失败。在清空管道后，执行针对信号交付所需的任何操作。
- en: This technique is commonly known as the *self-pipe trick*, and code demonstrating
    this technique is shown in [Example 63-9](ch63.html#using_the_self-pipe_trick
    "Example 63-9. Using the self-pipe trick").
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术通常被称为*自管道技巧*，展示该技术的代码可以在[示例 63-9](ch63.html#using_the_self-pipe_trick "示例
    63-9. 使用自管道技巧")中找到。
- en: Variations on this technique can equally be employed with *poll()* and *epoll_wait()*.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技巧的变种同样可以在 *poll()* 和 *epoll_wait()* 中使用。
- en: Example 63-9. Using the self-pipe trick
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 63-9. 使用自管道技巧
- en: '[PRE39]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Summary
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we explored various alternatives to the standard model for
    performing I/O: I/O multiplexing (*select()* and *poll()*), signal-driven I/O,
    and the Linux-specific *epoll* API. All of these mechanisms allow us to monitor
    multiple file descriptors to see if I/O is possible on any of them. None of these
    mechanisms actually performs I/O. Instead, once we have determined that a file
    descriptor is ready, we use the traditional I/O system calls to perform the I/O.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们探讨了执行 I/O 的标准模型的各种替代方法：I/O 多路复用（*select()* 和 *poll()*）、信号驱动的 I/O 和 Linux
    特有的 *epoll* API。所有这些机制都允许我们监视多个文件描述符，查看是否可以在其中任何一个上进行 I/O。没有一个机制实际上执行 I/O。相反，一旦我们确定某个文件描述符已准备好，我们就使用传统的
    I/O 系统调用来执行 I/O。
- en: The *select()* and *poll()* I/O multiplexing calls simultaneously monitor multiple
    file descriptors to see if I/O is possible on any of the descriptors. With both
    system calls, we pass a complete list of to-be-checked file descriptors to the
    kernel on each system call, and the kernel returns a modified list indicating
    which descriptors are ready. The fact that complete file descriptor lists are
    passed and checked on each call means that *select()* and *poll()* perform poorly
    when monitoring large numbers of file descriptors.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '*select()* 和 *poll()* I/O 多路复用调用同时监视多个文件描述符，查看是否可以在任何一个描述符上进行 I/O。使用这两个系统调用时，我们将待检查的文件描述符完整列表传递给内核，内核返回一个修改过的列表，指示哪些描述符已准备好。由于每次调用都传递并检查完整的文件描述符列表，这意味着在监视大量文件描述符时，*select()*
    和 *poll()* 的性能较差。'
- en: Signal-driven I/O allows a process to receive a signal when I/O is possible
    on a file descriptor. To enable signal-driven I/O, we must establish a handler
    for the `SIGIO` signal, set the owner process that is to receive the signal, and
    enable signal generation by setting the `O_ASYNC` open file status flag. This
    mechanism offers significant performance benefits over I/O multiplexing when monitoring
    large numbers of file descriptors. Linux allows us to change the signal used for
    notification, and if we instead employ a realtime signal, then multiple notifications
    can be queued, and the signal handler can use its *siginfo_t* argument to determine
    the file descriptor and event type that generated the signal.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 信号驱动的 I/O 允许进程在文件描述符上可以进行 I/O 时接收信号。要启用信号驱动的 I/O，我们必须为 `SIGIO` 信号建立处理程序，设置接收信号的所有者进程，并通过设置
    `O_ASYNC` 打开文件状态标志来启用信号生成。与 I/O 多路复用相比，这种机制在监视大量文件描述符时提供了显著的性能优势。Linux 允许我们更改用于通知的信号，如果我们使用实时信号，则可以将多个通知排队，信号处理程序可以使用其
    *siginfo_t* 参数来确定生成信号的文件描述符和事件类型。
- en: 'Like signal-driven I/O, *epoll* offers superior performance when monitoring
    large numbers of file descriptors. The performance advantage of *epoll* (and signal-driven
    I/O) derives from the fact that the kernel “remembers” the list of file descriptors
    that a process is monitoring (by contrast with *select()* and *poll()*, where
    each system call must again tell the kernel which file descriptors to check).
    The *epoll* API has some notable advantages over the use of signal-driven I/O:
    we avoid the complexities of dealing with signals and can specify which types
    of I/O events (e.g., input or output) are to be monitored.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于信号驱动的 I/O，*epoll* 在监视大量文件描述符时提供了优越的性能。*epoll*（以及信号驱动的 I/O）的性能优势来自于内核“记住”了进程正在监视的文件描述符列表（与*select()*和*poll()*不同，每次系统调用都必须再次告诉内核检查哪些文件描述符）。*epoll*
    API 相较于使用信号驱动的 I/O 有一些显著的优势：我们避免了处理信号的复杂性，并且可以指定需要监视的 I/O 事件类型（例如，输入或输出）。
- en: In the course of this chapter, we drew a distinction between level-triggered
    and edge-triggered readiness notification. With a level-triggered notification
    model, we are informed whether I/O is currently possible on a file descriptor.
    By contrast, edge-triggered notification informs us whether I/O activity has occurred
    on a file descriptor since it was last monitored. The I/O multiplexing system
    calls offer a level-triggered notification model; signal-driven I/O approximates
    to an edge-triggered model; and *epoll* is capable of operating under either model
    (level-triggered is the default). Edge-triggered notification is usually employed
    in conjunction with nonblocking I/O.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章过程中，我们区分了水平触发和边缘触发的就绪通知。使用水平触发通知模型时，我们会被告知某个文件描述符是否可以进行 I/O 操作。相反，边缘触发通知则告诉我们自上次监视以来某个文件描述符是否发生了
    I/O 活动。I/O 多路复用系统调用提供了水平触发通知模型；信号驱动的 I/O 类似于边缘触发模型；而*epoll*能够在这两种模型下工作（默认是水平触发）。边缘触发通知通常与非阻塞
    I/O 一起使用。
- en: 'We concluded the chapter by looking at a problem that sometimes faces programs
    that monitor multiple file descriptors: how to simultaneously also wait for the
    delivery of a signal. The usual solution to this problem is the so-called self-pipe
    trick, whereby a handler for the signal writes a byte to a pipe whose read end
    is included among the set of monitored file descriptors. SUSv3 specifies *pselect()*,
    a variation of *select()* that provides another solution to this problem. However,
    *pselect()* is not available on all UNIX implementations. Linux also provides
    the analogous (but nonstandard) *ppoll()* and *epoll_pwait()*.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后，我们讨论了一个程序可能面临的问题，即在监视多个文件描述符的同时，如何等待信号的传递。解决这个问题的常见方法是所谓的自管道技巧，其中信号的处理程序向一个管道写入一个字节，该管道的读取端被包含在被监视的文件描述符集合中。SUSv3
    指定了*pselect()*，它是*select()*的一个变种，提供了该问题的另一种解决方案。然而，*pselect()*并非所有 UNIX 实现中都可用。Linux
    还提供了类似的（但非标准的）*ppoll()*和*epoll_pwait()*。
- en: Further information
  id: totrans-595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步的信息
- en: '[Stevens et al., 2004] describes I/O multiplexing and signal-driven I/O, with
    particular emphasis on the use of these mechanisms with sockets. [Gammo et al,
    2004] is a paper comparing the performance of *select()*, *poll()*, and *epoll*.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '[Stevens 等人，2004] 描述了 I/O 多路复用和信号驱动的 I/O，特别强调了这些机制与套接字的结合使用。[Gammo 等人，2004]
    是一篇比较*select()*、*poll()* 和 *epoll* 性能的论文。'
- en: A particularly interesting online resource is at [http://www.kegel.com/c10k.html](http://www.kegel.com/c10k.html).
    Written by Dan Kegel, and entitled “The C10K problem,” this web page explores
    the issues facing developers of web servers designed to simultaneously serve tens
    of thousands of clients. The web page includes a host of links to related information.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有趣的在线资源是[http://www.kegel.com/c10k.html](http://www.kegel.com/c10k.html)。该网页由
    Dan Kegel 编写，名为“C10K 问题”，探讨了为同时服务数万个客户端而设计的 Web 服务器开发者面临的问题。网页包含了大量相关信息的链接。
- en: Exercises
  id: totrans-598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Modify the program in [Example 63-2](ch63.html#using_poll_open_parenthesis_close_parent
    "Example 63-2. Using poll() to monitor multiple file descriptors") `(poll_pipes.c)`
    to use *select()* instead of *poll()*.
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例 63-2](ch63.html#using_poll_open_parenthesis_close_parent "示例 63-2. 使用
    poll() 监视多个文件描述符")中的程序`(poll_pipes.c)`，将其改为使用*select()*代替*poll()*。
- en: Write an *echo* server (see [An Iterative UDP *echo* Server](ch60.html#an_iterative_udp_echo_server
    "An Iterative UDP echo Server") and [A Concurrent TCP *echo* Server](ch60.html#a_concurrent_tcp_echo_server
    "A Concurrent TCP echo Server")) that handles both TCP and UDP clients. To do
    this, the server must create both a listening TCP socket and a UDP socket, and
    then monitor both sockets using one of the techniques described in this chapter.
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个*echo*服务器（参见[一个迭代的UDP *echo*服务器](ch60.html#an_iterative_udp_echo_server
    "一个迭代的UDP echo服务器")和[一个并发的TCP *echo*服务器](ch60.html#a_concurrent_tcp_echo_server
    "一个并发的TCP echo服务器")），能够同时处理TCP和UDP客户端。为此，服务器必须创建一个监听TCP套接字和一个UDP套接字，然后使用本章中描述的技术之一来监视这两个套接字。
- en: Section 63.5 noted that *select()* can’t be used to wait on both signals and
    file descriptors, and described a solution using a signal handler and a pipe.
    A related problem exists when a program needs to wait for input on both a file
    descriptor and a System V message queue (since System V message queues don’t use
    file descriptors). One solution is to fork a separate child process that copies
    each message from the queue to a pipe included among the file descriptors monitored
    by the parent. Write a program that uses this scheme with *select()* to monitor
    input from both the terminal and a message queue.
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第63.5节指出，*select()*不能同时用于等待信号和文件描述符，并描述了使用信号处理程序和管道的解决方案。当程序需要等待一个文件描述符和一个System
    V消息队列的输入时，也会遇到类似的问题（因为System V消息队列不使用文件描述符）。一种解决方案是派生一个独立的子进程，将每条消息从队列复制到父进程监视的文件描述符之一的管道中。编写一个程序，使用此方案和*select()*同时监视来自终端和消息队列的输入。
- en: The last step of the description of the self-pipe technique in [The Self-Pipe
    Trick](ch63.html#the_self-pipe_trick "The Self-Pipe Trick") stated that the program
    should first drain the pipe, and then perform any actions that should be taken
    in response to the signal. What might happen if these substeps were reversed?
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[自管道技巧](ch63.html#the_self-pipe_trick "自管道技巧")中关于自管道技巧描述的最后一步提到，程序应首先清空管道，然后再执行任何应对信号的操作。如果这两个子步骤的顺序被颠倒，会发生什么？'
- en: Modify the program in [Example 63-9](ch63.html#using_the_self-pipe_trick "Example 63-9. Using
    the self-pipe trick") (`self_pipe.c`) to use *poll()* instead of *select()*.
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例63-9](ch63.html#using_the_self-pipe_trick "示例63-9. 使用自管道技巧")（`self_pipe.c`）中的程序，改为使用*poll()*而不是*select()*。
- en: Write a program that uses *epoll_create()* to create an *epoll* instance and
    then immediately waits on the returned file descriptor using *epoll_wait()*. When,
    as in this case, *epoll_wait()* is given an *epoll* file descriptor with an empty
    interest list, what happens? Why might this be useful?
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，使用*epoll_create()*创建一个*epoll*实例，然后立即使用*epoll_wait()*等待返回的文件描述符。当*epoll_wait()*被传递一个具有空兴趣列表的*epoll*文件描述符时，会发生什么？为什么这可能有用？
- en: Suppose we have an *epoll* file descriptor that is monitoring multiple file
    descriptors, all of which are always ready. If we perform a series of *epoll_wait()*
    calls in which *maxevents* is much smaller than the number of ready file descriptors
    (e.g., *maxevents* is 1), without performing all possible I/O on the ready descriptors
    between calls, what descriptor(s) does *epoll_wait()* return in each call? Write
    a program to determine the answer. (For the purposes of this experiment, it suffices
    to perform no I/O between the *epoll_wait()* system calls.) Why might this behavior
    be useful?
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个正在监视多个文件描述符的*epoll*文件描述符，这些文件描述符始终处于就绪状态。如果我们执行一系列*epoll_wait()*调用，其中*maxevents*远小于就绪文件描述符的数量（例如，*maxevents*为1），并且在调用之间没有对就绪的描述符执行任何I/O操作，那么*epoll_wait()*在每次调用中返回哪个描述符？编写一个程序来确定答案。（在这个实验中，只需在*epoll_wait()*系统调用之间不执行任何I/O操作即可。）这种行为为什么可能有用？
- en: Modify the program in [Example 63-3](ch63.html#using_signal-driven_i_solidus_o_on_a_ter
    "Example 63-3. Using signal-driven I/O on a terminal") (`demo_sigio.c`) to use
    a realtime signal instead of `SIGIO`. Modify the signal handler to accept a *siginfo_t*
    argument and display the values of the *si_fd* and *si_code* fields of this structure.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例63-3](ch63.html#using_signal-driven_i_solidus_o_on_a_ter "示例63-3. 在终端上使用信号驱动I/O")（`demo_sigio.c`）中的程序，改为使用实时信号代替`SIGIO`。修改信号处理程序，接受一个*siginfo_t*参数，并显示该结构体中*si_fd*和*si_code*字段的值。
