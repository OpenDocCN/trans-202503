- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 9 FILES AND DIRECTORIES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9 文件和目录
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Many applications require you to read or write data to and from files. In this
    chapter, we’ll explore how to interact with files via PHP scripts. We’ll focus
    primarily on simple *.txt* files, though we’ll also touch on how PHP handles other
    common text file formats.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序需要你从文件中读取或写入数据。在本章中，我们将探索如何通过 PHP 脚本与文件进行交互。我们将主要关注简单的 *.txt* 文件，尽管我们也会简要介绍
    PHP 如何处理其他常见的文本文件格式。
- en: PHP provides many built-in functions for working with files. Some read or write
    files all in one go, while other, lower-level functions provide more granular
    control, allowing you to open and close files and selectively read or write at
    specific locations. Not all web applications will require you to work with external
    files, but knowing your way around these functions is still useful, in case the
    need arises. Outside of web applications, for example, you may find yourself needing
    to reformat the data inside files or to move and rename files and directories.
    With the functions we’ll discuss here, you can write a PHP script to automate
    that process.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 提供了许多内置函数来处理文件。有些函数一次性读取或写入文件，而其他更底层的函数则提供更细粒度的控制，允许你打开和关闭文件，并在特定位置选择性地读取或写入内容。并不是所有的
    Web 应用程序都需要你处理外部文件，但掌握这些函数仍然很有用，以防有需要。举例来说，在 Web 应用程序之外，你可能会需要重新格式化文件中的数据，或者移动和重命名文件和目录。通过我们将在这里讨论的函数，你可以编写一个
    PHP 脚本来自动化这个过程。
- en: '### Reading a File into a String'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将文件读取到字符串中'
- en: If you know a file exists and you want to read all its contents into your script
    as a single string, you can do so in a single statement, simply by calling the
    built-in file_get_contents() function. To illustrate, let’s first create a file
    to be read in. [Listing 9-1](#lis9-1) shows a file containing a programming haiku
    by Jorge Suarez (found at *[http://selavo.lv/wiki/index.php/Programming_haiku](http://selavo.lv/wiki/index.php/Programming_haiku)*).
    Create a new file named *data.txt* containing these lines.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道文件存在并且希望将其所有内容作为单个字符串读取到脚本中，你可以通过一个语句实现，只需调用内置的 file_get_contents() 函数。为了说明这一点，让我们首先创建一个待读取的文件。[列表
    9-1](#lis9-1) 显示了一个由 Jorge Suarez 编写的编程俳句文件（可以在 *[http://selavo.lv/wiki/index.php/Programming_haiku](http://selavo.lv/wiki/index.php/Programming_haiku)*
    找到）。创建一个名为 *data.txt* 的新文件，包含以下内容。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 9-1: The text file data.txt containing a programming poem'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-1：包含编程诗歌的文本文件 data.txt
- en: This file contains three lines of text. The line breaks are a sign that the
    first two lines end with an invisible newline character.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件包含三行文本。换行符表示前两行以一个不可见的换行符结尾。
- en: Now that we have a file to work with, we can write a script to read and print
    its contents. Create a *main.php* file in the same directory as *data.txt* and
    enter the code in [Listing 9-2](#lis9-2).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个文件可以操作，我们可以编写一个脚本来读取并打印它的内容。在与 *data.txt* 相同目录下创建一个 *main.php* 文件，并输入
    [列表 9-2](#lis9-2) 中的代码。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-2: A main.php script to read and print the contents of a file'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-2：一个 main.php 脚本，用于读取并打印文件内容
- en: First, we declare a $file variable containing the path and filename for our
    text file. Since the text file and main script are in the same directory, we create
    this file location string by concatenating the __DIR__ magic constant (the path
    to the location of the main script) with a forward slash and the *data.txt* filename.
    We then use file_get_contents() to read the contents of the file into the $text
    variable. Finally, we print out the string containing the file contents.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个 `$file` 变量，包含文本文件的路径和文件名。由于文本文件和主脚本在同一目录下，我们通过将 __DIR__ 魔术常量（主脚本所在位置的路径）与正斜杠和
    *data.txt* 文件名连接起来，构建这个文件位置字符串。然后，我们使用 file_get_contents() 函数将文件内容读取到 `$text`
    变量中。最后，我们打印出包含文件内容的字符串。
- en: 'Run the main script at the terminal and you should see the haiku printed across
    three lines, just as it appears in [Listing 9-1](#lis9-1). This is because the
    invisible newline characters in the file made it into the $text string, just like
    the visible characters. We can prove these invisible characters exist in a couple
    of ways: by checking the size of the text file or by replacing the newlines with
    visible characters in the string read from the file. To make it really easy to
    see how newline characters are part of a text file, let’s replace the contents
    of *data.txt* with that of [Listing 9-3](#lis9-3).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端运行主脚本，你应该看到诗句分布在三行上，正如在[示例 9-1](#lis9-1)中所显示的那样。这是因为文件中的不可见新行字符被传递到了$text字符串中，就像可见字符一样。我们可以通过几种方式证明这些不可见字符的存在：检查文本文件的大小，或者通过将字符串中的新行替换为可见字符来验证从文件中读取的内容。为了更清楚地看到新行字符是如何成为文本文件的一部分的，让我们将*data.txt*的内容替换为[示例
    9-3](#lis9-3)中的内容。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 9-3: A simplified data.txt file'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-3：一个简化版的data.txt文件
- en: Now that the file consists of just two characters, each on a separate line,
    we can more easily examine the contents of the file. Update *main.php* to match
    [Listing 9-4](#lis9-4).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，文件只包含两个字符，每个字符位于单独的行上，我们可以更轻松地检查文件内容。更新*main.php*以匹配[示例 9-4](#lis9-4)。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-4: An updated main.php script to prove the existence of newline characters'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-4：一个更新后的main.php脚本，用于证明新行字符的存在
- en: 'As before, we first read the contents of the file into the $text variable.
    Then we read the size of the file with the built-in filesize() function, which
    returns the file’s number of bytes. In a text file with basic ASCII characters,
    each character (including invisible characters) takes up 1 byte, so we should
    expect the result to be 3. Next, we generate another string that replaces each
    newline character ("\n") in $text with a capital letter N, storing the result
    in the $newLinesChanged variable. Finally, we print the file size and the updated
    string. Here’s the output of running this script at the terminal:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们首先将文件内容读取到$text变量中。然后，我们使用内建的filesize()函数读取文件的大小，它返回文件的字节数。在一个只有基本ASCII字符的文本文件中，每个字符（包括不可见字符）占用1个字节，所以我们应该预期结果是3。接下来，我们生成另一个字符串，将$text中的每个新行字符（"\n"）替换为大写字母N，并将结果存储在$newLinesChanged变量中。最后，我们打印文件大小和更新后的字符串。以下是运行此脚本后在终端中输出的内容：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first line confirms that the file contains just three characters (bytes)
    of data: the letter a, a newline character, and the letter b. The second line
    is the string representing the contents of the file with the newlines made visible:
    aNb again confirms that the file contains just three characters, with a newline
    character between the two letters.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行确认文件只包含三个字符（字节）的数据：字母a、一个新行字符和字母b。第二行是代表文件内容的字符串，其中的新行字符被替换为可见字符：aNb再次确认文件只包含三个字符，其中两个字母之间有一个新行字符。
- en: 'Confirming that the newlines exist isn’t a trivial exercise: later in the chapter,
    we’ll explore functions that work with a file’s contents line by line. These functions
    rely on invisible newlines to know where one line ends and the next begins.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 确认新行的存在并不是一项简单的任务：在本章后面，我们将探索逐行处理文件内容的函数。这些函数依赖于不可见的新行字符来判断一行的结束和下一行的开始。
- en: NOTE
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* file_get_contents() *function can also read files from the web rather
    than from your local machine if you pass it a full URL to the file’s location.
    For example, try storing the URL* [https://filesamples.com/samples/document/txt/sample1.txt](https://filesamples.com/samples/document/txt/sample1.txt)
    *in the* $file *variable and then calling* file_get_contents($file) *as in [Listing
    9-2](#lis9-2). You should get back a string of nonsensical Latin text.*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*file_get_contents()* *函数也可以从网上读取文件，而不仅仅是从本地机器读取，只需传递文件位置的完整 URL。例如，尝试将 URL*
    [https://filesamples.com/samples/document/txt/sample1.txt](https://filesamples.com/samples/document/txt/sample1.txt)
    *存储在* $file *变量中，然后像[示例 9-2](#lis9-2)中那样调用* file_get_contents($file) *。你应该会得到一串无意义的拉丁文文本。*'
- en: Confirming That a File Exists
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 确认文件是否存在
- en: 'The previous examples assume that a file named *data.txt* exists. In practice,
    however, it’s a good idea to test that a file exists before attempting to read
    its contents. Otherwise, if you attempt to open or read a file that can’t be found,
    you’ll get a runtime warning such as the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例假设存在一个名为*data.txt*的文件。然而，在实际操作中，最好在尝试读取文件内容之前先测试文件是否存在。否则，如果你尝试打开或读取一个找不到的文件，你将收到类似以下的运行时警告：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Execution will continue after the warning, which can lead to further warnings
    and errors if the script attempts to manipulate the contents of the nonexistent
    file. To make your code more robust and able to cope with a missing file, you
    can use the built-in file_exists() function. It returns a Boolean value confirming
    whether the provided file exists. Let’s try it out by updating *main.php* with
    the contents of [Listing 9-5](#lis9-5).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 执行将在警告之后继续，如果脚本尝试操作不存在的文件内容，这可能会导致进一步的警告和错误。为了使你的代码更健壮并能应对缺失的文件，你可以使用内置的file_exists()函数。它返回一个布尔值，确认所提供的文件是否存在。让我们通过更新*main.php*并参考[示例
    9-5](#lis9-5)的内容来试一试。
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 9-5: An updated main.php script to confirm the existence of a file
    before reading it'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-5：更新后的main.php脚本，在读取文件之前确认文件的存在
- en: 'Here we add $file2, a second variable holding a path to a nonexistent file,
    *data2.txt*. Before attempting to read anything, we assign a default file not
    found message to the $text and $text2 variables. This way, these variables will
    still hold something, even if we fail to read the contents of a file. We next
    use the file_exists() function in two successive if statements to ensure that
    we attempt to read the contents of *data.txt* and *data2.txt* only if those files
    can be found. Then we print the contents of $text and $text2, each followed by
    a newline character. Here’s the result:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了$file2，它是一个保存不存在的文件路径*data2.txt*的第二个变量。在尝试读取任何内容之前，我们将默认的文件未找到消息分配给$text和$text2变量。这样，即使我们未能读取文件内容，这些变量仍然会保存一些内容。接下来，我们使用file_exists()函数，在两个连续的if语句中确保仅在找到相应文件时才尝试读取*data.txt*和*data2.txt*的内容。然后我们打印$text和$text2的内容，每个后面跟一个换行符。结果如下：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since *data.txt* can be found, its contents have been read into $text (replacing
    the default file not found message) and printed out. Meanwhile, since *data2.txt*
    doesn’t exist, printing $text2 ends up displaying a message indicating that the
    file can’t be found.  #### “Touching” a File'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*data.txt*文件存在，它的内容已被读取到$text中（替代了默认的文件未找到消息），并被打印出来。与此同时，由于*data2.txt*文件不存在，打印$text2会显示一条指示文件无法找到的消息。####
    “触摸”文件
- en: Linux and macOS have a touch file terminal command that either updates the last
    accessed or modified timestamp of the specified file to the current datetime or
    creates an empty file if that file doesn’t already exist. PHP offers the almost
    identical touch() function, which provides another way to ensure that a file exists
    before trying to access it. If you don’t mind a file’s contents being empty, you
    can replace the default file not found messages and if statements from [Listing
    9-5](#lis9-5) with simple touch() statements, as shown in [Listing 9-6](#lis9-6).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Linux和macOS具有touch文件终端命令，它会将指定文件的最后访问或修改时间戳更新为当前日期时间，或者如果文件不存在，则创建一个空文件。PHP提供了几乎相同的touch()函数，它提供了另一种在访问文件之前确保文件存在的方法。如果你不介意文件内容为空，你可以将[示例
    9-5](#lis9-5)中的默认文件未找到消息和if语句替换为简单的touch()语句，如[示例 9-6](#lis9-6)所示。
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 9-6: An updated main.php script to “touch” files before reading them'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-6：更新后的main.php脚本，在读取文件之前“触摸”文件
- en: We now pass each filename to touch() before using file_read_contents() to read
    the files. This lets us safely read the files without if statements and file_exists(),
    since we know touch() will create the files (albeit empty ones) if they don’t
    already exist.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在使用file_read_contents()读取文件之前，先将每个文件名传递给touch()。这让我们可以安全地读取文件，无需使用if语句和file_exists()，因为我们知道如果文件不存在，touch()会创建文件（尽管是空文件）。
- en: Ensuring That a Directory Exists
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 确保目录存在
- en: 'We’ve so far been working with files in the same directory as the executing
    script, but a file could also be in a different directory. In that case, it’s
    important to confirm that the directory exists (and perhaps create it if it doesn’t),
    since just like a missing file, a nonexistent directory will trigger a runtime
    warning. PHP has two built-in functions for this: is_dir() returns a Boolean value
    confirming whether a specified directory path can be found, and mkdir() attempts
    to create a directory at the specified path.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理与执行脚本位于同一目录中的文件，但文件也可能位于不同的目录中。在这种情况下，确认目录是否存在（并且如果不存在则可能需要创建它）非常重要，因为就像缺失的文件一样，不存在的目录会触发运行时警告。PHP有两个内置函数来处理这种情况：is_dir()返回一个布尔值，确认指定的目录路径是否可以找到，mkdir()则尝试在指定路径创建目录。
- en: NOTE
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* mkdir() *function will throw a runtime warning if the directory it’s
    trying to create already exists or if it can’t be created based on the current
    permissions settings. For more on permissions, see “Directory and File Permissions”
    on [page 163](#pg_163).*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*mkdir() 函数如果尝试创建的目录已存在，或者基于当前权限设置无法创建该目录，会抛出运行时警告。有关权限的更多信息，请参见[第 163 页](#pg_163)的《目录和文件权限》一章。*'
- en: To try these functions, update the contents of *main.php* as shown in [Listing
    9-7](#lis9-7).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这些函数，请按照[示例 9-7](#lis9-7)中所示更新 *main.php* 的内容。
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 9-7: An updated main.php script to create a directory if it doesn’t
    exist'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-7：一个更新后的 main.php 脚本，在目录不存在时创建该目录
- en: 'We break the desired path and filename into two variables: $dir holds the path
    to the directory where the file is to be read from, and $file holds the path plus
    the filename. We set $dir to the */var* subdirectory within the directory where
    our script is executing (__DIR__); this subdirectory doesn’t exist. The if (!is_dir($dir))
    statement checks whether $dir is *not* a valid directory path and calls mkdir()
    to create the directory if it isn’t. We’re then safe to call touch() on the file,
    since we now know the directory exists, and then to read the file, since touch()
    creates the file if it, too, doesn’t exist.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将目标路径和文件名拆分为两个变量：$dir 存储着文件所在目录的路径，$file 存储着路径加文件名。我们将 $dir 设置为执行脚本所在目录（__DIR__）下的*/var*
    子目录；该子目录不存在。if (!is_dir($dir)) 语句检查 $dir 是否*不是*有效的目录路径，如果不是有效路径，则调用 mkdir() 创建该目录。现在我们可以安全地调用
    touch() 创建文件，因为我们已经确认目录存在，然后读取文件，因为 touch() 会在文件不存在时创建该文件。
- en: 'The default option for mkdir() is that the function isn’t recursive: it will
    fail to create a directory if the parent of that directory doesn’t exist. However,
    the function has an optional recursive parameter; if it’s set to true, the function
    will create any missing parent directories as well. [Listing 9-8](#lis9-8) shows
    an example.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: mkdir() 的默认选项是非递归的：如果目标目录的父目录不存在，它将无法创建该目录。然而，该函数有一个可选的递归参数；如果设置为 true，函数将同时创建任何缺失的父目录。[示例
    9-8](#lis9-8) 中展示了一个示例。
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 9-8: An updated main.php script to recursively create directories if
    they’re missing'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-8：更新后的 main.php 脚本，如果目录缺失则递归创建目录
- en: The directory path now includes a */subsub* directory inside a */sub* directory
    inside the current directory of the executing script. Inside the if statement,
    we call mkdir() with the recursive argument set to true. This ensures that the
    function won’t create just the */subsub* directory but also its parent */sub*
    directory if necessary. We have to set recursive as a named argument, since mkdir()
    takes another optional argument to set the new directory’s permissions, and this
    argument comes before recursive in the function signature.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，目录路径包含一个位于当前执行脚本目录下的*/sub* 目录中的*/subsub* 子目录。在 if 语句内，我们调用 mkdir()，并将递归参数设置为
    true。这确保了该函数不仅会创建 */subsub* 目录，还会在必要时创建其父目录 */sub*。我们必须将递归设置为命名参数，因为 mkdir() 还接受另一个可选参数来设置新目录的权限，而该参数在函数签名中排在递归参数之前。
- en: Writing a String to a Text File
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将字符串写入文本文件
- en: Just as you can use file_get_contents() to read the contents of a file into
    a string, you can write the contents of a string to a text file by using the reciprocal
    file_put_contents() function. This function automatically creates the file being
    written to if it doesn’t exist, so you don’t need to worry about testing the filename
    first. The updated *main.php* script in [Listing 9-9](#lis9-9) shows how it works.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以使用 file_get_contents() 将文件内容读取到字符串中一样，你也可以使用互逆的 file_put_contents() 函数将字符串内容写入文本文件。如果目标文件不存在，file_put_contents()
    会自动创建该文件，因此你不需要事先测试文件名。更新后的 *main.php* 脚本在[示例 9-9](#lis9-9)中展示了其用法。
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 9-9: A main.php script writing data from a string to a file'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-9：一个 main.php 脚本将数据从字符串写入文件
- en: 'First, we declare a three-line heredoc string, $content, using CONTENT as the
    delimiter. Then we set the $file variable to the current directory path plus the
    filename *newfile.txt*. Next, we call the file_put_contents() function, passing
    it the destination file and the text to write to that file. This should create
    a file *newfile.txt* containing the text from the $content heredoc. To confirm
    that the file has been created with the text content, we use file_get_contents()
    to read the text back out of the file and into the $text variable, which we then
    print. Here’s the result:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个三行 heredoc 字符串 `$content`，使用 `CONTENT` 作为分隔符。然后，我们将 `$file` 变量设置为当前目录路径加上文件名
    *newfile.txt*。接下来，我们调用 `file_put_contents()` 函数，将目标文件和要写入该文件的文本传递给它。这应该会创建一个包含
    `$content` heredoc 内容的 *newfile.txt* 文件。为了确认文件已创建并包含文本内容，我们使用 `file_get_contents()`
    读取文件中的文本，并将其存储到 `$text` 变量中，然后打印出来。以下是结果：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The output matches the original heredoc string, indicating we successfully wrote
    the string to *newfile.txt* and read it back out again.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与原始 heredoc 字符串一致，表明我们成功地将字符串写入 *newfile.txt* 并再次读取出来。
- en: If the file you’re trying to write to already exists, the default behavior of
    file_put_contents() is to completely replace (overwrite) the contents of that
    file. To avoid this, call the function with the FILE_APPEND option. This adds
    the new text to the end of the file after its existing content. [Listing 9-10](#lis9-10)
    shows an example, updated from [Listing 9-9](#lis9-9).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图写入的文件已经存在，`file_put_contents()` 的默认行为是完全替换（覆盖）该文件的内容。为了避免这种情况，可以在调用该函数时使用
    FILE_APPEND 选项。这将把新文本添加到文件现有内容的末尾。[列表 9-10](#lis9-10) 展示了一个示例，更新自[列表 9-9](#lis9-9)。
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 9-10: A main.php script appending text to the end of a file'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-10：一个 main.php 脚本，将文本追加到文件末尾
- en: 'This time we create a different heredoc string and add it to *newfile.txt*
    by calling file_put_contents() with FILE_APPEND as a third argument. This should
    append the string after the current contents of the file, as the output confirms:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们创建一个不同的 heredoc 字符串，并通过将 FILE_APPEND 作为第三个参数调用 `file_put_contents()` 将其添加到
    *newfile.txt* 文件中。这应该会将字符串追加到文件当前内容之后，输出确认了这一点：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Try running the code in [Listing 9-10](#lis9-10) again without the FILE_APPEND
    option. You’ll find that only the text from $newContent appears in the output,
    since the existing text in the file is overwritten.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试再次运行[列表 9-10](#lis9-10)中的代码，不使用 FILE_APPEND 选项。你会发现只有 `$newContent` 中的文本出现在输出中，因为文件中已有的文本被覆盖了。
- en: Managing Files and Directories
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理文件和目录
- en: Beyond reading from and writing to files, PHP offers functions to help manage
    existing files and directories. For example, you can delete a file with the unlink()
    function or delete a whole directory with rmdir(). Both functions return true
    if successful or false otherwise. As with reading files, it’s important to test
    for the existence of a file or directory before attempting to delete it. Otherwise,
    if you call unlink() or rmdir() on a file or directory that doesn’t exist, you’ll
    get a warning (but execution will continue). [Listing 9-11](#lis9-11) shows these
    functions in action.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了读取和写入文件外，PHP 还提供了帮助管理现有文件和目录的函数。例如，你可以使用 `unlink()` 函数删除文件，或者使用 `rmdir()`
    删除整个目录。如果成功，两个函数都会返回 true，否则返回 false。与读取文件一样，在尝试删除文件之前，测试文件或目录是否存在非常重要。否则，如果你对不存在的文件或目录调用
    `unlink()` 或 `rmdir()`，你会收到警告（但执行会继续）。[列表 9-11](#lis9-11) 展示了这些函数的实际应用。
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 9-11: A main.php script to create and then delete a directory and a
    file'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-11：一个 main.php 脚本，用于创建并删除目录和文件
- en: As in some earlier examples, we declare the target directory and filename in
    two variables, $dir and $file. We then create the directory if it doesn’t already
    exist and touch() the file. At this point, we should be confident that a *data.txt*
    file exists in a */var* directory; we confirm this by var_dumping the results
    of calling is_dir() and file_exists(). Next, we use unlink($file) and rmdir($dir)
    to delete the file and its directory. Finally, we make the same var_dump() calls
    again to make sure that neither the directory nor the file exists when the script
    finishes execution. If you run this script, you should see true, true, false,
    false displayed, confirming that the directory and file existed and then were
    successfully deleted.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的一些示例一样，我们在两个变量 $dir 和 $file 中声明目标目录和文件名。然后，如果目录尚未存在，我们会创建该目录，并通过 touch()
    创建文件。此时，我们应该确保在*/var* 目录中存在 *data.txt* 文件；我们通过调用 is_dir() 和 file_exists() 并使用
    var_dump() 来确认这一点。接下来，我们使用 unlink($file) 和 rmdir($dir) 删除文件及其目录。最后，我们再次调用 var_dump()，以确保在脚本执行完毕后，目录和文件都不存在。如果你运行此脚本，你应该看到
    true, true, false, false 的输出，确认目录和文件曾经存在并已成功删除。
- en: 'Another useful file-management function is rename(), which changes the name
    of a file or directory. For example, you could rename *oldfile.txt* to *newfile.txt*
    with this statement:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的文件管理函数是rename()，它用于更改文件或目录的名称。例如，你可以使用以下语句将*oldfile.txt*重命名为*newfile.txt*：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You need to be careful with this function, testing that the old file or directory
    exists first. It’s also important to be mindful about the new file or directory.
    If you’re renaming a file and another file already exists with that name, it will
    be overwritten with no error or warning, which could be problematic if you need
    the contents of that overwritten file. If you’re renaming a directory and the
    new directory already exists, a warning will be generated, which is also not ideal,
    since it’s best to avoid warnings. If you’re renaming a file into a different
    directory, you also should ensure that the new directory exists and, if appropriate,
    is writable (which is required by Windows). See *[https://www.php.net/manual/en/function.rename.php](https://www.php.net/manual/en/function.rename.php)*
    for more about this function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数时需要小心，首先要测试旧的文件或目录是否存在。还需要特别注意新文件或目录。如果你正在重命名一个文件，而另一个同名的文件已经存在，那么该文件将被覆盖而不会显示错误或警告，如果你需要被覆盖文件的内容，这可能会造成问题。如果你正在重命名一个目录，而新目录已经存在，则会生成一个警告，这也不是理想的情况，因为最好避免出现警告。如果你正在将文件重命名到另一个目录中，你还应该确保新目录存在，并且如果需要的话，该目录是可写的（这是
    Windows 系统的要求）。有关此函数的更多信息，请参见 *[https://www.php.net/manual/en/function.rename.php](https://www.php.net/manual/en/function.rename.php)*。
- en: Reading a File into an Array
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将文件读取到数组中
- en: PHP’s built-in file() function reads the contents of a file into an array rather
    than a single string, with one array element for each line in the file. This is
    useful when you want to perform an action for each line (such as displaying the
    line’s contents alongside its line number, as in the following example), or when
    each line represents one item in a set of data to be processed, such as the data
    in a comma-separated values (CSV) file. [Listing 9-12](#lis9-12) shows a main
    script demonstrating the file() function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 内置的 file() 函数将文件的内容读取到一个数组中，而不是单一的字符串，每一行对应数组中的一个元素。当你想对每一行执行某个操作（例如，像以下示例一样显示行的内容及其行号），或者当每一行代表需要处理的数据集中的一个项时，这个功能非常有用，比如逗号分隔值（CSV）文件中的数据。*Listing
    9-12* 展示了一个主脚本，演示了 file() 函数的用法。
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 9-12: A main.php script to loop through and print each line of a text
    file'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 9-12: 一个用于循环遍历并打印文本文件每一行的 main.php 脚本'
- en: 'We pass the file information (in the $file variable) to the file() function,
    which reads the contents of *data.txt* line by line into an array called $lines.
    Then we use a foreach loop to print each element of the array (a line from the
    file) individually, along with its numeric key. If *data.txt* contains the three-line
    haiku from [Listing 9-1](#lis9-1), the output should look as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文件信息（保存在$file变量中）传递给 file() 函数，后者会将*data.txt*的内容逐行读取到一个名为$lines的数组中。然后，我们使用
    foreach 循环逐个打印数组的每个元素（文件中的一行），并显示其数字键。如果*data.txt*包含*Listing 9-1*中的三行俳句，则输出应该如下所示：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can pass optional flags as a second argument to the file() function to,
    for example, exclude the newline character at the end of each line (FILE_IGNORE_NEW_LINES)
    or completely ignore empty lines in the file (FILE_SKIP_EMPTY_LINES).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将可选的标志作为第二个参数传递给 file() 函数，例如，排除每行末尾的换行符（FILE_IGNORE_NEW_LINES）或完全忽略文件中的空行（FILE_SKIP_EMPTY_LINES）。
- en: Using Lower-Level File Functions
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用低级文件函数
- en: The file_get_contents() and file_put_contents() functions take care of all the
    steps of working with a file for you, such as opening the file, accessing its
    contents, and closing the file again. In most situations, those functions are
    all you need. Sometimes, however, you may need to work with files at a lower level,
    perhaps processing them one line, or even one character, at a time. In those cases,
    you might need to explicitly manage the various file-access steps in your code
    through a series of separate, lower-level function calls.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: file_get_contents() 和 file_put_contents() 函数会为你处理所有与文件相关的步骤，比如打开文件、访问文件内容以及再次关闭文件。在大多数情况下，这些函数已经足够满足需求。然而，有时你可能需要更低级地处理文件，可能是逐行，甚至逐字符地处理。在这种情况下，你可能需要通过一系列单独的低级函数调用来显式地管理文件访问的各个步骤。
- en: PHP’s lower-level file functions require you to work with a *filesystem pointer*
    (or just *file pointer*), a reference to a location in the file’s data. Internally,
    PHP treats a file as a *bytestream* (a resource object that can be read from and
    written to in a linear fashion), and the file pointer provides access to that
    stream. You obtain a file pointer by calling fopen() with a path to the file you
    want to access. You also have to pass in a string specifying *how* you want to
    interact with the file; for example, files can be opened only for reading, only
    for writing, for both reading and writing, and so on. [Table 9-1](#tab9-1) shows
    the strings for specifying some common fopen() modes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的低级文件函数要求你使用 *文件系统指针*（或简称 *文件指针*），这是文件数据位置的引用。在内部，PHP 将文件视为 *字节流*（一个可以线性读取和写入的资源对象），文件指针提供对该字节流的访问。你可以通过调用
    fopen() 并传入你想访问的文件路径来获得文件指针。你还需要传入一个字符串，指定 *如何* 与文件进行交互；例如，文件可以只为读取、只为写入、同时为读写等模式打开。[表
    9-1](#tab9-1) 显示了指定一些常见 fopen() 模式的字符串。
- en: 'Table 9-1: Common fopen() Modes'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-1：常见的 fopen() 模式
- en: '| Mode string | Description | Position of file pointer | Outcome if file doesn’t
    exist |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 模式字符串 | 描述 | 文件指针位置 | 如果文件不存在的结果 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ''r'' | Read only | Beginning of file | Warning |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| ''r'' | 仅读 | 文件开头 | 警告 |'
- en: '| ''r+'' | Read and write (overwrite) | Beginning of file | Warning |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| ''r+'' | 读写（覆盖） | 文件开头 | 警告 |'
- en: '| ''w'' | Write only (overwrite) | Beginning of file (and truncate the file
    by removing any existing content) | Attempt to create a file |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| ''w'' | 仅写（覆盖） | 文件开头（并通过移除现有内容来截断文件） | 尝试创建文件 |'
- en: '| ''a'' | Write only (append) | End of file | Attempt to create a file |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| ''a'' | 仅写（追加） | 文件末尾 | 尝试创建文件 |'
- en: 'The typical sequence of actions when working with a file is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 操作文件的典型步骤如下：
- en: 1.   Open a file in the appropriate mode and get a file pointer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   以适当的模式打开文件并获取文件指针。
- en: 2.   Change the location of the file pointer in the file if necessary.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   如果需要，改变文件指针在文件中的位置。
- en: 3.   Read or write at the location of the file pointer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   在文件指针的位置读取或写入。
- en: 4.   Repeat steps 2 and 3 as required.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 4.   根据需要重复步骤 2 和 3。
- en: 5.   Close the file pointer.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 5.   关闭文件指针。
- en: '[Listing 9-13](#lis9-13) demonstrates this process. This script achieves the
    same results as [Listing 9-2](#lis9-2) (reading the contents of a file to a string)
    by using the lower-level fopen(), fread(), and fclose() functions.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-13](#lis9-13) 演示了这个过程。这个脚本通过使用低级的 fopen()、fread() 和 fclose() 函数，达到了与
    [示例 9-2](#lis9-2)（将文件内容读取为字符串）相同的效果。'
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 9-13: Using lower-level functions to read a file'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-13：使用低级函数读取文件
- en: First, we use fopen() to open *data.txt*, using the string 'r' to specify read-only
    mode. The function returns a file pointer located at the beginning of the file,
    which we store in the $fileHandle variable. Next, we call filesize() to look up
    the size of the file (in bytes). We then call the fread() function, passing it
    the file pointer and the size of the file ($filesizeBytes) to read the entire
    contents of the file into the $text variable. If we wanted to read only part of
    the file, we could specify a different number of bytes as the second argument
    to the fread() function. (We’d also want to specify a different number of bytes
    if the file pointer were located somewhere other than the beginning of the file.)
    To finish up, we close the file by passing the file pointer to the fclose() function.
    Closing the file enables it to be used by other system processes and protects
    it from being corrupted if any errors occur in the script currently being executed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 fopen() 打开 *data.txt*，使用字符串 'r' 来指定只读模式。该函数返回一个文件指针，指向文件的开头，我们将其存储在
    $fileHandle 变量中。接下来，我们调用 filesize() 查找文件的大小（以字节为单位）。然后我们调用 fread() 函数，将文件指针和文件大小（$filesizeBytes）传递给它，以将整个文件的内容读取到
    $text 变量中。如果我们只想读取文件的一部分，可以在 fread() 函数的第二个参数中指定不同的字节数。（如果文件指针位于文件的某个位置而不是开头，我们也需要指定不同的字节数。）最后，我们通过将文件指针传递给
    fclose() 函数来关闭文件。关闭文件可以使其被其他系统进程使用，并在脚本执行过程中发生错误时防止文件被损坏。
- en: 'This example illustrates some of the most common low-level file functions,
    but PHP has many others. For example, fgets() reads one line of a file (up to
    the next newline) from the current file-pointer location, and fgetc() reads just
    one character from the current file-pointer location. The feof() function takes
    in a file pointer and returns true or false based on whether the pointer is at
    the end of the file. This is useful for loops such as the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例展示了一些最常见的低级文件操作函数，但 PHP 还有许多其他函数。例如，fgets() 从当前文件指针位置读取一行（直到下一个换行符），fgetc()
    从当前文件指针位置读取一个字符。feof() 函数接受一个文件指针，并根据指针是否处于文件末尾返回 true 或 false。这在如下循环中非常有用：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we use the NOT operator (!) to negate the result of feof(), so the loop
    will keep repeating until the pointer gets to the end of the file. Inside this
    kind of loop, we might read a line from the file with fgets(), read the next character
    with fgetc(), or read a fixed number of bytes with fread(). Logic in the loop
    would then process the data (if successfully read), and if we reach the end of
    the file while reading, the loop would terminate.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用 NOT 运算符（!）来否定 feof() 的结果，因此循环将持续进行，直到指针到达文件末尾。在这种循环中，我们可能会使用 fgets()
    从文件中读取一行，使用 fgetc() 读取下一个字符，或者使用 fread() 读取固定数量的字节。然后，循环中的逻辑将处理读取到的数据（如果成功读取），如果在读取过程中到达文件末尾，循环将终止。
- en: Some functions are just for working with and changing the file pointer. For
    example, rewind() moves the file pointer back to the beginning of the file, and
    ftell() returns the current location of the pointer, specified as the number of
    bytes from the start of the file. The fseek() function moves the file pointer
    to a given position in the file specified relative to its current position, the
    beginning or the end of the file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数只是用于操作和更改文件指针。例如，rewind() 将文件指针移回到文件的开头，ftell() 返回文件指针的当前位置信息，表示为从文件开头开始的字节数。fseek()
    函数将文件指针移动到文件中的指定位置，该位置相对于当前指针位置、文件开头或文件末尾指定。
- en: Processing Multiple Files
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理多个文件
- en: Let’s combine a lot of what we’ve discussed so far in this chapter in a more
    sophisticated example that programmatically extracts data from multiple files
    and collects it all in a new summary file. We’ll attempt to gather the names and
    game scores of three players, each in a separate file (*joe.txt*, *matt.txt*,
    and *sinead.txt*), reformat the data, and write it to a single output file called
    *total.txt*. [Listings 9-14](#lis9-14) through [9-16](#lis9-16) show the three
    raw data files we want to process.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个更复杂的示例，将本章迄今讨论的内容结合起来，程序化地从多个文件中提取数据，并将其汇总到一个新的摘要文件中。我们将尝试收集三名玩家的姓名和游戏分数，每个玩家的数据存储在单独的文件中（*joe.txt*、*matt.txt*
    和 *sinead.txt*），对数据进行重新格式化，然后写入名为 *total.txt* 的输出文件中。[清单 9-14](#lis9-14) 到 [9-16](#lis9-16)
    显示了我们想要处理的三个原始数据文件。
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 9-14: joe.txt'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-14：joe.txt
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 9-15: matt.txt'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-15：matt.txt
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 9-16: sinead.txt'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-16：sinead.txt
- en: 'Notice that the content in each data file is a little messy, with randomly
    located blank lines: [Listing 9-15](#lis9-15) ends with a blank line, and [Listing
    9-16](#lis9-16) starts and ends with two blank lines. That said, each data file
    has the same sequence of content: a line containing the player’s first name, a
    line with their last name, and a line with their integer score.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个数据文件的内容有点杂乱，存在随机位置的空行：[清单 9-15](#lis9-15)以一个空行结尾，[清单 9-16](#lis9-16)以两个空行开始和结束。尽管如此，每个数据文件的内容顺序是相同的：第一行包含玩家的名字，第二行包含他们的姓氏，第三行包含他们的整数分数。
- en: In the output file, we want to consolidate all the data about each player onto
    a single line, as well as display the total of all three players’ scores. [Listing
    9-17](#lis9-17) shows how the resulting *total.txt* file should appear.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出文件中，我们希望将每个玩家的所有数据合并到一行中，并显示所有三名玩家分数的总和。[清单 9-17](#lis9-17)展示了最终生成的*total.txt*文件应该如何显示。
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 9-17: The consolidated total.txt file we want to create'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-17：我们想要创建的合并后的total.txt文件
- en: To achieve this final result, we’ll need to handle each part of the data files
    differently, so we can’t simply load a whole file into a string with file_get_contents().
    It will be better to use file() to read in each file as an array of individual
    lines.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现最终结果，我们需要分别处理每个数据文件的不同部分，因此不能仅仅使用file_get_contents()将整个文件加载为一个字符串。更好的做法是使用file()函数将每个文件读取为一个包含单独行的数组。
- en: 'When working with multiple files, PHP’s oddly named glob() function is a powerful
    tool. It returns an array of file and directory paths that match a given pattern.
    This is particularly helpful for identifying and then looping through all the
    data files in a given location. For example, the following statement provides
    an array of paths to all *.txt* files in the */data* subfolder relative to the
    location of the executing script:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理多个文件时，PHP名为glob()的函数是一个强大的工具。它返回一个匹配给定模式的文件和目录路径数组。这对于识别并循环遍历指定位置的所有数据文件特别有用。例如，以下语句提供了一个包含*/data*子文件夹中所有*.txt*文件路径的数组，相对于执行脚本所在的位置：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The * is a wildcard representing any number of characters, so '/data/*.txt'
    will match any filename with a *.txt* extension in the given folder. That’s exactly
    what we’ll need to gather the player data files in this example.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*是一个通配符，代表任意数量的字符，因此''/data/*.txt''将匹配给定文件夹中任何以*.txt*扩展名结尾的文件名。这正是我们在这个示例中收集玩家数据文件所需要的。'
- en: Start a new project and create a */data* subfolder containing the text files
    *joe.txt*, *matt.txt*, and *sinead.txt* shown previously in [Listings 9-14](#lis9-14)
    through [9-16](#lis9-16). Then, in the main project folder, create a *main.php*
    script with the contents of [Listing 9-18](#lis9-18).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新项目，并创建一个包含前面在[清单 9-14](#lis9-14)至[9-16](#lis9-16)中展示的文本文件*joe.txt*、*matt.txt*和*sinead.txt*的*/data*子文件夹。然后，在主项目文件夹中，创建一个名为*main.php*的脚本，并包含[清单
    9-18](#lis9-18)中的内容。
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 9-18: A script processing multiple files'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-18：处理多个文件的脚本
- en: We first assign the path to the */data* subfolder from the location of the executing
    script to the $dir variable, and the filename pattern string '*.txt' to $fileNamePattern,
    using the * wildcard to represent any *.txt* file. We then call glob() to get
    an array of all the files in $dir matching the pattern in $fileNamePattern, storing
    the result in the $files variable ❶. Thanks to glob(), we know that all the files
    in the $files array exist, so we can avoid the ordeal of checking whether they
    exist before trying to read them.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将执行脚本所在位置的*/data*子文件夹路径赋值给$dir变量，并将文件名模式字符串'*.txt'赋值给$fileNamePattern，使用*通配符表示任何*.txt*文件。接着，我们调用glob()函数，获取$dir中与$fileNamePattern匹配的所有文件数组，并将结果存储在$files变量中❶。由于glob()函数的帮助，我们知道$files数组中的所有文件都存在，因此可以避免在尝试读取文件之前检查它们是否存在的麻烦。
- en: Next, we assign a path to *total.txt* to the $outputFile variable. This file
    may or may not exist already, but we want a fresh output file each time we run
    the script. We therefore touch() the file, which creates it if it doesn’t exist
    already, and then use unlink() to delete the file. Now we can be sure that we’re
    writing to an empty file when it comes time to gather the data into *total.txt*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将*total.txt*的路径赋值给$outputFile变量。这个文件可能已经存在，也可能不存在，但我们希望每次运行脚本时都能生成一个新的输出文件。因此，我们使用touch()函数来创建文件（如果它尚不存在），然后使用unlink()函数删除该文件。现在，我们可以确保在将数据合并到*total.txt*时，文件是空的。
- en: 'After initializing the $total variable to 0, we use a foreach loop ❷ to iterate
    over the filepaths in the $files array, storing each path in a temporary $file
    variable. For each file, we use file() to read the contents into an array called
    $lines. Calling the function with the FILE_IGNORE_NEW_LINES and FILE_SKIP_EMPTY_LINES
    flags ensures that end-of-line characters will be ignored and that empty lines
    will be excluded from the resulting array. Knowing what we know about each data
    file, this means that $lines should be a three-element array: the first element
    is the player’s first name, the second element is their last name, and the third
    element is their score (represented as a string). We read these values from the
    array into separate $firstName, $lastName, and $scoreString variables and use
    the built-in intval() function to convert the score from a string to an integer.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在将$total变量初始化为0之后，我们使用foreach循环❷遍历$files数组中的文件路径，将每个路径存储到临时变量$file中。对于每个文件，我们使用file()函数将其内容读取到一个名为$lines的数组中。使用FILE_IGNORE_NEW_LINES和FILE_SKIP_EMPTY_LINES标志调用该函数，确保忽略行尾字符并排除空行。这意味着根据我们对每个数据文件的了解，$lines应该是一个包含三个元素的数组：第一个元素是玩家的名字，第二个元素是他们的姓氏，第三个元素是他们的分数（以字符串形式表示）。我们从数组中读取这些值到单独的$firstName、$lastName和$scoreString变量，并使用内置的intval()函数将分数从字符串转换为整数。
- en: Still within the foreach loop, we call fopen() to get a file pointer to the
    output file (*total.txt*) in write-append mode (specified with the 'a' mode string),
    meaning the pointer will be located at the end of the file. The first time through
    the loop, *total.txt* won’t exist, so fopen() will create the file. We then use
    fwrite() to append a string to the output file, summarizing the player’s name
    and score and ending with a newline character (\n) ❸. We close the output file
    with fclose() and add the current player’s score to the $total variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在foreach循环内，我们调用fopen()来获取输出文件（*total.txt*）的文件指针，采用写附加模式（通过模式字符串'a'指定），这意味着指针将定位到文件末尾。第一次通过循环时，*total.txt*文件不会存在，因此fopen()会创建该文件。然后，我们使用fwrite()将一个字符串附加到输出文件中，总结玩家的姓名和分数，并以换行符（\n）结束❸。我们通过fclose()关闭输出文件，并将当前玩家的分数添加到$total变量中。
- en: Finally, after the foreach loop has completed, we once again access the output
    file in write-append mode and append a final string including the value of $total.
    Then, to make sure this has all worked, we call file_get _contents() to read the
    output file into a string and print the result ❹. Notice that we call the function
    directly from the print statement, instead of storing the string in a variable
    first.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在foreach循环完成后，我们再次以写附加模式访问输出文件，并附加一个包含$total值的最终字符串。然后，为了确保一切正常工作，我们调用file_get_contents()函数读取输出文件到一个字符串中并打印结果❹。注意，我们直接从打印语句中调用该函数，而不是先将字符串存储到一个变量中。
- en: If you run the *main.php* script, you should get the *total.txt* file shown
    previously in [Listing 9-17](#lis9-17). In fact, you can run this script as many
    times as you want and the result will always be the same, since any existing *total.txt*
    file is deleted with the combination of the touch() and unlink() functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行*main.php*脚本，你应该得到之前在[列表9-17](#lis9-17)中显示的*total.txt*文件。事实上，你可以随意多次运行该脚本，结果将始终相同，因为任何现有的*total.txt*文件都会在touch()和unlink()函数的组合操作下被删除。
- en: Strictly speaking, our *main.php* script isn’t the most efficient way to code
    the desired logic. We don’t need to open and close the output file each time during
    the foreach loop; we could open it just once before the loop and then close it
    once after appending the total score. However, opening it each time through the
    loop illustrates the value of write-append mode, which places the file pointer
    at the end of the file. This way, any new content written to the file is added
    after any existing content.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，我们的*main.php*脚本并不是实现所需逻辑的最高效方式。我们不需要在每次执行foreach循环时都打开和关闭输出文件；我们可以在循环之前只打开一次文件，然后在附加总分后再关闭它。然而，每次通过循环时打开文件可以说明写附加模式的价值，这种模式将文件指针放置在文件的末尾。这样，任何新写入文件的内容都会被添加到现有内容之后。
- en: JSON and Other File Types
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON和其他文件类型
- en: PHP can work with more than *.txt* files. For example, it can also work with
    JavaScript Object Notation (JSON) and other text-based data formats. For JSON
    data, the built-in json_encode() function can turn a PHP array into a JSON string,
    and the json_decode() function does the opposite. This type of conversion is particularly
    smooth since JSON data, like PHP arrays, revolves around key/value pairs. [Listing
    9-19](#lis9-19) shows these functions in action.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 不仅能处理 *.txt* 文件。例如，它还可以处理 JavaScript 对象表示法（JSON）以及其他基于文本的数据格式。对于 JSON 数据，内置的
    json_encode() 函数可以将 PHP 数组转换为 JSON 字符串，而 json_decode() 函数则执行相反的操作。这种类型的转换特别顺畅，因为
    JSON 数据与 PHP 数组一样，都是围绕键/值对构建的。[示例 9-19](#lis9-19) 展示了这些函数的实际应用。
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 9-19: A script to convert an array to JSON, and vice versa'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-19：一个将数组转换为 JSON 以及将 JSON 转换回数组的脚本
- en: We store a path to *data.json* in the $filePath variable. Then we declare a
    $data array that maps the values 'matt', 'E-042', and '086-111-2323' to the keys
    'name', 'office', and 'phone', respectively. Next, we use the json_encode() function
    to convert the array to a JSON-formatted string, storing the result in the $jsonString
    variable. We then use file_put_contents() to write the JSON string to the *data.json*
    file, just as we would use it to write to a *.txt* file.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 *data.json* 的路径存储在 $filePath 变量中。然后我们声明一个 $data 数组，将 'matt'、'E-042' 和 '086-111-2323'
    分别映射到键 'name'、'office' 和 'phone'。接下来，我们使用 json_encode() 函数将数组转换为 JSON 格式的字符串，并将结果存储在
    $jsonString 变量中。然后，我们使用 file_put_contents() 将 JSON 字符串写入 *data.json* 文件，就像我们写入
    *.txt* 文件一样。
- en: 'The rest of the script goes through the same process in reverse. We use file_get_contents()
    to read the JSON data from the file into the $jsonStringFromFile variable, which
    we print out. The variable contains a JSON string, but we use json_decode() to
    convert the string into a PHP array, which we display using var_dump(). We need
    to provide true as a second argument to the json_decode() function, or the result
    will be a type of object rather than an array. Here’s the output of running this
    script at the terminal:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的其余部分执行相同的反向操作。我们使用 file_get_contents() 从文件中读取 JSON 数据到 $jsonStringFromFile
    变量中，并将其打印出来。该变量包含一个 JSON 字符串，但我们使用 json_decode() 将字符串转换为 PHP 数组，并通过 var_dump()
    展示。我们需要提供 true 作为 json_decode() 函数的第二个参数，否则结果将是一个对象类型，而不是数组类型。以下是运行此脚本时在终端的输出：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first line shows the JSON string that we wrote into and read back out of
    the *data.json* file. The string consists of a JSON object, delimited by curly
    brackets, containing three key/value pairs separated by commas. The keys are set
    off from their corresponding values by colons. The rest of the output shows the
    contents of $jsonArrayFromFile, the array created by decoding the JSON data. Notice
    the direct correlation between the key/value pairs in the JSON object and the
    key/value pairs in the PHP array.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行展示了我们写入并从 *data.json* 文件中读取的 JSON 字符串。该字符串由一个 JSON 对象组成，使用大括号括起来，包含三个由逗号分隔的键/值对。键与其对应的值通过冒号分隔。其余部分显示了
    $jsonArrayFromFile 的内容，这是通过解码 JSON 数据创建的数组。注意 JSON 对象中的键/值对与 PHP 数组中的键/值对之间的直接对应关系。
- en: 'For YAML Ain’t Markup Language (YAML) text data files, PHP provides several
    functions. For example, yaml_parse() and yaml_emit() are similar to json_decode()
    and json_encode() but for converting between YAML strings and PHP arrays. PHP
    also has direct file-to-string and string-to-file YAML functions: yaml_parse_file()
    and yaml_emit_file().'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 YAML（YAML 不是标记语言）文本数据文件，PHP 提供了多个函数。例如，yaml_parse() 和 yaml_emit() 函数类似于 json_decode()
    和 json_encode()，用于在 YAML 字符串和 PHP 数组之间转换。PHP 还提供了直接的文件到字符串和字符串到文件的 YAML 函数：yaml_parse_file()
    和 yaml_emit_file()。
- en: For CSV files, PHP has the direct file-to-string and string-to-file functions
    fgetcsv() and fputcsv(). The str_getcsv() function takes a string in CSV format
    and converts it to an array. However, the function has some flaws. It doesn’t
    escape newline characters, for example, so it can’t cope with typical CSV files
    from spreadsheets like Google Sheets or Microsoft Excel. Perhaps because of this
    nonstandard treatment of CSV data, PHP doesn’t have a reciprocal function to create
    a CSV-encoded string from an array.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 CSV 文件，PHP 提供了直接的文件到字符串和字符串到文件的函数 fgetcsv() 和 fputcsv()。str_getcsv() 函数接受一个
    CSV 格式的字符串并将其转换为数组。然而，该函数存在一些缺陷。例如，它不会转义换行符，因此无法处理来自电子表格（如 Google Sheets 或 Microsoft
    Excel）的典型 CSV 文件。可能正因为这样 PHP 在处理 CSV 数据时不符合标准，导致它没有一个相应的函数来从数组创建 CSV 编码的字符串。
- en: Working with eXtensible Markup Language (XML) is a little more complex. PHP
    represents XML data with objects, so you need to be confident with the basics
    of object-oriented programming to use functions such as simplexml_load_file()
    and classes such as SimpleXMLElement. However, PHP provides several powerful ways
    to traverse and manipulate XML data once you know how to use these features of
    the language. We’ll discuss object-oriented PHP in [Part V](part5.xhtml).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可扩展标记语言（XML）要复杂一些。PHP 用对象表示 XML 数据，因此你需要掌握面向对象编程的基础知识，才能使用像 simplexml_load_file()
    这样的函数和 SimpleXMLElement 这样的类。然而，一旦你掌握了这些语言特性，PHP 提供了几种强大的方法来遍历和操作 XML 数据。我们将在
    [Part V](part5.xhtml) 中讨论面向对象的 PHP。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we worked with basic PHP functions like file_get_contents()
    and file_put_contents() for reading and writing data to and from external files.
    We also discussed the file() function, which reads the lines of a file into separate
    array elements, and low-level functions like fread() and fwrite() that let you
    traverse a file by using a pointer. We explored how to ensure that a file or directory
    exists (or doesn’t exist) before interacting with it, and how to use glob() to
    get a reference to all the files that match a certain criterion. Although we mostly
    worked with *.txt* files, we also touched on some PHP functions for interacting
    with JSON, YAML, CSV, and XML data formats.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了基本的 PHP 函数，如 file_get_contents() 和 file_put_contents()，用于读取和写入外部文件的数据。我们还讨论了
    file() 函数，它将文件的每一行读取为单独的数组元素，以及像 fread() 和 fwrite() 这样的低级函数，它们允许你通过指针遍历文件。我们探讨了如何在与文件交互之前，确保文件或目录存在（或不存在），以及如何使用
    glob() 获取所有匹配特定标准的文件的引用。虽然我们大部分时间都在处理 *.txt* 文件，但我们也涉及了一些 PHP 函数，用于处理 JSON、YAML、CSV
    和 XML 数据格式。
- en: Exercises
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '1.   Find a limerick online or write your own. Here’s one I found:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 1.   在网上找一首打油诗，或者自己写一首。我找到了一首：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Write a script that declares an array; each element of the array is a line from
    the limerick. Then write those lines to a text file named *limerick.txt*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个脚本，声明一个数组；数组的每个元素是打油诗中的一行。然后将这些行写入一个名为*limerick.txt*的文本文件中。
- en: 2.   Find a sample JSON file online that’s accessible through a URL (for example,
    at *[https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)*).
    Write a script that reads the JSON string from the URL, converts it to an array,
    and then uses var_dump() to display the array.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 2.   在网上找到一个可以通过 URL 访问的示例 JSON 文件（例如，* [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)
    *）。编写一个脚本，从 URL 读取 JSON 字符串，将其转换为数组，然后使用 var_dump() 显示该数组。
- en: 3.   Add a new data file for a game player and their high score in the *data*
    folder to be processed by the script in [Listing 9-18](#lis9-18). Run the main
    script, and you should see another line added to the output file and the new score
    added to the total.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 3.   在 *data* 文件夹中为游戏玩家及其最高分添加一个新的数据文件，以供 [Listing 9-18](#lis9-18) 中的脚本处理。运行主脚本，你应该会看到输出文件中多了一行，并且新分数已添加到总分中。
