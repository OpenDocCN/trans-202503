- en: Chapter 19. Fuzzing, Porting Exploits, and Metasploit Modules
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第19章. Fuzzing、移植利用和Metasploit模块
- en: In this chapter, we will review a few more basic exploit development techniques.
    We will look at using a technique called *fuzzing* to find potential exploits
    in vulnerable programs. We will also cover working with public exploit code and
    safely porting it to meet our needs, as well the basics of building our own Metasploit
    modules. Finally, we will discuss some of the exploitation mitigation techniques
    that our targets may have in place.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾一些更基础的利用开发技术。我们将研究如何使用一种叫做*fuzzing*的技术，找出易受攻击程序中的潜在漏洞。我们还将讨论如何处理公开的利用代码并安全地将其移植以满足我们的需求，以及构建我们自己的Metasploit模块的基础知识。最后，我们将讨论一些可能已被目标防御的漏洞缓解技术。
- en: Fuzzing Programs
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fuzzing程序
- en: In [Chapter 17](ch17.xhtml "Chapter 17. A Stack-Based Buffer Overflow in Windows"),
    we exploited War-FTP version 1.65’s Username field buffer overflow with a 1,100-byte
    exploit string. The natural question is, how did we know that 1,100 *A*s in the
    Username field would crash the program, and, more importantly, how did security
    researchers find this vulnerability for the first time? In some cases, source
    code for programs is publicly available, so a researcher looking for vulnerabilities
    need only be well versed in secure coding practices. In other cases, we can use
    a popular method called *fuzzing* to send various inputs to a program, hoping
    that something strange will happen.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第17章](ch17.xhtml "第17章. Windows中的基于栈的缓冲区溢出")中，我们利用了War-FTP版本1.65的用户名字段缓冲区溢出，使用了一个1,100字节的利用字符串。自然的问题是，我们怎么知道在用户名字段中填入1,100个*A*会导致程序崩溃，更重要的是，安全研究人员是如何首次发现这个漏洞的？在某些情况下，程序的源代码是公开的，因此寻找漏洞的研究人员只需要熟练掌握安全编码实践。在其他情况下，我们可以使用一种流行的方法叫做*fuzzing*，通过向程序发送各种输入，期望能发生一些奇怪的事情。
- en: Finding Bugs with Code Review
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过代码审查发现漏洞
- en: In [Chapter 16](ch16.xhtml "Chapter 16. A Stack-Based Buffer Overflow in Linux"),
    we used a short Linux program to illustrate a buffer overflow vulnerability. When
    auditing the source code of this program (as shown in [Example 19-1](ch19.xhtml#vulnerable_c_code
    "Example 19-1. Vulnerable C code")), we see the `strcpy` function ❶. As discussed
    in that chapter, this function does no bounds checking and may be a security risk.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第16章](ch16.xhtml "第16章. Linux中的基于栈的缓冲区溢出")中，我们使用了一个简短的Linux程序来说明缓冲区溢出漏洞。当审计该程序的源代码时（如[示例19-1](ch19.xhtml#vulnerable_c_code
    "示例19-1. 漏洞C代码")所示），我们看到了`strcpy`函数 ❶。正如该章节中所讨论的，这个函数没有进行边界检查，可能会带来安全风险。
- en: Example 19-1. Vulnerable C code
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-1. 漏洞C代码
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Reading through this source code, we see that user input (the first program
    argument) is passed to `function` ❷. The user input is then copied into a five-character
    string called `buffer` using `strpy` ❶. As we saw in [Chapter 16](ch16.xhtml "Chapter 16. A
    Stack-Based Buffer Overflow in Linux"), we can exploit this behavior to create
    a stack-based buffer overflow.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这段源代码时，我们看到用户输入（第一个程序参数）被传递给`function` ❷。然后，用户输入被通过`strpy` ❶复制到一个五字符的字符串`buffer`中。正如我们在[第16章](ch16.xhtml
    "第16章. Linux中的基于栈的缓冲区溢出")中看到的那样，我们可以利用这种行为来创建基于栈的缓冲区溢出。
- en: Fuzzing a Trivial FTP Server
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Fuzzing一个简单的FTP服务器
- en: When we don’t have access to a program’s source code, we have to use other methods
    to find potentially exploitable security issues. We can use fuzzing to send various
    inputs to the program that the developer never intended the code to process. If
    we can find input that will manipulate memory in a controllable way, we may be
    able to exploit the program.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们无法访问程序的源代码时，我们必须使用其他方法来寻找可能被利用的安全问题。我们可以通过fuzzing向程序发送各种输入，这些输入是开发者从未打算让代码处理的。如果我们能找到能够以可控方式操作内存的输入，我们可能就能利用这个程序。
- en: In [Chapter 17](ch17.xhtml "Chapter 17. A Stack-Based Buffer Overflow in Windows"),
    when exploiting War-FTP 1.65, we first made the program crash by sending 1,100
    *A*s in the Username field. Once we determined that EIP contained four *A*s, as
    well as a long string of *A*s from the ESP register, we concluded that this issue
    was exploitable and proceeded to write a working stack-based buffer overflow exploit.
    In the following example, we start a step earlier and use fuzzing to determine
    how many *A*s we need to send to a program in order to crash it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第17章](ch17.xhtml "第17章. Windows中的基于栈的缓冲区溢出")中，在利用War-FTP 1.65时，我们首先通过在用户名字段发送1100个*A*字符让程序崩溃。一旦我们确定EIP包含四个*A*字符，并且从ESP寄存器中有一长串的*A*字符，我们就认为这个问题是可以利用的，并继续编写有效的基于栈的缓冲区溢出利用程序。在以下示例中，我们提前一步，使用模糊测试来确定我们需要发送多少个*A*字符才能让程序崩溃。
- en: We can use fuzzing techniques to trigger crashes, which we can use to build
    exploits. Let’s look at an example of fuzzing a Trivial FTP (TFTP) server to find
    an exploitable vulnerability. We’ll use the 3Com TFTP server version 2.0.1, which
    we found on our Windows XP system during post exploitation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用模糊测试技术来触发崩溃，这可以帮助我们构建利用程序。让我们看一个模糊测试Trivial FTP（TFTP）服务器的示例，以找到一个可利用的漏洞。我们将使用3Com
    TFTP服务器2.0.1版本，它是在后期利用阶段从我们的Windows XP系统中发现的。
- en: TFTP runs by default on UDP port 69\. Because it is connectionless, we will
    need to know the syntax for TFTP communication to send UDP packets that the TFTP
    software will attempt to process. According to TFTP’s Request for Comment (RFC)
    page, a proper TFTP packet is in the format shown in [Example 19-2](ch19.xhtml#tftp_packet_format
    "Example 19-2. TFTP packet format"). To get TFTP to respond to us, we need to
    follow this specification.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: TFTP默认运行在UDP端口69上。由于它是无连接的，我们需要了解TFTP通信的语法，以便发送TFTP软件会尝试处理的UDP数据包。根据TFTP的《请求评论》（RFC）页面，一个正确的TFTP数据包格式如[示例19-2](ch19.xhtml#tftp_packet_format
    "示例19-2. TFTP数据包格式")所示。为了让TFTP响应我们，我们需要遵循这个规范。
- en: Example 19-2. TFTP packet format
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-2. TFTP数据包格式
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When considering stack-based buffer overflow attacks, look for places where
    the user controls the size and content of the input. If we can send input that
    technically meets the TFTP specification but which contains input that the code
    was not designed to process, we may be able to trigger a stack-based buffer overflow
    vulnerability. In the case of this TFTP server, the first field, Opcode, is always
    two bytes long and includes one of the following strings:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑基于栈的缓冲区溢出攻击时，要查找用户可以控制输入的大小和内容的地方。如果我们可以发送符合TFTP规范的输入，但其中包含代码未设计处理的输入，那么我们可能能够触发基于栈的缓冲区溢出漏洞。在这个TFTP服务器的情况下，第一个字段，操作码（Opcode），总是两个字节长，并且包含以下字符串之一：
- en: '| Opcode | Operation |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 操作码（Opcode） | 操作（Operation） |'
- en: '| --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 01 | Read request (RRQ) |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 01 | 读取请求（RRQ） |'
- en: '| 02 | Write request (WRQ) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 02 | 写请求（WRQ） |'
- en: '| 03 | Data (DATA) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 03 | 数据（DATA） |'
- en: '| 04 | Acknowledgment (ACK) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 04 | 确认（ACK） |'
- en: '| 05 | Error (ERROR) |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 05 | 错误（ERROR） |'
- en: However, we can control the Filename field. In a real TFTP request, this is
    where we would tell the server the filename we want to read, write, and so on.
    The length is variable and the contents of the string are user controlled, so
    this may be a good place to look for stack-based buffer overflow vulnerabilities.
    For example, perhaps the author of the code was not expecting anyone to enter
    a filename that is 1,000 characters long. After all, who would want to type in
    a 1,000-character filename?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以控制文件名字段。在真实的TFTP请求中，这就是我们告诉服务器我们想要读取、写入等的文件名的地方。文件名的长度是可变的，字符串的内容由用户控制，所以这可能是查找基于栈的缓冲区溢出漏洞的一个好地方。例如，也许代码的作者没有预料到会有人输入一个1000个字符长的文件名。毕竟，谁会想要输入一个1000字符长的文件名呢？
- en: The next field is a null byte, which signifies the end of the filename. We can’t
    control this field, but we can control the fourth field, Mode, which is a user-controlled
    variable string. According to the RFC, TFTP’s supported modes include netascii,
    octet, and mail. This is an ideal place for us to fuzz, because developers are
    expecting only eight characters or less for this field. The TFTP packet ends with
    a null byte to signify the end of the Mode.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个字段是一个空字节，表示文件名的结束。我们无法控制这个字段，但我们可以控制第四个字段，模式（Mode），它是一个用户控制的可变字符串。根据RFC，TFTP支持的模式包括netascii、octet和mail。这是一个理想的模糊测试点，因为开发者只期望该字段的字符数为八个或更少。TFTP数据包以空字节结束，以表示模式的结束。
- en: Attempting a Crash
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试崩溃
- en: For our fuzzing exercise, we will craft a succession of legitimate TFTP packets
    with bogus and increasingly long input in the Mode field. If the TFTP processes
    the packets correctly, it should say the Mode is unrecognized and stop processing
    the packet. Perhaps if we can trigger a stack-based buffer overflow vulnerability,
    the results will be different, and we can cause the program to crash. To do this,
    we will again write a simple Python program.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的模糊测试练习，我们将构造一系列合法的 TFTP 数据包，模式字段中包含虚假的且逐渐变长的输入。如果 TFTP 正确处理这些数据包，它应该会显示模式未识别并停止处理数据包。如果我们能触发基于栈的缓冲区溢出漏洞，结果可能会不同，从而导致程序崩溃。为此，我们将再次编写一个简单的
    Python 程序。
- en: Instead of setting our buffer variable to a string of 1,100 *A*s, as in the
    War-FTP exploitation examples in [Chapter 17](ch17.xhtml "Chapter 17. A Stack-Based
    Buffer Overflow in Windows") and [Chapter 18](ch18.xhtml "Chapter 18. Structured
    Exception Handler Overwrites"), we’ll create an array of strings of variable length
    in [Example 19-3](ch19.xhtml#simple_tftp_fuzzing_program "Example 19-3. A simple
    TFTP fuzzing program").
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在 [第 17 章](ch17.xhtml "第 17 章. Windows 中的栈溢出漏洞") 和 [第 18 章](ch18.xhtml "第
    18 章. 结构化异常处理程序覆盖") 中的 War-FTP 利用示例中将缓冲区变量设置为包含 1,100 个 *A* 字符的字符串不同，我们将在 [示例
    19-3](ch19.xhtml#simple_tftp_fuzzing_program "示例 19-3. 一个简单的 TFTP 模糊测试程序") 中创建一个包含可变长度字符串的数组。
- en: Example 19-3. A simple TFTP fuzzing program
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-3。一个简单的 TFTP 模糊测试程序
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first entry in the array will be a string of 100 *A*s ❶. But before we send
    any packets to the TFTP server, let’s create the rest of the fuzzing strings and
    append them to our array by adding new fuzzing strings in increments of 100\.
    Using a `while` loop, we will append progressively longer strings to the array
    until it is 50 elements long ❷. Each time we cycle through the `while` loop, a
    new element will be appended to the array ❸. After we have created our fuzzing
    strings and the `while` loop exits, we will enter a `for` loop ❹, which will grab
    each element of the array in turn and send it within the Mode field of a legitimate
    TFTP packet ❺.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的第一个元素将是一个包含 100 个 *A* 字符的字符串 ❶。但在向 TFTP 服务器发送任何数据包之前，让我们先创建其余的模糊字符串，并通过每次增加
    100 个字符的方式将它们添加到数组中。使用 `while` 循环，我们将不断将逐渐变长的字符串追加到数组中，直到数组长度为 50 ❷。每次循环 `while`，一个新的元素将被添加到数组中
    ❸。当我们创建好所有的模糊字符串并且 `while` 循环退出后，我们将进入一个 `for` 循环 ❹，这个循环会依次抓取数组中的每个元素，并将其作为有效的
    TFTP 数据包中的 Mode 字段内容发送 ❺。
- en: Our packet meets the specifications from the TFTP RFC. We have used the mode
    `02` (write request) and the filename *Georgia*. Our string of *A*s from the array
    are put into the Mode field. Hopefully, one of our increasingly long strings will
    cause a crash.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据包符合 TFTP RFC 的规范。我们使用了 `02` 模式（写请求）和文件名 *Georgia*。我们从数组中提取的 *A* 字符串被放入
    Mode 字段中。希望我们不断增长的字符串能够导致崩溃。
- en: Setting up our network socket is a little different from what we learned in
    the previous chapter when attacking FTP in Python. Because TFTP is a UDP protocol,
    we need to set up a UDP socket as opposed to a TCP socket, so the syntax is slightly
    different ❻. Save the Python code as *tftpfuzzer*, and make it executable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 设置我们的网络套接字与我们在上一章中攻击 FTP 时学到的稍有不同。因为 TFTP 是 UDP 协议，我们需要设置一个 UDP 套接字，而不是 TCP
    套接字，所以语法稍有不同 ❻。将 Python 代码保存为 *tftpfuzzer*，并使其可执行。
- en: Before we start sending fuzzing packets, switch back to your Windows XP machine
    and attach to the *3CTftpSvc* process with Immunity Debugger, as shown in [Figure 19-1](ch19.xhtml#attaching_immunity_debugger_to_the_3com
    "Figure 19-1. Attaching Immunity Debugger to the 3Com TFTP server"). This will
    allow us to view the contents of memory if we cause a crash to verify whether
    we have gained control of EIP. (Don’t forget to tell the program to continue running
    by clicking the play button at the top of the Immunity Debugger window.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始发送模糊测试数据包之前，切换回你的 Windows XP 机器，并使用 Immunity Debugger 附加到 *3CTftpSvc* 进程，如
    [图 19-1](ch19.xhtml#attaching_immunity_debugger_to_the_3com "图 19-1. 附加 Immunity
    Debugger 到 3Com TFTP 服务器") 所示。这样，如果我们引起崩溃，就能查看内存内容，验证是否已经控制了 EIP。（不要忘了点击 Immunity
    Debugger 窗口顶部的播放按钮，让程序继续运行。）
- en: '![Attaching Immunity Debugger to the 3Com TFTP server](httpatomoreillycomsourcenostarchimages2030580.png.jpg)Figure 19-1. Attaching
    Immunity Debugger to the 3Com TFTP server'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![附加 Immunity Debugger 到 3Com TFTP 服务器](httpatomoreillycomsourcenostarchimages2030580.png.jpg)图
    19-1. 附加 Immunity Debugger 到 3Com TFTP 服务器'
- en: Now, in [Example 19-4](ch19.xhtml#fuzzing_3com_tftp "Example 19-4. Fuzzing 3Com
    TFTP"), we run the TFTP fuzzer program we created in [Example 19-3](ch19.xhtml#simple_tftp_fuzzing_program
    "Example 19-3. A simple TFTP fuzzing program").
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 [示例 19-4](ch19.xhtml#fuzzing_3com_tftp "示例 19-4. 测试 3Com TFTP") 中，我们运行了在
    [示例 19-3](ch19.xhtml#simple_tftp_fuzzing_program "示例 19-3. 一个简单的 TFTP 模糊测试程序")
    中创建的 TFTP 模糊测试程序。
- en: Example 19-4. Fuzzing 3Com TFTP
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-4. 测试 3Com TFTP
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As the program runs through the successive strings of *A*s in the Mode field,
    the TFTP server replies that it doesn’t know that transport mode ❶. When the fuzzing
    program attempts to fuzz with a length of 600, it receives no response from the
    TFTP server ❷, which leads us to believe that a transport mode of 500 *A*s crashed
    the server, such that it could not respond to us when we sent over 600 *A*s.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序在 Mode 字段中依次运行多个 *A* 字符串时，TFTP 服务器会回复说它不知道该传输模式 ❶。当模糊测试程序尝试以 600 的长度进行模糊测试时，TFTP
    服务器没有回应 ❷，这让我们认为，传输模式为 500 个 *A* 字符时，服务器崩溃了，因此在我们发送超过 600 个 *A* 字符时，它无法响应我们。
- en: 'Looking back at the 3Com TFTP server in Immunity Debugger ([Figure 19-2](ch19.xhtml#threecom_tftp_has_crasheddot
    "Figure 19-2. 3Com TFTP has crashed.")), we see that it has crashed with `41414141`
    in EIP. Also note the short string of *A*s in the register ESP and the much longer
    string of *A*s in the register ESI. It seems that by sending over a string of
    500 characters in the Mode field, we can control execution and the contents of
    some memory registers: an ideal situation for writing a stack-based buffer overflow
    exploit.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾在 Immunity Debugger 中的 3Com TFTP 服务器（[图 19-2](ch19.xhtml#threecom_tftp_has_crasheddot
    "图 19-2. 3Com TFTP 已崩溃.")），我们看到它在 EIP 中崩溃，值为 `41414141`。还注意到在寄存器 ESP 中有一串较短的 *A*
    字符串，在寄存器 ESI 中有一串更长的 *A* 字符串。似乎通过在 Mode 字段中发送一个 500 字符的字符串，我们可以控制执行以及某些内存寄存器的内容：这是编写基于堆栈的缓冲区溢出漏洞利用程序的理想情况。
- en: '![3Com TFTP has crashed.](httpatomoreillycomsourcenostarchimages2030582.png.jpg)Figure 19-2. 3Com
    TFTP has crashed.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![3Com TFTP 已崩溃。](httpatomoreillycomsourcenostarchimages2030582.png.jpg)图 19-2.
    3Com TFTP 已崩溃。'
- en: Using the techniques learned in the previous chapter when exploiting War-FTP,
    see if you can develop a working exploit for the 3Com TFTP 2.0.1 without help
    from the text. In this case, the saved return pointer overwrite is at the end
    of the exploit string, and the shellcode in ESI will be earlier in the exploit
    string. (You’ll find a completed Python exploit for this exercise in [Writing
    Metasploit Modules](ch19.xhtml#writing_metasploit_modules "Writing Metasploit
    Modules"). Refer to that code if you get stuck.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一章中学习到的技巧，在没有文本帮助的情况下，看看你能否为 3Com TFTP 2.0.1 开发出有效的漏洞利用程序。在这种情况下，保存的返回指针覆盖位于漏洞字符串的末尾，而
    ESI 中的 shellcode 会出现在漏洞字符串的前面。（你可以在 [编写 Metasploit 模块](ch19.xhtml#writing_metasploit_modules
    "编写 Metasploit 模块") 中找到这个练习的完整 Python 漏洞利用程序。如果你遇到困难，可以参考那段代码。）
- en: To restart 3Com TFTP after a crash, browse to *C:\Windows*, open 3CTftpSvcCtrl,
    and click **Start Service**, as shown in [Figure 19-3](ch19.xhtml#threecom_tftp_service_control_dialog
    "Figure 19-3. 3Com TFTP Service Control dialog"). Then reattach to the new process
    in Immunity Debugger.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要在崩溃后重新启动 3Com TFTP，请浏览到 *C:\Windows*，打开 3CTftpSvcCtrl，并点击 **启动服务**，如 [图 19-3](ch19.xhtml#threecom_tftp_service_control_dialog
    "图 19-3. 3Com TFTP 服务控制对话框") 所示。然后在 Immunity Debugger 中重新附加到新进程。
- en: '![3Com TFTP Service Control dialog](httpatomoreillycomsourcenostarchimages2030584.png.jpg)Figure 19-3. 3Com
    TFTP Service Control dialog'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![3Com TFTP 服务控制对话框](httpatomoreillycomsourcenostarchimages2030584.png.jpg)图
    19-3. 3Com TFTP 服务控制对话框'
- en: Porting Public Exploits to Meet Your Needs
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将公开漏洞移植以满足你的需求
- en: Sometimes you may find an exploitable vulnerability on your pentest, but there
    is no Metasploit module available to exploit it. While the Metasploit team and
    contributing module writers from the community do an excellent job of keeping
    Metasploit up-to-date with current threats, not every known exploit on the Internet
    has been ported to the framework.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能会在渗透测试中发现一个可利用的漏洞，但没有可用的 Metasploit 模块来利用它。虽然 Metasploit 团队和社区中的贡献者在保持
    Metasploit 与当前威胁同步方面做得非常出色，但并非所有已知的互联网漏洞都已移植到这个框架中。
- en: We can attempt to develop a working exploit by downloading the target software
    and developing a working exploit, but that approach is not always feasible. The
    software in question may come with a license fee so expensive that you would end
    up losing money on the pentest, or it may not be available from the vendor or
    elsewhere. In addition, your pentest may have a limited time frame, and so you
    would be better off looking for additional vulnerabilities in the environment
    rather than spending significant time on custom-exploit development.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试通过下载目标软件并开发有效的漏洞利用来进行攻击，但这种方法并不总是可行的。相关软件可能需要支付昂贵的许可费用，导致你在渗透测试中亏损，或者可能无法从供应商或其他地方获得。此外，你的渗透测试可能有时间限制，因此，你最好去寻找环境中其他潜在的漏洞，而不是花费大量时间开发自定义漏洞利用。
- en: One way to develop your own working exploits is to use publicly available exploits
    as a base and port them to your environment. Even if a vulnerability lacks a corresponding
    Metasploit module, you may be able to find proof-of-concept exploit code on a
    website like Exploit Database (*[http://www.exploit-db.com/](http://www.exploit-db.com/)*)
    or SecurityFocus (*[http://www.securityfocus.com/](http://www.securityfocus.com/)*).
    Although public exploit code should always be used with caution (not everything
    online does what it says it does), with some due diligence, we can use public
    exploit code safely.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 开发自己的有效漏洞利用的一种方法是使用公开可用的漏洞利用作为基础，并将其移植到你的环境中。即使漏洞没有对应的Metasploit模块，你也可以在像Exploit
    Database (*[http://www.exploit-db.com/](http://www.exploit-db.com/)*) 或SecurityFocus
    (*[http://www.securityfocus.com/](http://www.securityfocus.com/)*）这样的网站上找到概念验证的漏洞利用代码。尽管公开的漏洞利用代码应该谨慎使用（并不是网上的所有东西都如其所述那样运行），但只要我们尽职调查，仍然可以安全地使用这些公开的漏洞利用代码。
- en: Let’s start with a public exploit for the 3Com TFTP 2.0.1 long transport mode
    vulnerability from Exploit Database, found online at *[http://www.exploit-db.com/exploits/3388/](http://www.exploit-db.com/exploits/3388/)*
    and shown in [Example 19-5](ch19.xhtml#public_exploit_for_3com_tftp "Example 19-5. Public
    exploit for 3Com TFTP").
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Exploit Database中找到的公开漏洞利用是针对3Com TFTP 2.0.1版本的长传输模式漏洞，链接在网上可以找到，位于 *[http://www.exploit-db.com/exploits/3388/](http://www.exploit-db.com/exploits/3388/)*，并显示在[示例
    19-5](ch19.xhtml#public_exploit_for_3com_tftp "示例 19-5. 3Com TFTP的公开漏洞利用")中。
- en: Example 19-5. Public exploit for 3Com TFTP
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-5. 3Com TFTP的公开漏洞利用
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This exploit is written in Perl ❶. To use public exploits, you will need basic
    reading knowledge in a number of languages. Additionally, this exploit targets
    Windows 2000 SP4 ❷, whereas our target is Windows XP SP3\. We will need to make
    some changes to port this exploit to our platform.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞利用是用Perl编写的 ❶。要使用公开的漏洞利用，你需要具备一定的多种语言的基础阅读能力。此外，这个漏洞利用的目标是Windows 2000 SP4
    ❷，而我们的目标是Windows XP SP3。我们需要进行一些修改才能将这个漏洞利用移植到我们的平台上。
- en: The shellcode included with this exploit claims to have been generated using
    Metasploit and to open a bind shell on port 4444 ❸.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞利用中包含的shellcode声称是使用Metasploit生成的，并且会在端口4444上打开一个绑定shell ❸。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: No offense intended to the original author of this exploit, but in a public
    exploit, always be wary of anything you can’t read. Additionally, be aware that
    the included shellcode may not work for your environment. For example, it may
    be a reverse shell headed to a static IP address and port. Therefore, it is good
    practice to use Msfvenom to generate new, trustworthy shellcode before running
    any public exploit.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是对该漏洞原作者的冒犯，但在使用公开漏洞利用时，始终要对你无法理解的部分保持警惕。此外，要意识到，所包含的shellcode可能不适用于你的环境。例如，它可能是一个反向shell，指向一个静态IP地址和端口。因此，在运行任何公开漏洞利用之前，使用Msfvenom生成新的、可信的shellcode是一个好的做法。
- en: Reading through the exploit, we see that the author creates a TFTP packet similar
    to the one we created in our fuzzing example earlier in the chapter ❺. The Mode
    field is filled with a NOP sled of 129 characters ❻, 344 bytes of shellcode ❼,
    and the four-byte return address ❽ (in this case, a `JMP` `ESI` instruction) to
    redirect execution to the attacker-controlled ESI register ❹.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读漏洞利用代码，我们看到作者创建了一个TFTP数据包，类似于我们在本章前面的模糊测试示例中创建的数据包 ❺。Mode字段填充了一个129个字符的NOP滑梯
    ❻，344字节的shellcode ❼，以及四字节的返回地址 ❽（在本例中是一个`JMP` `ESI`指令），用于将执行重定向到攻击者控制的ESI寄存器 ❹。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A *NOP sled* is a series of no operating instructions (\x90 in hex) that do
    nothing and move on. They are typically used to pad exploits. Exploit developers
    can just redirect execution to somewhere in the NOP sled, and execution will just
    “slide” down the NOP sled, doing nothing, until it reaches the shellcode. However,
    we have learned that we can be more precise with our exploits, and we usually
    don’t need NOP sleds at all.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*NOP sled* 是一系列不执行任何操作的指令（十六进制为 \x90），它们不会做任何事情并继续执行。它们通常用于填充 exploits。开发者可以将执行重定向到
    NOP sled 中的某个位置，执行会沿着 NOP sled “滑动”，什么也不做，直到到达 shellcode。然而，我们已经了解到，我们可以更精确地使用
    exploits，通常不需要 NOP sled。'
- en: The command for the variable `$jmp_2000` ❹ tells us that the exploit uses a
    `JMP ESI` instruction in *USER32.dll* on Windows 2000 SP4 English.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `$jmp_2000` ❹ 的命令告诉我们，exploits 使用了 Windows 2000 SP4 英文版中的 *USER32.dll* 中的
    `JMP ESI` 指令。
- en: Finding a Return Address
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找返回地址
- en: Because we are using a different platform, the memory location (`0x77E5080E`)
    of this `JMP ESI` instruction may be different. *USER32.dll* is a component of
    the Windows operating system. Windows XP does not use ASLR, discussed later in
    this chapter, so *USER32.dll* is loaded into the same memory location on all Windows
    XP SP3 English platforms.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是不同的平台，`JMP ESI` 指令的内存位置（`0x77E5080E`）可能会有所不同。*USER32.dll* 是 Windows
    操作系统的一个组件。Windows XP 不使用后文所讨论的 ASLR，因此 *USER32.dll* 会加载到所有 Windows XP SP3 英文平台的相同内存位置。
- en: We have taken advantage of static DLL locations in our previous exploit exercises.
    We need not have a copy of 3Com TFTP running to find the memory locations of instructions
    in Windows components. For example, as shown in [Figure 19-4](ch19.xhtml#finding_jmp_esi_instructions_in_user32do
    "Figure 19-4. Finding JMP ESI instructions in USER32.dll"), from debugging War-FTP,
    we can search for a `JMP ESI` instruction in *USER32.dll*. (It is a good idea
    to stick with the DLL noted in the original exploit if we don’t have a copy of
    the program. We can’t be sure the program loads *MSVCRT.dll*, for example.)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 exploit 演练中，我们利用了静态 DLL 地址。我们无需运行 3Com TFTP 即可找到 Windows 组件中指令的内存位置。例如，如
    [图 19-4](ch19.xhtml#finding_jmp_esi_instructions_in_user32do "图 19-4. 查找 USER32.dll
    中的 JMP ESI 指令") 所示，通过调试 War-FTP，我们可以在 *USER32.dll* 中查找 `JMP ESI` 指令。（如果我们没有程序的副本，最好坚持使用原
    exploit 中提到的 DLL。我们不能确定该程序是否加载了 *MSVCRT.dll*，例如。）
- en: Of course, in our case, we have 3Com TFTP locally, but if we didn’t have access
    to the app, we could use Mona to look for `JMP` instructions inside a specific
    module. For example, we could look for instances of `JMP ESI` (or the equivalent)
    with the command `!mona jmp -r esi -m user32`, as shown in [Figure 19-4](ch19.xhtml#finding_jmp_esi_instructions_in_user32do
    "Figure 19-4. Finding JMP ESI instructions in USER32.dll").
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在我们的例子中，我们本地有 3Com TFTP，但如果我们无法访问该应用程序，我们可以使用 Mona 查找特定模块中的 `JMP` 指令。例如，我们可以使用命令
    `!mona jmp -r esi -m user32` 查找 `JMP ESI`（或等效指令）的实例，如 [图 19-4](ch19.xhtml#finding_jmp_esi_instructions_in_user32do
    "图 19-4. 查找 USER32.dll 中的 JMP ESI 指令") 所示。
- en: '![Finding JMP ESI instructions in USER32.dll](httpatomoreillycomsourcenostarchimages2030586.png.jpg)Figure 19-4. Finding
    `JMP ESI` instructions in *USER32.dll*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![查找 USER32.dll 中的 JMP ESI 指令](httpatomoreillycomsourcenostarchimages2030586.png.jpg)图
    19-4. 查找 *USER32.dll* 中的 `JMP ESI` 指令'
- en: And we find a `JMP ESI` instruction at the memory address `7E45AE4E` in *USER32.dll*
    on Windows XP SP3\. If we change the `jmp_2000` variable to this value in little-endian
    format, this exploit should work for our platform.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Windows XP SP3 的 *USER32.dll* 中的内存地址 `7E45AE4E` 找到了 `JMP ESI` 指令。如果我们将 `jmp_2000`
    变量更改为这个小端格式的值，这个 exploit 应该适用于我们的平台。
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Replacing Shellcode
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换 Shellcode
- en: As noted earlier, we also need to replace the shellcode with code generated
    by Msfvenom. We can use a bind shell or any Windows payload that will fit in 344
    + 129 bytes (the included shellcode plus the NOP sled). The only bad character
    we need to avoid this time is the null byte. Tell Msfvenom to output the payload
    in Perl format so we can easily add it to our exploit.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们还需要用 Msfvenom 生成的代码替换 shellcode。我们可以使用 bind shell 或任何适合 344 + 129 字节（包括
    shellcode 和 NOP sled）的 Windows payload。我们需要避免的唯一坏字符是空字节。告诉 Msfvenom 以 Perl 格式输出
    payload，以便我们可以轻松将其添加到我们的 exploit 中。
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Editing the Exploit
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑 Exploit
- en: Our generated shellcode from Msfvenom is 368 bytes, whereas the original shellcode
    in the public exploit was 344 bytes. Now make the changes to the original exploit
    code shown in [Example 19-6](ch19.xhtml#ported_exploit "Example 19-6. The ported
    exploit"). We delete the NOP sled and pad our exploit string with 105 bytes after
    the shellcode, so our return address still ends up hijacking EIP.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 Msfvenom 生成的 shellcode 为 368 字节，而公开漏洞中的原始 shellcode 为 344 字节。现在，根据[示例 19-6](ch19.xhtml#ported_exploit
    "示例 19-6. 移植的漏洞")中的原始漏洞代码进行修改。我们删除了 NOP sled，并在 shellcode 后面填充了 105 字节的漏洞字符串，以确保我们的返回地址仍然能够劫持
    EIP。
- en: Example 19-6. The ported exploit
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-6. 移植的漏洞
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our ported exploit will look like [Example 19-6](ch19.xhtml#ported_exploit "Example 19-6. The
    ported exploit"), with the shellcode ❶, padding ❷, and return address ❸ adjusted
    to meet our needs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移植的漏洞代码将类似于[示例 19-6](ch19.xhtml#ported_exploit "示例 19-6. 移植的漏洞")，其中 shellcode
    ❶、填充 ❷ 和返回地址 ❸ 已根据我们的需求进行了调整。
- en: If you’ve done everything correctly, when you run the ported exploit, a bind
    shell with System privileges will open on TCP port 4444, as shown in [Example 19-7](ch19.xhtml#running_the_ported_exploit
    "Example 19-7. Running the ported exploit").
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作正确，当你运行移植后的漏洞时，一个具有系统权限的绑定 Shell 将在 TCP 端口 4444 上打开，正如[示例 19-7](ch19.xhtml#running_the_ported_exploit
    "示例 19-7. 运行移植的漏洞")中所示。
- en: Example 19-7. Running the ported exploit
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-7. 运行移植的漏洞
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Writing Metasploit Modules
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 Metasploit 模块
- en: Throughout this book we have leveraged many Metasploit modules for information
    gathering, exploitation, post exploitation, and so on. As new vulnerabilities
    are discovered, Metasploit modules are written for these issues, often by members
    of the security community like you. Additionally, as new post-exploitation or
    information-gathering techniques are implemented by researchers, they are often
    ported into Metasploit modules. In this section, we will look at the basics of
    writing our own Metasploit exploit module.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们利用了许多 Metasploit 模块进行信息收集、漏洞利用、后渗透等操作。随着新漏洞的发现，Metasploit 模块也会为这些问题编写，通常由像你一样的安全社区成员来完成。此外，随着研究人员实现新的后渗透或信息收集技术，这些技术也通常会被移植到
    Metasploit 模块中。在本节中，我们将介绍如何编写我们自己的 Metasploit 漏洞模块的基础知识。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Metasploit modules are written in Ruby.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit 模块是用 Ruby 编写的。
- en: The best way to write a Metasploit module is to start with a similar existing
    module or skeleton and, similar to what we did in the previous section, port the
    exploit to meet our needs. Let’s begin with an existing Metasploit TFTP exploit
    module and port the 3Com TFTP stack-based buffer overflow that we left as an exercise
    earlier in this chapter. Of course, a Metasploit module already exists for this
    vulnerability, but it would be too easy to use it as a base module.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Metasploit 模块的最佳方式是从一个相似的现有模块或框架开始，并且像我们在前一节中所做的那样，将漏洞移植过来以满足我们的需求。让我们从一个现有的
    Metasploit TFTP 漏洞模块开始，将本章前面作为练习留下的 3Com TFTP 基于堆栈的缓冲区溢出漏洞移植过来。当然，Metasploit 已经有了这个漏洞的模块，但如果直接使用它作为基础模块的话，太简单了。
- en: To see all the exploits for Windows TFTP servers, view the contents of */usr/share/metasploit-framework/modules/exploits/windows/tftp*
    in Kali.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有 Windows TFTP 服务器的漏洞，查看 Kali 中 */usr/share/metasploit-framework/modules/exploits/windows/tftp*
    目录下的内容。
- en: 'We’ll start with the module *futuresoft_transfermode.rb*. This module (shown
    in [Example 19-8](ch19.xhtml#metasploit_module_example "Example 19-8. Metasploit
    module example")) exploits a similar issue: a buffer overflow in the transfer
    mode field of another piece of TFTP software. We will adapt it for our 3Com TFTP
    exploit module.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从模块 *futuresoft_transfermode.rb* 开始。这个模块（如[示例 19-8](ch19.xhtml#metasploit_module_example
    "示例 19-8. Metasploit 模块示例")所示）利用了类似的问题：另一个 TFTP 软件的传输模式字段中的缓冲区溢出漏洞。我们将对其进行调整，使其适用于我们的
    3Com TFTP 漏洞模块。
- en: Example 19-8. Metasploit module example
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-8. Metasploit 模块示例
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the class definition ❶, as well as the include statements ❷, the author of
    this module tells Metasploit which mixins, or libraries, the module will inherit
    constructs from. This is a remote exploit over UDP that uses an SEH overwrite
    attack.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义 ❶ 中，以及包含语句 ❷ 中，模块的作者告诉 Metasploit 该模块将继承哪些 mixins 或库的构造。这是一个通过 UDP 实现的远程漏洞，使用了
    SEH 覆盖攻击。
- en: In the `Payload` section ❸, we tell Metasploit how many bytes we have available
    in the attack string for the payload. We also list the bad characters that need
    to be avoided ❹. The `StackAdjustment` option ❺ tells Metasploit to move ESP to
    the beginning of the payload to make more room on the stack for the payload to
    do its work without overwriting itself.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Payload` 部分 ❸，我们告诉 Metasploit 在攻击字符串中可用来放置有效载荷的字节数。我们还列出了需要避免的不良字符 ❹。`StackAdjustment`
    选项 ❺ 告诉 Metasploit 将 ESP 移动到有效载荷的开始处，为有效载荷在堆栈上腾出更多空间，以便它能正常工作而不被自己覆盖。
- en: In the `Targets` section ❻, the author lists all the targets that Metasploit
    can attack together with their relevant return addresses. (Note that we do not
    have to write return addresses in little-endian format. We will take care of this
    later in the module.) In addition to the default options for the *Exploit::Remote::UDP*
    mixin, the author also registered the `RPORT` option as 69 ❼, the default port
    for TFTP. Many programming languages use brackets to designate blocks such as
    functions or loops. Python uses indentation, and Ruby (the language used here)
    uses the word `end` ❽ to designate the end of a block.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Targets` 部分 ❻，作者列出了 Metasploit 可以攻击的所有目标及其相关的返回地址。（请注意，我们不需要以小端格式编写返回地址。我们稍后将在模块中处理这个问题。）除了
    *Exploit::Remote::UDP* 混入模块的默认选项外，作者还将 `RPORT` 选项注册为 69 ❼，这是 TFTP 的默认端口。许多编程语言使用括号来标识函数或循环等代码块。Python
    使用缩进，而 Ruby（此处使用的语言）则使用 `end` ❽ 来标识代码块的结束。
- en: The *Exploit::Remote::UDP* mixin does all the work of setting up a UDP socket
    for us. All we need to do is call the function `connect_udp` ❾. (You’ll find the
    details of `connect_udp` and other *Exploit::Remote::UDP* methods at */usr/share/metasploit-framework/lib/msf/core/exploit/udp.rb*
    in Kali.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*Exploit::Remote::UDP* 混入模块为我们完成了设置 UDP 套接字的所有工作。我们需要做的就是调用函数`connect_udp`
    ❾。（你可以在 Kali 的 */usr/share/metasploit-framework/lib/msf/core/exploit/udp.rb* 文件中找到`connect_udp`及其他*Exploit::Remote::UDP*
    方法的详细信息。）'
- en: The author then tells Metasploit how to create the exploit string. After the
    exploit string is built, the author uses the `udp_sock.put` method ❿ to send it
    to the vulnerable server.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，作者告诉 Metasploit 如何创建漏洞字符串。漏洞字符串构建完成后，作者使用`udp_sock.put`方法 ❿ 将其发送到易受攻击的服务器。
- en: A Similar Exploit String Module
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相似的漏洞字符串模块
- en: The example module uses an SEH exploit, whereas our 3Com TFTP exploit uses a
    saved return pointer, so let’s look at the exploit string in another Metasploit
    TFTP example for help in creating our exploit. Here is the exploit string used
    in the *exploit/windows/tftp/tftpd32_long_filename.rb* module.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例模块使用了 SEH 漏洞，而我们的 3Com TFTP 漏洞则使用了保存的返回指针，因此我们来查看另一个 Metasploit TFTP 示例中的漏洞字符串，以帮助我们创建自己的漏洞。以下是
    *exploit/windows/tftp/tftpd32_long_filename.rb* 模块中使用的漏洞字符串。
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Recall that the first two bytes of a TFTP packet are the opcode ❶. Here, the
    packet is telling the TFTP we want to read a file. Next is the filename, *rand_text_english(120,
    payload_badchars)*. As the module name suggests, rather than writing too much
    data into the transport mode field, this exploit uses a long filename. The author
    uses Metasploit’s `rand_text_english` function to create a 120-character string
    that avoids any bad characters by pulling from the `BadChar` variable earlier
    in the module ❷. This exploit seems to require a period (`.`) and then some more
    random text, after which the return address is added to the string. Metasploit
    pulls the return address from the `ret` variable defined earlier in the module.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，TFTP 数据包的前两个字节是操作码 ❶。在这里，数据包告诉 TFTP 我们想要读取一个文件。接下来是文件名，*rand_text_english(120,
    payload_badchars)*。正如模块名称所示，这个漏洞利用了一个长文件名，而不是将过多的数据写入传输模式字段。作者使用 Metasploit 的
    `rand_text_english` 函数创建了一个 120 个字符的字符串，避免了通过模块中早先定义的 `BadChar` 变量中的不良字符 ❷。这个漏洞似乎需要一个句点（`.`），然后是一些随机文本，接着返回地址被添加到字符串中。Metasploit
    从模块中早先定义的 `ret` 变量中提取返回地址。
- en: '`pack` is a Ruby method that turns an array into a binary sequence according
    to a template. The `''V''` template ❸ directs Ruby to pack our return address
    in little-endian format. Following the return address, the user’s chosen payload
    is encoded and appended to the exploit string, and the payload fills the total
    space allowed, as defined in the `Space` variable ❹. A null byte signals the end
    of the filename field. (Interestingly, the attack string does not even need to
    finish the TFTP packet to exploit the program, because the mode and final null
    byte are not appended to the exploit string.)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`pack` 是一个 Ruby 方法，它根据模板将数组转换为二进制序列。`''V''` 模板 ❸ 指示 Ruby 以小端格式打包我们的返回地址。在返回地址之后，用户选择的负载被编码并附加到漏洞字符串中，负载填满了允许的总空间，这个空间由
    `Space` 变量 ❹ 定义。一个空字节表示文件名字段的结束。（有趣的是，攻击字符串甚至不需要完成 TFTP 数据包就能利用程序，因为模式和最终的空字节并不会附加到漏洞字符串中。）'
- en: Porting Our Exploit Code
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移植我们的漏洞利用代码
- en: Earlier in this chapter, I suggested writing an exploit for the 3Com TFTP server
    long transport mode vulnerability as an exercise. Your finished exploit should
    be similar to the code shown in [Example 19-9](ch19.xhtml#finished_3com_tftp_python_exploit
    "Example 19-9. Finished 3Com TFTP Python exploit"). If you didn’t try writing
    this exploit, you should still be able to sort out how the code works, having
    worked through the previous examples.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候，我建议将 3Com TFTP 服务器的长传输模式漏洞作为练习编写一个漏洞利用代码。你编写的漏洞利用代码应该与 [示例 19-9](ch19.xhtml#finished_3com_tftp_python_exploit
    "示例 19-9. 完成的 3Com TFTP Python 漏洞利用代码") 中的代码类似。如果你没有尝试编写这个漏洞利用代码，依然应该能够理解代码的工作原理，因为你已经完成了前面的示例。
- en: Example 19-9. Finished 3Com TFTP Python exploit
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-9. 完成的 3Com TFTP Python 漏洞利用代码
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Your return address may point to another `JMP ESI` instruction ❷, and you may
    have used a different payload ❶.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你的返回地址可能指向另一个 `JMP ESI` 指令 ❷，而且你可能使用了不同的负载 ❶。
- en: Now let’s port the Python exploit into Metasploit, changing values in the FutureSoft
    TFTP example module to fit our needs. We need to make only a few changes to the
    existing exploit module we discussed previously, as shown in [Example 19-10](ch19.xhtml#edited_modulecomma_part_1
    "Example 19-10. Edited module, part 1") and [Example 19-11](ch19.xhtml#edited_modulecomma_part_2
    "Example 19-11. Edited module, part 2").
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将 Python 漏洞利用代码移植到 Metasploit，将 FutureSoft TFTP 示例模块中的值更改为适应我们的需求。我们只需对之前讨论的现有漏洞模块进行少量更改，如
    [示例 19-10](ch19.xhtml#edited_modulecomma_part_1 "示例 19-10. 编辑后的模块，第 1 部分") 和 [示例
    19-11](ch19.xhtml#edited_modulecomma_part_2 "示例 19-11. 编辑后的模块，第 2 部分") 中所示。
- en: Example 19-10. Edited module, part 1
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-10. 编辑后的模块，第 1 部分
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because this is a saved return pointer overwrite exploit, we will not need to
    import the SEH Metasploit mixin; we will only import *Msf::Exploit::Remote::Udp*
    ❶. Next we change the module’s information to match the 3Com TFTP 2.0.1 long transport
    mode vulnerability to enable Metasploit users to search for our module and verify
    that they have the correct exploit for the vulnerability. Search vulnerability
    references online to find the CVE, OSVDB, and BID numbers, and any other relevant
    links ❷.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个保存返回指针覆盖漏洞，我们不需要导入 SEH Metasploit 混合模块；只需导入 *Msf::Exploit::Remote::Udp*
    ❶。接下来，我们更改模块的信息，以匹配 3Com TFTP 2.0.1 长传输模式漏洞，以便 Metasploit 用户能够搜索到我们的模块并验证他们是否拥有正确的漏洞利用代码。在线搜索漏洞参考信息，找到
    CVE、OSVDB 和 BID 编号，以及其他相关链接 ❷。
- en: Next we change the payload options to match our 3Com exploit. In our Python
    exploit, we lead with 344 bytes of shellcode, followed by 129 bytes of padding,
    giving us a total of 473 bytes to work with for the payload. Tell Metasploit to
    create a 473-byte payload at ❸. For the target section, our Python exploit covers
    only one platform, Windows XP Professional SP3 English. If we were submitting
    our exploit to the Metasploit repositories, we should try to cover as many exploitable
    targets as possible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更改负载选项，以匹配我们的 3Com 漏洞利用代码。在我们的 Python 漏洞利用代码中，我们先是 344 字节的 shellcode，后跟
    129 字节的填充，总共 473 字节的负载。告诉 Metasploit 在 ❸ 创建一个 473 字节的负载。对于目标部分，我们的 Python 漏洞利用代码只覆盖一个平台——Windows
    XP Professional SP3 英文版。如果我们将漏洞提交到 Metasploit 仓库，应该尽量覆盖更多可以利用的目标。
- en: Finally, change the `RET` to the `JMP ESI` in *USER32.dll* ❹ from the Python
    exploit. We’ve also added the `DefaultTarget` option to tell Metasploit to use
    target 0 by default, so the user won’t need to set a target before running the
    module ❺.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 `RET` 更改为 Python 漏洞利用代码中的 *USER32.dll* ❹ 中的 `JMP ESI`。我们还添加了 `DefaultTarget`
    选项，告诉 Metasploit 默认使用目标 0，这样用户在运行模块之前就不需要设置目标 ❺。
- en: The only changes we need to make in the exploit portion of the module are to
    the exploit string itself, as shown in [Example 19-11](ch19.xhtml#edited_modulecomma_part_2
    "Example 19-11. Edited module, part 2").
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模块的利用部分唯一需要修改的是利用字符串本身，正如[示例 19-11](ch19.xhtml#edited_modulecomma_part_2
    "示例 19-11. 修改后的模块，第二部分")中所示。
- en: Example 19-11. Edited module, part 2
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-11. 修改后的模块，第二部分
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As in the Python exploit, we start by telling the TFTP server to write to a
    file ❶. We then use the `rand_text_english` function to create a random seven-character
    filename ❷. This method is superior to using static letters as we did in the Python
    exploit, because anything that is predictable can be used to write signatures
    for antivirus programs, intrusion-prevention systems, and so on. Next we follow
    the specification for a TFTP packet with a null byte to finish the filename at
    ❸, and then tack on the user’s chosen payload ❹ and the return address ❺. We finish
    the packet with a null byte, per the TFTP specification ❻. (After using `end`
    to close the exploit function, don’t forget to close the module as well at ❼.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Python 利用示例一样，我们首先告诉 TFTP 服务器将数据写入文件 ❶。然后，我们使用 `rand_text_english` 函数创建一个随机的七字符文件名
    ❷。这种方法比我们在 Python 利用示例中使用静态字母更为优越，因为任何可预测的内容都可以用来为杀毒程序、入侵防御系统等编写签名。接下来，我们按照 TFTP
    数据包规范，使用一个空字节来结束文件名 ❸，然后附加上用户选择的有效载荷 ❹ 和返回地址 ❺。最后按照 TFTP 规范 ❻ 用一个空字节结束数据包。（在使用
    `end` 结束利用函数后，不要忘记在 ❼ 处关闭模块。）
- en: We have now written an exploit module for the 3Com TFTP 2.0.1 long transport
    mode vulnerability. Save the file in */root/.msf4/modules/exploits/windows/tftp/myexploit.rb*,
    and then run the Msftidy tool on the module to verify that it meets the format
    specifications for Metasploit modules. Make any formatting changes that Msftidy
    suggests before submitting a module to the Metasploit repository.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经为 3Com TFTP 2.0.1 长传输模式漏洞编写了一个利用模块。将文件保存在 */root/.msf4/modules/exploits/windows/tftp/myexploit.rb*，然后运行
    Msftidy 工具对模块进行格式验证，确保其符合 Metasploit 模块的格式规范。在提交模块到 Metasploit 仓库之前，按照 Msftidy
    提出的建议进行任何格式更改。
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From time to time, Metasploit makes changes to its desired syntax, so run `msfupdate`
    to get the latest version of Msftidy if you are actually going to submit a module
    to the repositories. In this case, we don’t need to worry about it, and running
    `msfupdate` may cause other exercises in the book to break, so I don’t recommend
    it for now.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit 会不时修改其所需的语法，因此如果你打算提交一个模块到代码库，运行 `msfupdate` 获取最新版本的 Msftidy。在这种情况下，我们不需要担心这个问题，运行
    `msfupdate` 可能会导致书中的其他练习出现问题，因此目前我不建议运行它。
- en: Restart Msfconsole to load the latest modules, including any in this *.msf4/modules*
    directory. If you have made any syntax errors, Metasploit will display the details
    of the modules it was unable to load.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重启 Msfconsole 以加载最新的模块，包括任何位于 *.msf4/modules* 目录中的模块。如果你犯了任何语法错误，Metasploit
    会显示无法加载的模块的详细信息。
- en: Now use your new exploit module to attack your Windows XP target. As you see
    in [Example 19-12](ch19.xhtml#using_your_module "Example 19-12. Using your module"),
    Metasploit can fit many payloads in 473 characters, including Meterpreter ❶.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用你的新利用模块来攻击 Windows XP 目标。如[示例 19-12](ch19.xhtml#using_your_module "示例 19-12.
    使用你的模块")所示，Metasploit 可以将多个有效载荷装入 473 个字符内，包括 Meterpreter ❶。
- en: Example 19-12. Using your module
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 19-12. 使用你的模块
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we’ve walked through one example of writing a Metasploit module, here’s
    an idea for another. A Metasploit module that can exploit the War-FTP 1.65 USER
    buffer overflow, found at */usr/share/metasploit-framework/modules/exploits/windows/ftp/warftpd_165_user.rb*,
    uses the saved return pointer overwrite technique. Try writing a similar module
    that uses the SEH overwrite technique we worked through in [Chapter 18](ch18.xhtml
    "Chapter 18. Structured Exception Handler Overwrites").
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过一个编写 Metasploit 模块的示例，下面是另一个想法。一个可以利用 War-FTP 1.65 用户缓冲区溢出的 Metasploit
    模块，位于 */usr/share/metasploit-framework/modules/exploits/windows/ftp/warftpd_165_user.rb*，使用了保存的返回指针覆盖技术。尝试编写一个类似的模块，使用我们在[第18章](ch18.xhtml
    "第18章. 结构化异常处理程序覆盖")中处理过的 SEH 覆盖技术。
- en: Exploitation Mitigation Techniques
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用缓解技术
- en: We discussed one exploit mitigation technique, called SafeSEH, in [Chapter 18](ch18.xhtml
    "Chapter 18. Structured Exception Handler Overwrites"). In typical cat-and-mouse
    fashion, attackers develop new exploitation techniques while platforms implement
    mitigation techniques, and then attackers come up with something new. Here we
    will briefly discuss a few modern exploit mitigation methods. This list is by
    no means complete, nor is it within the scope of this book to discuss writing
    exploits that successfully bypass all these restrictions. There are many advanced
    exploitation and payload delivery techniques, such as heap sprays and return-oriented
    programming, beyond those discussed here. Check out my website (*[http://www.bulbsecurity.com/](http://www.bulbsecurity.com/)*)
    and the Corelan Team’s website (*[http://www.corelan.be/](http://www.corelan.be/)*)
    for more information on advanced exploit development techniques.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第18章](ch18.xhtml "第18章. 结构化异常处理程序覆盖")中讨论了一种漏洞利用缓解技术，称为 SafeSEH。攻击者开发新漏洞利用技术的同时，平台实现缓解措施，接着攻击者又会提出新的方法。在这里，我们将简要讨论几种现代的漏洞利用缓解方法。这份列表并不完整，也不在本书讨论绕过所有这些限制的漏洞利用的范围内。除了这里讨论的内容外，还有许多高级漏洞利用和有效载荷投递技术，如堆喷和面向返回的编程。更多关于高级漏洞利用开发技术的信息，请访问我的网站
    (*[http://www.bulbsecurity.com/](http://www.bulbsecurity.com/)*) 和 Corelan 团队的网站
    (*[http://www.corelan.be/](http://www.corelan.be/)*)。
- en: Stack Cookies
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆栈保护
- en: Naturally, as buffer overflow exploits became prevalent, developers wanted to
    stop these sorts of attacks from hijacking execution. One way to do so is by implementing
    *stack cookies*, also known as *canaries*. At the start of a program, a stack
    cookie is calculated and added to the *.data* section of memory. Functions that
    use structures prone to buffer overflows, such as string buffers, grab the canary
    value from *.data* and push it onto the stack after the saved return address and
    EBP. Just before a function returns, it checks the value of the canary on the
    stack against the value in *.data*. If the values don’t match, a buffer overflow
    is detected, and the program is terminated before the attack can hijack execution.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，随着缓冲区溢出漏洞的普遍存在，开发人员希望阻止这些类型的攻击劫持执行。实现*堆栈保护*（也称为*金丝雀*）是一种方法。在程序启动时，计算并将堆栈保护值添加到*.data*内存区域。使用易受缓冲区溢出影响的结构（如字符串缓冲区）的函数会从*.data*获取金丝雀值，并在保存的返回地址和
    EBP 之后将其压入堆栈。函数返回之前，会检查堆栈上的金丝雀值是否与*.data*中的值匹配。如果值不匹配，则会检测到缓冲区溢出，程序会在攻击劫持执行之前终止。
- en: You can use multiple techniques for bypassing stack cookies, such as triggering
    an SEH overwrite and exception before the vulnerable function returns and hijacking
    execution before the canary value is checked.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用多种技术绕过堆栈保护，如在易受攻击的函数返回之前触发 SEH 覆盖和异常，或者在检查金丝雀值之前劫持执行。
- en: Address Space Layout Randomization
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地址空间布局随机化
- en: The exploits we have written in this book have relied on certain instructions
    being at certain memory addresses. For example, in our first War-FTP stack-based
    buffer overflow example in [Chapter 17](ch17.xhtml "Chapter 17. A Stack-Based
    Buffer Overflow in Windows"), we relied on a `JMP ESP` equivalent instruction
    in the Windows *MSVCRT.dll* module being at memory address `0x77C35459` on all
    Windows XP SP3 English systems. In our SEH overwrite example in [Chapter 18](ch18.xhtml
    "Chapter 18. Structured Exception Handler Overwrites"), we relied on the `POP
    POP RET` instructions in War-FTP’s *MFC42.dll* module being at memory address
    `0x5F4580CA`. If neither case were true, our entire attack approach would have
    been undermined, and we would have to find the instructions before we could execute
    them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们编写的漏洞利用依赖于特定指令位于特定内存地址。例如，在我们第一章 [第17章](ch17.xhtml "第17章. 基于堆栈的缓冲区溢出攻击")中的
    War-FTP 堆栈缓冲区溢出示例中，我们依赖于 Windows *MSVCRT.dll* 模块中的 `JMP ESP` 等效指令位于所有 Windows
    XP SP3 英文系统中的内存地址 `0x77C35459`。在我们 [第18章](ch18.xhtml "第18章. 结构化异常处理程序覆盖")中的 SEH
    覆盖示例中，我们依赖于 War-FTP 的 *MFC42.dll* 模块中的 `POP POP RET` 指令位于内存地址 `0x5F4580CA`。如果这些条件中的任何一个不成立，我们的整个攻击方法就会受到破坏，我们就需要找到这些指令才能执行它们。
- en: 'When ASLR is implemented, you can’t count on certain instructions being at
    certain memory addresses. To see ASLR in action, open the Winamp program in Immunity
    Debugger on your Windows 7 virtual machine. Note the memory locations of *Winamp.exe*
    and some Windows DLLs such as *USER32* and *SHELL32*. Now restart the system and
    try again. You should notice that the locations of the Windows components change
    at reboot while the location of *Winamp.exe* stays the same. In my case, the first
    time I looked at Winamp in Immunity Debugger, the memory locations were as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用 ASLR 时，你不能依赖某些指令位于特定的内存地址。要查看 ASLR 的实际效果，可以在你的 Windows 7 虚拟机上通过 Immunity
    Debugger 打开 Winamp 程序。注意 *Winamp.exe* 和一些 Windows DLL（如 *USER32* 和 *SHELL32*）的内存位置。现在重启系统再试一次。你应该会注意到，Windows
    组件的位置在重启后发生了变化，而 *Winamp.exe* 的位置保持不变。在我的案例中，我第一次在 Immunity Debugger 中查看 Winamp
    时，内存位置如下：
- en: '`00400000` *Winamp.exe*'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`00400000` *Winamp.exe*'
- en: '`778B0000` *USER32.dll*'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`778B0000` *USER32.dll*'
- en: '`76710000` *SHELL32.dll*'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`76710000` *SHELL32.dll*'
- en: 'After reboot they looked like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重启后，它们的地址变成了这样：
- en: '`00400000` *Winamp.exe*'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`00400000` *Winamp.exe*'
- en: '`770C0000` *USER32.dll*'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`770C0000` *USER32.dll*'
- en: '`75810000` *SHELL32.dll*'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`75810000` *SHELL32.dll*'
- en: Like SafeSEH, there is no rule in Windows that programs must implement ASLR.
    Even some Windows applications such as Internet Explorer didn’t implement ASLR
    right away. However, Windows Vista and later shared libraries such as *USER32.dll*
    and *SHELL32.dll* do use ASLR. If we want to use any code in these libraries,
    we will not be able to call instructions directly from a static address.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SafeSEH 类似，Windows 中没有强制要求程序必须实现 ASLR。即使一些 Windows 应用程序（如 Internet Explorer）最初也没有立即实现
    ASLR。然而，Windows Vista 及之后的版本，像 *USER32.dll* 和 *SHELL32.dll* 这样的共享库确实使用了 ASLR。如果我们希望使用这些库中的代码，我们将无法直接从静态地址调用指令。
- en: Data Execution Prevention
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据执行保护
- en: In the exploits we developed in the past few chapters, we relied on the ability
    to inject our shellcode into memory somewhere, pass execution to the shellcode,
    and have the shellcode execute. *Data execution prevention (DEP)* makes this a
    little harder by designating specific parts of memory as nonexecutable. If an
    attacker tries to execute code from nonexecutable memory, the attack will fail.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们过去几章开发的漏洞利用中，我们依赖于将我们的 shellcode 注入某个内存位置，传递执行到 shellcode，并让 shellcode 执行。*数据执行保护（DEP）*
    通过将特定的内存区域标记为不可执行，设计上使得这一过程变得更加困难。如果攻击者尝试从不可执行的内存中执行代码，攻击将失败。
- en: DEP is used in most modern versions of Windows, as well as Linux, Mac OS, and
    even Android platforms. iOS does not require DEP, as discussed in the next section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: DEP 被大多数现代版本的 Windows 以及 Linux、Mac OS 和甚至 Android 平台使用。iOS 不需要 DEP，关于这一点将在下一节讨论。
- en: To bypass DEP, attackers typically use a technique called *return-oriented programming
    (ROP)*. ROP allows attackers to execute specific instructions already included
    in executable memory. One common technique is to use ROP to create a section of
    memory that is writable and executable, and then write the payload to this memory
    segment and execute it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过 DEP，攻击者通常使用一种名为 *返回导向编程（ROP）* 的技术。ROP 允许攻击者执行已包含在可执行内存中的特定指令。一种常见的技术是使用
    ROP 创建一个可写且可执行的内存区域，然后将有效载荷写入该内存段并执行它。
- en: Mandatory Code Signing
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制代码签名
- en: Apple’s iOS team takes a different approach to preventing malicious code from
    executing. All code that executes on an iPhone must be signed by a trusted authority,
    usually Apple itself. To run an application on an iPhone, developers must submit
    the code for Apple’s review. If Apple determines that their app is not malicious,
    it is usually approved and the code is signed by Apple.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的 iOS 团队采取了不同的方式来防止恶意代码执行。在 iPhone 上执行的所有代码必须由受信任的机构签名，通常是苹果公司本身。为了在 iPhone
    上运行应用程序，开发者必须提交代码进行苹果的审核。如果苹果确定他们的应用程序不是恶意的，通常会批准并由苹果签名代码。
- en: One common route that malware authors take to bypass detection at install time
    is downloading new, potentially malicious code at runtime and executing it. However,
    because all memory pages must be signed by a trusted authority, this sort of attack
    will fall flat on an iPhone. As soon as the application attempts to run unsigned
    code, the CPU will reject it, and the application will crash. DEP is not required,
    because mandatory code signing takes the protection a step further.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者绕过安装时检测的常见方式是，在运行时下载新的、潜在恶意的代码并执行它。然而，由于所有内存页必须由受信任的机构签名，这种攻击方式在 iPhone
    上会失败。只要应用程序尝试运行未签名的代码，CPU 就会拒绝它，应用程序将崩溃。DEP 不是必需的，因为强制代码签名进一步加强了保护。
- en: Of course, it is possible to write exploits that bypass these restrictions,
    as with iPhone jailbreaks, but on the latest versions of iOS, a jailbreak is no
    small feat. Rather than using ROP briefly to create a DEP bypass, with mandatory
    code signing, the entire payload must be created using ROP.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有可能编写能够绕过这些限制的漏洞，就像iPhone越狱一样，但在最新版本的iOS上，越狱并非易事。与其简短地使用ROP来创建DEP绕过，在强制代码签名的情况下，整个有效负载必须使用ROP来创建。
- en: One mitigation technique alone is not enough to foil the most skilled exploit
    developers armed with the latest methods. As a result, exploit mitigation techniques
    are typically chained together to further foil attacks. For example, iOS uses
    both mandatory code signing and full ASLR. Thus, an attacker has to use ROP for
    the entire payload, and thanks to ASLR, building a ROP payload is no picnic.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 单一的缓解技术不足以阻止那些掌握最新方法的高技能漏洞开发者。因此，漏洞缓解技术通常会组合在一起，以进一步抵御攻击。例如，iOS同时使用强制代码签名和完整的ASLR（地址空间布局随机化）。因此，攻击者必须对整个有效负载使用ROP，并且由于ASLR的存在，构建ROP有效负载并非易事。
- en: In the previous two chapters, we have covered a solid introduction to exploit
    development. Building on the skills we discussed, you can move on to more advanced
    exploitation—even taking out the latest, most secure platforms and programs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们已经涵盖了漏洞开发的基础知识。基于我们讨论的技能，你可以进入更高级的漏洞利用，甚至突破最新、最安全的平台和程序。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we looked at a few odds and ends for basic exploit development.
    We looked at a technique called fuzzing in order to find potential exploitation
    points. We also looked at working with public exploits and porting them to meet
    our needs. We replaced the shellcode using Msfvenom and found a return address
    that works with our platform. Next we looked at porting a completed Python exploit
    into our first Metasploit module. Starting with a module for a similar issue,
    we made changes to fit the 3Com TFTP long transport mode buffer overflow vulnerability.
    Finally, we talked briefly about some of the exploitation mitigation techniques
    that you will encounter as you continue your study of exploit development.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们介绍了一些基础漏洞开发的零散技巧。我们介绍了一种叫做模糊测试（fuzzing）的方法，用于发现潜在的漏洞点。我们还讨论了如何使用公共漏洞并将其移植以满足我们的需求。我们通过使用Msfvenom替换了shellcode，并找到了适合我们平台的返回地址。接下来，我们看了如何将一个完成的Python漏洞移植到我们的第一个Metasploit模块中。从一个类似问题的模块开始，我们做了修改以适应3Com
    TFTP长传输模式缓冲区溢出漏洞。最后，我们简要讨论了一些在继续学习漏洞开发时可能会遇到的漏洞缓解技术。
- en: We are nearing the end of our journey into the basics of penetration testing.
    Let’s finish up with a chapter on assessing the security of mobile devices.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束渗透测试基础部分的学习。让我们通过一章关于评估移动设备安全性的内容来收尾。
