- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Constants, Variables, and Data Types
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 常量、变量和数据类型
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'Chapter 2 discussed the basic format for data in memory. Chapter 3 covered
    how a computer system physically organizes that data in memory. This chapter finishes
    the discussion by connecting the concept of *data representation* to its actual
    physical representation. As the title indicates, this chapter concerns itself
    with three main topics: constants, variables, and data structures. I do not assume
    that you’ve had a formal course in data structures, though such experience would
    be useful.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第二章讨论了内存中数据的基本格式。第三章介绍了计算机系统如何在物理上组织这些数据。本章通过将 *数据表示* 概念与其实际的物理表示相连接，完成了这一讨论。如标题所示，本章主要涉及三个主题：常量、变量和数据结构。我并不假设你有数据结构的正式课程经验，尽管这样的经验会很有帮助。
- en: This chapter discusses how to declare and use constants, scalar variables, integers,
    data types, pointers, arrays, records/structures, and unions. You must master
    these subjects before going on to the next chapter. Declaring and accessing arrays,
    in particular, seem to present a multitude of problems to beginning assembly language
    programmers. However, the rest of this text depends on your understanding of these
    data structures and their memory representation. Do not try to skim over this
    material with the expectation that you will pick it up as you need it later. You
    will need it right away, and trying to learn this material along with later material
    will only confuse you more.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了如何声明和使用常量、标量变量、整数、数据类型、指针、数组、记录/结构体以及联合体。在进入下一章之前，你必须掌握这些内容。特别是，声明和访问数组似乎是初学汇编语言的程序员常遇到的各种问题。然而，本书其余部分依赖于你对这些数据结构及其内存表示的理解。不要试图跳过这部分内容，期望以后需要时再去学。你将马上用到这些知识，而试图在学习后续内容时再掌握这部分知识只会让你更加困惑。
- en: 4.1 The imul Instruction
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 `imul` 指令
- en: This chapter introduces arrays and other concepts that will require the expansion
    of your x86-64 instruction set knowledge. In particular, you will need to learn
    how to multiply two values; hence, this section looks at the `imul` (*integer
    multiply*) instruction.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了数组和其他概念，这些概念将要求你扩展对 x86-64 指令集的理解。特别是，你需要学习如何将两个值相乘；因此，本节将讲解 `imul`（*整数乘法*）指令。
- en: 'The `imul` instruction has several forms. This section doesn’t cover all of
    them, just the ones that are useful for array calculations (for the remaining
    `imul` instructions, see “Arithmetic Expressions” in Chapter 6). The `imul` variants
    of interest right now are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`imul` 指令有几种形式。本节不会覆盖所有形式，只讨论那些对于数组计算有用的形式（其余 `imul` 指令请参见第六章的“算术表达式”）。目前关注的
    `imul` 变体如下：'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the syntax of the `imul` instruction is different from that of the
    `add` and `sub` instructions. In particular, the destination operand must be a
    register (`add` and `sub` both allow a memory operand as a destination). Also
    note that `imul` allows three operands when the last operand is a constant. Another
    important difference is that the `imul` instruction allows only 16-, 32-, and
    64-bit operands; it does not multiply 8-bit operands. Finally, as is true for
    most instructions that support the immediate addressing mode, the CPU limits constant
    sizes to 32 bits. For 64-bit operands, the x86-64 will sign-extend the 32-bit
    immediate constant to 64 bits.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`imul` 指令的语法与 `add` 和 `sub` 指令不同。特别是，目标操作数必须是寄存器（`add` 和 `sub` 都允许将内存操作数作为目标）。另外，`imul`
    在最后一个操作数为常量时支持三个操作数。另一个重要的区别是，`imul` 指令只支持 16 位、32 位和 64 位操作数；它不支持 8 位操作数。最后，与大多数支持立即寻址模式的指令一样，CPU
    限制常量大小为 32 位。对于 64 位操作数，x86-64 会将 32 位立即数扩展为 64 位。
- en: '`imul` computes the product of its specified operands and stores the result
    into the destination register. If an overflow occurs (which is always a signed
    overflow, because `imul` multiplies only signed integer values), then this instruction
    sets both the carry and overflow flags. `imul` leaves the other condition code
    flags undefined (so, for example, you cannot meaningfully check the sign flag
    or the zero flag after executing `imul`).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`imul` 计算指定操作数的乘积，并将结果存储到目标寄存器中。如果发生溢出（因为 `imul` 只进行带符号整数值的乘法，所以溢出总是带符号溢出），该指令将同时设置进位标志和溢出标志。`imul`
    不会改变其他条件码标志（例如，执行 `imul` 后，你不能有意义地检查符号标志或零标志）。'
- en: 4.2 The inc and dec Instructions
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 `inc` 和 `dec` 指令
- en: 'As several examples up to this point have indicated, adding or subtracting
    1 from a register or memory location is a very common operation. In fact, these
    operations are so common that Intel’s engineers included a pair of instructions
    to perform these specific operations: `inc` (*increment*) and `dec` (*decrement*).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如到目前为止的几个例子所示，对寄存器或内存位置加1或减1是非常常见的操作。事实上，这些操作如此常见，以至于英特尔的工程师们专门设计了一对指令来执行这些特定的操作：`inc`（*增量*）和`dec`（*减量*）。
- en: 'The `inc` and `dec` instructions use the following syntax:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`inc`和`dec`指令使用以下语法：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The single operand can be any legal 8-, 16-, 32-, or 64-bit register or memory
    operand. The `inc` instruction will add 1 to the specified operand, and the `dec`
    instruction will subtract 1 from the specified operand.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单一操作数可以是任何合法的8位、16位、32位或64位寄存器或内存操作数。`inc`指令会对指定的操作数加1，`dec`指令会对指定的操作数减1。
- en: 'These two instructions are slightly shorter than the corresponding `add` or
    `sub` instructions (their encoding uses fewer bytes). There is also one slight
    difference between these two instructions and the corresponding `add` or `sub`
    instructions: they do not affect the carry flag.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条指令比对应的`add`或`sub`指令稍微短一些（它们的编码使用了更少的字节）。这两条指令与对应的`add`或`sub`指令之间还有一个细微的区别：它们不会影响进位标志。
- en: 4.3 MASM Constant Declarations
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 MASM常量声明
- en: 'MASM provides three directives that let you define constants in your assembly
    language programs.^([1](#c04-footnote-1)) Collectively, these three directives
    are known as *equates*. You’ve already seen the most common form:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: MASM提供了三种指令，让你在汇编语言程序中定义常量。^([1](#c04-footnote-1)) 总的来说，这三种指令被称为*equates*。你已经看过最常见的形式：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once you declare a symbolic constant in this manner, you may use the symbolic
    identifier anywhere the corresponding literal constant is legal. These constants
    are known as *manifest* *constants*—symbolic representations that allow you to
    substitute the literal value for the symbol anywhere in the program.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你以这种方式声明了一个符号常量，你可以在任何对应的文字常量合法的地方使用该符号标识符。这些常量被称为*manifest* *constants*——符号表示，它们允许你在程序的任何地方将文字值替换为符号。
- en: Contrast this with `.const` variables; a `.const` variable is certainly a constant
    value because you cannot change its value at runtime. However, a memory location
    is associated with a `.const` variable; the operating system, not the MASM compiler,
    enforces the read-only attribute. Although it will certainly crash your program
    when it runs, it is perfectly legal to write an instruction like `mov ReadOnlyVar,
    eax`. On the other hand, it is no more legal to write `mov MaxIndex, eax` (using
    the preceding declaration) than it is to write `mov 15, eax`. In fact, both statements
    are equivalent because the compiler substitutes `15` for `MaxIndex` whenever it
    encounters this manifest constant.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与`.const`变量进行对比；`.const`变量当然是一个常量，因为你无法在运行时更改其值。然而，`.const`变量与一个内存位置相关联；操作系统，而非MASM编译器，强制执行只读属性。尽管在程序运行时确实会崩溃，但像`mov
    ReadOnlyVar, eax`这样的指令是完全合法的。另一方面，写`mov MaxIndex, eax`（使用前面的声明）就像写`mov 15, eax`一样不合法。事实上，这两个语句是等价的，因为编译器在遇到这个常量时，会将`MaxIndex`替换为`15`。
- en: Constant declarations are great for defining “magic” numbers that might possibly
    change during program modification. Most of the listings throughout this book
    have used manifest constants like `nl` (*newline*), `maxLen`, and `NULL`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 常量声明非常适合定义在程序修改期间可能会变化的“魔法”数字。书中的大部分示例都使用了像`nl`（*换行符*）、`maxLen`和`NULL`这样的常量。
- en: 'In addition to the `=` directive, MASM provides the `equ` directive:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`=`指令外，MASM还提供了`equ`指令：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With a couple exceptions, these two equate directives do the same thing: they
    define a manifest constant, and MASM will substitute the `constant_expression`
    value wherever the `symbol` appears in the source file.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一些例外，这两个`equate`指令做的事情是一样的：它们定义了一个常量，MASM将在源文件中每次遇到`symbol`时用`constant_expression`的值替代它。
- en: 'The first difference between the two is that MASM allows you to redefine symbols
    that use the `=` directive. Consider the following code snippet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者之间的第一个区别是MASM允许你重新定义使用`=`指令的符号。考虑以下代码片段：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You might question the term *constant* when it’s pretty clear in this example
    that `maxSize`’s value changes at various points in the source file. However,
    note that while `maxSize`’s value does change during assembly, at runtime the
    particular literal constant (100 or 256 in this example) can never change.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会质疑*常量*这个术语，因为在这个例子中，`maxSize`的值在源文件的多个点上发生了变化。然而，请注意，尽管`maxSize`的值在汇编过程中会变化，但在运行时，特定的字面常量（在这个例子中为100或256）是永远不会改变的。
- en: You cannot redefine the value of a constant you declare with an `equ` directive
    (at runtime or assembly time). Any attempt to redefine an `equ` symbol results
    in a symbol redefinition error from MASM. So if you want to prevent the accidental
    redefinition of a constant symbol in your source file, you should use the `equ`
    directive rather than the `=` directive.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法重新定义通过`equ`指令声明的常量的值（无论是在运行时还是汇编时）。任何重新定义`equ`符号的尝试都会导致MASM的符号重定义错误。因此，如果你想防止在源文件中意外重新定义常量符号，应该使用`equ`指令，而不是`=`指令。
- en: Another difference between the `=` and `equ` directives is that constants you
    define with `=` must be representable as a 64-bit (or smaller) integer. Short
    character strings are legal as `=` operands, but only if they have eight or fewer
    characters (which would fit into a 64-bit value). Equates using `equ` have no
    such limitation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`=`和`equ`指令之间的另一个区别是，通过`=`定义的常量必须能表示为64位（或更小）整数。短字符字符串作为`=`操作数是合法的，但前提是它们的长度不超过八个字符（即适合64位值）。使用`equ`的等式则没有这种限制。'
- en: Ultimately, the difference between `=` and `equ` is that the `=` directive computes
    the value of a numeric expression and saves that value to substitute wherever
    that symbol appears in the program. The `equ` directive, if its operand can be
    reduced to a numeric value, will work the same way. However, if the `equ` operand
    cannot be converted to a numeric value, then the `equ` directive will save its
    operand as textual data and substitute that textual data in place of the symbol.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，`=`和`equ`之间的区别在于，`=`指令计算一个数值表达式的值并将该值保存下来，替代程序中出现该符号的位置。如果`equ`指令的操作数可以被简化为一个数值，它将以相同的方式工作。然而，如果`equ`操作数无法转换为数值，`equ`指令将把它的操作数保存为文本数据，并在符号位置替换为该文本数据。
- en: 'Because of the numeric/text processing, `equ` can get confused on occasion
    by its operand. Consider the following example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数值/文本处理，`equ`偶尔会对其操作数感到困惑。考虑以下例子：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'MASM will report an error (`initializer magnitude too large for specified size`
    or something similar) because a 64-bit value (obtained by creating an integer
    value from the eight characters `abcdefgh`) will not fit into a byte variable.
    However, if we add one more character to the string, MASM will gladly accept this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: MASM将报告错误（`initializer magnitude too large for specified size`或类似的错误），因为由八个字符`abcdefgh`构成的64位值将无法适配一个字节变量。然而，如果我们给字符串添加一个字符，MASM将很乐意接受：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The difference between these two examples is that in the first case, MASM decides
    that it can represent the string as a 64-bit integer, so the constant is a quad-word
    constant rather than a string of characters. In the second example, MASM cannot
    represent the string of characters as an integer, so it treats the operand as
    a text operand rather than a numeric operand. When MASM does a textual substitution
    of the string `abcdefghi` for `memStr` in the second example, MASM assembles the
    code properly because strings are perfectly legitimate operands for the `byte`
    directive.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子之间的区别在于，在第一个例子中，MASM决定它可以将字符串表示为64位整数，因此常量是一个四字常量，而不是字符字符串。在第二个例子中，MASM无法将字符字符串表示为整数，因此它将操作数视为文本操作数，而不是数值操作数。当MASM在第二个例子中对`memStr`进行文本替换为`abcdefghi`时，MASM能够正确地汇编代码，因为字符串是`byte`指令的完全合法操作数。
- en: 'Assuming you really want MASM to treat a string of eight characters or fewer
    as a string rather than as an integer value, there are two solutions. The first
    is to surround the operand with *text delimiters*. MASM uses the symbols `<` and
    `>` as text delimiters in an `equ` operand field. So, you could use the following
    code to solve this problem:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你真的希望MASM将八个或更少字符的字符串当作字符串而不是整数值来处理，那么有两种解决方案。第一种是将操作数用*文本定界符*括起来。MASM在`equ`操作数字段中使用符号`<`和`>`作为文本定界符。因此，你可以使用以下代码来解决这个问题：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Because the `equ` directive’s operand can be somewhat ambiguous at times, Microsoft
    introduced a third equate directive, `textequ`, to use when you want to create
    a text equate. Here’s the current example using a text equate:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `equ` 指令的操作数有时可能会有些模糊，微软引入了第三种等式指令 `textequ`，用于在你想创建文本等式时使用。以下是使用文本等式的当前示例：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that `textequ` operands must always use the text delimiters (`<` and `>`)
    in the operand field.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`textequ` 操作数必须始终使用文本定界符（`<` 和 `>`）在操作数字段中。
- en: 'Whenever MASM encounters a symbol defined with the text directive in a source
    file, it will immediately substitute the text associated with that directive for
    the identifier. This is somewhat similar to the C/C++ `#define` macro (except
    you don’t get to specify any parameters). Consider the following example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 MASM 在源文件中遇到用文本指令定义的符号时，它会立即将与该指令关联的文本替换为标识符。这与 C/C++ 中的 `#define` 宏有些相似（不过你无法指定任何参数）。考虑以下示例：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'MASM substitutes `maxCnt` for `max` throughout the program (after the `textequ`
    declaring `max`). In the third line of this example, this substitution yields
    the statement:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 会在整个程序中将 `maxCnt` 替换为 `max`（在 `textequ` 声明 `max` 后）。在此示例的第三行，这个替换结果是：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Thereafter in the program, MASM will substitute the value `11` everywhere it
    sees the symbol `maxCnt`. Whenever MASM sees `max` after that point, it will substitute
    `maxCnt`, and then it will substitute `11` for `maxCnt`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的后续部分，MASM 会在每次遇到符号 `maxCnt` 时将其替换为 `11`。以后每次 MASM 遇到 `max`，它都会替换为 `maxCnt`，然后再将
    `maxCnt` 替换为 `11`。
- en: 'You could even use MASM text equates to do something like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用 MASM 文本等式做类似下面的操作：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: MASM will substitute `mov` for `mv` and compile the last statement in this sequence
    into a `mov` instruction. Most people would consider this a huge violation of
    assembly language programming style, but it’s perfectly legal.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 会将 `mv` 替换为 `mov`，并将此序列中的最后一条语句编译成 `mov` 指令。大多数人会认为这是对汇编语言编程风格的巨大违反，但它是完全合法的。
- en: 4.3.1 Constant Expressions
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 常量表达式
- en: 'Thus far, this chapter has given the impression that a symbolic constant definition
    consists of an identifier, an optional type, and a literal constant. Actually,
    MASM constant declarations can be a lot more sophisticated than this because MASM
    allows the assignment of a constant expression, not just a literal constant, to
    a symbolic constant. The generic constant declaration takes one of the following
    two forms:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章给人的印象是，符号常量定义由标识符、可选的类型和字面常量组成。实际上，MASM 常量声明可能比这复杂得多，因为 MASM 允许将常量表达式（而不仅仅是字面常量）赋值给符号常量。通用常量声明有以下两种形式：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Constant (integer) expressions take the familiar form you’re used to in high-level
    languages like C/C++ and Python. They may contain literal constant values, previously
    declared symbolic constants, and various arithmetic operators.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 常量（整数）表达式采用你在 C/C++ 和 Python 等高级语言中习惯的形式。它们可以包含字面常量值、先前声明的符号常量以及各种算术运算符。
- en: The constant expression operators follow standard precedence rules (similar
    to those in C/C++); you may use the parentheses to override the precedence if
    necessary. In general, if the precedence isn’t obvious, use parentheses to exactly
    state the order of evaluation. [Table 4-1](#table4-1) lists the arithmetic operators
    MASM allows in constant (and address) expressions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 常量表达式运算符遵循标准的优先级规则（类似于 C/C++ 中的规则）；如果需要，可以使用括号来覆盖优先级。通常，如果优先级不明显，请使用括号明确指定评估顺序。[表
    4-1](#table4-1) 列出了 MASM 允许在常量（和地址）表达式中使用的算术运算符。
- en: 'Table 4-1: Operations Allowed in Constant Expressions'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1：常量表达式中允许的运算
- en: '| **Arithmetic operators** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **算术运算符** |'
- en: '| --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| `-` (unary negation) | Negates the expression immediately following `-`.
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `-`（一元取反） | 对紧随其后的表达式进行取反操作。 |'
- en: '| `*` | Multiplies the integer or real values around the asterisk. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 对星号两侧的整数或实数值进行乘法运算。 |'
- en: '| `/` | Divides the left integer operand by the right integer operand, producing
    an integer (truncated) result. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 将左侧整数操作数除以右侧整数操作数，得到一个整数（截断）结果。 |'
- en: '| `mod` | Divides the left integer operand by the right integer operand, producing
    an integer remainder. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `mod` | 将左侧整数操作数除以右侧整数操作数，产生一个整数余数。 |'
- en: '| `/` | Divides the left numeric operand by the second numeric operand, producing
    a floating-point result. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 将左侧数字操作数除以第二个数字操作数，得到一个浮点数结果。 |'
- en: '| `+` | Adds the left and right numeric operands. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 将左右数字操作数相加。 |'
- en: '| `-` | Subtracts the right numeric operand from the left numeric operand.
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 从左侧数字操作数中减去右侧数字操作数。 |'
- en: '| `[]` | `expr`1`[``expr`2`]` computes the sum of `expr`1 + `expr`2. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `[]` | `expr`1`[``expr`2`]`计算`expr`1 + `expr`2的和。 |'
- en: '| **Comparison operators** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **比较运算符** |'
- en: '| `EQ` | Compares left operand with right operand. Returns true if equal.*
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `EQ` | 比较左操作数与右操作数。如果相等，则返回真。* |'
- en: '| `NE` | Compares left operand with right operand. Returns true if not equal.
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `NE` | 比较左操作数与右操作数。如果不相等，则返回真。 |'
- en: '| `LT` | Returns true if left operand is less than right operand. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `LT` | 如果左操作数小于右操作数，则返回真。 |'
- en: '| `LE` | Returns true if left operand is `≤` right operand. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `LE` | 如果左操作数小于等于右操作数，则返回真。 |'
- en: '| `GT` | Returns true if left operand is greater than right operand. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `GT` | 如果左操作数大于右操作数，则返回真。 |'
- en: '| `GE` | Returns true if left operand is `≥` right operand. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `GE` | 如果左操作数大于等于右操作数，则返回真。 |'
- en: '| **Logical operators**** |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑运算符** |'
- en: '| `AND` | For Boolean operands, returns the logical AND of the two operands.
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `AND` | 对布尔操作数，返回两操作数的逻辑与。 |'
- en: '| `OR` | For Boolean operands, returns the logical OR of the two operands.
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `OR` | 对布尔操作数，返回两操作数的逻辑或。 |'
- en: '| `NOT` | For Boolean operands, returns the logical negation (inverse). |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `NOT` | 对布尔操作数，返回逻辑否定（逆）。 |'
- en: '| **Unary operators** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **一元运算符** |'
- en: '| `HIGH` | Returns the HO byte of the LO 16 bits of the following expression.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `HIGH` | 返回以下表达式的低16位的高字节。 |'
- en: '| `HIGHWORD` | Returns the HO word of the LO 32 bits of the following expression.
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `HIGHWORD` | 返回以下表达式的低32位的高字。 |'
- en: '| `HIGH32` | Returns the HO 32 bits of the 64-bit expression following the
    operator. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `HIGH32` | 返回操作符后面64位表达式的高32位。 |'
- en: '| `LENGTHOF` | Returns the number of data elements of the variable name following
    the operator. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `LENGTHOF` | 返回操作符后面跟随的变量名称的数据元素个数。 |'
- en: '| `LOW` | Returns the LO byte of the expression following the operator. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `LOW` | 返回操作符后面表达式的低字节。 |'
- en: '| `LOWWORD` | Returns the LO word of the expression following the operator.
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `LOWWORD` | 返回操作符后面表达式的低字。 |'
- en: '| `LOW32` | Returns the LO dword of the expression following the operator.
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `LOW32` | 返回操作符后面表达式的低双字。 |'
- en: '| `OFFSET` | Returns the offset into its respective section for the symbol
    following the operator. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `OFFSET` | 返回操作符后面符号在其相应节中的偏移量。 |'
- en: '| `OPATTR` | Returns the attributes of the expression following the operator.
    The attributes are returned as a bit map with the following meanings: bit 0: There
    is a code label in the expression.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '| `OPATTR` | 返回操作符后面表达式的属性。属性以位图的形式返回，含义如下：位0：表达式中有代码标签。'
- en: 'bit 1: The expression is relocatable.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 位1：该表达式是可重定位的。
- en: 'bit 2: The expression is a constant expression.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 位2：该表达式是常量表达式。
- en: 'bit 3: The expression uses direct addressing.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 位3：该表达式使用直接寻址。
- en: 'bit 4: The expression is a register.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 位4：该表达式是一个寄存器。
- en: 'bit 5: The expression contains no undefined symbols.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 位5：该表达式不包含未定义符号。
- en: 'bit 6: The expression is a stack-segment memory expression.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 位6：该表达式是一个栈段内存表达式。
- en: 'bit 7: The expression references an external label.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 位7：该表达式引用了一个外部标签。
- en: 'bits 8–11: Language type (probably 0 for 64-bit code). |'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 位8-11：语言类型（可能64位代码的值为0）。 |
- en: '| `SIZE` | Returns the size, in bytes, of the first initializer in a symbol’s
    declaration. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `SIZE` | 返回符号声明中第一个初始化器的字节大小。 |'
- en: '| `SIZEOF` | Returns the size, in bytes, allocated for a given symbol. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `SIZEOF` | 返回为给定符号分配的字节大小。 |'
- en: '| `THIS` | Returns an address expression equal to the value of the current
    program counter within a section. Must include type after `this`; for example,
    `this byte`. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `THIS` | 返回当前程序计数器在某节内的地址表达式。必须在`this`后加上类型；例如，`this byte`。 |'
- en: '| `$` | Synonym for `this`. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `$` | `this`的同义词。 |'
- en: 4.3.2 this and $ Operators
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 `this`和`$`运算符
- en: 'The last two operators in [Table 4-1](#table4-1) deserve special mention. The
    `this` and `$` operands (they are roughly synonyms for one another) return the
    current offset into the section containing them. The current offset into the section
    is known as the *location counter* (see “How MASM Allocates Memory for Variables”
    in Chapter 3). Consider the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 4-1](#table4-1)中，最后两个运算符值得特别提及。`this`和`$`操作数（它们大致是同义词）返回当前所在节的偏移量。当前偏移量被称为*位置计数器*（参见第3章《MASM如何分配变量内存》）。考虑以下内容：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This sets the label’s offset to the current location in the program. The type
    of the symbol will be *statement label* (for example, `proc`). Typically, people
    use the `$` operator for branch labels (and advanced features). For example, the
    following creates an infinite loop (effectively locking up the CPU):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置标签的偏移量为程序中的当前位置。符号的类型将是 *语句标签*（例如，`proc`）。通常，人们使用 `$` 操作符来处理分支标签（以及高级特性）。例如，以下代码会创建一个无限循环（实际上会锁死
    CPU）：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can also use instructions like this to skip a fixed number of bytes ahead
    (or behind) in the source file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用类似这样的指令，在源文件中跳过固定数量的字节（向前或向后）：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For the most part, creating operands like this is crazy because it depends on
    knowing the number of bytes of machine code each machine instruction compiles
    into. Obviously, this is an advanced operation and not recommended for beginning
    assembly language programmers (it’s even hard to recommend for most advanced assembly
    language programmers).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，像这样创建操作数是疯狂的，因为它依赖于知道每条机器指令在汇编时编译成的机器码字节数。显然，这是一项高级操作，不建议初学汇编语言的程序员使用（即便是对于大多数高级汇编语言程序员来说，也很难推荐这种做法）。
- en: 'One practical use of the `$` operator (and probably its most common use) is
    to compute the size of a block of data declarations in the source file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`$` 操作符的一个实际应用（也许是最常见的用法）是计算源文件中数据声明块的大小：'
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The address expression `$-someData` computes the current offset minus the offset
    of `someData` in the current section. In this case, this produces `5`, the number
    of bytes in the `someData` operand field. In this simple example, you’re probably
    better off using the `sizeof someData` expression. This also returns the number
    of bytes required for the `someData` declaration. However, consider the following
    statements:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 地址表达式 `$-someData` 计算当前偏移量减去当前节中 `someData` 的偏移量。在这个例子中，它会得到 `5`，即 `someData`
    操作数字段的字节数。在这个简单的例子中，使用 `sizeof someData` 表达式可能更为合适。它同样返回 `someData` 声明所需的字节数。然而，考虑以下语句：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, `sizeof someData` still returns `5` (because it returns only the
    length of the operands attached to `someData`), whereas `sizeSomeData` is set
    to `10`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`sizeof someData` 仍然返回 `5`（因为它只返回附加到 `someData` 的操作数的长度），而 `sizeSomeData`
    被设置为 `10`。
- en: 'If an identifier appears in a constant expression, that identifier must be
    a constant identifier that you have previously defined in your program in the
    equate directive. You may not use variable identifiers in a constant expression;
    their values are not defined at assembly time when MASM evaluates the constant
    expression. Also, don’t confuse compile-time and runtime operations:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标识符出现在常量表达式中，那么该标识符必须是你之前在程序中通过 equate 指令定义的常量标识符。你不能在常量表达式中使用变量标识符；因为当 MASM
    计算常量表达式时，变量的值在汇编时并未定义。此外，不要混淆编译时操作和运行时操作：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `this` operator differs from the `$` operator in one important way: the
    `$` has a default type of statement label. The `this` operator, on the other hand,
    allows you to specify a type. The syntax for the `this` operator is the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 操作符与 `$` 操作符有一个重要区别：`$` 默认类型是语句标签，而 `this` 操作符允许你指定类型。`this` 操作符的语法如下：'
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'where `type` is one of the usual data types (`byte`, `sbyte`, `word`, `sword`,
    and so forth). Therefore, `this proc` is what is directly equivalent to `$`. Note
    that the following two MASM statements are equivalent:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `type` 是常见的数据类型之一（如 `byte`、`sbyte`、`word`、`sword` 等）。因此，`this proc` 就是直接等同于
    `$` 的操作符。注意，以下两个 MASM 语句是等价的：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 4.3.3 Constant Expression Evaluation
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 常量表达式计算
- en: MASM immediately interprets the value of a constant expression during assembly.
    It does not emit any machine instructions to compute `x + y` in the constant expression
    of the example in the previous section. Instead, it directly computes the sum
    of these two constant values. From that point forward in the program, MASM associates
    the value `11` with the constant `Sum` just as if the program had contained the
    statement `Sum = 11` rather than `Sum = x + y`. On the other hand, MASM does not
    precompute the value `11` in AL for the `mov` and `add` instructions in the previous
    section; it faithfully emits the object code for these two instructions, and the
    x86-64 computes their sum when the program is run (sometime after the assembly
    is complete).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 会在汇编时立即解释常量表达式的值。它不会生成任何机器指令来计算前面例子中的常量表达式 `x + y`。相反，它直接计算这两个常量值的和。从那时起，MASM
    会将值 `11` 关联到常量 `Sum`，就好像程序包含了语句 `Sum = 11` 而不是 `Sum = x + y`。另一方面，MASM 不会在 `mov`
    和 `add` 指令的前面部分预先计算 `11` 的值；它会忠实地生成这两条指令的目标代码，而 x86-64 会在程序运行时（汇编完成后的一段时间）计算它们的和。
- en: 'In general, constant expressions don’t get very sophisticated in assembly language
    programs. Usually, you’re adding, subtracting, or multiplying two integer values.
    For example, the following set of equates defines a set of constants that have
    consecutive values:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，常量表达式在汇编语言程序中并不复杂。通常，你是在加法、减法或乘法两个整数值。例如，以下等式集合定义了一组具有连续值的常量：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These constants have the following values: `TapeDAT = 0`, `Tape8mm = 1`, `TapeQIC80
    = 2`, `TapeTravan = 3`, and `TapeDLT = 4`. This example, by the way, demonstrates
    how you would create a list of enumerated data constants in MASM.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量的值如下：`TapeDAT = 0`，`Tape8mm = 1`，`TapeQIC80 = 2`，`TapeTravan = 3`，`TapeDLT
    = 4`。顺便说一下，这个例子演示了如何在 MASM 中创建一个枚举数据常量列表。
- en: 4.4 The MASM typedef Statement
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 MASM typedef 声明
- en: 'Let’s say that you do not like the names that MASM uses for declaring `byte`,
    `word`, `dword`, `real4`, and other variables. Let’s say that you prefer Pascal’s
    naming convention or perhaps C’s naming convention. You want to use terms like
    *integer*, *float*, *double*, or whatever. If MASM were Pascal, you could redefine
    the names in the `type` section of the program. With C, you could use a `typedef`
    statement to accomplish the task. Well, MASM, like C/C++, has its own type statement
    that also lets you create aliases of these names. The MASM `typedef` statement
    takes the following form:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你不喜欢 MASM 用于声明 `byte`、`word`、`dword`、`real4` 和其他变量的名称。假设你更喜欢 Pascal 的命名规则，或者
    C 的命名规则。你希望使用像 *integer*、*float*、*double* 之类的术语。如果 MASM 是 Pascal，你可以在程序的 `type`
    部分重新定义这些名称。对于 C，你可以使用 `typedef` 语句来完成这项任务。好吧，MASM 像 C/C++ 一样，也有自己的类型声明语句，同样可以让你创建这些名称的别名。MASM
    的 `typedef` 语句格式如下：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following example demonstrates how to set up some names in your MASM programs
    that are compatible with C/C++ or Pascal:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何在 MASM 程序中设置与 C/C++ 或 Pascal 兼容的名称：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now you can declare your variables with more meaningful statements like these:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用更有意义的声明来声明你的变量，比如这些：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you program in Ada, C/C++, or FORTRAN (or any other language, for that matter),
    you can pick type names you’re more comfortable with. Of course, this doesn’t
    change how the x86-64 or MASM reacts to these variables one iota, but it does
    let you create programs that are easier to read and understand because the type
    names are more indicative of the actual underlying types. One warning for C/C++
    programmers: don’t get too excited and go off and define an `int` data type. Unfortunately,
    `int` is an x86-64 machine instruction (*interrupt*), and therefore this is a
    reserved word in MASM.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Ada、C/C++ 或 FORTRAN（或任何其他语言），你可以选择你更熟悉的类型名称。当然，这不会改变 x86-64 或 MASM 如何处理这些变量，但它确实让你可以创建更易读、易懂的程序，因为类型名称更能反映实际的底层类型。给
    C/C++ 程序员的一个警告：不要过于兴奋去定义一个 `int` 数据类型。不幸的是，`int` 是一个 x86-64 的机器指令（*中断*），因此这是 MASM
    中的保留字。
- en: 4.5 Type Coercion
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 类型强制转换
- en: Although MASM is fairly loose when it comes to type checking, MASM does ensure
    that you specify appropriate operand sizes to an instruction. For example, consider
    the following (incorrect) program in [Listing 4-1](#listing4-1).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 MASM 在类型检查方面相对宽松，但 MASM 确保你为指令指定了适当的操作数大小。例如，考虑以下（错误的）程序，在[列表 4-1](#listing4-1)中。
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 4-1: MASM type checking'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-1：MASM 类型检查
- en: 'MASM will generate errors for these four `mov` instructions because the operand
    sizes are incompatible. The `mov` instruction requires both operands to be the
    same size. The first instruction attempts to move a byte into EAX, the second
    instruction attempts to move a word into AL, and the third instruction attempts
    to move a double word into RAX. The fourth instruction attempts to move a qword
    into AX. Here’s the output from the compiler when you attempt to assemble this
    file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 会对这四条 `mov` 指令生成错误，因为操作数大小不兼容。`mov` 指令要求两个操作数的大小相同。第一条指令尝试将字节移动到 EAX，第二条指令尝试将字移动到
    AL，第三条指令尝试将双字移动到 RAX。第四条指令尝试将四字移动到 AX。当你尝试汇编这个文件时，编译器的输出如下：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'While this is a good feature in MASM,^([2](#c04-footnote-4)) sometimes it gets
    in the way. Consider the following code fragments:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是 MASM 中的一个好特性，^([2](#c04-footnote-4)) 但有时它会造成一些困扰。考虑以下代码片段：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, let’s assume that the programmer really wants to load the word
    starting at the address of `byte_values` into the AX register because they want
    to load AL with 0, and AH with 1, by using a single instruction (0 is held in
    the LO memory byte, and 1 is held in the HO memory byte). MASM will refuse, claiming
    a type mismatch error (because `byte_values` is a byte object and AX is a word
    object).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，假设程序员确实想要将从 `byte_values` 地址开始的字加载到 AX 寄存器中，因为他们想通过一条指令将 AL 置为 0，AH 置为
    1（0 存储在 LO 内存字节中，1 存储在 HO 内存字节中）。MASM 会拒绝此操作，报类型不匹配错误（因为 `byte_values` 是字节对象，而
    AX 是字对象）。
- en: The programmer could break this into two instructions, one to load AL with the
    byte at address `byte_values` and the other to load AH with the byte at address
    `byte_values[1]`. Unfortunately, this decomposition makes the program slightly
    less efficient (which was probably the reason for using the single `mov` instruction
    in the first place). To tell MASM that we know what we’re doing and we want to
    treat the `byte_values` variable as a `word` object, we can use type coercion.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员可以将其分解为两条指令，一条将地址 `byte_values` 处的字节加载到 AL 中，另一条将地址 `byte_values[1]` 处的字节加载到
    AH 中。不幸的是，这样的分解会使程序稍微低效一些（这可能正是最初使用单条 `mov` 指令的原因）。为了告诉 MASM 我们知道自己在做什么，并希望将 `byte_values`
    变量视为 `word` 对象，我们可以使用类型强制转换。
- en: '*Type coercion* is the process of telling MASM that you want to treat an object
    as an explicit type, regardless of its actual type.^([3](#c04-footnote-5)) To
    coerce the type of a variable, you use the following syntax:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型强制转换* 是告诉 MASM，你希望将一个对象当作一个显式类型来处理，而不管它的实际类型是什么。^([3](#c04-footnote-5))
    要强制转换变量的类型，你可以使用以下语法：'
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `new_type_name` item is the new type you wish to associate with the memory
    location specified by `address_expression`. You may use this coercion operator
    anywhere a memory address is legal. To correct the previous example, so MASM doesn’t
    complain about type mismatches, you would use the following statement:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`new_type_name` 项是你希望与 `address_expression` 指定的内存位置关联的新类型。你可以在任何合法的内存地址处使用此强制转换操作符。为了纠正之前的示例，以避免
    MASM 报告类型不匹配错误，你可以使用以下语句：'
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This instruction tells MASM to load the AX register with the word starting at
    address `byte_values` in memory. Assuming `byte_values` still contains its initial
    value, this instruction will load 0 into AL and 1 into AH.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令告诉 MASM 将 AX 寄存器加载为从内存地址 `byte_values` 开始的字。假设 `byte_values` 仍然包含其初始值，这条指令将把
    0 加载到 AL 中，把 1 加载到 AH 中。
- en: '[Table 4-2](#table4-2) lists all the MASM type-coercion operators.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-2](#table4-2) 列出了所有 MASM 类型强制转换操作符。'
- en: 'Table 4-2: MASM Type-Coercion Operators'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-2：MASM 类型强制转换操作符
- en: '| **Directive** | **Meaning** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **含义** |'
- en: '| --- | --- |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `byte ptr` | Byte (unsigned 8-bit) value |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `byte ptr` | 字节（无符号8位）值 |'
- en: '| `sbyte ptr` | Signed 8-bit integer value |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `sbyte ptr` | 有符号8位整数值 |'
- en: '| `word ptr` | Unsigned 16-bit (word) value |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `word ptr` | 无符号16位（字）值 |'
- en: '| `sword ptr` | Signed 16-bit integer value |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `sword ptr` | 有符号16位整数值 |'
- en: '| `dword ptr` | Unsigned 32-bit (double-word) value |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `dword ptr` | 无符号32位（双字）值 |'
- en: '| `sdword ptr` | Signed 32-bit integer value |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `sdword ptr` | 有符号32位整数值 |'
- en: '| `qword ptr` | Unsigned 64-bit (quad-word) value |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `qword ptr` | 无符号64位（四字）值 |'
- en: '| `sqword ptr` | Signed 64-bit integer value |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `sqword ptr` | 有符号64位整数值 |'
- en: '| `tbyte ptr` | Unsigned 80-bit (10-byte) value |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `tbyte ptr` | 无符号80位（10字节）值 |'
- en: '| `oword ptr` | 128-bit (octal-word) value |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `oword ptr` | 128位（八字）值 |'
- en: '| `xmmword ptr` | 128-bit (octal-word) value—same as `oword ptr` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `xmmword ptr` | 128位（八字）值——与 `oword ptr` 相同 |'
- en: '| `ymmword ptr` | 256-bit value (for use with AVX YMM registers) |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `ymmword ptr` | 256位值（用于AVX YMM寄存器） |'
- en: '| `zmmword ptr` | 512-bit value (for use with AVX-512 ZMM registers) |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `zmmword ptr` | 512位值（用于AVX-512 ZMM寄存器） |'
- en: '| `real4 ptr` | Single-precision (32-bit) floating-point value |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `real4 ptr` | 单精度（32位）浮动点数值 |'
- en: '| `real8 ptr` | Double-precision (64-bit) floating-point value |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `real8 ptr` | 双精度（64位）浮动点数值 |'
- en: '| `real10 ptr` | Extended-precision (80-bit) floating-point value |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `real10 ptr` | 扩展精度（80位）浮动点数值 |'
- en: 'Type coercion is necessary when you specify an anonymous variable as the operand
    to an instruction that directly modifies memory (for example, `neg`, `shl`, `not`,
    and so on). Consider the following statement:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个匿名变量指定为直接修改内存的指令操作数时（例如，`neg`、`shl`、`not`等），就需要使用类型强制。考虑以下语句：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'MASM will generate an error on this instruction because it cannot determine
    the size of the memory operand. The instruction does not supply sufficient information
    to determine whether the program should invert the bits in the byte pointed at
    by RBX, the word pointed at by RBX, the double word pointed at by RBX, or the
    quad word pointed at by RBX. You must use type coercion to explicitly specify
    the size of anonymous references with these types of instructions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: MASM会在这个指令上生成错误，因为它无法确定内存操作数的大小。该指令没有提供足够的信息来判断程序应该对RBX指向的字节、RBX指向的字（word）、RBX指向的双字（double
    word）还是RBX指向的四字（quad word）进行位反转。你必须使用类型强制运算符来明确指定这些类型指令中的匿名引用的大小：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Consider the following statement (where `byteVar` is an 8-bit variable):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下语句（其中`byteVar`是一个8位变量）：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Without the type-coercion operator, MASM complains about this instruction because
    it attempts to store a 32-bit register in an 8-bit memory location. Beginning
    programmers, wanting their programs to assemble, may take a shortcut and use the
    type-coercion operator, as shown in this instruction; this certainly quiets the
    assembler—it will no longer complain about a type mismatch—so the beginning programmers
    are happy.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有类型强制运算符，MASM会抱怨这个指令，因为它试图将一个32位寄存器存储到一个8位内存位置。初学者可能希望他们的程序能够汇编成功，于是可能会走捷径，使用类型强制运算符，如这个指令所示；这当然能让汇编器安静下来——它不再抱怨类型不匹配——因此初学者会很高兴。
- en: However, the program is still incorrect; the only difference is that MASM no
    longer warns you about your error. The type-coercion operator does not fix the
    problem of attempting to store a 32-bit value into an 8-bit memory location—it
    simply allows the instruction to store a 32-bit value *starting at the address
    specified by the 8-bit variable*. The program still stores 4 bytes, overwriting
    the 3 bytes following `byteVar` in memory.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，程序仍然是错误的；唯一的区别是 MASM 不再警告你关于错误的消息。类型强制运算符并没有解决尝试将一个32位的值存储到一个8位内存位置的问题——它只是允许指令将一个32位的值*从8位变量所指定的地址开始*存储。程序仍然存储4个字节，覆盖了内存中`byteVar`后面的3个字节。
- en: 'This often produces unexpected results, including the phantom modification
    of variables in your program.^([4](#c04-footnote-6)) Another, rarer possibility
    is for the program to abort with a general protection fault, if the 3 bytes following
    `byteVar` are not allocated in real memory or if those bytes just happen to fall
    in a read-only section of memory. The important thing to remember about the type-coercion
    operator is this: if you cannot exactly state the effect this operator has, don’t
    use it.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常会产生意外的结果，包括程序中变量的虚假修改。^([4](#c04-footnote-6)) 另一个较少见的情况是，当`byteVar`后面的3个字节没有分配到实际内存中，或这些字节恰好位于只读内存区时，程序可能会因一般保护错误而中止。关于类型强制运算符，重要的是要记住这一点：如果你无法准确描述这个运算符的作用，就不要使用它。
- en: Also keep in mind that the type-coercion operator does not perform any translation
    of the data in memory. It simply tells the assembler to treat the bits in memory
    as a different type. It will not automatically extend an 8-bit value to 32 bits,
    nor will it convert an integer to a floating-point value. It simply tells the
    compiler to treat the bit pattern of the memory operand as a different type.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 同时要记住，类型强制运算符并不会对内存中的数据进行任何转换。它仅仅告诉汇编器将内存中的位视为另一种类型。它不会自动将8位值扩展为32位，也不会将整数转换为浮动点数值。它只是告诉编译器将内存操作数的位模式视为不同类型。
- en: 4.6 Pointer Data Types
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 指针数据类型
- en: You’ve probably experienced pointers firsthand in the Pascal, C, or Ada programming
    languages, and you’re probably getting worried right now. Almost everyone has
    a bad experience when they first encounter pointers in a high-level language.
    Well, fear not! Pointers are actually easier to deal with in assembly language
    than in high-level languages.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在Pascal、C或Ada编程语言中亲自体验过指针，现在你可能开始担心了。当你第一次在高级语言中遇到指针时，几乎每个人都会有不好的经历。放心吧！实际上，在汇编语言中，指针比在高级语言中更容易处理。
- en: Besides, most of the problems you had with pointers probably had nothing to
    do with pointers but rather with the linked list and tree data structures you
    were trying to implement with them. Pointers, on the other hand, have many uses
    in assembly language that have nothing to do with linked lists, trees, and other
    scary data structures. Indeed, simple data structures like arrays and records
    often involve the use of pointers. So, if you have some deep-rooted fear about
    pointers, forget everything you know about them. You’re going to learn how great
    pointers really are.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你在使用指针时遇到的大多数问题可能与指针本身无关，而是与试图用指针实现的链表和树等数据结构有关。另一方面，指针在汇编语言中的用途远不止与链表、树等可怕的数据结构相关。实际上，像数组和记录这样的简单数据结构，往往也涉及到指针的使用。所以，如果你对指针有深深的恐惧感，那就忘掉你对它们的所有认知吧。你将会学到指针其实是多么强大。
- en: Probably the best place to start is with the definition of a pointer. A *pointer*
    is a memory location whose value is the address of another memory location. Unfortunately,
    high-level languages like C/C++ tend to hide the simplicity of pointers behind
    a wall of abstraction. This added complexity (which exists for good reason, by
    the way) tends to frighten programmers because *they don’t understand what’s going
    on*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的起点可能是指针的定义。*指针*是一个内存位置，其值是另一个内存位置的地址。不幸的是，像C/C++这样的高级语言往往把指针的简单性隐藏在一层抽象的墙后面。这个额外的复杂性（顺便说一下，这是有充分理由的）往往让程序员感到害怕，因为*他们不理解发生了什么*。
- en: 'To illuminate what’s really happening, consider the following array declaration
    in Pascal:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了揭示发生了什么，考虑以下Pascal中的数组声明：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Even if you don’t know Pascal, the concept here is pretty easy to understand.
    `M` is an array with 1024 integers in it, indexed from `M[0]` to `M[1023]`. Each
    one of these array elements can hold an integer value that is independent of all
    the others. In other words, this array gives you 1024 different integer variables,
    each of which you refer to by number (the array index) rather than by name.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不懂Pascal，这里的概念也很容易理解。`M`是一个包含1024个整数的数组，索引范围从`M[0]`到`M[1023]`。这些数组元素中的每一个都可以保存一个独立的整数值，互不干扰。换句话说，这个数组提供了1024个不同的整数变量，每个变量通过数字（数组索引）而非名称来引用。
- en: 'If you encounter a program that has the statement `M[0] := 100;`, you probably
    won’t have to think at all about what is happening with this statement. It is
    storing the value `100` into the first element of the array `M`. Now consider
    the following two statements:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到包含`M[0] := 100;`的程序，你可能根本不需要思考这条语句到底在做什么。它正在把值`100`存入数组`M`的第一个元素。现在考虑以下两条语句：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should agree, without too much hesitation, that these two statements perform
    the same operation as `M[0] := 100;`. Indeed, you’re probably willing to agree
    that you can use any integer expression in the range 0 to 1023 as an index into
    this array. The following statements still perform the same operation as our single
    assignment to index 0:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该毫不犹豫地同意，这两条语句执行的操作与`M[0] := 100;`是相同的。事实上，你可能会同意，你可以使用任何在0到1023范围内的整数表达式作为该数组的索引。以下语句依然执行与我们对索引0的单一赋值相同的操作：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '“Okay, so what’s the point?” you’re probably thinking. “Anything that produces
    an integer in the range 0 to 1023 is legal. So what?” Okay, how about the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: “好吧，那有什么意义？”你可能在想。“任何能产生0到1023范围内整数的东西都是合法的，那又怎样？”好吧，考虑以下内容：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Whoa! Now that takes a few moments to digest. However, if you take it slowly,
    it makes sense, and you’ll discover that these two instructions perform the same
    operation you’ve been doing all along. The first statement stores `0` into array
    element `M[1]`. The second statement fetches the value of `M[1]`, which is an
    integer so you can use it as an array index into `M`, and uses that value (`0`)
    to control where it stores the value `100`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！现在需要一点时间来消化。不过，如果你慢慢理解，这就能明白了，你会发现这两条指令执行的是你一直在做的相同操作。第一条语句将`0`存储到数组元素`M[1]`中。第二条语句获取`M[1]`的值，这个值是一个整数，你可以将它用作数组`M`的索引，并使用该值（`0`）来控制它存储值`100`的位置。
- en: 'If you’re willing to accept this as reasonable—perhaps bizarre, but usable
    nonetheless—then you’ll have no problems with pointers. Because `M[1]` is a pointer!
    Well, not really, but if you were to change `M` to *memory* and treat this array
    as all of memory, this is the exact definition of a pointer: a memory location
    whose value is the address (or index, if you prefer) of another memory location.
    Pointers are easy to declare and use in an assembly language program. You don’t
    even have to worry about array indices or anything like that.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意接受这一点作为合理的——或许有点奇怪，但仍然可以使用——那么你将不会对指针产生任何问题。因为`M[1]`是一个指针！嗯，严格来说不是，但如果你把`M`改为*内存*并将这个数组视为整个内存，那么这就是指针的精确定义：一个其值是另一个内存位置的地址（或者如果你愿意说是索引）的内存位置。在汇编语言程序中，指针的声明和使用非常简单。你甚至不需要担心数组索引之类的东西。
- en: 4.6.1 Using Pointers in Assembly Language
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.1 在汇编语言中使用指针
- en: 'A MASM pointer is a 64-bit value that may contain the address of another variable.
    If you have a dword variable `p` that contains 1000_0000h, then `p` “points” at
    memory location 1000_0000h. To access the dword that `p` points at, you could
    use code like the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个MASM指针是一个64位值，可以包含另一个变量的地址。如果你有一个dword变量`p`，它包含1000_0000h，那么`p`“指向”内存位置1000_0000h。要访问`p`指向的dword，你可以使用如下代码：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By loading the value of `p` into RBX, this code loads the value 1000_0000h into
    RBX (assuming `p` contains 1000_0000h). The second instruction loads the RAX register
    with the qword starting at the location whose offset appears in RBX. Because RBX
    now contains 1000_0000h, this will load RAX from locations 1000_0000h through
    1000_0007h.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`p`的值加载到RBX中，这段代码将值1000_0000h加载到RBX中（假设`p`包含1000_0000h）。第二条指令将RAX寄存器加载为从RBX中偏移量所在位置开始的qword。因为RBX现在包含1000_0000h，所以这将从地址1000_0000h到1000_0007h加载RAX。
- en: 'Why not just load RAX directly from location 1000_0000h by using an instruction
    like `mov rax, mem` (assuming `mem` is at address 1000_0000h)? Well, there are
    several reasons. But the primary reason is that this `mov` instruction always
    loads RAX from location `mem`. You cannot change the address from where it loads
    RAX. The former instructions, however, always load RAX from the location where
    `p` is pointing. This is easy to change under program control. In fact, the two
    instructions `mov rax, offset mem2` and `mov p, rax` will cause those previous
    two instructions to load RAX from `mem2` the next time they execute. Consider
    the following code fragment:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接使用类似`mov rax, mem`的指令从地址1000_0000h加载RAX呢（假设`mem`在地址1000_0000h）？嗯，有几个原因。但主要原因是，这个`mov`指令总是从`mem`所在的位置加载RAX。你不能改变它加载RAX的地址。然而，前面的指令总是从`p`指向的位置加载RAX。这在程序控制下很容易改变。事实上，两个指令`mov
    rax, offset mem2`和`mov p, rax`会导致这两个指令在下一次执行时从`mem2`加载RAX。考虑以下代码片段：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This short example demonstrates two execution paths through the program. The
    first path loads the variable `p` with the address of the variable `i`. The second
    path through the code loads `p` with the address of the variable `j`. Both execution
    paths converge on the last two `mov` instructions that load RAX with `i` or `j`
    depending on which execution path was taken. In many respects, this is like a
    parameter to a procedure in a high-level language like Swift. Executing the same
    instructions accesses different variables depending on whose address (`i` or `j`)
    winds up in `p`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例展示了程序中的两条执行路径。第一条路径将变量`p`加载为变量`i`的地址。第二条路径将`p`加载为变量`j`的地址。两条执行路径最终会汇聚到最后两个`mov`指令，这些指令根据所采取的执行路径将RAX加载为`i`或`j`。在许多方面，这类似于高级语言（如Swift）中的过程参数。执行相同的指令会根据`p`中存储的地址（`i`或`j`）访问不同的变量。
- en: 4.6.2 Declaring Pointers in MASM
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.2 在MASM中声明指针
- en: 'Because pointers are 64 bits long, you could use the `qword` type to allocate
    storage for your pointers. However, rather than use qword declarations, an arguably
    better approach is to use `typedef` to create a pointer type:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于指针长度为 64 位，你可以使用 `qword` 类型为指针分配存储空间。然而，与其使用 qword 声明，一个更好的方法是使用 `typedef`
    创建一个指针类型：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This example demonstrates that it is possible to initialize as well as declare
    pointer variables in MASM. Note that you may specify addresses of static variables
    (`.data`, `.const`, and `.data?` objects) in the operand field of a `qword/pointer`
    directive, so you can initialize only pointer variables with the addresses of
    static objects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了在 MASM 中初始化以及声明指针变量是可能的。请注意，你可以在 `qword/pointer` 指令的操作数字段中指定静态变量（`.data`、`.const`
    和 `.data?` 对象）的地址，因此你只能用静态对象的地址来初始化指针变量。
- en: 4.6.3 Pointer Constants and Pointer Constant Expressions
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.3 指针常量与指针常量表达式
- en: MASM allows very simple constant expressions wherever a pointer constant is
    legal. Pointer constant expressions take one of the three following forms:^([5](#c04-footnote-7))
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 允许在指针常量合法的任何地方使用非常简单的常量表达式。指针常量表达式有以下三种形式之一：^([5](#c04-footnote-7))
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `PureConstantExpression` term is a numeric constant expression that does
    not involve any pointer constants. This type of expression produces a memory address
    that is the specified number of bytes before or after (`-` or `+`, respectively)
    the `StaticVarName` variable in memory. Note that the first two forms shown here
    are semantically equivalent; both return a pointer constant whose address is the
    sum of the static variable and the constant expression.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`PureConstantExpression` 术语指的是不涉及任何指针常量的数字常量表达式。这种类型的表达式产生一个内存地址，该地址是 `StaticVarName`
    变量在内存中指定字节数之前或之后（分别是 `-` 或 `+`）的地址。请注意，这里显示的前两种形式在语义上是等效的；两者都返回一个指针常量，其地址是静态变量和常量表达式之和。'
- en: Because you can create pointer constant expressions, it should come as no surprise
    to discover that MASM lets you define manifest pointer constants by using equates.
    The program in [Listing 4-2](#listing4-2) demonstrates how you can do this.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以创建指针常量表达式，发现 MASM 允许通过使用等式定义显式指针常量也就不足为奇了。[列表 4-2](#listing4-2) 中的程序演示了你如何做到这一点。
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 4-2: Pointer constant expressions in a MASM program'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-2：MASM 程序中的指针常量表达式
- en: 'Here’s the assembly and execution of this code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此代码的汇编和执行：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that the address printed may vary on different machines and different versions
    of Windows.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，打印的地址在不同的机器和不同版本的 Windows 上可能会有所不同。
- en: 4.6.4 Pointer Variables and Dynamic Memory Allocation
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.4 指针变量与动态内存分配
- en: Pointer variables are the perfect place to store the return result from the
    C Standard Library `malloc()` function. This function returns the address of the
    storage it allocates in the RAX register; therefore, you can store the address
    directly into a pointer variable with a single `mov` instruction immediately after
    a call to `malloc()`. [Listing 4-3](#listing4-3) demonstrates calls to the C Standard
    Library `malloc()` and `free()` functions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 指针变量是存储 C 标准库 `malloc()` 函数返回结果的完美地方。该函数返回其在 RAX 寄存器中分配的存储地址；因此，你可以在调用 `malloc()`
    之后，直接用一个 `mov` 指令将地址存入指针变量。[列表 4-3](#listing4-3) 演示了调用 C 标准库的 `malloc()` 和 `free()`
    函数。
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 4-3: Demonstration of `malloc()` and `free()` calls'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-3：演示 `malloc()` 和 `free()` 调用
- en: Here’s the output I obtained when building and running this program. Note that
    the addresses that `malloc()` returns may vary by system, by operating system
    version, and for other reasons. Therefore, you will likely get different numbers
    than I obtained on my system.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在构建并运行此程序时得到的输出。请注意，`malloc()` 返回的地址可能会因系统、操作系统版本等不同而有所不同。因此，你很可能得到与我在系统上获得的数字不同的结果。
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 4.6.5 Common Pointer Problems
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.5 常见的指针问题
- en: 'Programmers encounter five common problems when using pointers. Some of these
    errors will cause your programs to immediately stop with a diagnostic message;
    other problems are subtler, yielding incorrect results without otherwise reporting
    an error or simply affecting the performance of your program without displaying
    an error. These five problems are as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在使用指针时会遇到五个常见问题。这些错误中的一些会导致程序立即停止并显示诊断信息；其他问题则较为微妙，可能会导致程序产生不正确的结果而不报告错误，或者仅仅影响程序的性能而没有显示错误。这五个问题如下：
- en: Using an uninitialized pointer
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用未初始化的指针
- en: Using a pointer that contains an illegal value (for example, NULL)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用包含非法值的指针（例如 NULL）
- en: Continuing to use `malloc()`’d storage after that storage has been freed
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在已经释放的存储空间上继续使用 `malloc()` 分配的存储
- en: Failing to `free()` storage once the program is finished using it
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序完成后未能`free()`存储空间
- en: Accessing indirect data by using the wrong data type
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用错误的数据类型访问间接数据
- en: The first problem is using a pointer variable before you have assigned a valid
    memory address to the pointer. Beginning programmers often don’t realize that
    declaring a pointer variable reserves storage only for the pointer itself; it
    does not reserve storage for the data that the pointer references. The short program
    in [Listing 4-4](#listing4-4) demonstrates this problem (don’t try to compile
    and run this program; it will crash).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是使用指针变量之前没有为指针分配有效的内存地址。初学者通常没有意识到，声明一个指针变量仅仅是为指针本身保留存储空间；它并没有为指针引用的数据保留存储空间。列表
    [4-4](#listing4-4) 中的简短程序演示了这个问题（不要尝试编译和运行这个程序，它会崩溃）。
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 4-4: Uninitialized pointer demonstration'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-4：未初始化指针演示
- en: Although variables you declare in the `.data` section are, technically, initialized,
    static initialization still doesn’t initialize the pointer in this program with
    a valid address (it initializes the pointer with `0`, which is NULL).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你在 `.data` 区段中声明的变量在技术上是初始化过的，但静态初始化仍然没有在该程序中为指针初始化有效地址（它将指针初始化为 `0`，即 NULL）。
- en: Of course, there is no such thing as a truly uninitialized variable on the x86-64\.
    What you really have are variables that you’ve explicitly given an initial value
    to and variables that just happen to inherit whatever bit pattern was in memory
    when storage for the variable was allocated. Much of the time, these garbage bit
    patterns lying around in memory don’t correspond to a valid memory address. Attempting
    to *dereference* such a pointer (that is, access the data in memory at which it
    points) typically raises a *memory access violation* exception.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在 x86-64 上并没有真正意义上的未初始化变量。你真正拥有的是那些你明确赋予初始值的变量，以及那些恰好继承了分配给变量的存储空间时内存中所包含的任何位模式的变量。很多时候，这些在内存中闲置的垃圾位模式并不对应一个有效的内存地址。试图*解除引用*这样的指针（也就是访问它指向的内存中的数据）通常会引发*内存访问违例*异常。
- en: Sometimes, however, those random bits in memory just happen to correspond to
    a valid memory location you can access. In this situation, the CPU will access
    the specified memory location without aborting the program. Although to a naive
    programmer this situation may seem preferable to stopping the program, in reality
    this is far worse because your defective program continues to run without alerting
    you to the problem. If you store data through an uninitialized pointer, you may
    very well overwrite the values of other important variables in memory. This defect
    can produce some very difficult-to-locate problems in your program.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时，这些内存中的随机位恰巧对应一个你可以访问的有效内存位置。在这种情况下，CPU 会访问指定的内存位置，而不会中止程序。虽然对一个初学者来说，这种情况可能看起来比停止程序更可取，但实际上这更糟糕，因为你的有缺陷的程序会继续运行而没有提示你出现问题。如果通过未初始化的指针存储数据，你很可能会覆盖内存中其他重要变量的值。这个缺陷可能会在程序中产生一些非常难以定位的问题。
- en: The second problem programmers have with pointers is storing invalid address
    values into a pointer. The first problem is actually a special case of this second
    problem (with garbage bits in memory supplying the invalid address rather than
    you producing it via a miscalculation). The effects are the same; if you attempt
    to dereference a pointer containing an invalid address, you either will get a
    memory access violation exception or will access an unexpected memory location.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员使用指针时的第二个问题是将无效的地址值存储到指针中。第一个问题实际上是第二个问题的一个特殊情况（内存中的垃圾位提供了无效地址，而不是你通过计算错误产生的）。后果是相同的；如果你尝试解除引用包含无效地址的指针，要么会得到内存访问违例异常，要么会访问一个意外的内存位置。
- en: 'The third problem listed is also known as the *dangling pointer problem*. To
    understand this problem, consider the following code fragment:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的第三个问题也被称为*悬空指针问题*。要理解这个问题，请考虑以下代码片段：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this example, the program allocates 256 bytes of storage and saves the address
    of that storage in the `ptrVar` variable. Then the code uses this block of 256
    bytes for a while and frees the storage, returning it to the system for other
    uses. Note that calling `free()` does not change the value of `ptrVar` in any
    way; `ptrVar` still points at the block of memory allocated by `malloc()` earlier.
    Indeed, `free()` does not change any data in this block, so upon return from `free()`,
    `ptrVar` still points at the data stored into the block by this code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，程序分配了256字节的存储空间，并将该存储空间的地址保存在`ptrVar`变量中。然后，代码使用这块256字节的存储空间一段时间，并释放了该存储空间，将其归还给系统供其他用途。请注意，调用`free()`不会以任何方式改变`ptrVar`的值；`ptrVar`仍然指向之前由`malloc()`分配的内存块。事实上，`free()`并不会改变该内存块中的任何数据，因此在从`free()`返回后，`ptrVar`仍然指向代码存储到该块中的数据。
- en: However, note that the call to `free()` tells the system that the program no
    longer needs this 256-byte block of memory and the system can use this region
    of memory for other purposes. The `free()` function cannot enforce the fact that
    you will never access this data again; you are simply promising that you won’t.
    Of course, the preceding code fragment breaks this promise; as you can see in
    the last two instructions, the program fetches the value in `ptrVar` and accesses
    the data it points at in memory.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，调用`free()`告诉系统程序不再需要这块256字节的内存块，系统可以将该内存区域用于其他用途。`free()`函数不能强制确保你永远不会再次访问这些数据；你只是承诺你不会。当然，前面的代码片段违反了这个承诺；正如你在最后两条指令中看到的，程序获取了`ptrVar`中的值，并访问了它在内存中指向的数据。
- en: 'The biggest problem with dangling pointers is that you can get away with using
    them a good part of the time. As long as the system doesn’t reuse the storage
    you’ve freed, using a dangling pointer produces no ill effects in your program.
    However, with each new call to `malloc()`, the system may decide to reuse the
    memory released by that previous call to `free()`. When this happens, any attempt
    to dereference the dangling pointer may produce unintended consequences. The problems
    range from reading data that has been overwritten (by the new, legal use of the
    data storage), to overwriting the new data, to (the worst case) overwriting system
    heap management pointers (doing so will probably cause your program to crash).
    The solution is clear: *never use a pointer value once you free the storage associated
    with that pointer*.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 悬空指针最大的问题在于，你有很大一部分时间可以在没有问题的情况下使用它们。只要系统没有重新使用你已经释放的存储空间，使用悬空指针不会对程序产生不良影响。然而，随着每次调用`malloc()`，系统可能决定重新使用先前调用`free()`释放的内存。当发生这种情况时，任何尝试取消引用悬空指针的操作可能会产生意想不到的后果。问题可能从读取已经被覆盖的数据（通过数据存储的新合法使用）开始，到覆盖新数据，再到（最糟糕的情况）覆盖系统堆管理指针（这样做可能会导致程序崩溃）。解决方案很明确：*一旦你释放了与指针相关联的存储空间，就永远不要再使用该指针的值*。
- en: 'Of all the problems, the fourth (failing to free allocated storage) will probably
    have the least impact on the proper operation of your program. The following code
    fragment demonstrates this problem:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 所有问题中，第四个问题（未释放分配的存储）可能对程序的正常运行影响最小。以下代码片段演示了这个问题：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this example, the program allocates 256 bytes of storage and references this
    storage by using the `ptrVar` variable. At some later time, the program allocates
    another block of bytes and overwrites the value in `ptrVar` with the address of
    this new block. Note that the former value in `ptrVar` is lost. Because the program
    no longer has this address value, there is no way to call `free()` to return the
    storage for later use.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，程序分配了256字节的存储空间，并通过使用`ptrVar`变量来引用这块存储。稍后，程序分配了另一块字节，并将`ptrVar`中的值覆盖为该新块的地址。请注意，`ptrVar`中之前的值丢失了。由于程序不再拥有这个地址值，因此无法调用`free()`来将存储空间返回给系统供以后使用。
- en: As a result, this memory is no longer available to your program. While making
    256 bytes of memory inaccessible to your program may not seem like a big deal,
    imagine that this code is in a loop that repeats over and over again. With each
    execution of the loop, the program loses another 256 bytes of memory. After a
    sufficient number of loop iterations, the program will exhaust the memory available
    on the heap. This problem is often called a *memory leak* because the effect is
    the same as though the memory bits were leaking out of your computer (yielding
    less and less available storage) during program execution.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，这段内存不再对你的程序可用。虽然让 256 字节的内存对程序不可用似乎不是什么大问题，但如果这段代码位于一个不断重复的循环中，就不一样了。每次执行循环时，程序会丧失另外
    256 字节的内存。经过足够次数的循环迭代后，程序将耗尽堆上的可用内存。这个问题通常被称为*内存泄漏*，因为它的效果就像是内存的位在程序执行过程中“泄漏”出你的计算机（导致可用存储越来越少）。
- en: 'Memory leaks are far less damaging than dangling pointers. Indeed, memory leaks
    create only two problems: the danger of running out of heap space (which, ultimately,
    may cause the program to abort, though this is rare) and performance problems
    due to virtual memory page swapping. Nevertheless, you should get in the habit
    of always freeing all storage once you have finished using it. When your program
    quits, the operating system reclaims all storage, including the data lost via
    memory leaks. Therefore, memory lost via a leak is lost only to your program,
    not the whole system.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏远比悬空指针危害小。实际上，内存泄漏只会带来两个问题：堆空间耗尽的风险（最终可能导致程序中止，尽管这种情况很少发生）以及由于虚拟内存页面交换引起的性能问题。尽管如此，你应该养成在使用完所有存储后立即释放它的习惯。当程序退出时，操作系统会回收所有存储，包括因内存泄漏而丢失的数据。因此，通过内存泄漏丢失的内存只会对程序造成影响，而不会影响整个系统。
- en: The last problem with pointers is the lack of type-safe access. This can occur
    because MASM cannot and does not enforce pointer type checking. For example, consider
    the program in [Listing 4-5](#listing4-5).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的最后一个问题是缺乏类型安全的访问。这种情况可能发生，因为 MASM 无法也不会强制执行指针类型检查。例如，考虑 [Listing 4-5](#listing4-5)
    中的程序。
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 4-5: Type-unsafe pointer access example'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-5：类型不安全的指针访问示例
- en: 'Here are the commands to build and run this sample program:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是构建和运行此示例程序的命令：
- en: '[PRE50]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The program in [Listing 4-5](#listing4-5) reads data from the user as character
    values and then displays the data as double-word hexadecimal values. While a powerful
    feature of assembly language is that it lets you ignore data types at will and
    automatically coerce the data without any effort, this power is a two-edged sword.
    If you make a mistake and access indirect data by using the wrong data type, MASM
    and the x86-64 may not catch the mistake, and your program may produce inaccurate
    results. Therefore, when using pointers and indirection in your programs, you
    need to take care that you use the data consistently with respect to data type.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 4-5](#listing4-5) 中的程序将用户输入的数据读取为字符值，然后以双字节的十六进制值显示数据。汇编语言的一个强大功能是，它允许你随意忽略数据类型，并且无需任何努力自动强制数据类型。然而，这种功能也有双刃剑的一面。如果你犯错，使用错误的数据类型访问间接数据，MASM
    和 x86-64 可能不会捕捉到这个错误，导致程序产生不准确的结果。因此，在程序中使用指针和间接访问时，需要确保数据在使用时与数据类型保持一致。'
- en: 'This demonstration program has one fundamental flaw that could create a problem
    for you: when reading the last two characters of the input buffer, the program
    accesses data beyond the characters input by the user. If the user inputs 255
    characters (plus the zero-terminating byte that `readLine()` appends), this program
    will access data beyond the end of the buffer allocated by `malloc()`. In theory,
    this could cause the program to crash. This is yet another problem that can occur
    when accessing data by using the wrong type via pointers.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示程序有一个基本的缺陷，可能会为你带来问题：当读取输入缓冲区的最后两个字符时，程序会访问超出用户输入字符的数据。如果用户输入了 255 个字符（加上
    `readLine()` 附加的零终止字节），程序将访问超出 `malloc()` 分配的缓冲区末尾的数据。从理论上讲，这可能导致程序崩溃。这又是一个因为使用错误的类型通过指针访问数据时可能出现的问题。
- en: 4.7 Composite Data Types
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 组合数据类型
- en: '*Composite data types*, also known as *aggregate data types*, are those that
    are built up from other (generally scalar) data types. The next sections cover
    several of the more important composite data types—character strings, arrays,
    multidimensional arrays, records/structs, and unions. A string is a good example
    of a composite data type; it is a data structure built up from a sequence of individual
    characters and other data.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*复合数据类型*，也称为*聚合数据类型*，是由其他（通常是标量）数据类型构建起来的数据类型。接下来的几节将涵盖几个较重要的复合数据类型 - 字符串，数组，多维数组，记录/结构体和联合体。字符串是复合数据类型的一个很好的例子；它是从一系列单个字符和其他数据构建起来的数据结构。'
- en: 4.8 Character Strings
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 字符串
- en: After integer values, *character strings* are probably the most common data
    type that modern programs use. The x86-64 does support a handful of string instructions,
    but these instructions are really intended for block memory operations, not a
    specific implementation of a character string. Therefore, this section will provide
    a couple of definitions of character strings and discuss how to process them.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在整数值之后，*字符串* 可能是现代程序中使用最普遍的数据类型之一。x86-64确实支持少量字符串指令，但这些指令实际上是用于块内存操作，而不是特定实现的字符字符串。因此，本节将提供几个字符串的定义，并讨论如何处理它们。
- en: 'In general, a character string is a sequence of ASCII characters that possesses
    two main attributes: a *length* and *character data*. Different languages use
    different data structures to represent strings. Assembly language (at least, sans
    any library routines) doesn’t really care how you implement strings. All you need
    to do is create a sequence of machine instructions to process the string data
    in whatever format the strings take.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，字符串是一系列ASCII字符，具有两个主要特点：*长度* 和 *字符数据*。不同的语言使用不同的数据结构来表示字符串。汇编语言（至少是没有任何库例程的情况下）并不在乎如何实现字符串。您只需要创建一系列机器指令来处理以任何格式获取的字符串数据。
- en: 4.8.1 Zero-Terminated Strings
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8.1 零终止字符串
- en: 'Without question, *zero-terminated strings* are the most common string representation
    in use today because this is the native string format for C, C++, and other languages.
    A zero-terminated string consists of a sequence of zero or more ASCII characters
    ending with a 0 byte. For example, in C/C++, the string `"abc"` requires 4 bytes:
    the three characters `a`, `b`, and `c` followed by a `0`. As you’ll soon see,
    MASM character strings are upward compatible with zero-terminated strings, but
    in the meantime, you should note that creating zero-terminated strings in MASM
    is easy. The easiest place to do this is in the `.data` section by using code
    like the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，*零终止字符串* 是当今使用最广泛的字符串表示，因为这是C、C++和其他语言的本地字符串格式。零终止字符串由以0字节结尾的零个或多个ASCII字符序列组成。例如，在C/C++中，字符串`"abc"`需要4个字节：三个字符`a`、`b`和`c`，后跟一个`0`。正如您很快就会看到的，MASM字符字符串与零终止字符串向上兼容，但同时，您应注意，在MASM中创建零终止字符串非常简单。在`.data`段中执行此操作的最简单方法是使用以下类似的代码：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Whenever a character string appears in the `byte` directive as it does here,
    MASM emits each character in the string to successive memory locations. The zero
    value at the end of the string terminates this string.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 每当字符字符串出现在`byte`指令中，就像在这里一样，MASM将每个字符连续地发射到后续的内存位置。字符串末尾的零值终止了该字符串。
- en: 'Zero-terminated strings have two principal attributes: they are simple to implement,
    and the strings can be any length. On the other hand, zero-terminated strings
    have a few drawbacks. First, though not usually important, zero-terminated strings
    cannot contain the NUL character (whose ASCII code is 0). Generally, this isn’t
    a problem, but it does create havoc once in a while. The second problem with zero-terminated
    strings is that many operations on them are somewhat inefficient. For example,
    to compute the length of a zero-terminated string, you must scan the entire string
    looking for that 0 byte (counting characters up to the 0). The following program
    fragment demonstrates how to compute the length of the preceding string:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 零终止字符串具有两个主要特点：它们易于实现，字符串可以是任意长度。另一方面，零终止字符串有一些缺点。首先，虽然通常不重要，但零终止字符串不能包含NUL字符（其ASCII代码为0）。一般情况下，这不是问题，但偶尔会造成混乱。零终止字符串的第二个问题是，对它们的许多操作有些效率低下。例如，要计算零终止字符串的长度，必须扫描整个字符串以查找该0字节（计算字符直到0为止）。以下程序片段演示了如何计算前述字符串的长度：
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see from this code, the time it takes to compute the length of the
    string is proportional to the length of the string; as the string gets longer,
    it takes longer to compute its length.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码可以看出，计算字符串长度所需的时间与字符串的长度成正比；随着字符串变长，计算其长度所需的时间也会增加。
- en: 4.8.2 Length-Prefixed Strings
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8.2 长度前缀字符串
- en: 'The *length-prefixed string* format overcomes some of the problems with zero-terminated
    strings. Length-prefixed strings are common in languages like Pascal; they generally
    consist of a length byte followed by zero or more character values. The first
    byte specifies the string length, and the following bytes (up to the specified
    length) are the character data. In a length-prefixed scheme, the string `"abc"`
    would consist of the 4 bytes: `03` (the string length) followed by `a`, `b`, and
    `c`. You can create length-prefixed strings in MASM by using code like the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*长度前缀字符串* 格式克服了零终止字符串的一些问题。长度前缀字符串在像 Pascal 这样的语言中很常见；它们通常由一个长度字节和零个或多个字符值组成。第一个字节指定字符串的长度，随后的字节（最多指定长度个字节）是字符数据。在长度前缀方案中，字符串
    `"abc"` 将由 4 个字节组成：`03`（字符串长度）后跟 `a`、`b` 和 `c`。你可以通过以下代码在 MASM 中创建长度前缀字符串：'
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Counting the characters ahead of time and inserting them into the byte statement,
    as was done here, may seem like a major pain. Fortunately, there are ways to have
    MASM automatically compute the string length for you.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 提前计算字符数并将其插入到字节语句中，如此处所示，可能会看起来像是一个大麻烦。幸运的是，有一些方法可以让 MASM 自动为你计算字符串长度。
- en: Length-prefixed strings solve the two major problems associated with zero-terminated
    strings. It is possible to include the NUL character in length-prefixed strings,
    and those operations on zero-terminated strings that are relatively inefficient
    (for example, string length) are more efficient when using length-prefixed strings.
    However, length-prefixed strings have their own drawbacks. The principal drawback
    is that they are limited to a maximum of 255 characters in length (assuming a
    1-byte length prefix).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 长度前缀字符串解决了与零终止字符串相关的两个主要问题。长度前缀字符串可以包含 NUL 字符，并且对于零终止字符串中的一些相对低效的操作（例如，字符串长度计算），使用长度前缀字符串会更加高效。然而，长度前缀字符串也有其缺点。主要缺点是它们的长度最大限制为
    255 个字符（假设使用的是 1 字节的长度前缀）。
- en: Of course, if you have a problem with a string length limitation of 255 characters,
    it’s perfectly possible to create a length-prefixed string by using any number
    of bytes for the length as needed. For example, the *High-Level Assembler* *(HLA)*
    uses a 4-byte length variant of length-prefixed strings, allowing strings up to
    4GB long.^([6](#c04-footnote-8)) The point is that in assembly language, you can
    define string formats however you like.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你遇到 255 个字符的字符串长度限制问题，可以通过根据需要使用任意数量的字节来创建长度前缀字符串。例如，*高级汇编器* *(HLA)* 使用
    4 字节长度变体的长度前缀字符串，允许字符串长度达到 4GB。^([6](#c04-footnote-8)) 关键点是，在汇编语言中，你可以根据自己的需要定义字符串格式。
- en: 'If you want to create length-prefixed strings in your assembly language programs,
    you don’t want to have to manually count the characters in the string and emit
    that length in your code. It’s far better to have the assembler do this kind of
    grunge work for you. This is easily accomplished using the location counter operator
    (`$`) as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在汇编语言程序中创建长度前缀字符串，你不希望手动计算字符串中的字符数并在代码中输出该长度。让汇编器帮你做这种繁琐的工作要好得多。这可以通过使用位置计数器操作符
    (`$`) 来轻松实现，如下所示：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `lpsLen` operand subtracts 1 in the address expression because `$-lengthPrefixedString`
    also includes the length prefix byte, which isn’t considered part of the string
    length.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`lpsLen` 操作数在地址表达式中减去 1，因为 `$-lengthPrefixedString` 也包括了长度前缀字节，而这个字节并不算作字符串长度的一部分。'
- en: 4.8.3 String Descriptors
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8.3 字符串描述符
- en: Another common string format is a *string descriptor*. A string descriptor is
    typically a small data structure (record or structure, see “Records/Structs” on
    page 197) that contains several pieces of data describing a string. At a bare
    minimum, a string descriptor will probably have a pointer to the actual string
    data and a field specifying the number of characters in the string (that is, the
    string length). Other possible fields might include the number of bytes currently
    occupied by the string,^([7](#c04-footnote-9)) the maximum number of bytes the
    string could occupy, the string encoding (for example, ASCII, Latin-1, UTF-8,
    or UTF-16), and any other information the string data structure’s designer could
    dream up.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的字符串格式是*字符串描述符*。字符串描述符通常是一个小的数据结构（记录或结构，详见第197页的“记录/结构”），它包含几个描述字符串的数据字段。至少，字符串描述符可能会有指向实际字符串数据的指针和指定字符串中字符数（即字符串长度）的字段。其他可能的字段可能包括当前字符串占用的字节数^[7](#c04-footnote-9)、字符串可能占用的最大字节数、字符串编码（例如，ASCII、Latin-1、UTF-8
    或 UTF-16），以及字符串数据结构设计者可能想到的任何其他信息。
- en: By far, the most common descriptor format incorporates a pointer to the string’s
    data and a size field specifying the number of bytes currently occupied by that
    string data. Note that this particular string descriptor is not the same thing
    as a length-prefixed string. In a length-prefixed string, the length immediately
    precedes the character data itself. In a descriptor, the length and a pointer
    are kept together, and this pair is (usually) separate from the character data
    itself.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最常见的描述符格式包括指向字符串数据的指针和一个大小字段，用于指定当前占用的字节数。请注意，这种特定的字符串描述符与长度前缀字符串不同。在长度前缀字符串中，长度位于字符数据之前。而在描述符中，长度和指针是捆绑在一起的，这一对通常与字符数据本身分开。
- en: 4.8.4 Pointers to Strings
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8.4 字符串指针
- en: Most of the time, an assembly language program won’t directly work with strings
    appearing in the `.data` (or `.const` or `.data?`) section. Instead, the program
    will work with pointers to strings (including strings whose storage the program
    has dynamically allocated with a call to a function like `malloc()`). [Listing
    4-5](#listing4-5) provided a simple (if not broken) example. In such applications,
    your assembly code will typically load a pointer to a string into a base register
    and then use a second (index) register to access individual characters in the
    string.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，汇编语言程序不会直接处理出现在 `.data`（或 `.const` 或 `.data?`）段中的字符串。相反，程序将处理指向字符串的指针（包括程序通过调用
    `malloc()` 等函数动态分配的字符串）。[清单 4-5](#listing4-5)提供了一个简单的（如果不是坏的）示例。在这种应用程序中，您的汇编代码通常会将指向字符串的指针加载到基寄存器中，然后使用第二个（索引）寄存器来访问字符串中的各个字符。
- en: 4.8.5 String Functions
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8.5 字符串函数
- en: Unfortunately, very few assemblers provide a set of string functions you can
    call from your assembly language programs.^([8](#c04-footnote-10)) As an assembly
    language programmer, you’re expected to write these functions on your own. Fortunately,
    a couple of solutions are available if you don’t quite feel up to the task.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，极少数汇编程序提供您可以从汇编语言程序中调用的一组字符串函数^[8](#c04-footnote-10)。作为汇编语言程序员，您需要自己编写这些函数。幸运的是，如果您觉得任务有些艰巨，仍然有一些解决方案可供选择。
- en: The first set of string functions you can call (without having to write them
    yourself) is the C Standard Library string functions (from the *string.h* header
    file in C). Of course, you’ll have to use C strings (zero-terminated strings)
    in your code when calling C Standard Library functions, but this generally isn’t
    a big problem. [Listing 4-6](#listing4-6) provides examples of calls to various
    C string functions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以调用的第一组字符串函数（无需自己编写）是 C 标准库字符串函数（来自 C 中的*string.h*头文件）。当然，您在调用 C 标准库函数时必须使用
    C 字符串（以零终止的字符串），但通常这不是一个大问题。[清单 4-6](#listing4-6)提供了调用各种 C 字符串函数的示例。
- en: '[PRE55]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Listing 4-6: Calling C Standard Library string function from MASM source code'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-6：从 MASM 源代码调用 C 标准库字符串函数
- en: 'Here are the commands to build and run [Listing 4-6](#listing4-6):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是构建和运行[清单 4-6](#listing4-6)的命令：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Of course, you could make a good argument that if all your assembly code does
    is call a bunch of C Standard Library functions, you should have written your
    application in C in the first place. Most of the benefits of writing code in assembly
    language happen only when you “think” in assembly language, not C. In particular,
    you can dramatically improve the performance of your string function calls if
    you stop using zero-terminated strings and switch to another string format (such
    as length-prefixed or descriptor-based strings that include a length component).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以提出一个很好的论点：如果你的所有汇编代码仅仅是调用一堆 C 标准库函数，那么你本来就应该一开始就用 C 编写应用程序。编写汇编代码的最大好处只有在你“用汇编语言思考”时才会发生，而不是用
    C 语言思考。特别是，如果你停止使用以零为终止符的字符串，改用另一种字符串格式（如长度前缀或基于描述符的字符串，它们包含长度组件），你可以显著提高字符串函数调用的性能。
- en: In addition to the C Standard Library, you can find lots of x86-64 string functions
    written in assembly language out on the internet. A good place to start is the
    MASM Forum at [https://masm32.com/board/](https://masm32.com/board/) (despite
    the name, this message forum supports 64-bit as well as 32-bit MASM programming).
    Chapter 14 discusses string functions written in assembly language in greater
    detail.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 C 标准库外，你还可以在互联网上找到许多用汇编语言编写的 x86-64 字符串函数。一个很好的起点是 MASM 论坛，网址是[https://masm32.com/board/](https://masm32.com/board/)（尽管名字如此，这个论坛支持
    64 位以及 32 位的 MASM 编程）。第 14 章将更详细地讨论用汇编语言编写的字符串函数。
- en: 4.9 Arrays
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9 数组
- en: Along with strings, arrays are probably the most commonly used composite data.
    Yet most beginning programmers don’t understand how arrays operate internally
    and their associated efficiency trade-offs. It’s surprising how many novice (and
    even advanced!) programmers view arrays from a completely different perspective
    once they learn how to deal with arrays at the machine level.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串一样，数组可能是最常用的复合数据类型。然而，大多数初学程序员并不了解数组在内部是如何运作的，以及它们相关的效率权衡。令人惊讶的是，很多初学者（甚至是高级程序员！）在了解如何在机器级别处理数组之后，会从完全不同的角度看待数组。
- en: Abstractly, an *array* is an aggregate data type whose members (elements) are
    all the same type. Selection of a member from the array is by an integer index.^([9](#c04-footnote-11))
    Different indices select unique elements of the array. This book assumes that
    the integer indices are contiguous (though this is by no means required). That
    is, if the number *x* is a valid index into the array and *y* is also a valid
    index, with *x* < *y*, then all *i* such that *x* < *i* < *y* are valid indices.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 从抽象的角度来看，*数组*是一种聚合数据类型，其成员（元素）都是相同类型的。通过整数索引选择数组的成员。^([9](#c04-footnote-11))
    不同的索引选择数组的不同元素。本书假设整数索引是连续的（尽管这并不是必须的）。也就是说，如果数字 *x* 是数组的有效索引，且 *y* 也是有效索引，且 *x*
    < *y*，那么所有 *i* 满足 *x* < *i* < *y* 的值，都是有效的索引。
- en: Whenever you apply the indexing operator to an array, the result is the specific
    array element chosen by that index. For example, `A[i]` chooses the *i*th element
    from array `A`. There is no formal requirement that element `i` be anywhere near
    element `i+1` in memory. As long as `A[i]` always refers to the same memory location
    and `A[i+1]` always refers to its corresponding location (and the two are different),
    the definition of an array is satisfied.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你对数组应用索引运算符时，结果是由该索引选择的特定数组元素。例如，`A[i]` 选择数组 `A` 中的第 *i* 个元素。并没有正式要求元素 `i`
    必须在内存中紧挨着元素 `i+1`。只要 `A[i]` 始终引用相同的内存位置，且 `A[i+1]` 始终引用其对应位置（并且两者不同），那么数组的定义就得到了满足。
- en: In this book, we assume that array elements occupy contiguous locations in memory.
    An array with five elements will appear in memory as [Figure 4-1](#figure4-1)
    shows.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们假设数组元素占据内存中的连续位置。一个包含五个元素的数组将在内存中显示为如[图 4-1](#figure4-1)所示。
- en: '![f04001](image_fi/501089c04/f04001.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![f04001](image_fi/501089c04/f04001.png)'
- en: 'Figure 4-1: Array layout in memory'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1：数组在内存中的布局
- en: The *base address* of an array is the address of the first element in the array
    and always appears in the lowest memory location. The second array element directly
    follows the first in memory, the third element follows the second, and so on.
    Indices are not required to start at zero. They may start with any number as long
    as they are contiguous. However, for the purposes of discussion, this book will
    start all indexes at zero.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的*基地址*是数组第一个元素的地址，并且总是出现在内存的最低位置。第二个数组元素紧接着第一个元素存储在内存中，第三个元素紧跟第二个元素，以此类推。索引不要求从零开始。只要它们是连续的，索引可以从任何数字开始。然而，为了讨论的目的，本书将所有索引从零开始。
- en: 'To access an element of an array, you need a function that translates an array
    index to the address of the indexed element. For a single-dimensional array, this
    function is very simple:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组的一个元素，你需要一个将数组索引转换为该元素地址的函数。对于一维数组，这个函数非常简单：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: where `initial_index` is the value of the first index in the array (which you
    can ignore if it’s zero), and the value `element_size` is the size, in bytes,
    of an individual array element.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`initial_index` 是数组中第一个索引的值（如果它是零，你可以忽略它），而 `element_size` 的值是单个数组元素的大小，以字节为单位。
- en: 4.9.1 Declaring Arrays in Your MASM Programs
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9.1 在 MASM 程序中声明数组
- en: 'Before you can access elements of an array, you need to set aside storage for
    that array. Fortunately, array declarations build on the declarations you’ve already
    seen. To allocate *n* elements in an array, you would use a declaration like the
    following in one of the variable declaration sections:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问数组元素之前，你需要为该数组分配存储空间。幸运的是，数组声明是基于你已经见过的声明构建的。要为数组分配 *n* 个元素，你可以在变量声明部分使用如下声明：
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`array_name` is the name of the array variable, and `base_type` is the type
    of an element of that array. This declaration sets aside storage for the array.
    To obtain the base address of the array, just use `array_name`.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_name` 是数组变量的名称，`base_type` 是该数组元素的类型。这个声明为数组分配了存储空间。要获取数组的基地址，只需使用 `array_name`。'
- en: 'The `n` `dup (?)` operand tells MASM to duplicate the object `n` times. Now
    let’s look at some specific examples:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`n` `dup (?)` 操作符告诉 MASM 将对象复制 `n` 次。现在让我们看一些具体的示例：'
- en: '[PRE59]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'These examples all allocate storage for uninitialized arrays. You may also
    specify that the elements of the arrays be initialized using declarations like
    the following in the `.data` and `.const` sections:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例都为未初始化的数组分配存储空间。你还可以通过在 `.data` 和 `.const` 部分使用如下声明来指定数组元素的初始化：
- en: '[PRE60]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Both definitions create arrays with eight elements. The first definition initializes
    each 4-byte real value to `1.0`, and the second declaration initializes each 32-bit
    integer (`sdword`) element to `1`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个定义都创建了包含八个元素的数组。第一个定义将每个 4 字节的实数值初始化为 `1.0`，而第二个声明将每个 32 位整数（`sdword`）元素初始化为
    `1`。
- en: 'If all the array elements have the same initial value, you can save a little
    work by using the following declarations:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有数组元素都有相同的初始值，你可以通过使用以下声明来节省一些工作：
- en: '[PRE61]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'These operand fields tell MASM to make eight copies of the value inside the
    parentheses. In past examples, this has always been `?` (an uninitialized value).
    However, you can put an initial value inside the parentheses, and MASM will duplicate
    that value. In fact, you can put a comma-separated list of values, and MASM will
    duplicate everything inside the parentheses:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作数字段告诉 MASM 复制括号内的值八次。在过去的示例中，这个值通常是 `?`（一个未初始化的值）。不过，你可以在括号内放入一个初始值，MASM
    将复制这个值。实际上，你可以放入一个由逗号分隔的值列表，MASM 将复制括号内的所有内容：
- en: '[PRE62]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: These two examples also create eight-element arrays. Their initial values will
    be 1.0, 2.0, 1.0, 2.0, 1.0, 2.0, 1.0, 2.0, and 1, 2, 1, 2, 1, 2, 1, 2, respectively.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例也创建了包含八个元素的数组。它们的初始值分别是 1.0、2.0、1.0、2.0、1.0、2.0、1.0、2.0，以及 1、2、1、2、1、2、1、2。
- en: 4.9.2 Accessing Elements of a Single-Dimensional Array
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9.2 访问一维数组的元素
- en: 'To access an element of a zero-based array, you can use this formula:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一个零基数组的元素，你可以使用以下公式：
- en: '[PRE63]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you are operating in `LARGEADDRESSAWARE:NO` mode, for the `base_address`
    entry you can use the name of the array (because MASM associates the address of
    the first element of an array with the name of that array). If you are operating
    in a large address mode, you’ll need to load the base address of the array into
    a 64-bit (base) register; for example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 `LARGEADDRESSAWARE:NO` 模式下操作，对于 `base_address` 条目，你可以使用数组的名称（因为 MASM 会将数组第一个元素的地址与数组的名称关联起来）。如果你在大地址模式下操作，你需要将数组的基地址加载到
    64 位（基）寄存器中；例如：
- en: '[PRE64]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `element_size` entry is the number of bytes for each array element. If
    the object is an array of bytes, the `element_size` field is 1 (resulting in a
    very simple computation). If each element of the array is a word (or other 2-byte
    type), then `element_size` is 2, and so on. To access an element of the `IntegerAry`
    array in the previous section, you’d use the following formula (the size is 4
    because each element is an sdword object):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`element_size`条目表示每个数组元素的字节数。如果对象是字节数组，则`element_size`字段为1（结果是非常简单的计算）。如果数组中的每个元素是一个字（或其他2字节类型），则`element_size`为2，依此类推。要访问前一节中的`IntegerAry`数组的元素，你需要使用以下公式（大小为4，因为每个元素是一个sdword对象）：'
- en: '[PRE65]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Assuming `LARGEADDRESSAWARE:NO`, the x86-64 code equivalent to the statement
    `eax = IntegerAry[index]` is as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 假设为`LARGEADDRESSAWARE:NO`，则与语句`eax = IntegerAry[index]`等效的x86-64代码如下：
- en: '[PRE66]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In large address mode (`LARGEADDRESSAWARE:YES`), you’d have to load the address
    of the array into a base register; for example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在大地址模式（`LARGEADDRESSAWARE:YES`）下，你需要将数组的地址加载到基址寄存器中；例如：
- en: '[PRE67]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: These two instructions don’t explicitly multiply the index register (RBX) by
    4 (the size of a 32-bit integer element in `IntegerAry`). Instead, they use the
    scaled-indexed address mode to perform the multiplication.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条指令并没有显式地将索引寄存器（RBX）乘以4（`IntegerAry`中32位整数元素的大小）。相反，它们使用了缩放索引寻址模式来执行乘法。
- en: Another thing to note about this instruction sequence is that it does not explicitly
    compute the sum of the base address plus the index times 4\. Instead, it relies
    on the scaled-indexed addressing mode to implicitly compute this sum. The instruction
    `mov eax, IntegerAry[rbx*4]` loads EAX from location `IntegerAry + rbx*4`, which
    is the base address plus `index*4` (because RBX contains `index*4`). Similarly,
    `mov eax, [rdx+rbx*4]` computes this same sum as part of the addressing mode.
    Sure, you could have used
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的地方是，这个指令序列并没有显式地计算基地址加上索引乘以4的和。相反，它依赖于缩放索引寻址模式隐式地计算这个和。指令`mov eax, IntegerAry[rbx*4]`从位置`IntegerAry
    + rbx*4`加载EAX，即基地址加上`index*4`（因为RBX包含`index*4`）。类似地，`mov eax, [rdx+rbx*4]`在寻址模式中计算了这个相同的和。当然，你本可以使用
- en: '[PRE68]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: in place of the previous sequence, but why use five instructions when two or
    three will do the same job? This is a good example of why you should know your
    addressing modes inside and out. Choosing the proper addressing mode can reduce
    the size of your program, thereby speeding it up.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 用前面的指令序列替代，但为什么要用五条指令，而两三条就能完成相同的任务呢？这是一个很好的例子，说明了为什么你应该深入理解你的寻址模式。选择合适的寻址模式可以减小程序的体积，从而加速程序的执行。
- en: However, if you need to multiply by a constant other than 1, 2, 4, or 8, then
    you cannot use the scaled-indexed addressing modes. Similarly, if you need to
    multiply by an element size that is not a power of 2, you will not be able to
    use the `shl` instruction to multiply the index by the element size; instead,
    you will have to use `imul` or another instruction sequence to do the multiplication.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你需要乘以1、2、4或8以外的常数，则不能使用缩放索引寻址模式。类似地，如果你需要乘以一个不是2的幂的元素大小，你将无法使用`shl`指令将索引乘以元素大小；相反，你将不得不使用`imul`或其他指令序列来执行乘法。
- en: The indexed addressing mode on the x86-64 is a natural for accessing elements
    of a single-dimensional array. Indeed, its syntax even suggests an array access.
    The important thing to keep in mind is that you must remember to multiply the
    index by the size of an element. Failure to do so will produce incorrect results.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64上的索引寻址模式非常适合访问一维数组的元素。实际上，它的语法甚至暗示着数组访问。需要记住的重要事项是，你必须记得将索引乘以元素的大小。如果忘记这么做，将会得到错误的结果。
- en: 'The examples appearing in this section assume that the `index` variable is
    a 64-bit value. In reality, integer indexes into arrays are generally 32-bit integers
    or 32-bit unsigned integers. Therefore, you’d typically use the following instruction
    to load the index value into RBX:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中出现的示例假设`index`变量是一个64位值。实际上，数组的整数索引通常是32位整数或32位无符号整数。因此，你通常会使用以下指令将索引值加载到RBX中：
- en: '[PRE69]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Because loading a 32-bit value into a general-purpose register automatically
    zero-extends that register to 64 bits, the former instruction sequences (which
    expect a 64-bit index value) will still work properly when you’re using 32-bit
    integers as indexes into an array.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将32位值加载到通用寄存器时，寄存器会自动扩展为64位，因此以前的指令序列（假定使用64位索引值）在使用32位整数作为数组索引时仍然能正常工作。
- en: 4.9.3 Sorting an Array of Values
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9.3 排序值数组
- en: Almost every textbook on this planet gives an example of a sort when introducing
    arrays. Because you’ve probably seen how to do a sort in high-level languages
    already, it’s instructive to take a quick look at a sort in MASM. [Listing 4-7](#listing4-7)
    uses a variant of the bubble sort, which is great for short lists of data and
    lists that are nearly sorted, but horrible for just about everything else.^([10](#c04-footnote-12))
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有关于数组的教科书在介绍数组时都会给出一个排序的例子。因为你可能已经在高级语言中见过如何进行排序，所以有必要快速看一下MASM中的排序。[列表4-7](#listing4-7)使用了冒泡排序的变种，它对于短列表和几乎已排序的列表非常有效，但对其他情况却非常低效。^([10](#c04-footnote-12))
- en: '[PRE70]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Listing 4-7: A simple bubble sort example'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-7：一个简单的冒泡排序示例
- en: 'Here are the commands to assemble and run this sample code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是汇编和运行此示例代码的命令：
- en: '[PRE71]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The bubble sort works by comparing adjacent elements in an array. The `cmp`
    instruction (before `; if EAX > sortMe[RBX + 1]`) compares EAX (which contains
    `sortMe[rbx*4]`) against `sortMe[rbx*4 + 4]`. Because each element of this array
    is 4 bytes (`dword`), the index `[rbx*4 + 4]` references the next element beyond
    `[rbx*4]`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序通过比较数组中相邻的元素来工作。`cmp`指令（在`; if EAX > sortMe[RBX + 1]`之前）比较EAX（它包含`sortMe[rbx*4]`）和`sortMe[rbx*4
    + 4]`。因为该数组中的每个元素是4字节（`dword`），所以索引`[rbx*4 + 4]`引用的是紧接着`[rbx*4]`之后的下一个元素。
- en: As is typical for a bubble sort, this algorithm terminates if the innermost
    loop completes without swapping any data. If the data is already presorted, the
    bubble sort is very efficient, making only one pass over the data. Unfortunately,
    if the data is not sorted (worst case, if the data is sorted in reverse order),
    then this algorithm is extremely inefficient. However, the bubble sort is easy
    to implement and understand (which is why introductory texts continue to use it
    in examples).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 正如冒泡排序的典型做法一样，如果最内层的循环完成时没有交换任何数据，那么这个算法就会终止。如果数据已经预先排序好，冒泡排序非常高效，只需对数据进行一轮遍历。不幸的是，如果数据没有排序（最糟糕的情况是数据按逆序排序），那么这个算法的效率非常低。然而，冒泡排序易于实现和理解（这也是入门教材继续使用它作为例子的原因）。
- en: 4.10 Multidimensional Arrays
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.10 多维数组
- en: The x86-64 hardware can easily handle single-dimensional arrays. Unfortunately,
    there is no magic addressing mode that lets you easily access elements of multidimensional
    arrays. That’s going to take some work and several instructions.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64硬件可以轻松处理一维数组。不幸的是，当前没有能够轻松访问多维数组元素的魔法寻址模式。这需要一些工作和多条指令。
- en: Before discussing how to declare or access multidimensional arrays, it would
    be a good idea to figure out how to implement them in memory. The first problem
    is to figure out how to store a multidimensional object into a one-dimensional
    memory space.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何声明或访问多维数组之前，最好先弄清楚如何在内存中实现它们。第一个问题是如何将多维对象存储到一维内存空间中。
- en: Consider for a moment a Pascal array of the form `A:array[0..3,0..3]` `of char;`.
    This array contains 16 bytes organized as four rows of four characters. Somehow,
    you’ve got to draw a correspondence with each of the 16 bytes in this array and
    16 contiguous bytes in main memory. [Figure 4-2](#figure4-2) shows one way to
    do this.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 请暂时考虑一个形式为`A:array[0..3,0..3]` `of char;`的Pascal数组。这个数组包含16个字节，组织成四行四列的字符。你需要将这个数组中的每个16个字节与主存中的16个连续字节对应起来。[图4-2](#figure4-2)展示了其中的一种做法。
- en: '![f04002](image_fi/501089c04/f04002.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![f04002](image_fi/501089c04/f04002.png)'
- en: 'Figure 4-2: Mapping a 4×4 array to sequential memory locations'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2：将4×4数组映射到顺序内存位置
- en: 'The actual mapping is not important as long as two things occur: (1) each element
    maps to a unique memory location (that is, no two entries in the array occupy
    the same memory locations) and (2) the mapping is consistent (that is, a given
    element in the array always maps to the same memory location). So, what you really
    need is a function with two input parameters (row and column) that produces an
    offset into a linear array of 16 memory locations.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的映射并不重要，只要满足两个条件：（1）每个元素映射到唯一的内存位置（即，数组中的两个条目不会占用相同的内存位置），（2）映射是一致的（即，数组中的某个元素总是映射到相同的内存位置）。因此，你真正需要的是一个具有两个输入参数（行和列）的函数，它能够生成指向16个内存位置的线性数组的偏移量。
- en: 'Now any function that satisfies these constraints will work fine. Indeed, you
    could randomly choose a mapping as long as it was consistent. However, what you
    really want is a mapping that is efficient to compute at runtime and works for
    any size array (not just 4×4 or even limited to two dimensions). While a large
    number of possible functions fit this bill, two functions in particular are used
    by most programmers and high-level languages: row-major ordering and column-major
    ordering.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何满足这些约束条件的函数都能正常工作。事实上，只要映射一致，你可以随机选择一个映射。然而，真正想要的是一个在运行时计算高效并适用于任何大小数组（不仅仅是
    4×4 或限制为二维）的映射。虽然有许多可能的函数符合这个要求，但有两个特别的函数被大多数程序员和高级语言使用：行主序排序和列主序排序。
- en: 4.10.1 Row-Major Ordering
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.10.1 行主序排序
- en: '*Row-major ordering* assigns successive elements, moving across the rows and
    then down the columns, to successive memory locations. This mapping is demonstrated
    in [Figure 4-3](#figure4-3).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*行主序排序*将连续的元素按行依次排列，然后再按列排列，分配到连续的内存位置。这种映射在[图 4-3](#figure4-3)中进行了展示。'
- en: '![f04003](image_fi/501089c04/f04003.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![f04003](image_fi/501089c04/f04003.png)'
- en: 'Figure 4-3: Row-major array element ordering'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-3：行主序数组元素排序
- en: Row-major ordering is the method most high-level programming languages employ.
    It is easy to implement and use in machine language. You start with the first
    row (row 0) and then concatenate the second row to its end. You then concatenate
    the third row to the end of the list, then the fourth row, and so on (see [Figure
    4-4](#figure4-4)).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 行主序排序是大多数高级编程语言采用的方法。它易于在机器语言中实现和使用。你从第一行（第 0 行）开始，然后将第二行连接到它的末尾。接着，将第三行连接到列表的末尾，然后是第四行，依此类推（见[图
    4-4](#figure4-4)）。
- en: '![f04004](image_fi/501089c04/f04004.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![f04004](image_fi/501089c04/f04004.png)'
- en: 'Figure 4-4: Another view of row-major ordering for a 4×4 array'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-4：4×4 数组的行主序排序的另一种视图
- en: 'The actual function that converts a list of index values into an offset is
    a slight modification of the formula for computing the address of an element of
    a single-dimensional array. The formula to compute the offset for a two-dimensional
    row-major ordered array is as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 将索引值列表转换为偏移量的实际函数是对计算一维数组元素地址的公式的轻微修改。计算二维行主序数组偏移量的公式如下：
- en: '[PRE72]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As usual, `base_address` is the address of the first element of the array (`A[0][0]`
    in this case), and `element_size` is the size of an individual element of the
    array, in bytes. `col_index` is the leftmost index, and `row_index` is the rightmost
    index into the array. `row_size` is the number of elements in one row of the array
    (4, in this case, because each row has four elements). Assuming `element_size`
    is 1, this formula computes the following offsets from the base address:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，`base_address`是数组第一个元素的地址（此例中为`A[0][0]`），`element_size`是数组中单个元素的字节大小。`col_index`是最左边的索引，`row_index`是数组的最右边索引。`row_size`是数组每一行中的元素数量（在此例中为
    4，因为每行有四个元素）。假设`element_size`为 1，则该公式从基地址计算出以下偏移量：
- en: '[PRE73]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'For a three-dimensional array, the formula to compute the offset into memory
    is the following:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三维数组，计算内存偏移量的公式如下：
- en: '[PRE74]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `col_size` is the number of items in a column, and `row_size` is the number
    of items in a row. In C/C++, if you’ve declared the array as `type` `A[i][j][k];`,
    then `row_size` is equal to `k` and `col_size` is equal to `j`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`col_size`是列中的元素数量，`row_size`是行中的元素数量。在 C/C++ 中，如果你将数组声明为`type` `A[i][j][k];`，那么`row_size`等于`k`，`col_size`等于`j`。'
- en: 'For a four-dimensional array, declared in C/C++ as `type` `A[i][j][k][m];`,
    the formula for computing the address of an array element is shown here:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个四维数组，在 C/C++ 中声明为`type` `A[i][j][k][m];`，计算数组元素地址的公式如下所示：
- en: '[PRE75]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `depth_size` is equal to `j`, `col_size` is equal to `k`, and `row_size`
    is equal to `m`. `left_index` represents the value of the leftmost index.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`depth_size`等于`j`，`col_size`等于`k`，`row_size`等于`m`。`left_index`表示最左侧索引的值。'
- en: By now you’re probably beginning to see a pattern. There is a generic formula
    that will compute the offset into memory for an array with *any* number of dimensions;
    however, you’ll rarely use more than four.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在你可能已经开始看出一种规律。有一个通用的公式可以计算具有*任意*维度的数组的内存偏移量；然而，你很少会使用超过四维的数组。
- en: 'Another convenient way to think of row-major arrays is as arrays of arrays.
    Consider the following single-dimensional Pascal array definition:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种理解行主序数组的方便方式是将其看作数组的数组。考虑以下单维的 Pascal 数组定义：
- en: '[PRE76]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: where `sometype` is the type `sometype = array [0..3] of char;`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `sometype` 是类型 `sometype = array [0..3] of char;`。
- en: '`A` is a single-dimensional array. Its individual elements happen to be arrays,
    but you can safely ignore that for the time being. The formula to compute the
    address of an element of a single-dimensional array is as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`A` 是一个一维数组。它的各个元素恰好是数组，但目前您可以忽略这一点。计算一维数组元素地址的公式如下：'
- en: '[PRE77]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this case, `element_size` happens to be 4 because each element of `A` is
    an array of four characters. So, this formula computes the base address of each
    row in this 4×4 array of characters (see [Figure 4-5](#figure4-5)).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`element_size` 恰好为 4，因为 `A` 的每个元素是一个由四个字符组成的数组。因此，这个公式计算的是这个 4×4 字符数组中每一行的基地址（见
    [图 4-5](#figure4-5)）。
- en: '![f04005](image_fi/501089c04/f04005.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![f04005](image_fi/501089c04/f04005.png)'
- en: 'Figure 4-5: Viewing a 4×4 array as an array of arrays'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5：将 4×4 数组视为数组的数组
- en: Of course, once you compute the base address of a row, you can reapply the single-dimensional
    formula to get the address of a particular element. While this doesn’t affect
    the computation, it’s probably a little easier to deal with several single-dimensional
    computations rather than a complex multidimensional array computation.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦你计算出一行的基地址，你可以重新应用一维公式来获得某个特定元素的地址。虽然这不会影响计算，但处理几个一维计算可能比处理一个复杂的多维数组计算更容易。
- en: 'Consider a Pascal array defined as `A:array [0..3, 0..3, 0..3, 0..3, 0..3]
    of char;`. You can view this five-dimensional array as a single-dimensional array
    of arrays. The following Pascal code provides such a definition:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个 Pascal 数组定义为 `A:array [0..3, 0..3, 0..3, 0..3, 0..3] of char;`。您可以将这个五维数组视为一个一维数组的数组。以下
    Pascal 代码提供了这样的定义：
- en: '[PRE78]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The size of `OneD` is 4 bytes. Because `TwoD` contains four `OneD` arrays,
    its size is 16 bytes. Likewise, `ThreeD` is four `TwoDs`, so it is 64 bytes long.
    Finally, `FourD` is four `ThreeDs`, so it is 256 bytes long. To compute the address
    of `A [b, c, d, e, f]`, you could use the following steps:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`OneD` 的大小是 4 字节。因为 `TwoD` 包含四个 `OneD` 数组，所以它的大小是 16 字节。同样，`ThreeD` 是四个 `TwoD`，因此它的大小是
    64 字节。最后，`FourD` 是四个 `ThreeD`，所以它的大小是 256 字节。为了计算 `A[b, c, d, e, f]` 的地址，您可以使用以下步骤：'
- en: Compute the address of `A[b]` as `Base` `+ b *` `size`. Here `size` is 256 bytes.
    Use this result as the new base address in the next computation.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过公式 `Base` `+ b *` `size` 计算 `A[b]` 的地址。此时 `size` 为 256 字节。将此结果作为下一步计算的新基地址。
- en: Compute the address of `A[b, c]` by the formula `Base` `+ c *` `size`, where
    `Base` is the value obtained in the previous step and `size` is 64\. Use the result
    as the new base in the next computation.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过公式 `Base` `+ c *` `size` 计算 `A[b, c]` 的地址，其中 `Base` 是上一步骤中获得的值，`size` 为 64。将此结果作为下一步计算的新基地址。
- en: Compute the base address of`A [b, c, d]` by `Base` `+ d *` `size`, where `Base`
    comes from the previous computation, and `size` is 16\. Use the result as the
    new base in the next computation.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过公式 `Base` `+ d *` `size` 计算 `A[b, c, d]` 的基地址，其中 `Base` 来自之前的计算，`size` 为 16。将此结果作为下一步计算的新基地址。
- en: Compute the address of `A[b, c, d, e]`with the formula `Base` `+ e *` `size`,
    where `Base` comes from the previous computation, and `size` is 4\. Use this value
    as the base for the next computation.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用公式 `Base` `+ e *` `size` 计算 `A[b, c, d, e]` 的地址，其中 `Base` 来自之前的计算，`size` 为
    4。将该值作为下一步计算的基地址。
- en: Finally, compute the address of `A[b, c, d, e, f]` by using the formula `Base`
    `+ f *` `size`, where `Base` comes from the previous computation and `size` is
    1 (obviously, you can ignore this final multiplication). The result you obtain
    at this point is the address of the desired element.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用公式 `Base` `+ f *` `size` 计算 `A[b, c, d, e, f]` 的地址，其中 `Base` 来自之前的计算，`size`
    为 1（显然，您可以忽略这最后的乘法）。此时获得的结果就是所需元素的地址。
- en: One of the main reasons you won’t find higher-dimensional arrays in assembly
    language is that assembly language emphasizes the inefficiencies associated with
    such access. It’s easy to enter something like `A[b, c, d, e, f]` into a Pascal
    program, not realizing what the compiler is doing with the code. Assembly language
    programmers are not so cavalier—they see the mess you wind up with when you use
    higher-dimensional arrays. Indeed, good assembly language programmers try to avoid
    two-dimensional arrays and often resort to tricks in order to access data in such
    an array when its use becomes absolutely mandatory.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你在汇编语言中很少能找到高维数组的一个主要原因是，汇编语言强调使用这些数组时的低效性。在Pascal程序中输入类似`A[b, c, d, e, f]`的东西很容易，但你并不了解编译器在处理这些代码时的细节。汇编语言程序员可不会那么轻率——他们明白使用高维数组时会遇到的麻烦。实际上，优秀的汇编语言程序员尽量避免使用二维数组，当使用二维数组变得绝对必要时，他们常常采用一些技巧来访问数组中的数据。
- en: 4.10.2 Column-Major Ordering
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.10.2 列优先排序
- en: '*Column-major ordering* is the other function high-level languages frequently
    use to compute the address of an array element. FORTRAN and various dialects of
    BASIC (for example, older versions of Microsoft BASIC) use this method.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '*列优先排序*是另一种高级语言中常用的计算数组元素地址的方法。FORTRAN和各种BASIC方言（例如较旧版本的Microsoft BASIC）都使用这种方法。'
- en: In row-major ordering, the rightmost index increases the fastest as you move
    through consecutive memory locations. In column-major ordering, the leftmost index
    increases the fastest. Pictorially, a column-major ordered array is organized
    as shown in [Figure 4-6](#figure4-6).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在行优先排序中，最右侧的索引随着连续内存位置的移动而增大最快。在列优先排序中，最左侧的索引增速最快。从图示来看，列优先排序的数组如[图 4-6](#figure4-6)所示。
- en: The formula for computing the address of an array element when using column-major
    ordering is similar to that for row-major ordering. You reverse the indexes and
    sizes in the computation.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列优先排序时，计算数组元素地址的公式与行优先排序类似。你只需反转计算中的索引和大小。
- en: '![f04006](image_fi/501089c04/f04006.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![f04006](image_fi/501089c04/f04006.png)'
- en: 'Figure 4-6: Column-major array element ordering'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-6：列优先数组元素排序
- en: 'For a two-dimension column-major array:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二维列优先数组：
- en: '[PRE79]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'For a three-dimension column-major array:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 对于三维列优先数组：
- en: '[PRE80]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'For a four-dimension column-major array:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 对于四维列优先数组：
- en: '[PRE81]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 4.10.3 Allocating Storage for Multidimensional Arrays
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.10.3 为多维数组分配存储
- en: 'If you have an *m*×*n* array, it will have *m* × *n* elements and require *m*
    × *n* × `element_size` bytes of storage. To allocate storage for an array, you
    must reserve this memory. As usual, there are several ways of accomplishing this
    task. To declare a multidimensional array in MASM, you could use a declaration
    like the following:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个*m*×*n*的数组，它将有*m* × *n*个元素，并需要*m* × *n* × `element_size`字节的存储空间。要为数组分配存储，你必须预留这些内存。像往常一样，有多种方法可以完成此任务。要在MASM中声明一个多维数组，你可以使用如下声明：
- en: '[PRE82]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: where `size`1 to `size`n are the sizes of each of the dimensions of the array.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`size`1到`size`n是数组每个维度的大小。
- en: 'For example, here is a declaration for a 4×4 array of characters:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是一个4×4字符数组的声明：
- en: '[PRE83]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here is another example that shows how to declare a three-dimensional array
    of strings (assuming the array holds 64-bit pointers to the strings):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个示例，展示了如何声明一个三维字符串数组（假设数组保存的是64位指针指向字符串）：
- en: '[PRE84]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'As was the case with single-dimensional arrays, you may initialize every element
    of the array to a specific value by following the declaration with the values
    of the array constant. Array constants ignore dimension information; all that
    matters is that the number of elements in the array constant corresponds to the
    number of elements in the actual array. The following example shows the `GameGrid`
    declaration with an initializer:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一维数组一样，你可以通过在声明后跟随数组常量的值来初始化数组的每个元素。数组常量忽略维度信息；重要的是数组常量中的元素数量与实际数组的元素数量一致。以下示例展示了带初始化器的`GameGrid`声明：
- en: '[PRE85]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This example was laid out to enhance readability (which is always a good idea).
    MASM does not interpret the four separate lines as representing rows of data in
    the array. Humans do, which is why it’s good to write the data in this manner.
    All that matters is that there are 16 (4 × 4) characters in the array constant.
    You’ll probably agree that this is much easier to read than
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的布局旨在增强可读性（这总是一个好主意）。MASM并不会将四行数据解释为数组中的数据行。人类会这样做，这也是为什么以这种方式编写数据很有益的原因。重要的是数组常量中有16个（4
    × 4）字符。你可能会同意，这比下面的形式更容易阅读：
- en: '[PRE86]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Of course, if you have a large array, an array with really large rows, or an
    array with many dimensions, there is little hope for winding up with something
    readable. That’s when comments that carefully explain everything come in handy.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你有一个大型数组，或者一个包含非常大行的数组，或一个具有多个维度的数组，那么很难做到具有良好的可读性。那时，仔细解释每一部分的注释就非常有用了。
- en: 'As for single-dimensional arrays, you can use the `dup` operator to initialize
    each element of a large array with the same value. The following example initializes
    a 256×64 array of bytes so that each byte contains the value 0FFh:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一维数组，你可以使用`dup`操作符初始化大数组的每个元素，使其具有相同的值。以下示例初始化了一个256×64的字节数组，使得每个字节都包含值`0FFh`：
- en: '[PRE87]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The use of a constant expression to compute the number of array elements rather
    than simply using the constant 16,384 (256 × 64) more clearly suggests that this
    code is initializing each element of a 256×64 element array than does the simple
    literal constant 16,384.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常量表达式来计算数组元素的数量，而不是简单地使用常量16,384（256 × 64），更清楚地表明这段代码正在初始化一个256×64元素的数组，而不是简单的字面常量16,384。
- en: 'Another MASM trick you can use to improve the readability of your programs
    is to use *nested* `dup` *declarations*. The following is an example of a MASM
    nested `dup` declaration:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你可以用来提高程序可读性的MASM技巧是使用*嵌套*`dup`*声明*。以下是一个MASM嵌套`dup`声明的示例：
- en: '[PRE88]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: MASM replicates anything inside the parentheses the number of times specified
    by the constant preceding the `dup` operator; this includes nested `dup` declarations.
    This example says, “Duplicate the stuff inside the parentheses 256 times.” Inside
    the parentheses, there is a `dup` operator that says, “Duplicate `0FFh` 64 times,”
    so the outside `dup` operator duplicates the duplication of 64 `0FFh` values 256
    times.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: MASM会根据`dup`操作符前面的常量指定的次数，复制括号内的内容；这包括嵌套的`dup`声明。这个示例表示：“将括号内的内容复制256次。”在括号内，有一个`dup`操作符，表示：“将`0FFh`复制64次”，所以外层的`dup`操作符将64个`0FFh`值的复制再复制256次。
- en: It is probably a good programming convention to declare multidimensional arrays
    by using the “`dup` of `dup` (. . . of `dup`)” syntax. This can make it clearer
    that you’re creating a multidimensional array rather than a single-dimensional
    array with a large number of elements.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“`dup` of `dup`（... of `dup`）”语法声明多维数组可能是一个好的编程习惯。这样可以更清楚地表明你正在创建一个多维数组，而不是一个包含大量元素的一维数组。
- en: 4.10.4 Accessing Multidimensional Array Elements in Assembly Language
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.10.4 在汇编语言中访问多维数组元素
- en: Well, you’ve seen the formulas for computing the address of a multidimensional
    array element. Now it’s time to see how to access elements of those arrays by
    using assembly language.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你已经看到过计算多维数组元素地址的公式。现在是时候看看如何使用汇编语言访问这些数组的元素了。
- en: 'The `mov`, `shl`, and `imul` instructions make short work of the various equations
    that compute offsets into multidimensional arrays. Let’s consider a two-dimensional
    array first:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov`、`shl`和`imul`指令能够轻松地处理计算多维数组偏移量的各种方程式。我们首先考虑一个二维数组的情况：'
- en: '[PRE89]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note that this code does *not* require the use of a two-register addressing
    mode on the x86-64 (at least, not when using the `LARGEADDRESSAWARE:NO` option).
    Although an addressing mode like `TwoD[rbx][rsi]` looks like it should be a natural
    for accessing two-dimensional arrays, that isn’t the purpose of this addressing
    mode.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码*不*需要在x86-64架构上使用双寄存器寻址模式（至少在使用`LARGEADDRESSAWARE:NO`选项时不需要）。虽然像`TwoD[rbx][rsi]`这样的寻址模式看起来应该是访问二维数组的自然方式，但这并不是该寻址模式的目的。
- en: 'Now consider a second example that uses a three-dimensional array (again, assuming
    `LARGEADDRESSAWARE:NO`):'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑第二个示例，它使用了三维数组（再次假设使用`LARGEADDRESSAWARE:NO`）：
- en: '[PRE90]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This code uses the `imul` instruction to multiply the value in RBX by 5, because
    the `shl` instruction can multiply a register by only a power of 2\. While there
    are ways to multiply the value in a register by a constant other than a power
    of 2, the `imul` instruction is more convenient.^([12](#c04-footnote-14)) Also
    remember that operations on the 32-bit general-purpose registers automatically
    zero-extend their result into the 64-bit register.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用`imul`指令将RBX寄存器中的值乘以5，因为`shl`指令只能将寄存器的值乘以2的幂。虽然有方法可以将寄存器中的值乘以其他常数，但`imul`指令更为方便。^([12](#c04-footnote-14))
    还要记住，32位通用寄存器上的操作会自动将结果扩展到64位寄存器中。
- en: 4.11 Records/Structs
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.11 记录/结构体
- en: Another major composite data structure is the Pascal *record* or C/C++/C# *structure*.^([13](#c04-footnote-15))
    The Pascal terminology is probably better, because it tends to avoid confusion
    with the more general term *data structure*. However, MASM uses the term *struct*,
    so this book favors that term.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个主要的复合数据结构是Pascal的*record*或C/C++/C#的*structure*。^([13](#c04-footnote-15))
    Pascal的术语可能更好，因为它通常避免与更通用的术语*数据结构*产生混淆。然而，MASM使用术语*struct*，因此本书使用该术语。
- en: Whereas an array is homogeneous, with elements that are all the same type, the
    elements in a struct can have different types. Arrays let you select a particular
    element via an integer index. With structs, you must select an element (known
    as a *field*) by name.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 而数组是同质的，其元素都是相同类型的，结构体中的元素可以具有不同的类型。数组让你通过整数索引选择特定的元素。使用结构体时，你必须通过名称选择一个元素（称为*字段*）。
- en: 'The whole purpose of a structure is to let you encapsulate different, though
    logically related, data into a single package. The Pascal record declaration for
    a student is a typical example:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的主要目的是让你将不同但逻辑上相关的数据封装到一个单一的包裹中。Pascal的学生记录声明是一个典型的例子：
- en: '[PRE91]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Most Pascal compilers allocate each field in a record to contiguous memory locations.
    This means that Pascal will reserve the first 65 bytes for the name,^([14](#c04-footnote-16))
    the next 2 bytes hold the major code (assuming a 16-bit integer), the next 12
    bytes hold the Social Security number, and so on.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Pascal编译器会将记录中的每个字段分配到连续的内存位置。这意味着Pascal会为名称保留前65个字节，^([14](#c04-footnote-16))
    接下来的2个字节存放专业代码（假设是16位整数），接下来的12个字节存放社会安全号码，依此类推。
- en: 4.11.1 MASM Struct Declarations
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.11.1 MASM结构体声明
- en: 'In MASM, you can create record types by using the `struct`/`ends` declaration.
    You would encode the preceding record in MASM as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在MASM中，你可以通过使用`struct`/`ends`声明来创建记录类型。你可以如下编码前面的记录：
- en: '[PRE92]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: As you can see, the MASM declaration is similar to the Pascal declaration. To
    be true to the Pascal declaration, this example uses character arrays rather than
    strings for the `sName` and `SSN` (US Social Security number) fields. Also, the
    MASM declaration assumes that integers are unsigned 16-bit values (which is probably
    appropriate for this type of data structure).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，MASM声明与Pascal声明类似。为了忠实于Pascal声明，本例中使用了字符数组而不是字符串来表示`sName`和`SSN`（美国社会安全号码）字段。此外，MASM声明假设整数是无符号的16位值（这对于此类型的数据结构可能是适当的）。
- en: The field names within the struct must be unique; the same name may not appear
    two or more times in the same record. However, all field names are local to that
    record. Therefore, you may reuse those field names elsewhere in the program or
    in different records.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体中的字段名必须唯一；同一个字段名不能在同一记录中出现两次或更多次。然而，所有字段名对于该记录是局部的。因此，你可以在程序的其他地方或不同的记录中重用这些字段名。
- en: 'The `struct`/`ends` declaration may appear anywhere in the source file as long
    as you define it before you use it. A `struct` declaration does not actually allocate
    any storage for a `student` variable. Instead, you have to explicitly declare
    a variable of type `student`. The following example demonstrates how to do this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`/`ends`声明可以出现在源文件的任何位置，只要你在使用之前定义它即可。`struct`声明实际上并不会为`student`变量分配存储空间。相反，你必须明确声明一个`student`类型的变量。以下示例展示了如何做到这一点：'
- en: '[PRE93]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The funny operand (`{}`) is a MASM-ism, just something you’ll have to remember.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这个奇怪的操作数（`{}`）是MASM的特色，你必须记住它。
- en: The `John` variable declaration allocates 89 bytes of storage laid out in memory,
    as shown in [Figure 4-7](#figure4-7).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`John`变量声明分配了89个字节的存储空间，如图[4-7](#figure4-7)所示。'
- en: '![f04007](image_fi/501089c04/f04007.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![f04007](image_fi/501089c04/f04007.png)'
- en: 'Figure 4-7: Student data structure storage in memory'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-7：学生数据结构在内存中的存储
- en: If the label `John` corresponds to the base address of this record, the `sName`
    field is at offset `John + 0`, the `Major` field is at offset `John + 65`, the
    `SSN` field is at offset `John + 67`, and so on.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标签 `John` 对应于此记录的基地址，则 `sName` 字段位于偏移量 `John + 0`，`Major` 字段位于偏移量 `John +
    65`，`SSN` 字段位于偏移量 `John + 67`，依此类推。
- en: 4.11.2 Accessing Record/Struct Fields
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.11.2 访问记录/结构字段
- en: 'To access an element of a structure, you need to know the offset from the beginning
    of the structure to the desired field. For example, the `Major` field in the variable
    `John` is at offset 65 from the base address of `John`. Therefore, you could store
    the value in AX into this field by using this instruction:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问结构的元素，你需要知道从结构开始到目标字段的偏移量。例如，`John` 变量中的 `Major` 字段位于 `John` 的基地址偏移量 65 处。因此，你可以使用以下指令将
    AX 中的值存储到此字段：
- en: '[PRE94]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Unfortunately, memorizing all the offsets to fields in a `struct` defeats the
    whole purpose of using them in the first place. After all, if you have to deal
    with these numeric offsets, why not just use an array of bytes instead of a `struct`?
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，记住 `struct` 中所有字段的偏移量违背了使用结构的初衷。毕竟，如果你必须处理这些数字偏移量，为什么不直接使用字节数组而不是 `struct`
    呢？
- en: 'Fortunately, MASM lets you refer to field names in a record by using the same
    mechanism most HLLs use: the dot operator. To store AX into the `Major` field,
    you could use `mov John.Major, ax`instead of the previous instruction. This is
    much more readable and certainly easier to use.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，MASM 让你使用大多数高级语言中常用的机制来引用记录中的字段名称：点操作符。要将 AX 存储到 `Major` 字段中，你可以使用 `mov
    John.Major, ax`，而不是之前的指令。这更具可读性，也更容易使用。
- en: The use of the dot operator does not introduce a new addressing mode. The instruction
    `mov John.Major, ax` still uses the PC-relative addressing mode. MASM simply adds
    the base address of `John` with the offset to the `Major` field (65) to get the
    actual displacement to encode into the instruction.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 使用点操作符不会引入新的寻址模式。指令 `mov John.Major, ax` 仍然使用 PC 相对寻址模式。MASM 只是将 `John` 的基地址与
    `Major` 字段的偏移量（65）相加，以获得实际位移值并将其编码到指令中。
- en: 'The dot operator works quite well when dealing with `struct` variables you
    declare in one of the static sections (`.data`, `.const`, or `.data?`) and access
    via the PC-relative addressing mode. However, what happens when you have a pointer
    to a record object? Consider the following code fragment:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理你在某个静态段（`.data`、`.const` 或 `.data?`）中声明的 `struct` 变量并通过 PC 相对寻址模式访问时，点操作符效果很好。然而，当你有一个指向记录对象的指针时，会发生什么呢？考虑以下代码片段：
- en: '[PRE95]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Unfortunately, the `Final` field name is local to the `student` structure.
    As a result, MASM will complain that the name `Final` is undefined in this code
    sequence. To get around this problem, you add the structure name to the dotted
    name list when using pointer references. Here’s the correct form of the preceding
    code:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`Final` 字段名是 `student` 结构的局部名。因此，MASM 会抱怨在此代码序列中 `Final` 名称未定义。为了解决这个问题，你可以在使用指针引用时将结构名添加到点操作符的名称列表中。以下是前述代码的正确形式：
- en: '[PRE96]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 4.11.3 Nesting MASM Structs
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.11.3 嵌套 MASM 结构
- en: 'MASM allows you to define fields of a structure that are themselves structure
    types. Consider the following two `struct` declarations:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 允许你定义结构的字段，而这些字段本身是结构类型。考虑以下两个 `struct` 声明：
- en: '[PRE97]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `sGrades` field now holds all the individual grade fields that were formerly
    individual fields in the `grades` structure. Note that this particular example
    has the same memory layout as the previous examples (see [Figure 4-7](#figure4-7)).
    The `grades` structure itself doesn’t add any new data; it simply organizes the
    grade fields under its own substructure.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`sGrades` 字段保存了原本在 `grades` 结构中的所有单独的成绩字段。请注意，这个特定示例与之前的示例（见 [图 4-7](#figure4-7)）具有相同的内存布局。`grades`
    结构本身并没有添加任何新的数据，它只是将成绩字段组织到自己的子结构中。
- en: 'To access the subfields, you use the same syntax you’d use with C/C++ (and
    most other HLLs supporting records/structures). If the `John` variable declaration
    appearing in previous sections was of this new `struct` type, you’d access the
    `Homework` field by using a statement such as the following:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问子字段，你可以使用与 C/C++（以及大多数支持记录/结构的其他高级语言）相同的语法。如果之前部分中出现的 `John` 变量声明是这种新的 `struct`
    类型，你可以通过以下语句访问 `Homework` 字段：
- en: '[PRE98]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 4.11.4 Initializing Struct Fields
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.11.4 初始化结构字段
- en: A typical structure declaration such as the following
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个典型的结构声明：
- en: '[PRE99]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: leaves all fields in `structType` uninitialized (similar to having the `?` operand
    in other variable declarations). MASM will allow you to provide initial values
    for all the fields of a structure by supplying a list of comma-separated items
    between the braces in the operand field of a structure variable declaration, as
    shown in [Listing 4-8](#listing4-8).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 会将`structType`中的所有字段保持未初始化状态（类似于其他变量声明中使用`?`操作数的效果）。MASM允许你通过在结构体变量声明的操作数字段中提供一个由逗号分隔的项列表，来为结构体的所有字段提供初始值，如[Listing
    4-8](#listing4-8)所示。
- en: '[PRE100]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Listing 4-8: Initializing the fields of a structure'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-8：初始化结构体的字段
- en: 'Here are the build commands and output for [Listing 4-8](#listing4-8):'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是[Listing 4-8](#listing4-8)的构建命令和输出：
- en: '[PRE101]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'If a structure field is an array object, you’ll need special syntax to initialize
    that array data. Consider the following structure definition:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结构体字段是数组对象，你需要使用特定的语法来初始化该数组数据。考虑以下结构体定义：
- en: '[PRE102]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The initialization operands must either be a string or a single item. Therefore,
    the following is not legal:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化操作数必须是一个字符串或一个单一项。因此，以下内容是非法的：
- en: '[PRE103]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This (presumably) is an attempt to initialize `aryField1` with `{1,2,3,4,5,6,7,8}`
    and `aryField2` with `{1,2,3,4}`. MASM, however, won’t accept this. MASM wants
    only two values in the operand field (one for `aryField1` and one for `aryField2`).
    The solution is to place the array constants for the two arrays in their own set
    of braces:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这（可能）是尝试用`{1,2,3,4,5,6,7,8}`初始化`aryField1`，并用`{1,2,3,4}`初始化`aryField2`。然而，MASM不接受这种写法。MASM只希望在操作数字段中有两个值（分别对应`aryField1`和`aryField2`）。解决方案是将两个数组常量分别放入各自的花括号中：
- en: '[PRE104]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'If you supply too many initializers for a given array element, MASM will report
    an error. If you supply too few initializers, MASM will quietly fill in the remaining
    array entries with 0 values:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为给定数组元素提供了太多初始化值，MASM会报告错误。如果提供的初始化值太少，MASM会默默地将其余数组项填充为0值：
- en: '[PRE105]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This example initializes `a.aryField1` with `{1,2,3,4,0,0,0,0}` and initializes
    `a.aryField2` with `{1,2,3,4}`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例将`a.aryField1`初始化为`{1,2,3,4,0,0,0,0}`，并将`a.aryField2`初始化为`{1,2,3,4}`。
- en: 'If the field is an array of bytes, you can substitute a character string (with
    no more characters than the array size) for the list of byte values:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字段是字节数组，你可以用字符字符串（其字符数不超过数组大小）来替代字节值列表：
- en: '[PRE106]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: If you supply too few characters, MASM will fill out the rest of the byte array
    with 0 bytes; too many characters produce an error.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的字符数过少，MASM会用0字节填充字节数组的其余部分；如果字符数过多，则会产生错误。
- en: 4.11.5 Arrays of Structs
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.11.5 结构体数组
- en: 'It is a perfectly reasonable operation to create an array of structures. To
    do so, you create a `struct` type and then use the standard array declaration
    syntax. The following example demonstrates how you could do this:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个结构体数组是完全合理的操作。为此，你需要创建一个`struct`类型，然后使用标准的数组声明语法。以下示例演示了如何做到这一点：
- en: '[PRE107]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'To access an element of this array, you use the standard array-indexing techniques.
    Because `recArray` is a single-dimensional array, you’d compute the address of
    an element of this array by using the formula `base_address` `+` `index` `* lengthof(recElement)`.
    For example, to access an element of `recArray`, you’d use code like the following:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问该数组的元素，你需要使用标准的数组索引技术。由于`recArray`是一个一维数组，你可以通过使用公式`base_address` `+` `index`
    `* lengthof(recElement)`来计算该数组元素的地址。例如，要访问`recArray`的一个元素，你可以使用如下代码：
- en: '[PRE108]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The index specification follows the entire variable name; remember, this is
    assembly, not a high-level language (in a high-level language, you’d probably
    use `recArray[i].someField`).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 索引规范跟随整个变量名称；请记住，这里是汇编语言，不是高级语言（在高级语言中，你可能会使用`recArray[i].someField`）。
- en: 'Naturally, you can create multidimensional arrays of records as well. You would
    use the row-major or column-major order functions to compute the address of an
    element within such records. The only thing that really changes (from the discussion
    of arrays) is that the size of each element is the size of the record object:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，你也可以创建多维记录数组。你需要使用行主序或列主序函数来计算记录中元素的地址。唯一的变化（与数组讨论中的不同）是每个元素的大小是记录对象的大小：
- en: '[PRE109]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 4.11.6 Aligning Fields Within a Record
  id: totrans-485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.11.6 记录内字段对齐
- en: 'To achieve maximum performance in your programs, or to ensure that MASM’s structures
    properly map to records or structures in a high-level language, you will often
    need to be able to control the alignment of fields within a record. For example,
    you might want to ensure that a double-word field’s offset is a multiple of four.
    You can use the `align` directive to do this. The following creates a structure
    with unaligned fields:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在程序中实现最大性能，或者确保 MASM 的结构正确映射到高级语言中的记录或结构，你通常需要能够控制记录中字段的对齐方式。例如，你可能希望确保双字字段的偏移量是四的倍数。你可以使用`align`指令来做到这一点。下面创建了一个具有未对齐字段的结构：
- en: '[PRE110]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Here’s how MASM organizes this structure’s fields in memory:^([15](#c04-footnote-17))
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 MASM 在内存中组织该结构字段的方式：^([15](#c04-footnote-17))
- en: '[PRE111]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: As you can see from this example, the `d`and `w` fields are both aligned on
    odd offsets, which may result in slower performance. Ideally, you would like `d`
    to be aligned on a double-word offset (multiple of four) and `w` aligned on an
    even offset.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这个示例中看到的，`d`和`w`字段都被对齐到奇数偏移量，这可能导致性能较慢。理想情况下，你希望`d`对齐到双字偏移（四的倍数），而`w`对齐到偶数偏移。
- en: 'You can fix this problem by adding `align` directives to the structure, as
    follows:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向结构中添加`align`指令来解决这个问题，如下所示：
- en: '[PRE112]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, MASM uses the following offsets for each of these fields:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，MASM 为这些字段使用以下偏移量：
- en: '[PRE113]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: As you can see, `d` is now aligned on a 4-byte offset, and `w` is aligned at
    an even offset.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`d`现在对齐到了4字节偏移，而`w`对齐到了偶数偏移。
- en: 'MASM provides one additional option that lets you automatically align objects
    in a `struct` declaration. If you supply a value (which must be 1, 2, 4, 8, or
    16) as the operand to the `struct` statement, MASM will automatically align all
    fields in the structure to an offset that is a multiple of that field’s size or
    to the value you specify as the operand, *whichever is smaller*. Consider the
    following example:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 提供了一个额外的选项，允许你在`struct`声明中自动对齐对象。如果你为`struct`语句提供一个值（必须是1、2、4、8或16），MASM
    将自动将结构中的所有字段对齐到一个偏移量，该偏移量是字段大小的倍数或你作为操作数指定的值，*以较小者为准*。考虑以下示例：
- en: '[PRE114]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Here’s the alignment MASM produces for this structure:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 MASM 为此结构生成的对齐方式：
- en: '[PRE115]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Note that MASM properly aligns `d` on a dword boundary and `w` on a word boundary
    (within the structure). Also note that `w` is not aligned on a dword boundary
    (even though the struct operand was 4). This is because MASM uses the smaller
    of the operand or the field’s size as the alignment value (and `w`’s size is 2).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，MASM 正确地将`d`对齐到双字边界，将`w`对齐到字边界（在结构体内）。还请注意，`w`没有对齐到双字边界（即使结构体操作数是4）。这是因为
    MASM 使用操作数或字段大小中的较小者作为对齐值（而`w`的大小是2）。
- en: 4.12 Unions
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.12 联合体
- en: 'A record/struct definition assigns different offsets to each field in the record
    according to the size of those fields. This behavior is quite similar to the allocation
    of memory offsets in a `.data?`, `.data`, or `.const` section. MASM provides a
    second type of structure declaration, the `union`, that does not assign different
    addresses to each object; instead, each field in a `union` declaration has the
    same offset: zero. The following example demonstrates the syntax for a `union`
    declaration:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 记录/结构定义根据字段的大小为记录中的每个字段分配不同的偏移量。这种行为与在`.data?`、`.data`或`.const`部分分配内存偏移量非常相似。MASM
    提供了第二种结构声明类型，即`union`，它不会为每个对象分配不同的地址；相反，`union`声明中的每个字段都具有相同的偏移量：零。下面的示例演示了`union`声明的语法：
- en: '[PRE116]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Yes, it seems rather weird that MASM still uses `ends` for the end of the union
    (rather than `endu`). If this really bothers you, just create a `textequ` for
    `endu` as follows:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，似乎很奇怪，MASM 仍然使用`ends`来标记`union`的结束（而不是`endu`）。如果这真的让你困扰，只需像下面这样为`endu`创建一个`textequ`：
- en: '[PRE117]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Now, you can use `endu` to your heart’s content to mark the end of a union.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以尽情使用`endu`来标记`union`的结束。
- en: 'You access the fields of a `union` exactly the same way you access the fields
    of a struct: using dot notation and field names. The following is a concrete example
    of a `union` type declaration and a variable of the `union` type:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 你访问`union`的字段与访问结构体字段的方式完全相同：使用点符号和字段名称。以下是一个`union`类型声明及`union`类型变量的具体示例：
- en: '[PRE118]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The important thing to note about union objects is that all the fields of a
    union have the same offset in the structure. In the preceding example, the `number.u`,
    `number.i`, and `number.q` fields all have the same offset: zero. Therefore, the
    fields of a union overlap in memory; this is similar to the way the x86-64 8-,
    16-, 32-, and 64-bit general-purpose registers overlap one another. Usually, you
    may access only one field of a union at a time; you do not manipulate separate
    fields of a particular union variable concurrently because writing to one field
    overwrites the other fields. In the preceding example, any modification of `number.u`
    would also change `number.i` and `number.q`.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，联合体对象的所有字段在结构中具有相同的偏移量。在前面的示例中，`number.u`、`number.i` 和 `number.q` 字段都有相同的偏移量：零。因此，联合体的字段在内存中是重叠的；这类似于
    x86-64 8 位、16 位、32 位和 64 位通用寄存器之间的重叠。通常，你一次只能访问一个联合体字段；你不能同时操作特定联合体变量的多个字段，因为写入一个字段会覆盖其他字段。在前面的示例中，任何对
    `number.u` 的修改也会改变 `number.i` 和 `number.q`。
- en: 'Programmers typically use unions for two reasons: to conserve memory or to
    create aliases. Memory conservation is the intended use of this data structure
    facility. To see how this works, let’s compare the `numeric` `union` in the preceding
    example with a corresponding structure type:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员通常出于两个原因使用联合体：节省内存或创建别名。节省内存是该数据结构功能的预期用途。为了了解其工作原理，让我们将前面示例中的 `numeric`
    `union` 与相应的结构类型进行比较：
- en: '[PRE119]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: If you declare a variable, say `n`, of type `numericRec`, you access the fields
    as `n.i`, `n.u`, and `n.q` exactly as though you had declared the variable to
    be type `numeric`. The difference between the two is that `numericRec` variables
    allocate separate storage for each field of the structure, whereas `numeric` (union)
    objects allocate the same storage for all fields. Therefore, `sizeof numericRec`
    is 16 because the record contains two double-word fields and a quad-word (`real64`)
    field. The `sizeof numeric`, however, is 8\. This is because all the fields of
    a union occupy the same memory locations, and the size of a union object is the
    size of the largest field of that object (see [Figure 4-8](#figure4-8)).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声明一个变量，比如 `n`，类型为 `numericRec`，你可以像声明为 `numeric` 类型一样，通过 `n.i`、`n.u` 和 `n.q`
    来访问各个字段。二者的区别在于，`numericRec` 类型的变量为每个字段分配了独立的存储空间，而 `numeric`（联合体）对象为所有字段分配相同的存储空间。因此，`sizeof
    numericRec` 的值为 16，因为该记录包含两个双字字段和一个四字字段（`real64`）。然而，`sizeof numeric` 的值为 8。原因是联合体的所有字段都占用相同的内存位置，联合体对象的大小是该对象最大字段的大小（见
    [图 4-8](#figure4-8)）。
- en: '![f04008](image_fi/501089c04/f04008.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![f04008](image_fi/501089c04/f04008.png)'
- en: 'Figure 4-8: Layout of a `union` versus a `struct` variable'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-8：`union` 与 `struct` 变量的布局
- en: 'In addition to conserving memory, programmers often use unions to create aliases
    in their code. As you may recall, an *alias* is a different name for the same
    memory object. Aliases are often a source of confusion in a program, so you should
    use them sparingly; sometimes, however, using an alias can be quite convenient.
    For example, in one section of your program, you might need to constantly use
    type coercion to refer to an object using a different type. Although you can use
    a MASM `textequ` to simplify this process, another way to do this is to use a
    `union` variable with the fields representing the different types you want to
    use for the object. As an example, consider the following code:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 除了节省内存，程序员通常还使用联合体在代码中创建别名。如你所记得，*别名*是同一内存对象的不同名称。别名通常是程序中的一种混淆源，因此你应该谨慎使用它们；然而，有时使用别名非常方便。例如，在程序的某个部分，你可能需要不断使用类型强制转换来以不同类型引用一个对象。尽管你可以使用
    MASM 的 `textequ` 来简化这个过程，另一种方法是使用一个 `union` 变量，并为你想要使用的不同类型创建相应的字段。例如，考虑以下代码：
- en: '[PRE120]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'With a declaration like this, you can manipulate an `uns32` object by accessing
    `v.u`. If, at some point, you need to treat the LO byte of this `dword` variable
    as a character, you can do so by accessing the `v.chr` variable; for example:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的声明，你可以通过访问 `v.u` 来操作一个 `uns32` 对象。如果你在某个时刻需要将该 `dword` 变量的低字节视为字符，你可以通过访问
    `v.chr` 变量来实现；例如：
- en: '[PRE121]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: You can use unions exactly the same way you use structures in a MASM program.
    In particular, `union` declarations may appear as fields in structures, `struct`
    declarations may appear as fields in unions, `array` declarations may appear within
    unions, you can create arrays of unions, and so on.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像在 MASM 程序中使用结构体一样使用联合体。特别是，`union` 声明可以作为结构体中的字段，`struct` 声明可以作为联合体中的字段，`array`
    声明可以出现在联合体中，你可以创建联合体的数组，等等。
- en: 4.12.1 Anonymous Unions
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.12.1 匿名联合体
- en: 'Within a `struct` declaration, you can place a `union` declaration without
    specifying a field name for the `union` object. The following example demonstrates
    the syntax:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `struct` 声明中，你可以放置一个 `union` 声明，而无需为 `union` 对象指定字段名称。以下示例演示了语法：
- en: '[PRE122]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Whenever an anonymous union appears within a record, you can access the fields
    of the union as though they were unenclosed fields of the record. In the preceding
    example, for instance, you would access `v`’s `u`and `i` fields by using the syntax
    `v.u` and `v.i`, respectively. The `u` and `i` fields have the same offset in
    the record (8, because they follow a `real8` object). The fields of `v` have the
    following offsets from `v`’s base address:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 每当匿名联合体出现在记录中时，你可以像访问记录中的未封闭字段一样访问联合体的字段。例如，在前面的示例中，你可以通过语法 `v.u` 和 `v.i` 来访问
    `v` 的 `u` 和 `i` 字段。`u` 和 `i` 字段在记录中的偏移量相同（8，因为它们紧跟在 `real8` 对象之后）。`v` 的字段相对于 `v`
    基地址的偏移量如下：
- en: '[PRE123]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '`sizeof(v)` is 20 because the `u` and `i` fields consume only 4 bytes.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizeof(v)` 的值为 20，因为 `u` 和 `i` 字段仅占用 4 个字节。'
- en: MASM also allows anonymous structures within unions. Please see the MASM documentation
    for more details, though the syntax and usage are identical to anonymous unions
    within structures.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 还允许在联合体中使用匿名结构。更多详细信息请参阅 MASM 文档，语法和用法与结构体中的匿名联合体相同。
- en: 4.12.2 Variant Types
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.12.2 变体类型
- en: One big use of unions in programs is to create *variant* types. A variant variable
    can change its type dynamically while the program is running. A variant object
    can be an integer at one point in the program, switch to a string at a different
    part of the program, and then change to a real value at a later time. Many very
    high-level language (VHLL) systems use a dynamic type system (that is, variant
    objects) to reduce the overall complexity of the program; indeed, proponents of
    many VHLLs insist that the use of a dynamic typing system is one of the reasons
    you can write complex programs with so few lines of code using those languages.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 联合体在程序中的一个重要用途是创建 *变体* 类型。变体变量可以在程序运行时动态改变其类型。一个变体对象在程序的某一点可以是整数，在程序的另一个部分可以切换为字符串，之后再变成实数值。许多高级语言（VHLL）系统使用动态类型系统（即变体对象）来减少程序的整体复杂性；事实上，许多
    VHLL 的支持者坚信，动态类型系统的使用是你能用如此少的代码行编写复杂程序的原因之一。
- en: Of course, if you can create variant objects in a VHLL, you can certainly do
    it in assembly language. In this section, we’ll look at how we can use the union
    structure to create variant types.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你可以在 VHLL 中创建变体对象，那么在汇编语言中当然也可以做到这一点。在本节中，我们将探讨如何使用联合体结构来创建变体类型。
- en: At any one given instant during program execution, a variant object has a specific
    type, but under program control, the variable can switch to a different type.
    Therefore, when the program processes a variant object, it must use an `if` statement
    or `switch` statement (or something similar) to execute different instructions
    based on the object’s current type. VHLLs do this transparently.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行的任何时刻，一个变体对象具有特定的类型，但在程序控制下，变量可以切换为不同的类型。因此，当程序处理一个变体对象时，必须使用 `if` 语句或
    `switch` 语句（或类似的结构）根据对象的当前类型执行不同的指令。高级语言（VHLL）系统会透明地处理这一过程。
- en: 'In assembly language, you have to provide the code to test the type yourself.
    To achieve this, the variant type needs additional information beyond the object’s
    value. Specifically, the variant object needs a field that specifies the current
    type of the object. This field (often known as the *tag* field) is an enumerated
    type or integer that specifies the object’s type at any given instant. The following
    code demonstrates how to create a variant type:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，你必须自己提供代码来测试类型。为了实现这一点，变体类型需要额外的信息，除了对象的值之外。具体而言，变体对象需要一个字段来指定对象的当前类型。这个字段（通常称为
    *tag* 字段）是一个枚举类型或整数，用来指定对象在任何给定时刻的类型。以下代码演示了如何创建一个变体类型：
- en: '[PRE124]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The program would test the `v.tag` field to determine the current type of the
    `v` object. Based on this test, the program would manipulate the `v.i`, `v.u`,
    or `v.r` field.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将测试 `v.tag` 字段以确定 `v` 对象的当前类型。根据这个测试，程序将操作 `v.i`、`v.u` 或 `v.r` 字段。
- en: Of course, when operating on variant objects, the program’s code must constantly
    be testing the tag field and executing a separate sequence of instructions for
    `dword`, `sdword`, or `real8` values. If you use the variant fields often, it
    makes a lot of sense to write procedures to handle these operations for you (for
    example, `vadd`, `vsub`, `vmul`, and `vdiv`).
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在操作变体对象时，程序的代码必须不断测试标签字段，并为 `dword`、`sdword` 或 `real8` 值执行不同的指令序列。如果你经常使用变体字段，那么编写程序处理这些操作（例如
    `vadd`、`vsub`、`vmul` 和 `vdiv`）是非常有意义的。
- en: 4.13 Microsoft ABI Notes
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.13 微软 ABI 注释
- en: 'The Microsoft ABI expects fields of an array to be aligned on their *natural*
    size: the offset from the beginning of the structure to a given field must be
    a multiple of the field’s size. On top of this, the whole structure must be aligned
    at a memory address that is a multiple of the size of the largest object in the
    structure (up to 16 bytes). Finally, the entire structure’s size must be a multiple
    of the largest element in the structure (you must add padding bytes to the end
    of the structure to appropriately fill out the structure’s size).'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 ABI 期望数组字段按照它们的*自然*大小对齐：从结构开始到某一字段的偏移量必须是该字段大小的倍数。除此之外，整个结构必须对齐到一个内存地址，该地址是结构中最大对象大小的倍数（最多16字节）。最后，整个结构的大小必须是结构中最大元素大小的倍数（你必须在结构末尾添加填充字节以适当填充结构的大小）。
- en: The Microsoft ABI expects arrays to begin at an address in memory that is a
    multiple of the element size. For example, if you have an array of 32-bit objects,
    the array must begin on a 4-byte boundary.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 ABI 期望数组从内存中一个是元素大小的倍数的地址开始。例如，如果你有一个32位对象的数组，该数组必须从4字节边界开始。
- en: Of course, if you’re not passing an array or structure data to another language
    (you’re only processing the struct or array in your assembly code), you can align
    (or misalign) the data however you want.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你不将数组或结构数据传递到另一种语言（你只在汇编代码中处理结构或数组），你可以随意对数据进行对齐（或不对齐）。
- en: 4.14 For More Information
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.14 获取更多信息
- en: For additional information about data structure representation in memory, consider
    reading my book *Write Great Code*, Volume 1(No Starch Press, 2004). For an in-depth
    discussion of data types, consult a textbook on data structures and algorithms.
    Of course, the MASM online documentation (at [https://www.microsoft.com/](https://www.microsoft.com/))
    is a good source of information.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 关于内存中数据结构表示的更多信息，考虑阅读我的书 *编写高效代码*，第一卷（No Starch Press，2004）。如果你想深入讨论数据类型，可以查阅一本关于数据结构和算法的教科书。当然，MASM
    在线文档（在 [https://www.microsoft.com/](https://www.microsoft.com/)）是一个很好的信息来源。
- en: 4.15 Test Yourself
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.15 测试自己
- en: What is the two-operand form of the `imul` instruction that multiplies a register
    by a constant?
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`imul` 指令的两个操作数形式是什么，它将一个寄存器与常量相乘？'
- en: What is the three-operand form of the `imul` instruction that multiplies a register
    by a constant and leaves the result in a destination register?
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`imul` 指令的三个操作数形式是什么，它将一个寄存器与常量相乘，并将结果保存在目标寄存器中？'
- en: What is the syntax for the `imul` instruction that multiplies one register by
    another?
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`imul` 指令的语法是什么，它将一个寄存器与另一个寄存器相乘？'
- en: What is a manifest constant?
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是清单常量？
- en: Which directive(s) would you use to create a manifest constant?
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪个指令来创建清单常量？
- en: What is the difference between a text equate and a numeric equate?
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本等式和数字等式之间有什么区别？
- en: Explain how you would use an equate to define literal strings whose length is
    greater than eight characters.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释如何使用等式定义长度大于八个字符的字面字符串。
- en: What is a constant expression?
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是常量表达式？
- en: What operator would you use to determine the number of data elements in the
    operand field of a byte directive?
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪个运算符来确定字节指令操作数字段中的数据元素个数？
- en: What is the location counter?
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是位置计数器？
- en: What operator(s) return(s) the current location counter?
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个运算符返回当前的位置计数器？
- en: How would you compute the number of bytes between two declarations in the `.data`
    section?
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何计算 `.data` 部分中两个声明之间的字节数？
- en: How would you create a set of enumerated data constants using MASM?
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用 MASM 创建一组枚举数据常量？
- en: How do you define your own data types using MASM?
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用 MASM 定义你自己的数据类型？
- en: What is a pointer (how is it implemented)?
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是指针（它是如何实现的）？
- en: How do you dereference a pointer in assembly language?
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在汇编语言中解引用一个指针？
- en: How do you declare pointer variables in assembly language?
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在汇编语言中声明指针变量？
- en: What operator would you use to obtain the address of a static data object (for
    example, in the `.data` section)?
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用什么操作符来获取静态数据对象的地址（例如，在 `.data` 区段中）？
- en: What are the five common problems encountered when using pointers in a program?
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指针时，程序中常见的五个问题是什么？
- en: What is a dangling pointer?
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是悬挂指针？
- en: What is a memory leak?
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是内存泄漏？
- en: What is a composite data type?
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是复合数据类型？
- en: What is a zero-terminated string?
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是零终止字符串？
- en: What is a length-prefixed string?
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是长度前缀字符串？
- en: What is a descriptor-based string?
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是基于描述符的字符串？
- en: What is an array?
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是数组？
- en: What is the base address of an array?
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组的基地址是什么？
- en: Provide an example of an array declaration using the `dup` operator.
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个使用 `dup` 操作符声明数组的例子。
- en: Describe how to create an array whose elements you initialize at assembly time.
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述如何创建一个在汇编时初始化元素的数组。
- en: What is the formula for accessing elements of a
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问一个
- en: Single-dimension array `dword A[10]`?
  id: totrans-572
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一维数组 `dword A[10]`？
- en: Two-dimensional array `word W[4, 8]`?
  id: totrans-573
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二维数组 `word W[4, 8]` 的公式是什么？
- en: Three-dimensional array `real8 R[2, 4, 6]`?
  id: totrans-574
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三维数组 `real8 R[2, 4, 6]`？
- en: What is row-major order?
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是行优先顺序？
- en: What is column-major order?
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是列优先顺序？
- en: Provide an example of a two-dimensional array declaration (word array `W[4,
    8]`) using nested `dup` operators.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个使用嵌套 `dup` 操作符声明二维数组（`word` 数组 `W[4, 8]`）的例子。
- en: What is a record/struct?
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是记录/结构体？
- en: What MASM directives do you use to declare a record data structure?
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MASM 中，使用哪些指令声明记录数据结构？
- en: What operator do you use to access fields of a record/struct?
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用什么操作符来访问记录/结构体的字段？
- en: What is a union?
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是联合？
- en: What directives do you use to declare unions in MASM?
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MASM 中，声明联合使用哪些指令？
- en: What is the difference between the memory organization of fields in a union
    versus those in a record/struct?
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联合和记录/结构体中字段的内存组织有什么区别？
- en: What is an anonymous union in a struct?
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构体中的匿名联合是什么？
