- en: Chapter 5. Bigger or Trickier Networks
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 5 章：更大或更复杂的网络
- en: '![Bigger or Trickier Networks](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![更大或更复杂的网络](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
- en: In this chapter, we’ll build on the material in previous chapters to meet the
    real-life challenges of both large and small networks with relatively demanding
    applications or users. The sample configurations in this chapter are based on
    the assumption that your packet-filtering setups will need to accommodate services
    you run on your local network. We’ll mainly look at this challenge from a Unix
    perspective, focusing on SSH, email, and Web services (with some pointers on how
    to take care of other services).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在前几章的基础上，解决大中型网络中相对要求较高的应用或用户的现实挑战。本章中的示例配置假设你的数据包过滤设置需要容纳你在本地网络上运行的服务。我们将主要从
    Unix 的角度来审视这一挑战，重点关注 SSH、电子邮件和 Web 服务（并提供一些关于如何处理其他服务的提示）。
- en: This chapter is about the things to do when you need to combine packet filtering
    with services that must be accessible outside your local network. How much this
    complicates your rule sets will depend on your network design and, to a certain
    extent, on the number of routable addresses you have available. We’ll begin with
    configurations for official, routable IPv4 addresses as well as the generally
    roomier IPv6 address ranges. Then, we’ll move on to situations with as few as
    one routable IPv4 address and the PF-based work-arounds that make the services
    usable even under these restrictions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了当你需要将数据包过滤与必须在本地网络外部可访问的服务结合使用时需要做的事情。这将如何增加你的规则集的复杂性，取决于你的网络设计，并在一定程度上取决于你拥有的可路由地址数量。我们将首先讨论官方的、可路由的
    IPv4 地址配置，以及通常较为宽松的 IPv6 地址范围。然后，我们将讨论即使只有一个可路由的 IPv4 地址时的情况，并介绍基于 PF 的解决方案，这些解决方案即使在这些限制下也能使服务可用。
- en: 'A Web Server and Mail Server on the Inside: Routable IPv4 Addresses'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部的 Web 服务器和邮件服务器：可路由的 IPv4 地址
- en: How complicated is your network? How complicated does it need to be?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你的网络有多复杂？它需要多复杂？
- en: 'We’ll start with the baseline scenario of the sample clients from [Chapter 3](ch03.html
    "Chapter 3. Into the Real World"). We set up the clients behind a basic PF firewall
    and give them access to a range of services hosted elsewhere but no services running
    on the local network. These clients get three new neighbors: a mail server, a
    Web server, and a file server. In this scenario, we use official, routable IPv4
    addresses because it makes life a little easier. Another advantage of this approach
    is that with routable addresses, we can let two of the new machines run DNS for
    our *example.com* domain: one as the master and the other as an authoritative
    slave.^([[25](#ftn.ch05fn01)]) And as you’ll see, adding IPv6 addresses and running
    a dual-stack network won’t necessarily make your rule set noticeably more complicated.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从[第 3 章](ch03.html "第 3 章：进入现实世界")中的示例客户端的基础场景开始。我们将客户端设置在一个基础的 PF 防火墙后，并让它们访问托管在其他地方的各种服务，但本地网络上没有运行任何服务。这些客户端将获得三个新的邻居：一个邮件服务器、一个
    Web 服务器和一个文件服务器。在这个场景中，我们使用官方的、可路由的 IPv4 地址，因为这样会稍微简化工作。另一种优势是，使用可路由地址时，我们可以让两台新机器为我们的
    *example.com* 域名提供 DNS 服务：一个作为主服务器，另一个作为权威从属服务器。^([[25](#ftn.ch05fn01)]) 正如你将看到的，添加
    IPv6 地址并运行双栈网络不一定会使你的规则集变得显著复杂。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*For DNS, it always makes sense to have at least one authoritative slave server
    somewhere outside your own network (in fact, some top-level domains won’t let
    you register a domain without it). You may also want to arrange for a backup mail
    server to be hosted elsewhere. Keep these things in mind as you build your network.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于 DNS，至少在你的网络外部有一个权威的从属服务器总是有意义的（事实上，一些顶级域名不允许你在没有它的情况下注册域名）。你可能还希望安排一个备份邮件服务器托管在其他地方。在构建网络时，请牢记这些事项。*'
- en: At this stage, we keep the physical network layout fairly simple. We put the
    new servers in the same local network as the clients—possibly in a separate server
    room but certainly on the same network segment or switch as the clients. Conceptually,
    the new network looks something like [Figure 5-1](ch05.html#basic_network_with_servers_and_clients_o
    "Figure 5-1. A basic network with servers and clients on the inside").
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，我们将物理网络布局保持得相对简单。我们将新的服务器放在与客户端相同的本地网络中——可能在一个单独的服务器房间中，但肯定与客户端位于同一网络段或交换机上。从概念上讲，新的网络看起来像是[图
    5-1](ch05.html#basic_network_with_servers_and_clients_o "图 5-1. 带有服务器和客户端的基本网络")。
- en: With the basic parameters for the network in place, we can start setting up
    a sensible rule set for handling the services we need. Once again, we start from
    the baseline rule set and add a few macros for readability.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络的基本参数设置完成后，我们可以开始为所需的服务设置一个合理的规则集。再次强调，我们从基础规则集开始，并添加一些宏以提高可读性。
- en: 'The macros we need come rather naturally from the specifications:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的宏自然来自于规范：
- en: 'Web server:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 服务器：
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Web server services:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 服务器服务：
- en: '[PRE1]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Mail server:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮件服务器：
- en: '[PRE2]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![A basic network with servers and clients on the inside](httpatomoreillycomsourcenostarchimages2127153.png.jpg)Figure 5-1. A
    basic network with servers and clients on the inside'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![内部有服务器和客户端的基本网络](httpatomoreillycomsourcenostarchimages2127153.png.jpg)图
    5-1. 内部有服务器和客户端的基本网络'
- en: 'Mail server services:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮件服务器服务：
- en: '[PRE3]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Name servers:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域名服务器：
- en: '[PRE4]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*At this point, you’ve probably noticed that both the IPv4 and IPv6 addresses
    for our servers are placed fairly close together within their respective address
    ranges. Some schools of thought hold that in the case of IPv6, each interface
    should be allocated at least a /64 range if your total allocation can bear it.
    Others have advocated more modest allocations. The IETF’s current best practice
    document on the matter is RFC6177, available from the IETF website* ([http://www.ietf.org](http://www.ietf.org)).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*此时，您可能已经注意到我们的服务器的 IPv4 和 IPv6 地址都比较靠近各自的地址范围。某些思潮认为，在 IPv6 的情况下，每个接口如果总分配量允许，应该分配至少一个
    /64 范围。其他人则提倡更为适度的分配。IETF 关于此问题的当前最佳实践文档是 RFC6177，可以从 IETF 网站获取* ([http://www.ietf.org](http://www.ietf.org)).'
- en: 'We assume that the file server doesn’t need to be accessible to the outside
    world, unless we choose to set it up with a service that needs to be visible outside
    the local network, such as an authoritative slave name server for our domain.
    Then, with the macros in hand, we add the `pass` rules. Starting with the Web
    server, we make it accessible to the world with the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设文件服务器不需要对外界可访问，除非我们选择为它设置一个需要在本地网络外部可见的服务，例如作为我们域的权威从属域名服务器。然后，在手头有了宏之后，我们添加
    `pass` 规则。从 Web 服务器开始，我们使用以下方式让它对外界可访问：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Is Synproxy Worth the Trouble?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SYN 代理值得一试吗？
- en: Over the years, the `synproxy state` option has received a lot of attention
    as a possible bulwark against ill-intentioned traffic from the outside. Specifically,
    the `synproxy state` option was intended to protect against SYN-flood attacks
    that could lead to resource exhaustion at the back end.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，`synproxy state` 选项作为一种防御外部恶意流量的可能屏障，受到了大量关注。具体来说，`synproxy state` 选项旨在防御可能导致后端资源耗尽的
    SYN 洪水攻击。
- en: 'It works like this: When a new connection is created, PF normally lets the
    communication partners handle the connection setup themselves, simply passing
    the packets on if they match a `pass` rule. With `synproxy` enabled, PF handles
    the initial connection setup and hands over the connection to the communication
    partners only once it’s properly established, essentially creating a buffer between
    the communication partners. The SYN proxying is slightly more expensive than the
    default `keep state`, but not necessarily noticeably so on reasonably scaled equipment.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它是这样工作的：当创建一个新连接时，PF 通常让通信伙伴自行处理连接设置，只要数据包匹配 `pass` 规则，就简单地将其传递。启用 `synproxy`
    后，PF 处理初始连接设置，只有在连接正确建立后才将连接交给通信伙伴，基本上在通信伙伴之间创建了一个缓冲区。SYN 代理比默认的 `keep state`
    稍微昂贵一些，但在合理规模的设备上不一定会显著感觉到。
- en: The potential downsides become apparent in load-balancing setups where a SYN-proxying
    PF could accept connections that the backend isn’t ready to accept, in some cases
    short-circuiting the redundancy by setting up connections to hosts other than
    those the load-balancing logic would have selected. The classic example here is
    a pool of HTTP servers with round-robin DNS. But the problem becomes especially
    apparent in protocols like SMTP, where the built-in redundancy dictates (by convention,
    at least—the actual RFC is a bit ambiguous) that if a primary mail exchanger isn’t
    accepting connections, you should try a secondary instead.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在负载均衡设置中，潜在的缺点变得显而易见，其中一个 SYN 代理 PF 可能会接受后端尚未准备好接受的连接，在某些情况下通过将连接设置到负载均衡逻辑原本不会选择的主机上，从而短路冗余。这里的经典例子是一个使用轮询
    DNS 的 HTTP 服务器池。但这个问题在像 SMTP 这样的协议中变得尤为明显，因为内置的冗余机制规定（至少按惯例—实际的 RFC 有点模糊）如果主邮件交换器不接受连接，应该尝试一个次级邮件交换器。
- en: When considering a setup where `synproxy` seems attractive, keep these issues
    in mind and analyze the potential impact on your setup that would come from adding
    `synproxy` to the mix. If you conclude that SYN proxying is needed, simply tack
    on `synproxy state` at the end of the rules that need the option. The rule of
    thumb is, if you are under active attack, inserting the `synproxy` option may
    be useful as a temporary measure. Under normal circumstances, it isn’t needed
    as a permanent part of your configuration.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑一个`synproxy`看起来有吸引力的设置时，记住这些问题，并分析将`synproxy`添加到配置中可能对设置造成的影响。如果你认为需要使用 SYN
    代理，只需在需要该选项的规则末尾添加`synproxy state`。经验法则是，如果你正在遭受主动攻击，插入`synproxy`选项可能作为临时措施有用。在正常情况下，它不需要作为配置的永久部分。
- en: 'On a similar note, we let the world talk to the mail server:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们允许外部世界与邮件服务器进行通信：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This lets clients anywhere have the same access as the ones in your local network,
    including a few mail-retrieval protocols that may run without encryption. That’s
    common enough in the real world, but you might want to consider your options if
    you’re setting up a new network.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，任何地方的客户端都能与局域网中的客户端拥有相同的访问权限，包括一些可能未加密运行的邮件检索协议。这在现实世界中是常见的，但如果你正在设置一个新的网络，可能需要考虑你的选择。
- en: 'For the mail server to be useful, it needs to be able to send mail to hosts
    outside the local network, too:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让邮件服务器发挥作用，它也需要能够向局域网外的主机发送邮件：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Keep in mind that the rule set starts with a `block all` rule, which means that
    only the mail server is allowed to initiate SMTP traffic from the local network
    to the rest of the world. If any of the other hosts on the network need to send
    email to or receive email from the outside world, they need to use the designated
    mail server. This could be a good way to ensure, for example, that you make it
    as hard as possible for any spam-sending zombie machines that might turn up in
    your network to deliver their payloads.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，规则集以`block all`规则开始，这意味着只有邮件服务器被允许从局域网发起到外部世界的 SMTP 流量。如果网络上的其他主机需要向外界发送或接收邮件，它们需要使用指定的邮件服务器。这可能是一个很好的方法，确保例如你能尽可能让任何可能出现在网络中的垃圾邮件僵尸机难以投递其负载。
- en: 'Finally, the name servers need to be accessible to clients outside our network
    who look up the information about *example.com* and any other domains for which
    we answer authoritatively:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，名称服务器需要能够被外部网络中的客户端访问，这些客户端需要查找关于*example.com*以及我们权威回答的任何其他域的信息：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Having integrated all the services that need to be accessible from the outside
    world, our rule set ends up looking roughly like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在整合了所有需要从外部访问的服务后，我们的规则集大致如下所示：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is still a fairly simple setup, but unfortunately, it has one potentially
    troubling security disadvantage. The way this network is designed, the servers
    that offer services to the world at large are all *in the same local network*
    as your clients, and you’d need to restrict any internal services to only local
    access. In principle, this means that an attacker would need to compromise only
    one host in your local network to gain access to any resource there, putting the
    miscreant on equal footing with any user in your local network. Depending on how
    well each machine and resource are protected from unauthorized access, this could
    be anything from a minor annoyance to a major headache.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是一个相对简单的设置，但不幸的是，它有一个可能令人担忧的安全缺点。这个网络的设计方式是，所有为外界提供服务的服务器都与客户端位于*同一局域网*内，而你需要将任何内部服务限制为仅本地访问。原则上，这意味着攻击者只需要入侵你局域网中的一个主机，就能访问该局域网中的任何资源，从而使恶意者与你局域网中的任何用户处于平等地位。根据每台机器和资源对未经授权访问的保护程度，这可能从一个小麻烦到一个大问题不等。
- en: In the next section, we’ll look at some options for segregating the services
    that need to interact with the world at large from the local network.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨一些将需要与外界交互的服务与局域网隔离的选项。
- en: 'A Degree of Separation: Introducing the DMZ'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一定的隔离度：引入 DMZ（隔离区）
- en: In the previous section, you saw how to set up services on your local network
    and make them selectively available to the outside world through a sensible PF
    rule set. For more fine-grained control over access to your internal network,
    as well as the services you need to make it visible to the rest of the world,
    add a degree of physical separation. Even a separate *virtual local area network
    (VLAN)* will do nicely.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你已经学习了如何在本地网络上设置服务，并通过合理的PF规则集将它们选择性地公开给外部世界。为了更精细地控制对内部网络的访问，以及需要对外界可见的服务，可以增加一定程度的物理隔离。即使是一个单独的*虚拟局域网（VLAN）*也能很好地解决问题。
- en: 'Achieving the physical and logical separation is fairly easy: Simply move the
    machines that run the public services to a separate network that’s attached to
    a separate interface on the gateway. The net effect is a separate network that
    isn’t quite part of your local network but isn’t entirely in the public part of
    the Internet either. Conceptually, the segregated network looks like [Figure 5-2](ch05.html#network_with_the_servers_in_a_dmz
    "Figure 5-2. A network with the servers in a DMZ").'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实现物理和逻辑分离相当简单：只需将运行公共服务的机器移到一个连接到网关单独接口的网络中。其最终效果是创建一个独立的网络，它既不是你本地网络的一部分，也不完全属于互联网上的公共部分。从概念上讲，这个隔离的网络看起来像是[图5-2](ch05.html#network_with_the_servers_in_a_dmz
    "图5-2。具有服务器的DMZ网络")中所示。
- en: '![A network with the servers in a DMZ](httpatomoreillycomsourcenostarchimages2127155.png.jpg)Figure 5-2. A
    network with the servers in a DMZ'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![具有服务器的DMZ网络](httpatomoreillycomsourcenostarchimages2127155.png.jpg)图5-2。具有服务器的DMZ网络'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Think of this little network as a zone of relative calm between the territories
    of hostile factions. It’s no great surprise that a few years back, someone coined
    the phrase* demilitarized zone (DMZ) *to describe this type of configuration.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*把这个小网络看作是敌对派系领土之间相对平静的区域。几年前，有人创造了“*非军事区（DMZ）*”这一术语，用来描述这种配置。*'
- en: For address allocation, you can segment off an appropriately sized chunk of
    your official address space for the new DMZ network. Alternatively, you can move
    those parts of your network that don’t have a specific need to run with publicly
    accessible and routable IPv4 addresses into a NAT environment. Either way, you
    end up with at least one more interface in your filtering configuration. As you’ll
    see later, if you’re really short of official IPv4 addresses, it’s possible to
    run a DMZ setup in all-NAT environments as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于地址分配，你可以为新的DMZ网络隔离出一块适当大小的官方地址空间。或者，你可以将那些没有特定需求需要使用公开可访问和可路由的IPv4地址的网络部分，转移到NAT环境中。无论哪种方式，你最终都会在过滤配置中至少拥有一个额外的接口。正如你稍后将看到的，如果你的官方IPv4地址非常紧张，也可以在全NAT环境中运行DMZ设置。
- en: The adjustments to the rule set itself don’t need to be extensive. If necessary,
    you can change the configuration for each interface. The basic rule-set logic
    remains, but you may need to adjust the definitions of the macros (`webserver`,
    `mailserver`, `nameservers`, and possibly others) to reflect your new network
    layout.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对规则集本身的调整不需要太复杂。如果需要，你可以修改每个接口的配置。基本的规则集逻辑保持不变，但你可能需要调整宏的定义（`webserver`，`mailserver`，`nameservers`，以及可能的其他宏），以适应你的新网络布局。
- en: 'In our example, we could choose to segment off the part of our address ranges
    where we’ve already placed our servers. If we leave some room for growth, we can
    set up the IPv4 range for the new `dmz_if` on a /25 subnet with a network address
    and netmask of 192.0.2.128/255.255.255.128\. This leaves us with 192.0.2.129 through
    192.0.2.254 as the usable address range for hosts in the DMZ. As we’ve already
    placed our servers in the 2001:db8::baad:f00d: 0/112 network (with a measly 65,536
    addresses to play with), the easiest way forward for the IPv6 range is to segment
    off that network, too, and assign the interface facing the network an appropriate
    IPv6 address, like the one in [Figure 5-2](ch05.html#network_with_the_servers_in_a_dmz
    "Figure 5-2. A network with the servers in a DMZ").'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们可以选择将已经放置服务器的地址范围部分进行隔离。如果为扩展留出一些空间，我们可以为新的`dmz_if`设置IPv4范围，使用/25子网，其网络地址和子网掩码为192.0.2.128/255.255.255.128。这样，192.0.2.129到192.0.2.254将作为DMZ中主机可用的地址范围。由于我们已经将服务器放置在2001:db8::baad:f00d:0/112网络中（该网络有65,536个地址可供使用），对于IPv6范围来说，最简单的方式是也将该网络进行隔离，并为面向该网络的接口分配适当的IPv6地址，就像[图5-2](ch05.html#network_with_the_servers_in_a_dmz
    "图5-2。具有服务器的DMZ网络")中所示。
- en: With that configuration and no changes in the IP addresses assigned to the servers,
    you don’t really need to touch the rule set at all for the packet filtering to
    work after setting up a physically segregated DMZ. That’s a nice side effect,
    which could be due to either laziness or excellent long-range planning. Either
    way, it underlines the importance of having a sensible address-allocation policy
    in place.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该配置，并且没有更改分配给服务器的 IP 地址，你实际上不需要触碰规则集，只需在设置物理隔离的 DMZ 后，数据包过滤就能正常工作。这是一个很好的副作用，可能是由于懒惰或者是出色的长远规划。无论如何，它都强调了拥有合理地址分配策略的重要性。
- en: 'It might be useful to tighten up your rule set by editing your `pass` rules
    so the traffic to and from your servers is allowed to pass only on the interfaces
    that are actually relevant to the services:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑你的 `pass` 规则来严格限制规则集可能会很有用，这样流量进出服务器时只能通过与服务相关的接口：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You could choose to make the other `pass` rules that reference your local network
    interface-specific, too, but if you leave them intact, they’ll continue to work.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择使其他引用本地网络接口的 `pass` 规则也具有接口特定性，但如果你保持它们不变，它们将继续有效。
- en: 'Sharing the Load: Redirecting to a Pool of Addresses'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 负载共享：重定向到地址池
- en: Once you’ve set up services to be accessible to the world at large, one likely
    scenario is that over time, one or more of your services will grow more sophisticated
    and resource-hungry or simply attract more traffic than you feel comfortable serving
    from a single server.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了可以向全球提供访问的服务，一个可能的场景是，随着时间的推移，你的某些服务会变得更复杂、需要更多资源，或者只是吸引了比你希望单台服务器处理的更多流量。
- en: There are a number of ways to make several machines share the load of running
    a service, including ways to fine-tune the service itself. For the network-level
    load balancing, PF offers the basic functionality you need via redirection to
    tables or address pools. In fact, you can implement a form of load balancing without
    even touching your `pass` rules, at least if your environment is not yet dual-stack.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以使多台机器共享运行服务的负载，包括对服务本身进行微调的方式。对于网络级负载均衡，PF 提供了你所需的基本功能，通过重定向到表格或地址池。实际上，你可以在不触碰
    `pass` 规则的情况下实现一种负载均衡，至少如果你的环境还不是双栈的情况下。
- en: 'Take the Web server in our example. We already have the macro that represents
    a service, our Web server. For reasons that will become obvious in a moment, we
    need to reduce that macro to represent only the public IPv4 address (`webserver
    = "192.0.2.227"`), which, in turn, is associated with the hostname that your users
    have bookmarked, possibly *[www.example.com](http://www.example.com)*. When the
    time comes to share the load, set up the required number of identical, or at least
    equivalent, servers and then alter your rule set slightly to introduce the redirection.
    First, define a table that holds the addresses for your Web server pool’s IPv4
    addresses:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们示例中的 Web 服务器为例。我们已经有了表示服务的宏，我们的 Web 服务器。由于接下来将要讨论的原因，我们需要将该宏简化为只表示公共 IPv4
    地址（`webserver = "192.0.2.227"`），该地址与用户书签中可能标记的主机名（*例如：[www.example.com](http://www.example.com)*）相关联。当需要分担负载时，设置所需数量的相同或至少等效的服务器，然后稍微修改规则集以引入重定向。首先，定义一个表格，用于存储
    Web 服务器池的 IPv4 地址：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, perform the redirection:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行重定向：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Unlike the redirections in earlier examples, such as the FTP proxy in [Chapter 3](ch03.html
    "Chapter 3. Into the Real World"), this rule sets up all members of the `webpool`
    table as potential redirection targets for incoming connections intended for the
    `webports` ports on the `webserver` address. Each incoming connection that matches
    this rule is redirected to one of the addresses in the table, spreading the load
    across several hosts. You may choose to retire the original Web server once the
    switch to this redirection is complete, or you may let it be absorbed in the new
    Web server pool.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期示例中的重定向不同，比如 [第 3 章](ch03.html "第 3 章. 走向现实世界") 中的 FTP 代理，此规则将 `webpool`
    表中的所有成员设置为即将到来的连接的潜在重定向目标，这些连接目标是指向 `webserver` 地址上的 `webports` 端口。每个与此规则匹配的传入连接都会被重定向到表中的一个地址，从而将负载分散到多个主机上。完成此重定向切换后，你可以选择退休原
    Web 服务器，或者让其被新的 Web 服务器池吸收。
- en: 'On PF versions earlier than OpenBSD 4.7, the equivalent rule is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenBSD 4.7 之前的 PF 版本中，相应的规则如下：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In both cases, the `round-robin` option means that PF shares the load between
    the machines in the pool by cycling through the table of redirection addresses
    sequentially.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`round-robin` 选项意味着 PF 通过依次循环重定向地址表中的机器，来分担池中机器的负载。
- en: Some applications expect accesses from each individual source address to always
    go to the same host in the backend (for example, there are services that depend
    on client- or session-specific parameters that will be lost if new connections
    hit a different host in the backend). If your configuration needs to cater to
    such services, you can add the `sticky-address` option to make sure that new connections
    from a client are always redirected to the same machine behind the redirection
    as the initial connection. The downside to this option is that PF needs to maintain
    source-tracking data for each client, and the default value for maximum source
    nodes tracked is set at 10,000, which may be a limiting factor. (See [Chapter 10](ch10.html
    "Chapter 10. Getting Your Setup Just Right") for advice on adjusting this and
    similar limit values.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序期望每个单独的源地址的访问总是定向到后端的同一主机（例如，有些服务依赖于客户端或会话特定的参数，如果新连接访问不同的后端主机，这些参数将丢失）。如果你的配置需要支持这种服务，你可以添加
    `sticky-address` 选项，确保来自客户端的新连接始终定向到与初始连接相同的后端主机。使用此选项的缺点是，PF 需要为每个客户端维护源跟踪数据，而最大源节点跟踪的默认值是
    10,000，这可能成为一个限制因素。（有关调整此类限制值的建议，请参见[第 10 章](ch10.html "第 10 章. 调整你的设置")。）
- en: 'When even load distribution isn’t an absolute requirement, selecting the redirection
    address at `random` may be appropriate:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当负载分配的平衡不是绝对要求时，选择 `random` 的重定向地址可能是合适的：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*On pre–OpenBSD 4.7 PF versions, the `random` option isn’t supported for redirection
    to tables or lists of addresses.*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 OpenBSD 4.7 之前的 PF 版本中，`random` 选项不支持用于重定向到地址表或地址列表。*'
- en: Even organizations with large pools of official, routable IPv4 addresses have
    opted to introduce NAT between their load-balanced server pools and the Internet
    at large. This technique works equally well in various NAT-based setups, but moving
    to NAT offers some additional possibilities and challenges.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是拥有大量官方可路由 IPv4 地址的组织，也选择在其负载均衡服务器池与互联网之间引入 NAT。这种技术在各种基于 NAT 的设置中同样有效，但迁移到
    NAT 提供了一些额外的可能性和挑战。
- en: In order to accommodate an IPv4 and IPv6 dual-stack environment in this way,
    you’ll need to set up separate tables for address pools and separate `pass` or
    `match` rules with redirections for IPv4 and IPv6\. A single table of both IPv4
    and IPv6 addresses may sound like an elegant idea at first, but the simple redirection
    rules outlined here aren’t intelligent enough to make correct redirection decisions
    based on the address family of individual table entries.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以这种方式支持 IPv4 和 IPv6 双栈环境，你需要为地址池设置独立的表，并为 IPv4 和 IPv6 设置独立的 `pass` 或 `match`
    规则和重定向。虽然一开始听起来将 IPv4 和 IPv6 地址放在一个表中是一个优雅的想法，但这里概述的简单重定向规则并不智能到足以根据单个表条目的地址族做出正确的重定向决策。
- en: Getting Load Balancing Right with relayd
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 relayd 进行负载均衡
- en: After you’ve been running for a while with load balancing via round-robin redirection,
    you may notice that the redirection doesn’t automatically adapt to external conditions.
    For example, unless special steps are taken, if a host in the list of redirection
    targets goes down, traffic will still be redirected to the IP addresses in the
    list of possibilities.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过轮询重定向进行负载均衡运行一段时间后，你可能会注意到重定向不会自动适应外部条件。例如，除非采取特殊措施，否则如果重定向目标列表中的某个主机宕机，流量仍然会被重定向到可能的
    IP 地址列表中。
- en: Clearly, a monitoring solution is needed. Fortunately, the OpenBSD base system
    provides one. The relay daemon `relayd`^([[26](#ftn.ch05fn02)]) interacts with
    your PF configuration, providing the ability to weed out nonfunctioning hosts
    from your pool. Introducing `relayd` into your setup, however, may require some
    minor changes to your rule set.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，需要一个监控解决方案。幸运的是，OpenBSD 基础系统提供了一个。中继守护进程 `relayd`^([[26](#ftn.ch05fn02)])
    与你的 PF 配置交互，提供了从你的池中筛选掉不正常主机的功能。然而，将 `relayd` 引入你的设置可能需要对你的规则集做一些小的调整。
- en: The `relayd` daemon works in terms of two main classes of services that it refers
    to as *redirects* and *relays*. It expects to be able to add or subtract hosts’
    IP addresses to or from the PF tables it controls. The daemon interacts with your
    rule set through a special-purpose anchor named `relayd` (and in pre–OpenBSD 4.7
    versions, also a redirection anchor, `rdr-anchor`, with the same name).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`relayd`守护进程基于两类主要服务工作，分别称为*重定向*和*中继*。它期望能够将主机的IP地址添加到或从它控制的PF表中删除。该守护进程通过一个专门的锚点`relayd`与你的规则集交互（在OpenBSD
    4.7之前的版本中，还包含一个名为`rdr-anchor`的重定向锚点，名称相同）。'
- en: 'To see how we can make our sample configuration work a little better by using
    `relayd`, we’ll look back at the load-balancing rule set. Starting from the top
    of your *pf.conf* file, add the anchor for `relayd` to insert rules as needed:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看我们如何通过使用`relayd`使我们的示例配置更好，我们回顾一下负载均衡规则集。从*pf.conf*文件的顶部开始，添加`relayd`的锚点，以便根据需要插入规则：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On pre–OpenBSD 4.7 versions, you also need the redirection anchor:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenBSD 4.7之前的版本中，你还需要使用重定向锚点：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the load-balancing rule set, we had the following definition for our Web
    server pool:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在负载均衡规则集中，我们为Web服务器池定义了以下内容：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It has this `match` rule to set up the redirection:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个`match`规则来设置重定向：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Or on pre–OpenBSD 4.7 versions, you’d use the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在OpenBSD 4.7之前的版本中，你会使用以下配置：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To make this configuration work slightly better, we remove the redirection and
    the table (remember to take care of both sets in a dual-stack configuration),
    and we let `relayd` handle the redirection or redirections by setting up its own
    versions inside the anchor. (Don’t remove the `pass` rule, however, because your
    rule set will still need to have a `pass` rule that lets traffic flow to the IP
    addresses in `relayd`’s tables. If you had separate rules for your `inet` and
    `inet6` traffic, you may be able to merge those rules back into one.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个配置效果更好，我们移除重定向和表（记得在双栈配置中处理好这两个部分），并让`relayd`通过在锚点内设置自己的版本来处理重定向。 （不过，不要移除`pass`规则，因为你的规则集仍然需要一个`pass`规则，允许流量访问`relayd`表中的IP地址。如果你有针对`inet`和`inet6`流量的单独规则，你可能可以将这些规则合并回一个规则。）
- en: 'Once the *pf.conf* parts have been taken care of, we turn to `relayd`’s own
    *relayd.conf* configuration file. The syntax in this configuration file is similar
    enough to *pf.conf* to make it fairly easy to read and understand. First, we add
    the macro definitions we’ll be using later:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理了*pf.conf*的部分内容，我们转向`relayd`的*relayd.conf*配置文件。这个配置文件的语法与*pf.conf*类似，因此比较容易阅读和理解。首先，我们添加稍后将使用的宏定义：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All of these correspond to definitions we could have put in a *pf.conf* file.
    The default checking interval in `relayd` is 10 seconds, which means that a host
    could be down for almost 10 seconds before it’s taken offline. Being cautious,
    we’ll set the checking interval to 5 seconds to minimize visible downtime, with
    the following line:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都对应于我们可以在*pf.conf*文件中放置的定义。`relayd`的默认检查间隔是10秒，这意味着主机可能会停机近10秒钟，才会被标记为离线。为了小心起见，我们将检查间隔设置为5秒，以尽量减少可见的停机时间，配置如下：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we make a table called `webpool` that uses most of the macros:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个名为`webpool`的表，使用了大部分的宏：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For reasons we’ll return to shortly, we define one other table:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 出于稍后会讲到的原因，我们定义了另一个表：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At this point, we’re ready to set up the redirect:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一步，我们准备好设置重定向：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This redirect says that connections to port 80 should be redirected to the
    members of the `webpool` table. The `sticky-address` option has the same effect
    here as the `rdr-to` in PF rules: New connections from the same source IP address
    (within the time interval defined by the `timeout` value) are redirected to the
    same host in the backend pool as the previous ones.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重定向表示对端口80的连接应该被重定向到`webpool`表中的成员。`sticky-address`选项在这里与PF规则中的`rdr-to`效果相同：来自同一源IP地址的新连接（在由`timeout`值定义的时间间隔内）会被重定向到后端池中与之前相同的主机。
- en: The `relayd` daemon should check to see whether a host is available by asking
    it for the file */status.html*, using the protocol HTTP, and expecting the return
    code to be equal to 200\. This is the expected result for a client asking a running
    Web server for a file it has available.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`relayd`守护进程应检查主机是否可用，方法是请求文件*/status.html*，使用HTTP协议，并期望返回码为200\。这是客户端请求运行中的Web服务器提供其可用文件时的预期结果。'
- en: 'No big surprises so far, right? The `relayd` daemon will take care of excluding
    hosts from the table if they go down. But what if all the hosts in the `webpool`
    table go down? Fortunately, the developers thought of that, too, and introduced
    the concept of backup tables for services. This is the last part of the definition
    for the `www` service, with the table `sorry` as the backup table: The hosts in
    the `sorry` table take over if the `webpool` table becomes empty. This means that
    you need to configure a service that’s able to offer a “Sorry, we’re down” message
    in case all the hosts in your `webpool` fail.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应该没有什么大惊小怪的，对吧？`relayd`守护进程会处理从表中排除故障主机的情况。如果`webpool`表中的所有主机都宕机了怎么办？幸运的是，开发人员也考虑到了这一点，并引入了为服务配置备份表的概念。这是`www`服务定义的最后一部分，`sorry`表作为备份表：如果`webpool`表为空，`sorry`表中的主机会接管。这意味着你需要配置一个能够在`webpool`中的所有主机失败时提供“抱歉，我们已停机”消息的服务。
- en: If you’re running an IPv6-only service, you should, of course, substitute your
    IPv6 addresses for the ones given in the example earlier. If you’re running a
    dual-stack setup, you should probably set up the load-balancing mechanism separately
    for each protocol, where the configurations differ only in names (append a `4`
    or `6`, for example, to the IPv4 and IPv6 sets of names, respectively) and the
    addresses themselves.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行的是IPv6-only服务，当然应该将你的IPv6地址替换为之前示例中给出的地址。如果你运行的是双栈配置，最好为每种协议分别设置负载均衡机制，其中配置仅在名称上有所不同（例如，将`4`或`6`附加到IPv4和IPv6名称集上），以及地址本身。
- en: With all of the elements of a valid `relayd` configuration in place, you can
    enable your new configuration.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有有效的`relayd`配置元素都到位后，你可以启用你的新配置。
- en: 'Before you actually start `relayd`, add an empty set of `relayd_flags` to your
    */etc/rc.conf.local* to enable:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在你实际启动`relayd`之前，向你的*/etc/rc.conf.local*文件中添加一个空的`relayd_flags`集来启用：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Reload your PF rule set and then start `relayd`. If you want to check your
    configuration before actually starting `relayd`, you can use the `-n` command-line
    option to `relayd`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载你的PF规则集，然后启动`relayd`。如果你想在实际启动`relayd`之前检查配置，可以使用`-n`命令行选项来检查`relayd`：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If your configuration is correct, `relayd` displays the message `configuration
    OK` and exits.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的配置正确，`relayd`会显示消息`configuration OK`并退出。
- en: To actually start the daemon, you could start `relayd` without any command-line
    flags, but as with most daemons, it’s better to start it via its `rc` script wrapper
    stored in */etc/rc.d/*, so the following sequence reloads your edited PF configuration
    and enables `relayd`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际启动守护进程，你可以不带任何命令行标志地启动`relayd`，但像大多数守护进程一样，最好通过其`rc`脚本包装器启动，包装器存储在*/etc/rc.d/*中，因此以下序列会重新加载你编辑过的PF配置并启用`relayd`。
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With a correct configuration, both commands will silently start, without displaying
    any messages. (If you prefer more verbose messages, both `pfctl` and `relayd`
    offer the `-v` flag. For `relayd`, you may want to add the `-v` flag to the *rc.conf.local*
    entry.) You can check that `relayd` is running with `top` or `ps`. In both cases,
    you’ll find three `relayd` processes, roughly like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 配置正确时，两个命令将静默启动，而不会显示任何消息。（如果你更喜欢更详细的消息，`pfctl`和`relayd`都提供了`-v`标志。对于`relayd`，你可能希望在*rc.conf.local*条目中添加`-v`标志。）你可以使用`top`或`ps`检查`relayd`是否正在运行。在这两种情况下，你将看到三个`relayd`进程，大致如下所示：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And as we mentioned earlier, with an empty set of `relayd_flags` in your *rc.conf.local*
    file, `relayd` is enabled at startup. However, once the configuration is enabled,
    most of your interaction with `relayd` will happen through the `relayctl` administration
    program. In addition to letting you monitor status, `relayctl` lets you reload
    the `relayd` configuration and selectively disable or enable hosts, tables, and
    services. You can even view service status interactively, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，在你的*rc.conf.local*文件中添加一个空的`relayd_flags`集时，`relayd`会在启动时启用。然而，一旦配置启用，与你的`relayd`交互的绝大多数操作将通过`relayctl`管理程序进行。除了让你监控状态外，`relayctl`还允许你重新加载`relayd`配置并有选择地禁用或启用主机、表和服务。你甚至可以以交互方式查看服务状态，如下所示：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this example, the `webpool` is seriously degraded, with only two of four
    hosts up and running. Fortunately, the backup table is still functioning, and
    hopefully it’ll still be up if the last two servers fail as well. For now, all
    tables are active with at least one host up. For tables that no longer have any
    members, the `Status` column changes to empty. Asking `relayctl` for host information
    shows the status information in a host-centered format:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`webpool`严重降级，只有四个主机中的两个正在运行。幸运的是，备用表仍在正常工作，如果最后两个服务器也失败，它应该仍然能够正常工作。目前，所有表格都至少有一个主机处于活动状态。对于没有任何成员的表格，`Status`列会显示为空。请求`relayctl`获取主机信息时，显示的是主机中心格式的状态信息：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you need to take a host out of the pool for maintenance (or any time-consuming
    operation), you can use `relayctl` to disable it, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将某个主机从池中移除以进行维护（或其他任何耗时的操作），你可以使用`relayctl`禁用它，如下所示：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In most cases, the operation will display `command succeeded` to indicate that
    the operation completed successfully. Once you’ve completed maintenance and put
    the machine online, you can reenable it as part of `relayd`’s pool with this command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，操作会显示`command succeeded`，以表明操作成功完成。一旦你完成了维护并将机器重新上线，你可以使用以下命令将其重新启用为`relayd`池的一部分：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Again, you should see the message `command succeeded` almost immediately to
    indicate that the operation was successful.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你应该几乎立即看到消息`command succeeded`，以表示操作成功。
- en: In addition to the basic load balancing demonstrated here, `relayd` has been
    extended in recent OpenBSD versions to offer several features that make it attractive
    in more complex settings. For example, it can now handle Layer 7 proxying or relaying
    functions for HTTP and HTTPS, including protocol handling with header append and
    rewrite, URL-path append and rewrite, and even session and cookie handling. The
    protocol handling needs to be tailored to your application. For example, the following
    is a simple HTTPS relay for load balancing the encrypted Web traffic from clients
    to the Web servers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了此处演示的基本负载均衡外，`relayd`在最近的OpenBSD版本中进行了扩展，提供了多个功能，使其在更复杂的设置中具有吸引力。例如，它现在可以处理第7层代理或中继功能，用于
    HTTP 和 HTTPS，包括带有头部附加和重写的协议处理、URL路径附加和重写，甚至会话和 cookie 处理。协议处理需要根据你的应用进行定制。例如，以下是一个简单的
    HTTPS 中继，用于负载均衡从客户端到 Web 服务器的加密 Web 流量。
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This protocol handler definition demonstrates a range of simple operations on
    the HTTP headers and sets both SSL parameters and specific TCP parameters to optimize
    connection handling. The header options operate on the protocol headers, inserting
    the values of the variables by either appending to existing headers (`append`)
    or changing the content to a new value (`change`).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协议处理器定义演示了一系列对 HTTP 头部的简单操作，并设置了 SSL 参数和特定的 TCP 参数，以优化连接处理。头部选项对协议头部进行操作，通过附加到现有头部（`append`）或将内容更改为新值（`change`）来插入变量的值。
- en: The URL and cookie hashes are used by the load balancer to select to which host
    in the target pool the request is forwarded. The `path filter` specifies that
    any `get` request, including the first quoted string as a substring of the second,
    is to be dropped. The `ssl` options specify that only SSL version 2 ciphers are
    accepted, with key lengths in the medium-to-high range—in other words, 128 bits
    or more.^([[27](#ftn.ch05fn03)]) Finally, the `tcp` options specify `nodelay`
    to minimize delays, specify the use of the selective acknowledgment method (RFC
    2018), and set the socket buffer size and the maximum allowed number of pending
    connections the load balancer keeps track of. These options are examples only;
    in most cases, your application will perform well with these settings at their
    default values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: URL 和 cookie 哈希值由负载均衡器用于选择将请求转发到目标池中的哪个主机。`path filter`指定任何`get`请求，包括第一个引用字符串作为第二个字符串的子串，都应被丢弃。`ssl`选项指定只接受
    SSL 版本 2 密码套件，密钥长度处于中高范围——换句话说，128 位或更高。^([[27](#ftn.ch05fn03)]) 最后，`tcp`选项指定`nodelay`以最小化延迟，指定使用选择确认方法（RFC
    2018），并设置套接字缓冲区大小和负载均衡器跟踪的最大待处理连接数。这些选项仅作为示例；在大多数情况下，你的应用程序在默认值设置下表现良好。
- en: 'The relay definition using the protocol handler follows a pattern that should
    be familiar given the earlier definition of the `www` service:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协议处理器定义的中继遵循一种模式，考虑到之前定义的`www`服务，应该是很熟悉的：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Still, your SSL-enabled Web applications will likely benefit from a slightly
    different set of parameters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，启用 SSL 的 Web 应用程序可能会从稍微不同的一组参数中受益。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*We’ve added a `check ssl`, assuming that each member of the `webhosts` table
    is properly configured to complete an SSL handshake. Depending on your application,
    it may be useful to look into keeping all SSL processing in `relayd`, thus offloading
    the encryption-handling tasks from the backends.*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们添加了`check ssl`，假设`webhosts`表中的每个成员都已正确配置以完成SSL握手。根据您的应用程序，可能有必要考虑将所有SSL处理保持在`relayd`中，从而将加密处理任务从后端卸载。*'
- en: Finally, for CARP-based failover of the hosts running `relayd` on your network
    (see [Chapter 8](ch08.html "Chapter 8. Redundancy and Resource Availability")
    for information about CARP), `relayd` can be configured to support CARP interaction
    by setting the CARP demotion counter for the specified interface groups at shutdown
    or startup.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于运行`relayd`的主机的基于CARP的故障切换（有关CARP的信息，请参见[第8章](ch08.html "第8章 冗余和资源可用性")），`relayd`可以通过在关机或启动时为指定的接口组设置CARP降级计数器来配置以支持CARP交互。
- en: Like all others parts of the OpenBSD system, `relayd` comes with informative
    man pages. For the angles and options not covered here (there are a few), dive
    into the man pages for `relayd`, `relayd.conf`, and `relayctl` and start experimenting
    to find just the configuration you need.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 和OpenBSD系统的其他部分一样，`relayd`带有详细的手册页。对于这里没有涵盖的角度和选项（有一些），可以深入查阅`relayd`、`relayd.conf`和`relayctl`的手册页，并开始实验，找到所需的配置。
- en: A Web Server and Mail Server on the Inside—The NAT Version
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部的Web服务器和邮件服务器——NAT版本
- en: 'Let’s backtrack a little and begin again with the baseline scenario where the
    sample clients from [Chapter 3](ch03.html "Chapter 3. Into the Real World") get
    three new neighbors: a mail server, a Web server, and a file server. This time
    around, externally visible IPv4 addresses are either not available or too expensive,
    and running several other services on a machine that’s primarily a firewall isn’t
    desirable. This means we’re back to the situation where we do our NAT at the gateway.
    Fortunately, the redirection mechanisms in PF make it relatively easy to keep
    servers on the inside of a gateway that performs NAT.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微回溯一下，从基线场景重新开始，在这个场景中，来自[第3章](ch03.html "第3章 进入现实世界")的示例客户端获得了三个新邻居：一台邮件服务器、一台Web服务器和一台文件服务器。这次，外部可见的IPv4地址要么不可用，要么过于昂贵，而且在一台主要是防火墙的机器上运行其他多个服务并不理想。这意味着我们又回到了在网关处进行NAT的情况。幸运的是，PF中的重定向机制使得将服务器保持在执行NAT的网关内部变得相对容易。
- en: 'The network specifications are the same as for the *example.com* setup we just
    worked through: We need to run a Web server that serves up data in cleartext (`http`)
    and encrypted (`https`) form, and we want a mail server that sends and receives
    email while letting clients inside and outside the local network use a number
    of well-known submission and retrieval protocols. In short, we want pretty much
    the same features as in the setup from the previous section, but with only one
    routable address.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 网络规格与我们刚才处理的*example.com*设置相同：我们需要运行一台Web服务器，提供明文（`http`）和加密（`https`）形式的数据，同时希望运行一台邮件服务器，发送和接收电子邮件，同时允许内外部的客户端使用多个知名的提交和检索协议。简而言之，我们希望的功能几乎与上一部分的设置相同，但只使用一个可路由地址。
- en: 'Of the three servers, only the Web server and the mail server need to be visible
    to the outside world, so we add macros for their IP addresses and services to
    the [Chapter 3](ch03.html "Chapter 3. Into the Real World") rule set:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三台服务器中，只有Web服务器和邮件服务器需要对外部可见，因此我们将它们的IP地址和服务添加到[第3章](ch03.html "第3章 进入现实世界")规则集中：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With only one routable address and the servers hidden in NATed address space,
    we need to set up rules at the gateway that redirect the traffic we want our servers
    to handle. We could define a set of `match` rules to set up the redirection and
    then address the `block` or `pass` question in a separate set of rules later,
    like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一个可路由的地址，并且服务器隐藏在NAT地址空间中，我们需要在网关上设置规则，重定向我们希望服务器处理的流量。我们可以定义一组`match`规则来设置重定向，然后在稍后的规则集中单独处理`block`或`pass`问题，如下所示：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This combination of `match` and `pass` rules is very close to the way things
    were done in pre–OpenBSD 4.7 PF versions, and if you’re upgrading from a previous
    version, this is the kind of quick edit that could bridge the syntax gap quickly.
    But you could also opt to go for the new style and write this slightly more compact
    version instead:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `match` 和 `pass` 规则的组合与 OpenBSD 4.7 之前的 PF 版本做法非常相似，如果您从旧版本升级，这种快速编辑可以迅速弥合语法差距。但您也可以选择使用新的风格，写出这种稍微简洁的版本：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note the use of `pass` rules with `rdr-to`. This combination of filtering and
    redirection will help make things easier in a little while, so try this combination
    for now.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用带有 `rdr-to` 的 `pass` 规则。这个过滤和重定向的组合将在稍后使事情变得更简单，因此现在可以尝试使用这种组合。
- en: On pre–OpenBSD 4.7 PF, the rule set will be quite similar, except in the way
    that we handle the redirections.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenBSD 4.7 之前的 PF 中，规则集会非常相似，区别在于我们处理重定向的方式。
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: DMZ with NAT
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带 NAT 的 DMZ
- en: With an all-NAT setup, the pool of available addresses to allocate for a DMZ
    is likely to be larger than in our previous example, but the same principles apply.
    When you move the servers off to a physically separate network, you’ll need to
    check that your rule set’s macro definitions are sane and adjust the values if
    necessary.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在全 NAT 配置下，分配给 DMZ 的可用地址池可能比我们之前的示例更大，但相同的原则适用。当您将服务器移动到物理隔离的网络时，需要检查规则集的宏定义是否合理，并在必要时调整这些值。
- en: 'Just as in the routable-addresses case, it might be useful to tighten up your
    rule set by editing your pass rules so the traffic to and from your servers is
    allowed to pass on only the interfaces that are actually relevant to the services:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在路由地址的情况下，编辑 `pass` 规则以使进出服务器的流量仅能通过与服务实际相关的接口，这样可以更有效地精简您的规则集：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The version for pre–OpenBSD 4.7 PF differs in some details, with the redirection
    still in separate rules:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 OpenBSD 4.7 之前的 PF，规则集在某些细节上有所不同，重定向仍然是在单独的规则中进行：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You could create specific `pass` rules that reference your local network interface,
    but if you leave the existing `pass` rules intact, they’ll continue to work.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建特定的 `pass` 规则来引用您的本地网络接口，但如果保持现有的 `pass` 规则不变，它们仍会继续有效。
- en: Redirection for Load Balancing
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于负载均衡的重定向
- en: The redirection-based load-balancing rules from the previous example work equally
    well in a NAT regime, where the public address is the gateway’s external interface
    and the redirection addresses are in a private range.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 来自前一个示例的基于重定向的负载均衡规则在 NAT 环境下同样有效，其中公共地址是网关的外部接口，重定向地址位于私有范围内。
- en: 'Here’s the `webpool` definition:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `webpool` 的定义：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The main difference between the routable-address case and the NAT version is
    that after you’ve added the `webpool` definition, you edit the existing `pass`
    rule with redirection, which then becomes this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 路由地址和 NAT 版本之间的主要区别在于，在添加了 `webpool` 定义之后，您需要编辑现有的带有重定向的 `pass` 规则，变成如下所示：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Or for pre–OpenBSD 4.7 PF versions, use this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于 OpenBSD 4.7 之前的 PF 版本，使用如下配置：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: From that point on, your NATed DMZ behaves much like the one with official,
    routable addresses.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，您的 NATed DMZ 的行为与具有正式路由地址的 DMZ 十分相似。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can configure a valid IPv6 setup to coexist with a NATed IPv4 setup like
    this one, but if you choose to do so, be sure to treat inet and inet6 traffic
    separately in your PF rules. And contrary to popular belief, rules with nat-to
    and rdr-to options work in IPv6 configurations the same as in IPv4.*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*您可以配置有效的 IPv6 设置，以与像这样的 NAT IPv4 设置共存，但如果选择这样做，请确保在 PF 规则中分别处理 inet 和 inet6
    流量。与普遍看法相反，带有 nat-to 和 rdr-to 选项的规则在 IPv6 配置中与 IPv4 相同。*'
- en: Back to the Single NATed Network
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回到单一 NAT 网络
- en: It may surprise you to hear that there are cases where setting up a small network
    is more difficult than working with a large one. For example, returning to the
    situation where the servers are on the same physical network as the clients, the
    basic NATed configuration works very well—up to a point. In fact, everything works
    brilliantly as long as all you’re interested in is getting traffic from hosts
    outside your local network to reach your servers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地发现，在某些情况下，设置一个小型网络比处理一个大型网络更为困难。例如，回到服务器与客户端位于同一物理网络的情况，基本的 NAT 配置运行得非常好——直到某个程度。事实上，只要您的目标是让外部主机流量到达您的服务器，一切都会运行得非常顺利。
- en: 'Here’s the full configuration:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的配置：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The last four rules here are the ones that interest us the most. If you try
    to reach the services on the official address from hosts in your own network,
    you’ll soon see that the requests for the redirected services from machines in
    your local network most likely never reach the external interface. This is because
    all the redirection and translation happens on the external interface. The gateway
    receives the packets from your local network on the internal interface, with the
    destination address set to the external interface’s address. The gateway recognizes
    the address as one of its own and tries to handle the request as if it were directed
    at a local service; as a consequence, the redirections don’t quite work from the
    inside.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最后四个规则是我们最关心的。如果你尝试从自己网络中的主机访问官方地址上的服务，你很快会发现，来自本地网络的重定向服务请求很可能永远不会到达外部接口。这是因为所有的重定向和翻译都发生在外部接口上。网关接收到来自本地网络的包，在内部接口上，目标地址设置为外部接口的地址。网关将该地址识别为其自身的地址，并试图将请求处理为针对本地服务的请求；结果，重定向在内部无法正常工作。
- en: 'The equivalent part to those last four lines of the preceding rule set for
    pre–OpenBSD 4.7 systems looks like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于OpenBSD 4.7之前的系统，前面规则集中的最后四行对应的部分如下所示：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Fortunately, several work-arounds for this particular problem are possible.
    The problem is common enough that the PF User Guide lists four different solutions
    to the problem,^([[28](#ftn.ch05fn04)]) including moving your servers to a DMZ,
    as described earlier. Because this is a PF book, we’ll concentrate on a PF-based
    solution (actually a pretty terrible work-around), which consists of treating
    the local network as a special case for our redirection and NAT rules.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有几个针对这个特定问题的解决方法。这个问题足够常见，以至于PF用户指南列出了四种不同的解决方案，^([[28](#ftn.ch05fn04)])，其中包括将服务器迁移到DMZ，正如前面所述。因为这是一本关于PF的书，我们将专注于基于PF的解决方案（实际上是一个相当糟糕的解决方法），该方法通过将本地网络作为我们重定向和NAT规则的特殊情况来处理。
- en: 'We need to intercept the network packets originating in the local network and
    handle those connections correctly, making sure that any return traffic is directed
    to the communication partner who actually originated the connection. This means
    that in order for the redirections to work as expected from the local network,
    we need to add special-case redirection rules that mirror the ones designed to
    handle requests from the outside. First, here are the `pass` rules with redirections
    for OpenBSD 4.7 and newer:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要拦截来自本地网络的网络数据包，并正确处理这些连接，确保任何返回流量都能定向到实际发起连接的通信伙伴。这意味着为了使重定向在本地网络中按预期工作，我们需要添加特殊情况的重定向规则，这些规则与设计用来处理外部请求的规则相似。首先，下面是OpenBSD
    4.7及更新版本的`pass`规则与重定向：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first two rules are identical to the original ones. The next two intercept
    the traffic from the local network, and the `rdr-to` actions in both rewrite the
    destination address, much as the corresponding rules do for the traffic that originates
    elsewhere. The `pass` on `$int_if` rules serve the same purpose as in the earlier
    version.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前两条规则与原始规则相同。接下来的两条规则拦截来自本地网络的流量，且两者中的`rdr-to`操作会重写目标地址，类似于对应规则在处理来自其他地方的流量时所做的事情。`pass`规则在`$int_if`接口上的作用与之前版本中的相同。
- en: The `match` rules with `nat-to` are there as a routing work-around. Without
    them, the `webserver` and `mailserver` hosts would route return traffic for the
    redirected connections directly back to the hosts in the local network, where
    the traffic wouldn’t match any outgoing connection. With the `nat-to` in place,
    the servers consider the gateway as the source of the traffic and will direct
    return traffic back the same path it came originally. The gateway matches the
    return traffic to the states created by connections from the clients in the local
    network and applies the appropriate actions to return the traffic to the correct
    clients.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`规则与`nat-to`作为路由解决方法存在。没有它们，`webserver`和`mailserver`主机会将重定向连接的返回流量直接路由回本地网络中的主机，而这些流量将无法匹配任何外发连接。有了`nat-to`，这些服务器将网关视为流量的源，并将返回流量通过最初的路径重新定向回去。网关将返回流量与从本地网络的客户端创建的连接状态进行匹配，并采取适当的操作将流量返回到正确的客户端。'
- en: The equivalent rules for pre–OpenBSD 4.7 versions are at first sight a bit more
    confusing, but the end result is the same.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于OpenBSD 4.7之前的版本，相应的规则乍一看可能更为复杂，但最终结果是相同的。
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This way, we twist the redirections and the address translation logic to do
    what we need, and we don’t need to touch the `pass` rules at all. (I’ve had the
    good fortune to witness via email and IRC the reactions of several network admins
    at the moment when the truth about this five-line reconfiguration sank in.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以扭转重定向和地址转换的逻辑，完成我们需要的操作，而根本不需要触及`pass`规则。（我有幸通过电子邮件和IRC目睹了几个网络管理员在意识到这五行重新配置的真相时的反应。）
- en: Filtering on Interface Groups
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤接口组
- en: Your network could have several subnets that may never need to interact with
    your local network except for some common services, like email, Web, file, and
    print. How you handle the traffic from and to such subnets depends on how your
    network is designed. One useful approach is to treat each less-privileged network
    as a separate local network attached to its own separate interface on a common
    filtering gateway and then to give it a rule set that allows only the desired
    direct interaction with the neighboring networks attached to the main gateway.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你的网络可能有多个子网，这些子网之间可能永远不需要相互通信，除非是一些公共服务，如电子邮件、网页、文件和打印。你如何处理这些子网的进出流量取决于你的网络设计。一个有用的方法是将每个低权限的网络视为一个独立的本地网络，并将其附加到一个公共过滤网关的独立接口上，然后为其设定一套规则，仅允许与主网关相邻网络的所需直接交互。
- en: You can make your PF configuration more manageable and readable by grouping
    logically similar interfaces into interface groups and by applying filtering rules
    to the groups rather than the individual interfaces. Interface groups, as implemented
    via the `ifconfig` *group* option, originally appeared in OpenBSD 3.6 and have
    been adopted in FreeBSD 7.0 onward.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将逻辑相似的接口分组到接口组中，并将过滤规则应用于这些组而不是单个接口，你可以使PF配置更加可管理和易于阅读。接口组是通过`ifconfig` *group*选项实现的，最早出现在OpenBSD
    3.6版本中，之后在FreeBSD 7.0及以后的版本中得到了采用。
- en: 'All configured network interfaces can be configured to belong to one or more
    groups. Some interfaces automatically belong to one of the default groups. For
    example, all IEEE 802.11 wireless network interfaces belong to the `wlan` group,
    while interfaces associated with the default routes belong to the `egress` group.
    Fortunately, an interface can be a member of several groups, and you can add interfaces
    to interface groups via the appropriate `ifconfig` command, as in this example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所有配置的网络接口都可以配置为属于一个或多个组。有些接口会自动属于某个默认组。例如，所有IEEE 802.11无线网络接口都属于`wlan`组，而与默认路由相关的接口则属于`egress`组。幸运的是，接口可以是多个组的成员，你可以通过适当的`ifconfig`命令将接口添加到接口组中，下面是一个示例：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For a permanent configuration, the equivalent under OpenBSD would be in the
    *hostname.sis2* file or the `ifconfig_sis2=` line in the *rc.conf* file on FreeBSD
    7.0 or later.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于永久配置，在OpenBSD中等效的配置将出现在*hostname.sis2*文件中，或者在FreeBSD 7.0及以后的版本中出现在`ifconfig_sis2=`行中。
- en: 'Where it makes sense, you can then treat the interface group much the same
    as you would handle a single interface in filtering rules:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在有意义的地方，你可以像处理单个接口一样处理接口组中的过滤规则：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If by now you’re thinking that in most, if not all, the rule-set examples up
    to this point, it would be possible to filter on the group `egress` instead of
    the macro `$ext_if`, you’ve grasped an important point. It could be a useful exercise
    to go through any existing rule sets you have and see what using interface groups
    can do to help readability even further. Remember that an interface group can
    have one or more members.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在想到，在到目前为止的大多数规则集示例中，完全可以在`egress`组上进行过滤，而不是宏`$ext_if`，那么你已经掌握了一个重要的概念。回顾你现有的规则集，看看使用接口组如何进一步帮助提高可读性，可能是一个有益的练习。记住，一个接口组可以有一个或多个成员。
- en: Note that filtering on interface groups makes it possible to write essentially
    hardware-independent rule sets. As long as your *hostname.if* files or `ifconfig_if=`
    lines put the interfaces in the correct groups, rule sets that consistently filter
    on interface groups will be fully portable between machines that may or may not
    have identical hardware configurations.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，过滤接口组使得编写本质上与硬件无关的规则集成为可能。只要你的*hostname.if*文件或`ifconfig_if=`行将接口放入正确的组中，始终在接口组上过滤的规则集将能够在硬件配置可能不同的机器之间完全移植。
- en: 'On systems where the interface group feature isn’t available, you may be able
    to achieve some of the same effects via creative use of macros, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有接口组功能的系统中，你可能能够通过创造性地使用宏来实现类似的效果，具体如下：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The Power of Tags
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签的力量
- en: In some networks, the decision of where a packet should be allowed to pass can’t
    be made to map easily to criteria like subnet and service. The fine-grained control
    the site’s policy demands could make the rule set complicated and potentially
    hard to maintain.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些网络中，不能轻易通过子网和服务等标准来决定数据包是否允许通过。站点策略所需的精细控制可能会使规则集变得复杂，且难以维护。
- en: Fortunately, PF offers yet another mechanism for classification and filtering
    in the form of *packet tagging*. The useful way to implement packet tagging is
    to `tag` incoming packets that match a specific `pass` rule and then let the packets
    pass elsewhere based on which identifiers the packet is `tagged` with. In OpenBSD
    4.6 and later, it’s even possible to have separate `match` rules that `tag` according
    to the match criteria, leaving decisions on passing, redirecting, or taking other
    actions to rules later in the rule set.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，PF提供了另一种分类和过滤机制，即*数据包标签*。实现数据包标签的有效方式是对符合特定`pass`规则的传入数据包进行`tag`标记，然后根据数据包所标记的标识符将其传递到其他地方。在OpenBSD
    4.6及以后的版本中，甚至可以有单独的`match`规则，根据匹配标准进行`tag`标记，将传递、重定向或其他操作的决定留给规则集中后面的规则。
- en: 'One example could be the wireless access points we set up in [Chapter 4](ch04.html
    "Chapter 4. Wireless Networks Made Easy"), which we could reasonably expect to
    inject traffic into the local network with an apparent source address equal to
    the access point’s `$ext_if` address. In that scenario, a useful addition to the
    rule set of a gateway with several of these access points might be the following
    (assuming, of course, that definitions of the `wifi_allowed` and `wifi_ports`
    macros fit the site’s requirements):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可能是我们在[第4章](ch04.html "第4章 无线网络简化")中设置的无线接入点，我们可以合理地预期这些接入点将以与接入点的`$ext_if`地址相同的源地址将流量注入到本地网络中。在这种情况下，对于网关的规则集，可以合理地添加以下内容（当然，假设`wifi_allowed`和`wifi_ports`宏的定义符合站点的要求）：
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As the complexity of the rule set grows, consider using `tag` in incoming `match`
    and `pass` rules to make your rule set readable and easier to maintain.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 随着规则集复杂性的增加，考虑在传入的`match`和`pass`规则中使用`tag`，使规则集更具可读性并易于维护。
- en: Tags are sticky, and once a packet has been tagged by a matching rule, the tag
    stays, which means that a packet can have a tag even if it wasn’t applied by the
    last matching rule. However, a packet can have only one tag at any time. If a
    packet matches several rules that apply tags, the tag will be overwritten with
    a new one by each new matching `tag` rule.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是粘性的，一旦数据包被匹配规则标记，标签就会保留，这意味着即使数据包不是由最后匹配的规则应用的，它也可以拥有标签。然而，任何时候一个数据包只能有一个标签。如果数据包匹配多个应用标签的规则，标签会被每个新的匹配`tag`规则覆盖。
- en: For example, you could set several tags on incoming traffic via a set of `match`
    or `pass` rules, supplemented by a set of `pass` rules that determine where packets
    pass out based on the tags set on the incoming traffic.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以通过一组`match`或`pass`规则为传入流量设置多个标签，然后再通过一组`pass`规则根据传入流量上设置的标签来确定数据包的去向。
- en: The Bridging Firewall
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桥接防火墙
- en: An Ethernet *bridge* consists of two or more interfaces that are configured
    to forward Ethernet frames transparently and that aren’t directly visible to the
    upper layers, such as the TCP/IP stack. In a filtering context, the bridge configuration
    is often considered attractive because it means that the filtering can be performed
    on a machine that doesn’t have its own IP addresses. If the machine in question
    runs OpenBSD or a similarly capable operating system, it can still filter and
    redirect traffic.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以太网*桥接*由两个或更多配置为透明转发以太网帧的接口组成，这些接口对于上层（如TCP/IP协议栈）是不可见的。在过滤的上下文中，桥接配置通常被认为很有吸引力，因为它意味着过滤操作可以在没有自己IP地址的机器上进行。如果该机器运行OpenBSD或类似功能的操作系统，它仍然可以过滤和重定向流量。
- en: The main advantage of such a setup is that attacking the firewall itself is
    more difficult.^([[29](#ftn.ch05fn05)]) The disadvantage is that all admin tasks
    must be performed at the firewall’s console, unless you configure a network interface
    that’s reachable via a secured network of some kind or even a serial console.
    It also follows that bridges with no IP address configured can’t be set as the
    gateway for a network and can’t run any services on the bridged interfaces. Rather,
    you can think of a bridge as an intelligent bulge on the network cable, which
    can filter and redirect.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置的主要优点是攻击防火墙本身更加困难。^([[29](#ftn.ch05fn05)]) 缺点是，除非配置一个通过某种安全网络或串行控制台可以访问的网络接口，否则所有管理任务必须在防火墙的控制台上执行。由此可见，未配置
    IP 地址的桥接不能作为网络的网关，也无法在桥接接口上运行任何服务。相反，你可以将桥接视为网络电缆上的一个智能凸起，它能够过滤并重定向数据。
- en: 'A few general caveats apply to using firewalls implemented as bridges:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用作为桥接实现的防火墙时，需要注意一些通用的警告：
- en: The interfaces are placed in promiscuous mode, which means that they’ll receive
    (and to some extent process) every packet on the network.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口被设置为混杂模式，这意味着它们将接收（并在某种程度上处理）网络上的每一个数据包。
- en: Bridges operate on the Ethernet level and, by default, forward all types of
    packets, not just TCP/IP.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接在以太网层工作，并且默认情况下会转发所有类型的数据包，而不仅仅是 TCP/IP 数据包。
- en: The lack of IP addresses on the interfaces makes some of the more effective
    redundancy features, such as CARP, unavailable.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口没有 IP 地址使得一些更有效的冗余功能（例如 CARP）无法使用。
- en: The method for configuring bridges differs among operating systems in some details.
    The following examples are very basic and don’t cover all possible wrinkles, but
    they should be enough to get you started.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 配置桥接的方法在不同操作系统之间存在一些细微差别。以下示例非常基础，并未涵盖所有可能的细节，但它们应该足以让你入门。
- en: Basic Bridge Setup on OpenBSD
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 OpenBSD 上的基本桥接设置
- en: The OpenBSD GENERIC kernel contains all the necessary code to configure bridges
    and filter on them. Unless you’ve compiled a custom kernel without the bridge
    code, the setup is quite straightforward.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 的 GENERIC 内核包含了所有配置桥接和在其上过滤的必要代码。除非你编译了一个没有桥接代码的自定义内核，否则设置过程非常直接。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*On OpenBSD 4.7 and newer, the brconfig command no longer exists. All bridge
    configuration and related functionality was merged into ifconfig for the OpenBSD
    4.7 release. If you’re running on an OpenBSD release where brconfig is available,
    you’re running an out-of-date, unsupported configuration. Please upgrade to a
    more recent version as soon as feasible.*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 OpenBSD 4.7 及更新版本中，brconfig 命令不再存在。所有桥接配置和相关功能已并入 ifconfig，适用于 OpenBSD 4.7
    版本。如果你正在使用包含 brconfig 的 OpenBSD 版本，说明你正在使用过时且不再支持的配置。请尽快升级到更新的版本。*'
- en: 'To set up a bridge with two interfaces on the command line, you first create
    the bridge device. The first device of a kind is conventionally given the sequence
    number 0, so we create the `bridge0` device with the following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要在命令行上设置一个包含两个接口的桥接，首先需要创建桥接设备。第一种类型的设备通常会给定序号 0，因此我们使用以下命令创建 `bridge0` 设备：
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Before the next `ifconfig` command, use `ifconfig` to check that the prospective
    member interfaces (in our case, `ep0` and `ep1`) are up, but not assigned IP addresses.
    Next, configure the bridge by entering the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个 `ifconfig` 命令之前，使用 `ifconfig` 检查预期的成员接口（在我们的例子中是 `ep0` 和 `ep1`）是否处于活动状态，但没有分配
    IP 地址。接下来，通过输入以下命令来配置桥接：
- en: '[PRE53]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The OpenBSD `ifconfig` command contains a fair bit of filtering code itself.
    In this example, we use the `blocknonip` option for each interface to block all
    non-IP traffic.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 的 `ifconfig` 命令本身包含了一些过滤代码。在这个例子中，我们为每个接口使用 `blocknonip` 选项来阻止所有非 IP
    流量。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The OpenBSD ifconfig command offers its own set of filtering options in addition
    to other configuration options. The `bridge(4)` and `ifconfig(8)` man pages provide
    further information. Because it operates on the Ethernet level, it’s possible
    to use `ifconfig` to specify filtering rules that let the bridge filter on MAC
    addresses. Using these filtering capabilities, it’s also possible to let the bridge
    tag packets for further processing in your PF rule set via the `tagged` keyword.
    For tagging purposes, a bridge with one member interface will do.*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*OpenBSD的ifconfig命令提供了自己的过滤选项，除此之外还有其他配置选项。`bridge(4)`和`ifconfig(8)`的手册页提供了更多的信息。因为它是在以太网层操作，所以可以使用`ifconfig`来指定过滤规则，使得桥接可以基于MAC地址进行过滤。通过这些过滤功能，也可以让桥接通过`tagged`关键字标记数据包，以便在PF规则集中进一步处理。对于标记功能，一个带有单个成员接口的桥接器就可以工作。*'
- en: 'To make the configuration permanent, create or edit */etc/hostname.ep0* and
    enter the following line:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使配置永久生效，创建或编辑*/etc/hostname.ep0*并输入以下行：
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'For the other interface, */etc/hostname.ep1* should contain the same line:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个接口，*/etc/hostname.ep1*应包含相同的行：
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, enter the bridge setup in */etc/hostname.bridge0*:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*/etc/hostname.bridge0*中输入桥接设置：
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Your bridge should now be up, and you can go on to create the PF filter rules.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的桥接器应该已经启动，你可以继续创建PF过滤规则。
- en: Basic Bridge Setup on FreeBSD
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FreeBSD上的基本桥接设置
- en: 'For FreeBSD, the procedure is a little more involved than on OpenBSD. In order
    to be able to use bridging, your running kernel must include the `if_bridge` module.
    The default kernel configurations build this module, so under ordinary circumstances,
    you can go directly to creating the interface. To compile the bridge device into
    the kernel, add the following line in the kernel configuration file:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于FreeBSD，过程比OpenBSD稍微复杂一些。为了能够使用桥接功能，你的运行中的内核必须包含`if_bridge`模块。默认的内核配置会构建这个模块，因此在普通情况下，你可以直接创建接口。要将桥接设备编译到内核中，请在内核配置文件中添加以下行：
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can also load the device at boot time by putting the following line in the
    */etc/loader.conf* file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在*/etc/loader.conf*文件中加入以下行来在启动时加载该设备。
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create the bridge by entering this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下内容来创建桥接器：
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Creating the `bridge0` interface also creates a set of bridge-related `sysctl`
    values:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`bridge0`接口还会创建一组与桥接相关的`sysctl`值：
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It’s worth checking that these `sysctl` values are available. If they are, it’s
    confirmation that the bridge has been enabled. If they’re not, go back and see
    what went wrong and why.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 检查这些`sysctl`值是否可用是值得的。如果它们存在，说明桥接已启用。如果没有，返回检查出错原因。
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*These values apply to filtering on the bridge interface itself. You don’t
    need to touch them because IP-level filtering on the member interfaces (the ends
    of the pipe) is enabled by default.*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些值适用于对桥接接口本身的过滤。你不需要修改它们，因为对成员接口（管道的两端）的IP级别过滤默认是启用的。*'
- en: 'Before the next `ifconfig` command, check that the prospective member interfaces
    (in our case, `ep0` and `ep1`) are up but haven’t been assigned IP addresses.
    Then configure the bridge by entering this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行下一个`ifconfig`命令之前，检查拟议的成员接口（在我们的例子中是`ep0`和`ep1`）是否已经启动，但尚未分配IP地址。然后输入以下内容来配置桥接器：
- en: '[PRE61]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To make the configuration permanent, add the following lines to */etc/ rc.conf*:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使配置永久生效，将以下行添加到*/etc/ rc.conf*中：
- en: '[PRE62]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This means your bridge is up and you can go on to create the PF filter rules.
    See the `if_bridge(4)` man page for further FreeBSD-specific bridge information.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你的桥接器已经启动，你可以继续创建PF过滤规则。有关FreeBSD特定桥接信息，请参阅`if_bridge(4)`的手册页。
- en: Basic Bridge Setup on NetBSD
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NetBSD上的基本桥接设置
- en: On NetBSD, the default kernel configuration doesn’t have the filtering bridge
    support compiled in. You need to compile a custom kernel with the following option
    added to the kernel configuration file. Once you have the new kernel with the
    bridge code in place, the setup is straightforward.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在NetBSD上，默认的内核配置没有编译过滤桥接支持。你需要编译一个自定义内核，并将以下选项添加到内核配置文件中。一旦你有了包含桥接代码的新内核，设置过程就很简单。
- en: '[PRE63]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To create a bridge with two interfaces on the command line, first create the
    `bridge0` device:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上创建一个具有两个接口的桥接器，首先创建`bridge0`设备：
- en: '[PRE64]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Before the next `brconfig` command, use `ifconfig` to check that the prospective
    member interfaces (in our case, `ep0` and `ep1`) are up but haven’t been assigned
    IP addresses. Then, configure the bridge by entering this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行下一个`brconfig`命令之前，使用`ifconfig`检查拟议的成员接口（在我们的例子中是`ep0`和`ep1`）是否已经启动，但尚未分配IP地址。然后，输入以下内容来配置桥接器：
- en: '[PRE65]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, enable the filtering on the `bridge0` device:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启用 `bridge0` 设备的过滤功能：
- en: '[PRE66]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To make the configuration permanent, create or edit */etc/ifconfig.ep0* and
    enter the following line:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使配置永久生效，请创建或编辑 */etc/ifconfig.ep0* 并输入以下行：
- en: '[PRE67]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'For the other interface, */etc/ifconfig.ep1* should contain the same line:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个接口，*/etc/ifconfig.ep1* 应包含相同的行：
- en: '[PRE68]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, enter the bridge setup in */etc/ifconfig.bridge0*:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 */etc/ifconfig.bridge0* 中输入桥接设置：
- en: '[PRE69]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Your bridge should now be up, and you can go on to create the PF filter rules.
    For further information, see the PF on NetBSD documentation at *[http://www.netbsd.org/Documentation/network/pf.html](http://www.netbsd.org/Documentation/network/pf.html)*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的桥接应该已启动，您可以继续创建 PF 过滤规则。有关更多信息，请参见 *[http://www.netbsd.org/Documentation/network/pf.html](http://www.netbsd.org/Documentation/network/pf.html)*
    中的 NetBSD 文档。
- en: The Bridge Rule Set
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 桥接规则集
- en: '[Figure 5-3](ch05.html#network_with_a_bridge_firewall "Figure 5-3. A network
    with a bridge firewall") shows the *pf.conf* file for a bulge-in-the-wire version
    of the baseline rule set we started in this chapter. As you can see, the network
    changes slightly.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-3](ch05.html#network_with_a_bridge_firewall "图 5-3. 带桥接防火墙的网络") 显示了一个基线规则集的*pf.conf*
    文件，该规则集在本章开始时我们介绍的基础规则集的基础上进行了扩展。如您所见，网络稍有变化。'
- en: '![A network with a bridge firewall](httpatomoreillycomsourcenostarchimages2127157.png.jpg)Figure 5-3. A
    network with a bridge firewall'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![带桥接防火墙的网络](httpatomoreillycomsourcenostarchimages2127157.png.jpg)图 5-3. 带桥接防火墙的网络'
- en: The machines in the local network share a common default gateway, which isn’t
    the bridge but could be placed either inside or outside the bridge.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 本地网络中的计算机共享一个公共默认网关，该网关不是桥接器，但可以放置在桥接器内或外部。
- en: '[PRE70]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Significantly more complicated setups are possible. But remember that while
    redirections will work, you won’t be able to run services on any of the interfaces
    without IP addresses.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出现复杂得多的设置。但请记住，虽然重定向有效，但没有 IP 地址的接口无法运行任何服务。
- en: Handling Nonroutable IPv4 Addresses from Elsewhere
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理来自其他地方的不可路由 IPv4 地址
- en: Even with a properly configured gateway to handle filtering and potentially
    NAT for your own network, you may find yourself in the unenviable position of
    needing to compensate for other people’s misconfigurations.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有一个正确配置的网关来处理过滤和可能的 NAT（网络地址转换）以应对您自己的网络，您仍可能会发现自己处于不得不补偿其他人配置错误的尴尬境地。
- en: Establishing Global Rules
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建立全局规则
- en: One depressingly common class of misconfigurations is the kind that lets traffic
    with nonroutable addresses out to the Internet. Traffic from nonroutable IPv4
    addresses plays a part in several *denial-of-service (DoS)* attack techniques,
    so it’s worth considering explicitly blocking traffic from nonroutable addresses
    from entering your network. One possible solution is outlined here. For good measure,
    it also blocks any attempt to initiate contact to nonroutable addresses through
    the gateway’s external interface.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一种令人沮丧的常见配置错误类型是允许具有不可路由地址的流量访问互联网。来自不可路由 IPv4 地址的流量在几种*拒绝服务（DoS）*攻击技术中发挥作用，因此值得考虑显式地阻止来自不可路由地址的流量进入您的网络。这里概述了一个可能的解决方案。为确保万无一失，它还会阻止任何通过网关外部接口尝试与不可路由地址建立联系的行为。
- en: '[PRE71]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, the `martians` macro denotes the RFC 1918 addresses and a few other ranges
    mandated by various RFCs not to be in circulation on the open Internet. Traffic
    to and from such addresses is quietly dropped on the gateway’s external interface.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`martians` 宏表示 RFC 1918 地址和其他一些 RFC 强制要求不应在开放互联网中流通的地址范围。到这些地址的流量以及来自这些地址的流量会在网关的外部接口上静默丢弃。
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The martians macro could easily be implemented as a table instead, with all
    of the table advantages as an added bonus for your rule set. In fact, if you view
    the loaded rules in a rule set that contains this combination of macro and rules,
    you’ll see that macro expansion and rule-set optimization most likely replaced
    your list with one table per rule. However, if you roll your own table, you’ll
    get to pick a nicer name for it yourself.*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*martians 宏也可以轻松地实现为一个表格形式，这样您的规则集将有额外的表格优势。事实上，如果您查看包含此宏和规则组合的规则集中的加载规则，您会看到宏展开和规则集优化最有可能用每个规则一个表格替代了您的列表。然而，如果您自己编写表格，您可以为它选择一个更合适的名字。*'
- en: The specific details of how to implement this kind of protection will vary according
    to your network configuration and may be part of a wider set of network security
    measures. Your network design might also dictate that you include or exclude address
    ranges other than these.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现这种保护的具体细节会根据你的网络配置有所不同，可能是更广泛的网络安全措施的一部分。你的网络设计可能还会决定是否包含或排除这些地址范围之外的内容。
- en: Restructuring Your Rule Set with Anchors
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用锚点重构你的规则集
- en: We’ve mentioned anchors a few times already, in the context of applications
    such as FTP-proxy or `relayd` that use anchors to interact with a running PF configuration.
    Anchors are named sub–rule sets where it’s possible to insert or remove rules
    as needed without reloading the whole rule set.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在多个场合提到过锚点，例如在使用锚点与运行中的PF配置交互的应用程序（如FTP代理或`relayd`）的上下文中。锚点是命名的子规则集，可以根据需要插入或删除规则，而无需重新加载整个规则集。
- en: 'Once you have a rule set where an otherwise unused anchor is defined, you can
    even manipulate anchor contents from the command line using `pfctl`’s `-a` switch,
    like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个规则集，其中定义了一个平时未使用的锚点，你甚至可以使用`pfctl`的`-a`开关从命令行操作锚点内容，如下所示：
- en: '[PRE72]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, a rule is inserted into the existing anchor `baddies`, overwriting any
    previous content.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个规则被插入到现有的锚点`baddies`中，覆盖了任何先前的内容。
- en: 'You can even load rules from a separate file into an anchor:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以从一个单独的文件加载规则到锚点中：
- en: '[PRE73]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Or you can list the current contents of an anchor:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以列出锚点的当前内容：
- en: '[PRE74]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*There are a few more pfctl options that you’ll find useful for handling anchors.
    See the pfctl man page for inspiration.*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*你还会发现一些其他的pfctl选项对于处理锚点很有用。请参考pfctl手册页获取灵感。*'
- en: 'You can also split your configuration by putting the contents of anchors into
    separate files to be loaded at rule-set load time. That way it becomes possible
    to edit the rules in the anchors separately, reload the edited anchor, and, of
    course, do any other manipulation like the ones described above. To do this, first
    add a line like this to *pf.conf*:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将锚点的内容放入单独的文件，在规则集加载时加载这些文件，从而拆分你的配置。这样就可以单独编辑锚点中的规则，重新加载编辑后的锚点，当然，也可以进行如上所述的任何其他操作。为此，首先在*pf.conf*中添加如下行：
- en: '[PRE75]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This references the file */etc/anchor-ssh-good*, which could look like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这引用了文件*/etc/anchor-ssh-good*，它可能看起来像这样：
- en: '[PRE76]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Perhaps simply to make it possible to delegate the responsibility for the table
    `sshbuddies` to a junior admin, the anchor loads the table from the file */etc/sshbuddies*,
    which could look like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 可能只是为了让初级管理员能够委派`sshbuddies`表的责任，锚点从文件*/etc/sshbuddies*加载该表，文件内容可能是这样的：
- en: '[PRE77]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This way, you can manipulate the contents of the anchor in the following ways:
    Add rules by editing the file and reloading the anchor, replace the rules by feeding
    other rules from the command line via standard input (as shown in the earlier
    example), or change the behavior of the rules inside the anchor by manipulating
    the contents of the table they reference.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以通过以下方式操作锚点的内容：通过编辑文件并重新加载锚点来添加规则，通过标准输入从命令行传递其他规则来替换规则（如前面示例所示），或者通过操作它们引用的表的内容来改变锚点内部规则的行为。
- en: Note
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*For more extensive anchors, like the ones discussed in the following paragraphs,
    it’s probably more useful to use include clauses in your* pf.conf *if you want
    to maintain the anchors as separate files.*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于更复杂的锚点，例如以下段落中讨论的锚点，如果你希望将锚点作为单独的文件来维护，使用include语句可能更有用。* pf.conf *中。*'
- en: 'The concept hinted at previously (specifying a set of common criteria that
    apply to all actions within an anchor) is appealing in situations where your configuration
    is large enough to need a few extra structuring aids. For example, “on interface”
    could be a useful common criterion for traffic arriving on a specific interface
    because that traffic tends to have certain similarities. For example, look at
    the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的概念（指定适用于锚点内所有操作的共同标准集）在你的配置足够庞大，需要一些额外的结构化帮助时非常有用。例如，“在接口上”可能是一个有用的共同标准，用于到达特定接口的流量，因为这些流量通常具有某些相似性。例如，看看以下内容：
- en: '[PRE78]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A separate anchor `ext` would serve the `egress` interface group:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的锚点`ext`将服务于`egress`接口组：
- en: '[PRE79]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Another obvious logical optimization if you group rules in anchors based on
    interface affinity is to lump in tags to help policy-routing decisions. A simple
    but effective example could look like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你根据接口亲和性将规则分组到锚点中，那么另一个显而易见的逻辑优化就是加入标签来帮助策略路由决策。一个简单但有效的例子可能是这样的：
- en: '[PRE80]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Even if the anchor examples here have all included a blocking decision inside
    the anchor, the decision to block or pass based on tag information doesn’t have
    to happen inside the anchor.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这里的锚点示例都包含了在锚点内做出阻止决策，基于标签信息来决定是阻止还是放行并不一定需要在锚点内进行。
- en: After this whirlwind tour of anchors as a structuring tool, it may be tempting
    to try to convert your entire rule set to an anchors-based structure. If you try
    to do so, you’ll probably find ways to make the internal logic clearer. But don’t
    be surprised if certain rules need to be global, outside of anchors tied to common
    criteria. And you’ll almost certainly find that what turns out to be useful in
    your environment is at least a little different from what inspired the scenarios
    I’ve presented here.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在对锚点作为结构工具的快速概览后，可能会有尝试将整个规则集转换为基于锚点的结构的冲动。如果你尝试这么做，你可能会找到让内部逻辑更清晰的方法。但不要惊讶于某些规则需要是全局性的，而不是与常见标准关联的锚点之外的规则。而且你几乎肯定会发现，最终在你的环境中有用的东西至少与我在这里呈现的场景有所不同。
- en: How Complicated Is Your Network?—Revisited
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的网络有多复杂？——再探讨
- en: Early on in this chapter, we posed the questions “How complicated is your network?”
    and “How complicated does it need to be?” Over the subsections of this chapter,
    we’ve presented a number of tools and techniques that make it possible to build
    complex infrastructure with PF and related tools and that help manage that complexity
    while keeping the network administrator sane.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，我们提出了“你的网络有多复杂？”和“它需要有多复杂？”的问题。在本章的各个小节中，我们展示了一些工具和技术，使得可以用 PF 和相关工具构建复杂的基础设施，并帮助管理这些复杂性，同时保持网络管理员的理智。
- en: If you’re in charge of one site where you need to apply all or most of the techniques
    we’ve mentioned in this chapter, I feel your pain. On the other hand, if you’re
    in charge of a network that diverse, the subsequent chapters on traffic shaping
    and managing resource availability are likely to be useful to you as well.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你负责的站点需要应用我们在本章中提到的所有或大部分技术，我理解你的痛苦。另一方面，如果你负责的是一个如此多样化的网络，那么后续关于流量整形和资源可用性管理的章节可能对你也会很有帮助。
- en: The rest of this book deals mainly with optimizing your setup for performance
    and resource availability, with the exception of one chapter where we deviate
    slightly and take on a lighter tone. Before we dive into how to optimize performance
    and ensure high availability, it’s time to take a look at how to make your infrastructure
    unavailable or hard to reach for selected groups or individuals. The next chapter
    deals exclusively with making life harder for the unwashed masses—or perhaps even
    well-organized criminals—who try to abuse services in your care.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分主要讲述如何优化设置以提高性能和资源可用性，除了其中有一章稍微偏离，采用了更轻松的语气。在我们深入探讨如何优化性能并确保高可用性之前，是时候看看如何使基础设施对特定群体或个人变得不可用或难以访问。下一章专门讲述如何让那些试图滥用你所负责服务的未受洗礼的大众——或者甚至是组织严密的犯罪分子——的生活更加困难。
- en: '* * *'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[25](#ch05fn01)]) In fact, the *example.com* network here lives in the 192.0.2.0/24
    block, which is reserved in RFC 3330 for example and documentation use. We use
    this address range mainly to differentiate from the NAT examples elsewhere in
    this book, which use addresses in the “private” RFC 1918 address space.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[25](#ch05fn01)]) 事实上，这里提到的 *example.com* 网络位于 192.0.2.0/24 网段，该网段在 RFC 3330
    中为示例和文档用途保留。我们使用这个地址范围，主要是为了与本书中其他地方使用的 NAT 示例区分开来，后者使用的是“私有” RFC 1918 地址空间中的地址。
- en: ^([[26](#ch05fn02)]) Originally introduced in OpenBSD 4.1 under the name `hoststated`,
    the daemon has seen active development (mainly by Reyk Floeter and Pierre-Yves
    Ritschard) over several years, including a few important changes to the configuration
    syntax, and it was renamed `relayd` in time for the OpenBSD 4.3 release.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[26](#ch05fn02)]) 最初在 OpenBSD 4.1 中以 `hoststated` 名称引入，这个守护进程在多年的开发中（主要由
    Reyk Floeter 和 Pierre-Yves Ritschard 完成）经历了积极的开发，包括对配置语法的一些重要更改，并且在 OpenBSD 4.3
    版本中被重新命名为 `relayd`。
- en: ^([[27](#ch05fn03)]) See the OpenSSL man page for further explanation of cipher-related
    options.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[27](#ch05fn03)]) 请参见 OpenSSL 手册页以获得更多关于加密选项的说明。
- en: ^([[28](#ch05fn04)]) See the “Redirection and Reflection” section in the PF
    User Guide (*[http://www.openbsd.org/faq/pf/rdr.html#reflect](http://www.openbsd.org/faq/pf/rdr.html#reflect)*).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '^([[28](#ch05fn04)]) 请参阅 PF 用户指南中的“重定向与反射”部分 (*[http://www.openbsd.org/faq/pf/rdr.html#reflect](http://www.openbsd.org/faq/pf/rdr.html#reflect)*)。  '
- en: ^([[29](#ch05fn05)]) How much security this actually adds is a matter of occasional
    heated debate on mailing lists such as *openbsd-misc* and other networking-oriented
    lists. Reading up on the pros and cons as perceived by core OpenBSD developers
    can be entertaining as well as enlightening.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[29](#ch05fn05)]) 这一措施实际增加的安全性，是在 *openbsd-misc* 和其他面向网络的邮件列表中偶尔激烈讨论的主题。阅读
    OpenBSD 核心开发者对其优缺点的看法，既能娱乐又能启发思考。
