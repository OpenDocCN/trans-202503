- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**SYSTEM ADMINISTRATION: MANAGING USERS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统管理：管理用户**'
- en: '![image](../images/common4.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common4.jpg)'
- en: No sophisticated operating system, whether it’s Windows, OS X, or Unix, can
    run indefinitely without human intervention. If you’re on a multiuser Linux system,
    someone is already performing the necessary system administration tasks. You might
    be able to ignore the proverbial “man behind the curtain” who is managing and
    maintaining everything, or you might well be the Great and Powerful Oz yourself,
    the person who pulls the levers and pushes the buttons to keep the system running.
    If you have a single-user system, there are system administration tasks that you
    should be performing on a regular basis.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是 Windows、OS X 还是 Unix，任何复杂的操作系统都无法在没有人工干预的情况下无限期运行。如果你使用的是多用户的 Linux 系统，肯定会有人在执行必要的系统管理任务。你可能忽略了那个“幕后的人”，他负责管理和维护一切，或者你可能正是那个“大魔法师”自己，掌控着一切操作，保持系统的正常运行。如果你使用的是单用户系统，那么你应该定期执行一些系统管理任务。
- en: Fortunately, simplifying life for Linux system administrators (the goal for
    this chapter) is one of the most common uses of shell scripting. In fact, quite
    a few Linux commands are actually shell scripts, and many of the most basic tasks,
    like adding users, analyzing disk usage, and managing the filespace of the guest
    account, can be accomplished more efficiently with short scripts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，简化 Linux 系统管理员的工作（本章目标）是 Shell 脚本最常见的用途之一。实际上，许多 Linux 命令实际上就是 Shell 脚本，许多最基本的任务，如添加用户、分析磁盘使用情况以及管理访客帐户的文件空间，都可以通过简短的脚本更高效地完成。
- en: 'What’s surprising is that many system administration scripts are no more than
    20 to 30 lines long. Heck, you can use Linux commands to identify scripts and
    run a pipe to figure out how many lines each contains. Here are the 15 shortest
    scripts in */usr/bin/*:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，许多系统管理脚本的长度也不过是 20 到 30 行。事实上，你可以使用 Linux 命令来识别脚本，并通过管道命令来查找每个脚本的行数。以下是
    */usr/bin/* 中 15 个最短的脚本：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'None of the shortest 15 scripts in the */usr/bin/* directory are longer than
    10 lines. And at 10 lines, the equation-formatting script `neqn` is a fine example
    of how a little shell script can really improve the user experience:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*/usr/bin/* 目录中最短的 15 个脚本都不超过 10 行。而在 10 行中，方程式格式化脚本 `neqn` 是一个很好的例子，展示了一个小的
    Shell 脚本如何真正改善用户体验：'
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Like `neqn`, the scripts presented in this chapter are short and useful, offering
    a range of administrative capabilities including easy system backups; the creation,
    management, and deletion of users and their data; an easy-to-use frontend for
    the `date` command that changes the current date and time; and a helpful tool
    to validate *crontab* files.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `neqn` 类似，本章介绍的脚本简短而实用，提供了一系列的管理功能，包括简单的系统备份；用户及其数据的创建、管理和删除；一个易于使用的 `date`
    命令前端，用于更改当前的日期和时间；以及一个有用的工具来验证 *crontab* 文件。
- en: '**#35 Analyzing Disk Usage**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#35 分析磁盘使用情况**'
- en: Even with the advent of very large disks and their continual drop in price,
    system administrators seem to be perpetually tasked with keeping an eye on disk
    usage so that shared drives don’t fill up.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 即便是大容量硬盘的出现以及它们价格的持续下降，系统管理员似乎仍然不断被要求监控磁盘使用情况，以防共享磁盘被填满。
- en: The most common monitoring technique is to look at the */usr* or */home* directory,
    using the `du` command to determine the disk usage of all subdirectories and reporting
    the top 5 or 10 users. The problem with this approach, however, is that it doesn’t
    take into account space usage elsewhere on the hard disk(s). If some users have
    additional archive space on a second drive, or you have some sneaky types who
    keep MPEGs in a dot directory in */tmp* or in an unused directory in the *ftp*
    area, this usage will escape detection. Also, if you have home directories spread
    across multiple drives, searching each */home* isn’t necessarily optimal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的监控技术是查看 */usr* 或 */home* 目录，使用 `du` 命令确定所有子目录的磁盘使用情况，并报告前 5 或前 10 个用户。然而，这种方法的问题在于，它没有考虑硬盘（或多个硬盘）上其他地方的空间使用情况。如果某些用户在第二个硬盘上有额外的归档空间，或者你有些偷偷摸摸的用户在
    */tmp* 的点目录或 *ftp* 区域中的未使用目录中存放 MPEG 文件，那么这些使用情况将无法被检测到。此外，如果你的 home 目录分布在多个硬盘上，逐个搜索每个
    */home* 目录未必是最优的做法。
- en: Instead, a better solution is to get all the account names directly from the
    */etc/passwd* file and then to search the filesystems for files owned by each
    account, as shown in [Listing 5-1](ch05.xhtml#ch5ex1).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是直接从 */etc/passwd* 文件中获取所有帐户名，然后在文件系统中搜索每个帐户拥有的文件，如 [列表 5-1](ch05.xhtml#ch5ex1)
    所示。
- en: '***The Code***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 5-1: The* `*fquota*` *script*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-1：* `*fquota*` *脚本*'
- en: '***How It Works***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: By convention, user IDs 1 through 99 are for system daemons and administrative
    tasks, while 100 and above are for user accounts. Since Linux administrators tend
    to be a fairly organized bunch, this script skips all accounts that have a uid
    of less than 100.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，用户 ID 从 1 到 99 用于系统守护进程和管理任务，而 100 及以上则用于用户账户。由于 Linux 管理员通常比较有条理，这个脚本跳过了所有
    UID 小于 100 的账户。
- en: The `-xdev` argument to the `find` command ➊ ensures that `find` doesn’t go
    through all filesystems. In other words, this argument prevents the command from
    slogging through system areas, read-only source directories, removable devices,
    the */proc* directory of running processes (on Linux), and similar areas. This
    is why we specify directories like */usr*, */var*, and */home* explicitly. These
    directories are commonly on their own filesystems for backup and managerial purposes.
    Adding them when they reside on the same filesystem as the root filesystem doesn’t
    mean they will be searched twice.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`-xdev` 参数用于 `find` 命令 ➊，确保 `find` 不会遍历所有文件系统。换句话说，这个参数防止命令在系统区域、只读源目录、可移动设备、正在运行的进程的
    */proc* 目录（在 Linux 中）以及类似区域中耗时。正因如此，我们明确指定了如 */usr*、*/var* 和 */home* 这样的目录。这些目录通常在各自独立的文件系统中，用于备份和管理目的。即使它们与根文件系统位于同一文件系统中，加入这些目录并不意味着它们会被重复搜索。'
- en: It may seem at first glance that this script outputs an `exceeds disk quota`
    message for each and every account, but the `awk` statement after the loop ➋ only
    allows this message to be reported for accounts with usage greater than the predefined
    `MAXDISKUSAGE`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 刚开始看，可能会觉得这个脚本对每个账户都输出 `超过磁盘配额` 的消息，但在循环之后的 `awk` 语句 ➋ 只会在账户的使用量大于预定义的 `MAXDISKUSAGE`
    时报告此消息。
- en: '***Running the Script***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script has no arguments and should be run as root to ensure it has access
    to all directories and filesystems. The smart way to do this is by using the helpful
    `sudo` command (run the command `man sudo` in your terminal for more details).
    Why is `sudo` helpful? Because it allows you to execute *one* command as root,
    after which you will go back to being a regular user. Each time you want to run
    an administrative command, you have to consciously use `sudo` to do so. Using
    `su - root`, by contrast, makes you root for all subsequent commands until you
    exit the subshell, and when you get distracted, it’s all too easy to forget you
    are root and type in something that can lead to disaster.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本没有参数，应该以 root 用户身份运行，以确保它有权限访问所有目录和文件系统。聪明的做法是使用有用的 `sudo` 命令（在终端运行命令 `man
    sudo` 以获取更多细节）。为什么 `sudo` 有用？因为它允许你以 root 用户身份执行*一个*命令，之后你会恢复为普通用户身份。每次你想运行一个管理命令时，都必须有意识地使用
    `sudo`。与此相反，使用 `su - root` 会让你一直以 root 身份执行后续的所有命令，直到退出子 Shell，而一旦你分心，很容易忘记自己是
    root，执行一些可能导致灾难的操作。
- en: '**NOTE**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You will have to modify the directories listed in the* `*find*` *command*
    ➊ *to match the corresponding directories in your own disk topography.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*你需要修改* `*find*` *命令中列出的目录* ➊ *，使其与自己磁盘拓扑中的对应目录匹配。*'
- en: '***The Results***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: Because this script searches across filesystems, it should be no surprise that
    it takes a while to run. On a large system, it could easily take somewhere between
    a cup of tea and a lunch with your significant other. [Listing 5-2](ch05.xhtml#ch5ex2)
    details the results.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个脚本会跨文件系统进行搜索，所以它需要一些时间才能运行，这一点应该不足为奇。在大型系统上，运行时间可能会介于喝一杯茶和和你的伴侣共进午餐之间。[列表
    5-2](ch05.xhtml#ch5ex2) 详细说明了结果。
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 5-2: Testing the* `*fquota*` *script*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2：测试* `*fquota*` *脚本*'
- en: You can see that `taylor` is way out of control with his disk usage! His 21GB
    definitely exceeds the 20GB per user quota.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `taylor` 在磁盘使用方面完全失控！他使用的 21GB 明显超过了每个用户 20GB 的配额。
- en: '***Hacking the Script***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: A complete script of this nature should have some sort of automated email capability
    to warn the scofflaws that they’re hogging disk space. This enhancement is demonstrated
    in the very next script.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的完整脚本应该具有某种自动发送电子邮件的功能，用来警告那些占用过多磁盘空间的人。这个增强功能在下一个脚本中得到了演示。
- en: '**#36 Reporting Disk Hogs**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#36 报告磁盘占用者**'
- en: 'Most system administrators seek the easiest way to solve a problem, and the
    easiest way to manage disk quotas is to extend `fquota` ([Script #35](ch05.xhtml#ch05lev1sec01)
    on [page 119](ch05.xhtml#page_119)) to issue email warnings directly to users
    who are consuming too much space, as shown in [Listing 5-3](ch05.xhtml#ch5ex3).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '大多数系统管理员都希望以最简单的方式解决问题，而管理磁盘配额的最简单方法是扩展`fquota`（见[脚本 #35](ch05.xhtml#ch5lev1sec01)，[第119页](ch05.xhtml#page_119)），直接向消耗过多空间的用户发出电子邮件警告，见[列表
    5-3](ch05.xhtml#ch5ex3)。'
- en: '***The Code***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-3: The* `*diskhogs*` *script*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-3：*`*diskhogs*`*脚本*'
- en: '***How It Works***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: 'This script uses [Script #35](ch05.xhtml#ch05lev1sec01) as a base, with changes
    marked at ➊, ➋, ➍, ➎, and ➏. Note the addition of the `fmt` command in the email
    pipeline at ➏.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '该脚本使用[脚本 #35](ch05.xhtml#ch05lev1sec01)作为基础，变更标记在➊、➋、➍、➎和➏处。请注意在邮件管道中添加了`fmt`命令，见➏。'
- en: 'This handy trick improves the appearance of an automatically generated email
    when fields of unknown length, like `$account`, are embedded in the text. The
    logic of the `for` loop ➌ in this script is slightly different from the logic
    of the `for` loop in [Script #35](ch05.xhtml#ch05lev1sec01): because the output
    of the loop in this script is intended purely for the second part of the script,
    during each cycle, the script simply reports the account name and disk usage rather
    than a `disk quota exceeded` error message.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '这个巧妙的技巧改善了自动生成的电子邮件的外观，当字段的长度未知时，例如`$account`，它被嵌入到文本中。在此脚本中，`for`循环的逻辑在第➌处稍有不同于[脚本
    #35](ch05.xhtml#ch5lev1sec01)中的`for`循环：因为该脚本中循环的输出仅用于脚本的第二部分，在每个循环中，脚本只报告账户名和磁盘使用情况，而不是`磁盘配额超限`的错误信息。'
- en: '***Running the Script***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script has no starting arguments and should be run as root for accurate
    results. This can most safely be accomplished by using the `sudo` command, as
    shown in [Listing 5-4](ch05.xhtml#ch5ex4).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本没有起始参数，应该以root身份运行以获得准确的结果。最安全的做法是使用`sudo`命令，如[列表 5-4](ch05.xhtml#ch5ex4)所示。
- en: '***The Results***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-4: Testing the* `*diskhogs*` *script*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-4：测试*`*diskhogs*`*脚本*'
- en: If we now peek into the `ashley` account mailbox, we’ll see that a message from
    the script has been delivered, shown in [Listing 5-5](ch05.xhtml#ch5ex5).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在查看`ashley`账户的邮箱，我们会看到来自脚本的一条消息已被送达，见[列表 5-5](ch05.xhtml#ch5ex5)。
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-5: The email sent to the* `*ashley*` *user for being a disk hog*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：因超用磁盘而向`*ashley*`用户发送的电子邮件*'
- en: '***Hacking the Script***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修改脚本***'
- en: A useful refinement to this script would be to allow certain users to have larger
    quotas than others. This could easily be accomplished by creating a separate file
    that defines the disk quota for each user and setting a default quota in the script
    for users not appearing in the file. A file with account name and quota pairs
    could be scanned with `grep` and the second field extracted with a call to `cut
    -f2`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的一个有用的改进是允许某些用户拥有比其他用户更大的配额。这可以通过创建一个单独的文件来定义每个用户的磁盘配额来轻松实现，并在脚本中为未出现在文件中的用户设置默认配额。可以使用`grep`扫描包含账户名和配额对的文件，并通过调用`cut
    -f2`提取第二个字段。
- en: '**#37 Improving the Readability of df Output**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#37 改善df输出的可读性**'
- en: The `df` utility output can be cryptic, but we can improve its readability.
    The script in [Listing 5-6](ch05.xhtml#ch5ex6) converts the byte counts reported
    by `df` into more human-friendly units.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`df`工具的输出可能会让人费解，但我们可以提高其可读性。[列表 5-6](ch05.xhtml#ch5ex6)中的脚本将`df`报告的字节数转换为更易懂的单位。'
- en: '***The Code***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-6: The* `*newdf*` *script, wrapping* `*df*` *so it is easier to
    use*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-6：*`*newdf*`*脚本，包装*`*df*`*以便更易于使用*'
- en: '***How It Works***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: Much of the work in this script takes place within an `awk` script, and it wouldn’t
    take too big of a step to write the entire script in `awk` rather than in the
    shell, using the `system()` function to call `df` directly. (Actually, this script
    would be an ideal candidate to rewrite in Perl, but that’s outside the scope of
    this book.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本的大部分工作都在`awk`脚本中完成，而且完全可以将整个脚本用`awk`编写，而不是使用Shell，利用`system()`函数直接调用`df`。
    (实际上，这个脚本是用Perl重写的理想候选者，但这超出了本书的范围。)
- en: There’s also an old-school trick in this script at ➊ and ➋ that comes from programming
    in BASIC, of all things.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本中也有一个老派的技巧，在➊和➋处，来自于BASIC编程。
- en: 'When working with arbitrary-precision numeric values, a quick way to limit
    the number of digits after the decimal is to multiply the value by a power of
    10, convert it to an integer (dropping the fractional portion), and then divide
    it by the same power of 10: `prettymb=(int(mb * 100)) / 100;`. With this code,
    a value like 7.085344324 becomes a much more attractive 7.08.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理任意精度的数字值时，一种快速限制小数点后位数的方法是将值乘以 10 的幂次，将其转换为整数（去掉小数部分），然后再除以相同的 10 的幂次：`prettymb=(int(mb
    * 100)) / 100;`。使用这段代码，像 7.085344324 这样的值会变得更加简洁，变成 7.08。
- en: '**NOTE**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some versions of* `*df*` *have an* `*-h*` *flag that offers an output format
    similar to this script’s output format. However, as with many of the scripts in
    this book, this one will let you achieve friendly and more meaningful output on
    every Unix or Linux system, regardless of what version of* `*df*` *is present.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*某些版本的* `*df*` *具有一个* `*-h*` *标志，提供类似于此脚本输出格式的输出。然而，正如本书中许多脚本所示，这个脚本可以让你在每个
    Unix 或 Linux 系统上实现更友好、更有意义的输出，无论你使用的是什么版本的* `*df*`*。*'
- en: '***Running the Script***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script has no arguments and can be run by anyone, root or otherwise. To
    avoid reporting disk use on devices that you aren’t interested in, use `grep -v`
    after the call to `df`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本没有参数，任何人都可以运行，包括 root 用户和普通用户。为了避免报告你不感兴趣的设备的磁盘使用情况，可以在调用 `df` 后使用 `grep
    -v` 来过滤。
- en: '***The Results***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: Regular `df` reports are difficult to understand, as shown in [Listing 5-7](ch05.xhtml#ch5ex7).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 常规的 `df` 报告难以理解，正如在 [清单 5-7](ch05.xhtml#ch5ex7) 中所示。
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 5-7: The default output of* `*df*` *is convoluted and confusing.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-7：* `*df*` *的默认输出复杂且令人困惑。*'
- en: The new script exploits `awk` to improve readability and knows how to convert
    512-byte blocks into a more readable gigabyte format, as you can see in [Listing
    5-8](ch05.xhtml#ch5ex8).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 新脚本利用 `awk` 改善了可读性，并且知道如何将 512 字节的块转换为更易读的千兆字节格式，正如在 [清单 5-8](ch05.xhtml#ch5ex8)
    中所示。
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 5-8: The easier to read and understand output of* `*newdf*`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-8：* `*newdf*` *的更易读且易理解的输出*'
- en: '***Hacking the Script***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修改脚本***'
- en: There are a number of gotchas in this script, not the least of which is that
    a lot of versions of `df` now include `inode` usage, and many also include processor
    internal information even though it’s really completely uninteresting (for example,
    the two `map` entries in the example above). In fact, this script would be far
    more useful if we screened those things out, so the first change you could make
    would be to use the `-P` flag in the call to `df` near the end of the script ➌
    to remove the `inode` usage information. (You could also add it as a new column,
    but then the output would get even wider and harder to format.) In terms of removing
    things like the `map` data, that’s an easy `grep`, right? Simply add `|grep -v
    "^map"` at the end of ➊ and you’ll mask ’em forevermore.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本有许多坑，最不容忽视的一点是，现在很多版本的 `df` 会包括 `inode` 使用情况，许多版本还会包括处理器内部信息，尽管这些信息实际上完全无关紧要（例如，上面例子中的两个
    `map` 条目）。实际上，如果我们去除这些内容，这个脚本会更有用。因此，你可以做的第一个修改是，在脚本最后调用 `df` 时使用 `-P` 标志，以去除
    `inode` 使用信息。（你也可以将其作为一个新列添加，但那样输出会变得更宽，格式也更难处理。）至于去除 `map` 数据，这个很容易用 `grep` 解决，对吧？只需在
    ➊ 之后添加 `|grep -v "^map"`，你就能永远屏蔽它们。
- en: '**#38 Figuring Out Available Disk Space**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#38 计算可用磁盘空间**'
- en: 'While [Script #37](ch05.xhtml#ch05lev1sec03) simplified the `df` output to
    be easier to read and understand, the more basic question of how much disk space
    is available on the system can be addressed in a shell script. The `df` command
    reports disk usage on a per-disk basis, but the output can be a bit baffling:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然 [脚本 #37](ch05.xhtml#ch05lev1sec03) 简化了 `df` 输出，使其更易读和理解，但如何在系统中查看可用磁盘空间的基本问题可以通过一个
    shell 脚本来解决。`df` 命令按磁盘报告磁盘使用情况，但输出可能有些令人困惑：'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A more useful version of `df` would sum the “available capacity” values in column
    4 and present the sum in a human-readable format. It’s a task easily accomplished
    with a script using the `awk` command, as shown in [Listing 5-9](ch05.xhtml#ch5ex9).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有用的 `df` 版本会将第四列中的“可用容量”值求和，并以人类可读的格式展示总和。这是一个可以轻松通过脚本使用 `awk` 命令来完成的任务，正如在
    [清单 5-9](ch05.xhtml#ch5ex9) 中所示。
- en: '***The Code***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 5-9: The* `*diskspace*` *script, a handy wrapper with friendlier output
    to* `*df*`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-9：* `*diskspace*` *脚本，这是一个具有更友好输出的实用封装器，替代了* `*df*`'
- en: '***How It Works***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The `diskspace` shell script relies mainly on a temporary `awk` script that
    is written to the */tmp* directory. This `awk` script calculates the total amount
    of disk space left using data fed to it and then prints the result in a user-friendly
    format. The output of `df` is then piped through `awk` ➊, which performs the actions
    in the `awk` script. When execution of the script is finished, the temporary `awk`
    script is removed from the */tmp* directory because of the `trap` command run
    at the beginning of the script.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`diskspace` 脚本主要依赖于一个临时的 `awk` 脚本，该脚本写入到 */tmp* 目录中。这个 `awk` 脚本使用传入的数据计算剩余的总磁盘空间，并以用户友好的格式输出结果。然后，`df`
    的输出通过 `awk` ➊ 被传递，`awk` 执行该脚本中的操作。当脚本执行完毕后，临时的 `awk` 脚本会由于脚本开头运行的 `trap` 命令而从
    */tmp* 目录中被删除。'
- en: '***Running the Script***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script, which can be run as any user, produces a succinct one-line summary
    of available disk space.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以作为任何用户运行，输出一个简洁的可用磁盘空间的单行摘要。
- en: '***The Results***'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: For the same system that generated the earlier `df` output, this script reports
    output similar to that shown in [Listing 5-10](ch05.xhtml#ch5ex10).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生成先前 `df` 输出的相同系统，这个脚本的输出与 [清单 5-10](ch05.xhtml#ch5ex10) 中显示的类似。
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 5-10: Testing the* `*diskspace*` *script*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-10：测试* `*diskspace*` *脚本*'
- en: '***Hacking the Script***'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: 'If your system has lots of disk space across many multiterabyte drives, you
    might expand this script to automatically return values in terabytes as needed.
    If you’re just out of space, it’ll doubtlessly be discouraging to see 0.03GB of
    available disk space—but that’s a good incentive to use [Script #36](ch05.xhtml#ch05lev1sec02)
    on [page 121](ch05.xhtml#page_121) and clean things up, right?'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您的系统有很多多TB的磁盘空间，您可以扩展此脚本，使其在需要时自动返回以太字节为单位的值。如果磁盘空间不足，看到仅剩 0.03GB 的可用磁盘空间无疑会让人沮丧——但这也是使用
    [脚本 #36](ch05.xhtml#ch05lev1sec02) 进行清理的一个好动力，对吧？'
- en: Another issue to consider is whether it’s more useful to know about the available
    disk space on all devices, including those partitions that cannot grow, like */boot*,
    or whether it’s enough to report on just user volumes. If the latter, you can
    improve this script by making a call to `grep` immediately after the `df` call
    ➊. Use `grep` with the desired device names to include only particular devices,
    or use `grep -v` followed by the unwanted device names to screen out devices you
    don’t want included.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的问题是，了解所有设备上的可用磁盘空间是否更有用，包括那些无法扩展的分区，如 */boot*，还是仅报告用户卷的磁盘空间就足够了。如果是后者，您可以通过在
    `df` 调用后 ➊ 立即调用 `grep` 来改进此脚本。使用 `grep` 结合所需的设备名称，仅包括特定设备，或者使用 `grep -v` 后跟不需要的设备名称，筛选掉您不希望包含的设备。
- en: '**#39 Implementing a Secure locate**'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#39 实现一个安全的 locate**'
- en: 'The `locate` script, [Script #19](ch02.xhtml#ch02lev1sec06) on [page 68](ch02.xhtml#page_68),
    is useful but has a security problem: if the build process is run as root, it
    builds a list of all files and directories on the entire system, regardless of
    owner, allowing users to see directories and filenames that they wouldn’t otherwise
    have permission to access. The build process can be run as a generic user (as
    OS X does, running `mklocatedb` as user `nobody`), but that’s not right either,
    because you want to be able to locate file matches anywhere in your directory
    tree, regardless of whether user `nobody` has access to those particular files
    and directories.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`locate` 脚本，[脚本 #19](ch02.xhtml#ch02lev1sec06) 在 [第 68 页](ch02.xhtml#page_68)，是有用的，但存在安全问题：如果构建过程以
    root 身份运行，它会构建一个包含整个系统所有文件和目录的列表，而不考虑所有者，允许用户查看他们本不允许访问的目录和文件名。构建过程可以以普通用户身份运行（如
    OS X 所做的，运行 `mklocatedb` 时使用 `nobody` 用户），但这样也不对，因为您希望能够在目录树中的任何位置找到文件匹配项，无论用户
    `nobody` 是否有权限访问这些特定的文件和目录。'
- en: One way to solve this dilemma is to increase the data saved in the `locate`
    database so that each entry has an owner, group, and permissions string attached.
    But then the `mklocatedb` database itself remains insecure, unless the `locate`
    script is run as either a `setuid` or `setgid` script, and that’s something to
    be avoided at all costs in the interest of system security.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个难题的一种方法是增加 `locate` 数据库中保存的数据，使得每个条目都附带所有者、组和权限字符串。但随后 `mklocatedb` 数据库本身仍然不安全，除非
    `locate` 脚本以 `setuid` 或 `setgid` 脚本运行，而出于系统安全的考虑，这种做法是应该避免的。
- en: A compromise is to have a separate *.locatedb* file for each user. This isn’t
    too bad of an option, because a personal database is needed only for users who
    actually use the `locate` command. Once invoked, the system creates a *.locatedb*
    file in the user’s home directory, and a `cron` job can update existing *.locatedb*
    files nightly to keep them in sync. The very first time someone runs the secure
    `slocate` script, it outputs a message warning them that they may see only matches
    for files that are publicly accessible. Starting the very next day (depending
    on the `cron` schedule), the users get their personalized results.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一种折中的方法是为每个用户单独保存一个 *.locatedb* 文件。这并不是一个坏选择，因为只有实际使用 `locate` 命令的用户才需要个人数据库。一旦调用，系统会在用户的主目录中创建一个
    *.locatedb* 文件，`cron` 任务可以每日更新现有的 *.locatedb* 文件，以保持同步。在第一次运行安全的 `slocate` 脚本时，它会输出一条警告消息，提醒用户他们可能只会看到公共访问的文件的匹配结果。从第二天开始（取决于
    `cron` 的计划），用户将看到个性化的结果。
- en: '***The Code***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: 'Two scripts are necessary for a secure `locate`: the database builder, `mkslocatedb`
    (shown in [Listing 5-11](ch05.xhtml#ch5ex11)) and the actual search utility, `slocate`
    (shown in [Listing 5-12](ch05.xhtml#ch5ex12)).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的 `locate` 需要两个脚本：数据库构建器 `mkslocatedb`（如 [列表 5-11](ch05.xhtml#ch5ex11) 所示）和实际的搜索工具
    `slocate`（如 [列表 5-12](ch05.xhtml#ch5ex12) 所示）。
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 5-11: The* `*mkslocatedb*` *script*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-11：* `*mkslocatedb*` *脚本*'
- en: The `slocate` script itself (shown in [Listing 5-12](ch05.xhtml#ch5ex12)) is
    the user interface to the `slocate` database.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`slocate` 脚本本身（如 [列表 5-12](ch05.xhtml#ch5ex12) 所示）是与 `slocate` 数据库的用户接口。'
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 5-12: The* `*slocate*` *script, the companion script to* `*mkslocatedb*`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-12：* `*slocate*` *脚本，* `*mkslocatedb*` *脚本的配套脚本*'
- en: '***How It Works***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The `mkslocatedb` script revolves around the idea that a process running as
    root can temporarily become owned by a different user ID by using `su -fm *user*`
    ➊. It can then run `find` on the filesystem of each user as that user in order
    to create a user-specific database of filenames. Working with the `su` command
    proves tricky within this script, though, because by default, `su` not only wants
    to change the effective user ID but also wants to import the environment of the
    specified account. The end result is odd and confusing error messages on just
    about any Unix unless the `-m` flag is specified, which prevents the user environment
    from being imported. The `-f` flag is extra insurance, bypassing the *.cshrc*
    file for any `csh` or `tcsh` users.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkslocatedb` 脚本的核心思想是，一个以 root 身份运行的进程可以通过使用 `su -fm *user*` ➊ 临时变更为由其他用户
    ID 所拥有。然后，它可以作为该用户在每个用户的文件系统上运行 `find`，以便创建一个特定于用户的文件名数据库。然而，在这个脚本中使用 `su` 命令有一定的难度，因为默认情况下，`su`
    不仅希望更改有效用户 ID，还希望导入指定账户的环境。最终的结果是在几乎所有的 Unix 系统上都会出现奇怪且令人困惑的错误信息，除非指定了 `-m` 标志，这可以防止导入用户环境。`-f`
    标志是额外的保障，绕过任何 `csh` 或 `tcsh` 用户的 *.cshrc* 文件。'
- en: 'The other unusual notation at ➊ is `2>/dev/null,` which routes all error messages
    directly to the proverbial bit bucket: anything redirected to */dev/null* vanishes
    without a trace. This is an easy way to skip the inevitable flood of `permission
    denied` error messages for each `find` function invoked.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不寻常的符号 ➊ 是 `2>/dev/null,`，它将所有错误信息直接重定向到所谓的“位桶”：任何重定向到 */dev/null* 的内容都会无声无息地消失。这是一种跳过每次调用
    `find` 函数时不可避免的 `permission denied` 错误信息的简便方法。
- en: '***Running the Script***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: The `mkslocatedb` script is unusual in that not only must it be run as root,
    but using `sudo` won’t cut it. You need to either log in as root or use the more
    powerful `su` command to become root before running the script. This is because
    `su` will actually switch you to the root user in order to run the script, in
    contrast to `sudo`, which simply grants the current user root privileges. `sudo`
    can result in different permissions being set on files than `su` does. The `slocate`
    script, of course, has no such requirements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkslocatedb` 脚本的特殊之处在于，它不仅必须以 root 身份运行，而且使用 `sudo` 是不够的。你需要以 root 用户身份登录，或者使用更强大的
    `su` 命令来成为 root，才能运行该脚本。这是因为 `su` 实际上会将你切换为 root 用户以运行脚本，而 `sudo` 只是简单地赋予当前用户
    root 权限。`sudo` 可能会导致文件上的权限与 `su` 不同。当然，`slocate` 脚本没有这样的要求。'
- en: '***The Results***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: Building the `slocate` database for both `nobody` (the public database) and
    user `taylor` on a Linux box produces the output shown in [Listing 5-13](ch05.xhtml#ch5ex13).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统上为 `nobody`（公共数据库）和用户 `taylor` 构建 `slocate` 数据库时，输出结果如 [列表 5-13](ch05.xhtml#ch5ex13)
    所示。
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 5-13: Running the* `*mkslocatedb*` *script as root*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-13：* 以 root 身份运行 `*mkslocatedb*` *脚本*'
- en: 'To search for a particular file or set of files that match a given pattern,
    let’s first try it as user `tintin` (who doesn’t have a *.slocatedb* file):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找匹配给定模式的特定文件或文件集，首先让我们以` tintin `用户身份尝试（该用户没有*.slocatedb*文件）：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we’ll enter the same command, but as user `taylor`, who owns the file being
    sought:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将以` taylor `用户身份输入相同的命令，该用户拥有要查找的文件：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***Hacking the Script***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: If you have a very large filesystem, it’s possible that this approach will consume
    a nontrivial amount of space. One way to address this issue is to make sure that
    the individual *.slocatedb* database files don’t contain entries that also appear
    in the central database. This requires a bit more processing up front (`sort`
    both and then use `diff`, or simply skip */usr* and */bin* when searching for
    individual user files), but it could pay off in terms of saved space.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个非常大的文件系统，这种方法可能会占用相当数量的空间。解决此问题的一种方法是确保单个*.slocatedb*数据库文件不包含在中央数据库中也出现的条目。这需要更多的前期处理（将两者都`sort`并使用`diff`，或在搜索单个用户文件时直接跳过*/usr*和*/bin*），但从节省空间的角度来看，这可能会有所收获。
- en: Another technique for saving space is to build the individual *.slocatedb* files
    with references only to files that have been accessed since the last update. This
    works better if the `mkslocatedb` script is run weekly rather than daily; otherwise,
    each Monday all users would be back to ground zero because they’d be unlikely
    to have run the `slocate` command over the weekend.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种节省空间的技巧是构建仅包含自上次更新以来已访问文件引用的单个*.slocatedb*文件。如果`mkslocatedb`脚本每周运行一次而不是每天运行，这种方法效果更好；否则，每到周一，所有用户都会回到原点，因为他们不太可能在周末运行`slocate`命令。
- en: 'Finally, another easy way to save space would be to keep the *.slocatedb* files
    compressed and uncompress them on the fly when they are searched with `slocate`.
    See the `zgrep` command in [Script #33](ch04.xhtml#ch04lev1sec07) on [page 109](ch04.xhtml#page_109)
    for inspiration regarding how to do this.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，另一个节省空间的简单方法是将*.slocatedb*文件压缩，并在通过`slocate`进行搜索时即时解压。有关如何实现这一点的灵感，请参见[脚本
    #33](ch04.xhtml#ch04lev1sec07)中的`zgrep`命令，以及[第109页](ch04.xhtml#page_109)的说明。'
- en: '**#40 Adding Users to the System**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#40 将用户添加到系统**'
- en: If you’re responsible for managing a network of Unix or Linux systems, you’ve
    already experienced the frustration caused by subtle incompatibilities among the
    different operating systems in your dominion. Some of the most basic administration
    tasks prove to be the most incompatible across different flavors of Unix, and
    chief among these tasks is user account management. Rather than have a single
    command line interface that is 100 percent consistent across all Linux flavors,
    each vendor has developed its own graphical interface for working with the peculiarities
    of its own system.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你负责管理Unix或Linux系统的网络，你已经体验到不同操作系统之间微妙的不兼容性所带来的沮丧。一些最基本的管理任务在不同的Unix版本中被证明是最不兼容的，其中最为重要的任务就是用户帐户管理。与其让所有Linux版本的命令行界面保持100%的一致性，每个厂商都开发了自己的图形界面，以处理其系统的特殊性。
- en: The Simple Network Management Protocol (SNMP) was ostensibly supposed to help
    normalize this sort of thing, but managing user accounts is just as difficult
    now as it was a decade ago, particularly in a heterogeneous computing environment.
    As a result, a very helpful set of scripts for a system administrator includes
    a version of `adduser`, `suspenduser`, and `deleteuser` that can be customized
    for your specific needs and then easily ported to all of your Unix systems. We’ll
    show you `adduser` here and cover `suspenduser` and `deleteuser` in the next two
    scripts.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 简单网络管理协议（SNMP）本应帮助规范此类问题，但管理用户帐户现在依然像十年前一样困难，特别是在异构计算环境中。因此，对于系统管理员而言，一套非常有用的脚本包括可以根据特定需求自定义的`adduser`、`suspenduser`和`deleteuser`版本，并且可以轻松地移植到所有Unix系统。我们将在这里展示`adduser`，并将在接下来的两个脚本中介绍`suspenduser`和`deleteuser`。
- en: '**NOTE**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*OS X is an exception to this rule, with its reliance on a separate user account
    database. To retain your sanity, just use the Mac versions of these commands and
    don’t try to figure out the byzantine command line access that they sort of grant
    administrative users.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*OS X是这一规则的例外，它依赖于单独的用户帐户数据库。为了保持理智，直接使用Mac版本的这些命令，不要试图弄清楚它们给予管理用户的那些复杂命令行访问。*'
- en: On a Linux system, an account is created by adding a unique entry to the */etc/passwd*
    file, consisting of a one- to eight-character account name, a unique user ID,
    a group ID, a home directory, and a login shell for that user. Modern systems
    store the encrypted password value in */etc/shadow*, so a new user entry must
    be added to that file, too. Finally, the account needs to be listed in the */etc/group*
    file, with the user either as their own group (the strategy implemented in this
    script) or as part of an existing group. [Listing 5-14](ch05.xhtml#ch5ex14) shows
    how we can accomplish all of these steps.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统中，账户是通过向 */etc/passwd* 文件中添加一个唯一条目来创建的，该条目包括一个 1 到 8 个字符的账户名、一个唯一的用户
    ID、一个组 ID、一个主目录和该用户的登录 Shell。现代系统将加密的密码值存储在 */etc/shadow* 中，因此也必须向该文件添加一个新的用户条目。最后，账户需要列出在
    */etc/group* 文件中，用户可以是他们自己的组（这是此脚本中实现的策略），也可以是现有组的一部分。[Listing 5-14](ch05.xhtml#ch5ex14)
    展示了我们如何完成所有这些步骤。
- en: '***The Code***'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 5-14: The* `*adduser*` *script*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-14：* `*adduser*` *脚本*'
- en: '***How It Works***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: The coolest single line in this script is at ➊. This scans through the */etc/passwd*
    file to figure out the largest user ID currently in use that’s less than the highest
    allowable user account value (this script uses 5000, but you should adjust this
    for your own configuration) and then adds 1 to it for the new account user ID.
    This saves the admin from having to remember what the next available ID is, and
    it also offers a high degree of consistency in account information as the user
    community evolves and changes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本中最酷的单行代码位于 ➊。它扫描 */etc/passwd* 文件，找出当前正在使用的最大用户 ID，该 ID 小于允许的最大用户账户值（此脚本使用的是
    5000，但你应该根据自己的配置进行调整），然后在其基础上加 1，作为新账户的用户 ID。这可以避免管理员记住下一个可用的 ID，同时，在用户社区发展和变化的过程中，它还可以提供高度一致的账户信息。
- en: The script creates an account with this user ID. Then it creates the account’s
    home directory and copies into it the contents of the */etc/skel* directory. By
    convention, the */etc/skel* directory is where a master *.cshrc*, *.login*, *.bashrc*,
    and *.profile* are kept, and on sites where there’s a web server offering `~account`
    service, a directory like */etc/skel/public_html* would also be copied across
    to the new home directory. This is super useful if your organization provisions
    Linux workstations or accounts with special bash configurations for engineers
    or developers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本使用这个用户 ID 创建一个账户。然后，它会创建该账户的主目录，并将 */etc/skel* 目录中的内容复制到该目录中。按惯例，*/etc/skel*
    目录中存放着主 *.cshrc*、*.login*、*.bashrc* 和 *.profile* 文件，如果站点上有提供 `~account` 服务的 Web
    服务器，还会将像 */etc/skel/public_html* 这样的目录复制到新的主目录中。如果你的组织为工程师或开发人员配置 Linux 工作站或账户并带有特定的
    bash 配置，这非常有用。
- en: '***Running the Script***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script must be run by root and has no starting arguments.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本必须由 root 用户运行，并且没有起始参数。
- en: '***The Results***'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: Our system already has an account named `tintin`, so we’ll ensure that `snowy`^([1](footnote.xhtml#fn01))
    has his own account too (shown in [Listing 5-15](ch05.xhtml#ch5ex15)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统已经有了一个名为 `tintin` 的账户，因此我们还将确保 `snowy`^([1](footnote.xhtml#fn01)) 也有自己的账户（见[Listing
    5-15](ch05.xhtml#ch5ex15)）。
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 5-15: Testing the* `*adduser*` *script*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-15：测试* `*adduser*` *脚本*'
- en: '***Hacking the Script***'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: One significant advantage of using your own `adduser` script is that you can
    add code and change the logic of certain operations without worrying about an
    OS upgrade stepping on the modifications. Possible modifications include automatically
    sending a welcome email that outlines usage guidelines and online help options,
    automatically printing out an account information sheet that can be routed to
    the user, adding a `firstname_lastname` or `firstname.lastname` alias to the mail
    *aliases* file, or even copying a set of files into the account so that the owner
    can immediately begin to work on a team project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义 `adduser` 脚本的一个显著优势是，你可以添加代码并更改某些操作的逻辑，而不必担心操作系统升级时覆盖这些修改。可能的修改包括自动发送欢迎电子邮件，概述使用指南和在线帮助选项；自动打印出账户信息表，并将其分发给用户；在邮件
    *aliases* 文件中添加 `firstname_lastname` 或 `firstname.lastname` 别名；甚至将一组文件复制到账户中，使得账户所有者可以立即开始进行团队项目。
- en: '**#41 Suspending a User Account**'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#41 挂起用户账户**'
- en: Whether a user is being escorted off the premises for industrial espionage,
    a student is taking the summer off, or a contractor is going on hiatus, there
    are many times when it’s useful to disable an account without actually deleting
    it from the system.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是因为工业间谍行为被护送出门，学生放暑假，还是承包商暂时休假，有时禁用账户而不删除它是非常有用的。
- en: This can be done simply by changing the user’s password to a new value that
    they aren’t told, but if the user is logged in at the time, it’s also important
    to log them out and shut off access to that home directory from other accounts
    on the system. When an account is suspended, odds are very good that the user
    needs to be off the system *now*—not when they feel like it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过将用户的密码更改为一个他们不知道的新值来简单完成，但如果用户此时已经登录，那么还需要确保将其登出，并关闭系统中其他账户对该主目录的访问权限。当账户被暂停时，很有可能该用户需要立即离开系统——而不是等到他们自己觉得合适的时候。
- en: Much of the script in [Listing 5-16](ch05.xhtml#ch5ex16) revolves around ascertaining
    whether the user is logged in, notifying the user that they are being logged off,
    and kicking the user off the system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-16](ch05.xhtml#ch5ex16)中的大部分脚本都集中在确定用户是否已登录，通知用户他们即将被登出，并将用户踢出系统。'
- en: '***The Code***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 5-16: The* `*suspenduser*` *script*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-16: `*suspenduser*` 脚本*'
- en: '***How It Works***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: This script changes the user’s password to a value unknown to the user and then
    shuts off the user’s home directory. If they are logged in, we give a few seconds’
    warning and then log the user out by killing all of their running processes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将用户的密码更改为一个用户不知道的值，然后关闭用户的主目录。如果用户已登录，我们会给出几秒钟的警告，然后通过终止他们所有正在运行的进程将用户登出。
- en: Notice how the script sends the `SIGHUP` (`HUP`) hang-up signal to each running
    process ➊ and then waits a second before sending the more aggressive `SIGKILL`
    (`KILL`) signal ➋. The `SIGHUP` signal quits running applications—except not *always*,
    and it won’t kill a login shell. The `SIGKILL` signal, however, can’t be ignored
    or blocked, so it’s guaranteed to be 100 percent effective. It’s not preferred,
    though, because it doesn’t give the application any time to clean up temporary
    files, flush file buffers to ensure that changes are written to disk, and so forth.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，脚本如何向每个正在运行的进程发送`SIGHUP`（`HUP`）挂起信号 ➊，然后等待一秒钟，再发送更具攻击性的`SIGKILL`（`KILL`）信号
    ➋。`SIGHUP`信号会退出正在运行的应用程序——但并非*总是如此*，它不会杀死登录的shell。然而，`SIGKILL`信号无法被忽视或阻止，因此它能确保100%有效。尽管如此，它并不是首选方法，因为它不给应用程序任何时间来清理临时文件，刷新文件缓冲区以确保更改写入磁盘，等等。
- en: Unsuspending a user is a simple two-step process of opening their home directory
    back up (with `chmod 700`) and resetting the password to a known value (with `passwd`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 取消暂停用户是一个简单的两步过程：首先通过`chmod 700`重新打开用户的主目录，然后通过`passwd`将密码重置为已知的值。
- en: '***Running the Script***'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'This script must be run as root, and it has one argument: the name of the account
    to suspend.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本必须以root身份运行，并且有一个参数：要暂停的账户名称。
- en: '***The Results***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: It turns out that `snowy` has already been abusing his account. Let’s suspend
    him, as shown in [Listing 5-17](ch05.xhtml#ch5ex17).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明，`snowy`已经在滥用他的账户。让我们按照[Listing 5-17](ch05.xhtml#ch5ex17)中的方式暂停他的账户。
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 5-17: Testing the* `*suspenduser*` *script on the user* `*snowy*`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-17: 在用户`*snowy*`上测试`*suspenduser*`脚本*'
- en: Since `snowy` was logged in at the time, [Listing 5-18](ch05.xhtml#ch5ex18)
    shows what he saw on his screen just seconds before he was kicked off the system.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`snowy`当时已登录，[Listing 5-18](ch05.xhtml#ch5ex18)展示了他在被踢出系统前几秒钟看到的屏幕内容。
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 5-18: The warning printed to a user’s terminals before they are suspended*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-18: 用户被暂停前显示的警告信息*'
- en: '**#42 Deleting a User Account**'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#42 删除用户账户**'
- en: Deleting an account is a bit more tricky than suspending it, because the script
    needs to check the entire filesystem for files owned by the user before the account
    information is removed from */etc/passwd* and */etc/shadow*. [Listing 5-19](ch05.xhtml#ch5ex19)
    ensures a user and their data are fully deleted from the system. It expects the
    previous `suspenduser` script is in the current `PATH`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 删除账户比暂停账户稍微复杂一些，因为脚本需要在从*/etc/passwd*和*/etc/shadow*中移除账户信息之前，检查整个文件系统中是否有该用户拥有的文件。[Listing
    5-19](ch05.xhtml#ch5ex19)确保用户及其数据被完全从系统中删除。它假设之前的`suspenduser`脚本已存在于当前的`PATH`中。
- en: '***The Code***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 5-19: The* `*deleteuser*` *script*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-19: `*deleteuser*` 脚本*'
- en: '***How It Works***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: To avoid anything changing in the to-be-suspended user’s account while the script
    is working, the very first task that `deleteuser` performs is to suspend the user
    account by calling `suspenduser`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免脚本运行时目标用户账户的任何更改，`deleteuser`执行的第一个任务是通过调用`suspenduser`来挂起用户账户。
- en: Before modifying the password file, this script locks it using the `lockfile`
    program if it’s available ➊. Alternatively, on Linux you could also look into
    using the `flock` utility for creating a file lock. If not, the script drops back
    to a relatively primitive semaphore locking mechanism through the creation of
    the file */etc/passwd.lock*. If the lock file already exists ➋, this script will
    wait for it to be deleted by another program; once it’s gone, `deleteuser` immediately
    creates it and proceeds ➌, deleting it when done ➍.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改密码文件之前，如果`lockfile`程序可用，脚本会先使用它锁定文件 ➊。或者，在Linux上，你也可以考虑使用`flock`工具来创建文件锁。如果没有，脚本会退回到一个相对原始的信号量锁定机制，通过创建文件*/etc/passwd.lock*来实现。如果锁文件已经存在
    ➋，该脚本将等待另一个程序删除它；一旦它被删除，`deleteuser`会立即创建该锁文件并继续执行 ➌，执行完成后再删除它 ➍。
- en: '***Running the Script***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This script must be run as root (use `sudo`) and needs the name of the account
    to delete as a command argument. [Listing 5-20](ch05.xhtml#ch5ex20) shows the
    script being run on the user `snowy`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本必须以root身份运行（使用`sudo`），并且需要提供要删除的账户名作为命令参数。[清单 5-20](ch05.xhtml#ch5ex20)展示了脚本在用户`snowy`上运行的示例。
- en: '**WARNING**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*This script is irreversible and causes lots of files to vanish, so be careful
    if you want to experiment with it!*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个脚本是不可逆的，且会导致许多文件消失，因此如果你想实验它，请小心！*'
- en: '***The Results***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 5-20: Testing the* `*deleteuser*` *script on the user* `*snowy*`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-20：测试* `*deleteuser*` *脚本，目标用户为* `*snowy*`'
- en: That sneaky `snowy` had hidden an AVI file (*dogbone.avi*) in */var/log*. Luckily
    we noticed that—who knows what it could be?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 那个狡猾的`snowy`在*/var/log*中隐藏了一个AVI文件（*dogbone.avi*）。幸运的是我们发现了它——谁知道它是什么呢？
- en: '***Hacking the Script***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***黑客脚本***'
- en: This `deleteuser` script is deliberately incomplete. You should decide what
    additional steps to take—whether to compress and archive a final copy of the account
    files, write them to tape, back them up on a cloud service, burn them to a DVD-ROM,
    or even mail them directly to the FBI (hopefully we’re just kidding on that last
    one). In addition, the account needs to be removed from the */etc/group* files.
    If there are stray files outside of the user’s home directory, the `find` command
    identifies them, but it’s still up to the sysadmin to examine and delete each
    one as appropriate.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`deleteuser`脚本故意不完整。你应该决定采取什么额外的步骤——无论是压缩并归档账户文件的最终副本，将其写入磁带，备份到云服务，刻录到DVD-ROM，还是直接邮寄给FBI（希望我们在最后一点开玩笑）。此外，还需要从*/etc/group*文件中删除该账户。如果有用户主目录之外的孤立文件，`find`命令会帮助找到它们，但仍然需要系统管理员检查并根据情况删除每一个文件。
- en: Another useful addition to this script would be a dry-run mode, allowing you
    to see what the script would remove from the system before actually performing
    the user deletion.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的一个有用补充是干运行模式，它可以让你在实际删除用户之前，先查看该脚本将从系统中删除哪些内容。
- en: '**#43 Validating the User Environment**'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#43 验证用户环境**'
- en: Because people migrate their login, profile, and other shell environment customizations
    from one system to another, it’s not uncommon for these settings to progressively
    decay; eventually, the `PATH` can include directories that aren’t on the system,
    the `PAGER` can point to a nonexistent binary, and worse.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于人们会将登录、配置文件以及其他Shell环境的定制从一个系统迁移到另一个系统，因此这些设置逐渐衰退是常见现象；最终，`PATH`可能包括一些系统上不存在的目录，`PAGER`可能指向一个不存在的二进制文件，等等。
- en: A sophisticated solution to this problem is to first check the `PATH` to ensure
    that it includes only valid directories on the system, and then to check each
    of the key helper application settings to ensure that they’re either indicating
    a fully qualified file that exists or are specifying a binary that’s in the `PATH`.
    This is detailed in [Listing 5-21](ch05.xhtml#ch5ex21).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的高级方案是，首先检查`PATH`，确保它只包含系统上有效的目录，然后检查每个关键帮助程序设置，确保它们要么指向一个存在的完全限定文件，要么指定一个在`PATH`中的二进制文件。这个过程在[清单
    5-21](ch05.xhtml#ch5ex21)中有详细说明。
- en: '***The Code***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 5-21: The* `*validator*` *script*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-21：* `*validator*` *脚本*'
- en: '***How It Works***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: 'The tests performed by this script aren’t overly complex. To check that all
    the directories in `PATH` are valid, the code steps through each directory to
    ensure that it exists ➏. Notice that the internal field separator (`IFS`) had
    to be changed to a colon at ➎ so that the script would properly step through all
    of the `PATH` directories. By convention, the `PATH` variable uses a colon to
    separate each of its directories:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本执行的测试并不复杂。为了检查 `PATH` 中的所有目录是否有效，代码会逐个检查每个目录，确保它存在 ➏。注意，在 ➎ 处需要将内部字段分隔符（`IFS`）更改为冒号，这样脚本才能正确地逐个检查所有的
    `PATH` 目录。按照惯例，`PATH` 变量使用冒号来分隔每个目录：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To validate that the environment variable values are valid, the `validate()`
    function ➋ first checks whether each value begins with a `/`. If it does, the
    function checks whether the variable is an executable. If it doesn’t begin with
    a `/`, the script calls the `in_path()` function imported from the library we
    started with [Script #1](ch01.xhtml#ch01lev1sec02) on [page 11](ch01.xhtml#page_11)
    ➊ to see whether the program is found in one of the directories in the current
    `PATH`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '为了验证环境变量值的有效性，`validate()` 函数 ➋ 首先检查每个值是否以 `/` 开头。如果是，它将检查该变量是否可执行。如果不是以 `/`
    开头，脚本会调用我们从库中引入的 `in_path()` 函数（在 [脚本 #1](ch01.xhtml#ch01lev1sec02) 的 [第 11 页](ch01.xhtml#page_11)
    中有提到） ➊ 来检查该程序是否能在当前 `PATH` 中的某个目录下找到。'
- en: The most unusual aspects of this script are its use of default values within
    some of the conditionals and its use of variable slicing. Its use of default values
    in the conditionals is exemplified by the line at ➍. The notation `${*varname*:?"*errorMessage*"}`
    can be read as “If `*varname*` exists, substitute its value; otherwise, fail with
    the error `*errorMessage*`.”
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本最不寻常的地方是它在某些条件语句中使用默认值以及变量切片。它在条件语句中使用默认值的例子可以在 ➍ 处看到。符号 `${*varname*:?"*errorMessage*"}`
    可以解释为：“如果 `*varname*` 存在，则替换它的值；否则，返回错误信息 `*errorMessage*`。”
- en: The variable-slicing notation `${varvalue%${varvalue#?}}` used at ➌ is the POSIX
    substring function, and it produces only the first character of the variable `varvalue`.
    In this script, it’s used to tell whether an environment variable has a fully
    qualified filename (one starting with `/` and specifying the path to the binary).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➌ 处使用的变量切片符号 `${varvalue%${varvalue#?}}` 是 POSIX 子字符串函数，它只提取变量 `varvalue`
    的第一个字符。在这个脚本中，它用于判断一个环境变量是否拥有一个完全限定的文件名（即以 `/` 开头并指定二进制文件路径的文件名）。
- en: 'If your version of Unix/Linux doesn’t support either of these notations, they
    can be replaced in a straightforward fashion. For example, instead of `${SHELL:?No
    Shell}`, you could substitute the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的 Unix/Linux 版本不支持这些符号，它们可以通过简单的方式替代。例如，代替 `${SHELL:?No Shell}`，你可以使用以下代码：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And instead of `{varvalue%${varvalue#?}}`, you could use this code to accomplish
    the same result:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用 `{varvalue%${varvalue#?}}`，可以用以下代码来实现相同的结果：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***Running the Script***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This is code that users can run to check their own environment. There are no
    starting arguments, as [Listing 5-22](ch05.xhtml#ch5ex22) shows.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用户可以运行的代码来检查自己的环境。如 [列表 5-22](ch05.xhtml#ch5ex22) 所示，脚本没有传入任何参数。
- en: '***The Results***'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 5-22: Testing the* `*validator*` *script*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-22：测试`*validator*`脚本*'
- en: '**#44 Cleaning Up After Guests Leave**'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#44 客人离开后的清理工作**'
- en: 'Although many sites disable the `guest` user for security reasons, others do
    have a guest account (often with a trivially guessable password) to allow clients
    or people from other departments to access the network. It’s a useful account,
    but there’s one big problem: with multiple people sharing the same account, it’s
    easy for someone to leave things messed up for the next user—maybe they were experimenting
    with commands, editing *.rc* files, adding subdirectories, or so forth.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多网站出于安全原因禁用了 `guest` 用户，其他网站仍然有访客账户（通常设置了一个容易猜到的密码），以便让客户或其他部门的人访问网络。这个账户很有用，但也有一个大问题：多个用户共享同一个账户，容易导致下一个用户使用时遇到麻烦——也许他们在试验命令、编辑
    *.rc* 文件、添加子目录，等等。
- en: This script in [Listing 5-23](ch05.xhtml#ch5ex23) addresses the problem by cleaning
    up the account space each time a user logs out of the guest account. It deletes
    any newly created files or subdirectories, removes all dotfiles, and rebuilds
    the official account files, copies of which are stored in a read-only archive
    tucked away in the guest account’s *.template* directory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-23](ch05.xhtml#ch5ex23)中的这个脚本通过在每次用户注销访客账户时清理账户空间来解决问题。它删除任何新创建的文件或子目录，移除所有点文件，并重建官方账户文件，这些文件的副本存储在访客账户的*.template*目录中的只读存档里。'
- en: '***The Code***'
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 5-23: The* `*fixguest*` *script*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-23：* `*fixguest*` *脚本*'
- en: '***How It Works***'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: For this script to work correctly, you’ll want to create a master set of template
    files and directories within the guest home directory, tucked into a new directory
    called *..template*. Change the permissions of the *..template* directory to be
    read-only and then ensure that all the files and directories within *..template*
    have the proper ownership and permissions for user `guest`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保此脚本正确运行，你需要在访客主目录中创建一个模板文件和目录的主集，并将其放入一个名为*..template*的新目录中。将*..template*目录的权限设置为只读，并确保*..template*目录中的所有文件和目录对用户`guest`具有正确的所有权和权限。
- en: '***Running the Script***'
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'A logical time to run the `fixguest` script is at logout, by invoking it in
    the *.logout* file (which works with most shells, though not all). Also, it’ll
    doubtless save you lots of complaints from users if the `login` script outputs
    a message like this one:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合理的执行`fixguest`脚本的时间是在注销时，可以在*.logout*文件中调用它（这适用于大多数shell，但并非全部）。此外，如果`login`脚本输出如下信息，肯定会为你节省很多来自用户的投诉：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, because some guest users might be savvy enough to tinker with the *.logout*
    file, it would be worthwhile to invoke the `fixguest` script from `cron` too.
    Just make sure no one is logged into the account when it runs!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于一些访客用户可能足够聪明，能够修改*.logout*文件，因此值得通过`cron`调用`fixguest`脚本。只要确保在脚本运行时没有人登录该账户！
- en: '***The Results***'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: There are no visible results from running this program, except that the `guest`
    home directory is restored to mirror the layout and files in the ..*template*
    directory.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序没有明显的结果，除了`guest`主目录恢复为与*..template*目录中的布局和文件相一致的状态。
