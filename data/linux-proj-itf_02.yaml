- en: Chapter 2. Fundamental Concepts
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2章 基本概念
- en: This chapter introduces a range of concepts related to Linux system programming.
    It is intended for readers who have worked primarily with other operating systems,
    or who have only limited experience with Linux or another UNIX implementation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些与Linux系统编程相关的概念，适合那些主要使用其他操作系统，或者仅有有限Linux或其他UNIX实现经验的读者。
- en: 'The Core Operating System: The Kernel'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心操作系统：内核
- en: 'The term *operating system* is commonly used with two different meanings:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作系统*一词通常有两种不同的含义：'
- en: To denote the entire package consisting of the central software managing a computer’s
    resources and all of the accompanying standard software tools, such as command-line
    interpreters, graphical user interfaces, file utilities, and editors.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用来指代整个软件包，它包括管理计算机资源的核心软件及所有附带的标准软件工具，如命令行解释器、图形用户界面、文件工具和编辑器。
- en: More narrowly, to refer to the central software that manages and allocates computer
    resources (i.e., the CPU, RAM, and devices).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更狭义地说，是指管理和分配计算机资源（即CPU、RAM和设备）的核心软件。
- en: The term *kernel* is often used as a synonym for the second meaning, and it
    is with this meaning of the term *operating system* that we are concerned in this
    book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*内核*一词通常作为“操作系统”第二种含义的同义词，我们在本书中关注的正是这一层面的*操作系统*。'
- en: Although it is possible to run programs on a computer without a kernel, the
    presence of a kernel greatly simplifies the writing and use of other programs,
    and increases the power and flexibility available to programmers. The kernel does
    this by providing a software layer to manage the limited resources of a computer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有内核也能在计算机上运行程序，但内核的存在极大地简化了其他程序的编写和使用，并增加了可供程序员使用的力量和灵活性。内核通过提供一个软件层来管理计算机有限的资源，从而实现这一点。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Linux kernel executable typically resides at the pathname `/boot/vmlinuz`,
    or something similar. The derivation of this filename is historical. On early
    UNIX implementations, the kernel was called `unix`. Later UNIX implementations,
    which implemented virtual memory, renamed the kernel as `vmunix`. On Linux, the
    filename mirrors the system name, with the *z* replacing the final *x* to signify
    that the kernel is a compressed executable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核的可执行文件通常位于路径 `/boot/vmlinuz`，或类似路径。这个文件名的来源是有历史背景的。在早期的UNIX实现中，内核被称为`unix`。后来的UNIX实现引入了虚拟内存，便将内核重命名为`vmunix`。在Linux中，文件名反映了系统名称，最后的*z*代替了*x*，表示内核是一个压缩的可执行文件。
- en: Tasks performed by the kernel
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内核执行的任务
- en: 'Among other things, the kernel performs the following tasks:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 内核执行以下任务：
- en: '*Process scheduling*: A computer has one or more central processing units (CPUs),
    which execute the instructions of programs. Like other UNIX systems, Linux is
    a *preemptive multitasking* operating system, *Multitasking* means that multiple
    processes (i.e., running programs) can simultaneously reside in memory and each
    may receive use of the CPU(s). *Preemptive* means that the rules governing which
    processes receive use of the CPU and for how long are determined by the kernel
    process scheduler (rather than by the processes themselves).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进程调度*：计算机有一个或多个中央处理单元（CPU），用于执行程序指令。像其他UNIX系统一样，Linux是一个*抢占式多任务*操作系统，*多任务*意味着多个进程（即运行中的程序）可以同时驻留在内存中，每个进程可以使用CPU。*抢占式*意味着哪些进程能使用CPU以及使用多长时间的规则由内核的进程调度器决定（而不是由进程本身决定）。'
- en: '*Memory management*: While computer memories are enormous by the standards
    of a decade or two ago, the size of software has also correspondingly grown, so
    that physical memory (RAM) remains a limited resource that the kernel must share
    among processes in an equitable and efficient fashion. Like most modern operating
    systems, Linux employs virtual memory management ([Virtual Memory Management](ch06.html#virtual_memory_management
    "Virtual Memory Management")), a technique that confers two main advantages:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存管理*：虽然按十几年前的标准来看，计算机的内存已经非常庞大，但软件的大小也相应地增加了，因此物理内存（RAM）仍然是一个有限的资源，内核必须以公平和高效的方式在进程之间分配。像大多数现代操作系统一样，Linux采用了虚拟内存管理（[虚拟内存管理](ch06.html#virtual_memory_management
    "虚拟内存管理")），这一技术带来了两个主要优势：'
- en: Processes are isolated from one another and from the kernel, so that one process
    can’t read or modify the memory of another process or the kernel.
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程相互隔离，并与内核隔离，这样一个进程不能读取或修改另一个进程或内核的内存。
- en: Only part of a process needs to be kept in memory, thereby lowering the memory
    requirements of each process and allowing more processes to be held in RAM simultaneously.
    This leads to better CPU utilization, since it increases the likelihood that,
    at any moment in time, there is at least one process that the CPU(s) can execute.
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需将进程的部分内容保留在内存中，从而降低了每个进程的内存需求，并允许同时在 RAM 中保存更多进程。这带来了更好的 CPU 利用率，因为它增加了在任何时刻至少有一个进程可以被
    CPU 执行的可能性。
- en: '*Provision of a file system*: The kernel provides a file system on disk, allowing
    files to be created, retrieved, updated, deleted, and so on.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供文件系统*：内核提供磁盘上的文件系统，允许创建、检索、更新、删除文件等操作。'
- en: '*Creation and termination of processes*: The kernel can load a new program
    into memory, providing it with the resources (e.g., CPU, memory, and access to
    files) that it needs in order to run. Such an instance of a running program is
    termed a *process*. Once a process has completed execution, the kernel ensures
    that the resources it uses are freed for subsequent reuse by later programs.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进程的创建与终止*：内核可以将一个新程序加载到内存中，为其提供运行所需的资源（例如，CPU、内存以及对文件的访问）。运行中的程序实例称为*进程*。一旦进程执行完成，内核会确保释放它使用的资源，以便后续的程序可以重新利用这些资源。'
- en: '*Access to devices*: The devices (mice, monitors, keyboards, disk and tape
    drives, and so on) attached to a computer allow communication of information between
    the computer and the outside world, permitting input, output, or both. The kernel
    provides programs with an interface that standardizes and simplifies access to
    devices, while at the same time arbitrating access by multiple processes to each
    device.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*访问设备*：连接到计算机的设备（鼠标、显示器、键盘、磁盘和磁带驱动器等）允许计算机与外部世界交换信息，实现输入、输出或两者兼有。内核为程序提供了一个接口，标准化并简化了对设备的访问，同时调度多个进程对每个设备的访问。'
- en: '*Networking*: The kernel transmits and receives network messages (packets)
    on behalf of user processes. This task includes routing of network packets to
    the target system.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*网络通信*：内核代表用户进程传输和接收网络消息（数据包）。这项任务包括将网络数据包路由到目标系统。'
- en: '*Provision of a system call application programming interface (API)*: Processes
    can request the kernel to perform various tasks using kernel entry points known
    as *system calls*. The Linux system call API is the primary topic of this book.
    [System Calls](ch03.html#system_calls "System Calls") details the steps that occur
    when a process performs a system call.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供系统调用应用程序编程接口（API）*：进程可以通过内核入口点（称为*系统调用*）请求内核执行各种任务。Linux 系统调用 API 是本书的主要内容。[系统调用](ch03.html#system_calls
    "系统调用")详细介绍了进程执行系统调用时的步骤。'
- en: In addition to the above features, multiuser operating systems such as Linux
    generally provide users with the abstraction of a *virtual private computer*;
    that is, each user can log on to the system and operate largely independently
    of other users. For example, each user has their own disk storage space (home
    directory). In addition, users can run programs, each of which gets a share of
    the CPU and operates in its own virtual address space, and these programs can
    independently access devices and transfer information over the network. The kernel
    resolves potential conflicts in accessing hardware resources, so users and processes
    are generally unaware of the conflicts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述功能外，像 Linux 这样的多用户操作系统通常为用户提供*虚拟私人计算机*的抽象；也就是说，每个用户都可以登录系统并在很大程度上独立于其他用户进行操作。例如，每个用户都有自己的磁盘存储空间（主目录）。此外，用户可以运行程序，每个程序都会获得
    CPU 的一部分资源并在自己的虚拟地址空间中运行，这些程序可以独立访问设备并通过网络传输信息。内核解决了访问硬件资源时可能出现的冲突，因此用户和进程通常不会察觉到这些冲突。
- en: Kernel mode and user mode
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内核模式与用户模式
- en: 'Modern processor architectures typically allow the CPU to operate in at least
    two different modes: *user mode* and *kernel mode* (sometimes also referred to
    as *supervisor mode*). Hardware instructions allow switching from one mode to
    the other. Correspondingly, areas of virtual memory can be marked as being part
    of *user space* or *kernel space*. When running in user mode, the CPU can access
    only memory that is marked as being in user space; attempts to access memory in
    kernel space result in a hardware exception. When running in kernel mode, the
    CPU can access both user and kernel memory space.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现代处理器架构通常允许CPU至少在两种不同的模式下操作：*用户模式*和*内核模式*（有时也称为*超级用户模式*）。硬件指令允许从一个模式切换到另一个模式。相应地，虚拟内存的区域可以被标记为属于*用户空间*或*内核空间*。在用户模式下运行时，CPU只能访问标记为用户空间的内存；尝试访问内核空间的内存会导致硬件异常。在内核模式下运行时，CPU可以访问用户和内核内存空间。
- en: Certain operations can be performed only while the processor is operating in
    kernel mode. Examples include executing the halt instruction to stop the system,
    accessing the memory-management hardware, and initiating device I/O operations.
    By taking advantage of this hardware design to place the operating system in kernel
    space, operating system implementers can ensure that user processes are not able
    to access the instructions and data structures of the kernel, or to perform operations
    that would adversely affect the operation of the system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 某些操作只能在处理器处于内核模式时执行。例如，执行停止指令以停止系统，访问内存管理硬件，以及发起设备输入输出操作。通过利用这种硬件设计将操作系统放入内核空间，操作系统实现者可以确保用户进程无法访问内核的指令和数据结构，也无法执行可能会不利于系统操作的操作。
- en: Process versus kernel views of the system
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进程与内核视角的对比
- en: In many everyday programming tasks, we are accustomed to thinking about programming
    in a process-oriented way. However, when considering various topics covered later
    in this book, it can be useful to reorient our perspective to consider things
    from the kernel’s point of view. To make the contrast clear, we now consider how
    things look first from a process viewpoint and then from a kernel viewpoint.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多日常编程任务中，我们习惯于以面向进程的方式进行编程。然而，在本书后面涉及的各种主题中，从内核的角度考虑问题可能会很有帮助。为了清楚地展示这种对比，我们现在先从进程视角来看看事物的表现，然后再从内核视角来考察。
- en: A running system typically has numerous processes. For a process, many things
    happen asynchronously. An executing process doesn’t know when it will next time
    out, which other processes will then be scheduled for the CPU (and in what order),
    or when it will next be scheduled. The delivery of signals and the occurrence
    of interprocess communication events are mediated by the kernel, and can occur
    at any time for a process. Many things happen transparently for a process. A process
    doesn’t know where it is located in RAM or, in general, whether a particular part
    of its memory space is currently resident in memory or held in the swap area (a
    reserved area of disk space used to supplement the computer’s RAM). Similarly,
    a process doesn’t know where on the disk drive the files it accesses are being
    held; it simply refers to the files by name. A process operates in isolation;
    it can’t directly communicate with another process. A process can’t itself create
    a new process or even end its own existence. Finally, a process can’t communicate
    directly with the input and output devices attached to the computer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个运行中的系统通常有多个进程。对于一个进程，许多事情是异步发生的。一个正在执行的进程并不知道它下次什么时候会超时，哪些其他进程会被调度到CPU（以及调度的顺序），或者它下次何时会被调度。信号的传递和进程间通信事件的发生是由内核调度的，并且可能在任何时候发生。许多事情对一个进程来说是透明的。一个进程并不知道它在RAM中的位置，或者一般来说，它的内存空间中的某一部分是否当前驻留在内存中，还是被保存在交换区（一个用于补充计算机RAM的磁盘空间保留区域）。类似地，一个进程也不知道它访问的文件在磁盘驱动器上的位置；它只是通过文件名引用这些文件。一个进程是在隔离中运行的；它不能直接与另一个进程通信。一个进程无法自己创建新进程，也不能结束自身的存在。最后，一个进程不能直接与连接到计算机的输入输出设备进行通信。
- en: By contrast, a running system has one kernel that knows and controls everything.
    The kernel facilitates the running of all processes on the system. The kernel
    decides which process will next obtain access to the CPU, when it will do so,
    and for how long. The kernel maintains data structures containing information
    about all running processes and updates these structures as processes are created,
    change state, and terminate. The kernel maintains all of the low-level data structures
    that enable the filenames used by programs to be translated into physical locations
    on the disk. The kernel also maintains data structures that map the virtual memory
    of each process into the physical memory of the computer and the swap area(s)
    on disk. All communication between processes is done via mechanisms provided by
    the kernel. In response to requests from processes, the kernel creates new processes
    and terminates existing processes. Lastly, the kernel (in particular, device drivers)
    performs all direct communication with input and output devices, transferring
    information to and from user processes as required.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，运行中的系统有一个内核，它知道并控制一切。内核帮助管理系统上所有进程的运行。内核决定哪个进程将获得下一次 CPU 访问权限、何时访问以及访问多长时间。内核维护包含所有运行进程信息的数据结构，并在进程创建、状态变化和终止时更新这些结构。内核维护所有低级数据结构，使程序使用的文件名能够被转换为磁盘上的物理位置。内核还维护将每个进程的虚拟内存映射到计算机的物理内存和磁盘交换区的数据结构。进程间的所有通信都通过内核提供的机制完成。响应进程的请求，内核创建新进程并终止现有进程。最后，内核（特别是设备驱动程序）执行所有与输入输出设备的直接通信，根据需要将信息传输到用户进程或从用户进程传输。
- en: Later in this book we’ll say things such as “a process can create another process,”
    “a process can create a pipe,” “a process can write data to a file,” and “a process
    can terminate by calling *exit()*.” Remember, however, that the kernel mediates
    all such actions, and these statements are just shorthand for “a process can *request
    that the kernel* create another process,” and so on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本书稍后会提到类似“一个进程可以创建另一个进程”、“一个进程可以创建一个管道”、“一个进程可以向文件写数据”以及“一个进程可以通过调用 *exit()*
    来终止”。但是，请记住，所有这些操作都由内核调解，而这些表述只是“一个进程可以 *请求内核* 创建另一个进程”等的简写形式。
- en: Further information
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多信息
- en: Modern texts covering operating systems concepts and design, with particular
    reference to UNIX systems, include [Tanenbaum, 2007], [Tanenbaum & Woodhull, 2006],
    and [Vahalia, 1996], the last of these containing much detail on virtual memory
    architectures. [Goodheart & Cox, 1994] provide details on System V Release 4\.
    [Maxwell, 1999] provides an annotated listing of selected parts of the Linux 2.2.5
    kernel. [Lions, 1996] is a detailed exposition of the Sixth Edition UNIX source
    code that remains a useful introduction to UNIX operating system internals. [Bovet
    & Cesati, 2005] describes the implementation of the Linux 2.6 kernel.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现代有关操作系统概念和设计的书籍，特别是参考 UNIX 系统的书籍，包含了 [Tanenbaum, 2007]、[Tanenbaum & Woodhull,
    2006] 和 [Vahalia, 1996]，后者包含了关于虚拟内存架构的详细内容。[Goodheart & Cox, 1994] 提供了关于 System
    V Release 4 的细节。[Maxwell, 1999] 提供了 Linux 2.2.5 内核的部分注释列表。[Lions, 1996] 是对第六版
    UNIX 源代码的详细阐述，仍然是 UNIX 操作系统内部结构的有用入门书籍。[Bovet & Cesati, 2005] 详细描述了 Linux 2.6
    内核的实现。
- en: The Shell
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shell
- en: A *shell* is a special-purpose program designed to read commands typed by a
    user and execute appropriate programs in response to those commands. Such a program
    is sometimes known as a *command interpreter*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shell* 是一个特殊的程序，用于读取用户输入的命令并根据这些命令执行相应的程序。这样的程序有时被称为 *命令解释器*。'
- en: The term *login shell* is used to denote the process that is created to run
    a shell when the user first logs in.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*登录 Shell* 这个术语用于表示在用户首次登录时创建并运行 Shell 的过程。'
- en: 'Whereas on some operating systems the command interpreter is an integral part
    of the kernel, on UNIX systems, the shell is a user process. Many different shells
    exist, and different users (or, for that matter, a single user) on the same computer
    can simultaneously use different shells. A number of important shells have appeared
    over time:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些操作系统中，命令解释器是内核的一个组成部分，而在 UNIX 系统中，Shell 是一个用户进程。存在许多不同的 Shell，且同一台计算机上的不同用户（或者说，同一个用户）可以同时使用不同的
    Shell。随着时间的推移，出现了许多重要的 Shell：
- en: '*Bourne shell* (*sh*): This is the oldest of the widely used shells, and was
    written by Steve Bourne. It was the standard shell for Seventh Edition UNIX. The
    Bourne shell contains many of the features familiar in all shells: I/O redirection,
    pipelines, filename generation (globbing), variables, manipulation of environment
    variables, command substitution, background command execution, and functions.
    All later UNIX implementations include the Bourne shell in addition to any other
    shells they might provide.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Bourne shell* (*sh*)：这是最古老的广泛使用的 shell，由 Steve Bourne 编写。它是第七版 UNIX 的标准 shell。Bourne
    shell 包含了所有 shell 中常见的许多功能：I/O 重定向、管道、文件名生成（通配符）、变量、环境变量操作、命令替换、后台命令执行以及函数。所有后来的
    UNIX 实现都包括 Bourne shell，除了它们可能提供的其他 shell。'
- en: '*C shell* (*csh*): This shell was written by Bill Joy at the University of
    California at Berkeley. The name derives from the resemblance of many of the flow-control
    constructs of this shell to those of the C programming language. The C shell provided
    several useful interactive features unavailable in the Bourne shell, including
    command history, command-line editing, job control, and aliases. The C shell was
    not backward compatible with the Bourne shell. Although the standard interactive
    shell on BSD was the C shell, shell scripts (described in a moment) were usually
    written for the Bourne shell, so as to be portable across all UNIX implementations.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C shell* (*csh*)：这个 shell 是由 Bill Joy 在加利福尼亚大学伯克利分校编写的。这个名字来源于该 shell 中许多流程控制构造与
    C 编程语言中的相似之处。C shell 提供了许多 Bourne shell 中没有的有用交互功能，包括命令历史、命令行编辑、作业控制和别名。C shell
    不兼容 Bourne shell。虽然 BSD 上的标准交互式 shell 是 C shell，但 shell 脚本（稍后会描述）通常是为 Bourne shell
    编写的，以确保它们能够跨所有 UNIX 实现移植。'
- en: '*Korn shell* (*ksh*): This shell was written as the successor to the Bourne
    shell by David Korn at AT&T Bell Laboratories. While maintaining backward compatibility
    with the Bourne shell, it also incorporated interactive features similar to those
    provided by the C shell.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Korn shell* (*ksh*)：这个 shell 是由 AT&T 贝尔实验室的 David Korn 编写的，作为 Bourne shell
    的继任者。在保持与 Bourne shell 的向后兼容性的同时，它还结合了类似于 C shell 提供的交互式功能。'
- en: '*Bourne again shell* (*bash*): This shell is the GNU project’s reimplementation
    of the Bourne shell. It supplies interactive features similar to those available
    in the C and Korn shells. The principal authors of *bash* are Brian Fox and Chet
    Ramey. Bash is probably the most widely used shell on Linux. (On Linux, the Bourne
    shell, *sh*, is typically provided by *bash* emulating *sh* as closely as possible.)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Bourne again shell* (*bash*)：这个 shell 是 GNU 项目重新实现的 Bourne shell。它提供了类似于 C
    shell 和 Korn shell 的交互功能。*bash* 的主要作者是 Brian Fox 和 Chet Ramey。Bash 可能是 Linux 上最广泛使用的
    shell。（在 Linux 上，Bourne shell，*sh*，通常由 *bash* 模拟，尽可能接近 *sh* 的实现。）'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: POSIX.2-1992 specified a standard for the shell that was based on the then current
    version of the Korn shell. Nowadays, the Korn shell and *bash* both conform to
    POSIX, but provide a number of extensions to the standard, and many of these extensions
    differ between the two shells.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX.2-1992 规定了一个标准的 shell，该标准基于当时版本的 Korn shell。如今，Korn shell 和 *bash* 都符合
    POSIX 标准，但它们提供了多个扩展，并且这些扩展在两个 shell 之间有所不同。
- en: 'The shells are designed not merely for interactive use, but also for the interpretation
    of *shell scripts*, which are text files containing shell commands. For this purpose,
    each of the shells has the facilities typically associated with programming languages:
    variables, loop and conditional statements, I/O commands, and functions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 shell 不仅仅是为了交互使用，还用于解释 *shell 脚本*，即包含 shell 命令的文本文件。为此，每个 shell 都具备了通常与编程语言相关的功能：变量、循环和条件语句、I/O
    命令以及函数。
- en: Each of the shells performs similar tasks, albeit with variations in syntax.
    Unless referring to the operation of a specific shell, we typically refer to “the
    shell,” with the understanding that all shells operate in the manner described.
    Most of the examples in this book that require a shell use *bash*, but, unless
    otherwise noted, the reader can assume these examples work the same way in other
    Bourne-type shells.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 shell 执行类似的任务，尽管语法有所不同。除非提到特定 shell 的操作，否则我们通常会称之为“shell”，并理解所有 shell 都是以描述的方式运行的。本书中大多数需要
    shell 的示例使用 *bash*，但是，除非特别说明，读者可以假设这些示例在其他 Bourne 类型的 shell 中也能以相同的方式工作。
- en: Users and Groups
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户与组
- en: Each user on the system is uniquely identified, and users may belong to groups.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的每个用户都有唯一标识，且用户可以属于不同的组。
- en: Users
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户
- en: 'Every user of the system has a unique *login name* (username) and a corresponding
    numeric *user ID* (UID). For each user, these are defined by a line in the system
    *password file*, `/etc/passwd`, which includes the following additional information:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的每个用户都有一个唯一的*登录名*（用户名）和一个对应的数字*用户 ID*（UID）。对于每个用户，这些信息由系统*密码文件*（`/etc/passwd`）中的一行定义，包含以下附加信息：
- en: '*Group ID*: the numeric group ID of the first of the groups of which the user
    is a member.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组 ID*：用户所属的第一个组的数字组 ID。'
- en: '*Home directory*: the initial directory into which the user is placed after
    logging in.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主目录*：用户登录后进入的初始目录。'
- en: '*Login shell*: the name of the program to be executed to interpret user commands.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*登录 shell*：用于解释用户命令的程序名称。'
- en: The password record may also include the user’s password, in encrypted form.
    However, for security reasons, the password is often stored in the separate *shadow
    password file*, which is readable only by privileged users.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 密码记录可能还包括用户的密码，以加密形式存储。然而，出于安全考虑，密码通常存储在单独的*影子密码文件*中，该文件仅对特权用户可读。
- en: Groups
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组
- en: 'For administrative purposes—in particular, for controlling access to files
    and other system resources—it is useful to organize users into *groups*. For example,
    the people in a team working on a single project, and thus sharing a common set
    of files, might all be made members of the same group. In early UNIX implementations,
    a user could be a member of only one group. BSD allowed a user to simultaneously
    belong to multiple groups, an idea that was taken up by other UNIX implementations
    and the POSIX.1-1990 standard. Each group is identified by a single line in the
    system *group file*, `/etc/group`, which includes the following information:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行管理——特别是为了控制对文件和其他系统资源的访问——将用户组织成*组*是非常有用的。例如，某个团队中参与同一项目的人员，因而共享一套公共文件，可能会被加入同一个组。在早期的
    UNIX 实现中，用户只能属于一个组。BSD 系统允许用户同时属于多个组，这一想法被其他 UNIX 实现和 POSIX.1-1990 标准采纳。每个组通过系统的*组文件*（`/etc/group`）中的一行来标识，该行包含以下信息：
- en: '*Group name*: the (unique) name of the group.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组名称*：该组的（唯一）名称。'
- en: '*Group ID* (GID): the numeric ID associated with this group.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组 ID*（GID）：与此组关联的数字 ID。'
- en: '*User list*: a comma-separated list of login names of users who are members
    of this group (and who are not otherwise identified as members of the group by
    virtue of the group ID field of their password file record).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户列表*：以逗号分隔的登录名列表，列出该组的成员用户（这些用户并未通过密码文件记录中的组 ID 字段被标识为该组的成员）。'
- en: Superuser
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 超级用户
- en: One user, known as the *superuser*, has special privileges within the system.
    The superuser account has user ID 0, and normally has the login name *root*. On
    typical UNIX systems, the superuser bypasses all permission checks in the system.
    Thus, for example, the superuser can access any file in the system, regardless
    of the permissions on that file, and can send signals to any user process in the
    system. The system administrator uses the superuser account to perform various
    administrative tasks on the system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用户，称为*超级用户*，在系统中具有特殊权限。超级用户账户的用户 ID 为 0，通常登录名为*root*。在典型的 UNIX 系统中，超级用户绕过系统中的所有权限检查。因此，例如，超级用户可以访问系统中的任何文件，无论该文件的权限如何，并且可以向系统中的任何用户进程发送信号。系统管理员使用超级用户账户执行各种系统管理任务。
- en: Single Directory Hierarchy, Directories, Links, and Files
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一目录层次结构、目录、链接和文件
- en: The kernel maintains a single hierarchical directory structure to organize all
    files in the system. (This contrasts with operating systems such as Microsoft
    Windows, where each disk device has its own directory hierarchy.) At the base
    of this hierarchy is the *root directory*, named `/` (slash). All files and directories
    are children or further removed descendants of the root directory. [Figure 2-1](ch02.html#subset_of_the_linux_single_directory_hie
    "Figure 2-1. Subset of the Linux single directory hierarchy") shows an example
    of this hierarchical file structure.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 内核维护着一个单一的层次化目录结构，用于组织系统中的所有文件。（这与操作系统如 Microsoft Windows 不同，后者每个磁盘设备都有自己的目录层次结构。）该层次结构的根目录是*根目录*，名为
    `/`（斜杠）。所有文件和目录都是根目录的子目录或进一步的后代。[图 2-1](ch02.html#subset_of_the_linux_single_directory_hie
    "图 2-1. Linux 单一目录层次结构示例") 显示了这种层次化文件结构的示例。
- en: '![Subset of the Linux single directory hierarchy](figs/web/02-1_CONCEPTS-file-system.png.jpg)Figure 2-1. Subset
    of the Linux single directory hierarchy'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![Linux单一目录层次结构的子集](figs/web/02-1_CONCEPTS-file-system.png.jpg)图2-1. Linux单一目录层次结构的子集'
- en: File types
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件类型
- en: Within the file system, each file is marked with a *type*, indicating what kind
    of file it is. One of these file types denotes ordinary data files, which are
    usually called *regular* or *plain* files to distinguish them from other file
    types. These other file types include devices, pipes, sockets, directories, and
    symbolic links.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统中，每个文件都有一个*类型*标识，表示它属于哪种文件类型。文件类型之一表示普通数据文件，这些文件通常被称为*常规*或*普通*文件，以区别于其他类型的文件。这些其他文件类型包括设备、管道、套接字、目录和符号链接。
- en: The term *file* is commonly used to denote a file of any type, not just a regular
    file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件*一词通常用于表示任何类型的文件，而不仅仅是常规文件。'
- en: Directories and links
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目录与链接
- en: A *directory* is a special file whose contents take the form of a table of filenames
    coupled with references to the corresponding files. This filename-plus-reference
    association is called a *link*, and files may have multiple links, and thus multiple
    names, in the same or in different directories.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*目录*是一种特殊的文件，其内容形式为文件名的表格，并附有对相应文件的引用。这种文件名加引用的关联叫做*链接*，一个文件可以在同一目录或不同目录中有多个链接，从而有多个名称。'
- en: Directories may contain links both to files and to other directories. The links
    between directories establish the directory hierarchy shown in [Figure 2-1](ch02.html#subset_of_the_linux_single_directory_hie
    "Figure 2-1. Subset of the Linux single directory hierarchy").
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 目录可以包含指向文件和其他目录的链接。目录之间的链接建立了[图2-1](ch02.html#subset_of_the_linux_single_directory_hie
    "图2-1. Linux单一目录层次结构的子集")所示的目录层次结构。
- en: 'Every directory contains at least two entries: `.` (dot), which is a link to
    the directory itself, and `..` (dot-dot), which is a link to its *parent directory*,
    the directory above it in the hierarchy. Every directory, except the root directory,
    has a parent. For the root directory, the dot-dot entry is a link to the root
    directory itself (thus, `/..` equates to `/`).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目录至少包含两个条目：`.`（点），这是指向目录本身的链接；以及`..`（点点），这是指向其*父目录*的链接，即层次结构中上一级的目录。每个目录，除了根目录外，都有一个父目录。对于根目录，点点条目是指向根目录本身的链接（因此，`/..`等同于`/`）。
- en: Symbolic links
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 符号链接
- en: Like a normal link, a *symbolic link* provides an alternative name for a file.
    But whereas a normal link is a filename-plus-pointer entry in a directory list,
    a symbolic link is a specially marked file containing the name of another file.
    (In other words, a symbolic link has a filename-plus-pointer entry in a directory,
    and the file referred to by the pointer contains a string that names another file.)
    This latter file is often called the *target* of the symbolic link, and it is
    common to say that the symbolic link “points” or “refers” to the target file.
    When a pathname is specified in a system call, in most circumstances, the kernel
    automatically *dereferences* (or synonymously, *follows*) each symbolic link in
    the pathname, replacing it with the filename to which it points. This process
    may happen recursively if the target of a symbolic link is itself a symbolic link.
    (The kernel imposes limits on the number of dereferences to handle the possibility
    of circular chains of symbolic links.) If a symbolic link refers to a file that
    doesn’t exist, it is said to be a *dangling link*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 像普通链接一样，*符号链接*为文件提供了一个替代名称。但普通链接是目录列表中的文件名加指针条目，而符号链接是一个特别标记的文件，包含另一个文件的名称。（换句话说，符号链接在目录中有一个文件名加指针条目，而指针指向的文件包含一个字符串，表示另一个文件的名称。）这个后者的文件通常称为*符号链接的目标*，常说符号链接“指向”或“引用”目标文件。当在系统调用中指定路径名时，在大多数情况下，内核会自动*解除引用*（或同义地，*跟随*）路径名中的每个符号链接，并将其替换为指向的文件名。如果符号链接的目标本身是符号链接，这个过程可能会递归发生。（内核对解除引用的次数施加限制，以处理符号链接的循环链条问题。）如果符号链接指向一个不存在的文件，则称为*悬空链接*。
- en: Often *hard link* and *soft link* are used as alternative terms for normal and
    symbolic links. The reasons for having two different types of links are explained
    in [Chapter 18](ch18.html "Chapter 18. Directories and Links").
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*硬链接*和*软链接*常作为普通链接和符号链接的替代术语。为何要有两种不同类型的链接，解释请参见[第18章](ch18.html "第18章. 目录与链接")。'
- en: Filenames
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件名
- en: On most Linux file systems, filenames can be up to 255 characters long. Filenames
    may contain any characters except slashes (`/`) and null characters (`\`0). However,
    it is advisable to employ only letters and digits, and the . (period), _ (underscore),
    and - (hyphen) characters. This 65-character set, `[-._a-zA-Z0-9`], is referred
    to in SUSv3 as the *portable filename character set*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Linux 文件系统中，文件名最多可以有 255 个字符。文件名可以包含除了斜杠（`/`）和空字符（`\0`）之外的任何字符。不过，建议仅使用字母、数字以及.（句点）、_（下划线）和-（连字符）字符。这个
    65 个字符的字符集，`[-._a-zA-Z0-9]`，在SUSv3中被称为*可移植文件名字符集*。
- en: We should avoid the use of characters in filenames that are not in the portable
    filename character set because those characters may have special meanings within
    the shell, within regular expressions, or in other contexts. If a filename containing
    characters with special meanings appears in such contexts, then these characters
    must be *escaped*; that is, specially marked—typically with a preceding backslash
    (`\`)—to indicate that they should not be interpreted with those special meanings.
    In contexts where no escape mechanism is available, the filename is not usable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该避免在文件名中使用不属于可移植文件名字符集的字符，因为这些字符在 Shell、正则表达式或其他上下文中可能有特殊意义。如果包含有特殊意义字符的文件名出现在这些上下文中，则必须对这些字符进行*转义*；也就是说，必须特别标记——通常是在前面加上反斜杠（`\`）——以表明这些字符不应按特殊意义进行解释。在没有转义机制的上下文中，这样的文件名不可用。
- en: We should also avoid filenames beginning with a hyphen (`-`), since such filenames
    may be mistaken for options when specified in a shell command.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该避免使用以连字符（`-`）开头的文件名，因为在 Shell 命令中指定这样的文件名时，可能会被误认为是选项。
- en: Pathnames
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路径名
- en: A *pathname* is a string consisting of an optional initial slash (`/`) followed
    by a series of filenames separated by slashes. All but the last of these component
    filenames identifies a directory (or a symbolic link that resolves to a directory).
    The last component of a pathname may identify any type of file, including a directory.
    The series of component filenames preceding the final slash is sometimes referred
    to as the *directory* part of a pathname, while the name following the final slash
    is sometimes referred to as the file or *base* part of the pathname.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*路径名*是一个字符串，由可选的初始斜杠（`/`）和一系列由斜杠分隔的文件名组成。除最后一个文件名外，这些组件文件名标识一个目录（或一个解析为目录的符号链接）。路径名的最后一个组件可以标识任何类型的文件，包括目录。路径名前面部分的文件名序列有时称为路径名的*目录*部分，而最后一个斜杠后面的名字有时称为路径名的文件或*基础*部分。'
- en: A pathname is read from left to right; each filename resides in the directory
    specified by the preceding part of the pathname. The string `..` can be used anywhere
    in a pathname to refer to the parent of the location so far specified in the pathname.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 路径名是从左到右读取的；每个文件名位于路径名前面部分指定的目录中。字符串`..`可以在路径名的任何位置使用，表示当前指定位置的父级目录。
- en: 'A pathname describes the location of a file within the single directory hierarchy,
    and is either absolute or relative:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 路径名描述了文件在单一目录层次结构中的位置，可以是绝对路径名或相对路径名：
- en: An *absolute pathname* begins with a slash (`/`) and specifies the location
    of a file with respect to the root directory. Examples of absolute pathnames for
    files in [Figure 2-1](ch02.html#subset_of_the_linux_single_directory_hie "Figure 2-1. Subset
    of the Linux single directory hierarchy") are `/home/mtk/.bashrc`, `/usr/include`,
    and `/` (the pathname of the root directory).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绝对路径名*以斜杠（`/`）开始，指定相对于根目录的文件位置。在[图 2-1](ch02.html#subset_of_the_linux_single_directory_hie
    "图 2-1. Linux 单一目录层次结构的子集")中的绝对路径名示例有`/home/mtk/.bashrc`、`/usr/include`和`/`（根目录的路径名）。'
- en: A *relative pathname* specifies the location of a file relative to a process’s
    current working directory (see below), and is distinguished from an absolute pathname
    by the absence of an initial slash. In [Figure 2-1](ch02.html#subset_of_the_linux_single_directory_hie
    "Figure 2-1. Subset of the Linux single directory hierarchy"), from the directory
    `usr`, the file `types.h` could be referenced using the relative pathname `include/sys/types.h`,
    while from the directory `avr`, the file `.bashrc` could be accessed using the
    relative pathname `../mtk/.bashrc`.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*相对路径名*指定了相对于进程当前工作目录（见下文）的文件位置，并且与绝对路径名的区别在于它没有初始的斜杠。在[图 2-1](ch02.html#subset_of_the_linux_single_directory_hie
    "图 2-1. Linux 单一目录层次结构的子集")中，从目录`usr`可以使用相对路径名`include/sys/types.h`引用文件`types.h`，而从目录`avr`则可以使用相对路径名`../mtk/.bashrc`访问文件`.bashrc`。'
- en: Current working directory
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 当前工作目录
- en: Each process has a *current working directory* (sometimes just referred to as
    the process’s *working directory* or *current directory*). This is the process’s
    “current location” within the single directory hierarchy, and it is from this
    directory that relative pathnames are interpreted for the process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个*当前工作目录*（有时称为进程的*工作目录*或*当前目录*）。这是进程在单一目录层次结构中的“当前位置”，并且从这个目录开始，相对路径名会被进程解释。
- en: A process inherits its current working directory from its parent process. A
    login shell has its initial current working directory set to the location named
    in the home directory field of the user’s password file entry. The shell’s current
    working directory can be changed with the *cd* command.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 进程继承其当前工作目录自父进程。登录 shell 的初始当前工作目录设置为用户密码文件条目中的主目录字段所指定的位置。可以使用*cd*命令更改 shell
    的当前工作目录。
- en: File ownership and permissions
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件所有权和权限
- en: Each file has an associated user ID and group ID that define the owner of the
    file and the group to which it belongs. The ownership of a file is used to determine
    the access rights available to users of the file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件都有一个关联的用户 ID 和组 ID，用来定义文件的所有者和所属的组。文件的所有权用于确定用户对文件的访问权限。
- en: 'For the purpose of accessing a file, the system divides users into three categories:
    the *owner* of the file (sometimes termed the *user* of the file), users who are
    members of the group matching the file’s group ID (*group*), and the rest of the
    world (*other*). Three permission bits may be set for each of these categories
    of user (making a total of nine permission bits): *read* permission allows the
    contents of the file to be read; *write* permission allows modification of the
    contents of the file; and *execute* permission allows execution of the file, which
    is either a program or a script to be processed by some interpreter (usually,
    but not always, one of the shells).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问文件，系统将用户分为三类：文件的*所有者*（有时称为文件的*用户*）、属于与文件组 ID 匹配的组的用户（*组*），以及其他所有人（*其他*）。对于每个用户类别，可以设置三个权限位（总共九个位权限）：*读取*权限允许读取文件内容；*写入*权限允许修改文件内容；*执行*权限允许执行文件，这个文件可以是程序或由某个解释器（通常是
    shell，但不总是）处理的脚本。
- en: 'These permissions may also be set on directories, although their meanings are
    slightly different: *read* permission allows the contents of (i.e., the filenames
    in) the directory to be listed; *write* permission allows the contents of the
    directory to be changed (i.e., filenames can be added, removed, and changed);
    and *execute* (sometimes called *search*) permission allows access to files within
    the directory (subject to the permissions on the files themselves).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些权限也可以设置在目录上，尽管它们的含义略有不同：*读取*权限允许列出目录中的内容（即目录中的文件名）；*写入*权限允许更改目录中的内容（即可以添加、删除和更改文件名）；*执行*（有时称为*搜索*）权限允许访问目录内的文件（取决于文件本身的权限）。
- en: File I/O Model
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件 I/O 模型
- en: One of the distinguishing features of the I/O model on UNIX systems is the concept
    of *universality of I/O*. This means that the same system calls (*open()*, *read()*,
    *write()*, *close()*, and so on) are used to perform I/O on all types of files,
    including devices. (The kernel translates the application’s I/O requests into
    appropriate file-system or device-driver operations that perform I/O on the target
    file or device.) Thus, a program employing these system calls will work on any
    type of file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX 系统 I/O 模型的一个显著特点是*I/O 的普遍性*概念。这意味着相同的系统调用（*open()*, *read()*, *write()*,
    *close()* 等）用于对所有类型的文件进行 I/O 操作，包括设备。（内核将应用程序的 I/O 请求转换为适当的文件系统或设备驱动程序操作，以对目标文件或设备执行
    I/O。）因此，使用这些系统调用的程序将适用于任何类型的文件。
- en: 'The kernel essentially provides one file type: a sequential stream of bytes,
    which, in the case of disk files, disks, and tape devices, can be randomly accessed
    using the *lseek()* system call.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 内核基本上提供了一种文件类型：字节的顺序流，在磁盘文件、磁盘和磁带设备的情况下，可以使用*lseek()*系统调用进行随机访问。
- en: Many applications and libraries interpret the *newline* character (ASCII code
    10 decimal, sometimes also known as *linefeed*) as terminating one line of text
    and commencing another. UNIX systems have no *end-of-file* character; the end
    of a file is detected by a read that returns no data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序和库将 *换行* 字符（ASCII 码 10，十进制，有时也称为 *换行符*）解释为终止一行文本并开始另一行。UNIX 系统没有 *文件结束*
    字符；文件的结束是通过读取时没有返回数据来检测的。
- en: File descriptors
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件描述符
- en: The I/O system calls refer to open files using a *file descriptor*, a (usually
    small) nonnegative integer. A file descriptor is typically obtained by a call
    to *open()*, which takes a pathname argument specifying a file upon which I/O
    is to be performed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 系统调用通过*文件描述符*来引用打开的文件，文件描述符是一个（通常较小的）非负整数。文件描述符通常通过调用 *open()* 获取，该函数接受一个指定要进行
    I/O 操作的文件路径名参数。
- en: 'Normally, a process inherits three open file descriptors when it is started
    by the shell: descriptor 0 is *standard input*, the file from which the process
    takes its input; descriptor 1 is *standard output*, the file to which the process
    writes its output; and descriptor 2 is *standard error*, the file to which the
    process writes error messages and notification of exceptional or abnormal conditions.
    In an interactive shell or program, these three descriptors are normally connected
    to the terminal. In the *stdio* library, these descriptors correspond to the file
    streams *stdin*, *stdout*, and *stderr*.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，进程在由 shell 启动时会继承三个打开的文件描述符：描述符 0 是*标准输入*，即进程获取输入的文件；描述符 1 是*标准输出*，即进程输出结果的文件；描述符
    2 是*标准错误*，即进程输出错误消息和异常或不正常条件通知的文件。在交互式 shell 或程序中，这三个描述符通常连接到终端。在 *stdio* 库中，这些描述符对应于文件流
    *stdin*、*stdout* 和 *stderr*。
- en: The *stdio* library
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*stdio* 库'
- en: To perform file I/O, C programs typically employ I/O functions contained in
    the standard C library. This set of functions, referred to as the *stdio* library,
    includes *fopen()*, *fclose()*, *scanf()*, *printf()*, *fgets()*, *fputs()*, and
    so on. The *stdio* functions are layered on top of the I/O system calls (*open()*,
    *close()*, *read()*, *write()*, and so on).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行文件 I/O，C 程序通常会使用标准 C 库中的 I/O 函数。这些函数集合称为 *stdio* 库，包含了 *fopen()*、*fclose()*、*scanf()*、*printf()*、*fgets()*、*fputs()*
    等等。*stdio* 函数是建立在 I/O 系统调用（如 *open()*、*close()*、*read()*、*write()* 等）的基础上的。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We assume that the reader is already familiar with the C standard I/O (*stdio*)
    functions, and don’t cover them in this book. Further information on the *stdio*
    library can be found in [Kernighan & Ritchie, 1988], [Harbison & Steele, 2002],
    [Plauger, 1992], and [Stevens & Rago, 2005].
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设读者已经熟悉 C 标准 I/O (*stdio*) 函数，本书不再涉及这些内容。有关 *stdio* 库的更多信息，可以参考 [Kernighan
    & Ritchie, 1988]、[Harbison & Steele, 2002]、[Plauger, 1992] 和 [Stevens & Rago,
    2005]。
- en: Programs
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序
- en: '*Programs* normally exist in two forms. The first form is *source code*, human-readable
    text consisting of a series of statements written in a programming language such
    as C. To be executed, source code must be converted to the second form: binary
    machine-language instructions that the computer can understand. (This contrasts
    with a *script*, which is a text file containing commands to be directly processed
    by a program such as a shell or other command interpreter.) The two meanings of
    the term *program* are normally considered synonymous, since the step of compiling
    and linking converts source code into semantically equivalent binary machine code.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*程序*通常有两种形式。第一种形式是*源代码*，它是由一系列使用编程语言（如 C）编写的、易于人类阅读的文本语句。为了执行，源代码必须转换为第二种形式：计算机能够理解的二进制机器语言指令。（这与*脚本*不同，脚本是包含一系列命令的文本文件，命令会直接被程序处理，如
    shell 或其他命令解释器。）这两种意义下的*程序*通常被认为是同义的，因为编译和链接的步骤将源代码转换为语义上等价的二进制机器码。'
- en: Filters
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过滤器
- en: A *filter* is the name often applied to a program that reads its input from
    *stdin*, performs some transformation of that input, and writes the transformed
    data to *stdout*. Examples of filters include *cat*, *grep*, *tr*, *sort*, *wc*,
    *sed*, and *awk*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*过滤器* 是一个常用的名称，指的是一种从 *stdin* 获取输入、对输入进行某些变换并将变换后的数据写入 *stdout* 的程序。过滤器的例子包括
    *cat*、*grep*、*tr*、*sort*、*wc*、*sed* 和 *awk*。'
- en: Command-line arguments
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命令行参数
- en: 'In C, programs can access the *command-line arguments*, the words that are
    supplied on the command line when the program is run. To access the command-line
    arguments, the *main()* function of the program is declared as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，程序可以访问*命令行参数*，即程序运行时在命令行上提供的单词。要访问命令行参数，程序的*main()*函数需要按以下方式声明：
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The *argc* variable contains the total number of command-line arguments, and
    the individual arguments are available as strings pointed to by members of the
    array *argv*. The first of these strings, *argv[0]*, identifies the name of the
    program itself.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*argc*变量包含命令行参数的总数，单独的参数作为由*argv*数组成员指向的字符串提供。第一个字符串*argv[0]*表示程序本身的名称。'
- en: Processes
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程
- en: Put most simply, a *process* is an instance of an executing program. When a
    program is executed, the kernel loads the code of the program into virtual memory,
    allocates space for program variables, and sets up kernel bookkeeping data structures
    to record various information (such as process ID, termination status, user IDs,
    and group IDs) about the process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，*进程*是一个正在执行的程序的实例。当程序执行时，内核将程序代码加载到虚拟内存中，为程序变量分配空间，并设置内核的书籍数据结构来记录有关进程的各种信息（如进程ID、终止状态、用户ID和组ID）。
- en: From a kernel point of view, processes are the entities among which the kernel
    must share the various resources of the computer. For resources that are limited,
    such as memory, the kernel initially allocates some amount of the resource to
    the process, and adjusts this allocation over the lifetime of the process in response
    to the demands of the process and the overall system demand for that resource.
    When the process terminates, all such resources are released for reuse by other
    processes. Other resources, such as the CPU and network bandwidth, are renewable,
    but must be shared equitably among all processes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核的角度来看，进程是内核必须共享计算机各种资源的实体。对于有限的资源，如内存，内核最初为进程分配一些资源，并根据进程的需求和系统对该资源的总体需求在进程的生命周期中调整这种分配。当进程终止时，所有这些资源都会被释放，以供其他进程重新使用。其他资源，如CPU和网络带宽，虽然是可再生的，但必须在所有进程之间公平共享。
- en: Process memory layout
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进程内存布局
- en: 'A process is logically divided into the following parts, known as *segments*:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 进程逻辑上被分为以下部分，称为*段*：
- en: '*Text*: the instructions of the program.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文本*：程序的说明。'
- en: '*Data*: the static variables used by the program.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据*：程序使用的静态变量。'
- en: '*Heap*: an area from which programs can dynamically allocate extra memory.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*堆*：一个程序可以从中动态分配额外内存的区域。'
- en: '*Stack*: a piece of memory that grows and shrinks as functions are called and
    return and that is used to allocate storage for local variables and function call
    linkage information.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*堆栈*：一块内存，随着函数调用和返回而增长和缩小，用于分配局部变量和函数调用链接信息的存储。'
- en: Process creation and program execution
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进程创建与程序执行
- en: A process can create a new process using the *fork()* system call. The process
    that calls *fork()* is referred to as the *parent process*, and the new process
    is referred to as the *child process*. The kernel creates the child process by
    making a duplicate of the parent process. The child inherits copies of the parent’s
    data, stack, and heap segments, which it may then modify independently of the
    parent’s copies. (The program text, which is placed in memory marked as read-only,
    is shared by the two processes.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以通过调用*fork()*系统调用来创建新进程。调用*fork()*的进程被称为*父进程*，新创建的进程被称为*子进程*。内核通过制作父进程的副本来创建子进程。子进程继承父进程的数据、堆栈和堆段的副本，随后可以独立于父进程的副本进行修改。（程序文本位于标记为只读的内存中，两个进程共享该部分内存。）
- en: The child process goes on either to execute a different set of functions in
    the same code as the parent, or, frequently, to use the *execve()* system call
    to load and execute an entirely new program. An *execve()* call destroys the existing
    text, data, stack, and heap segments, replacing them with new segments based on
    the code of the new program.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程可以执行与父进程相同代码中的不同功能集，或者通常使用*execve()*系统调用加载并执行一个全新的程序。*execve()*调用会销毁现有的文本、数据、堆栈和堆段，并用基于新程序代码的段替代它们。
- en: Several related C library functions are layered on top of *execve()*, each providing
    a slightly different interface to the same functionality. All of these functions
    have names starting with the string *exec*, and where the differences don’t matter,
    we’ll use the notation *exec()* to refer generally to these functions. Be aware,
    however, that there is no actual function with the name *exec()*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 几个相关的C库函数在*execve()*之上层叠，每个函数提供略有不同的接口来实现相同的功能。所有这些函数的名称都以*exec*字符串开头，且在差异不重要的情况下，我们将使用*exec()*表示这些函数。需要注意的是，实际上并没有名为*exec()*的函数。
- en: Commonly, we’ll use the verb *to exec* to describe the operation performed *execve()*
    and the library functions layered on top of it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会使用动词*to exec*来描述执行*execve()*以及其上层库函数执行的操作。
- en: Process ID and parent process ID
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进程ID和父进程ID
- en: Each process has a unique integer *process identifier* (PID). Each process also
    has a *parent process identifier* (PPID) attribute, which identifies the process
    that requested the kernel to create this process.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个独特的整数*进程标识符*（PID）。每个进程还具有一个*父进程标识符*（PPID）属性，用于标识请求内核创建该进程的进程。
- en: Process termination and termination status
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进程终止与终止状态
- en: 'A process can terminate in one of two ways: by requesting its own termination
    using the *_exit()* system call (or the related *exit()* library function), or
    by being killed by the delivery of a signal. In either case, the process yields
    a *termination status*, a small nonnegative integer value that is available for
    inspection by the parent process using the *wait()* system call. In the case of
    a call to _*exit()*, the process explicitly specifies its own termination status.
    If a process is killed by a signal, the termination status is set according to
    the type of signal that caused the death of the process. (Sometimes, we’ll refer
    to the argument passed to _*exit()* as the *exit status* of the process, as distinct
    from the termination status, which is either the value passed to _*exit()* or
    an indication of the signal that killed the process.)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以通过两种方式终止：通过使用*_exit()*系统调用（或相关的*exit()*库函数）请求自身终止，或通过信号的发送将其终止。在这两种情况下，进程都会产生一个*终止状态*，这是一个小的非负整数值，父进程可以通过*wait()*系统调用检查该状态。如果调用了_*exit()*，进程将明确指定其终止状态。如果进程被信号杀死，终止状态将根据导致进程死亡的信号类型进行设置。（有时，我们会将传递给_*exit()*的参数称为进程的*退出状态*，以区别于终止状态，后者要么是传递给_*exit()*的值，要么是指示杀死进程的信号。）
- en: By convention, a termination status of 0 indicates that the process succeeded,
    and a nonzero status indicates that some error occurred. Most shells make the
    termination status of the last executed program available via a shell variable
    named *$?*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，终止状态为0表示进程成功，非零状态表示发生了某种错误。大多数shell通过名为*$?*的shell变量提供最后执行程序的终止状态。
- en: Process user and group identifiers (credentials)
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进程的用户标识符和组标识符（凭证）
- en: 'Each process has a number of associated user IDs (UIDs) and group IDs (GIDs).
    These include:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有多个相关联的用户ID（UID）和组ID（GID）。这些包括：
- en: '*Real user ID* and *real group ID*: These identify the user and group to which
    the process belongs. A new process inherits these IDs from its parent. A login
    shell gets its real user ID and real group ID from the corresponding fields in
    the system password file.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实际用户ID*和*实际组ID*：这些ID标识了进程所属的用户和组。新进程从其父进程继承这些ID。登录shell从系统密码文件中的相应字段获取实际用户ID和实际组ID。'
- en: '*Effective user ID* and *effective group ID*: These two IDs (in conjunction
    with the supplementary group IDs discussed in a moment) are used in determining
    the permissions that the process has when accessing protected resources such as
    files and interprocess communication objects. Typically, the process’s effective
    IDs have the same values as the corresponding real IDs. Changing the effective
    IDs is a mechanism that allows a process to assume the privileges of another user
    or group, as described in a moment.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有效用户ID*和*有效组ID*：这两个ID（结合稍后讨论的附加组ID）用于确定进程在访问受保护资源（如文件和进程间通信对象）时所具有的权限。通常，进程的有效ID与相应的实际ID具有相同的值。更改有效ID是一种机制，允许进程获取另一个用户或组的权限，稍后会详细描述。'
- en: '*Supplementary group IDs*: These IDs identify additional groups to which a
    process belongs. A new process inherits its supplementary group IDs from its parent.
    A login shell gets its supplementary group IDs from the system group file.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*附加组ID*：这些ID标识进程所属的额外组。一个新进程会继承其父进程的附加组ID。登录Shell从系统组文件中获取其附加组ID。'
- en: Privileged processes
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 特权进程
- en: Traditionally, on UNIX systems, a *privileged process* is one whose *effective*
    user ID is 0 (superuser). Such a process bypasses the permission restrictions
    normally applied by the kernel. By contrast, the term *unprivileged* (or *nonprivileged*)
    is applied to processes run by other users. Such processes have a nonzero effective
    user ID and must abide by the permission rules enforced by the kernel.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在UNIX系统中，*特权进程*是指其*有效*用户ID为0（超级用户）的进程。这样的进程绕过了内核通常施加的权限限制。相比之下，*非特权进程*（或*无特权进程*）是指由其他用户运行的进程。这些进程有非零有效用户ID，并且必须遵守内核施加的权限规则。
- en: A process may be privileged because it was created by another privileged process—for
    example, by a login shell started by *root* (superuser). Another way a process
    may become privileged is via the set-user-ID mechanism, which allows a process
    to assume an effective user ID that is the same as the user ID of the program
    file that it is executing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可能是特权的，因为它是由另一个特权进程创建的——例如，由*root*（超级用户）启动的登录Shell。进程还可以通过设置用户ID机制变得具有特权，该机制允许进程获得与其正在执行的程序文件相同的有效用户ID。
- en: Capabilities
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 能力
- en: Since kernel 2.2, Linux divides the privileges traditionally accorded to the
    superuser into a set of distinct units called *capabilities*. Each privileged
    operation is associated with a particular capability, and a process can perform
    an operation only if it has the corresponding capability. A traditional superuser
    process (effective user ID of 0) corresponds to a process with all capabilities
    enabled.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2.2版本的内核开始，Linux将传统上属于超级用户的权限划分为一组独立的单元，称为*能力*。每个特权操作都与特定的能力相关联，进程只有在具备相应能力时，才能执行该操作。传统的超级用户进程（有效用户ID为0）对应于一个启用了所有能力的进程。
- en: Granting a subset of capabilities to a process allows it to perform some of
    the operations normally permitted to the superuser, while preventing it from performing
    others.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将一部分能力授予进程可以让它执行一些通常只有超级用户才能执行的操作，同时防止它执行其他操作。
- en: Capabilities are described in detail in [Chapter 39](ch39.html "Chapter 39. Capabilities").
    In the remainder of the book, when noting that a particular operation can be performed
    only by a privileged process, we’ll usually identify the specific capability in
    parentheses. Capability names begin with the prefix `CAP_`, as in `CAP_KILL`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 能力在[第39章](ch39.html "第39章。能力")中有详细描述。在本书的其余部分，当提到某个特定操作只能由特权进程执行时，我们通常会在括号中标明具体的能力名称。能力名称以前缀`CAP_`开头，例如`CAP_KILL`。
- en: The *init* process
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*init* 进程'
- en: When booting the system, the kernel creates a special process called *init*,
    the “parent of all processes,” which is derived from the program file `/sbin/init`.
    All processes on the system are created (using *fork()*) either by *init* or by
    one of its descendants. The *init* process always has the process ID 1 and runs
    with superuser privileges. The *init* process can’t be killed (not even by the
    superuser), and it terminates only when the system is shut down. The main task
    of *init* is to create and monitor a range of processes required by a running
    system. (For details, see the *init(8)* manual page.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动系统时，内核创建了一个特殊的进程，称为*init*，即“所有进程的父进程”，它来源于程序文件`/sbin/init`。系统上的所有进程都是通过*init*或其后代创建的（使用*fork()*）。*init*进程的进程ID始终是1，并且以超级用户权限运行。*init*进程无法被终止（即使是超级用户也不能终止），它仅在系统关闭时终止。*init*的主要任务是创建和监视运行系统所需的一系列进程。（详细信息，请参见*init(8)*手册页。）
- en: Daemon processes
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 守护进程
- en: 'A *daemon* is a special-purpose process that is created and handled by the
    system in the same way as other processes, but which is distinguished by the following
    characteristics:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*守护进程*是一种特殊的进程，由系统创建和管理，方式与其他进程相同，但它具有以下特点：'
- en: It is long-lived. A daemon process is often started at system boot and remains
    in existence until the system is shut down.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是长期存在的。守护进程通常在系统启动时启动，并保持存在直到系统关闭。
- en: It runs in the background, and has no controlling terminal from which it can
    read input or to which it can write output.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在后台运行，并且没有控制终端，无法从中读取输入或向其写入输出。
- en: Examples of daemon processes include *syslogd*, which records messages in the
    system log, and *httpd*, which serves web pages via the Hypertext Transfer Protocol
    (HTTP).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程的例子包括*syslogd*，它记录系统日志中的信息，以及*httpd*，它通过超文本传输协议（HTTP）提供网页服务。
- en: Environment list
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 环境列表
- en: Each process has an *environment list*, which is a set of *environment variables*
    that are maintained within the user-space memory of the process. Each element
    of this list consists of a name and an associated value. When a new process is
    created via *fork()*, it inherits a copy of its parent’s environment. Thus, the
    environment provides a mechanism for a parent process to communicate information
    to a child process. When a process replaces the program that it is running using
    *exec()*, the new program either inherits the environment used by the old program
    or receives a new environment specified as part of the *exec()* call.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个*环境列表*，它是一个包含*环境变量*的集合，存储在进程的用户空间内存中。该列表的每个元素由一个名称和一个相关的值组成。当通过*fork()*创建新进程时，它会继承父进程的环境副本。因此，环境提供了一种机制，使父进程可以向子进程传递信息。当一个进程使用*exec()*替换其正在运行的程序时，新程序要么继承旧程序使用的环境，要么接收作为*exec()*调用一部分的新的环境。
- en: 'Environment variables are created with the *export* command in most shells
    (or the *setenv* command in the C shell), as in the following example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Shell 中，环境变量是通过*export*命令创建的（在 C Shell 中是*setenv*命令），例如如下所示：
- en: '[PRE1]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Whenever we present a shell session log showing interactive input and output,
    the input text is always boldfaced. Sometimes, we include commentary in the log
    in italic text, adding notes about the commands entered or the output produced.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们展示一个显示交互式输入和输出的 Shell 会话日志时，输入文本总是以粗体显示。有时，我们在日志中加入注释，使用斜体文本，对输入的命令或输出的结果进行说明。
- en: C programs can access the environment using an external variable (*char **environ*),
    and various library functions allow a process to retrieve and modify values in
    its environment.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: C 程序可以通过外部变量(*char **environ*)访问环境，并且各种库函数允许进程检索和修改其环境中的值。
- en: Environment variables are used for a variety of purposes. For example, the shell
    defines and uses a range of variables that can be accessed by scripts and programs
    executed from the shell. These include the variable `HOME`, which specifies the
    pathname of the user’s login directory, and the variable `PATH`, which specifies
    a list of directories that the shell should search when looking for programs corresponding
    to commands entered by the user.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量有多种用途。例如，Shell 定义并使用一系列变量，脚本和程序可以通过这些变量访问，这些变量包括`HOME`，它指定用户登录目录的路径名，以及`PATH`，它指定
    Shell 在寻找与用户输入的命令对应的程序时应该搜索的目录列表。
- en: Resource limits
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 资源限制
- en: 'Each process consumes resources, such as open files, memory, and CPU time.
    Using the *setrlimit()* system call, a process can establish upper limits on its
    consumption of various resources. Each such *resource limit* has two associated
    values: a *soft limit*, which limits the amount of the resource that the process
    may consume; and a *hard limit*, which is a ceiling on the value to which the
    soft limit may be adjusted. An unprivileged process may change its soft limit
    for a particular resource to any value in the range from zero up to the corresponding
    hard limit, but can only lower its hard limit.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都会消耗资源，例如打开的文件、内存和 CPU 时间。通过使用*setrlimit()*系统调用，进程可以为其消耗的各种资源设定上限。每个这样的*资源限制*都有两个相关的值：*软限制*，它限制进程可以消耗的资源量；以及*硬限制*，它是软限制可以调整的最大值。一个没有特权的进程可以将某一特定资源的软限制调整到从零到相应硬限制之间的任何值，但只能降低其硬限制。
- en: When a new process is created with *fork()*, it inherits copies of its parent’s
    resource limit settings.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过*fork()*创建一个新进程时，它会继承父进程的资源限制设置副本。
- en: The resource limits of the shell can be adjusted using the *ulimit* command
    (*limit* in the C shell). These limit settings are inherited by the child processes
    that the shell creates to execute commands.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 的资源限制可以通过*ulimit*命令（在 C Shell 中是*limit*命令）进行调整。这些限制设置会被 Shell 创建的子进程继承，以执行命令。
- en: Memory Mappings
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存映射
- en: The *mmap()* system call creates a new *memory mapping* in the calling process’s
    virtual address space.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*mmap()* 系统调用在调用进程的虚拟地址空间中创建一个新的*内存映射*。'
- en: 'Mappings fall into two categories:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 映射分为两类：
- en: A *file mapping* maps a region of a file into the calling process’s virtual
    memory. Once mapped, the file’s contents can be accessed by operations on the
    bytes in the corresponding memory region. The pages of the mapping are automatically
    loaded from the file as required.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*文件映射*将文件的一个区域映射到调用进程的虚拟内存中。一旦映射，文件的内容可以通过对相应内存区域中的字节进行操作来访问。映射的页会根据需要自动从文件中加载。
- en: By contrast, an *anonymous mapping* doesn’t have a corresponding file. Instead,
    the pages of the mapping are initialized to 0.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，*匿名映射*没有对应的文件。相反，映射的页被初始化为 0。
- en: The memory in one process’s mapping may be shared with mappings in other processes.
    This can occur either because two processes map the same region of a file or because
    a child process created by *fork()* inherits a mapping from its parent.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程的内存映射可能与其他进程的映射共享。这种情况可能发生在两个进程映射同一区域的文件时，或者因为通过*fork()*创建的子进程继承了父进程的映射。
- en: When two or more processes share the same pages, each process may see the changes
    made by other processes to the contents of the pages, depending on whether the
    mapping is created as private or shared. When a mapping is *private*, modifications
    to the contents of the mapping are not visible to other processes and are not
    carried through to the underlying file. When a mapping is *shared*, modifications
    to the contents of the mapping are visible to other processes sharing the same
    mapping and are carried through to the underlying file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或多个进程共享相同的页面时，每个进程可能会看到其他进程对页面内容所做的更改，这取决于映射是私有的还是共享的。当映射是*私有的*时，对映射内容的修改对其他进程不可见，并且不会反映到底层文件中。当映射是*共享的*时，对映射内容的修改对共享相同映射的其他进程可见，并且会反映到底层文件中。
- en: Memory mappings serve a variety of purposes, including initialization of a process’s
    text segment from the corresponding segment of an executable file, allocation
    of new (zero-filled) memory, file I/O (memory-mapped I/O), and interprocess communication
    (via a shared mapping).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射有多种用途，包括从可执行文件的相应段初始化进程的文本段、分配新的（填充零的）内存、文件 I/O（内存映射 I/O）以及进程间通信（通过共享映射）。
- en: Static and Shared Libraries
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态库和共享库
- en: 'An *object library* is a file containing the compiled object code for a (usually
    logically related) set of functions that may be called from application programs.
    Placing code for a set of functions in a single object library eases the tasks
    of program creation and maintenance. Modern UNIX systems provide two types of
    object libraries: *static libraries* and *shared libraries*.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*目标库*是一个包含（通常是逻辑上相关的）一组函数的编译目标代码的文件，这些函数可以从应用程序中调用。将一组函数的代码放入一个单一的目标库中可以简化程序创建和维护的任务。现代
    UNIX 系统提供了两种类型的目标库：*静态库*和*共享库*。
- en: Static libraries
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 静态库
- en: Static libraries (sometimes also known as *archives*) were the only type of
    library on early UNIX systems. A static library is essentially a structured bundle
    of compiled object modules. To use functions from a static library, we specify
    that library in the link command used to build a program. After resolving the
    various function references from the main program to the modules in the static
    library, the linker extracts copies of the required object modules from the library
    and copies these into the resulting executable file. We say that such a program
    is *statically linked*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库（有时也称为*档案*）是早期 UNIX 系统中唯一的库类型。静态库本质上是一个结构化的编译过的目标模块集合。为了使用静态库中的函数，我们在构建程序时的链接命令中指定该库。在将主程序中的各种函数引用解析到静态库中的模块后，链接器会从库中提取所需的目标模块副本，并将这些副本复制到最终的可执行文件中。我们说这样一个程序是*静态链接*的。
- en: The fact that each statically linked program includes its own copy of the object
    modules required from the library creates a number of disadvantages. One is that
    the duplication of object code in different executable files wastes disk space.
    A corresponding waste of memory occurs when statically linked programs using the
    same library function are executed at the same time; each program requires its
    own copy of the function to reside in memory. Additionally, if a library function
    requires modification, then, after recompiling that function and adding it to
    the static library, all applications that need to use the updated function must
    be relinked against the library.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个静态链接的程序都包含其所需的库中目标模块的副本，这会带来一些不利之处。其中一个问题是，不同可执行文件中目标代码的重复会浪费磁盘空间。当多个静态链接程序同时执行并使用相同的库函数时，内存中也会发生相应的浪费；每个程序都需要自己的一份函数副本。此外，如果库函数需要修改，那么在重新编译该函数并将其添加到静态库后，所有需要使用更新函数的应用程序都必须重新链接该库。
- en: Shared libraries
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享库
- en: Shared libraries were designed to address the problems with static libraries.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库的设计旨在解决静态库的问题。
- en: If a program is linked against a shared library, then, instead of copying object
    modules from the library into the executable, the linker just writes a record
    into the executable to indicate that at run time the executable needs to use that
    shared library. When the executable is loaded into memory at run time, a program
    called the *dynamic linker* ensures that the shared libraries required by the
    executable are found and loaded into memory, and performs run-time linking to
    resolve the function calls in the executable to the corresponding definitions
    in the shared libraries. At run time, only a single copy of the code of the shared
    library needs to be resident in memory; all running programs can use that copy.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序与共享库链接，那么链接器不会将库中的目标模块复制到可执行文件中，而是将一条记录写入可执行文件，指示在运行时该可执行文件需要使用该共享库。当可执行文件在运行时被加载到内存中时，一个叫做*动态链接器*的程序会确保找到并加载可执行文件所需的共享库，并在运行时进行链接，将可执行文件中的函数调用解析到共享库中的相应定义。在运行时，只有共享库的单一副本需要驻留在内存中，所有正在运行的程序都可以使用这一副本。
- en: The fact that a shared library contains the sole compiled version of a function
    saves disk space. It also greatly eases the job of ensuring that programs employ
    the newest version of a function. Simply rebuilding the shared library with the
    new function definition causes existing programs to automatically use the new
    definition when they are next executed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库包含函数的唯一编译版本，从而节省了磁盘空间。这也大大简化了确保程序使用最新版本函数的工作。只需重新构建包含新函数定义的共享库，现有程序在下次执行时便会自动使用新的定义。
- en: Interprocess Communication and Synchronization
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程间通信与同步
- en: A running Linux system consists of numerous processes, many of which operate
    independently of each other. Some processes, however, cooperate to achieve their
    intended purposes, and these processes need methods of communicating with one
    another and synchronizing their actions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正在运行的 Linux 系统由众多进程组成，其中许多进程相互独立地运行。然而，一些进程通过合作来实现它们的预定目标，这些进程需要相互之间的通信和同步方法。
- en: 'One way for processes to communicate is by reading and writing information
    in disk files. However, for many applications, this is too slow and inflexible.
    Therefore, Linux, like all modern UNIX implementations, provides a rich set of
    mechanisms for *interprocess communication* (IPC), including the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 进程间通信的一种方式是通过读取和写入磁盘文件中的信息。然而，对于许多应用程序来说，这种方式太慢且不灵活。因此，Linux 像所有现代 UNIX 实现一样，提供了丰富的*进程间通信*（IPC）机制，包括以下几种：
- en: '*signals*, which are used to indicate that an event has occurred;'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信号*，用于指示某个事件已发生；'
- en: '*pipes* (familiar to shell users as the `|` operator) and *FIFOs*, which can
    be used to transfer data between processes;'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管道*（对 shell 用户来说，熟悉的`|`操作符）和*FIFO*，可以用来在进程之间传输数据；'
- en: '*sockets*, which can be used to transfer data from one process to another,
    either on the same host computer or on different hosts connected by a network;'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*套接字*，可用于将数据从一个进程传输到另一个进程，无论是在同一台主机上还是在通过网络连接的不同主机之间；'
- en: '*file locking*, which allows a process to lock regions of a file in order to
    prevent other processes from reading or updating the file contents;'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件锁定*，允许进程锁定文件的某些区域，以防止其他进程读取或更新文件内容；'
- en: '*message queues*, which are used to exchange messages (packets of data) between
    processes;'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消息队列*，用于在进程之间交换消息（数据包）； '
- en: '*semaphores*, which are used to synchronize the actions of processes; and'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信号量*，用于同步进程的操作；以及'
- en: '*shared memory*, which allows two or more processes to share a piece of memory.
    When one process changes the contents of the shared memory, all of the other processes
    can immediately see the changes.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共享内存*，允许两个或多个进程共享一块内存。当一个进程改变共享内存的内容时，所有其他进程都能立即看到这些变化。'
- en: The wide variety of IPC mechanisms on UNIX systems, with sometimes overlapping
    functionality, is in part due to their evolution under different variants of the
    UNIX system and the requirements of various standards. For example, FIFOs and
    UNIX domain sockets essentially perform the same function of allowing unrelated
    processes on the same system to exchange data. Both exist in modern UNIX systems
    because FIFOs came from System V, while sockets came from BSD.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX系统上多种多样的IPC机制，有时功能重叠，部分原因是它们在不同UNIX系统变种和各种标准的要求下演化。例如，FIFO和UNIX域套接字本质上执行相同的功能，允许同一系统上的无关进程交换数据。两者都存在于现代UNIX系统中，因为FIFO来自System
    V，而套接字则来自BSD。
- en: Signals
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号
- en: Although we listed them as a method of IPC in the previous section, signals
    are more usually employed in a wide range of other contexts, and so deserve a
    longer discussion.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在前一节中将它们列为进程间通信（IPC）的一种方法，但信号通常在更广泛的其他上下文中使用，因此值得更长时间的讨论。
- en: Signals are often described as “software interrupts.” The arrival of a signal
    informs a process that some event or exceptional condition has occurred. There
    are various types of signals, each of which identifies a different event or condition.
    Each signal type is identified by a different integer, defined with symbolic names
    of the form `SIGxxxx`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 信号通常被描述为“软件中断”。信号的到达通知进程某个事件或异常条件的发生。信号有多种类型，每种类型表示不同的事件或条件。每种信号类型由不同的整数标识，并用形式为`SIGxxxx`的符号名称定义。
- en: 'Signals are sent to a process by the kernel, by another process (with suitable
    permissions), or by the process itself. For example, the kernel may send a signal
    to a process when one of the following occurs:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 信号由内核、其他进程（具有适当权限）或进程本身发送。例如，当发生以下情况时，内核可能会向进程发送信号：
- en: the user typed the *interrupt* character (usually *Control-C*) on the keyboard;
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在键盘上输入了*中断*字符（通常是*Control-C*）；
- en: one of the process’s children has terminated;
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程的某个子进程已终止；
- en: a timer (alarm clock) set by the process has expired; or
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程设置的计时器（闹钟）已过期；或者
- en: the process attempted to access an invalid memory address.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程尝试访问无效的内存地址。
- en: Within the shell, the *kill* command can be used to send a signal to a process.
    The *kill()* system call provides the same facility within programs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell中，*kill*命令可以用于向进程发送信号。*kill()*系统调用在程序中提供相同的功能。
- en: 'When a process receives a signal, it takes one of the following actions, depending
    on the signal:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程接收到信号时，它根据信号采取以下某种行动：
- en: it ignores the signal;
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它忽略了信号；
- en: it is killed by the signal; or
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被信号终止；或者
- en: it is suspended until later being resumed by receipt of a special-purpose signal.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被暂停，直到通过接收一个特殊用途的信号被恢复。
- en: For most signal types, instead of accepting the default signal action, a program
    can choose to ignore the signal (useful if the default action for the signal is
    something other than being ignored), or to establish a *signal handler*. A signal
    handler is a programmer-defined function that is automatically invoked when the
    signal is delivered to the process. This function performs some action appropriate
    to the condition that generated the signal.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数信号类型，程序可以选择忽略信号（如果该信号的默认动作不是被忽略，则这种方式很有用），或者建立一个*信号处理程序*。信号处理程序是一个程序员定义的函数，当信号被发送到进程时，该函数会自动调用。该函数执行与生成该信号的条件相关的某些操作。
- en: In the interval between the time it is generated and the time it is delivered,
    a signal is said to be *pending* for a process. Normally, a pending signal is
    delivered as soon as the receiving process is next scheduled to run, or immediately
    if the process is already running. However, it is also possible to *block* a signal
    by adding it to the process’s *signal mask*. If a signal is generated while it
    is blocked, it remains pending until it is later unblocked (i.e., removed from
    the signal mask).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成信号与信号交付之间的这段时间内，信号被称为*挂起*。通常，挂起的信号会在接收进程下次调度运行时传递，或者如果进程已经在运行，则立即传递。然而，也可以通过将信号添加到进程的*信号屏蔽*中来*屏蔽*信号。如果在信号被屏蔽时生成信号，它将保持挂起状态，直到以后被解除屏蔽（即，从信号屏蔽中移除）。
- en: Threads
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程
- en: In modern UNIX implementations, each process can have multiple *threads* of
    execution. One way of envisaging threads is as a set of processes that share the
    same virtual memory, as well as a range of other attributes. Each thread is executing
    the same program code and shares the same data area and heap. However, each thread
    has it own stack containing local variables and function call linkage information.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 UNIX 实现中，每个进程可以有多个*线程*。一种理解线程的方式是将其看作一组共享相同虚拟内存的进程，以及一系列其他属性。每个线程执行相同的程序代码，并共享相同的数据区和堆。然而，每个线程都有自己的堆栈，包含局部变量和函数调用链信息。
- en: Threads can communicate with each other via the global variables that they share.
    The threading API provides *condition variables* and *mutexes*, which are primitives
    that enable the threads of a process to communicate and synchronize their actions,
    in particular, their use of shared variables. Threads can also communicate with
    one another using the IPC and synchronization mechanisms described in [Interprocess
    Communication and Synchronization](ch02.html#interprocess_communication_and_synchroni
    "Interprocess Communication and Synchronization").
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以通过它们共享的全局变量相互通信。线程 API 提供了*条件变量*和*互斥锁*，这些原语使得一个进程的线程能够进行通信并同步它们的行为，特别是在它们使用共享变量时。线程也可以通过[进程间通信与同步](ch02.html#interprocess_communication_and_synchroni
    "进程间通信与同步")中描述的 IPC 和同步机制相互通信。
- en: The primary advantages of using threads are that they make it easy to share
    data (via global variables) between cooperating threads and that some algorithms
    transpose more naturally to a multithreaded implementation than to a multiprocess
    implementation. Furthermore, a multithreaded application can transparently take
    advantage of the possibilities for parallel processing on multiprocessor hardware.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程的主要优点在于，它们使得通过全局变量在协作线程之间共享数据变得容易，并且某些算法比起多进程实现，更自然地转化为多线程实现。此外，多线程应用程序可以透明地利用多处理器硬件上的并行处理能力。
- en: Process Groups and Shell Job Control
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程组和 Shell 作业控制
- en: 'Each program executed by the shell is started in a new process. For example,
    the shell creates three processes to execute the following pipeline of commands
    (which displays a list of files in the current working directory sorted by file
    size):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 执行的每个程序都是在一个新进程中启动的。例如，Shell 创建三个进程来执行以下命令管道（该管道显示当前工作目录中按文件大小排序的文件列表）：
- en: '[PRE2]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All major shells, except the Bourne shell, provide an interactive feature called
    *job control*, which allows the user to simultaneously execute and manipulate
    multiple commands or pipelines. In job-control shells, all of the processes in
    a pipeline are placed in a new *process group* or *job*. (In the simple case of
    a shell command line containing a single command, a new process group containing
    just a single process is created.) Each process in a process group has the same
    integer *process group identifier*, which is the same as the process ID of one
    of the processes in the group, termed the *process group leader*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Bourne Shell 外，所有主要的 Shell 都提供一个名为*作业控制*的交互功能，允许用户同时执行和操作多个命令或管道。在作业控制的 Shell
    中，管道中的所有进程都会被放置在一个新的*进程组*或*作业*中。（在一个简单的 Shell 命令行中，仅包含一个命令时，会创建一个只包含单个进程的新进程组。）进程组中的每个进程都有相同的整数*进程组标识符*，该标识符与组内某个进程的进程
    ID 相同，这个进程被称为*进程组领导者*。
- en: The kernel allows for various actions, notably the delivery of signals, to be
    performed on all members of a process group. Job-control shells use this feature
    to allow the user to suspend or resume all of the processes in a pipeline, as
    described in the next section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 内核允许对进程组中的所有成员执行各种操作，特别是信号的传递。作业控制外壳利用这一特性，允许用户暂停或恢复管道中的所有进程，如下节所述。
- en: Sessions, Controlling Terminals, and Controlling Processes
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话、控制终端和控制进程
- en: A *session* is a collection of process groups (jobs). All of the processes in
    a session have the same *session identifier*. A *session leader* is the process
    that created the session, and its process ID becomes the session ID.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*会话*是由进程组（作业）组成的集合。会话中的所有进程都具有相同的*会话标识符*。*会话领导者*是创建会话的进程，它的进程 ID 成为会话 ID。'
- en: Sessions are used mainly by job-control shells. All of the process groups created
    by a job-control shell belong to the same session as the shell, which is the session
    leader.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 会话主要由作业控制外壳使用。所有由作业控制外壳创建的进程组都属于与外壳相同的会话，该外壳是会话的会话领导者。
- en: Sessions usually have an associated *controlling terminal*. The controlling
    terminal is established when the session leader process first opens a terminal
    device. For a session created by an interactive shell, this is the terminal at
    which the user logged in. A terminal may be the controlling terminal of at most
    one session.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 会话通常会有一个关联的*控制终端*。控制终端是在会话领导者进程首次打开终端设备时建立的。对于由交互式外壳创建的会话，这就是用户登录时使用的终端。一个终端最多只能是一个会话的控制终端。
- en: As a consequence of opening the controlling terminal, the session leader becomes
    the *controlling process* for the terminal. The controlling process receives a
    `SIGHUP` signal if a terminal disconnect occurs (e.g., if the terminal window
    is closed).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于打开了控制终端，会话领导者成为该终端的*控制进程*。如果发生终端断开连接（例如，如果终端窗口被关闭），控制进程会收到一个`SIGHUP`信号。
- en: At any point in time, one process group in a session is the *foreground process
    group* (*foreground job*), which may read input from the terminal and send output
    to it. If the user types the *interrupt* character (usually *Control-C*) or the
    *suspend* character (usually *Control-Z*) on the controlling terminal, then the
    terminal driver sends a signal that kills or suspends (i.e., stops) the foreground
    process group. A session can have any number of *background process groups* (*background
    jobs*), which are created by terminating a command with the ampersand (`&`) character.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，会话中的一个进程组是*前台进程组*（*前台作业*），它可以从终端读取输入并将输出发送到终端。如果用户在控制终端上输入*中断*字符（通常是*Control-C*）或*暂停*字符（通常是*Control-Z*），则终端驱动程序会发送一个信号，终止或暂停（即停止）前台进程组。一个会话可以有任意数量的*后台进程组*（*后台作业*），它们通过在命令后加上符号（`&`）来创建。
- en: Job-control shells provide commands for listing all jobs, sending signals to
    jobs, and moving jobs between the foreground and background.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 作业控制外壳提供了列出所有作业、向作业发送信号，以及将作业在前台和后台之间移动的命令。
- en: Pseudoterminals
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟终端
- en: A *pseudoterminal* is a pair of connected virtual devices, known as the *master*
    and *slave*. This device pair provides an IPC channel allowing data to be transferred
    in both directions between the two devices.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟终端*是一对连接的虚拟设备，分别称为*主设备*和*从设备*。这一设备对提供了一个 IPC 通道，允许数据在两个设备之间双向传输。'
- en: The key point about a pseudoterminal is that the slave device provides an interface
    that behaves like a terminal, which makes it possible to connect a terminal-oriented
    program to the slave device and then use another program connected to the master
    device to drive the terminal-oriented program. Output written by the driver program
    undergoes the usual input processing performed by the terminal driver (for example,
    in the default mode, a carriage return is mapped to a newline) and is then passed
    as input to the terminal-oriented program connected to the slave. Anything that
    the terminal-oriented program writes to the slave is passed (after performing
    all of the usual terminal output processing) as input to the driver program. In
    other words, the driver program is performing the function normally performed
    by the user at a conventional terminal.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 伪终端的关键点在于从设备提供了一个行为类似终端的接口，这使得可以将终端导向程序连接到从设备，然后使用连接到主设备的另一个程序来驱动终端导向程序。由驱动程序写入的输出经过终端驱动程序执行通常的输入处理（例如，在默认模式下，回车被映射为换行符），然后作为输入传递给连接到从设备的终端导向程序。终端导向程序写入从设备的任何内容，都将（在执行所有常规终端输出处理后）作为输入传递给驱动程序。换句话说，驱动程序执行的是通常由用户在传统终端上执行的功能。
- en: Pseudoterminals are used in a variety of applications, most notably in the implementation
    of terminal windows provided under an X Window System login and in applications
    providing network login services, such as *telnet* and *ssh*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 伪终端被广泛应用于各种场景，最显著的应用是在X Window系统登录下提供的终端窗口的实现以及提供网络登录服务的应用程序，如*telnet*和*ssh*。
- en: Date and Time
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期和时间
- en: 'Two types of time are of interest to a process:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种时间对进程非常重要：
- en: '*Real time* is measured either from some standard point (*calendar* time) or
    from some fixed point, typically the start, in the life of a process (*elapsed*
    or *wall clock* time). On UNIX systems, calendar time is measured in seconds since
    midnight on the morning of January 1, 1970, Universal Coordinated Time (usually
    abbreviated UTC), and coordinated on the base point for timezones defined by the
    longitudinal line passing through Greenwich, England. This date, which is close
    to the birth of the UNIX system, is referred to as the *Epoch*.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实时*是从某个标准时间点（*日历*时间）或某个固定时间点（通常是进程生命周期开始时）来度量的（即*经过*时间或*挂钟时间*）。在UNIX系统上，日历时间是从1970年1月1日午夜以来的秒数来度量的，使用协调世界时（通常缩写为UTC），并且与通过英国格林威治的经线定义的时区基准点进行协调。这个日期，接近UNIX系统的诞生，被称为*纪元*。'
- en: '*Process time*, also called *CPU time*, is the total amount of CPU time that
    a process has used since starting. CPU time is further divided into *system CPU
    time*, the time spent executing code in *kernel mode* (i.e., executing system
    calls and performing other kernel services on behalf of the process), and *user
    CPU time*, the time spent executing code in *user mode* (i.e., executing normal
    program code).'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进程时间*，也称为*CPU时间*，是一个进程自启动以来所使用的总CPU时间。CPU时间进一步划分为*系统CPU时间*，即在*内核模式*下执行代码的时间（例如，执行系统调用并为进程执行其他内核服务），和*用户CPU时间*，即在*用户模式*下执行代码的时间（例如，执行普通程序代码）。'
- en: The *time* command displays the real time, the system CPU time, and user CPU
    time taken to execute the processes in a pipeline.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*time*命令显示真实时间、系统CPU时间以及执行管道中进程所需的用户CPU时间。'
- en: Client-Server Architecture
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端-服务器架构
- en: At various points in this book, we discuss the design and implementation of
    client-server applications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的不同部分，我们讨论了客户端-服务器应用程序的设计和实现。
- en: 'A *client-server application* is one that is broken into two component processes:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*客户端-服务器应用程序*是一个被分成两个组件进程的应用程序：
- en: a *client*, which asks the server to carry out some *service* by sending it
    a request message; and
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*客户端*，它通过发送请求消息请求服务器执行某些*服务*；
- en: a *server*, which examines the client’s request, performs appropriate actions,
    and then sends a response message back to the client.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*服务器*，它检查客户端的请求，执行适当的操作，然后将响应消息发送回客户端。
- en: Sometimes, the client and server may engage in an extended dialogue of requests
    and responses.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，客户端和服务器可能会进行一系列扩展的请求和响应对话。
- en: Typically, the client application interacts with a user, while the server application
    provides access to some shared resource. Commonly, there are multiple instances
    of client processes communicating with one or a few instances of the server process.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，客户端应用程序与用户互动，而服务器应用程序提供对某些共享资源的访问。通常，多个客户端进程实例与一个或几个服务器进程实例进行通信。
- en: The client and server may reside on the same host computer or on separate hosts
    connected via a network. To communicate with one another, the client and server
    use the IPC mechanisms discussed in [Interprocess Communication and Synchronization](ch02.html#interprocess_communication_and_synchroni
    "Interprocess Communication and Synchronization").
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器可能驻留在同一主机上，也可能位于通过网络连接的不同主机上。为了相互通信，客户端和服务器使用在[进程间通信与同步](ch02.html#interprocess_communication_and_synchroni
    "进程间通信与同步")中讨论的IPC机制。
- en: 'Servers may implement a variety of services, such as:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可能实现多种服务，例如：
- en: providing access to a database or other shared information resource;
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对数据库或其他共享信息资源的访问；
- en: providing access to a remote file across a network;
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供通过网络访问远程文件；
- en: encapsulating some business logic;
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装一些业务逻辑；
- en: providing access to a shared hardware resource (e.g., a printer); or
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对共享硬件资源（例如打印机）的访问；或者
- en: serving web pages.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供网页服务。
- en: 'Encapsulating a service within a single server is useful for a number of reasons,
    such as the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务封装在单一服务器中有很多好处，举例如下：
- en: '*Efficiency*: It may be cheaper to provide one instance of a resource (e.g.,
    a printer) that is managed by a server than to provide the same resource locally
    on every computer.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*效率*：由服务器管理的单个资源实例（例如打印机）可能比在每台计算机上本地提供相同资源更为经济。'
- en: '*Control, coordination, and security*: By holding a resource (especially an
    information resource) at a single location, the server can coordinate access to
    the resource (e.g., so that two clients don’t simultaneously update the same piece
    of information) or secure it so that it is made available to only selected clients.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制、协调与安全性*：通过将资源（特别是信息资源）集中在一个位置，服务器可以协调对该资源的访问（例如，防止两个客户端同时更新相同的信息），或将其安全地保护，只允许特定的客户端访问。'
- en: '*Operation in a heterogeneous environment*: In a network, the various clients,
    and the server, can be running on different hardware and operating system platforms.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在异构环境中的操作*：在网络中，各种客户端和服务器可以运行在不同的硬件和操作系统平台上。'
- en: Realtime
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时
- en: '*Realtime applications* are those that need to respond in a timely fashion
    to input. Frequently, such input comes from an external sensor or a specialized
    input device, and output takes the form of controlling some external hardware.
    Examples of applications with realtime response requirements include automated
    assembly lines, bank ATMs, and aircraft navigation systems.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时应用程序*是那些需要及时响应输入的应用程序。通常，这种输入来自外部传感器或专用输入设备，输出则表现为控制一些外部硬件。具有实时响应要求的应用程序示例包括自动化生产线、银行ATM机和飞机导航系统。'
- en: Although many realtime applications require rapid responses to input, the defining
    factor is that the response is guaranteed to be delivered within a certain deadline
    time after the triggering event.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多实时应用程序要求对输入做出快速响应，但决定性因素是确保在触发事件后的某个截止时间内传递响应。
- en: The provision of realtime responsiveness, especially where short response times
    are demanded, requires support from the underlying operating system. Most operating
    systems don’t natively provide such support because the requirements of realtime
    responsiveness can conflict with the requirements of multiuser time-sharing operating
    systems. Traditional UNIX implementations are not realtime operating systems,
    although realtime variants have been devised. Realtime variants of Linux have
    also been created, and recent Linux kernels are moving toward full native support
    for realtime applications.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 提供实时响应性，特别是在要求短响应时间的情况下，需要底层操作系统的支持。大多数操作系统原生不提供这种支持，因为实时响应性要求可能与多用户时间共享操作系统的要求相冲突。传统的UNIX实现并不是实时操作系统，尽管已经开发出了实时变种。Linux的实时变种也已创建，最近的Linux内核正在朝着完全原生支持实时应用程序的方向发展。
- en: POSIX.1b defined a number of extensions to POSIX.1 for the support of realtime
    applications. These include asynchronous I/O, shared memory, memory-mapped files,
    memory locking, realtime clocks and timers, alternative scheduling policies, realtime
    signals, message queues, and semaphores. Even though they don’t strictly qualify
    as realtime, most UNIX implementations now support some or all of these extensions.
    (During the course of this book, we describe those features of POSIX.1b that are
    supported by Linux.)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX.1b 为支持实时应用程序定义了 POSIX.1 的多个扩展。这些扩展包括异步 I/O、共享内存、内存映射文件、内存锁定、实时时钟和定时器、替代调度策略、实时信号、消息队列和信号量。尽管它们严格来说不算是实时的，但大多数
    UNIX 实现现在支持其中的一部分或全部扩展。（在本书中，我们将描述 POSIX.1b 的特性，Linux 支持其中的哪些功能。）
- en: Note
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, we use the term *real time* to refer to the concept of calendar
    or elapsed time, and the term *realtime* to denote an operating system or application
    providing the type of responsiveness described in this section.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用术语 *real time* 来指代日历或经过的时间的概念，而使用术语 *realtime* 来表示操作系统或应用程序提供的本节所描述的响应性。
- en: The `/proc` File System
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`/proc` 文件系统'
- en: Like several other UNIX implementations, Linux provides a `/proc` file system,
    which consists of a set of directories and files mounted under the `/proc` directory.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些 UNIX 实现一样，Linux 提供了一个 `/proc` 文件系统，该系统由一组目录和文件组成，挂载在 `/proc` 目录下。
- en: The `/proc` file system is a virtual file system that provides an interface
    to kernel data structures in a form that looks like files and directories on a
    file system. This provides an easy mechanism for viewing and changing various
    system attributes. In addition, a set of directories with names of the form `/proc/`*PID*,
    where *PID* is a process ID, allows us to view information about each process
    running on the system.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc` 文件系统是一个虚拟文件系统，它以看起来像文件和目录的形式提供了一个访问内核数据结构的接口。这提供了一种便捷的机制来查看和更改各种系统属性。此外，一组以
    `/proc/`*PID* 形式命名的目录，其中 *PID* 是进程 ID，使我们可以查看系统上每个正在运行的进程的相关信息。'
- en: The contents of `/proc` files are generally in human-readable text form and
    can be parsed by shell scripts. A program can simply open and read from, or write
    to, the desired file. In most cases, a process must be privileged to modify the
    contents of files in the `/proc` directory.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc` 文件的内容通常是人类可读的文本形式，并且可以被 shell 脚本解析。程序可以简单地打开并从中读取，或写入所需的文件。在大多数情况下，进程必须具有特权才能修改
    `/proc` 目录中文件的内容。'
- en: As we describe various parts of the Linux programming interface, we’ll also
    describe the relevant `/proc` files. [The `/proc` File System](ch12.html#the_solidus_proc_file_system-id1
    "The /proc File System") provides further general information on this file system.
    The `/proc` file system is not specified by any standards, and the details that
    we describe are Linux-specific.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们描述 Linux 编程接口的各个部分时，我们也会描述相关的 `/proc` 文件。[`/proc` 文件系统](ch12.html#the_solidus_proc_file_system-id1
    "The /proc File System") 提供了有关该文件系统的更多一般信息。`/proc` 文件系统没有由任何标准指定，本文描述的细节是 Linux
    特有的。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we surveyed a range of fundamental concepts related to Linux
    system programming. An understanding of these concepts should provide readers
    with limited experience on Linux or UNIX with enough background to begin learning
    system programming.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了一些与 Linux 系统编程相关的基本概念。理解这些概念应该能为读者提供足够的背景，使那些对 Linux 或 UNIX 经验有限的读者能够开始学习系统编程。
