- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 7 NETWORK MONITORING
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7 网络监控
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In this chapter, I’ll describe various approaches for monitoring network activity
    on macOS systems. I’ll start simple, by showing you how to regularly schedule
    network snapshots to obtain a near-continuous view of a host’s network activity.
    Next, you’ll dive deep into Apple’s *NetworkExtension* framework and APIs, which
    provide a means of customizing the operating system’s core networking features
    and building comprehensive network monitoring tools. As an example, I’ll discuss
    leveraging this powerful framework to build host-based DNS monitors and firewalls
    capable of filtering and blocking selected activity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将描述在macOS系统上监控网络活动的各种方法。我将从简单的开始，向你展示如何定期安排网络快照，以便获得主机网络活动的近连续视图。接下来，你将深入了解苹果的*NetworkExtension*框架和API，它们提供了一种定制操作系统核心网络功能并构建全面网络监控工具的方法。作为一个例子，我将讨论如何利用这个强大的框架构建基于主机的DNS监视器和防火墙，能够筛选和阻止特定的活动。
- en: In [Chapter 4](chapter4.xhtml), we generated a snapshot of a device’s network
    state at given moments. While this simple approach can efficiently detect a variety
    of malicious behaviors, it has several limitations. Most notably, if malware isn’t
    accessing the network at the exact time at which the snapshot is taken, it will
    remain undetected. For example, the malware leveraged in the 3CX supply chain
    attack beaconed only every hour or two.^([1](#chapter7-1)) Unless the network
    snapshot was serendipitously scheduled, it would miss the malware’s network activity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](chapter4.xhtml)中，我们在给定的时刻生成了设备网络状态的快照。尽管这种简单的方法可以有效地检测各种恶意行为，但它也有一些局限性。最显著的是，如果恶意软件在快照拍摄时没有访问网络，它将保持未被发现。例如，3CX供应链攻击中使用的恶意软件每隔一两个小时才发送一次信号。^([1](#chapter7-1))除非网络快照恰好被计划在这个时间，否则它将错过恶意软件的网络活动。
- en: To overcome this shortcoming, we can continuously monitor the network for signs
    of infections. The collected network data could help us build baselines of normal
    traffic over time and provide a corpus for input to a larger distributed threat
    hunting system. While these approaches can be more complex to implement than simple
    snapshot tools, the insight they provide into the network activity on a host makes
    them an invaluable component of any comprehensive malware detection tool.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个缺点，我们可以持续监控网络，寻找感染的迹象。收集到的网络数据可以帮助我们随着时间的推移建立正常流量的基准，并为更大的分布式威胁猎捕系统提供输入数据。尽管这些方法比简单的快照工具实现起来更加复杂，但它们提供的网络活动洞察使其成为任何综合恶意软件检测工具中不可或缺的组成部分。
- en: This book won’t cover using the framework for full packet captures, as capturing
    and processing this data would require significant resources, so it’s almost always
    best to perform these captures directly on the network, rather than on the host.
    Moreover, full packet captures are generally overkill for detecting malware. Often,
    simply identifying some unauthorized network activity, such as a listening socket
    or a connection to an unrecognized API endpoint, is sufficient to cast suspicion
    on a process (especially those that are unrecognized) and reveal an infection.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会涉及使用框架进行完整数据包捕获的内容，因为捕获和处理这些数据需要大量资源，因此通常最好直接在网络上而不是在主机上进行这些捕获。此外，完整数据包捕获通常对恶意软件检测来说是过度的。通常，仅仅识别一些未经授权的网络活动，如监听套接字或连接到未知的API端点，就足以引起对某个进程（尤其是那些未被识别的进程）的怀疑，并揭示感染。
- en: NOTE
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*To use the* NetworkExtension *framework tools, we must add the proper entitlements,
    and we must build the code with provisioning profiles that authorize these entitlements
    at runtime. I won’t cover this process here, as the focus is on core concepts
    of working with the framework. Turn to [Part III](part3.xhtml) to learn how to
    obtain the necessary entitlements and create provisioning profiles.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*要使用* NetworkExtension *框架工具，我们必须添加适当的授权，并且必须使用能够在运行时授权这些授权的配置文件构建代码。我不会在这里详细讲解这个过程，因为重点是如何使用框架的核心概念。请参阅[第三部分](part3.xhtml)，了解如何获取必要的授权并创建配置文件。*'
- en: Obtaining Regular Snapshots
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取定期快照
- en: One simple way to continuously monitor network activity is to repeatedly take
    snapshots of the current network state. For example, in [Chapter 4](chapter4.xhtml),
    we used Apple’s nettop utility to display network information. When you run this
    tool, it appears to update the information whenever new connections appear. However,
    consulting the utility’s man page reveals that, behind the scenes, nettop does
    nothing more than obtain network snapshots at regular intervals. By default, it
    takes a snapshot every second, though you can change this interval with the -s
    command line option. Is this a true network monitor? No, but its approach is straightforward
    and, assuming the snapshots happen often, likely comprehensive enough to detect
    suspicious network activity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 持续监控网络活动的一个简单方法是重复拍摄当前网络状态的快照。例如，在[第4章](chapter4.xhtml)中，我们使用了苹果的 nettop 工具来显示网络信息。当你运行这个工具时，它似乎会在出现新连接时更新信息。然而，查阅该工具的手册页面会发现，实际上，nettop
    并不过是在定期获取网络快照。默认情况下，它每秒拍摄一次快照，尽管你可以使用 -s 命令行选项来更改这个时间间隔。这算是一个真正的网络监控工具吗？不算，但它的方法简单直接，并且假设快照频繁发生，它的监控可能足够全面来检测可疑的网络活动。
- en: To mimic nettop, we can capture a snapshot of the network activity using the
    *NetworkStatistics* framework, invoking its NStatManagerQueryAllSourcesDescriptions
    API, as discussed in [Chapter 4](chapter4.xhtml). Then we can simply reinvoke
    the API at regular intervals. The code in [Listing 7-1](chapter7.xhtml#Lis7-1)
    does exactly this.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟 nettop，我们可以使用 *NetworkStatistics* 框架来捕获网络活动的快照，调用其 NStatManagerQueryAllSourcesDescriptions
    API，如[第4章](chapter4.xhtml)中所讨论的那样。然后，我们可以简单地在定期间隔内重新调用这个 API。[清单 7-1](chapter7.xhtml#Lis7-1)中的代码就是这样做的。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 7-1: Regularly capturing the network state'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-1：定期捕获网络状态
- en: The code first creates a dispatch queue ❶ and a dispatch source ❷. Then it sets
    the start time and refresh rate for the dispatch source via the dispatch_source_set_timer
    API ❸. For illustrative purposes, we specify a refresh rate of 10 seconds. The
    API call requires this rate in nanoseconds, so we multiply it by NSEC_PER_SEC,
    a system constant representing the number of nanoseconds in one second. Next,
    we create an event handler ❹ that will reinvoke the NStatManagerQueryAllSourcesDescriptions
    API each time the dispatch source is refreshed. Finally, we invoke the dispatch_resume
    function ❺ to set the snapshot-based monitor in motion. Now, onto a continual
    monitor.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建一个调度队列 ❶ 和一个调度源 ❷。然后，它通过 dispatch_source_set_timer API ❸ 设置调度源的起始时间和刷新率。为了说明，我们指定了
    10 秒的刷新率。这个 API 调用要求使用纳秒为单位的刷新率，因此我们将其乘以 NSEC_PER_SEC，这是一个系统常量，表示一秒中的纳秒数。接下来，我们创建一个事件处理程序
    ❹，每次调度源刷新时，它将重新调用 NStatManagerQueryAllSourcesDescriptions API。最后，我们调用 dispatch_resume
    函数 ❺ 来启动基于快照的监控。现在，让我们来看一下持续监控。
- en: DNS Monitoring
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DNS 监控
- en: 'Monitoring DNS traffic is an effective way to detect many types of malware.
    The idea is simple: regardless of how malware infects a victim’s machine, any
    connection it makes to a domain, such as its command-and-control server, will
    generate a DNS request and response. If we monitor DNS traffic directly on the
    host, we can do the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 监控 DNS 流量是检测许多类型恶意软件的有效方法。这个方法很简单：无论恶意软件如何感染受害者的机器，它与域名的任何连接，例如与其指挥与控制服务器的连接，都会生成
    DNS 请求和响应。如果我们直接在主机上监控 DNS 流量，我们可以做到以下几点：
- en: '**Identify new processes using the network** Anytime this activity occurs,
    you should closely examine the new process. Users frequently install new software
    that accesses the network for legitimate reasons, but if the item isn’t notarized
    or persists, for example, it could be malicious.'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**识别使用网络的新进程** 每当发生此活动时，你应该仔细检查这个新进程。用户经常安装访问网络的新软件，出于合法目的，但如果该项目没有进行认证或持续存在，例如，它可能是恶意的。'
- en: ''
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Extract the domain that the process is attempting to resolve** If the domain
    looks suspicious (perhaps because it’s hosted by an internet service provider
    commonly leveraged by malicious actors), it could reveal the presence of malware.
    Also, saving these DNS requests provides a historical record of system activity
    that you can query whenever the security community discovers new malware to see,
    albeit retroactively, whether you’ve been infected.'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提取进程试图解析的域名** 如果这个域名看起来可疑（可能因为它是由恶意行为者常用的互联网服务提供商托管的），它可能揭示了恶意软件的存在。此外，保存这些
    DNS 请求提供了一个系统活动的历史记录，你可以在安全社区发现新恶意软件时查询这些记录，看看，尽管是事后回溯，但是否曾经被感染。'
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Detect malware abusing DNS as an exfiltration channel** As firewalls typically
    allow DNS traffic, malware can exfiltrate data through valid DNS requests.'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**检测滥用 DNS 作为数据外泄通道的恶意软件** 由于防火墙通常允许 DNS 流量，恶意软件可以通过有效的 DNS 请求来外泄数据。'
- en: 'Monitoring just DNS traffic is a more efficient approach than monitoring all
    network activity, yet it still provides a way to uncover most malware. For example,
    take a look at a malicious updater component I discovered in early 2023.^([2](#chapter7-2))
    Dubbed iWebUpdater, this binary persistently installs itself to *~/Library/Services/iWebUpdate*.
    It then beacons to the domain *iwebservicescloud.com* to send information about
    the infected host and to download and install additional binaries. Within the
    malicious *iWebUpdate* binary, you can find this hardcoded domain at the address
    0x10000f7c2:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 仅监控 DNS 流量比监控所有网络活动更高效，但仍然提供了一种揭露大多数恶意软件的方法。例如，看看我在 2023 年初发现的一个恶意更新程序组件。^([2](#chapter7-2))
    这个二进制文件被命名为 iWebUpdater，它将自己持久安装到 *~/Library/Services/iWebUpdate*。然后，它向域 *iwebservicescloud.com*
    发送信息，关于感染主机并下载和安装其他二进制文件。在恶意的 *iWebUpdate* 二进制文件中，你可以在地址 0x10000f7c2 处找到这个硬编码的域名：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In its disassembly, you can see the malware references this address when it
    builds a URL whose parameters contain information about the infected host:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在其反汇编中，可以看到恶意软件在构建包含感染主机信息的 URL 时引用了这个地址：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then the malicious updater attempts to connect to the URL by leveraging the
    curl API. Using the popular network monitoring tool Wireshark, we can observe
    the DNS request and resulting response ([Figure 7-1](chapter7.xhtml#fig7-1)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，恶意更新程序通过利用 curl API 尝试连接到 URL。使用流行的网络监控工具 Wireshark，我们可以观察到 DNS 请求和相应的响应（见[图
    7-1](chapter7.xhtml#fig7-1)）。
- en: '![](../images/Figure7-1.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure7-1.jpg)'
- en: 'Figure 7-1: A network capture of iWebUpdater resolving the IP address of its
    update server'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：iWebUpdater 解析其更新服务器 IP 地址的网络抓包
- en: Even though antivirus engines initially didn’t flag the binary as malicious,
    the *iwebservicescloud.com* domain has a long history of resolving to IP addresses
    associated with malicious actors. If we could tie the DNS data back to the iWebUpdate
    binary (which I’ll show how to do shortly), we could see that it originates from
    a persistently installed launch agent that isn’t signed. Shady!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管防病毒引擎最初没有将该二进制文件标记为恶意，但 *iwebservicescloud.com* 域名有着长期解析到与恶意行为者相关的 IP 地址的历史。如果我们能够将
    DNS 数据追溯到 iWebUpdate 二进制文件（我稍后将展示如何做到这一点），我们就可以发现它来自一个未签名的、持久安装的启动代理。可疑！
- en: For another example of the power of DNS monitoring, let’s consider the 3CX supply
    chain attack more closely. Supply chain attacks are notoriously difficult to detect,
    and in this case, Apple inadvertently notarized the subverted 3CX installer. Although
    traditional antivirus software didn’t initially flag the application as malicious,
    security tools leveraging DNS monitoring capabilities quickly noticed that something
    was amiss and began alerting users, who flocked to the 3CX forums, posting messages
    such as “I had an alert come through . . . telling me that the 3CX Desktop App
    has been attempting to communicate with a ‘highly suspicious’ domain, likely to
    be actor controlled.”^([3](#chapter7-3))
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 DNS 监控强大功能的另一个例子，我们再来仔细看看 3CX 供应链攻击。供应链攻击因其难以检测而臭名昭著，而在这个案例中，苹果无意中对被篡改的 3CX
    安装程序进行了公证。尽管传统的防病毒软件最初没有将该应用标记为恶意，但利用 DNS 监控功能的安全工具迅速发现了异常，并开始警告用户，随后用户涌向 3CX
    论坛，发布诸如“我收到了一个警告……告诉我 3CX 桌面应用程序正在尝试与一个‘高度可疑’的域进行通信，可能是由攻击者控制的。”^([3](#chapter7-3))
- en: Could other heuristics have detected the attack? Possibly, but even Apple’s
    notarization system failed to notice it. Luckily, a DNS monitor provided a way
    to detect that the subverted application was communicating with a new and unusual
    domain, and mitigations soon limited what could have been a massively impactful
    and widespread cybersecurity event.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有其他启发式方法能够检测到该攻击？可能有，但即便是苹果的公证系统也未能发现它。幸运的是，DNS 监控工具提供了一种方式，能够检测到被篡改的应用程序正在与一个新的、异常的域进行通信，而补救措施很快就限制了这一本可能会造成巨大影响和广泛传播的网络安全事件。
- en: 'Of course, there are downsides to DNS monitoring. Most notably, it won’t help
    you detect malware that doesn’t resolve domains, such as simple backdoors that
    merely open listening sockets for remote connections, or those that directly connect
    to an IP address. Though such malware is rare, you’ll encounter it occasionally.
    For example, Dummy, the simple Mac malware mentioned previously, creates a reverse
    shell to a hardcoded IP address:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，DNS 监控也有其缺点。最明显的是，它无法帮助你检测那些不解析域名的恶意软件，例如仅仅打开监听套接字进行远程连接的简单后门，或者那些直接连接到 IP
    地址的恶意软件。虽然这种恶意软件比较少见，但偶尔会遇到。例如，前面提到的简单 Mac 恶意软件 Dummy，会创建一个反向 shell 连接到硬编码的 IP
    地址：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Connecting directly to an IP address doesn’t generate any DNS traffic, so a
    DNS monitor wouldn’t detect Dummy. In this case, you’d need a more comprehensive
    *filter data provider* that is capable of monitoring all traffic. Later in this
    chapter, I will show you how to build such a tool using the same framework and
    many of the same APIs used to build a simpler DNS monitor.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 直接连接到 IP 地址不会生成任何 DNS 流量，因此 DNS 监控无法检测到 Dummy。在这种情况下，你需要一个更全面的*过滤数据提供者*，它能够监控所有流量。本章稍后我会展示如何使用相同的框架和许多与构建简单
    DNS 监控工具相同的 API 来构建这样的工具。
- en: Using the NetworkExtension Framework
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 NetworkExtension 框架
- en: Monitoring network traffic on macOS used to require writing a network kernel
    extension. Apple has since deprecated this approach, along with all third-party
    kernel extensions, and introduced *system extensions* to replace it. System extensions
    run more safely in user mode and provide a modern mechanism to extend or enhance
    macOS functionality.^([4](#chapter7-4))
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上监控网络流量曾经需要编写网络内核扩展。苹果随后弃用了这种方法，以及所有第三方内核扩展，并引入了*系统扩展*来替代它。系统扩展在用户模式下运行，更加安全，并提供了一个现代化的机制来扩展或增强
    macOS 功能。^([4](#chapter7-4))
- en: To extend core networking features, Apple also introduced the user-mode *NetworkExtension*
    framework.^([5](#chapter7-5)) By building system extensions that leverage this
    framework, you can achieve the same capabilities as the now-deprecated network
    kernel extensions, but from user mode.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展核心网络功能，苹果还引入了用户模式的*NetworkExtension*框架。^([5](#chapter7-5)) 通过构建利用该框架的系统扩展，你可以实现与现已弃用的网络内核扩展相同的功能，但这是从用户模式实现的。
- en: System extensions are powerful, so Apple requires that you fulfill several prerequisites
    before you can deploy your extension:^([6](#chapter7-6))
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 系统扩展功能强大，因此苹果要求你在部署扩展之前满足若干先决条件。^([6](#chapter7-6))
- en: You must package the extension in an application bundle’s *Contents/Library/SystemExtensions/*
    directory.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须将扩展打包在应用程序包的*Contents/Library/SystemExtensions/* 目录中。
- en: The application containing the extension must be given the *com.apple .developer.system-extension.install*
    entitlement, and you must build it with a provisioning profile that provides the
    means to authorize the entitlement at runtime.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含扩展的应用程序必须获得*com.apple.developer.system-extension.install* 权限，并且你必须使用一个配置文件来构建它，这个配置文件提供了在运行时授权该权限的方法。
- en: The application containing the extension must be signed with an Apple developer
    ID, as well as notarized.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含扩展的应用程序必须使用 Apple 开发者 ID 签名，并且需要进行公证。
- en: The application containing the extension must be installed in an appropriate
    *Applications* directory.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含扩展的应用程序必须安装在合适的*应用程序*目录中。
- en: In unmanaged environments, macOS requires explicit user approval to load any
    system extension.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非托管环境中，macOS 需要明确的用户批准才能加载任何系统扩展。
- en: I’ll explain how to fulfill these requirements in [Chapter 13](chapter13.xhtml).
    As I noted in the book’s introduction, you can turn off System Integrity Protection
    (SIP) and Apple Mobile File Integrity (AMFI) to sidestep some of them. However,
    disabling these protections significantly reduces the overall security of the
    system, so I recommend doing so only within a virtual machine or on a system dedicated
    to development or testing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[第 13 章](chapter13.xhtml)中解释如何满足这些要求。正如我在本书的介绍中提到的，你可以关闭系统完整性保护（SIP）和 Apple
    移动文件完整性（AMFI）来规避其中的一些要求。然而，禁用这些保护会显著降低系统的整体安全性，因此我建议仅在虚拟机中或专门用于开发或测试的系统上这样做。
- en: Next, I will briefly cover how to programmatically install and load a system
    extension, then use the *NetworkExtension* framework to monitor DNS traffic. Here,
    relevant code snippets are provided, and you can find this code in its entirety
    in Objective-See’s open source *DNSMonitor* project, covered in detail in [Chapter
    13](chapter13.xhtml).^([7](#chapter7-7))
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将简要介绍如何以编程方式安装和加载系统扩展，然后使用*NetworkExtension*框架监控DNS流量。此处提供了相关的代码片段，您可以在Objective-See的开源*DNSMonitor*项目中找到完整的代码，详细内容见[第13章](chapter13.xhtml)。^([7](#chapter7-7))
- en: NOTE
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Several APIs mentioned in this section have recently been deprecated by Apple,
    for example, in macOS 15\. However, at the time of this publication, they retain
    their functionality. If you’re developing for older versions of macOS, you’ll
    still want to use these APIs for compatibility. Additionally, some deprecated
    functions, such as those from Apple’s* libresolv *library, lack direct replacements,
    so it makes sense to continue using them where necessary.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节提到的几个API最近已被Apple废弃，例如在macOS 15中。但在本书出版时，它们仍然保留功能。如果您正在为较旧版本的macOS开发，仍然需要使用这些API以保持兼容性。此外，某些已废弃的函数，如来自Apple*libresolv*库的函数，缺乏直接替代品，因此在必要时继续使用它们是有意义的。*'
- en: Activating a System Extension
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 激活系统扩展
- en: Apple requires you to place any system extension in an application bundle, so
    the code to install, or *activate*, a system extension must also live in the application.
    [Listing 7-2](chapter7.xhtml#Lis7-2) shows how to programmatically activate such
    an extension.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Apple要求您将任何系统扩展放置在应用程序包中，因此，安装或*激活*系统扩展的代码也必须位于应用程序中。[列表7-2](chapter7.xhtml#Lis7-2)展示了如何以编程方式激活此类扩展。
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 7-2: Installing a system extension'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-2：安装系统扩展
- en: 'The application that contains an extension should first invoke the OSSystemExtensionRequest
    class’s activationRequestForExtension:queue: method ❶, which creates a request
    to activate a system extension.^([8](#chapter7-8)) The method takes the extension’s
    bundle ID and a dispatch queue, which it will use to call delegate methods. We
    must set a delegate ❷ before we can submit the request to the system extension
    manager to trigger the activation ❸.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 包含扩展的应用程序应首先调用OSSystemExtensionRequest类的activationRequestForExtension:queue:方法❶，该方法会创建一个激活系统扩展的请求。^([8](#chapter7-8))
    该方法接受扩展的bundle ID和一个调度队列，系统会使用该队列来调用委托方法。在提交请求给系统扩展管理器触发激活之前，我们必须先设置一个委托❷。
- en: Let’s talk about the delegate in a bit more detail. The OSSystemExtensionRequest
    object requires a *delegate object*, which should conform to the OSSystemExtensionRequestDelegate
    protocol and implement various delegate methods to handle callbacks that occur
    during the activation process, as well as success and failure cases. The operating
    system will automatically invoke these delegate methods during the process of
    activating the extension. Here is a brief overview of these required delegate
    methods, based on Apple’s documentation:^([9](#chapter7-9))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来详细谈谈委托。OSSystemExtensionRequest对象需要一个*委托对象*，该对象应符合OSSystemExtensionRequestDelegate协议，并实现各种委托方法，以处理激活过程中发生的回调以及成功和失败的情况。在激活扩展的过程中，操作系统会自动调用这些委托方法。以下是根据Apple文档对这些必需委托方法的简要概述：^([9](#chapter7-9))
- en: '**requestNeedsUserApproval**: Invoked when the system has determined that it
    needs user approval before activating the extension'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**requestNeedsUserApproval**: 在系统确定需要用户批准才能激活扩展时调用'
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**request:actionForReplacingExtension:withExtension:** Invoked when another
    version of the extension is already installed on the system'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**request:actionForReplacingExtension:withExtension:** 在系统中已安装扩展的另一个版本时调用'
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**request:didFailWithError:** Invoked when the activation request has failed'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**request:didFailWithError:** 在激活请求失败时调用'
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**request:didFinishWithResult:** Invoked when the activation request has completed'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**request:didFinishWithResult:** 在激活请求完成时调用'
- en: It’s important that your application implement these required delegate methods.
    Otherwise, it will crash when the system attempts to invoke them during the activation
    of your extension.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序必须实现这些必需的委托方法。否则，当系统尝试在激活扩展时调用它们时，应用程序将崩溃。
- en: 'The good news is that implementing the methods doesn’t involve much. For example,
    the requestNeedsUserApproval: method can simply return, as can the request:didFailWithError:
    method (although you’ll likely want to use it to log error messages). The request:actionForReplacingExtension:withExtension:
    method can return a value of OSSystemExtensionReplacementActionReplace to tell
    the operating system to replace any old instances of the extension.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，实施这些方法并不复杂。例如，`requestNeedsUserApproval:` 方法可以简单地返回，`request:didFailWithError:`
    方法也可以如此（尽管你可能希望用它来记录错误信息）。`request:actionForReplacingExtension:withExtension:`
    方法可以返回 `OSSystemExtensionReplacementActionReplace` 的值，告诉操作系统替换任何旧的扩展实例。
- en: 'Once the user has approved the extension, the system will invoke the request:didFinishWithResult:
    delegate method. If the result passed into this method is OSSystemExtensionRequestCompleted,
    the extension has successfully activated. At this point, you can proceed to enable
    network monitoring.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户批准了扩展，系统将调用 `request:didFinishWithResult:` 委托方法。如果传入该方法的结果是 `OSSystemExtensionRequestCompleted`，则表示扩展已成功激活。此时，你可以继续启用网络监控。
- en: Enabling the Monitoring
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启用监控
- en: Assuming the system extension activated successfully, you can now instruct the
    system to begin routing all DNS traffic through the extension. A singleton NEDNSProxyManager
    object can enable this monitoring, as shown in [Listing 7-3](chapter7.xhtml#Lis7-3).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设系统扩展成功激活，现在你可以指示系统开始通过扩展路由所有 DNS 流量。一个单例的 NEDNSProxyManager 对象可以启用此监控，如[列表
    7-3](chapter7.xhtml#Lis7-3)所示。
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 7-3: Enabling DNS monitoring via an NEDNSProxyManager object'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-3：通过 NEDNSProxyManager 对象启用 DNS 监控
- en: 'First, we must load the current DNS proxy configuration by calling the NEDNSProxyManager
    class’s shared manager loadFromPreferencesWithCompletionHandler: method ❶. As
    its only argument, this method takes a block to invoke once the preferences have
    been loaded.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须通过调用 NEDNSProxyManager 类的共享管理器的 `loadFromPreferencesWithCompletionHandler:`
    方法 ❶ 来加载当前的 DNS 代理配置。这个方法只有一个参数，即一个块（block），该块会在加载完偏好设置后调用。
- en: After invoking the callback, we can configure the preferences to enable the
    DNS monitor. First, we set a description ❷ that will appear in the operating system’s
    System Settings application, which can display all active extensions. Then we
    allocate and initialize an NEDNSProxyProviderProtocol object with the bundle ID
    of our extension ❸. Following this, we specify that we’re toggling the DNS monitor
    on by setting the NEDNSProxyManager object’s shared manager enabled instance variable
    to YES ❹.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 调用回调后，我们可以配置偏好设置以启用 DNS 监控。首先，我们设置一个描述 ❷，该描述将显示在操作系统的系统设置应用中，系统设置应用可以展示所有激活的扩展。然后，我们分配并初始化一个
    NEDNSProxyProviderProtocol 对象，并设置其捆绑 ID ❸。接下来，我们通过将 NEDNSProxyManager 对象的共享管理器的
    `enabled` 实例变量设置为 YES ❹ 来表示我们已开启 DNS 监控。
- en: Finally, we invoke the shared manager’s saveToPreferencesWithCompletionHandler
    method to save the updated configuration information ❺. Once we make this call,
    the system extension should be fully activated, and the operating system will
    begin proxying DNS traffic through it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用共享管理器的 `saveToPreferencesWithCompletionHandler` 方法来保存更新后的配置信息 ❺。一旦调用此方法，系统扩展应已完全激活，操作系统将开始通过它代理
    DNS 流量。
- en: Writing the Extension
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写扩展
- en: When we make a request to activate a system extension and toggle on a network
    extension, the system will copy the extension from the application’s bundle into
    a secure, root-owned directory, */Library/SystemExtension*. After verifying the
    extension, the system will load and execute it as a stand-alone process running
    with root privileges.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们请求激活系统扩展并开启网络扩展时，系统会将扩展从应用的捆绑包复制到一个安全的、根用户拥有的目录中，*/Library/SystemExtension*。在验证扩展后，系统会将其加载并作为独立进程执行，且运行时拥有根权限。
- en: Now that we’ve activated the extension from within the application, let’s explore
    the code found in the extension itself. [Listing 7-4](chapter7.xhtml#Lis7-4) begins
    the extension.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从应用内激活了扩展，让我们来看看扩展本身的代码。[列表 7-4](chapter7.xhtml#Lis7-4) 开始了扩展的部分内容。
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-4: The network extension’s initialization logic'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-4：网络扩展的初始化逻辑
- en: In the extension’s main function, we invoke the NEProvider startSystemExtensionMode
    method to “start the Network Extension machinery.”^([10](#chapter7-10)) I also
    recommend making a call to dispatch_main; otherwise, the main function will return,
    and your extension will exit.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展的主函数中，我们调用 NEProvider 的 `startSystemExtensionMode` 方法来“启动网络扩展机制”。^([10](#chapter7-10))
    我还建议调用 `dispatch_main`，否则主函数将返回，导致扩展退出。
- en: 'Behind the scenes, the startSystemExtensionMode method will cause the *NetworkExtension*
    framework to instantiate the class specified under the NEProviderClasses key of
    the NetworkExtension dictionary in the extension’s *Info.plist* file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`startSystemExtensionMode` 方法会使 *NetworkExtension* 框架实例化在扩展的 *Info.plist*
    文件中，NetworkExtension 字典下的 NEProviderClasses 键指定的类：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You must create this class, naming it whatever you’d like. Here, we’ve chosen
    the name DNSProxyProvider, and as we’re interested in proxying DNS traffic, we
    used the key value com.apple.networkextension.dns-proxy. This class must inherit
    from the NEProviderClass class or one of its subclasses, such as NEDNSProxyProvider:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须创建这个类，并随意命名。这里，我们选择了名称 `DNSProxyProvider`，因为我们关心的是代理 DNS 流量，所以我们使用了键值 `com.apple.networkextension.dns-proxy`。此类必须继承自
    `NEProviderClass` 类或其子类之一，如 `NEDNSProxyProvider`：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Moreover, the class must implement relevant delegate methods that the *NetworkExtension*
    framework will call to, for example, handle DNS network events. These delegate
    methods include the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该类必须实现 *NetworkExtension* 框架将调用的相关委托方法，例如处理 DNS 网络事件。这些委托方法包括以下内容：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The start and stop methods provide you with an opportunity to perform any necessary
    initialization or cleanup. You can learn more about them in the *NEDNSProxyProvider.h*
    file or in Apple’s developer documentation for the NEDNSProxyProvider class.^([11](#chapter7-11))
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`start` 和 `stop` 方法为你提供了执行必要初始化或清理工作的机会。你可以在 *NEDNSProxyProvider.h* 文件中或通过苹果开发者文档中的
    NEDNSProxyProvider 类了解更多信息。^([11](#chapter7-11))'
- en: 'The *NetworkExtension* framework will automatically invoke the handleNewFlow:
    delegate method to deliver the network data, so this method should contain the
    DNS monitor’s core logic. The method gets invoked with a *flow*, which represents
    a unit of network data transferred between a source and destination.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*NetworkExtension* 框架会自动调用 `handleNewFlow:` 委托方法来传递网络数据，因此该方法应包含 DNS 监控器的核心逻辑。该方法会在有
    *flow* 时被调用，*flow* 表示在源和目标之间传输的网络数据单元。'
- en: 'The NEAppProxyFlow objects encapsulate flows passed to handleNewFlow: to provide
    an interface for the network data. Because DNS traffic generally travels over
    UDP, this example focuses solely on UDP flows, whose type is NEAppProxyUDPFlow,
    a subclass of NEAppProxyFlow. In [Chapter 13](chapter13.xhtml), I’ll go through
    the steps of proxying UDP traffic in detail, but for now, we’ll just consider
    the process of interacting with DNS packets.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: NEAppProxyFlow 对象封装了传递给 `handleNewFlow:` 的流，以提供网络数据的接口。由于 DNS 流量通常通过 UDP 传输，因此这个示例仅专注于
    UDP 流，UDP 流的类型是 `NEAppProxyUDPFlow`，它是 `NEAppProxyFlow` 的子类。在 [第 13 章](chapter13.xhtml)
    中，我将详细介绍代理 UDP 流量的步骤，但现在我们只考虑与 DNS 数据包交互的过程。
- en: Parsing DNS Requests
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解析 DNS 请求
- en: We can read from an NEAppProxyUDPFlow flow object to obtain a list of datagrams
    for a specific DNS request (or *question*, in DNS parlance). Each datagram is
    stored in an NSData object; [Listing 7-5](chapter7.xhtml#Lis7-5) parses and prints
    these out.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一个 NEAppProxyUDPFlow 流对象中读取，以获取特定 DNS 请求（或在 DNS 术语中称为 *question*）的报文列表。每个数据报文都存储在一个
    NSData 对象中；[Listing 7-5](chapter7.xhtml#Lis7-5) 解析并打印这些报文。
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 7-5: Reading and then parsing DNS datagrams'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 7-5：读取并解析 DNS 数据报文
- en: We parse the packet via the dns_parse_packet function ❶, found in Apple’s *libresolv*
    library. We then print out the packet via a call to the dns_print_reply function
    ❷. Finally, we free it via the dns_free_reply function ❸.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `dns_parse_packet` 函数❶ 解析数据包，该函数位于苹果的 *libresolv* 库中。然后我们通过调用 `dns_print_reply`
    函数❷ 打印数据包。最后，通过 `dns_free_reply` 函数❸ 释放它。
- en: Of course, you’ll likely want your program to examine the DNS request rather
    than just print it out. You can inspect the parsed DNS record returned by the
    dns_parse_packet function, which has the type dns_reply_t. For example, [Listing
    7-6](chapter7.xhtml#Lis7-6) shows how to access the request’s fully qualified
    domain name (FQDN).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能希望你的程序检查 DNS 请求，而不仅仅是打印它。你可以检查由 `dns_parse_packet` 函数返回的解析后的 DNS 记录，该记录的类型为
    `dns_reply_t`。例如，[Listing 7-6](chapter7.xhtml#Lis7-6) 展示了如何访问请求的完全限定域名（FQDN）。
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 7-6: Extracting members of interest from a parsed DNS request'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 7-6：从解析后的 DNS 请求中提取感兴趣的成员
- en: We make use of the qdcount and question members of the DNS packet to iterate
    over every question ❶. For each question, we extract its name (the domain to resolve)
    ❷, its class, and its type; convert them into strings (via Apple’s dns_class_string);
    and save them into a dictionary object. Finally, we save the dictionary of extracted
    details for each question to an array ❸.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用 DNS 数据包的 qdcount 和 question 成员来遍历每个问题 ❶。对于每个问题，我们提取它的名称（要解析的域名）❷、其类别和类型；将它们转换为字符串（通过
    Apple 的 dns_class_string）；并将它们保存到字典对象中。最后，我们将每个问题提取的详细信息字典保存到一个数组 ❸ 中。
- en: 'Now, if you perform a query via nslookup, for example, to *objective-see.org*,
    the DNS monitor code will capture the request:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你通过 nslookup 进行查询，例如查询 *objective-see.org*，DNS 监控代码将捕获到请求：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we’ll handle DNS responses (called *answers*).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理 DNS 回应（称为 *答案*）。
- en: Parsing DNS Responses
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解析 DNS 回应
- en: A DNS monitor that leverages the NEDNSProxyProvider class is essentially a proxy,
    proxying both local requests and remote responses. This means that we must read
    the DNS request of the local flow, and then open a remote and send the request
    to its destination. To access any response, we read data from the remote endpoint
    using the nw_connection_receive API. [Listing 7-7](chapter7.xhtml#Lis7-7) invokes
    this API on the remote endpoint, then invokes the dns_parse_packet within its
    callback block to parse the response.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 NEDNSProxyProvider 类的 DNS 监控器本质上是一个代理，它代理本地请求和远程回应。这意味着我们必须读取本地流的 DNS 请求，然后打开远程连接并将请求发送到其目标。为了访问任何回应，我们使用
    nw_connection_receive API 从远程端点读取数据。[Listing 7-7](chapter7.xhtml#Lis7-7) 在远程端点上调用此
    API，然后在其回调块中调用 dns_parse_packet 来解析回应。
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 7-7: Receiving and parsing DNS responses'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 7-7：接收和解析 DNS 回应
- en: Although we could just print out the response using the dns_print_reply function,
    let’s instead extract the answers. You’ll notice that this code, shown in [Listing
    7-8](chapter7.xhtml#Lis7-8), is similar to the snippet that extracted the questions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以使用 dns_print_reply 函数直接打印回应，但我们更倾向于提取答案。你会注意到，这段代码（见 [Listing 7-8](chapter7.xhtml#Lis7-8)）与提取问题的代码片段类似。
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 7-8: Extracting members of interest from a parsed DNS response'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 7-8：从解析后的 DNS 回应中提取感兴趣的成员
- en: Here, however, we access the ancount ❶ and answer members ❷ and then must add
    additional logic to extract the response’s contents. For example, we examine its
    type ❸ and, if it’s an IPv4 address (ns_t_a) ❹, convert it via the inet_ntoa function
    ❺.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，我们访问 ancount ❶ 和 answer 成员 ❷，然后必须添加额外的逻辑来提取回应的内容。例如，我们检查它的类型 ❸，如果是 IPv4
    地址（ns_t_a）❹，则通过 inet_ntoa 函数 ❺ 转换它。
- en: 'If we run Objective-See’s DNSMonitor, which contains this code and has received
    the appropriate entitlement and notarization, we can see that it will capture
    the answer to our previous *objective-see.org* lookup:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行 Objective-See 的 DNSMonitor，它包含了这段代码并且已获得适当的授权和认证，我们可以看到它会捕获到我们之前查询 *objective-see.org*
    的答案：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The packet type is a reply containing the original question and the answers.
    We also learn that the domain *objective-see.org* maps to multiple IP addresses.
    When run against actual malware, this information can be incred- ibly useful.
    Take the aforementioned iWebUpdater as an example. When it connects to *iwebservicescloud.com*,
    it generates a DNS request and reply:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包类型是包含原始问题和答案的回应。我们还了解到，域名 *objective-see.org* 映射到多个 IP 地址。当与实际恶意软件一起运行时，这些信息可以非常有用。以前面提到的
    iWebUpdater 为例。当它连接到 *iwebservicescloud.com* 时，它会生成一个 DNS 请求和回应：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The DNS monitoring code is able to detect both the resolution request and reply.
    Passing either of these into an external threat intelligence platform such as
    VirusTotal should reveal that the domain has a history of resolving to IP addresses
    associated with malicious activity (including the specific IP address it resolved
    to here).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 监控代码能够检测到解析请求和回应。将其中任何一个传递到外部威胁情报平台（如 VirusTotal），应该能显示该域名有历史记录解析到与恶意活动相关的
    IP 地址（包括它解析到的具体 IP 地址）。
- en: The astute reader may have noticed that the output also identified iWebUpdater
    as the process responsible for making this request. Let’s see how to do this now.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 精明的读者可能已经注意到，输出结果还识别出 iWebUpdater 是发出此请求的进程。现在我们来看看如何做。
- en: Identifying the Responsible Process
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 识别责任进程
- en: Identifying the process responsible for a DNS request is essential to detecting
    malware, yet DNS monitors that aren’t host-based can’t provide this information.
    For example, requests from trusted system processes are likely safe, while requests
    from, say, a persistent, unnotarized process such as iWebUpdate should be closely
    scrutinized.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 确定负责 DNS 请求的进程对于检测恶意软件至关重要，但非主机式的 DNS 监控无法提供此信息。例如，来自受信任系统进程的请求很可能是安全的，而来自某些持久的、未经过
    notarize 处理的进程（如 iWebUpdate）的请求则应当受到密切审查。
- en: 'Now I’ll show you how to obtain the ID of the responsible process using information
    provided by the *NetworkExtension* framework. The flow object passed into the
    extension via the handleNewFlow: delegate method contains an instance variable
    named metaData whose type is NEFlowMetaData. Consulting the *NEFlowMetaData.h*
    file (found in *NetworkExtension.framework/Versions/A/Headers/*) reveals that
    it contains a property named sourceAppAuditToken with the responsible process’s
    audit token.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我将向你展示如何使用 *NetworkExtension* 框架提供的信息获取负责进程的 ID。通过 handleNewFlow: 委托方法传递到扩展中的流对象包含一个名为
    metaData 的实例变量，其类型为 NEFlowMetaData。查看 *NEFlowMetaData.h* 文件（位于 *NetworkExtension.framework/Versions/A/Headers/*）可以发现，它包含一个名为
    sourceAppAuditToken 的属性，存储着负责进程的审计令牌。'
- en: From this audit token, we can extract the responsible process’s ID and securely
    obtain its path using SecCode* APIs. [Listing 7-9](chapter7.xhtml#Lis7-9) implements
    this technique.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个审计令牌中，我们可以提取负责进程的 ID，并通过 SecCode* APIs 安全地获取其路径。[列表 7-9](chapter7.xhtml#Lis7-9)
    实现了这一技术。
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 7-9: Obtaining the responsible process’s ID and path from a network
    flow'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-9：从网络流中获取负责进程的 ID 和路径
- en: First, we initialize a pointer to an audit token. As noted, the sourceAppAuditToken
    contains this token in the form of an NSData object. To get a pointer to the audit
    token’s actual bytes, we use the bytes property of the NSData class ❶. With this
    pointer, we can extract the associated process ID via the audit_token_to_pid function
    ❷. Next, we obtain a code reference from the audit token ❸ and then invoke the
    SecCodeCopyPath function to obtain the process’s path ❹.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化一个指向审计令牌的指针。如前所述，sourceAppAuditToken 包含以 NSData 对象形式存储的令牌。为了获取指向审计令牌实际字节的指针，我们使用
    NSData 类的 bytes 属性 ❶。通过这个指针，我们可以通过 audit_token_to_pid 函数提取相关的进程 ID ❷。接下来，我们从审计令牌中获取代码引用
    ❸，然后调用 SecCodeCopyPath 函数来获取进程的路径 ❹。
- en: It’s worth noting that the SecCodeCopyGuestWithAttributes API can fail, for
    example, if the process has self-deleted. This case is both very unusual and likely
    indicative of a malicious process. Regardless, you’ll have to defer to other,
    less certain methods of obtaining the process’s path, such as examining the process’s
    arguments, which can be surreptitiously modified.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，SecCodeCopyGuestWithAttributes API 可能会失败，例如，如果进程已经自我删除。在这种情况下，虽然比较罕见，但可能表明这是一个恶意进程。无论如何，你必须依赖其他不那么确定的方法来获取进程的路径，比如检查进程的参数，这些参数可能会被偷偷修改。
- en: From the flow, we can also extract the responsible process’s code signing identifier,
    which can help classify the process as either benign or something to investigate
    further. This identifier is in the flow’s sourceAppSigningIdentifier attribute.
    [Listing 7-10](chapter7.xhtml#Lis7-10) extracts it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从流中，我们还可以提取负责进程的代码签名标识符，这有助于将进程分类为良性进程或需要进一步调查的进程。这个标识符位于流的 sourceAppSigningIdentifier
    属性中。[列表 7-10](chapter7.xhtml#Lis7-10) 提取了它。
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 7-10: Extracting code signing information from a network flow'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-10：从网络流中提取代码签名信息
- en: 'As noted earlier in this chapter, the DNS monitoring process I’ve described
    thus far would fail to detect malware such as Dummy, which connects directly to
    an IP address. To detect such threats, let’s expand our monitoring capabilities
    to examine all network traffic.  ### Filter Data Providers'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '如本章早些时候所述，我迄今为止描述的 DNS 监控进程无法检测到直接连接到 IP 地址的恶意软件，例如 Dummy。为了检测这些威胁，让我们扩展监控能力，检查所有网络流量。  ###
    数据过滤提供者'
- en: One of the most powerful network monitoring capabilities afforded by macOS are
    *filter data providers*. Implemented within a system extension and built atop
    the *NetworkExtension* framework, these network extensions can observe and filter
    all network traffic. You could use them to actively block malicious network traffic
    or else to passively observe all network flows, then identify potentially suspicious
    processes to investigate further.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: macOS提供的最强大网络监控功能之一就是*过滤数据提供者*。这些网络扩展实现于系统扩展中，并建立在*NetworkExtension*框架之上，可以观察并过滤所有网络流量。你可以利用它们主动阻止恶意网络流量，或者被动地观察所有网络流量，并识别可能的可疑进程，以进一步调查。
- en: Interestingly, when Apple introduced filter data providers along with the other
    network extensions, it initially decided to exempt traffic generated by various
    system components from filtering, even though this traffic had previously been
    routed through the now-deprecated network kernel extensions. This meant that security
    tools such as network monitors and firewalls that had previously observed all
    network traffic now remained blind to some of it. Unsurprisingly, abusing the
    exempted system components was easy and provided a stealthy way to bypass any
    third-party security tool built atop Apple’s network extensions. After I demonstrated
    this bypass, the media jumped on the story,^([12](#chapter7-12)) and public outcry
    encouraged Apple to reevaluate its approach. Ultimately, wiser minds in Cupertino
    prevailed; today, all network traffic on macOS is routed through any installed
    filter data provider.^([13](#chapter7-13))
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，当Apple引入过滤数据提供者以及其他网络扩展时，它最初决定将各种系统组件生成的流量排除在过滤之外，尽管这些流量之前是通过现在已废弃的网络内核扩展进行路由的。这意味着，之前能观察到所有网络流量的安全工具（如网络监视器和防火墙）现在对其中的一部分流量视而不见。不出所料，滥用这些被豁免的系统组件变得很容易，为绕过任何基于Apple网络扩展构建的第三方安全工具提供了一种隐蔽的方法。在我展示了这个绕过方法后，媒体纷纷报道这一事件，^([12](#chapter7-12))，公众的强烈反应促使Apple重新审视其做法。最终，库比蒂诺的智者们取得了胜利；如今，macOS上的所有网络流量都会通过任何已安装的过滤数据提供者进行路由。^([13](#chapter7-13))
- en: NOTE
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*As with the DNS monitor, the filter data provider network extension we’ll
    implement here must meet the prerequisites discussed in “Using the NetworkExtension
    Framework” on [page 159](chapter7.xhtml#pg_159).*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*与DNS监视器一样，我们将在这里实现的过滤数据提供者网络扩展必须满足“使用NetworkExtension框架”中讨论的前提条件，见[第159页](chapter7.xhtml#pg_159)。*'
- en: The code in this section largely comes from Objective-See’s popular open source
    firewall, LuLu, written by yours truly. You can find LuLu’s complete code in its
    GitHub repository, [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/LuLu*](https://github.com/objective-see/LuLu).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码大部分来自Objective-See的流行开源防火墙LuLu，由我本人编写。你可以在其GitHub代码库中找到LuLu的完整代码，[*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/LuLu*](https://github.com/objective-see/LuLu)。
- en: Enabling Filtering
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启用过滤
- en: Let’s start by programmatically activating a network extension that implements
    a filter data provider. This process deviates slightly from the activation of
    a network extension that implements DNS monitoring; instead of using an NEDNSProxyManager
    object, we’ll leverage an NEFilterManager object.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过编程方式激活一个实现过滤数据提供者的网络扩展。这个过程与激活实现DNS监控的网络扩展略有不同；我们将使用NEFilterManager对象，而不是NEDNSProxyManager对象。
- en: In the main application, use the process covered in “Activating a System Extension”
    on [page 160](chapter7.xhtml#pg_160) to activate the extension, then enable filtering
    as shown in [Listing 7-11](chapter7.xhtml#Lis7-11).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在主应用程序中，使用“激活系统扩展”中描述的过程，在[第160页](chapter7.xhtml#pg_160)激活扩展，然后按照[列表7-11](chapter7.xhtml#Lis7-11)所示启用过滤。
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 7-11: Enabling filtering with an NEFilterManager object'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-11：使用NEFilterManager对象启用过滤
- en: 'First, we access the NEFilterManager shared manager object and invoke its loadFromPreferencesWithCompletionHandler:
    method ❶. Once this completes, we initialize an NEFilterProviderConfiguration
    object ❷. We then set two configuration options ❸. As we’re not interested in
    filtering packets, we set this option to NO. On the other hand, we want to filter
    socket activity, so we set this to YES. The code then saves this configuration
    and sets the NEFilterManager shared manager object to enabled ❹. Finally, to trigger
    the network extension activation with this configuration, the code invokes the
    shared manager’s saveToPreferencesWithCompletionHandler: method ❺. Once this process
    completes, the filter data provider should be running.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们访问 NEFilterManager 共享管理器对象，并调用它的 loadFromPreferencesWithCompletionHandler:
    方法 ❶。完成后，我们初始化一个 NEFilterProviderConfiguration 对象 ❷。然后我们设置两个配置选项 ❸。由于我们不打算过滤数据包，所以将此选项设置为
    NO。另一方面，我们希望过滤套接字活动，因此将其设置为 YES。代码随后保存这个配置并将 NEFilterManager 共享管理器对象设置为启用 ❹。最后，为了激活带有此配置的网络扩展，代码调用共享管理器的
    saveToPreferencesWithCompletionHandler: 方法 ❺。这个过程完成后，过滤数据提供者应该开始运行。'
- en: Writing the Extension
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写扩展
- en: 'As with the DNS monitor, the filter data provider is a separate binary that
    you must package in a bundle’s *Contents/Library/SystemExtensions/* directory.
    Once loaded, it should invoke NEProvider’s startSystemExtensionMode: method. In
    the extension’s *Info.plist* file, we add a dictionary referenced by the key NEProviderClasses
    containing a single key-value pair ([Listing 7-12](chapter7.xhtml#Lis7-12)).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '与 DNS 监视器类似，过滤数据提供者是一个独立的二进制文件，必须打包在捆绑包的 *Contents/Library/SystemExtensions/*
    目录中。加载后，它应该调用 NEProvider 的 startSystemExtensionMode: 方法。在扩展的 *Info.plist* 文件中，我们添加一个字典，通过键
    NEProviderClasses 引用，包含一个键值对 ([列表 7-12](chapter7.xhtml#Lis7-12))。'
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 7-12: The extension’s Info.plist file, which specifies the extension’s
    NEProviderClasses class'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-12：扩展的 Info.plist 文件，指定扩展的 NEProviderClasses 类
- en: We set the key to com.apple.networkextension.filter-data and the value to the
    name of our class in the extension that inherits from NEFilterDataProvider. In
    this example, we’ve named the class FilterDataProvider, which we declare as such
    ([Listing 7-13](chapter7.xhtml#Lis7-13)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将键设置为 com.apple.networkextension.filter-data，值设置为我们扩展中继承自 NEFilterDataProvider
    的类的名称。在此示例中，我们将类命名为 FilterDataProvider，并按此方式声明它 ([列表 7-13](chapter7.xhtml#Lis7-13))。
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 7-13: An interface definition for the FilterDataProvider class'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-13：FilterDataProvider 类的接口定义
- en: Once the filter data provider extension is up and running, the *NetworkExtension*
    framework will automatically invoke this class’s startFilterWithCompletionHandler
    method, where you’ll specify what traffic you’d like to filter. The code in [Listing
    7-14](chapter7.xhtml#Lis7-14) filters all protocols but only for outgoing traffic,
    which is more helpful than incoming traffic for detecting unauthorized or new
    programs that could be malware.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦过滤数据提供者扩展启动并运行，*NetworkExtension*框架将自动调用此类的 startFilterWithCompletionHandler
    方法，在这里你可以指定你想要过滤的流量。[列表 7-14](chapter7.xhtml#Lis7-14) 中的代码过滤所有协议，但仅限于出站流量，这比入站流量更有助于检测未经授权或可能是恶意软件的新程序。
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 7-14: Setting filter rules to specify which traffic should be routed
    through the extension'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-14：设置过滤规则以指定哪些流量应通过扩展进行路由
- en: First, the code creates an NENetworkRule object, setting the protocol filter
    option to any and the direction filter option to outbound ❶. Then it uses this
    NENetworkRule object to create an NEFilterRule object. It also specifies an action
    of NEFilterActionFilterData to tell the *NetworkExtension* framework that we want
    to filter data ❷. Next, it creates an NEFilterSettings object with the filter
    rule we just created that matches all outbound traffic. Specifying NEFilterActionAllow
    for the default action means any traffic that doesn’t match this filter rule will
    be allowed ❸. Finally, it applies the settings to begin the filtration ❹.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码创建了一个 NENetworkRule 对象，将协议过滤选项设置为任何，方向过滤选项设置为出站 ❶。然后，使用这个 NENetworkRule
    对象创建一个 NEFilterRule 对象。它还指定了 NEFilterActionFilterData 动作，告诉*NetworkExtension*框架我们想要过滤数据
    ❷。接下来，创建了一个 NEFilterSettings 对象，使用我们刚刚创建的过滤规则，这个规则匹配所有出站流量。指定 NEFilterActionAllow
    作为默认动作意味着任何不匹配此过滤规则的流量将被允许 ❸。最后，它应用这些设置开始过滤 ❹。
- en: 'Now, anytime a program on the system initiates a new outbound network connection,
    the system automatically invokes the handleNewFlow: delegate method in our filter
    class. Though it shares the same name, this delegate method differs from the one
    we used for DNS monitoring in a few ways. It takes a single argument (an NEFilterFlow
    object that contains information about the flow) and, upon returning, must instruct
    the system on how to handle the flow. It does so via an NEFilterNewFlowVerdict
    object, which can specify verdicts such as allow (allowVerdict), drop (dropVerdict),
    or pause (pauseVerdict). Because we’re focusing on tying a flow to its responsible
    process, we’ll always allow the flow ([Listing 7-15](chapter7.xhtml#Lis7-15)).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何时候系统上的程序发起一个新的外向网络连接，系统会自动调用我们过滤器类中的`handleNewFlow:`代理方法。虽然它的名字相同，但这个代理方法与我们用于DNS监控的那个方法有所不同。它接受一个参数（一个包含流信息的NEFilterFlow对象），并且在返回时，必须指示系统如何处理该流。它通过一个NEFilterNewFlowVerdict对象来实现，这个对象可以指定裁定，如允许（allowVerdict）、丢弃（dropVerdict）或暂停（pauseVerdict）。因为我们专注于将流与其负责的进程绑定，所以我们总是允许流通过（[Listing
    7-15](chapter7.xhtml#Lis7-15)）。
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 7-15: Returning a verdict from the handleNewFlow: method'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-15: 从handleNewFlow:方法返回裁定'
- en: 'If we were building a firewall, we would instead consult the firewall’s rules
    or alert the user before allowing or blocking each flow.  #### Querying the Flow'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们正在构建一个防火墙，我们将查阅防火墙的规则，或者在允许或阻止每个流之前提醒用户。  #### 查询流'
- en: 'By querying the flow, we can extract information such as its remote end-point
    and the process responsible for generating it. First, let’s just print out the
    flow object. For example, here is a flow generated by curl when attempting to
    connect to *objective-see.org*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查询流，我们可以提取诸如其远程端点和负责生成它的进程等信息。首先，让我们打印出流对象。例如，下面是一个由curl生成的流，用于尝试连接到*objective-see.org*：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Besides information about the responsible process, such as its app ID, we can
    see details about the destination, including both an endpoint and a hostname.
    The flow object also contains information about the type of flow, including its
    protocol and socket family.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关于责任进程的信息，比如其应用程序ID外，我们还可以看到关于目标的详细信息，包括端点和主机名。流对象还包含关于流类型的信息，包括其协议和套接字族。
- en: 'Now let’s extract more granular information. Recall that when configuring the
    filter, we told the system we were interested only in filtering sockets. As such,
    the flow passed into the handleNewFlow: method will be an NEFilterSocketFlow object,
    which is a subclass of the NEFilterFlow class. These objects have an instance
    variable called remoteEndpoint containing an object of type NWEndpoint, which
    itself contains information about the flow’s destination. You can extract the
    IP address of the remote endpoint via the NEFilterSocketFlow object’s hostname
    instance variable and retrieve its port from the port variable, both of which
    are stored as strings ([Listing 7-16](chapter7.xhtml#Lis7-16)).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们提取更具体的信息。回想一下，在配置过滤器时，我们告诉系统我们只对过滤套接字感兴趣。因此，传递到`handleNewFlow:`方法的流将是一个NEFilterSocketFlow对象，它是NEFilterFlow类的子类。这些对象有一个名为remoteEndpoint的实例变量，包含一个NWEndpoint类型的对象，该对象本身包含有关流的目标地址的信息。你可以通过NEFilterSocketFlow对象的hostname实例变量提取远程端点的IP地址，并通过port变量检索其端口，这两个变量都以字符串形式存储（[Listing
    7-16](chapter7.xhtml#Lis7-16)）。
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 7-16: Extracting the remote endpoint’s address and port'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-16: 提取远程端点的地址和端口'
- en: These NEFilterSocketFlow objects also contain low-level information about the
    flow, including the socket family, type, and protocol. [Table 7-1](chapter7.xhtml#tab7-1)
    summarizes these, but you can learn more about them in Apple’s *NEFilterFlow.h*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些NEFilterSocketFlow对象还包含有关流的低级信息，包括套接字族、类型和协议。[Table 7-1](chapter7.xhtml#tab7-1)总结了这些信息，但你可以在Apple的*NEFilterFlow.h*中了解更多细节。
- en: 'Table 7-1: Low-Level Flow Information in NEFilterSocketFlow Objects'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'Table 7-1: NEFilterSocketFlow对象中的低级流信息'
- en: '| Variable name | Type | Description |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 变量名 | 类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| socketType | int | Socket type, such as SOCK_STREAM |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| socketType | int | 套接字类型，如SOCK_STREAM |'
- en: '| socketFamily | int | Socket family, such as AF_INET |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| socketFamily | int | 套接字族，如AF_INET |'
- en: '| socketProtocol | int | Socket protocol, such as IPPROTO_TCP |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| socketProtocol | int | 套接字协议，如IPPROTO_TCP |'
- en: From the remoteEndpoint and the socket instance variables, you can extract information
    to be fed into network-based heuristics. For example, you might craft a heuristic
    that flags any network traffic bound to nonstandard ports.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从remoteEndpoint和socket实例变量中，你可以提取信息用于网络基础的启发式分析。例如，你可以设计一个启发式规则，标记所有目标为非标准端口的网络流量。
- en: To identify the responsible process, NEFilterFlow objects have the sourceAppIdentifier
    and sourceAppAuditToken properties. We’ll focus on the latter, as it can provide
    us with both a process ID and process path. [Listing 7-17](chapter7.xhtml#Lis7-17)
    performs this extraction by following the same approach we took in the DNS monitor.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别负责的进程，NEFilterFlow对象有sourceAppIdentifier和sourceAppAuditToken属性。我们将重点关注后者，因为它能提供进程ID和进程路径。[清单7-17](chapter7.xhtml#Lis7-17)通过采用我们在DNS监视器中使用的方法来执行此提取。
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 7-17: Identifying the responsible process from a flow'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 清单7-17：从流中识别负责的进程
- en: We extract the audit token from the flow and then call the audit_token_to_pid
    function to obtain the responsible process’s ID. We also use the audit token to
    obtain a code reference, then call SecCodeCopyPath to retrieve the process’s path.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从流中提取审计令牌，然后调用audit_token_to_pid函数获取负责进程的ID。我们还使用审计令牌获取代码引用，然后调用SecCodeCopyPath来检索进程路径。
- en: Running the Monitor
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行监视器
- en: If we compile this code as part of a project that implements a complete, properly
    entitled network extension, we can globally observe all outbound network flows
    in real time and then extract information about each flow’s remote endpoint and
    responsible process. Yes, this means now we can easily detect basic malware such
    as Dummy, but let’s test the tool against a relevant specimen of macOS malware,
    SentinelSneak.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此代码编译为实现完整、适当授权的网络扩展的一部分，我们可以实时全局观察所有出站网络流量，并提取每个流的远程端点和负责的进程信息。是的，这意味着我们现在可以轻松检测到像Dummy这样的基础恶意软件，但让我们针对一个相关的macOS恶意软件样本——SentinelSneak进行测试。
- en: 'Detected at the end of 2022, this malicious Python package targeted developers
    with the goal of exfiltrating sensitive data.^([14](#chapter7-14)) It used a hardcoded
    IP address for its command-and-control server. From its unobfuscated Python code,
    we can see that curl uploaded information from an infected system to an exfiltration
    server found at 54.254.189.27:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个恶意的Python软件包在2022年底被发现，目标是开发者，目的是窃取敏感数据。^([14](#chapter7-14))它使用了一个硬编码的IP地址作为命令与控制服务器。从它未加混淆的Python代码中，我们可以看到curl将感染系统的信息上传到位于54.254.189.27的外泄服务器：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This means the DNS monitor we wrote earlier in this chapter wouldn’t detect
    its unauthorized network access. But the filter data provider should capture and
    display the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们在本章早些时候编写的DNS监视器无法检测到它的未经授权的网络访问。但过滤器数据提供者应该捕获并显示以下内容：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, it was able to capture the flow, extract the remote endpoint
    (54.254.189.27:443), and correctly identify the responsible process as curl.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它能够捕获流量，提取远程端点（54.254.189.27:443），并正确识别负责的进程为curl。
- en: 'This responsible process makes detection more complex, as curl is a legitimate
    macOS platform binary and not an untrusted component of the malware. What might
    we do? Well, using methods covered in [Chapter 1](chapter1.xhtml), we could extract
    the arguments with which the malware has executed curl:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个负责的进程使得检测变得更加复杂，因为curl是一个合法的macOS平台二进制文件，而不是恶意软件的不可信组件。我们该怎么做呢？好吧，使用[第1章](chapter1.xhtml)中介绍的方法，我们可以提取恶意软件执行curl时使用的参数：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These arguments should raise some red flags, because although legitimate software
    often uses curl to download files, it’s rarely used to upload them, especially
    to a hardcoded IP address. Moreover, the -k argument tells curl to run in insecure
    mode, meaning the server’s SSL certificate won’t be verified. Again, this is a
    red flag, as legitimate software leveraging curl wouldn’t normally run in this
    insecure mode.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数应该引起警惕，因为尽管合法软件通常使用curl下载文件，但它很少用于上传文件，尤其是上传到硬编码的IP地址。此外，-k参数告诉curl以不安全模式运行，这意味着服务器的SSL证书将不会被验证。再次强调，这是一个警告信号，因为合法软件利用curl时通常不会以这种不安全的模式运行。
- en: You could also determine that the process’s parent is a Python script and collect
    the script for manual analysis, which would quickly reveal its malicious nature.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以确定该进程的父进程是一个Python脚本，并收集该脚本进行手动分析，这将很快揭示它的恶意性质。
- en: Conclusion
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: This chapter focused on the concepts necessary for building real-time, host-based
    network monitoring tools by leveraging Apple’s powerful *NetworkExtension* framework.
    Because the vast majority of Mac malware incorporates networking capabilities,
    the techniques described in this chapter are essential for any malware detection
    system. Unauthorized network activity serves as a critical indicator for many
    security tools and heuristic-based detection approaches, providing an invaluable
    way to detect both known and unknown threats targeting macOS.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了通过利用苹果强大的*NetworkExtension*框架来构建实时、基于主机的网络监控工具所需的概念。由于绝大多数Mac恶意软件都包含网络功能，因此本章中描述的技术对于任何恶意软件检测系统都是必不可少的。未经授权的网络活动作为许多安全工具和启发式检测方法的关键指示器，为检测针对macOS的已知和未知威胁提供了宝贵的方式。
- en: Notes
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '[  1](#chapter7_1).  “Smooth Operator,” GCHQ, June 29, 2023, [*https://<wbr>www<wbr>.ncsc<wbr>.gov<wbr>.uk<wbr>/static<wbr>-assets<wbr>/documents<wbr>/malware<wbr>-analysis<wbr>-reports<wbr>/smooth<wbr>-operator<wbr>/NCSC<wbr>_MAR<wbr>-Smooth<wbr>-Operator<wbr>.pdf*](https://www.ncsc.gov.uk/static-assets/documents/malware-analysis-reports/smooth-operator/NCSC_MAR-Smooth-Operator.pdf).'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  1](#chapter7_1).  “Smooth Operator，”GCHQ，2023年6月29日，[*https://<wbr>www<wbr>.ncsc<wbr>.gov<wbr>.uk<wbr>/static<wbr>-assets<wbr>/documents<wbr>/malware<wbr>-analysis<wbr>-reports<wbr>/smooth<wbr>-operator<wbr>/NCSC<wbr>_MAR<wbr>-Smooth<wbr>-Operator<wbr>.pdf*](https://www.ncsc.gov.uk/static-assets/documents/malware-analysis-reports/smooth-operator/NCSC_MAR-Smooth-Operator.pdf).'
- en: '[  2](#chapter7_2).  Patrick Wardle, “Where There Is Love, There Is . . . Malware?”
    Objective-See, February 24, 2023, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x72<wbr>.html*](https://objective-see.org/blog/blog_0x72.html).'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  2](#chapter7_2).  Patrick Wardle，"哪里有爱，哪里就有……恶意软件？" Objective-See，2023年2月24日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x72<wbr>.html*](https://objective-see.org/blog/blog_0x72.html).'
- en: '[  3](#chapter7_3).  “Crowdstrike Endpoint Security Detection re 3CX Desktop
    App,” 3CX forums, March 29, 2023, [*https://<wbr>www<wbr>.3cx<wbr>.com<wbr>/community<wbr>/threads<wbr>/crowdstrike<wbr>-endpoint<wbr>-security<wbr>-detection<wbr>-re<wbr>-3cx<wbr>-desktop<wbr>-app<wbr>.119934<wbr>/*](https://www.3cx.com/community/threads/crowdstrike-endpoint-security-detection-re-3cx-desktop-app.119934/).'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  3](#chapter7_3).  “Crowdstrike Endpoint Security Detection re 3CX桌面应用程序，”3CX论坛，2023年3月29日，[*https://<wbr>www<wbr>.3cx<wbr>.com<wbr>/community<wbr>/threads<wbr>/crowdstrike<wbr>-endpoint<wbr>-security<wbr>-detection<wbr>-re<wbr>-3cx<wbr>-desktop<wbr>-app<wbr>.119934<wbr>/*](https://www.3cx.com/community/threads/crowdstrike-endpoint-security-detection-re-3cx-desktop-app.119934/).'
- en: '[  4](#chapter7_4).  For details on system extensions, see Will Yu, “Mac System
    Extensions for Threat Detection: Part 3,” *Elastic*, February 19, 2020, [*https://<wbr>www<wbr>.elastic<wbr>.co<wbr>/blog<wbr>/mac<wbr>-system<wbr>-extensions<wbr>-for<wbr>-threat<wbr>-detection<wbr>-part<wbr>-3*](https://www.elastic.co/blog/mac-system-extensions-for-threat-detection-part-3).'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  4](#chapter7_4).  有关系统扩展的详细信息，请参见Will Yu的文章，“Mac系统扩展用于威胁检测：第三部分，”*Elastic*，2020年2月19日，[*https://<wbr>www<wbr>.elastic<wbr>.co<wbr>/blog<wbr>/mac<wbr>-system<wbr>-extensions<wbr>-for<wbr>-threat<wbr>-detection<wbr>-part<wbr>-3*](https://www.elastic.co/blog/mac-system-extensions-for-threat-detection-part-3).'
- en: '[  5](#chapter7_5).  “Network Extension,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/networkextension<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/networkextension?language=objc).'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  5](#chapter7_5).  “网络扩展，”苹果开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/networkextension<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/networkextension?language=objc).'
- en: '[  6](#chapter7_6).  “Installing System Extensions and Drivers,” Apple Developer
    Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/systemextensions<wbr>/installing<wbr>-system<wbr>-extensions<wbr>-and<wbr>-drivers<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/systemextensions/installing-system-extensions-and-drivers?language=objc).'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  6](#chapter7_6).  “安装系统扩展和驱动程序，”苹果开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/systemextensions<wbr>/installing<wbr>-system<wbr>-extensions<wbr>-and<wbr>-drivers<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/systemextensions/installing-system-extensions-and-drivers?language=objc).'
- en: '[  7](#chapter7_7).  See also [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/products<wbr>/utilities<wbr>.html#DNSMonitor*](https://objective-see.org/products/utilities.html#DNSMonitor).'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  7](#chapter7_7).  另请参见[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/products<wbr>/utilities<wbr>.html#DNSMonitor*](https://objective-see.org/products/utilities.html#DNSMonitor).'
- en: '[  8](#chapter7_8).  “activationRequestForExtension:queue:,” Apple Developer
    Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/systemextensions<wbr>/ossystemextensionrequest<wbr>/activationrequest(forextensionwithidentifier:queue:)<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/systemextensions/ossystemextensionrequest/activationrequest(forextensionwithidentifier:queue:)?language=objc).'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  8](#chapter7_8).  “activationRequestForExtension:queue:，”Apple开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/systemextensions<wbr>/ossystemextensionrequest<wbr>/activationrequest(forextensionwithidentifier:queue:)<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/systemextensions/ossystemextensionrequest/activationrequest(forextensionwithidentifier:queue:)?language=objc)。'
- en: '[  9](#chapter7_9).  “OSSystemExtensionRequestDelegate,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/systemextensions<wbr>/ossystemextensionrequestdelegate<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/systemextensions/ossystemextensionrequestdelegate?language=objc).'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  9](#chapter7_9).  “OSSystemExtensionRequestDelegate，”Apple开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/systemextensions<wbr>/ossystemextensionrequestdelegate<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/systemextensions/ossystemextensionrequestdelegate?language=objc)。'
- en: '[10](#chapter7_10).  “startSystemExtensionMode,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/networkextension<wbr>/neprovider<wbr>/3197862<wbr>-startsystemextensionmode<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/networkextension/neprovider/3197862-startsystemextensionmode?language=objc).'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[10](#chapter7_10).  “startSystemExtensionMode，”Apple开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/networkextension<wbr>/neprovider<wbr>/3197862<wbr>-startsystemextensionmode<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/networkextension/neprovider/3197862-startsystemextensionmode?language=objc)。'
- en: '[11](#chapter7_11).  “NEDNSProxyProvider,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/networkextension<wbr>/nednsproxyprovider<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/networkextension/nednsproxyprovider?language=objc).'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[11](#chapter7_11).  “NEDNSProxyProvider，”Apple开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/networkextension<wbr>/nednsproxyprovider<wbr>?language<wbr>=objc*](https://developer.apple.com/documentation/networkextension/nednsproxyprovider?language=objc)。'
- en: '[12](#chapter7_12).  Dan Goodin, “Apple Lets Some Big Sur Network Traffic Bypass
    Firewalls,” Arstechnica, November 17, 2020, [*https://<wbr>arstechnica<wbr>.com<wbr>/gadgets<wbr>/2020<wbr>/11<wbr>/apple<wbr>-lets<wbr>-some<wbr>-big<wbr>-sur<wbr>-network<wbr>-traffic<wbr>-bypass<wbr>-firewalls<wbr>/*](https://arstechnica.com/gadgets/2020/11/apple-lets-some-big-sur-network-traffic-bypass-firewalls/).'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[12](#chapter7_12).  Dan Goodin，“Apple允许一些Big Sur网络流量绕过防火墙”，Arstechnica，2020年11月17日，[*https://<wbr>arstechnica<wbr>.com<wbr>/gadgets<wbr>/2020<wbr>/11<wbr>/apple<wbr>-lets<wbr>-some<wbr>-big<wbr>-sur<wbr>-network<wbr>-traffic<wbr>-bypass<wbr>-firewalls<wbr>/*](https://arstechnica.com/gadgets/2020/11/apple-lets-some-big-sur-network-traffic-bypass-firewalls/)。'
- en: '[13](#chapter7_13).  Filipe Espósito, “macOS Big Sur 11.2 beta 2 Removes Filter
    That Lets Apple Apps Bypass Third-Party Firewalls,” 9to5Mac, January 13, 2021,
    [*https://<wbr>9to5mac<wbr>.com<wbr>/2021<wbr>/01<wbr>/13<wbr>/macos<wbr>-big<wbr>-sur<wbr>-11<wbr>-2<wbr>-beta<wbr>-2<wbr>-removes<wbr>-filter<wbr>-that<wbr>-lets<wbr>-apple<wbr>-apps<wbr>-bypass<wbr>-third<wbr>-party<wbr>-firewalls<wbr>/*](https://9to5mac.com/2021/01/13/macos-big-sur-11-2-beta-2-removes-filter-that-lets-apple-apps-bypass-third-party-firewalls/).'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[13](#chapter7_13).  Filipe Espósito，“macOS Big Sur 11.2 beta 2移除允许Apple应用程序绕过第三方防火墙的过滤器”，9to5Mac，2021年1月13日，[*https://<wbr>9to5mac<wbr>.com<wbr>/2021<wbr>/01<wbr>/13<wbr>/macos<wbr>-big<wbr>-sur<wbr>-11<wbr>-2<wbr>-beta<wbr>-2<wbr>-removes<wbr>-filter<wbr>-that<wbr>-lets<wbr>-apple<wbr>-apps<wbr>-bypass<wbr>-third<wbr>-party<wbr>-firewalls<wbr>/*](https://9to5mac.com/2021/01/13/macos-big-sur-11-2-beta-2-removes-filter-that-lets-apple-apps-bypass-third-party-firewalls/)。'
- en: '[14](#chapter7_14).  Patrick Wardle, “The Mac Malware of 2022,” Objective-See,
    January 1, 2023, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x71<wbr>.html*](https://objective-see.org/blog/blog_0x71.html).'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[14](#chapter7_14).  Patrick Wardle，“2022年Mac恶意软件”，Objective-See，2023年1月1日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x71<wbr>.html*](https://objective-see.org/blog/blog_0x71.html)。'
