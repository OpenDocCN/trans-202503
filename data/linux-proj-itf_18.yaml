- en: Chapter 18. Directories and Links
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第18章 目录和链接
- en: In this chapter, we conclude our discussion of file-related topics by looking
    at directories and links. After an overview of their implementation, we describe
    the system calls used to create and remove directories and links. We then look
    at library functions that allow a program to scan the contents of a single directory
    and to walk through (i.e., examine each file in) a directory tree.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过研究目录和链接来结束对文件相关主题的讨论。在概述其实现之后，我们描述用于创建和删除目录及链接的系统调用。接着，我们研究允许程序扫描单个目录内容并遍历（即检查目录树中每个文件）目录树的库函数。
- en: 'Each process has two directory-related attributes: a root directory, which
    determines the point from which absolute pathnames are interpreted, and a current
    working directory, which determines the point from which relative pathnames are
    interpreted. We look at the system calls that allow a process to change both of
    these attributes.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有两个与目录相关的属性：根目录，它决定了绝对路径名的解释起点；当前工作目录，它决定了相对路径名的解释起点。我们将研究允许进程更改这两个属性的系统调用。
- en: We finish the chapter with a discussion of library functions that are used to
    resolve pathnames and to parse them into directory and filename components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结尾将讨论用于解析路径名并将其拆解为目录和文件名组件的库函数。
- en: Directories and (Hard) Links
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录和（硬）链接
- en: 'A *directory* is stored in the file system in a similar way to a regular file.
    Two things distinguish a directory from a regular file:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*目录*在文件系统中的存储方式与常规文件类似。有两点将目录与常规文件区分开：'
- en: A directory is marked with a different file type in its i-node entry ([I-nodes](ch14.html#i-nodes
    "I-nodes")).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录在其i节点条目中标记为不同的文件类型（[I节点](ch14.html#i-nodes "I-nodes")）。
- en: A directory is a file with a special organization. Essentially, it is a table
    consisting of filenames and i-node numbers.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录是具有特殊组织方式的文件。本质上，它是一个由文件名和i节点号组成的表。
- en: On most native Linux file systems, filenames can be up to 255 characters long.
    The relationship between directories and i-nodes is illustrated in [Figure 18-1](ch18.html#relationship_between_i-node_and_director
    "Figure 18-1. Relationship between i-node and directory structures for the file
    /etc/passwd"), which shows the partial contents of the file system i-node table
    and relevant directory files that are maintained for an example file (`/etc/passwd`).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数原生Linux文件系统中，文件名最长可以为255个字符。目录与i节点之间的关系如[图18-1](ch18.html#relationship_between_i-node_and_director
    "图18-1. 文件/etc/passwd的i节点与目录结构关系")所示，图中展示了文件系统i节点表的部分内容以及为示例文件(`/etc/passwd`)维护的相关目录文件。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although a process can open a directory, it can’t use *read()* to read the contents
    of a directory. To retrieve the contents of a directory, a process must instead
    use the system calls and library functions discussed later in this chapter. (On
    some UNIX implementations, it is possible to perform a *read()* on a directory,
    but this is not portable.) Nor can a process directly change a directory’s contents
    with *write()*; it can only indirectly (i.e., request the kernel to) change the
    contents using system calls such as *open()* (to create a new file), *link()*,
    *mkdir()*, *symlink()*, *unlink()*, and *rmdir()*. (All of these system calls
    are described later in this chapter, except *open()*, which was described in Section
    4.3.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一个进程可以打开一个目录，但它不能使用*read()*读取目录的内容。要检索目录内容，进程必须使用本章后面讨论的系统调用和库函数。（在某些UNIX实现中，可以对目录执行*read()*，但这并不具有移植性。）进程也不能直接通过*write()*更改目录的内容；它只能通过系统调用间接（即请求内核）更改内容，如*open()*（创建新文件）、*link()*、*mkdir()*、*symlink()*、*unlink()*和*rmdir()*。（这些系统调用将在本章后面描述，除了*open()*，它在第4.3节中已描述。）
- en: The i-node table is numbered starting at 1, rather than 0, because 0 in the
    i-node field of a directory entry indicates that the entry is unused. I-node 1
    is used to record bad blocks in the file system. The root directory (/) of a file
    system is always stored in i-node entry 2 (as shown in [Figure 18-1](ch18.html#relationship_between_i-node_and_director
    "Figure 18-1. Relationship between i-node and directory structures for the file
    /etc/passwd")), so that the kernel knows where to start when resolving a pathname.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: i 节点表是从 1 开始编号的，而不是从 0 开始，因为目录条目中的 i 节点字段为 0 表示该条目未使用。i 节点 1 用于记录文件系统中的坏块。文件系统的根目录（/）总是存储在
    i 节点条目 2 中（如 [图 18-1](ch18.html#relationship_between_i-node_and_director "Figure
    18-1. Relationship between i-node and directory structures for the file /etc/passwd")
    所示），这样内核就知道从哪里开始解析路径名。
- en: '![Relationship between i-node and directory structures for the file /etc/passwd](figs/web/18-1_DIRS_LINKS-inodes-dirs.png.jpg)Figure 18-1. Relationship
    between i-node and directory structures for the file `/etc/passwd`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![文件 /etc/passwd 的 i 节点与目录结构的关系](figs/web/18-1_DIRS_LINKS-inodes-dirs.png.jpg)图
    18-1. 文件 `/etc/passwd` 的 i 节点与目录结构的关系'
- en: 'If we review the list of information stored in a file i-node ([I-nodes](ch14.html#i-nodes
    "I-nodes")), we see that the i-node doesn’t contain a filename; it is only the
    mapping within a directory list that defines the name of a file. This has a useful
    consequence: we can create multiple names—in the same or in different directories—each
    of which refers to the same i-node. These multiple names are known as *links*,
    or sometimes as *hard links* to distinguish them from symbolic links, which we
    discuss shortly.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾存储在文件 i 节点中的信息列表（[I 节点](ch14.html#i-nodes "I-nodes")），会发现 i 节点不包含文件名；文件名仅在目录列表中的映射定义了文件的名称。这有一个有用的结果：我们可以在同一目录或不同目录中创建多个名称，每个名称都指向相同的
    i 节点。这些多个名称被称为 *链接*，有时为了与符号链接区分开来，也称为 *硬链接*，后者将在稍后讨论。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All native Linux and UNIX file systems support hard links. However, many non-UNIX
    file systems (e.g., Microsoft’s VFAT) do not. (Microsoft’s NTFS file system does
    support hard links.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有本地 Linux 和 UNIX 文件系统都支持硬链接。然而，许多非 UNIX 文件系统（例如，微软的 VFAT）不支持硬链接。（微软的 NTFS 文件系统支持硬链接。）
- en: 'From the shell, we can create new hard links to an existing file using the
    *ln* command, as shown in the following shell session log:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 shell 中，我们可以使用 *ln* 命令为现有文件创建新的硬链接，如以下 shell 会话日志所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The i-node numbers displayed (as the first column) by *ls -li* confirm what
    was already clear from the output of the *cat* command: the names `abc` and `xyz`
    refer to the same i-node entry, and hence to the same file. In the third field
    displayed by *ls -li*, we can see the link count for the i-node. After the *ln
    abc xyz* command, the link count of the i-node referred to by `abc` has risen
    to 2, since there are now two names referring to the file. (The same link count
    is displayed for the file `xyz`, since it refers to the same i-node.)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*ls -li* 命令显示的 i 节点号（作为第一列）确认了从 *cat* 命令输出中已经明确的内容：`abc` 和 `xyz` 指向相同的 i 节点条目，因此指向相同的文件。在
    *ls -li* 命令显示的第三列中，我们可以看到该 i 节点的链接计数。在执行 *ln abc xyz* 命令后，`abc` 所指向的 i 节点的链接计数增加到了
    2，因为现在有两个名称指向同一个文件。（对于文件 `xyz` 显示相同的链接计数，因为它指向相同的 i 节点。）'
- en: 'If one of these filenames is removed, the other name, and the file itself,
    continue to exist:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个文件名被删除，另一个文件名和文件本身仍然存在：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The i-node entry and data blocks for the file are removed (deallocated) only
    when the i-node’s link count falls to 0—that is, when all of the names for the
    file have been removed. To summarize: the *rm* command removes a filename from
    a directory list, decrements the link count of the corresponding i-node by 1,
    and, if the link count thereby falls to 0, deallocates the i-node and the data
    blocks to which it refers.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的 i 节点条目和数据块仅在 i 节点的链接计数降到 0 时被删除（释放），即当文件的所有名称都被删除时。总结一下：*rm* 命令从目录列表中删除一个文件名，减少对应
    i 节点的链接计数 1，并且如果链接计数因此降到 0，则释放该 i 节点及其指向的数据块。
- en: All of the names (links) for a file are equivalent—none of the names (e.g.,
    the first) has priority over any of the others. As we saw in the above example,
    after the first name associated with the file was removed, the physical file continued
    to exist, but it was then accessible only by the other name.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的所有名称（链接）是等价的——没有任何名称（例如，第一个）优先于其他名称。正如我们在上面的例子中看到的那样，在文件的第一个名称被删除后，物理文件仍然存在，但它现在只能通过其他名称访问。
- en: 'A question often asked in online forums is “How can I find the filename associated
    with the file descriptor X in my program?” The short answer is that we can’t—
    at least not portably and unambiguously—since a file descriptor refers to an i-node,
    and multiple filenames (or even, as described in [Creating and Removing (Hard)
    Links: *link*() and *unlink*()](ch18.html#creating_and_removing_open_parenthesis_h
    "Creating and Removing (Hard) Links: link() and unlink()"), none at all) may refer
    to this i-node.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在线论坛中经常有人提问：“如何找到与程序中的文件描述符 X 关联的文件名？”简短的回答是我们无法做到——至少不能以可移植和明确的方式做到——因为文件描述符指向的是一个
    i-node，而多个文件名（甚至如在[创建和删除（硬）链接：*link*()和*unlink*()](ch18.html#creating_and_removing_open_parenthesis_h
    "创建和删除（硬）链接：link()和unlink()")中描述的那样，甚至没有文件名）可能指向这个 i-node。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'On Linux, we can see which files a process currently has open by using *readdir()*
    ([Reading Directories: *opendir()* and *readdir()*](ch18.html#reading_directories_colon_opendir_open_p
    "Reading Directories: opendir() and readdir()")) to scan the contents of the Linux-specific
    `/proc/`*PID*`/fd` directory, which contains symbolic links for each of the file
    descriptors currently opened by the process. The *lsof(1)* and *fuser(1)* tools,
    which have been ported to many UNIX systems, can also be useful in this regard.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，我们可以通过使用*readdir()*（[读取目录：*opendir()*和*readdir()*](ch18.html#reading_directories_colon_opendir_open_p
    "读取目录：opendir()和readdir()")）扫描 Linux 特有的`/proc/`*PID*`/fd`目录的内容，来查看当前进程打开了哪些文件，该目录包含了进程当前打开的每个文件描述符的符号链接。*lsof(1)*和*fuser(1)*工具也已移植到许多
    UNIX 系统上，在这方面也非常有用。
- en: 'Hard links have two limitations, both of which can be circumvented by the use
    of symbolic links:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 硬链接有两个限制，而这两个限制都可以通过使用符号链接来绕过：
- en: Because directory entries (hard links) refer to files using just an i-node number,
    and i-node numbers are unique only within a file system, a hard link must reside
    on the same file system as the file to which it refers.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于目录条目（硬链接）是通过仅使用 i-node 编号来引用文件的，而 i-node 编号仅在文件系统内是唯一的，因此硬链接必须与它所指向的文件位于同一文件系统中。
- en: A hard link can’t be made to a directory. This prevents the creation of circular
    links, which would confuse many system programs.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬链接不能创建到目录上。这是为了防止创建循环链接，这种链接会混淆许多系统程序。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Early UNIX implementations permitted the superuser to create hard links to directories.
    This was necessary because these implementations did not provide a *mkdir()* system
    call. Instead, a directory was created using *mknod()*, and then links for the
    `.` and `..` entries were created ([Vahalia, 1996]). Although this feature is
    no longer needed, some modern UNIX implementations retain it for backward compatibility.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的 UNIX 实现允许超级用户创建指向目录的硬链接。这是必要的，因为这些实现没有提供*mkdir()*系统调用。相反，目录是通过*mknod()*创建的，然后为`.`和`..`条目创建了链接（[Vahalia,
    1996]）。虽然这个特性现在不再需要，但一些现代 UNIX 实现保留了它以保持向后兼容。
- en: An effect similar to hard links on directories can be achieved using bind mounts
    ([Bind Mounts](ch14.html#bind_mounts "Bind Mounts")).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绑定挂载（[绑定挂载](ch14.html#bind_mounts "绑定挂载")）可以实现类似于硬链接对目录的效果。
- en: Symbolic (Soft) Links
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号（软）链接
- en: A *symbolic link*, also sometimes called a *soft link*, is a special file type
    whose data is the name of another file. [Figure 18-2](ch18.html#representation_of_hard_and_symbolic_link
    "Figure 18-2. Representation of hard and symbolic links") illustrates the situation
    where two hard links, `/home/erena/this` and `/home/allyn/that`, refer to the
    same file, and a symbolic link, /`home/kiran/other`, refers to the name `/home/erena/this`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号链接*，有时也叫做*软链接*，是一种特殊的文件类型，其数据是另一个文件的名称。[图 18-2](ch18.html#representation_of_hard_and_symbolic_link
    "图 18-2. 硬链接和符号链接的表示")展示了两个硬链接，`/home/erena/this`和`/home/allyn/that`，它们指向同一个文件，而一个符号链接`/home/kiran/other`则指向名称`/home/erena/this`。'
- en: From the shell, symbolic links are created using the *ln -s* command. The *ls
    -F* command displays a trailing `@` character at the end of symbolic links.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从 shell 中，可以使用*ln -s*命令创建符号链接。*ls -F*命令会在符号链接的末尾显示一个`@`字符。
- en: The pathname to which a symbolic link refers may be either absolute or relative.
    A relative symbolic link is interpreted relative to the location of the link itself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接所指向的路径可以是绝对路径，也可以是相对路径。相对符号链接是相对于链接本身的位置进行解释的。
- en: Symbolic links don’t have the same status as hard links. In particular, a symbolic
    link is not included in the link count of the file to which it refers. (Thus,
    the link count of i-node 61 in [Figure 18-2](ch18.html#representation_of_hard_and_symbolic_link
    "Figure 18-2. Representation of hard and symbolic links") is 2, not 3.) Therefore,
    if the filename to which the symbolic link refers is removed, the symbolic link
    itself continues to exist, even though it can no longer be dereferenced (followed).
    We say that it has become a *dangling link*. It is even possible to create a symbolic
    link to a filename that doesn’t exist at the time the link is created.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接不像硬链接那样具有相同的地位。特别是，符号链接不包括在它所指向的文件的链接计数中。（因此，[图18-2](ch18.html#representation_of_hard_and_symbolic_link
    "图18-2. 硬链接和符号链接的表示")中i节点61的链接计数为2，而不是3。）因此，如果符号链接所指向的文件名被删除，符号链接本身仍然存在，尽管它不能再被解引用（跟随）。我们称其为*悬空链接*。甚至可以创建指向在创建时不存在的文件名的符号链接。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Symbolic links were introduced by 4.2BSD. Although they were not included in
    POSIX.1-1990, they were subsequently incorporated into SUSv1, and thus are in
    SUSv3.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接是由4.2BSD引入的。尽管它们没有包含在POSIX.1-1990中，但随后被纳入SUSv1，并因此出现在SUSv3中。
- en: '![Representation of hard and symbolic links](figs/web/18-2_DIRS_LINKS-links.png.jpg)Figure 18-2. Representation
    of hard and symbolic links'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![硬链接和符号链接的表示](figs/web/18-2_DIRS_LINKS-links.png.jpg)图18-2. 硬链接和符号链接的表示'
- en: 'Since a symbolic link refers to a filename, rather than an i-node number, it
    can be used to link to a file in a different file system. Symbolic links also
    do not suffer the other limitation of hard links: we can create symbolic links
    to directories. Tools such as *find* and *tar* can tell the difference between
    hard and symbolic links, and either don’t follow symbolic links by default, or
    avoid getting trapped in circular references created using symbolic links.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于符号链接是指向文件名，而不是i节点编号，因此可以用来链接到不同文件系统中的文件。符号链接也没有硬链接的其他限制：我们可以创建指向目录的符号链接。像*find*和*tar*这样的工具能够区分硬链接和符号链接，它们通常不会跟随符号链接，或者避免陷入由符号链接创建的循环引用。
- en: It is possible to chain symbolic links (e.g., `a` is a symbolic link to `b`,
    which is a symbolic link to `c`). When a symbolic link is specified in various
    file-related system calls, the kernel dereferences the series of links to arrive
    at the final file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可以链接符号链接（例如，`a`是指向`b`的符号链接，`b`是指向`c`的符号链接）。当在各种与文件相关的系统调用中指定符号链接时，内核会解引用这系列链接，以最终访问目标文件。
- en: SUSv3 requires that an implementation allow at least `_POSIX_SYMLOOP_MAX` dereferences
    of each symbolic link component of a pathname. The specified value for `_POSIX_SYMLOOP_MAX`
    is 8\. However, before kernel 2.6.18, Linux imposed a limit of 5 dereferences
    when following a chain of symbolic links. Starting with kernel 2.6.18, Linux implements
    the SUSv3-specified minimum of 8 dereferences. Linux also imposes a total of 40
    dereferences for an entire pathname. These limits are required to prevent extremely
    long symbolic link chains, as well as symbolic link loops, from causing stack
    overflows in the kernel code that resolves symbolic links.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3要求实现至少允许对路径名中的每个符号链接组件进行`_POSIX_SYMLOOP_MAX`次解引用。指定的`_POSIX_SYMLOOP_MAX`值为8。然而，在内核版本2.6.18之前，Linux在跟随符号链接链时，限制了解引用次数为5次。从内核版本2.6.18开始，Linux实现了SUSv3指定的最小值8次解引用。Linux还对整个路径名的解引用总数施加了40次限制。这些限制是为了防止极长的符号链接链和符号链接环路导致内核代码中的栈溢出问题，内核代码负责解析符号链接。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some UNIX file systems perform an optimization not mentioned in the main text
    nor shown in [Figure 18-2](ch18.html#representation_of_hard_and_symbolic_link
    "Figure 18-2. Representation of hard and symbolic links"). When the total length
    of the string forming the symbolic link’s contents is small enough to fit in the
    part of the i-node that would normally be used for data pointers, the link string
    is instead stored there. This saves allocating a disk block and also speeds access
    to the symbolic link information, since it is retrieved along with the file i-node.
    For example, *ext2*, *ext3*, and *ext4* employ this technique to fit short symbolic
    strings into the 60 bytes normally used for data block pointers. In practice,
    this can be a very effective optimization. Of the 20,700 symbolic links on one
    system checked by the author, 97% were 60 bytes or smaller.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些UNIX文件系统执行了一项优化，主文中未提及，且未在[图18-2](ch18.html#representation_of_hard_and_symbolic_link
    "图18-2. 硬链接和符号链接的表示")中显示。当构成符号链接内容的字符串总长度足够小，能够适应通常用于数据指针的i节点部分时，该链接字符串会直接存储在那里。这样可以避免分配一个磁盘块，并且加速符号链接信息的访问，因为它与文件的i节点一起被检索。例如，*ext2*、*ext3*和*ext4*采用这种技术，将短符号链接字符串存储在通常用于数据块指针的60个字节内。实际上，这是一项非常有效的优化。在作者检查的一个系统中的20,700个符号链接中，97%的链接大小都在60字节以内。
- en: Interpretation of symbolic links by system calls
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 系统调用对符号链接的解释
- en: Many system calls dereference (follow) symbolic links and thus work on the file
    to which the link refers. Some system calls don’t dereference symbolic links,
    but instead operate directly on the link file itself. As each system call is covered,
    we describe its behavior with respect to symbolic links. This behavior is also
    summarized in [Table 18-1](ch18.html#interpretation_of_symbolic_links_by_vari
    "Table 18-1. Interpretation of symbolic links by various functions").
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统调用会解引用（跟随）符号链接，因此它们作用于链接所指向的文件。一些系统调用则不会解引用符号链接，而是直接作用于链接文件本身。在每个系统调用的介绍中，我们都会描述它在符号链接方面的行为。该行为也在[表18-1](ch18.html#interpretation_of_symbolic_links_by_vari
    "表18-1. 不同函数对符号链接的解释")中进行了总结。
- en: 'In a few cases where it is necessary to have similar functionality for both
    the file to which a symbolic link refers and for the symbolic link itself, alternative
    system calls are provided: one that dereferences the link and another that does
    not, with the latter prefixed by the letter *l*; for example, *stat()* and *lstat()*.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在少数情况下，当需要对符号链接所指向的文件和符号链接本身执行类似操作时，提供了替代系统调用：一个会解引用链接，另一个不会，后者以字母*l*为前缀；例如，*stat()*和*lstat()*。
- en: 'One point generally applies: symbolic links in the directory part of a pathname
    (i.e., all of the components preceding the final slash) are always dereferenced.
    Thus, in the pathname `/somedir/somesubdir/file`, `somedir` and `somesubdir` will
    always be dereferenced if they are symbolic links, and `file` may be dereferenced,
    depending on the system call to which the pathname is passed.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，有一点适用：路径名中目录部分的符号链接（即，所有位于最后一个斜杠前的组件）总是会被解引用。因此，在路径名`/somedir/somesubdir/file`中，如果`somedir`和`somesubdir`是符号链接，它们将始终被解引用，而`file`则可能会被解引用，具体取决于传递路径名的系统调用。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Operating Relative to a Directory File Descriptor](ch18.html#operating_relative_to_a_directory_file_d
    "Operating Relative to a Directory File Descriptor"), we describe a set of system
    calls, added in Linux 2.6.16, that extend the functionality of some of the interfaces
    shown in [Table 18-1](ch18.html#interpretation_of_symbolic_links_by_vari "Table 18-1. Interpretation
    of symbolic links by various functions"). For some of these system calls, the
    behavior with respect to following symbolic links can be controlled by the *flags*
    argument to the call.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在[相对于目录文件描述符的操作](ch18.html#operating_relative_to_a_directory_file_d "相对于目录文件描述符的操作")中，我们描述了一组在Linux
    2.6.16中新增的系统调用，它们扩展了[表18-1](ch18.html#interpretation_of_symbolic_links_by_vari
    "表18-1. 不同函数对符号链接的解释")中所示的一些接口的功能。对于这些系统调用中的某些，跟随符号链接的行为可以通过调用中的*flags*参数进行控制。
- en: File permissions and ownership for symbolic links
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 符号链接的文件权限和所有权
- en: The ownership and permissions of a symbolic link are ignored for most operations
    (symbolic links are always created with all permissions enabled). Instead, the
    ownership and permissions of the file to which the link refers are used in determining
    whether an operation is permitted. The ownership of a symbolic link is relevant
    only when the link itself is being removed or renamed in a directory with the
    sticky permission bit set ([Set-User-ID, Set-Group-ID, and Sticky Bits](ch15.html#set-user-id_comma_set-group-id_comma_and
    "Set-User-ID, Set-Group-ID, and Sticky Bits")).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接的所有权和权限对于大多数操作都被忽略（符号链接始终创建时会启用所有权限）。相反，链接所指向的文件的所有权和权限会在确定操作是否允许时起作用。符号链接的所有权只有在链接本身在具有粘性权限位的目录中被移除或重命名时才相关（[用户标识符、组标识符和粘性位](ch15.html#set-user-id_comma_set-group-id_comma_and
    "用户标识符、组标识符和粘性位")）。
- en: 'Creating and Removing (Hard) Links: *link*() and *unlink*()'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和移除（硬）链接：*link*()和*unlink*()
- en: The *link()* and *unlink()* system calls create and remove hard links.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*link()*和*unlink()*系统调用创建和移除硬链接。'
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: Table 18-1. Interpretation of symbolic links by various functions
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表18-1。 各种函数对符号链接的解释
- en: '| Function | Follows links? | Notes |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 是否跟随链接？ | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *access()* | • |   |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| *access()* | • |   |'
- en: '| *acct()* | • |   |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| *acct()* | • |   |'
- en: '| *bind()* | • | UNIX domain sockets have pathnames |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| *bind()* | • | UNIX 域套接字具有路径名 |'
- en: '| *chdir()* | • |   |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| *chdir()* | • |   |'
- en: '| *chmod()* | • |   |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| *chmod()* | • |   |'
- en: '| *chown()* | • |   |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| *chown()* | • |   |'
- en: '| *chroot()* | • |   |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| *chroot()* | • |   |'
- en: '| *creat()* | • |   |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| *creat()* | • |   |'
- en: '| *exec()* | • |   |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| *exec()* | • |   |'
- en: '| *getxattr()* | • |   |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| *getxattr()* | • |   |'
- en: '| *lchown()* |   |   |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| *lchown()* |   |   |'
- en: '| *lgetxattr()* |   |   |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| *lgetxattr()* |   |   |'
- en: '| *link()* |   | See [Creating and Removing (Hard) Links: *link*() and *unlink*()](ch18.html#creating_and_removing_open_parenthesis_h
    "Creating and Removing (Hard) Links: link() and unlink()") |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| *link()* |   | 见[创建和移除（硬）链接：*link*()和*unlink*()](ch18.html#creating_and_removing_open_parenthesis_h
    "创建和移除（硬）链接：link()和unlink()") |'
- en: '| *listxattr()* | • |   |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| *listxattr()* | • |   |'
- en: '| *llistxattr()* |   |   |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| *llistxattr()* |   |   |'
- en: '| *lremovexattr()* |   |   |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| *lremovexattr()* |   |   |'
- en: '| *lsetxattr()* |   |   |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| *lsetxattr()* |   |   |'
- en: '| *lstat()* |   |   |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| *lstat()* |   |   |'
- en: '| *lutimes()* |   |   |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| *lutimes()* |   |   |'
- en: '| *open()* | • | Unless O_NOFOLLOW or O_EXCL &#124; O_CREAT specified |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| *open()* | • | 除非指定了O_NOFOLLOW或O_EXCL &#124; O_CREAT |'
- en: '| *opendir()* | • |   |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| *opendir()* | • |   |'
- en: '| *pathconf()* | • |   |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| *pathconf()* | • |   |'
- en: '| *pivot_root()* | • |   |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| *pivot_root()* | • |   |'
- en: '| *quotactl()* | • |   |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| *quotactl()* | • |   |'
- en: '| *readlink()* |   |   |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| *readlink()* |   |   |'
- en: '| *removexattr()* | • |   |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| *removexattr()* | • |   |'
- en: '| *rename()* |   | Links are not followed in either argument |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| *rename()* |   | 链接在任一参数中都不会被跟随 |'
- en: '| *rmdir()* |   | Fails with ENOTDIR if argument is a symbolic link |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| *rmdir()* |   | 如果参数是符号链接，则会失败并返回ENOTDIR |'
- en: '| *setxattr()* | • |   |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| *setxattr()* | • |   |'
- en: '| *stat()* | • |   |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| *stat()* | • |   |'
- en: '| *statfs(), statvfs()* | • |   |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| *statfs(), statvfs()* | • |   |'
- en: '| *swapon(), swapoff()* | • |   |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| *swapon(), swapoff()* | • |   |'
- en: '| *truncate()* | • |   |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| *truncate()* | • |   |'
- en: '| *unlink()* |   |   |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| *unlink()* |   |   |'
- en: '| *uselib()* | • |   |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| *uselib()* | • |   |'
- en: '| *utime(), utimes()* | • |   |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| *utime(), utimes()* | • |   |'
- en: Given the pathname of an existing file in *oldpath*, the *link()* system call
    creates a new link, using the pathname specified in *newpath*. If *newpath* already
    exists, it is not overwritten; instead, an error (`EEXIST`) results.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 给定*oldpath*中的现有文件路径名，*link()*系统调用会使用*newpath*中指定的路径名创建一个新链接。如果*newpath*已经存在，则不会被覆盖；而是会返回一个错误（`EEXIST`）。
- en: On Linux, the *link()* system call doesn’t dereference symbolic links. If *oldpath*
    is a symbolic link, then *newpath* is created as a new hard link to the same symbolic
    link file. (In other words, *newpath* is also a symbolic link to the same file
    to which *oldpath* refers.) This behavior doesn’t conform to SUSv3, which says
    that all functions that perform pathname resolution should dereference symbolic
    links unless otherwise specified (and there is no exception specified for *link()*).
    Most other UNIX implementations behave in the manner specified by SUSv3\. One
    notable exception is Solaris, which provides the same behavior as Linux by default,
    but provides SUSv3-conformant behavior if appropriate compiler options are used.
    The upshot of this inconsistency across implementations is that portable applications
    should avoid specifying a symbolic link for the *oldpath* argument.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，*link()* 系统调用不会解引用符号链接。如果 *oldpath* 是符号链接，则 *newpath* 会作为指向相同符号链接文件的新硬链接创建。（换句话说，*newpath*
    也是指向与 *oldpath* 相同文件的符号链接。）这种行为不符合 SUSv3，后者规定所有执行路径名解析的函数应该解引用符号链接，除非另有说明（并且没有为
    *link()* 指定任何例外）。大多数其他 UNIX 实现遵循 SUSv3 规定的行为。一个显著的例外是 Solaris，它默认提供与 Linux 相同的行为，但如果使用适当的编译器选项，则可以提供符合
    SUSv3 的行为。这种实现之间的不一致的结果是，便携式应用程序应避免为 *oldpath* 参数指定符号链接。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv4 recognizes the inconsistency across existing implementations and specifies
    that the choice of whether or not *link()* dereferences symbolic links is implementation-defined.
    SUSv4 also adds the specification of *linkat()*, which performs the same task
    as *link()*, but has a *flags* argument that can be used to control whether the
    call dereferences symbolic links. See [Operating Relative to a Directory File
    Descriptor](ch18.html#operating_relative_to_a_directory_file_d "Operating Relative
    to a Directory File Descriptor") for further details.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv4 认识到现有实现之间的不一致，并规定是否 *link()* 解引用符号链接的选择由实现定义。SUSv4 还新增了 *linkat()* 的规范，它执行与
    *link()* 相同的任务，但具有一个 *flags* 参数，可以用来控制调用是否解引用符号链接。有关更多细节，请参见 [相对于目录文件描述符的操作](ch18.html#operating_relative_to_a_directory_file_d
    "相对于目录文件描述符的操作")。
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1。
- en: The *unlink()* system call removes a link (deletes a filename) and, if that
    is the last link to the file, also removes the file itself. If the link specified
    in *pathname* doesn’t exist, then *unlink()* fails with the error `ENOENT`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*unlink()* 系统调用删除一个链接（删除文件名），并且如果这是指向该文件的最后一个链接，它也会删除该文件本身。如果 *pathname* 中指定的链接不存在，则
    *unlink()* 会因错误 `ENOENT` 而失败。'
- en: We can’t use *unlink()* to remove a directory; that task requires *rmdir()*
    or *remove()*, which we look at in Section 18.6.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用 *unlink()* 删除目录；这个任务需要 *rmdir()* 或 *remove()*，我们将在第 18.6 节中讨论它们。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 says that if *pathname* specifies a directory, then *unlink()* should
    fail with the error `EPERM`. However, on Linux, *unlink()* fails with the error
    `EISDIR` in this case. (LSB explicitly permits this deviation from SUSv3.) A portable
    application should be prepared to handle either value if checking for this case.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 规定，如果 *pathname* 指定的是一个目录，那么 *unlink()* 应该因错误 `EPERM` 而失败。然而，在 Linux 中，在这种情况下，*unlink()*
    会因错误 `EISDIR` 而失败。（LSB 明确允许这种偏离 SUSv3 的行为。）便携式应用程序应该准备好处理此情况的任何一个错误值。
- en: The *unlink()* system call doesn’t dereference symbolic links. If *pathname*
    is a symbolic link, the link itself is removed, rather than the name to which
    it points.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*unlink()* 系统调用不会解引用符号链接。如果 *pathname* 是符号链接，则会删除该链接本身，而不是它指向的名称。'
- en: An open file is deleted only when all file descriptors are closed
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 只有当所有文件描述符都被关闭时，打开的文件才会被删除。
- en: In addition to maintaining a link count for each i-node, the kernel also counts
    open file descriptions for the file (see [Figure 5-2](ch05.html#relationship_between_file_descriptors_co
    "Figure 5-2. Relationship between file descriptors, open file descriptions, and
    i-nodes"), in [Duplicating File Descriptors](ch05.html#duplicating_file_descriptors
    "Duplicating File Descriptors")). If the last link to a file is removed and any
    processes hold open descriptors referring to the file, the file won’t actually
    be deleted until all of the descriptors are closed. This is a useful feature,
    because it permits us to unlink a file without needing to worry about whether
    some other process has it open. (However, we can’t reattach a name to an open
    file whose link count has fallen to 0.) In addition, we can perform tricks such
    as creating and opening a temporary file, unlinking it immediately, and then continuing
    to use it within our program, relying on the fact that the file is destroyed only
    when we close the file descriptor—either explicitly, or implicitly when the program
    exits. (This is what the *tmpfile()* function described in [Creating Temporary
    Files](ch05.html#creating_temporary_files "Creating Temporary Files") does.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为每个 i-node 维护链接计数外，内核还会统计文件的打开文件描述符（参见[图 5-2](ch05.html#relationship_between_file_descriptors_co
    "图 5-2. 文件描述符、打开文件描述符和 i-nodes 之间的关系")，以及[复制文件描述符](ch05.html#duplicating_file_descriptors
    "复制文件描述符")）。如果删除了文件的最后一个链接，而任何进程仍持有指向该文件的打开描述符，则文件在所有描述符关闭之前不会真正被删除。这是一个有用的特性，因为它允许我们在不需要担心其他进程是否打开该文件的情况下删除文件。（但是，我们不能将一个链接计数已降至
    0 的打开文件重新附加到一个文件名。）此外，我们可以执行一些技巧，比如创建并打开一个临时文件，立即删除它，然后在程序中继续使用它，依赖于文件只有在我们关闭文件描述符时才会被销毁——无论是显式地，还是在程序退出时隐式地关闭。（这就是[创建临时文件](ch05.html#creating_temporary_files
    "创建临时文件")中描述的 *tmpfile()* 函数所做的。）
- en: The program in [Example 18-1](ch18.html#removing_a_link_with_unlink_open_parenth
    "Example 18-1. Removing a link with unlink()") demonstrates that even when the
    last link to a file is removed, the file is deleted only when all open file descriptors
    that refer to it are closed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-1](ch18.html#removing_a_link_with_unlink_open_parenth "示例 18-1. 使用 unlink()
    删除链接")中的程序演示了即使删除了文件的最后一个链接，文件也只有在所有指向它的打开文件描述符关闭时才会被删除。'
- en: Example 18-1. Removing a link with *unlink()*
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 18-1. 使用 *unlink()* 删除链接
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The program in [Example 18-1](ch18.html#removing_a_link_with_unlink_open_parenth
    "Example 18-1. Removing a link with unlink()") accepts two command-line arguments.
    The first argument identifies the name of a file that the program should create.
    The program opens this file and then immediately unlinks the filename. Although
    the filename disappears, the file itself continues to exist. The program then
    writes random blocks of data to the file. The number of these blocks is specified
    in the optional second command-line argument of the program. At this point, the
    program employs the *df(1)* command to display the amount of space used on the
    file system. The program then closes the file descriptor, at which the point the
    file is removed, and uses *df(1)* once more to show that the amount of disk space
    in use has decreased. The following shell session demonstrates the use of the
    program in [Example 18-1](ch18.html#removing_a_link_with_unlink_open_parenth "Example 18-1. Removing
    a link with unlink()"):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-1](ch18.html#removing_a_link_with_unlink_open_parenth "示例 18-1. 使用 unlink()
    删除链接")中的程序接受两个命令行参数。第一个参数指定程序应该创建的文件名。程序打开此文件后立即删除该文件名。虽然文件名消失了，但文件本身仍然存在。程序接着向文件写入随机数据块。这些数据块的数量由程序的可选第二个命令行参数指定。此时，程序使用
    *df(1)* 命令显示文件系统上已使用的空间。程序随后关闭文件描述符，此时文件被删除，并再次使用 *df(1)* 显示已使用的磁盘空间减少。以下的 shell
    会话演示了[示例 18-1](ch18.html#removing_a_link_with_unlink_open_parenth "示例 18-1. 使用
    unlink() 删除链接")中程序的使用：'
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Example 18-1](ch18.html#removing_a_link_with_unlink_open_parenth "Example 18-1. Removing
    a link with unlink()"), we use the *system()* function to execute a shell command.
    We describe *system()* in detail in Section 27.6.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 18-1](ch18.html#removing_a_link_with_unlink_open_parenth "示例 18-1. 使用 unlink()
    删除链接")中，我们使用 *system()* 函数执行一个 shell 命令。我们在第 27.6 节中详细描述了 *system()*。
- en: 'Changing the Name of a File: *rename()*'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改文件名：*rename()*
- en: The *rename()* system call can be used both to rename a file and to move it
    into another directory on the same file system.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*rename()* 系统调用既可以用来重命名文件，也可以将文件移动到同一文件系统的其他目录中。'
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，错误时返回 -1
- en: The *oldpath* argument is an existing pathname, which is renamed to the pathname
    given in *newpath*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*oldpath*参数是一个现有路径名，它被重命名为*newpath*中给定的路径名。'
- en: The *rename()* call just manipulates directory entries; it doesn’t move file
    data. Renaming a file doesn’t affect other hard links to the file, nor does it
    affect any processes that hold open descriptors for the file, since these descriptors
    refer to open file descriptions, which (after the *open()* call) have no connection
    with filenames.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*rename()*调用仅操作目录条目；它不会移动文件数据。重命名文件不会影响其他硬链接，也不会影响任何已打开文件描述符的进程，因为这些描述符指向的是打开文件描述，它们（在*open()*调用之后）与文件名没有关联。'
- en: 'The following rules apply to the use of *rename()*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*rename()*时适用以下规则：
- en: If *newpath* already exists, it is overwritten.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*newpath*已经存在，则会被覆盖。
- en: If *newpath* and *oldpath* refer to the same file, then no changes are made
    (and the call succeeds). This is rather counterintuitive. Following from the previous
    point, we normally expect that if two filenames `x` and `y` exist, then the call
    *rename* (“x”, “y”) would remove the name `x`. This is not the case if `x` and
    `y` are links to the same file.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*newpath*和*oldpath*指向同一个文件，则不会进行任何更改（且调用成功）。这一点有点反直觉。根据前一点，我们通常期望如果两个文件名`x`和`y`存在，那么*rename*（“x”，“y”）调用会删除`x`。但如果`x`和`y`是指向同一文件的链接，情况则不同。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The rationale for this rule, which comes from the original BSD implementation,
    was probably to simplify the checks that the kernel must perform in order to guarantee
    that calls such as *rename(“x”, “x”)*, *rename(“x”, “./x”)*, and *rename(“x”,
    “somedir/../x”)* don’t remove the file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这一规则的理由来自最初的BSD实现，可能是为了简化内核必须执行的检查，以保证像*rename(“x”, “x”)*、*rename(“x”, “./x”)*和*rename(“x”,
    “somedir/../x”)*这样的调用不会删除文件。
- en: The *rename()* system call doesn’t dereference symbolic links in either of its
    arguments. If *oldpath* is a symbolic link, then the symbolic link is renamed.
    If *newpath* is a symbolic link, then it is treated as a normal pathname to which
    *oldpath* is to be renamed (i.e., the existing *newpath* symbolic link is removed).
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*rename()*系统调用不会取消引用其任何参数中的符号链接。如果*oldpath*是符号链接，则重命名的是符号链接。如果*newpath*是符号链接，则它被视为一个普通的路径名，将*oldpath*重命名为该路径名（即，现有的*newpath*符号链接会被删除）。'
- en: 'If *oldpath* refers to a file other than a directory, then *newpath* can’t
    specify the pathname of a directory (the error is `EISDIR`). To rename a file
    to a location inside a directory (i.e., move the file to another directory), *newpath*
    must include the new filename. The following call both moves a file into a different
    directory and changes its name:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*oldpath*指向的是一个非目录文件，则*newpath*不能指定目录路径名（错误为`EISDIR`）。要将文件重命名为目录中的位置（即，将文件移到另一个目录），*newpath*必须包含新的文件名。以下调用会将文件移到不同的目录并更改其名称：
- en: '[PRE7]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Specifying the name of a directory in *oldpath* allows us to rename that directory.
    In this case, *newpath* either must not exist or must be the name of an empty
    directory. If *newpath* is an existing file or an existing, nonempty directory,
    then an error results (respectively, `ENOTDIR` and `ENOTEMPTY`).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*oldpath*中指定目录名称允许我们重命名该目录。在这种情况下，*newpath*要么不存在，要么必须是一个空目录的名称。如果*newpath*是一个现有文件或一个已存在且非空的目录，则会出现错误（分别为`ENOTDIR`和`ENOTEMPTY`）。
- en: If *oldpath* is a directory, then *newpath* can’t contain a directory prefix
    that is the same as *oldpath*. For example, we could not rename `/home/mtk` to
    `/home/mtk/bin` (the error is `EINVAL`).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*oldpath*是一个目录，则*newpath*不能包含与*oldpath*相同的目录前缀。例如，我们不能将`/home/mtk`重命名为`/home/mtk/bin`（错误为`EINVAL`）。
- en: The files referred to by *oldpath* and *newpath* must be on the same file system.
    This is required because a directory is a list of hard links that refer to i-nodes
    in the same file system as the directory. As stated earlier, *rename()* is merely
    manipulating the contents of directory lists. Attempting to rename a file into
    a different file system fails with the error `EXDEV`. (To achieve the desired
    result, we must instead copy the contents of the file from one file system to
    another and then delete the old file. This is what the *mv* command does in this
    case.)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*oldpath*和*newpath*所引用的文件必须位于同一文件系统中。这是因为目录是指向同一文件系统中i节点的硬链接列表。如前所述，*rename()*只是操作目录列表的内容。尝试将文件重命名到不同的文件系统会导致错误`EXDEV`。（要实现预期结果，我们必须将文件内容从一个文件系统复制到另一个文件系统，然后删除旧文件。这正是*mv*命令在这种情况下的操作。）'
- en: 'Working with Symbolic Links: *symlink()* and *readlink()*'
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用符号链接：*symlink()*和*readlink()*
- en: We now look at the system calls used to create symbolic links and examine their
    contents.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在来看看用于创建符号链接的系统调用，并检查它们的内容。
- en: The *symlink()* system call creates a new symbolic link, *linkpath*, to the
    pathname specified in *filepath*. (To remove a symbolic link, we use *unlink()*.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*symlink()* 系统调用创建一个新的符号链接 *linkpath*，指向 *filepath* 中指定的路径名。（要删除符号链接，我们使用 *unlink()*。）'
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，失败时返回 -1。
- en: If the pathname given in *linkpath* already exists, then the call fails (with
    *errno* set to `EEXIST`). The pathname specified in *filepath* may be absolute
    or relative.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *linkpath* 中给定的路径名已经存在，则调用失败（并且 *errno* 设置为 `EEXIST`）。*filepath* 中指定的路径名可以是绝对路径或相对路径。
- en: The file or directory named in *filepath* doesn’t need to exist at the time
    of the call. Even if it exists at that time, there is nothing to prevent it from
    being removed later. In this case, *linkpath* becomes a *dangling link*, and attempts
    to dereference it in other system calls yield an error (usually `ENOENT`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用时，*filepath* 中指定的文件或目录不需要存在。即使它在调用时存在，也没有任何东西能阻止它稍后被删除。在这种情况下，*linkpath*
    变成了一个 *悬挂链接*，在其他系统调用中尝试解除引用它会导致错误（通常是 `ENOENT`）。
- en: If we specify a symbolic link as the *pathname* argument to *open()*, it opens
    the file to which the link refers. Sometimes, we would rather retrieve the content
    of the link itself—that is, the pathname to which it refers. The *readlink()*
    system call performs this task, placing a copy of the symbolic link string in
    the character array pointed to by *buffer*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将符号链接指定为 *open()* 的 *pathname* 参数，它将打开链接所指向的文件。有时，我们更希望检索链接本身的内容——即它所指向的路径名。*readlink()*
    系统调用执行此任务，将符号链接字符串的副本放入 *buffer* 指向的字符数组中。
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns number of bytes placed in *buffer* on success, or -1 on error
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回放入 *buffer* 中的字节数，失败时返回 -1。
- en: The *bufsiz* argument is an integer used to tell *readlink()* the number of
    bytes available in *buffer*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*bufsiz* 参数是一个整数，用来告诉 *readlink()* *buffer* 中可用的字节数。'
- en: If no errors occur, then *readlink()* returns the number of bytes actually placed
    in *buffer*. If the length of the link exceeds *bufsiz*, then a truncated string
    is placed in *buffer* (and *readlink()* returns the size of that string—that is,
    *bufsiz*).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生错误，*readlink()* 将返回实际放入 *buffer* 中的字节数。如果链接的长度超过 *bufsiz*，则会将截断的字符串放入
    *buffer* 中（并且 *readlink()* 返回该字符串的大小——即 *bufsiz*）。
- en: Because a terminating null byte is not placed at the end of *buffer*, there
    is no way to distinguish the case where *readlink()* returns a truncated string
    from that where it returns a string that exactly fills *buffer*. One way of checking
    if the latter has occurred is to reallocate a larger *buffer* array and call *readlink()*
    again. Alternatively, we can size *pathname* using the `PATH_MAX` constant (described
    in [System Limits](ch11.html#system_limits "System Limits")), which defines the
    length of the longest pathname that a program should have to accommodate.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 *buffer* 的末尾不会放置终止的空字节，所以无法区分 *readlink()* 返回的是被截断的字符串还是返回了恰好填满 *buffer*
    的字符串。检查后一种情况的方法是重新分配更大的 *buffer* 数组并再次调用 *readlink()*。或者，我们可以使用 `PATH_MAX` 常量（在
    [系统限制](ch11.html#system_limits "系统限制") 中描述）来确定 *pathname* 的大小，该常量定义了程序应能容纳的最长路径名长度。
- en: We demonstrate the use of *readlink()* in [Example 18-4](ch18.html#read_and_resolve_a_symbolic_link
    "Example 18-4. Read and resolve a symbolic link").
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [示例 18-4](ch18.html#read_and_resolve_a_symbolic_link "示例 18-4. 读取并解析符号链接")
    中演示了 *readlink()* 的使用。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 defined a new limit, `SYMLINK_MAX`, that an implementation should define
    to indicate the maximum number of bytes that can be stored in a symbolic link.
    This limit is required to be at least 255 bytes. At the time of writing, Linux
    doesn’t define this limit. In the main text, we suggest the use of `PATH_MAX`
    because that limit should be at least as large as `SYMLINK_MAX`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 定义了一个新的限制 `SYMLINK_MAX`，实现应该定义该限制，以指示可以存储在符号链接中的最大字节数。该限制要求至少为 255 字节。截至本文写作时，Linux
    并未定义此限制。正文中，我们建议使用 `PATH_MAX`，因为该限制应至少与 `SYMLINK_MAX` 一样大。
- en: In SUSv2, the return type of *readlink()* was specified as *int*, and many current
    implementations (as well as older *glibc* versions on Linux) follow that specification.
    SUSv3 changed the return type to *ssize_t*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SUSv2 中，*readlink()* 的返回类型被指定为 *int*，许多当前的实现（以及 Linux 上较旧的 *glibc* 版本）遵循该规范。SUSv3
    将返回类型更改为 *ssize_t*。
- en: 'Creating and Removing Directories: *mkdir()* and *rmdir()*'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和删除目录：*mkdir()* 和 *rmdir()*
- en: The *mkdir()* system call creates a new directory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*mkdir()* 系统调用用于创建新目录。'
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回0，出错时返回-1
- en: The *pathname* argument specifies the pathname of the new directory. This pathname
    may be relative or absolute. If a file with this pathname already exists, then
    the call fails with the error `EEXIST`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*pathname* 参数指定新目录的路径名。该路径名可以是相对路径或绝对路径。如果该路径名对应的文件已经存在，则调用将失败，并返回错误 `EEXIST`。'
- en: The ownership of the new directory is set according to the rules described in
    [Ownership of New Files](ch15.html#ownership_of_new_files "Ownership of New Files").
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 新目录的所有权将根据[新文件的所有权](ch15.html#ownership_of_new_files "新文件的所有权")中描述的规则进行设置。
- en: 'The *mode* argument specifies the permissions for the new directory. (We describe
    the meanings of the permission bits for directories in [Ownership of New Files](ch15.html#ownership_of_new_files
    "Ownership of New Files"), [Changing File Ownership: *chown()*, *fchown()*, and
    *lchown()*](ch15.html#changing_file_ownership_colon_chown_open "Changing File
    Ownership: chown(), fchown(), and lchown()"), and [Set-User-ID, Set-Group-ID,
    and Sticky Bits](ch15.html#set-user-id_comma_set-group-id_comma_and "Set-User-ID,
    Set-Group-ID, and Sticky Bits").) This bit-mask value may be specified by ORing
    (`|`) together constants from [Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), in [Permissions on Directories](ch15.html#permissions_on_directories
    "Permissions on Directories"), but, as with *open()*, it may also be specified
    as an octal number. The value given in *mode* is ANDed against the process umask
    ([The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")). In addition, the set-user-ID
    bit (`S_ISUID`) is always turned off, since it has no meaning for directories.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*mode* 参数指定新目录的权限。（我们在[新文件的所有权](ch15.html#ownership_of_new_files "新文件的所有权")、[更改文件所有权：*chown()*、*fchown()*
    和 *lchown()*](ch15.html#changing_file_ownership_colon_chown_open "更改文件所有权：chown(),
    fchown(), 和 lchown()")以及[设置用户ID、设置组ID 和粘滞位](ch15.html#set-user-id_comma_set-group-id_comma_and
    "设置用户ID、设置组ID 和粘滞位")中描述了目录权限位的含义。）该位掩码值可以通过按位或（`|`）将[表15-4](ch15.html#constants_for_file_permission_bits
    "表15-4 文件权限位常量")中的常量组合来指定，也可以像*open()*一样指定为八进制数。给定的 *mode* 值会与进程的 umask 进行按位与运算（[进程文件模式创建掩码：*umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "进程文件模式创建掩码：umask()")）。此外，设置用户ID位（`S_ISUID`）总是被关闭，因为它对目录没有意义。'
- en: If the sticky bit (`S_ISVTX`) is set in *mode*, then it will be set on the new
    directory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 *mode* 中设置了粘滞位（`S_ISVTX`），则该位也会设置在新目录上。
- en: The setting of the set-group-ID bit (`S_ISGID`) in *mode* is ignored. Instead,
    if the set-group-ID bit is set on the parent directory, then it will also be set
    on the newly created directory. In [Ownership of New Files](ch15.html#ownership_of_new_files
    "Ownership of New Files"), we noted that setting the set-group-ID permission bit
    on a directory causes new files created in the directory to take their group ID
    from the directory’s group ID, rather than the process’s effective group ID. The
    *mkdir()* system call propagates the set-group-ID permission bit in the manner
    described here so that all subdirectories under a directory will share the same
    behavior.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *mode* 中设置组ID位（`S_ISGID`）将被忽略。相反，如果父目录上设置了组ID位，则新创建的目录也会设置该位。在[新文件的所有权](ch15.html#ownership_of_new_files
    "新文件的所有权")中，我们提到，在目录上设置组ID权限位会使得在该目录中创建的新文件继承目录的组ID，而不是进程的有效组ID。*mkdir()* 系统调用以此方式传播组ID权限位，以确保目录下的所有子目录共享相同的行为。
- en: SUSv3 explicitly notes that the manner in which *mkdir()* treats the set-user-ID,
    set-group-ID, and sticky bits is implementation-defined. On some UNIX implementations,
    these 3 bits are always turned off on a new directory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 明确指出，*mkdir()* 如何处理设置用户ID、设置组ID 和粘滞位是由实现定义的。在某些 UNIX 实现中，这三个位在新目录上总是关闭的。
- en: 'The newly created directory contains two entries: `.` (dot), which is a link
    to the directory itself, and `..` (dot-dot), which is a link to the parent directory.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的目录包含两个条目：`.`（点），它是指向该目录本身的链接，和`..`（点点），它是指向父目录的链接。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 doesn’t require directories to contain `.` and `..` entries. It requires
    only that an implementation correctly interpret `.` and `..` when they appear
    in pathnames. A portable application should not rely on the existence of these
    entries in a directory.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'SUSv3 不要求目录必须包含 `.` 和 `..` 项。它只要求在路径名中出现 `.` 和 `..` 时，正确解释它们。一个便携式应用程序不应依赖目录中存在这些项。  '
- en: The *mkdir()* system call creates only the last component of *pathname*. In
    other words, the call *mkdir(“aaa/bbb/ccc”, mode)* will succeed only if the directories
    `aaa` and `aaa/bbb` already exist. (This corresponds to the default operation
    of the *mkdir(1)* command, but *mkdir(1)* also provides the *-p* option to create
    all of the intervening directory names if they don’t exist.)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*mkdir()* 系统调用仅创建 *pathname* 的最后一个组件。换句话说，调用 *mkdir(“aaa/bbb/ccc”, mode)* 仅在目录
    `aaa` 和 `aaa/bbb` 已经存在时才会成功。（这与 *mkdir(1)* 命令的默认操作相对应，但 *mkdir(1)* 还提供了 *-p* 选项，以便在目录不存在时创建所有中间的目录名称。）  '
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '注意  '
- en: The GNU C library provides the *mkdtemp(template)* function, which is the directory
    analog of the *mkstemp()* function. It creates a uniquely named directory with
    read, write, and execute permissions enabled for the owner, and no permissions
    allowed for any other users. Instead of returning a file descriptor as its result,
    *mkdtemp()* returns a pointer to a modified string containing the actual directory
    name in *template*. SUSv3 doesn’t specify this function, and it is not available
    on all UNIX implementations; it is specified in SUSv4.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'GNU C 库提供了 *mkdtemp(template)* 函数，它是 *mkstemp()* 函数的目录类模拟。它创建一个唯一命名的目录，为所有者启用读、写和执行权限，且不允许其他用户拥有任何权限。与返回文件描述符不同，*mkdtemp()*
    返回指向修改后的字符串的指针，该字符串包含实际的目录名称，存储在 *template* 中。SUSv3 未指定此函数，且并非所有 UNIX 实现都支持它；它在
    SUSv4 中有所规定。  '
- en: The *rmdir()* system call removes the directory specified in *pathname*, which
    may be an absolute or a relative pathname.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*rmdir()* 系统调用删除指定的 *pathname* 目录，*pathname* 可以是绝对路径或相对路径。  '
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '注意  '
- en: Returns 0 on success, or -1 on error
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '成功时返回 0，出错时返回 -1  '
- en: In order for *rmdir()* to succeed, the directory must be empty. If the final
    component of *pathname* is a symbolic link, it is not dereferenced; instead, the
    error `ENOTDIR` results.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '为了使 *rmdir()* 成功，目录必须为空。如果 *pathname* 的最后一个组件是符号链接，则不会取消引用；相反，会返回错误 `ENOTDIR`。  '
- en: 'Removing a File or Directory: *remove()*'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '删除文件或目录：*remove()*  '
- en: The *remove()* library function removes a file or an empty directory.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*remove()* 库函数用于删除文件或空目录。  '
- en: '[PRE12]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '注意  '
- en: Returns 0 on success, or -1 on error
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '成功时返回 0，出错时返回 -1  '
- en: If *pathname* is a file, *remove()* calls *unlink()*; if *pathname* is a directory,
    *remove()* calls *rmdir()*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 *pathname* 是一个文件，*remove()* 会调用 *unlink()*；如果 *pathname* 是一个目录，*remove()*
    会调用 *rmdir()*。  '
- en: Like *unlink()* and *rmdir()*, *remove()* doesn’t dereference symbolic links.
    If *pathname* is a symbolic link, *remove()* removes the link itself, rather than
    the file to which it refers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '像 *unlink()* 和 *rmdir()* 一样，*remove()* 不会取消引用符号链接。如果 *pathname* 是一个符号链接，*remove()*
    删除的是符号链接本身，而不是它所指向的文件。  '
- en: If we want to remove a file in preparation for creating a new file with the
    same name, then using *remove()* is simpler than code that checks whether a pathname
    refers to a file or directory and calls *unlink()* or *rmdir()*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们希望删除一个文件以便准备创建一个同名的新文件，那么使用 *remove()* 比检查路径名是文件还是目录并调用 *unlink()* 或 *rmdir()*
    更为简单。  '
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '注意  '
- en: The *remove()* function was invented for the standard C library, which is implemented
    on both UNIX and non-UNIX systems. Most non-UNIX systems don’t support hard links,
    so removing files with a function named *unlink()* would not make sense.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*remove()* 函数是为标准 C 库发明的，该库在 UNIX 和非 UNIX 系统上都有实现。大多数非 UNIX 系统不支持硬链接，因此使用名为
    *unlink()* 的函数来删除文件是没有意义的。'
- en: 'Reading Directories: *opendir()* and *readdir()*'
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '读取目录：*opendir()* 和 *readdir()*  '
- en: The library functions described in this section can be used to open a directory
    and retrieve the names of the files it contains one by one.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '本节描述的库函数可以用于打开目录并逐一检索其中包含的文件名称。  '
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '注意  '
- en: The library functions for reading directories are layered on top of the *getdents()*
    system call (which is not part of SUSv3), but provide an interface that is easier
    to use. Linux also provides a *readdir(2)* system call (as opposed to the *readdir(3)*
    library function described here), which performs a similar task to, but is made
    obsolete by, *getdents()*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 用于读取目录的库函数是建立在*getdents()*系统调用之上的（该调用不是SUSv3的一部分），但提供了一个更易于使用的接口。Linux还提供了*readdir(2)*系统调用（与此处描述的*readdir(3)*库函数不同），其执行的任务类似，但已被*getdents()*取代。
- en: The *opendir()* function opens a directory and returns a handle that can be
    used to refer to the directory in later calls.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*opendir()*函数打开一个目录并返回一个句柄，该句柄可以在后续调用中用于引用该目录。'
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns directory stream handle, or `NULL` on error
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 返回目录流句柄，出错时返回`NULL`
- en: The *opendir()* function opens the directory specified by *dirpath* and returns
    a pointer to a structure of type *DIR*. This structure is a so-called *directory
    stream*, which is a handle that the caller passes to the other functions described
    below. Upon return from *opendir()*, the directory stream is positioned at the
    first entry in the directory list.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*opendir()*函数打开由*dirpath*指定的目录，并返回指向*DIR*类型结构的指针。该结构是所谓的*目录流*，它是一个句柄，调用者将其传递给下面描述的其他函数。*opendir()*返回时，目录流位于目录列表中的第一个条目。'
- en: The *fdopendir()* function is like *opendir()*, except that the directory for
    which a stream is to be created is specified via the open file descriptor *fd*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*fdopendir()*函数类似于*opendir()*，不同之处在于为创建目录流指定的目录是通过打开的文件描述符*fd*来指定的。'
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns directory stream handle, or `NULL` on error
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 返回目录流句柄，出错时返回`NULL`
- en: The *fdopendir()* function is provided so that applications can avoid the kinds
    of race conditions described in [Operating Relative to a Directory File Descriptor](ch18.html#operating_relative_to_a_directory_file_d
    "Operating Relative to a Directory File Descriptor").
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 提供*fdopendir()*函数是为了让应用程序避免在[操作相对于目录文件描述符](ch18.html#operating_relative_to_a_directory_file_d
    "操作相对于目录文件描述符")中描述的竞争条件。
- en: After a successful call to *fdopendir()*, this file descriptor is under the
    control of the system, and the program should not access it in any way other than
    by using the functions described in the remainder of this section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用*fdopendir()*后，文件描述符由系统控制，程序不应以任何方式访问它，除非使用本节其余部分描述的函数。
- en: The *fdopendir()* function is specified in SUSv4 (but not in SUSv3).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*fdopendir()*函数在SUSv4中被指定（但在SUSv3中没有）。'
- en: The *readdir()* function reads successive entries from a directory stream.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*readdir()*函数从目录流中读取连续的条目。'
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to a statically allocated structure describing next directory
    entry, or `NULL` on end-of-directory or error
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向静态分配结构的指针，描述下一个目录条目，或者在目录结束或出错时返回`NULL`
- en: 'Each call to *readdir()* reads the next directory entry from the directory
    stream referred to by *dirp* and returns a pointer to a statically allocated structure
    of type *dirent*, containing the following information about the entry:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用*readdir()*时，都会从由*dirp*引用的目录流中读取下一个目录条目，并返回指向静态分配的*dirent*类型结构的指针，该结构包含有关该条目的以下信息：
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This structure is overwritten on each call to *readdir()*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构在每次调用*readdir()*时会被覆盖。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have omitted various nonstandard fields in the Linux *dirent* structure from
    the above definition, since their use renders an application nonportable. The
    most interesting of these nonstandard fields is *d_type*, which is also present
    on BSD derivatives, but not on other UNIX implementations. This field holds a
    value indicating the type of the file named in *d_name*, such as `DT_REG` (regular
    file), `DT_DIR` (directory), `DT_LNK` (symbolic link), or `DT_FIFO` (FIFO). (These
    names are analogous to the macros in [Table 15-1](ch15.html#macros_for_checking_file_types_in_the_st
    "Table 15-1. Macros for checking file types in the st_mode field of the stat structure"),
    in [File size, blocks allocated, and optimal I/O block size](ch15.html#file_size_comma_blocks_allocated_comma_a
    "File size, blocks allocated, and optimal I/O block size").) Using the information
    in this field saves the cost of calling *lstat()* in order to discover the file
    type. Note, however, that, at the time of writing, this field is fully supported
    only on *Btrfs*, *ext2*, *ext3*, and *ext4*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已在上述定义中省略了Linux *dirent*结构中的各种非标准字段，因为它们的使用会使应用程序变得不可移植。这些非标准字段中最有趣的是*d_type*，它在BSD衍生版本中也存在，但在其他UNIX实现中不存在。该字段保存一个值，表示在*d_name*中命名的文件类型，例如`DT_REG`（常规文件）、`DT_DIR`（目录）、`DT_LNK`（符号链接）或`DT_FIFO`（FIFO）。
    （这些名称类似于[表15-1](ch15.html#macros_for_checking_file_types_in_the_st "表15-1. 检查stat结构中st_mode字段中文件类型的宏")中的宏，参见[文件大小、分配的块和最佳I/O块大小](ch15.html#file_size_comma_blocks_allocated_comma_a
    "文件大小、分配的块和最佳I/O块大小")。）使用该字段中的信息可以节省调用*lstat()*以发现文件类型的成本。请注意，然而，在撰写本文时，该字段仅在*Btrfs*、*ext2*、*ext3*和*ext4*上完全支持。
- en: Further information about the file referred to by *d_name* can be obtained by
    calling *lstat()* (or *stat()*, if a symbolic link should be dereferenced) on
    the pathname constructed using the *dirpath* argument that was specified to *opendir()*
    concatenated with (a slash and) the value returned in the *d_name* field.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用*lstat()*（如果需要取消符号链接，则调用*stat()*）来获取有关由*d_name*引用的文件的更多信息，方法是使用指定给*opendir()*的*dirpath*参数构造的路径名，并与（一个斜杠和）*d_name*字段中返回的值连接起来。
- en: The filenames returned by *readdir()* are not in sorted order, but rather in
    the order in which they happen to occur in the directory (this depends on the
    order in which the file system adds files to the directory and how it fills gaps
    in the directory list after files are removed). (The command *ls -f* lists files
    in the same unsorted order that they would be retrieved by *readdir()*.)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*readdir()*返回的文件名不是按排序顺序排列的，而是按它们在目录中出现的顺序排列（这取决于文件系统向目录添加文件的顺序，以及在删除文件后如何填充目录列表中的空白）。
    （命令*ls -f*按与*readdir()*检索文件时相同的无序顺序列出文件。）'
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can use the function *scandir(3)* to retrieve a sorted list of files matching
    programmer-defined criteria; see the manual page for details. Although not specified
    in SUSv3, *scandir()* is provided on most UNIX implementations. SUSv4 added a
    specification for *scandir()*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用函数*scandir(3)*来检索符合程序员定义的条件的已排序文件列表；有关详细信息，请参阅手册页。尽管SUSv3中未指定，*scandir()*在大多数UNIX实现中都提供。SUSv4为*scandir()*添加了规范。
- en: 'On end-of-directory or error, *readdir()* returns `NULL`, in the latter case
    setting *errno* to indicate the error. To distinguish these two cases, we can
    write the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录结束或出错时，*readdir()*返回`NULL`，在后者的情况下，会设置*errno*以指示错误。为了区分这两种情况，我们可以编写如下代码：
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the contents of a directory change while a program is scanning it with *readdir()*,
    the program might not see the changes. SUSv3 explicitly notes that it is unspecified
    whether *readdir()* will return a filename that has been added to or removed from
    the directory since the last call to *opendir()* or *rewinddir()*. All filenames
    that have been neither added nor removed since the last such call are guaranteed
    to be returned.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目录的内容在程序使用*readdir()*扫描时发生变化，程序可能看不到这些变化。SUSv3明确指出，未指定*readdir()*是否会返回自上次调用*opendir()*或*rewinddir()*以来已添加或删除的文件名。所有自上次此类调用以来既未添加也未删除的文件名都保证会被返回。
- en: The *rewinddir()* function moves the directory stream back to the beginning
    so that the next call to *readdir()* will begin again with the first file in the
    directory.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*rewinddir()*函数将目录流移动回起始位置，以便下次调用*readdir()*时，从目录中的第一个文件开始。'
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The *closedir()* function closes the open directory stream referred to by *dirp*,
    freeing the resources used by the stream.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*closedir()*函数关闭由*dirp*引用的已打开的目录流，释放该流使用的资源。'
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回 -1
- en: Two further functions, *telldir()* and *seekdir()*, which are also specified
    in SUSv3, allow random access within a directory stream. Refer to the manual pages
    for further information about these functions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个函数，*telldir()* 和 *seekdir()*，它们也在 SUSv3 中有指定，允许在目录流中进行随机访问。有关这些函数的更多信息，请参阅手册页。
- en: Directory streams and file descriptors
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目录流和文件描述符
- en: A directory stream has an associated file descriptor. The *dirfd()* function
    returns the file descriptor associated with the directory stream referred to by
    *dirp*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 目录流有一个相关联的文件描述符。*dirfd()* 函数返回与 *dirp* 引用的目录流相关联的文件描述符。
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns file descriptor on success, or -1 on error
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件描述符，出错时返回 -1
- en: We might, for example, pass the file descriptor returned by *dirfd()* to *fchdir()*
    ([The Current Working Directory of a Process](ch18.html#the_current_working_directory_of_a_proce
    "The Current Working Directory of a Process")) in order to change the current
    working directory of the process to the corresponding directory. Alternatively,
    we might pass the file descriptor as the *dirfd* argument of one of the functions
    described in [Operating Relative to a Directory File Descriptor](ch18.html#operating_relative_to_a_directory_file_d
    "Operating Relative to a Directory File Descriptor").
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将 *dirfd()* 返回的文件描述符传递给 *fchdir()*（[进程的当前工作目录](ch18.html#the_current_working_directory_of_a_proce
    "进程的当前工作目录")），以将进程的当前工作目录更改为相应的目录。或者，我们也可以将文件描述符作为 *dirfd* 参数传递给 [相对于目录文件描述符操作](ch18.html#operating_relative_to_a_directory_file_d
    "相对于目录文件描述符操作") 中描述的函数之一。
- en: The *dirfd()* function also appears on the BSDs, but is present on few other
    implementations. It is not specified in SUSv3, but is specified in SUSv4.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*dirfd()* 函数也出现在 BSD 系统中，但在其他实现中较少出现。它在 SUSv3 中没有指定，但在 SUSv4 中有指定。'
- en: At this point, it is worth mentioning that *opendir()* automatically sets the
    close-on-exec flag (`FD_CLOEXEC`) for the file descriptor associated with the
    directory stream. This ensures that the file descriptor is automatically closed
    when an *exec()* is performed. (SUSv3 requires this behavior.) We describe the
    close-on-exec flag in Section 27.4.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，值得一提的是，*opendir()* 会自动为与目录流关联的文件描述符设置关闭执行标志（`FD_CLOEXEC`）。这确保了在执行 *exec()*
    时，文件描述符会自动关闭。（SUSv3 要求这种行为。）我们在第 27.4 节中描述了关闭执行标志。
- en: Example program
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 18-2](ch18.html#scanning_a_directory "Example 18-2. Scanning a directory")
    uses *opendir()*, *readdir()*, and *closedir()* to list the contents of each of
    the directories specified in its command line (or in the current working directory
    if no arguments are supplied). Here is an example of the use of this program:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-2](ch18.html#scanning_a_directory "示例 18-2. 扫描目录") 使用 *opendir()*、*readdir()*
    和 *closedir()* 来列出命令行中指定的每个目录（如果没有提供参数，则列出当前工作目录的内容）。下面是使用此程序的示例：'
- en: '[PRE21]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Example 18-2. Scanning a directory
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 18-2. 扫描目录
- en: '[PRE22]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The *readdir_r()* function
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*readdir_r()* 函数'
- en: The *readdir_r()* function is a variation on *readdir()*. The key semantic difference
    between *readdir_r()* and *readdir()* is that the former is reentrant, while the
    latter is not. This is because *readdir_r()* returns the file entry via the caller-allocated
    *entry* argument, while *readdir()* returns information via a pointer to a statically
    allocated structure. We discuss reentrancy in [Reentrant and Async-Signal-Safe
    Functions](ch21.html#reentrant_and_async-signal-safe_function "Reentrant and Async-Signal-Safe
    Functions") and [Thread Safety (and Reentrancy Revisited)](ch31.html#thread_safety_open_parenthesis_and_reent
    "Thread Safety (and Reentrancy Revisited)").
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*readdir_r()* 函数是 *readdir()* 的一种变体。*readdir_r()* 和 *readdir()* 之间的关键语义差异在于，前者是可重入的，而后者不是。这是因为
    *readdir_r()* 通过调用方分配的 *entry* 参数返回文件项，而 *readdir()* 则通过指向静态分配结构的指针返回信息。我们在 [可重入和异步信号安全函数](ch21.html#reentrant_and_async-signal-safe_function
    "可重入和异步信号安全函数") 和 [线程安全（以及可重入性复习）](ch31.html#thread_safety_open_parenthesis_and_reent
    "线程安全（以及可重入性复习）") 中讨论了可重入性。'
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or a positive error number on error
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，出错时返回一个正的错误编号
- en: Given *dirp*, which is a directory stream previously opened via *opendir()*,
    *readdir_r()* places information about the next directory entry into the *dirent*
    structure referred to by *entry*. In addition, a pointer to this structure is
    placed in *result*. If the end of the directory stream is reached, then `NULL`
    is placed in *result* instead (and *readdir_r()* returns 0). On error, *readdir_r()*
    doesn’t return -1, but instead returns a positive integer corresponding to one
    of the *errno* values.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 *dirp*，这是一个之前通过 *opendir()* 打开的目录流，*readdir_r()* 将下一个目录项的信息放入 *entry* 所引用的
    *dirent* 结构中。此外，指向此结构的指针被放入 *result* 中。如果已到达目录流的末尾，则 *result* 中将放入 `NULL`（此时 *readdir_r()*
    返回 0）。如果发生错误，*readdir_r()* 不会返回 -1，而是返回一个对应于某个 *errno* 值的正整数。
- en: 'On Linux, the *d_name* field of the *dirent* structure is sized as an array
    of 256 bytes, which is long enough to hold the largest possible filename. Although
    several other UNIX implementations define the same size for *d_name*, SUSv3 leaves
    this point unspecified, and some UNIX implementations instead define the field
    as a 1-byte array, leaving the calling program with the task of allocating a structure
    of the correct size. When doing this, we should size the *d_name* field as one
    greater (for the terminating null byte) than the value of the constant `NAME_MAX`.
    Portable applications should thus allocate the *dirent* structure as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，*dirent* 结构的 *d_name* 字段被定义为一个 256 字节的数组，这足够容纳最大的文件名。尽管其他几个 UNIX 实现也为
    *d_name* 定义了相同的大小，但 SUSv3 没有规定这一点，一些 UNIX 实现将该字段定义为 1 字节数组，导致调用程序需要负责分配正确大小的结构体。在这种情况下，我们应该将
    *d_name* 字段的大小设置为常量 `NAME_MAX` 的值加一（用于终止的空字节）。因此，便携式应用程序应按以下方式分配 *dirent* 结构：
- en: '[PRE24]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using the `offsetof()` macro (defined in `<stddef.h>`) avoids any implementation-specific
    dependencies on the number and size of fields in the *dirent* structure preceding
    the *d_name* field (which is always the last field in the structure).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `offsetof()` 宏（定义在 `<stddef.h>` 中）可以避免对 *dirent* 结构中在 *d_name* 字段之前的字段数量和大小的任何实现特定依赖（*d_name*
    字段总是结构中的最后一个字段）。
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `offsetof()` macro takes two arguments—a structure type and the name of
    a field within that structure—and returns a value of type *size_t* that is the
    offset in bytes of the field from the beginning of the structure. This macro is
    necessary because a compiler may insert padding bytes in a structure to satisfy
    alignment requirements for types such as *int*, with the result that a field’s
    offset within a structure may be greater than the sum of the sizes of the fields
    that precede it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`offsetof()` 宏接受两个参数——一个结构体类型和该结构体中某个字段的名称——并返回一个 *size_t* 类型的值，表示该字段相对于结构体开始位置的字节偏移量。这个宏是必要的，因为编译器可能会在结构体中插入填充字节，以满足诸如
    *int* 之类类型的对齐要求，从而导致字段在结构体中的偏移量可能大于前面字段大小的总和。'
- en: 'File Tree Walking: *nftw()*'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件树遍历：*nftw()*
- en: The *nftw()* function allows a program to recursively walk through an entire
    directory subtree performing some operation (i.e., calling some programmer-defined
    function) for each file in the subtree.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*nftw()* 函数允许程序递归遍历整个目录子树，并对子树中的每个文件执行某些操作（即调用某些程序员定义的函数）。'
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *nftw()* function is an enhancement of the older *ftw()* function, which
    performs a similar task. New applications should use *nftw()* (*new ftw*) because
    it provides more functionality, and predictable handling of symbolic links (SUSv3
    permits *ftw()* either to follow or not follow symbolic links). SUSv3 specifies
    both *nftw()* and *ftw()*, but the latter function is marked obsolete in SUSv4.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*nftw()* 函数是对旧版 *ftw()* 函数的增强，后者执行类似的任务。新应用程序应使用 *nftw()*（*new ftw*），因为它提供了更多功能，并且能预测性地处理符号链接（SUSv3
    允许 *ftw()* 要么跟随符号链接，要么不跟随符号链接）。SUSv3 同时指定了 *nftw()* 和 *ftw()*，但后者在 SUSv4 中被标记为过时。'
- en: The GNU C library also provides the BSD-derived *fts* API (*fts_open()*, *fts_read()*,
    *fts_children()*, *fts_set()*, and *fts_close()*). These functions perform a similar
    task to *ftw()* and *nftw()*, but offer greater flexibility to an application
    walking the tree. However, this API is not standardized and is provided on few
    UNIX implementations other than BSD descendants, so we omit discussion of it here.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C 库还提供了基于 BSD 衍生的 *fts* API（*fts_open()*, *fts_read()*, *fts_children()*,
    *fts_set()*, 和 *fts_close()*）。这些函数执行与 *ftw()* 和 *nftw()* 相似的任务，但为应用程序遍历树结构提供了更大的灵活性。然而，这个
    API 并没有标准化，除了 BSD 后代外，其他 UNIX 实现中很少提供，因此我们在这里省略对其的讨论。
- en: The *nftw()* function walks through the directory tree specified by *dirpath*
    and calls the programmer-defined function *func* once for each file in the directory
    tree.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*nftw()* 函数会遍历由 *dirpath* 指定的目录树，并对目录树中的每个文件调用程序员定义的函数 *func* 一次。'
- en: '[PRE25]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 after successful walk of entire tree, or -1 on error, or the first
    nonzero value returned by a call to *func*
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 成功遍历整个树后返回 0，出错时返回 -1，或者返回 *func* 调用时的第一个非零值。
- en: By default, *nftw()* performs an unsorted, preorder traversal of the given tree,
    processing each directory before processing the files and subdirectories within
    that directory.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，*nftw()* 对给定的树执行无序的先序遍历，先处理每个目录，再处理该目录下的文件和子目录。
- en: While traversing the directory tree, *nftw()* opens at most one file descriptor
    for each level of the tree. The *nopenfd* argument specifies the maximum number
    of file descriptors that *nftw()* may use. If the depth of the directory tree
    exceeds this maximum, *nftw()* does some bookkeeping, and closes and reopens descriptors
    in order to avoid holding open more than *nopenfd* descriptors simultaneously
    (and consequently runs more slowly). The need for this argument was greater under
    older UNIX implementations, some of which had a limit of 20 open file descriptors
    per process. Modern UNIX implementations allow a process to open a large number
    of file descriptors, and thus we can specify a generous number here (say 10 or
    more).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历目录树时，*nftw()* 每一层目录最多只打开一个文件描述符。*nopenfd* 参数指定 *nftw()* 可以使用的最大文件描述符数。如果目录树的深度超过此最大值，*nftw()*
    会进行一些记录，并关闭和重新打开描述符，以避免同时打开超过 *nopenfd* 个描述符（从而导致性能下降）。在旧的 UNIX 实现中对这个参数的需求更大，因为其中一些系统对每个进程有
    20 个打开文件描述符的限制。现代 UNIX 实现允许进程打开大量文件描述符，因此我们可以在此指定一个较大的数字（比如 10 或更多）。
- en: 'The *flags* argument to *nftw()* is created by ORing (`|`) zero or more of
    the following constants, which modify the operation of the function:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*nftw()* 的 *flags* 参数是通过按位或（`|`）运算将以下常量之一或多个组合起来的，这些常量会修改该函数的操作：'
- en: '`FTW_CHDIR`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_CHDIR`'
- en: Do a *chdir()* into each directory before processing its contents. This is useful
    if *func* is designed to do some work in the directory in which the file specified
    by its *pathname* argument resides.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理每个目录的内容之前，先进行 *chdir()* 操作。这在 *func* 设计为在包含其 *pathname* 参数指定的文件的目录中执行某些操作时非常有用。
- en: '`FTW_DEPTH`'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_DEPTH`'
- en: Do a postorder traversal of the directory tree. This means that *nftw()* calls
    *func* on all of the files (and subdirectories) within a directory before executing
    *func* on the directory itself. (The name of this flag is somewhat misleading—*nftw()*
    always does a depth-first, rather than a breadth-first, traversal of the directory
    tree. All that this flag does is convert the traversal from preorder to postorder.)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对目录树进行后序遍历。这意味着 *nftw()* 会在执行 *func* 操作目录本身之前，对目录中的所有文件（和子目录）调用 *func*。（这个标志的名称有些误导——*nftw()*
    始终是深度优先遍历目录树，而不是广度优先遍历。这个标志的作用只是将遍历方式从先序转换为后序。）
- en: '`FTW_MOUNT`'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_MOUNT`'
- en: Don’t cross over into another file system. Thus, if one of the subdirectories
    of the tree is a mount point, it is not traversed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 不要跨越到另一个文件系统。因此，如果树的某个子目录是挂载点，则不会进行遍历。
- en: '`FTW_PHYS`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_PHYS`'
- en: By default, *nftw()* dereferences symbolic links. This flag tells it not to
    do so. Instead, a symbolic link is passed to *func* with a *typeflag* value of
    `FTW_SL`, as described below.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，*nftw()* 会取消符号链接的引用。这个标志指示它不要这么做。相反，符号链接会传递给 *func*，并且 *typeflag* 值为 `FTW_SL`，如下所述。
- en: 'For each file, *nftw()* passes four arguments when calling *func*. The first
    of these arguments, *pathname*, is the pathname of the file. This pathname may
    be absolute, if *dirpath* was specified as an absolute pathname, or relative to
    the current working directory of the calling process at the time of the call to
    *ntfw()*, if *dirpath* was expressed as a relative pathname. The second argument,
    *statbuf*, is a pointer to a *stat* structure ([Retrieving File Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()")) containing information about this file.
    The third argument, *typeflag*, provides further information about the file, and
    has one of the following symbolic values:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个文件，*nftw()*在调用*func*时传递四个参数。其中第一个参数，*pathname*，是文件的路径名。如果*dirpath*指定为绝对路径名，则此路径名可以是绝对的；如果*dirpath*以相对路径名表示，则此路径名相对于调用*nftw()*时调用进程的当前工作目录。第二个参数，*statbuf*，是指向*stat*结构体的指针（[检索文件信息：*stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "检索文件信息：stat()")），该结构体包含该文件的信息。第三个参数，*typeflag*，提供关于文件的进一步信息，并具有以下符号值之一：
- en: '`FTW_D`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_D`'
- en: This is a directory.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个目录。
- en: '`FTW_DNR`'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_DNR`'
- en: This is a directory that can’t be read (and so *nftw()* doesn’t traverse any
    of its descendants).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个无法读取的目录（因此*nftw()*不会遍历其任何子目录）。
- en: '`FTW_DP`'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_DP`'
- en: We are doing a postorder traversal (`FTW_DEPTH`) of a directory, and the current
    item is a directory whose files and subdirectories have already been processed.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在对一个目录进行后序遍历（`FTW_DEPTH`），当前项是一个目录，其文件和子目录已被处理。
- en: '`FTW_F`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_F`'
- en: This is a file of any type other than a directory or symbolic link.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这是除目录或符号链接外的任何类型的文件。
- en: '`FTW_NS`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_NS`'
- en: Calling *stat()* on this file failed, probably because of permission restrictions.
    The value in *statbuf* is undefined.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对该文件调用*stat()*失败，可能是由于权限限制。*statbuf*中的值未定义。
- en: '`FTW_SL`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_SL`'
- en: This is a symbolic link. This value is returned only if *nftw()* is called with
    the `FTW_PHYS` flag.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个符号链接。只有在使用`FTW_PHYS`标志调用*nftw()*时，才会返回此值。
- en: '`FTW_SLN`'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_SLN`'
- en: This item is a dangling symbolic link. This value occurs only if `FTW_PHYS`
    was not specified in the *flags* argument.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个悬空的符号链接。只有在*flags*参数中未指定`FTW_PHYS`时，才会出现此值。
- en: 'The fourth argument to *func*, *ftwbuf*, is a pointer to a structure defined
    as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*func*的第四个参数，*ftwbuf*，是指向以下定义结构体的指针：'
- en: '[PRE26]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The *base* field of this structure is the integer offset of the filename part
    (the component after the last `/`) of the *pathname* argument of *func*. The *level*
    field is the depth of this item relative to the starting point of the traversal
    (which is level 0).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构的*base*字段是*func*的*pathname*参数中文件名部分（即最后一个`/`之后的部分）的整数偏移量。*level*字段是此项相对于遍历起点的深度（起点为0级）。
- en: Each time it is called, *func* must return an integer value, and this value
    is interpreted by *nftw()*. Returning 0 tells *nftw()* to continue the tree walk,
    and if all calls to *func* return 0, *nftw()* itself returns 0 to its caller.
    Returning a nonzero value tells *nftw()* to immediately stop the tree walk, in
    which case *nftw()* returns the same nonzero value as its return value.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用时，*func*必须返回一个整数值，并且*nftw()*会解释该值。返回0表示*nftw()*继续树形遍历，如果所有对*func*的调用都返回0，则*nftw()*本身会返回0给调用者。返回非零值表示*nftw()*立即停止树形遍历，在这种情况下，*nftw()*返回相同的非零值作为返回值。
- en: 'Because *nftw()* uses dynamically allocated data structures, the only way that
    a program should ever prematurely terminate a directory tree walk is by returning
    a nonzero value from *func*. Using *longjmp()* ([Performing a Nonlocal Goto: *setjmp()*
    and *long jmp()*](ch06.html#performing_a_nonlocal_goto_colon_setjmp "Performing
    a Nonlocal Goto: setjmp() and long jmp()")) to exit from *func* may lead to unpredictable
    results—at the very least, memory leaks in a program.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*nftw()*使用动态分配的数据结构，程序唯一应提前终止目录树遍历的方式是通过从*func*返回一个非零值。使用*longjmp()*（[执行非局部跳转：*setjmp()*
    和 *longjmp()*](ch06.html#performing_a_nonlocal_goto_colon_setjmp "执行非局部跳转：setjmp()
    和 longjmp()")）从*func*退出可能导致不可预测的结果——至少会导致程序内存泄漏。
- en: Example program
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 18-3](ch18.html#using_nftw_open_parenthesis_close_parent "Example 18-3. Using
    nftw() to walk a directory tree") demonstrates the use of *nftw()*.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例18-3](ch18.html#using_nftw_open_parenthesis_close_parent "示例18-3. 使用*nftw()*遍历目录树")演示了如何使用*nftw()*。'
- en: Example 18-3. Using *nftw()* to walk a directory tree
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 示例18-3. 使用*nftw()*遍历目录树
- en: '[PRE27]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The program in [Example 18-3](ch18.html#using_nftw_open_parenthesis_close_parent
    "Example 18-3. Using nftw() to walk a directory tree") displays an indented hierarchy
    of the filenames in a directory tree, one file per line, as well as the file type
    and i-node number. Command-line options can be used to specify settings for the
    *flags* argument used to call *nftw()*. The following shell session shows examples
    of what we see when we run this program. We first create a new empty subdirectory,
    which we populate with various types of files:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-3](ch18.html#using_nftw_open_parenthesis_close_parent "示例 18-3. 使用 nftw()
    遍历目录树")中的程序显示了目录树中文件名的缩进层级，每个文件一行，以及文件类型和i节点号。可以使用命令行选项来指定调用*nftw()*时使用的*flags*参数设置。以下
    shell 会话展示了我们运行此程序时的输出示例。我们首先创建一个新的空子目录，然后向其中添加各种类型的文件：'
- en: '[PRE28]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then use our program to invoke *nftw()* with a *flags* argument of 0:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用我们的程序调用*nftw()*，并传入一个*flags*参数为0：
- en: '[PRE29]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the above output, we can see that the symbolic link `s1` was resolved.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们可以看到符号链接`s1`已被解析。
- en: 'We then use our program to invoke *nftw()* with a *flags* argument containing
    `FTW_PHYS` and `FTW_DEPTH`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用我们的程序调用*nftw()*，并传入一个包含`FTW_PHYS`和`FTW_DEPTH`的*flags*参数：
- en: '[PRE30]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: From the above output, we can see that the symbolic link `s1` was not resolved.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中，我们可以看到符号链接`s1`没有被解析。
- en: The *nftw()* `FTW_ACTIONRETVAL` flag
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*nftw()*中的`FTW_ACTIONRETVAL`标志'
- en: 'Starting with version 2.3.3, *glibc* permits an additional, nonstandard flag
    to be specified in *flags*. This flag, `FTW_ACTIONRETVAL`, changes the way that
    *nftw()* interprets the return value from calls to *func()*. When this flag is
    specified, *func()* should return one of the following values:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本2.3.3开始，*glibc*允许在*flags*中指定一个额外的非标准标志。这个标志`FTW_ACTIONRETVAL`改变了*nftw()*对调用*func()*时返回值的解释。当指定此标志时，*func()*应该返回以下值之一：
- en: '`FTW_CONTINUE`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_CONTINUE`'
- en: Continue processing entries in the directory tree, as with the traditional 0
    return from *func()*.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 继续处理目录树中的条目，类似于*func()*返回的传统0值。
- en: '`FTW_SKIP_SIBLINGS`'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_SKIP_SIBLINGS`'
- en: Don’t process any further entries in the current directory; resume processing
    in the parent directory.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 不再处理当前目录中的其他条目；处理将在父目录中继续。
- en: '`FTW_SKIP_SUBTREE`'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_SKIP_SUBTREE`'
- en: If *pathname* is a directory (i.e., *typeflag* is `FTW_D`), then don’t call
    *func()* for entries under that directory. Processing resumes with the next sibling
    of this directory.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*pathname*是一个目录（即，*typeflag*是`FTW_D`），则不要对该目录下的条目调用*func()*。处理将从该目录的下一个兄弟目录继续。
- en: '`FTW_STOP`'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`FTW_STOP`'
- en: Don’t process any further entries in the directory tree, as with the traditional
    nonzero return from *func()*. The value `FTW_STOP` is returned to the caller of
    *nftw()*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 不再处理目录树中的其他条目，类似于*func()*返回的传统非零值。`FTW_STOP`值将返回给*nftw()*的调用者。
- en: The `_GNU_SOURCE` feature test macro must be defined in order to obtain the
    definition of `FTW_ACTIONRETVAL` from `<ftw.h>`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 必须定义`_GNU_SOURCE`功能测试宏，以便从`<ftw.h>`中获取`FTW_ACTIONRETVAL`的定义。
- en: The Current Working Directory of a Process
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程的当前工作目录
- en: A process’s *current working directory* defines the starting point for the resolution
    of relative pathnames referred to by the process. A new process inherits its current
    working directory from its parent.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的*当前工作目录*定义了相对路径名解析的起始点，进程引用的相对路径名将从此目录开始解析。新进程继承其父进程的当前工作目录。
- en: Retrieving the current working directory
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检索当前工作目录
- en: A process can retrieve its current working directory using *getcwd()*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以使用*getcwd()*检索其当前工作目录。
- en: '[PRE31]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns *cwdbuf* on success, or `NULL` on error
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回*cwdbuf*，错误时返回`NULL`
- en: The *getcwd()* function places a null-terminated string containing the absolute
    pathname of the current working directory into the allocated buffer pointed to
    by *cwdbuf*. The caller must allocate the *cwdbuf* buffer to be at least *size*
    bytes in length. (Normally, we would size *cwdbuf* using the `PATH_MAX` constant.)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*getcwd()*函数将当前工作目录的绝对路径名放入由*cwdbuf*指向的已分配缓冲区中，路径名以空字符结尾。调用者必须为*cwdbuf*分配至少*size*字节的内存空间。（通常，我们会使用`PATH_MAX`常量来设置*cwdbuf*的大小。）'
- en: On success, *getcwd()* returns a pointer to *cwdbuf* as its function result.
    If the pathname for the current working directory exceeds *size* bytes, then *getcwd()*
    returns `NULL`, with *errno* set to `ERANGE`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，*getcwd()*将*cwdbuf*的指针作为函数返回值。如果当前工作目录的路径名超出*size*字节，则*getcwd()*返回`NULL`，并将*errno*设置为`ERANGE`。
- en: On Linux/x86-32, *getcwd()* returns a maximum of 4096 (`PATH_MAX`) bytes. If
    the current working directory (and *cwdbuf* and *size*) exceeds this limit, then
    the pathname is silently truncated, removing complete directory prefixes from
    the *beginning* of the string (which is still null-terminated). In other words,
    we can’t use *getcwd()* reliably when the length of the absolute pathname for
    the current working directory exceeds this limit.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux/x86-32 上，*getcwd()* 返回最大 4096 字节（`PATH_MAX`）。如果当前工作目录（以及 *cwdbuf* 和
    *size*）超过此限制，则路径名会被静默截断，删除字符串*开头*的完整目录前缀（仍然是以 null 结尾）。换句话说，当当前工作目录的绝对路径名长度超过此限制时，我们不能可靠地使用
    *getcwd()*。
- en: Note
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In fact, the Linux *getcwd()* system call internally allocates a virtual memory
    page for the returned pathname. On the x86-32 architecture, the page size is 4096
    bytes, but on architectures with larger page sizes (e.g., Alpha with a page size
    of 8192 bytes), *getcwd()* can return larger pathnames.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Linux 的 *getcwd()* 系统调用在内部为返回的路径名分配了一个虚拟内存页面。在 x86-32 架构上，页面大小为 4096 字节，但在页面大小更大的架构上（例如，Alpha
    架构的页面大小为 8192 字节），*getcwd()* 可以返回更大的路径名。
- en: 'If the *cwdbuf* argument is `NULL` and *size* is 0, then the *glibc* wrapper
    function for *getcwd()* allocates a buffer as large as required and returns a
    pointer to that buffer as its function result. To avoid memory leaks, the caller
    must later deallocate this buffer with *free()*. Reliance on this feature should
    be avoided in portable applications. Most other implementations provide a simpler
    extension of the SUSv3 specification: if *cwdbuf* is `NULL`, then *getcwd()* allocates
    *size* bytes and uses this buffer to return the result to the caller. The *glibc
    getcwd()* implementation also provides this feature.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *cwdbuf* 参数为 `NULL` 且 *size* 为 0，则 *glibc* 为 *getcwd()* 的包装函数分配足够大的缓冲区，并将指向该缓冲区的指针作为函数结果返回。为了避免内存泄漏，调用者必须稍后使用
    *free()* 释放此缓冲区。应避免在可移植应用程序中依赖此功能。大多数其他实现提供了对 SUSv3 规范的更简单扩展：如果 *cwdbuf* 为 `NULL`，则
    *getcwd()* 会分配 *size* 字节，并使用此缓冲区将结果返回给调用者。*glibc getcwd()* 实现也提供了此功能。
- en: Note
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The GNU C library also provides two other functions for obtaining the current
    working directory. The BSD-derived *getwd(path)* function is vulnerable to buffer
    overruns, since it provides no method of specifying an upper limit for the size
    of the returned pathname. The *get_current_dir_name()* function returns a string
    containing the current working directory name as its function result. This function
    is easy to use, but it is not portable. For security and portability, *getcwd()*
    is preferred over these two functions (as long as we avoid using the GNU extensions).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C 库还提供了另外两个获取当前工作目录的函数。BSD 衍生的 *getwd(path)* 函数易受到缓冲区溢出的影响，因为它没有提供指定返回路径名大小上限的方法。*get_current_dir_name()*
    函数返回一个包含当前工作目录名称的字符串作为其函数结果。此函数易于使用，但不可移植。为了安全性和可移植性，*getcwd()* 比这两个函数更受推荐（只要我们避免使用
    GNU 扩展）。
- en: With suitable permissions (roughly, we own the process or have the `CAP_SYS_PTRACE`
    capability), we can determine the current working directory of any process by
    reading (*readlink()*) the contents of the Linux-specific `/proc/`*PID*`/cwd`
    symbolic link.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 具有适当权限（大致上，我们拥有进程或具有`CAP_SYS_PTRACE`能力）时，可以通过读取 (*readlink()*) Linux 特定的 `/proc/`*PID*`/cwd`
    符号链接的内容，确定任何进程的当前工作目录。
- en: Changing the current working directory
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改当前工作目录
- en: The *chdir()* system call changes the calling process’s current working directory
    to the relative or absolute pathname specified in *pathname* (which is dereferenced
    if it is a symbolic link).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*chdir()* 系统调用将调用进程的当前工作目录更改为 *pathname* 中指定的相对或绝对路径名（如果是符号链接，则会解引用该路径名）。'
- en: '[PRE32]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，失败时返回 -1
- en: The *fchdir()* system call does the same as *chdir()*, except that the directory
    is specified via a file descriptor previously obtained by opening the directory
    with *open()*.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*fchdir()* 系统调用与 *chdir()* 执行相同的操作，不同之处在于，目录是通过先前通过 *open()* 打开目录而获得的文件描述符来指定的。'
- en: '[PRE33]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回 0，失败时返回 -1
- en: 'We can use *fchdir()* to change the process’s current working directory to
    another location, and then later return to the original location, as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 *fchdir()* 将进程的当前工作目录更改为另一个位置，然后稍后返回原始位置，如下所示：
- en: '[PRE34]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The equivalent using *chdir()* is as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *chdir()* 等效的操作如下：
- en: '[PRE35]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Operating Relative to a Directory File Descriptor
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作相对于目录文件描述符
- en: Starting with kernel 2.6.16, Linux provides a range of new system calls that
    perform similar tasks to various traditional system calls, but provide additional
    functionality that is useful to some applications. These system calls are summarized
    in [Table 18-2](ch18.html#system_calls_that_use_a_directory_file_d "Table 18-2. System
    calls that use a directory file descriptor to interpret relative pathnames").
    We describe these system calls in this chapter because they provide variations
    on the traditional semantics of the process’s current working directory.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核版本 2.6.16 开始，Linux 提供了一系列新的系统调用，这些系统调用执行与传统系统调用相似的任务，但提供了额外的功能，这对某些应用程序非常有用。这些系统调用在[表
    18-2](ch18.html#system_calls_that_use_a_directory_file_d "表 18-2. 使用目录文件描述符解释相对路径名的系统调用")中进行了总结。我们在本章中描述这些系统调用，因为它们对进程当前工作目录的传统语义提供了变化。
- en: Table 18-2. System calls that use a directory file descriptor to interpret relative
    pathnames
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 表 18-2. 使用目录文件描述符解释相对路径名的系统调用
- en: '| New interface | Traditional analog | Notes |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 新接口 | 传统类比 | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *faccessat()* | *access()* | Supports `AT_EACCESS` and `AT_SYMLINK_NOFOLLOW`
    flags |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| *faccessat()* | *access()* | 支持 `AT_EACCESS` 和 `AT_SYMLINK_NOFOLLOW` 标志 |'
- en: '| *fchmodat()* | *chmod()* |   |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| *fchmodat()* | *chmod()* |   |'
- en: '| *fchownat()* | *chown()* | Supports `AT_SYMLINK_NOFOLLOW` flag |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| *fchownat()* | *chown()* | 支持 `AT_SYMLINK_NOFOLLOW` 标志 |'
- en: '| *fstatat()* | *stat()* | Supports `AT_SYMLINK_NOFOLLOW` flag |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| *fstatat()* | *stat()* | 支持 `AT_SYMLINK_NOFOLLOW` 标志 |'
- en: '| *linkat()* | *link()* | Supports (since Linux 2.6.18) `AT_SYMLINK_FOLLOW`
    flag |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| *linkat()* | *link()* | 支持（从 Linux 2.6.18 开始）`AT_SYMLINK_FOLLOW` 标志 |'
- en: '| *mkdirat()* | *mkdir()* |   |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| *mkdirat()* | *mkdir()* |   |'
- en: '| *mkfifoat()* | *mkfifo()* | Library function layered on top of `mknodat()`
    |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| *mkfifoat()* | *mkfifo()* | 该库函数是在 `mknodat()` 之上封装的 |'
- en: '| *mknodat()* | *mknod()* |   |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| *mknodat()* | *mknod()* |   |'
- en: '| *openat()* | *open()* |   |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| *openat()* | *open()* |   |'
- en: '| *readlinkat()* | *readlink()* |   |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| *readlinkat()* | *readlink()* |   |'
- en: '| *renameat()* | *rename()* |   |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| *renameat()* | *rename()* |   |'
- en: '| *symlinkat()* | *symlink()* |   |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| *symlinkat()* | *symlink()* |   |'
- en: '| *unlinkat()* | *unlink()* | Supports `AT_REMOVEDIR` flag |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| *unlinkat()* | *unlink()* | 支持 `AT_REMOVEDIR` 标志 |'
- en: '| *utimensat()* | *utimes()* | Supports `AT_SYMLINK_NOFOLLOW` flag |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| *utimensat()* | *utimes()* | 支持 `AT_SYMLINK_NOFOLLOW` 标志 |'
- en: 'In order to describe these system calls, we’ll use a specific example: *openat()*.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述这些系统调用，我们将使用一个特定的例子：*openat()*。
- en: '[PRE36]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Returns file descriptor on success, or -1 on error
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回文件描述符，出错时返回 -1
- en: 'The *openat()* system call is similar to the traditional *open()* system call,
    but adds an argument, *dirfd*, that is used as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*openat()* 系统调用类似于传统的 *open()* 系统调用，但增加了一个参数 *dirfd*，该参数的使用方式如下：'
- en: If *pathname* specifies a relative pathname, then it is interpreted relative
    to the directory referred to by the open file descriptor *dirfd*, rather than
    relative to the process’s current working directory.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *pathname* 指定了相对路径名，那么它会相对于由打开的文件描述符 *dirfd* 所指示的目录进行解释，而不是相对于进程的当前工作目录。
- en: If *pathname* specifies a relative pathname, and *dirfd* contains the special
    value `AT_FDCWD`, then *pathname* is interpreted relative to the process’s current
    working directory (i.e., the same behavior as *open(2)*).
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *pathname* 指定了一个相对路径名，并且 *dirfd* 包含特殊值 `AT_FDCWD`，那么 *pathname* 会相对于进程的当前工作目录进行解释（即，与
    *open(2)* 相同的行为）。
- en: If *pathname* specifies an absolute pathname, then *dirfd* is ignored.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *pathname* 指定了绝对路径名，则 *dirfd* 被忽略。
- en: The *flags* argument of *openat()* serves the same purpose as for *open()*.
    However, some of the system calls listed in [Table 18-2](ch18.html#system_calls_that_use_a_directory_file_d
    "Table 18-2. System calls that use a directory file descriptor to interpret relative
    pathnames") support a *flags* argument that is not provided by the corresponding
    traditional system call, and the purpose of this argument is to modify the semantics
    of the call. The most frequently provided flag is `AT_SYMLINK_NOFOLLOW`, which
    specifies that if *pathname* is a symbolic link, then the system call should operate
    on the link, rather than the file to which it refers. (The *linkat()* system call
    provides the `AT_SYMLINK_FOLLOW` flag, which performs the converse action, changing
    the default behavior of *linkat()* so that it dereferences *oldpath* if it is
    a symbolic link.) For details of the other flags, refer to the corresponding manual
    pages.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '*openat()* 的 *flags* 参数与 *open()* 中的作用相同。然而，[表18-2](ch18.html#system_calls_that_use_a_directory_file_d
    "表18-2. 使用目录文件描述符来解析相对路径名的系统调用") 中列出的一些系统调用支持 *flags* 参数，而传统系统调用中没有该参数，且该参数的目的是修改调用的语义。最常见的标志是
    `AT_SYMLINK_NOFOLLOW`，它指定如果 *pathname* 是符号链接，那么系统调用应对链接进行操作，而不是对其指向的文件进行操作。（*linkat()*
    系统调用提供了 `AT_SYMLINK_FOLLOW` 标志，执行相反的操作，改变 *linkat()* 的默认行为，使其在 *oldpath* 是符号链接时进行解引用。）有关其他标志的详细信息，请参阅相应的手册页。'
- en: 'The system calls listed in [Table 18-2](ch18.html#system_calls_that_use_a_directory_file_d
    "Table 18-2. System calls that use a directory file descriptor to interpret relative
    pathnames") are supported for two reasons (again, we explain using the example
    of *openat()*):'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[表18-2](ch18.html#system_calls_that_use_a_directory_file_d "表18-2. 使用目录文件描述符来解析相对路径名的系统调用")
    中列出的系统调用有两个原因被支持（我们再次以 *openat()* 为例解释）：'
- en: Using *openat()* allows an application to avoid certain race conditions that
    can occur when *open()* is used to open files in locations other than the current
    working directory. These races can occur because some component of the directory
    prefix of *pathname* could be changed in parallel with the *open()* call. By opening
    a file descriptor for the target directory, and passing that descriptor to *openat()*,
    such races can be avoided.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *openat()* 可以让应用程序避免使用 *open()* 在当前工作目录之外的其他位置打开文件时可能发生的某些竞态条件。这些竞态条件可能发生，因为*pathname*的某些目录前缀组件可能在与*open()*调用并行时发生变化。通过为目标目录打开一个文件描述符，并将该描述符传递给
    *openat()*，可以避免这种竞态条件。
- en: 'In [Chapter 29](ch29.html "Chapter 29. Threads: Introduction"), we’ll see that
    the working directory is a process attribute that is shared by all threads of
    the process. For some applications, it is useful for different threads to have
    different “virtual” working directories. An application can emulate this functionality
    using *openat()* in conjunction with directory file descriptors maintained by
    the application.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第29章](ch29.html "第29章. 线程：简介")中，我们将看到工作目录是一个进程属性，所有线程共享。对于某些应用程序，不同的线程拥有不同的“虚拟”工作目录是有用的。应用程序可以通过将
    *openat()* 与应用程序维护的目录文件描述符结合使用来模拟此功能。
- en: These system calls are not standardized in SUSv3, but are included in SUSv4\.
    In order to expose the declaration of each of these system calls, the `_XOPEN_SOURCE`
    feature test macro must be defined with a value greater than or equal to 700 before
    including the appropriate header file (e.g., `<fcntl.h>` for *open()*). Alternatively,
    the `_POSIX_C_SOURCE` macro can be defined with a value greater than or equal
    to 200809\. (Before *glibc* 2.10, the `_ATFILE_SOURCE` macro needed to be defined
    to expose the declarations of these system calls.)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统调用在SUSv3中没有标准化，但在SUSv4中被包含。为了暴露每个系统调用的声明，必须在包含适当的头文件（例如，`<fcntl.h>` 用于 *open()*)
    之前定义宏`_XOPEN_SOURCE`，并且其值大于或等于700。或者，也可以定义宏`_POSIX_C_SOURCE`，并且其值大于或等于200809。（在*glibc*
    2.10之前，需要定义宏`_ATFILE_SOURCE`来暴露这些系统调用的声明。）
- en: Note
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Solaris 9 and later provide versions of some of the interfaces listed in [Table 18-2](ch18.html#system_calls_that_use_a_directory_file_d
    "Table 18-2. System calls that use a directory file descriptor to interpret relative
    pathnames"), with slightly different semantics.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: Solaris 9及更高版本提供了[表18-2](ch18.html#system_calls_that_use_a_directory_file_d
    "表18-2. 使用目录文件描述符来解析相对路径名的系统调用")中列出的一些接口的版本，具有略微不同的语义。
- en: 'Changing the Root Directory of a Process: *chroot()*'
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变进程的根目录：*chroot()*
- en: Every process has a *root directory*, which is the point from which absolute
    pathnames (i.e., those beginning with /) are interpreted. By default, this is
    the real root directory of the file system. (A new process inherits its parent’s
    root directory.) On occasion, it is useful for a process to change its root directory,
    and a privileged (`CAP_SYS_CHROOT`) process can do this using the *chroot()* system
    call.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个 *根目录*，这是解释绝对路径名（即以 / 开头的路径名）的起点。默认情况下，这是文件系统的真实根目录。（新进程继承其父进程的根目录。）偶尔，一个进程更改其根目录是有用的，并且有特权（`CAP_SYS_CHROOT`）的进程可以使用
    *chroot()* 系统调用来实现这一点。
- en: '[PRE37]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 成功返回 0，错误返回 -1
- en: The *chroot()* system call changes the process’s root directory to the directory
    specified by *pathname* (which is dereferenced if it is a symbolic link). Thereafter,
    all absolute pathnames are interpreted as starting from that location in the file
    system. This is sometimes referred to as setting up a *chroot* jail, since the
    program is then confined to a particular area of the file system.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '*chroot()* 系统调用将进程的根目录更改为由 *pathname* 指定的目录（如果它是符号链接，则进行解引用）。此后，所有绝对路径名都被解释为从文件系统中的该位置开始。有时这被称为设置
    *chroot* 监狱，因为程序随后被限制在文件系统的特定区域内。'
- en: SUSv2 contained a specification for *chroot()* (marked LEGACY), but this was
    removed in SUSv3\. Nevertheless, *chroot()* appears on most UNIX implementations.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv2 包含了 *chroot()* 的规范（标记为 LEGACY），但在 SUSv3 中已移除。尽管如此，*chroot()* 出现在大多数 UNIX
    实现中。
- en: Note
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *chroot()* system call is employed by the *chroot* command, which enables
    us to execute shell commands in a *chroot* jail.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '*chroot()* 系统调用由 *chroot* 命令使用，它使我们能够在 *chroot* 监狱中执行 shell 命令。'
- en: The root directory of any process can be found by reading (*readlink()*) the
    contents of the Linux-specific `/proc/`*PID*`/root` symbolic link.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 任何进程的根目录可以通过读取（*readlink()*）Linux 特定的 `/proc/`*PID*`/root` 符号链接的内容找到。
- en: The classic example of the use of *chroot()* is in the *ftp* program. As a security
    measure, when a user logs in anonymously under FTP, the *ftp* program uses *chroot()*
    to set the root directory for the new process to the directory specifically reserved
    for anonymous logins. After the chroot() call, the user is limited to the file-system
    subtree under their new root directory, so they can’t roam around the entire file
    system. (This relies on the fact that the root directory is its own parent; that
    is, `/..` is a link to `/`, so that changing directory to `/` and then attempting
    a *cd ..* leaves the user in the same directory.)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '*chroot()* 的经典应用示例是在 *ftp* 程序中。作为安全措施，当用户以匿名方式登录 FTP 时，*ftp* 程序使用 *chroot()*
    将新进程的根目录设置为专门为匿名登录保留的目录。在执行 chroot() 调用后，用户被限制在其新根目录下的文件系统子树中，因此不能在整个文件系统中漫游。（这依赖于根目录是其自身的父目录的事实；也就是说，`/..`
    是指向 `/` 的链接，因此改变到 `/` 然后尝试 *cd ..* 将会让用户留在同一目录。）'
- en: Note
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some UNIX implementations (but not Linux) allow multiple hard links to a directory,
    so that it is possible to create a hard link within a subdirectory to its parent
    (or a further removed ancestor). On implementations permitting this, the presence
    of a hard link that reaches outside the jail directory tree compromises the jail.
    Symbolic links to directories outside the jail don’t pose a problem—because they
    are interpreted within the framework of the process’s new root directory, they
    can’t reach outside the *chroot* jail.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 UNIX 实现（但不包括 Linux）允许一个目录有多个硬链接，因此可以在子目录中创建一个硬链接到其父目录（或进一步移除的祖先）。在允许此操作的实现中，存在一条硬链接超出监狱目录树的情况会破坏监狱的安全性。指向监狱外部目录的符号链接不会构成问题——因为它们在进程新根目录的框架内解释，它们无法达到
    *chroot* 监狱之外。
- en: Normally, we can’t execute arbitrary programs within a *chroot* jail. This is
    because most programs are dynamically linked against shared libraries. Therefore,
    we must either limit ourselves to executing statically linked programs, or replicate
    a standard set of system directories containing shared libraries (including, for
    example, `/lib` and `/usr/lib`) within the jail (in this regard, the bind mount
    feature described in [Bind Mounts](ch14.html#bind_mounts "Bind Mounts") can be
    useful).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们不能在 *chroot* 监狱中执行任意程序。这是因为大多数程序是动态链接到共享库的。因此，我们必须限制自己只能执行静态链接的程序，或者在监狱中复制包含共享库的标准系统目录集合（例如
    `/lib` 和 `/usr/lib`）（在这方面，文中描述的绑定挂载功能在 [绑定挂载](ch14.html#bind_mounts "Bind Mounts")
    中可能是有用的）。
- en: The *chroot()* system call was not conceived as a completely secure jail mechanism.
    To begin with, there are various ways in which a privileged program can subsequently
    use a further *chroot()* call to break out of the jail. For example, a privileged
    (`CAP_MKNOD`) program can use *mknod()* to create a memory device file (similar
    to `/dev/mem`) giving access to the contents of RAM, and, from that point, anything
    is possible. In general, it is advisable not to include set-user-ID-*root* programs
    within a *chroot* jail file system.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*chroot()*系统调用最初并不是作为一个完全安全的监狱机制设计的。首先，有多种方式，特权程序可以利用进一步的*chroot()*调用突破监狱。例如，一个特权程序（`CAP_MKNOD`）可以使用*mknod()*创建一个内存设备文件（类似于`/dev/mem`），从而访问RAM的内容，从那时起，一切皆有可能。一般来说，建议不要在*chroot*监狱文件系统中包含set-user-ID-*root*程序。'
- en: 'Even with unprivileged programs, we must take care to prevent the following
    possible routes for breaking out of a *chroot* jail:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是非特权程序，我们也必须小心防止以下可能的路径导致突破*chroot*监狱：
- en: Calling *chroot()* doesn’t change the process’s current working directory. Thus,
    a call to *chroot()* is typically preceded or followed by a call to *chdir()*
    (e.g., *chdir*(“/”) after the *chroot()* call). If this is not done, then a process
    can use relative pathnames to access files and directories outside the jail. (Some
    BSD derivatives prevent this possibility—if the current working directory lies
    outside the new root directory tree, then it is changed by the *chroot()* call
    to be the same as the root directory.)
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用*chroot()*不会改变进程的当前工作目录。因此，*chroot()*调用通常会前后紧跟着*chdir()*调用（例如，*chdir*(“/”)在*chroot()*调用之后）。如果没有执行此操作，进程可以使用相对路径名访问监狱外的文件和目录。（一些BSD派生系统防止了这种可能性——如果当前工作目录位于新根目录树之外，则*chroot()*调用会将其更改为与根目录相同。）
- en: 'If a process holds an open file descriptor for a directory outside the jail,
    then the combination of *fchdir()* plus *chroot()* can be used to break out of
    the jail, as shown in the following code sample:'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个进程持有指向监狱外目录的打开文件描述符，则可以结合使用*fchdir()*和*chroot()*来突破监狱，如以下代码示例所示：
- en: '[PRE38]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To prevent this possibility, we must close all open file descriptors referring
    to directories outside the jail. (Some other UNIX implementations provide the
    *fchroot()* system call, which can be used to achieve a similar result to the
    above code snippet.)
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了防止这种情况，我们必须关闭所有指向监狱外部目录的打开文件描述符。（其他一些UNIX实现提供了*fchroot()*系统调用，可以用来实现与上述代码片段相似的效果。）
- en: Even preventing the preceding possibilities is insufficient to stop an arbitrary
    unprivileged program (i.e., one whose operation we don’t have control over) from
    breaking out of the jail. The jailed process can still use a UNIX domain socket
    to receive a file descriptor (from another process) referring to a directory outside
    the jail. (We briefly explain the concept of passing file descriptors between
    processes via a socket in [Passing File Descriptors](ch61.html#passing_file_descriptors
    "Passing File Descriptors").) By specifying this file descriptor in a call to
    *fchdir()*, the program can set its current working directory outside the jail
    and then access arbitrary files and directories using relative pathnames.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即便防止了前述的可能性，也不足以阻止一个任意的非特权程序（即我们无法控制其操作的程序）从监狱中逃脱。被监禁的进程仍然可以使用UNIX域套接字接收一个文件描述符（来自另一个进程），该描述符指向监狱外的目录。（我们将在[传递文件描述符](ch61.html#passing_file_descriptors
    "Passing File Descriptors")中简要解释通过套接字在进程间传递文件描述符的概念。）通过在对*fchdir()*的调用中指定该文件描述符，程序可以将当前工作目录设置到监狱外，并使用相对路径名访问任意文件和目录。
- en: Note
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some BSD derivatives provide a *jail()* system call, which addresses the points
    described above, as well as several others, to create a jail that is secure even
    for a privileged process.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 一些BSD派生系统提供了一个*jail()*系统调用，它解决了上面描述的问题以及其他一些问题，可以创建一个即使对特权进程也安全的监狱环境。
- en: 'Resolving a Pathname: *realpath()*'
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析路径名：*realpath()*
- en: The *realpath()* library function dereferences all symbolic links in *pathname*
    (a null-terminated string) and resolves all references to /. and /.. to produce
    a null-terminated string containing the corresponding absolute pathname.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '*realpath()*库函数会解引用*pathname*（一个以空字符结尾的字符串）中的所有符号链接，并解析所有对/.和/..的引用，以生成一个包含相应绝对路径名的以空字符结尾的字符串。'
- en: '[PRE39]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to resolved pathname on success, or `NULL` on error
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回指向解析后的路径名的指针，出错时返回`NULL`。
- en: The resulting string is placed in the buffer pointed to by *resolved_path*,
    which should be a character array of at least `PATH_MAX` bytes. On success, *realpath()*
    also returns a pointer to this resolved string.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 结果字符串将被放置在 *resolved_path* 指向的缓冲区中，该缓冲区应至少为 `PATH_MAX` 字节的字符数组。在成功的情况下，*realpath()*
    还会返回指向该解析字符串的指针。
- en: The *glibc* implementation of *realpath()* allows the caller to specify *resolved_path*
    as `NULL`. In this case, *realpath()* allocates a buffer of up to `PATH_MAX` bytes
    for the resolved pathname and returns a pointer to that buffer as the function
    result. (The caller must deallocate this buffer using *free()*.) SUSv3 doesn’t
    specify this extension, but it is specified in SUSv4.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '*glibc* 实现的 *realpath()* 允许调用者将 *resolved_path* 指定为 `NULL`。在这种情况下，*realpath()*
    为解析后的路径名分配最多 `PATH_MAX` 字节的缓冲区，并将该缓冲区的指针作为函数结果返回。（调用者必须使用 *free()* 释放该缓冲区。）SUSv3
    没有指定这一扩展，但在 SUSv4 中有所规定。'
- en: 'The program in [Example 18-4](ch18.html#read_and_resolve_a_symbolic_link "Example 18-4. Read
    and resolve a symbolic link") uses *readlink()* and *realpath()* to read the contents
    of a symbolic link and to resolve the link to an absolute pathname. Here is an
    example of the use of this program:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-4](ch18.html#read_and_resolve_a_symbolic_link "示例 18-4. 读取并解析符号链接")
    中的程序使用 *readlink()* 和 *realpath()* 读取符号链接的内容，并将链接解析为绝对路径名。以下是此程序使用的示例：'
- en: '[PRE40]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Example 18-4. Read and resolve a symbolic link
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 18-4. 读取并解析符号链接
- en: '[PRE41]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Parsing Pathname Strings: *dirname()* and *basename()*'
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析路径名字符串：*dirname()* 和 *basename()*
- en: The *dirname()* and *basename()* functions break a pathname string into directory
    and filename parts. (These functions perform a similar task to the *dirname(1)*
    and *basename(1)* commands.)
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '*dirname()* 和 *basename()* 函数将路径名字符串分解为目录和文件名部分。（这些函数执行的任务与 *dirname(1)* 和
    *basename(1)* 命令类似。）'
- en: '[PRE42]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return a pointer to a null-terminated (and possibly statically allocated)
    string
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都返回指向空字符终止（且可能是静态分配的）字符串的指针。
- en: For example, given the pathname `/home/britta/prog.c`, *dirname()* returns `/home/britta`
    and *basename()* returns `prog.c`. Concatenating the string returned by *dirname()*,
    a slash (`/`), and the string returned by *basename()* yields a complete pathname.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定路径名 `/home/britta/prog.c`，*dirname()* 返回 `/home/britta`，而 *basename()*
    返回 `prog.c`。将 *dirname()* 返回的字符串、一个斜杠（`/`）和 *basename()* 返回的字符串连接起来，即可得到完整的路径名。
- en: 'Note the following points regarding the operation of *dirname()* and *basename()*:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下有关 *dirname()* 和 *basename()* 操作的几点：
- en: Trailing slash characters in *pathname* are ignored.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*pathname* 中的尾部斜杠字符会被忽略。'
- en: If *pathname* doesn’t contain a slash, then *dirname()* returns the string `.`
    (dot) and *basename()* returns *pathname*.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *pathname* 不包含斜杠，则 *dirname()* 返回字符串 `.`（点），而 *basename()* 返回 *pathname*。
- en: If *pathname* consists of just a slash, then both *dirname()* and *basename()*
    return the string `/`. Applying the concatenation rule above to create a pathname
    from these returned strings would yield the string `///`. This *is* a valid pathname.
    Because multiple consecutive slashes are equivalent to a single slash, the pathname
    `///` is equivalent to the pathname `/`.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *pathname* 仅由一个斜杠组成，则 *dirname()* 和 *basename()* 都返回字符串 `/`。按照上述的连接规则，用这些返回的字符串创建路径名将得到字符串
    `///`。这*是*一个有效的路径名。因为多个连续的斜杠等价于一个斜杠，所以路径名 `///` 等同于路径名 `/`。
- en: If *pathname* is a `NULL` pointer or an empty string, then both *dirname()*
    and *basename()* return the string `.` (dot). (Concatenating these strings yields
    the pathname `./.`, which is equivalent to `.`, the current directory.)
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *pathname* 是 `NULL` 指针或空字符串，则 *dirname()* 和 *basename()* 都返回字符串 `.`（点）。（将这些字符串连接起来得到路径名
    `./.`，其等价于当前目录 `.`。）
- en: '[Table 18-3](ch18.html#examples_of_strings_returned_by_dirname "Table 18-3. Examples
    of strings returned by dirname() and basename()") shows the strings returned by
    *dirname()* and *basename()* for various example pathnames.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 18-3](ch18.html#examples_of_strings_returned_by_dirname "表 18-3. *dirname()*
    和 *basename()* 返回的字符串示例") 显示了对于各种示例路径名，*dirname()* 和 *basename()* 返回的字符串。'
- en: Table 18-3. Examples of strings returned by *dirname()* and *basename()*
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 表 18-3. *dirname()* 和 *basename()* 返回的字符串示例
- en: '| Pathname string | *dirname()* | *basename()* |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| 路径名字符串 | *dirname()* | *basename()* |'
- en: '| --- | --- | --- |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `/` | `/` | `/` |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `/` | `/` | `/` |'
- en: '| `/usr/bin/zip` | `/usr/bin` | `zip` |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| `/usr/bin/zip` | `/usr/bin` | `zip` |'
- en: '| `/etc/passwd////` | `/etc` | `passwd` |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| `/etc/passwd////` | `/etc` | `passwd` |'
- en: '| `/etc////passwd` | `/etc` | `passwd` |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| `/etc////passwd` | `/etc` | `passwd` |'
- en: '| `etc/passwd` | `etc` | `passwd` |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| `etc/passwd` | `etc` | `passwd` |'
- en: '| `passwd` | `.` | `passwd` |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| `passwd` | `.` | `passwd` |'
- en: '| `passwd/` | `.` | `passwd` |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| `passwd/` | `.` | `passwd` |'
- en: '| `..` | `.` | `..` |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| `..` | `.` | `..` |'
- en: '| `NULL` | `.` | `.` |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| `NULL` | `.` | `.` |'
- en: Example 18-5. Using *dirname()* and *basename()*
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 18-5. 使用 *dirname()* 和 *basename()*
- en: '[PRE43]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Both *dirname()* and *basename()* may modify the string pointed to by *pathname*.
    Therefore, if we wish to preserve a pathname string, we must pass copies of it
    to *dirname()* and *basename()*, as shown in [Example 18-5](ch18.html#using_dirname_open_parenthesis_close_par
    "Example 18-5. Using dirname() and basename()") (page 371). This program uses
    *strdup()* (which calls *malloc()*) to make copies of the strings to be passed
    to *dirname()* and *basename()*, and then uses *free()* to deallocate the duplicate
    strings.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '*dirname()* 和 *basename()* 可能会修改 *pathname* 所指向的字符串。因此，如果我们希望保留一个路径名字符串，我们必须将其副本传递给
    *dirname()* 和 *basename()*，如 [示例 18-5](ch18.html#using_dirname_open_parenthesis_close_par
    "示例 18-5. 使用 dirname() 和 basename()")（第 371 页）所示。此程序使用 *strdup()*（它调用 *malloc()*）来制作要传递给
    *dirname()* 和 *basename()* 的字符串副本，然后使用 *free()* 来释放这些副本字符串。'
- en: Finally, note that both *dirname()* and *basename()* can return pointers to
    statically allocated strings that may be modified by future calls to the same
    functions.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意 *dirname()* 和 *basename()* 都可以返回指向静态分配字符串的指针，这些字符串可能会被未来对同一函数的调用修改。
- en: Summary
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: An i-node doesn’t contain a file’s name. Instead, files are assigned names via
    entries in directories, which are tables listing filename and i-node number correspondences.
    These directory entries are called (hard) links. A file may have multiple links,
    all of which enjoy equal status. Links are created and removed using *link()*
    and *unlink()*. A file can be renamed using the *rename()* system call.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 i-node 不包含文件名。相反，文件通过目录中的条目来分配名称，这些条目是列出文件名和 i-node 编号对应关系的表格。这些目录条目被称为（硬）链接。一个文件可以有多个链接，所有这些链接具有相同的地位。链接是通过
    *link()* 和 *unlink()* 创建和删除的。一个文件可以使用 *rename()* 系统调用进行重命名。
- en: 'A symbolic (or soft) link is created using *symlink()*. Symbolic links are
    similar to hard links in some respects, with the differences that symbolic links
    can cross file-system boundaries and can refer to directories. A symbolic link
    is just a file containing the name of another file; this name may be retrieved
    using *readlink()*. A symbolic link is not included in the (target) i-node’s link
    count, and it may be left dangling if the filename to which it refers is removed.
    Some system calls automatically dereference (follow) symbolic links; others do
    not. In some cases, two versions of a system call are provided: one that dereferences
    symbolic links and another that does not. Examples are *stat()* and *lstat()*.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *symlink()* 创建符号（或软）链接。符号链接在某些方面类似于硬链接，但不同之处在于，符号链接可以跨越文件系统边界并可以引用目录。符号链接只是一个包含另一个文件名称的文件；这个名称可以通过
    *readlink()* 获取。符号链接不包含在（目标）i-node 的链接计数中，如果它所指向的文件名被删除，符号链接可能会变成悬挂状态。某些系统调用会自动解引用（跟随）符号链接；而其他系统调用则不会。在某些情况下，提供了两种版本的系统调用：一种解引用符号链接，另一种则不解引用。示例包括
    *stat()* 和 *lstat()*。
- en: Directories are created with *mkdir()* and removed using *rmdir()*. To scan
    the contents of a directory, we can use *opendir()*, *readdir()*, and related
    functions. The *nftw()* function allows a program to walk an entire directory
    tree, calling a programmer-defined function to operate on each file in the tree.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 目录通过 *mkdir()* 创建，使用 *rmdir()* 删除。要扫描目录内容，我们可以使用 *opendir()*、*readdir()* 和相关函数。*nftw()*
    函数允许程序遍历整个目录树，调用程序定义的函数对树中的每个文件进行操作。
- en: The *remove()* function can be used to remove a file (i.e., a link) or an empty
    directory.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '*remove()* 函数可用于删除文件（即，链接）或空目录。'
- en: Each process has a root directory, which determines the point from which absolute
    pathnames are interpreted, and a current working directory, which determines the
    point from which relative pathnames are interpreted. The *chroot()* and *chdir()*
    system calls are used to change these attributes. The *getcwd()* function returns
    a process’s current working directory.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个根目录，它决定了绝对路径名的解释起点，还有一个当前工作目录，它决定了相对路径名的解释起点。*chroot()* 和 *chdir()*
    系统调用用于更改这些属性。*getcwd()* 函数返回进程的当前工作目录。
- en: Linux provides a set of system calls (e.g., *openat()*) that behave like their
    traditional counterparts (e.g., *open()*), except that relative pathnames can
    be interpreted with respect to the directory specified by a file descriptor supplied
    to the call (instead of using the process’s current working directory). This is
    useful for avoiding certain types of race conditions and for implementing per-thread
    virtual working directories.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: Linux提供了一组系统调用（例如，*openat()*），它们的行为类似于传统的对等函数（例如，*open()*），但相对路径名可以根据传递给调用的文件描述符指定的目录进行解释（而不是使用进程的当前工作目录）。这对于避免某些类型的竞争条件以及实现每个线程的虚拟工作目录非常有用。
- en: The *realpath()* function resolves a pathname—dereferencing all symbolic links
    and resolving all references to . and .. to corresponding directories—to yield
    a corresponding absolute pathname. The *dirname()* and *basename()* functions
    can be used to parse a pathname into directory and filename components.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '*realpath()*函数解析一个路径名——取消所有符号链接并解析所有对`.`和`..`的引用为相应的目录——从而生成一个对应的绝对路径名。*dirname()*和*basename()*函数可以用来将路径名解析为目录和文件名组件。'
- en: Exercises
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'In [The *open() flags* Argument](ch04.html#the_open_open_parenthesis_close_parenthe
    "The open() flags Argument"), we noted that it is not possible to open a file
    for writing if it is currently being executed (*open()* returns -1, with *errno*
    set to `ETXTBSY`). Nevertheless, it is possible to do the following from the shell:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[《*open() 标志* 参数》](ch04.html#the_open_open_parenthe "The open() flags Argument")中，我们注意到，如果文件正在被执行，则无法打开它进行写入（*open()*返回-1，并且*errno*被设置为`ETXTBSY`）。然而，从shell中可以执行以下操作：
- en: '[PRE44]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The last command overwrites the existing executable of the same name. How is
    this possible? (For a clue, use *ls -li* to look at the i-node number of the executable
    file after each compilation.)
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一条命令覆盖了同名的现有可执行文件。怎么做到的呢？（提示：使用*ls -li*查看每次编译后可执行文件的i节点号。）
- en: Why does the call to *chmod()* in the following code fail?
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么下面代码中的*chmod()*调用会失败？
- en: '[PRE45]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Implement *realpath()*.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现*realpath()*。
- en: Modify the program in [Example 18-2](ch18.html#scanning_a_directory "Example 18-2. Scanning
    a directory") (`list_files.c`) to use *readdir_r()* instead of *readdir()*.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例18-2](ch18.html#scanning_a_directory "Example 18-2. 扫描目录")（`list_files.c`）中的程序，使用*readdir_r()*代替*readdir()*。
- en: Implement a function that performs the equivalent of *getcwd()*. A useful tip
    for solving this problem is that you can find the name of the current working
    directory by using *opendir()* and *readdir()* to walk through each of the entries
    in the parent directory (`..`) to find an entry with the same i-node and device
    number as the current working directory (i.e., respectively, the *st_ino* and
    *st_dev* fields in the *stat* structure returned by *stat()* and *lstat()*). Thus,
    it is possible to construct the directory path by walking up the directory tree
    (*chdir(“..”)*) one step at a time and performing such scans. The walk can be
    finished when the parent directory is the same as the current working directory
    (recall that `/..` is the same as `/`). The caller should be left in the same
    directory in which it started, regardless of whether your *getcwd()* function
    succeeds or fails (*open()* plus *fchdir()* are handy for this purpose).
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个功能，执行与*getcwd()*等效的操作。解决此问题的一个有用提示是，你可以通过使用*opendir()*和*readdir()*遍历父目录（`..`）中的每个条目，找到与当前工作目录具有相同i节点和设备号的条目（即分别是*stat()*和*lstat()*返回的*st_ino*和*st_dev*字段）。因此，可以通过逐步向上走目录树（*chdir(“..”)*）并进行这种扫描来构建目录路径。当父目录与当前工作目录相同（回想一下，`/..`与`/`是相同的）时，可以结束扫描。调用者应保持在其启动时所在的目录，不管你的*getcwd()*函数是否成功或失败（*open()*加上*fchdir()*对于此目的非常有用）。
- en: Modify the program in [Example 18-3](ch18.html#using_nftw_open_parenthesis_close_parent
    "Example 18-3. Using nftw() to walk a directory tree") (`nftw_dir_tree.c`) to
    use the `FTW_DEPTH` flag. Note the difference in the order in which the directory
    tree is traversed.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改[示例18-3](ch18.html#using_nftw_open_parenthesis_close_parent "Example 18-3.
    使用nftw()遍历目录树")（`nftw_dir_tree.c`）中的程序，使用`FTW_DEPTH`标志。注意目录树遍历顺序的不同。
- en: Write a program that uses *nftw()* to traverse a directory tree and finishes
    by printing out counts and percentages of the various types (regular, directory,
    symbolic link, and so on) of files in the tree.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，使用*nftw()*遍历目录树，最后打印出树中各种类型（常规文件、目录、符号链接等）的文件数量和百分比。
- en: Implement *nftw()*. (This will require the use of the *opendir()*, *readdir()*,
    *closedir()*, and *stat()* system calls, among others.)
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现*nftw()*。（这将需要使用*opendir()*、*readdir()*、*closedir()*、*stat()*等系统调用。）
- en: In [The Current Working Directory of a Process](ch18.html#the_current_working_directory_of_a_proce
    "The Current Working Directory of a Process"), we showed two different techniques
    (using *fchdir()* and *chdir()*, respectively) to return to the previous current
    working directory after changing the current working directory to another location.
    Suppose we are performing such an operation repeatedly. Which method do you expect
    to be more efficient? Why? Write a program to confirm your answer.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[进程的当前工作目录](ch18.html#the_current_working_directory_of_a_proce "进程的当前工作目录")中，我们展示了两种不同的技术（分别使用*fchdir()*和*chdir()*）来在将当前工作目录更改为另一个位置后返回到之前的当前工作目录。假设我们正在重复执行这样的操作。你认为哪种方法效率更高？为什么？编写一个程序以确认你的答案。
