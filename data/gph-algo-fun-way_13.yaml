- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MINIMUM
    SPANNING TREES</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">最小生成树</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: The *minimum spanning tree* of a weighted, undirected graph is the set of edges
    with the smallest total weight that connects all the nodes. We can use this concept
    to model and optimize a variety of real-world problems, from designing power grids
    to hypothesizing how chipmunks should be constructing their burrows.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 加权无向图的*最小生成树*是连接所有节点的边集，并且具有最小的总权重。我们可以用这一概念来建模和优化多种现实世界中的问题，从设计电网到推测松鼠应该如何构建它们的洞穴。
- en: This chapter introduces two classical algorithms for constructing minimum spanning
    trees. Prim’s algorithm is a nodewise agglomerative algorithm that builds a bigger
    and bigger set of connected nodes. Kruskal’s algorithm constructs a minimum spanning
    tree from a sorted list of edges by adding one edge at a time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了构建最小生成树的两种经典算法。普里姆算法是一种逐步聚合的节点算法，它通过构建越来越大的连接节点集合来实现。克鲁斯卡尔算法通过从排序后的边列表中逐一添加边来构建最小生成树。
- en: 'After discussing how minimum spanning trees can be applied to several real-world
    problems, we consider two additional algorithms closely related to minimum spanning
    trees: grid-based maze generation and single- linkage clustering. We show how
    these tasks can be mapped into graph problems and solved using variations of the
    algorithms from this chapter.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论最小生成树如何应用于多个现实世界问题之后，我们考虑与最小生成树紧密相关的另外两个算法：基于网格的迷宫生成和单连接聚类。我们展示了这些任务如何映射为图问题，并通过本章的算法变种进行求解。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Structure of Minimum Spanning
    Trees</samp>'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">最小生成树的结构</samp>'
- en: A *spanning tree* of a graph is a set of edges that connects all the nodes in
    the graph without forming any cycles. We can visualize spanning trees as the backbone
    of a real-world infrastructure network—the minimum connections needed to make
    every node reachable from any other node. These might be power lines, roads, links
    in a computer network, or the tunnels between holes in a chipmunk burrow. The
    *minimum spanning tree* is the set of edges that connect all the nodes while minimizing
    the sum of the edge weights.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图的*生成树*是连接图中所有节点的边集，并且不形成任何环。我们可以将生成树想象为现实世界基础设施网络的骨干——连接每个节点的最少连接，使得任何节点都可以从其他节点到达。这些可能是电力线、道路、计算机网络中的链接，或者是松鼠洞穴中的通道。*最小生成树*是连接所有节点的边集，同时最小化边权的总和。
- en: We can picture these requirements in terms of an especially well-organized chipmunk’s
    burrow, as shown in [Figure 10-1](#fig10-1). The chipmunk constructs their domain
    as a series of holes (nodes) linked by tunnels (edges). As in a graph, each tunnel
    directly links exactly two holes in a straight line. The chipmunk imposes two
    additional requirements. First, each hole to the surface needs to be reachable
    through its tunnels from any other hole. After all, what good are multiple entrances
    if they don’t let you vanish into one and pop out of another? Second, the total
    distances of tunnels must be minimized. The chipmunk is lazy and would prefer
    to expend its energy randomly popping out of the ground at various points rather
    than digging new tunnels.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个特别有组织的松鼠洞穴来形象化这些要求，如[图 10-1](#fig10-1)所示。松鼠将它们的领域构建为一系列通过隧道（边）连接的洞穴（节点）。就像在图中一样，每条隧道直接连接着两个洞穴，并且是一条直线。松鼠设定了两个额外的要求。首先，每个洞穴到地表需要通过隧道从任何其他洞穴到达。毕竟，如果多个入口不能让你从一个洞口消失然后从另一个洞口出来，那还有什么用呢？其次，隧道的总距离必须最小化。松鼠很懒，宁愿随机地在不同地点从地面冒出来，而不愿挖新的隧道。
- en: '![a graph with five nodes and four edges, arranged on a 2D plane.](../images/f10001.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含五个节点和四条边的图，排列在一个二维平面上。](../images/f10001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: Five chipmunk
    holes connected as a minimum spanning tree</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-1: 五个松鼠洞穴连接成最小生成树</samp>'
- en: 'Formally we define the problem of finding the minimum spanning tree in a weighted,
    undirected graph as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正式定义，在一个加权无向图中寻找最小生成树的问题如下：
- en: Given a graph with a set of nodes *V* and edges *E*, find the set of edges *E*′
    ⊆ *E* that connects every node in *V* while minimizing the sum of edge weights
    *∑*e [∈] E[′] *weight*(*e*)*.*
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个由节点 *V* 和边 *E* 组成的图，找到一个边集 *E*′ ⊆ *E*，它连接图中每个节点，同时最小化边权重的总和 *∑*e [∈] E[′]
    *weight*(*e*)*。
- en: By definition, the minimum spanning tree will have |*V* | – 1 edges, the minimum
    number needed to connect |*V* | nodes. Any more edges would add cycles and unnecessary
    weight.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 按照定义，最小生成树将拥有|*V*| – 1条边，这是连接|*V*|个节点所需的最少边数。任何更多的边都会产生环路和不必要的重量。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用案例</samp>
- en: This section introduces a few real-world examples of using the minimum spanning
    tree concept to design cost-efficient physical networks or optimize communications
    in a social network.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一些使用最小生成树概念设计高效物理网络或优化社交网络通信的实际案例。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Physical Networks</samp>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">物理网络</samp>'
- en: Minimum spanning trees are useful in determining the minimum cost set of links
    that we need to build to fully connect a physical network. Imagine that the Algorithmic
    Coffee Shop Company is looking to build a state-of-the-art pneumatic tube system
    for delivering beans between its locations. After promising to serve over 10,000
    varieties of coffee, the company quickly realizes that it lacks the storage space
    in some locations to keep such a vast variety on hand. Instead, it decides to
    build a central warehouse and ship small packets of beans to each store as needed.
    Every store will now boast an unparalleled selection.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最小生成树在确定我们需要构建的、以最低成本完全连接物理网络的链接集时非常有用。想象一下，算法咖啡公司计划为其各个地点之间传送咖啡豆构建一套最先进的气动管道系统。在承诺提供超过10,000种咖啡后，公司很快意识到一些地点缺乏足够的存储空间来存放如此多种类的咖啡豆。因此，公司决定建立一个中央仓库，根据需求将少量咖啡豆运送到每个商店。每个商店现在将拥有无与伦比的咖啡选择。
- en: The planners quickly realize that it is prohibitively expensive to build pneumatic
    tubes from every store to the warehouse. The two stores in Javaville are each
    located over 10 miles from the distribution center, but only two blocks from each
    other. It is much cheaper to build a single tube from the distribution center
    to the Main Street location and then a second tube from Main Street to the Coffee
    Boulevard location. A request for the Coffee Boulevard location can be satisfied
    by first sending the beans to the Main Street location and then forwarding them
    to Coffee Boulevard.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 规划人员很快意识到，从每个商店到仓库建立气动管道的费用过高。位于Javaville的两家商店距离配送中心超过10英里，但彼此相隔仅两个街区。通过从配送中心到Main
    Street位置再到Coffee Boulevard位置建立一条管道要便宜得多。对Coffee Boulevard位置的请求可以通过先将咖啡豆发送到Main
    Street位置，然后再转发到Coffee Boulevard来满足。
- en: This multistep routing turns the design of the pneumatic delivery system into
    a minimum spanning tree problem, as shown in [Figure 10-2](#fig10-2). Each of
    the Algorithmic Coffee Shop Company’s buildings is a node and each potential tube
    between any pair is an edge.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种多步骤路由将气动传递系统的设计转化为一个最小生成树问题，如[图 10-2](#fig10-2)所示。算法咖啡公司每个建筑物都是一个节点，任何一对商店之间的潜在管道都是一条边。
- en: '![A city map with three vertical streets and two horizontal streets. Two boxes
    represent café locations with one on the first vertical street (Coffee Boulevard)
    and the other on the right portion of the bottom horizontal street (main Street).
    An edge joins the two cafés and an arrow points from one to off the map with a
    label “To distribution Center”.](../images/f10002.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![一张城市地图，上面有三条垂直街道和两条水平街道。两家咖啡店的位置分别位于第一条垂直街道（Coffee Boulevard）和底部水平街道的右侧部分（Main
    Street）。两家咖啡店之间有一条边，箭头指向图外，标注为“前往配送中心”。](../images/f10002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: Two coffee shops
    on a minimum spanning tree delivery network</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-2：最小生成树交付网络中的两家咖啡店</samp>
- en: In [Figure 10-2](#fig10-2), the weight of an edge is the cost it would take
    to build the pneumatic tube between the two buildings. While often a factor of
    distance, the cost can also increase due to environmental factors. For example,
    building a tube that cuts through the center of a city is much more expensive
    than the same length tube under a farm. The planners need to find the set of edges
    (tubes to construct) that connects all the buildings while minimizing the cost.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图10-2](#fig10-2)中，边的权重是建造两栋建筑之间气动管道的成本。虽然通常与距离有关，但成本也可能因环境因素而增加。例如，在城市中心修建一条管道比在农田下修建相同长度的管道要昂贵得多。规划者需要找到一组边（需要建造的管道），以便连接所有建筑物并最小化成本。
- en: 'Aside from pneumatic coffee tubes, more typical applications of minimum-cost
    spanning trees to physical networks include the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了气动咖啡管外，最典型的最小成本生成树在物理网络中的应用包括以下几种：
- en: '**Constructing highways **Nodes are cities, edges are highways, and edge weight
    is the cost to construct a highway between two points.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建高速公路** 节点是城市，边是高速公路，边的权重是建造两点之间高速公路的成本。'
- en: '**Power grids **Nodes are cities, edges are transmission lines, and edge weight
    is the cost to construct the transmission lines between two points.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**电力网** 节点是城市，边是传输线路，边的权重是建造两点之间传输线路的成本。'
- en: '**Bridging an archipelago **Nodes are islands in the archipelago, edges are
    physical bridges between two islands, and edge weight is the cost to construct
    a bridge between two islands.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨岛桥梁** 节点是群岛中的岛屿，边是两岛之间的实际桥梁，边的权重是建造两岛之间桥梁的成本。'
- en: '**Design of airline networks **Nodes are airports, edges are flights, and edge
    weight is the cost of flying between two airports.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**航空网络设计** 节点是机场，边是航班，边的权重是两机场之间飞行的成本。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Social Networks</samp>
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">社交网络</samp>
- en: Minimum spanning trees also apply to non-physical networks. For example, imagine
    a Society for Personal Communication Between Data Structure Experts that does
    not believe in bulk emails. Such announcement methods are much too impersonal.
    Instead, the organizers insist that each message be passed by a personal call
    from member to member. However, like in any organization consisting of experts,
    there exists a range of old friendships and feuds. Last year, Alice Hash Table
    had a falling out with Bob Binary Search Tree, and they no longer talk.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最小生成树也适用于非物理网络。例如，想象一个不相信群发邮件的“数据结构专家个人通信协会”。这种公告方式过于冷漠。相反，组织者坚持要求每个消息必须通过成员之间的个人电话传递。然而，像任何由专家组成的组织一样，成员之间有着各种各样的旧友谊和恩怨。去年，艾丽斯·哈希表与鲍勃·二叉搜索树发生了争执，之后他们不再交谈。
- en: Every year, the organization develops an elaborate phone tree allowing the organization
    to spread the news of its upcoming conference while minimizing the discomfort
    of its members. Each member is represented as a node with edges to each other
    member. The cost of an edge is the level of discomfort two members have with talking
    to one another. In the best case, a chat among friends, the weight is minimal
    to represent the time cost of the phone call. However, in the worst case, the
    cost between two feuding members results in days of lost productivity and angry
    muttering. The organization needs to find the set of pairwise communications that
    informs every member about the conference details while minimizing overall angst.
    This requires all nodes to be connected using the minimum number and cost of edges.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每年，组织都会开发一个复杂的电话树，允许该组织在最小化成员不适感的同时传播即将举行的会议的消息。每个成员都表示为一个节点，并与其他成员通过边相连。边的成本是两个成员之间交谈时的不适感。在最佳情况下，即朋友之间的聊天，权重最小，仅表示电话通话的时间成本。然而，在最坏情况下，两名有恩怨的成员之间的成本会导致数天的生产力损失和愤怒的抱怨。组织需要找到一组配对通信，使每个成员都能收到会议的相关信息，同时最小化整体的不安。这要求所有节点通过最少数量和成本的边进行连接。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Prim’s Algorithm</samp>
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">普里姆算法</samp>
- en: Constructing a minimum spanning tree requires an algorithm to select a minimum
    cost subset of the edges from the full graph such that the resulting graph is
    fully connected. One method of finding a graph’s minimum spanning tree is *Prim’s
    algorithm*, which was independently proposed by multiple people including computer
    scientist R.C. Prim and mathematician Vojteˇch Jarník. The algorithm operates
    very similarly to Dijkstra’s algorithm in [Chapter 7](chapter7.xhtml), working
    through an unvisited set and building up a minimum spanning tree one node at a
    time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 构建最小生成树需要一种算法，从完整的图中选择一个最小代价的边集，使得生成的图是完全连接的。找到图的最小生成树的一种方法是*普里姆算法*，该算法由包括计算机科学家R.C.
    普里姆和数学家Vojteˇch Jarník在内的多位学者独立提出。该算法与[第7章](chapter7.xhtml)中的Dijkstra算法非常相似，都是通过遍历一个未访问的节点集，并逐个节点地构建最小生成树。
- en: Prim’s algorithm starts with an unvisited set of all nodes and arbitrarily chooses
    one to visit. This visited node forms the start of the minimum spanning tree.
    On each iteration, the algorithm finds the unvisited node with the minimum edge
    weight to *any* of the nodes that it has previously visited, asking, “Which node
    is closest to our set’s periphery and thus can be added with the least cost?”
    The algorithm removes this new node from the unvisited set and adds the corresponding
    edge to the minimum-cost spanning tree. It keeps adding nodes and edges, one per
    iteration, until it has visited every node.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 普里姆算法从一个未访问的所有节点集合开始，任意选择一个节点进行访问。这个已访问的节点构成最小生成树的起点。在每次迭代中，算法会找到与它已经访问过的节点中某一个节点的边权最小的未访问节点，并问：“哪个节点离我们已连接集合的边界最近，且可以以最小代价添加进来？”算法将这个新节点从未访问集合中移除，并将相应的边添加到最小代价生成树中。它不断地在每次迭代中添加节点和边，直到访问了所有的节点。
- en: Prim’s algorithm will visit each node at most once and consider each edge at
    most twice (once from each end). Additionally, for each node, we may see a cost
    proportional to the logarithm of |*V* | to insert or update a node in the priority
    queue implemented as a standard heap. The total cost of the algorithm therefore
    scales as (|*V* | + |*E*|) × log (|*V* |).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 普里姆算法最多访问每个节点一次，并且最多考虑每条边两次（每个端点各一次）。此外，对于每个节点，我们可能会看到与|*V*|的对数成比例的成本，来插入或更新在标准堆中实现的优先队列中的节点。因此，算法的总成本按(|*V*|
    + |*E*|) × log (|*V*|)的复杂度增长。
- en: We can picture Prim’s algorithm as a construction company hired to upgrade bridges
    between islands in an archipelago. The company plans to replace the rotting wooden
    bridges connecting the archipelago with fully modern versions. Because the old
    wooden bridges will not support the weight of the construction equipment, from
    the company’s point of view, only islands joined by a new bridge are truly connected.
    Their contract specifies that, in the end, any pair of islands must be reachable
    with a new modern bridge.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将普里姆算法想象成一个建设公司，受雇于一个群岛之间的桥梁升级项目。该公司计划将连接群岛的腐朽木桥替换为现代化的桥梁。由于旧的木桥无法承受施工设备的重量，因此从公司角度来看，只有通过新桥连接的岛屿才算是“真正连接”。他们的合同要求，最终任何一对岛屿都必须通过新建的现代化桥梁相互可达。
- en: The builders start at a single island and work outward, connecting more and
    more islands with new bridges. At each step, they choose to upgrade the shortest
    wooden bridge that joins an island in the current connected set to an island outside
    that set. By always starting new bridges from an island in the connected set,
    the builders can move their equipment to the new edge’s origin using modern bridges.
    By always ending bridges on islands outside the connected set, the builders increase
    the coverage of the connected set at every stage.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 建设者从一个岛屿开始，向外扩展，逐渐用新的桥梁连接更多岛屿。每一步，他们选择升级连接当前已连接岛屿与外部岛屿之间的最短木桥。通过始终从已连接岛屿开始新桥的建设，建设者可以用现代桥梁将设备运送到新边的起点。通过始终在未连接岛屿上结束桥梁，建设者在每一步都增加了已连接岛屿集的覆盖范围。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: At each step of Prim’s algorithm, we track the unconnected nodes along with
    the best edge weight seen that would connect them. We maintain this data using
    a custom <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> implementation
    that provides an efficient mechanism for looking up values in the queue and modifying
    priorities. For the purposes of this code, you need to understand only the basics
    of inserting items into the priority queue, removing items from the priority queue,
    and modifying priorities. However, if you’re curious, you can review the details
    in [Appendix B](appendix_B.xhtml).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Prim 算法的每一步中，我们跟踪未连接的节点以及连接它们的最佳边权重。我们通过使用自定义的<samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp>实现来维护这些数据，该实现提供了一种高效的机制来查找队列中的值并修改优先级。为了理解这段代码，你只需要掌握向优先队列中插入项、从优先队列中移除项以及修改优先级的基本知识。然而，如果你感兴趣，可以在[附录
    B](appendix_B.xhtml)中查看详细信息。
- en: 'The code itself loops over the nodes in the priority queue until it is empty.
    Every time it removes a new node from the priority queue (the unvisited set),
    it examines that node’s unvisited neighbors and checks whether the current node
    provides better (that is, lower cost) edges to any of its unconnected neighbors.
    If so, it updates the neighbor’s information with the new edge and weight:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身会遍历优先队列中的节点，直到队列为空。每次从优先队列中移除一个新节点（即未访问的节点），它会检查该节点的未访问邻居，并判断当前节点是否为任何未连接的邻居提供了更好的（即更低成本的）边。如果是，它就会用新的边和权重更新邻居的信息：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code starts by creating a trio of helper data structures, including a min-heap-based
    priority queue of unconnected nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>),
    an array indicating the last node visited before a given node (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>),
    and the final set of edges for the minimum spanning tree (<samp class="SANS_TheSansMonoCd_W5Regular_11">mst_edges</samp>).
    The code requires importing the custom <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp>
    class defined in [Appendix B](appendix_B.xhtml), as well as importing <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>
    from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先创建了三个辅助数据结构，包括一个基于最小堆的未连接节点优先队列（<samp class="SANS_TheSansMonoCd_W5Regular_11">pq</samp>）、一个表示在给定节点之前最后访问节点的数组（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>），以及最小生成树的最终边集（<samp class="SANS_TheSansMonoCd_W5Regular_11">mst_edges</samp>）。这段代码需要导入在[附录
    B](appendix_B.xhtml)中定义的自定义<samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp>类，以及从
    Python 的<samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp>库中导入<samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>。
- en: All nodes are inserted into the priority queue at the start of the algorithm
    ❶. The starting node (0) is given priority 0.0 and the rest are given infinite
    priority. The code then proceeds like Dijkstra’s algorithm, processing the unvisited
    nodes one at a time. A <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop iterates until the priority queue of unvisited nodes is empty ❷. During each
    iteration, the node with the minimum distance to any of the visited nodes is chosen
    and dequeued from the priority queue. As we will see, this effectively removes
    the node from the unvisited set.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点在算法开始时都会被插入到优先队列中❶。起始节点（0）被赋予优先级0.0，其他节点则赋予无限优先级。接着，代码按照类似于 Dijkstra 算法的方式，逐一处理未访问的节点。一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环会一直运行，直到未访问节点的优先队列为空❷。在每次迭代中，会选择与任何已访问节点距离最小的节点，并从优先队列中出队。如我们将看到的，这有效地将该节点从未访问的节点集中移除。
- en: The code next checks whether there exists an edge back to one of the nodes in
    the connected set ❸. There are two cases in which the node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    entry might be <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>. The first
    is node 0, which does not have a predecessor by virtue of being explored first.
    The second case is in a disconnected component where <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>
    is not reachable from node 0\. In this latter case, because all the nodes cannot
    be connected, the graph does not have a minimum spanning tree and the function
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码检查是否存在一条返回到连通集合中某个节点的边 ❸。有两种情况可能导致节点的<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>条目为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>。第一种情况是节点0，由于首先被探索，因此没有前驱节点。第二种情况是断开分量，其中<samp
    class="SANS_TheSansMonoCd_W5Regular_11">index</samp>无法从节点0到达。在后一种情况下，由于所有节点无法连接，图就没有最小生成树，函数返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">None</samp>。
- en: After adding the new node to the visited set (by dequeuing it), a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop iterates over each of the node’s neighbors ❹, checking whether the neighbor
    is unvisited (still in the priority queue). If so, the code checks whether it
    has found a better edge to the node by comparing the previous best edge weight
    with that of the new edge. The code finishes by returning the set of edges making
    up the minimum spanning tree.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在将新节点添加到已访问集合（通过出队操作）后，<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历每个节点的邻居
    ❹，检查邻居是否未被访问（仍在优先队列中）。如果是，代码将通过比较先前最佳边的权重与新边的权重，来检查是否找到了到该节点的更好边。代码最后通过返回组成最小生成树的边集来结束。
- en: Note that if a graph is disconnected, each connected component has its own minimum
    spanning tree. An alternative approach to the code presented here is to return
    the list of edges that create the minimum spanning trees for each connected component.
    We can implement this by removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">elif</samp>
    check ❸ and its corresponding return. The code will then move on to the next component
    by selecting a node from the priority queue and continue selecting edges.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果图是断开的，每个连通分量都有自己的最小生成树。与这里呈现的代码的替代方法是返回为每个连通分量创建最小生成树的边的列表。我们可以通过删除<samp
    class="SANS_TheSansMonoCd_W5Regular_11">elif</samp>检查 ❸及其对应的返回语句来实现这一点。然后，代码将通过从优先队列中选择一个节点并继续选择边来处理下一个分量。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个例子</samp>
- en: '[Figure 10-3](#fig10-3) shows an illustration of Prim’s algorithm on a graph
    with eight nodes. The table to the right of each subfigure shows the information
    tracked for each node, including the node’s ID, the distance to that node from
    the connected set of nodes as stored by the node’s priority, and the closest member
    of the current connected subset as stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    list. All nodes except the first one start with an infinite distance and a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp> node pointer of <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    to indicate that we have yet to find a path that leads to that node. After removing
    a node from the priority queue, we gray out its row to indicate it is no longer
    under consideration.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-3](#fig10-3)展示了Prim算法在一个包含八个节点的图上的示例。每个子图右侧的表格显示了每个节点跟踪的信息，包括节点的ID、从已连接节点集合到该节点的距离（由节点的优先级存储），以及当前连接子集中的最近节点，该信息存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>列表中。除了第一个节点外，所有节点的初始距离为无穷大，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>节点指针为<samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>，表示我们尚未找到通向该节点的路径。移除一个节点后，我们将其行标灰色显示，以表示该节点不再被考虑。'
- en: The search starts at node 0 in [Figure 10-3(a)](#fig10-3). This corresponds
    to our island bridge building company setting up operations at its headquarters
    on its home island. The search removes this node from the priority queue, checks
    each of node 0’s neighbors, and updates the information accordingly. Node 1 is
    assigned a distance of 1.0 and node 3 a distance of 0.6\. Both neighbors’ <samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp> values now point back to node
    0 as the closest node in the connected subset.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索从[图 10-3(a)](#fig10-3)中的节点 0 开始。这对应于我们的岛屿桥梁建设公司在其母岛的总部开始运营。搜索从优先队列中移除节点 0，检查其每个邻居，并相应更新信息。节点
    1 被分配了 1.0 的距离，节点 3 被分配了 0.6 的距离。两个邻居的<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>值现在都指向节点
    0，作为已连接子集中最近的节点。
- en: In [Figure 10-3(b)](#fig10-3), the search progresses to the closest node that
    is not in the connected subset. This corresponds to building the first bridge
    between islands. The algorithm dequeues node 3 with a distance (priority) of 0.6,
    adds it to the connected subset, and checks its neighbors 4 and 6\. These are
    both newly reachable via an edge from node 3\. The search updates both nodes’
    priorities and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 10-3(b)](#fig10-3)中，搜索进展到距离最近且不在已连接子集中的节点。这对应于建立岛屿之间的第一座桥梁。算法从优先队列中取出距离（优先级）为
    0.6 的节点 3，将其加入已连接子集，并检查其邻居节点 4 和 6。这两个节点通过节点 3 的边成为新可达节点。搜索更新了这两个节点的优先级和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>值。
- en: The search next explores node 1 in [Figure 10-3(c)](#fig10-3). While checking
    the neighbors of node 1, it finds a shorter edge connecting to node 4\. This is
    equivalent to the workers noticing the old wooden bridge (1, 4) is shorter and
    thus cheaper to upgrade than the other wooden bridge (3, 4) that is currently
    slated for an upgrade. The search thus updates the distance from node 4 to 0.5
    and updates its <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> pointer
    to node 1 to reflect the origin of the connecting edge. The search is now scheduled
    to use the edge from (1, 4) to join node 4 to our connected set instead of the
    previous edge (3, 4).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索接下来探索[图 10-3(c)](#fig10-3)中的节点 1。在检查节点 1 的邻居时，发现了一个更短的边连接到节点 4。这相当于工人们注意到旧木桥（1，4）比另一个当前计划升级的木桥（3，4）更短，因此升级成本更低。因此，搜索更新了节点
    4 的距离为 0.5，并将其<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>指针更新为节点
    1，以反映连接边的起点。搜索现在计划使用边（1，4）将节点 4 加入到我们的已连接集合中，而不是使用之前的边（3，4）。
- en: '![Each subfigure shows one of the eight steps of Prim’s algorithm on a graph
    with 8 nodes and 12 weighted edges. (A) shows node 0 circled and shaded. (B) shows
    node 3 circled with both 0 and 3 shaded. The edge between nodes 0 and 3 is bolded.](../images/f10003.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图展示了 Prim 算法在一个包含 8 个节点和 12 条加权边的图上的八个步骤。（A）显示了节点 0 被圈出并着色。（B）显示了节点 3
    被圈出，节点 0 和 3 都被着色。节点 0 和节点 3 之间的边加粗显示。](../images/f10003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: An illustration
    of Prim’s algorithm</samp>'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-3：Prim 算法的示意图</samp>
- en: In the next five subfigures, the search progresses to node 5, node 2, node 4,
    node 6, and node 7, respectively, checking each node’s unvisited neighbors and
    updating any for which it finds shorter edges. The size of the connected subgraph
    grows by one each step until all nodes are connected.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的五个子图中，搜索依次进行到节点 5、节点 2、节点 4、节点 6 和节点 7，检查每个节点未访问的邻居，并更新发现更短边的节点。每一步，连接的子图大小增加一，直到所有节点都被连接。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Kruskal’s Algorithm</samp>
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">克鲁斯卡尔算法</samp>
- en: An alternative to the node-by-node approach of Prim’s algorithm is to take an
    edge-centric approach to constructing minimum spanning trees. Kruskal’s algorithm,
    invented by multidisciplinary scholar Joseph B. Kruskal, works by looping over
    a sorted list of edge weights and progressively adding edges to build the minimum
    spanning tree. Intuitively, we want to add the graph’s smaller edges, since they
    are the least expensive connections between nodes. If we maintain a list of edges
    sorted by weight, we can proceed through it, adding the next edge that would help
    build the minimum spanning tree. This loop over a sorted list forms the core of
    Kruskal’s algorithm.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 普里姆算法的逐节点方法的替代方案是采用基于边的方式来构建最小生成树。克鲁斯卡尔算法由跨学科的学者约瑟夫·B·克鲁斯卡尔发明，其原理是循环遍历一个排序后的边权重列表，逐步添加边以构建最小生成树。直观地，我们希望添加图中较小的边，因为它们是节点之间最便宜的连接。如果我们维护一个按权重排序的边列表，就可以逐步添加下一个有助于构建最小生成树的边。这一排序列表循环遍历的过程就是克鲁斯卡尔算法的核心。
- en: Kruskal’s algorithm’s cost scales proportional to |*E*| log (|*E*|). The algorithm
    starts by extracting and sorting each edge, requiring time proportional to |*E*|
    log (|*E*|). Using an efficient implementation of the union-find algorithm, we
    can combine the sets in |*E*| log (|*V* |) time. As long as |*E*| ≥ |*V* |, the
    algorithm will scale as |*E*| log (|*E*|).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 克鲁斯卡尔算法的成本与|*E*| log (|*E*|)成正比。算法首先提取并排序每条边，所需时间与|*E*| log (|*E*|)成正比。使用高效实现的并查集算法，我们可以在|*E*|
    log (|*V* |)时间内合并集合。只要|*E*| ≥ |*V* |，算法的规模将是|*E*| log (|*E*|)。
- en: We can visualize Kruskal’s algorithm in the context of a pet owner building
    a complex living space for their beloved hamster. The hamster already has several
    large habitats that the owner decides to connect using clear tubes, giving their
    pet free range to roam between cages. The habitats’ arrangement within the room
    is fixed. The owner, looking to minimize the total tubing needed, measures each
    pairwise distance between habitats, sorts the list, and determines which tube
    to add next. Unlike the island building example, the pet owner does not need to
    worry about transporting construction equipment from node to node. They can easily
    move between any pair of nodes to build the connection.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将克鲁斯卡尔算法与一位宠物主人为其心爱的仓鼠搭建复杂生活空间的情境进行可视化。仓鼠已经有了几个大栖息地，主人决定用透明管道将它们连接起来，让宠物自由穿梭于各个笼子之间。栖息地在房间内的布局是固定的。为了最小化所需的管道总量，主人测量每一对栖息地之间的距离，排序列表，然后决定接下来添加哪条管道。与岛屿建设的例子不同，宠物主人不需要担心将施工设备从一个节点运送到另一个节点。他们可以轻松地在任意一对节点之间移动来建立连接。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Union-Find</samp>
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Union-Find</samp>
- en: 'Beyond finding the next lowest-cost edge, we need to answer one additional
    question when considering each new edge: does this edge join nodes from currently
    disconnected clusters? If not, the edge is redundant. Remember that the key word
    here is *minimum*. If we already have edges (A, B) and (B, C), the edge (A, C)
    doesn’t help, as node C was already reachable from node A through node B.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了找到下一个最低成本的边，我们在考虑每条新边时还需要回答一个额外的问题：这条边是否将当前断开的集群连接起来？如果没有，那么这条边就是多余的。记住，关键字是*最小*。如果我们已经有了边(A,
    B)和(B, C)，那么边(A, C)就没有帮助，因为节点C已经通过节点B从节点A到达。
- en: 'To efficiently implement Kruskal’s algorithm, we make use of a new helper data
    structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>. This
    data structure allows us to represent a collection of different sets, which we
    will use to track the connected components of the graph. The data structure facilitates
    a few efficient, set-based operations, including the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效实现克鲁斯卡尔算法，我们使用一种新的辅助数据结构<samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>。这种数据结构允许我们表示一组不同的集合，我们将使用它来跟踪图的连通组件。该数据结构支持一些高效的集合操作，包括以下内容：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">are_disjoint(i, j)</samp>Determines
    whether two elements <samp class="SANS_TheSansMonoCd_W7Bold_B_11">i</samp> and
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">j</samp> are in different sets. We
    use this to test whether two nodes are part of the same connected set.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">are_disjoint(i, j)</samp>确定两个元素<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">i</samp>和<samp class="SANS_TheSansMonoCd_W7Bold_B_11">j</samp>是否在不同的集合中。我们使用此方法来测试两个节点是否属于同一连通集合。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">union_sets(i, j)</samp>Merges the
    set with element <samp class="SANS_TheSansMonoCd_W7Bold_B_11">i</samp> and the
    set with element <samp class="SANS_TheSansMonoCd_W7Bold_B_11">j</samp> into a
    single set. We use this to connect two sets of nodes when adding an edge.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">union_sets(i, j)</samp>将包含元素 <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">i</samp> 的集合和包含元素 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">j</samp>
    的集合合并为一个集合。我们用它来连接两个节点集合，当我们添加一条边时。
- en: The data structure also tracks a count of the disjoint sets that is updated
    with each operation (<samp class="SANS_TheSansMonoCd_W5Regular_11">num_disjoint_sets</samp>).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构还会跟踪不相交集合的计数，并在每次操作时更新（<samp class="SANS_TheSansMonoCd_W5Regular_11">num_disjoint_sets</samp>）。
- en: For the purposes of the algorithms in this book, it is not necessary to dive
    into the details of <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>.
    It is sufficient to treat it as a module that facilitates the operations described.
    Interested readers can find a basic description and the code sufficient to implement
    the algorithms in this book in [Appendix C](appendix_C.xhtml).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的算法，实际上不需要深入了解 <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>
    的细节。将其视为一个方便进行操作的模块就足够了。有兴趣的读者可以在[附录 C](appendix_C.xhtml)中找到一个基本的描述和足够实现本书算法的代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: 'Given the helper data structure, the code for Kruskal’s algorithm consists
    of two main steps. First, we create a list of all the graph’s edges and sort it.
    Second, we iterate through that list by checking whether the current edge joins
    disconnected components and, if so, adding it to our minimum spanning tree:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 给定辅助数据结构，Kruskal 算法的代码分为两个主要步骤。首先，我们创建一个包含所有图的边的列表并进行排序。然后，我们通过遍历该列表，检查当前边是否连接了不相连的组件，如果是的话，就将其添加到我们的最小生成树中：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code starts by creating a series of helper data structures, including a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp> data structure
    representing the current disjoint sets (<samp class="SANS_TheSansMonoCd_W5Regular_11">djs</samp>)
    to determine which points already belong to the same cluster, a list (<samp class="SANS_TheSansMonoCd_W5Regular_11">all_edges</samp>)
    that will store the *sorted* list of edges, and an empty list (<samp class="SANS_TheSansMonoCd_W5Regular_11">mst_edges</samp>)
    to hold the resulting edges for the minimum spanning tree. The code then loops
    over every node in the graph to fill these helper data structures ❶. For each
    node, it inserts each of the node’s edges into the list of all edges.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先创建一系列辅助数据结构，包括一个表示当前不相交集合的 <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>
    数据结构（<samp class="SANS_TheSansMonoCd_W5Regular_11">djs</samp>），用于确定哪些点已经属于同一个簇，一个列表（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">all_edges</samp>）用于存储*排序后的*边列表，以及一个空列表（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mst_edges</samp>）用于存放最小生成树的结果边。然后，代码遍历图中的每个节点来填充这些辅助数据结构❶。对于每个节点，它将该节点的每条边插入到所有边的列表中。
- en: Since our representation of an undirected graph includes the edge (A, B) in
    the adjacency lists for both node A and node B, the code uses a simple check to
    avoid adding the same edge twice ❷. (Note that this check is only needed to improve
    the efficiency when using this representation of an undirected graph. The code
    would still work correctly without the check but would include twice the number
    of edges in <samp class="SANS_TheSansMonoCd_W5Regular_11">all_edges</samp>.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对无向图的表示在节点 A 和节点 B 的邻接表中都包含边 (A, B)，代码使用简单的检查来避免重复添加相同的边❷。（请注意，这个检查仅在使用这种无向图表示法时用于提高效率。如果没有该检查，代码仍然能够正常工作，只不过在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">all_edges</samp> 中会包含两倍数量的边。）
- en: After the full list of edges is assembled, the code sorts the edges in order
    of increasing weight ❸. The code iterates over each edge in the sorted list with
    a single <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, then uses
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp> data structure
    to check whether the edge connects two currently unconnected components ❹. If
    so, the edge is useful. The code adds it to the set of edges from the minimum
    spanning tree (<samp class="SANS_TheSansMonoCd_W5Regular_11">mst_edges</samp>)
    and merges the disjoint sets for the edge’s nodes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有边列表组装完成后，代码会按边的权重升序对边进行排序❸。代码通过单一的<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历排序后的每条边，然后使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>数据结构检查该边是否连接两个当前未连接的组件❹。如果是，这条边就是有用的。代码会将它添加到最小生成树的边集(<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mst_edges</samp>)中，并合并该边节点的两个不连通子集。
- en: Finally, the code checks whether it was able to connect all the nodes into a
    single connected component ❺. If so, it returns the list of edges for the minimum
    spanning tree. Otherwise, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>.
    If we remove this final check, the code will instead return the edges from the
    individual minimum spanning trees for graphs that are not a single connected component.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码检查是否能够将所有节点连接成一个单一的连通组件❺。如果是，它会返回最小生成树的边列表。如果不是，它则返回<samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>。如果去掉这个最终的检查，代码将返回那些不属于单一连通组件的图的每个最小生成树的边。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个示例</samp>
- en: '[Figure 10-4](#fig10-4) shows an example of Kruskal’s algorithm running on
    a graph with 8 nodes and 12 edges.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-4](#fig10-4)展示了Kruskal算法在一个有8个节点和12条边的图上的运行示例。'
- en: The search begins with an empty set of edges and thus a disconnected set of
    nodes. In [Figure 10-4(a)](#fig10-4), the search selects the edge with the lowest
    weight from our graph. This corresponds to the edge (1, 5) with a weight of 0.2\.
    The edge in the figure is marked in bold to indicate it is part of the minimum-cost
    spanning tree. Nodes 1 and 5 are now part of the same connected subset, and the
    search has reduced the number of disjoint sets from eight to seven.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索从一个空的边集开始，因此是一个不连通的节点集。在[图10-4(a)](#fig10-4)中，搜索从图中选择了权重最小的边。这个边对应的是边(1, 5)，权重为0.2。图中的边用粗体标记，表示它是最小成本生成树的一部分。节点1和节点5现在属于同一个连通子集，搜索将不连通的子集数量从八个减少到了七个。
- en: The search continues in [Figure 10-4(b)](#fig10-4) by choosing the edge with
    the next lowest weight. This time it connects nodes 6 and 7 through an edge with
    weight 0.3\. It has reduced the number of disjoint sets to six.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图10-4(b)](#fig10-4)中，搜索继续通过选择权重次小的边来进行。这次它通过权重为0.3的边连接了节点6和节点7，将不连通的子集数量减少到了六个。
- en: '![Each subfigure shows one of the seven steps of Kruskal’s algorithm where
    an edge is added. In (A) only the edge (1, 5) with weight 0.2 is bolded. In (B)
    both the edges (1, 5) and (6, 7) are bolded.](../images/f10004.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图展示了Kruskal算法的七个步骤中的一个，其中一条边被添加。在(A)中，只有边(1, 5)的权重0.2被加粗。在(B)中，边(1, 5)和(6,
    7)都被加粗。](../images/f10004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: An illustration
    of Kruskal’s algorithm</samp>'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-4：Kruskal算法的示意图</samp>
- en: 'In the next two subfigures, the search adds nodes 2 and 4 to the first connected
    subset {1, 5}, resulting in a connected set consisting of {1, 2, 4, 5}. In [Figure
    10-4(e)](#fig10-4), the algorithm merges another two singleton nodes by joining
    nodes 0 and 3 via the edge with weight 0.6\. It then joins up the remaining three
    disjoint sets by adding the edges (0, 1) and (3, 6) in the following two subfigures.
    At this point, we are down to a single set, which means our minimum-cost spanning
    tree edges connect all the nodes in the graph.  ### <samp class="SANS_Futura_Std_Bold_B_11">Maze
    Generation</samp>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个子图中，搜索将节点2和节点4添加到第一个连通子集{1, 5}中，结果形成了包含{1, 2, 4, 5}的连通集。在[图10-4(e)](#fig10-4)中，算法通过边权重为0.6的边将节点0和节点3连接在一起，合并了另外两个孤立的节点。接着，算法通过在接下来的两个子图中添加边(0,
    1)和(3, 6)，将剩余的三个不连通子集合并到一起。此时，所有节点已经连接成一个单一的子集，意味着最小成本生成树的边连接了图中的所有节点。### <samp
    class="SANS_Futura_Std_Bold_B_11">迷宫生成</samp>
- en: While the graph searches presented in preceding chapters allow us to algorithmically
    solve mazes, they cannot help us generate mazes in the first place. In this section,
    we take a detour from the more canonical uses of minimum spanning tree algorithms,
    such as building transportation networks, to show how we can extend Kruskal’s
    algorithm to create random but always solvable mazes. To make the mazes sufficiently
    fun, we ensure that each has exactly one valid solution.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前几章中介绍的图形搜索方法可以帮助我们算法地解决迷宫问题，但它们无法帮助我们首先生成迷宫。在本节中，我们偏离了最小生成树算法的更经典用途（例如构建交通网络），展示了如何扩展Kruskal算法来创建随机但始终可解的迷宫。为了让迷宫足够有趣，我们确保每个迷宫只有一个有效的解。
- en: Imagine we are given the task of generating a maze for the children’s place
    mat at a local family restaurant. Our design can be simple but must be solvable,
    with only one path through the maze. The restaurant owners wisely do not want
    to challenge young patrons with impossible mazes, lest this results in screaming
    and thrown food.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们被要求为当地一家家庭餐厅的儿童餐垫设计一个迷宫。我们的设计可以很简单，但必须是可解的，并且迷宫中只有一条路径。餐厅老板聪明地不想用不可能解开的迷宫来挑战年轻的顾客，以免造成尖叫声和食物被扔出去的情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Representing Grid-Based
    Mazes</samp>
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">表示基于网格的迷宫</samp>
- en: For simplicity of the code in this section, we represent our mazes using a regular
    grid of squares like the ones on graph paper. After hours of careful consideration
    about how to draw our mazes, we decide to shade individual edges to represent
    the maze’s walls. The player can move between any two adjacent squares that do
    not have a wall between them. As we draw each line, we eliminate a potential option
    for leaving that square and perhaps chuckle at the difficult task we are creating.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化本节代码，我们使用类似图纸上的常规方格来表示迷宫。在经过数小时的深思熟虑后，我们决定通过给每条边着色来表示迷宫的墙壁。玩家可以在没有墙壁的两个相邻方格之间移动。随着每条线的绘制，我们消除了离开该方格的一个潜在选项，也许还会因我们正在创造的艰难任务而轻轻一笑。
- en: '[Figure 10-5(a)](#fig10-5) shows an example grid-based maze. We can equivalently
    represent this grid structure using a graph, as shown in [Figure 10-5(b)](#fig10-5).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-5(a)](#fig10-5)展示了一个基于网格的迷宫示例。我们可以通过图形等效地表示该网格结构，如[图10-5(b)](#fig10-5)所示。'
- en: '![Two subfigures show representation of grid-based mazes. (A) shows a 4 × 4
    grid of squares with the upper left corner labeled S and the lower right corner
    labeled E. Walls are shown with solid lines. (B) shows the same maze represented
    as a 4 × 4 series of nodes.](../images/f10005.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![两个子图展示了基于网格的迷宫表示。（A）展示了一个4×4的方格，左上角标记为S，右下角标记为E。墙壁用实线表示。（B）展示了相同的迷宫，以4×4的节点系列表示。](../images/f10005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-5: A grid-based maze
    and its graph representation</samp>'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-5：一个基于网格的迷宫及其图形表示</samp>
- en: In [Figure 10-5(b)](#fig10-5), each square in the maze corresponds to a single
    graph node. We add undirected edges between any two adjacent nodes without a wall
    so that an edge indicates the ability to travel from one node to another.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图10-5(b)](#fig10-5)中，迷宫中的每个方格都对应一个单独的图节点。我们在没有墙壁的两个相邻节点之间添加无向边，以便边表示能够从一个节点到达另一个节点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating Mazes</samp>
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">生成迷宫</samp>
- en: We construct our maze by starting with a grid-based graph and building a randomized
    spanning tree algorithm based on Kruskal’s algorithm to connect all the nodes.
    The grid-based initial structure gives us connections based on adjacency. Each
    node has up to four connections to the nodes above, below, left, and right of
    it. Generating a spanning tree allows us to ensure that each node is reachable
    from any other node and that we can reach the ending node from the starting one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从一个基于网格的图开始，并基于Kruskal算法构建一个随机化的生成树算法，来连接所有节点。基于网格的初始结构使我们能够基于邻接关系建立连接。每个节点最多有四个连接，分别连接其上、下、左、右的节点。生成生成树可以确保每个节点都可以从任何其他节点到达，并且我们可以从起始节点到达结束节点。
- en: We define the valid edges using a connected grid-based graph, as shown in [Figure
    10-6](#fig10-6). Like the grids we generated in [Chapter 5](chapter5.xhtml), this
    graph represents all the nodes we need to connect and the set of potential edges
    we can use to connect them. If our grid has a width of *w* and a height of *h*,
    it contains *h* × *w* nodes and undirected edges (with equal weights of 1) connecting
    neighboring nodes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个连接的基于网格的图来定义有效边，如[图10-6](#fig10-6)所示。就像我们在[第5章](chapter5.xhtml)中生成的网格一样，这个图表示我们需要连接的所有节点，以及我们可以用来连接它们的潜在边的集合。如果我们的网格宽度为*w*，高度为*h*，那么它包含*h*
    × *w*个节点和连接相邻节点的无向边（权重为1）。
- en: '![A 5 × 5 grid of nodes. Each node has at most four edges to any immediate
    neighbors in each of the four directions.](../images/f10006.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![一个5×5的节点网格。每个节点最多有四条边连接到四个方向的相邻节点。](../images/f10006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-6: A grid-based graph</samp>'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图10-6：基于网格的图</samp>
- en: If we used the graph in [Figure 10-6](#fig10-6) for our final maze, there would
    be a huge number of potential paths between any two locations. In other words,
    the graph does not make for a particularly fun or challenging maze. Beginning
    at the start node, we could traverse directly to the end node by moving the minimum
    number of steps in one horizontal and one vertical direction. Real-world equivalents
    would be a hedge maze implemented as an empty lawn or a blank maze on our place
    mat. To construct an interesting maze, we need to use a minimum subset of these
    edges.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用[图10-6](#fig10-6)中的图来构建我们的最终迷宫，那么任意两点之间就会有大量潜在路径。换句话说，这个图并不会构成一个特别有趣或具有挑战性的迷宫。从起始节点开始，我们可以通过在水平方向和垂直方向上各走一步，直接到达终点节点。现实世界中的类似例子可能是一个用空旷草坪做的树篱迷宫，或者是我们餐垫上的一个空白迷宫。为了构建一个有趣的迷宫，我们需要从这些边中选择一个最小的子集。
- en: As in Kruskal’s algorithm, we start with an empty spanning tree where none of
    the nodes are connected. In the case of our grid-based place mat, we start with
    a grid of boxes. One by one, we add edges to our spanning tree and erase the lines
    between adjacent boxes. We can alternatively visualize the connection of two components
    as a cartoon figure removing a physical wall between two adjacent rooms by using
    an oversized sledgehammer or simply bursting through the wall. As our cartoon
    character gleefully opens up passageways (or we carefully erase grid lines), the
    disparate components connect and a path through the maze forms.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Kruskal算法一样，我们从一个空的生成树开始，其中没有任何节点是连接的。在我们基于网格的餐垫的例子中，我们从一个方格网格开始。我们逐个向生成树添加边并擦除相邻方格之间的线。我们也可以将连接两个组件的过程想象成一个卡通人物用一个巨大的大锤子拆除两个相邻房间之间的实体墙，或者直接穿透墙壁。当我们的卡通人物愉快地打开通道（或者我们小心地擦去网格线）时，原本分离的组件连接在一起，迷宫中的路径也形成了。
- en: The key to generating a random maze is, intuitively, to choose the next edge
    randomly. Both Kruskal’s and Prim’s algorithms rely on some method to break ties
    among equal-weight edges. In this case, however, all edges have the same edge
    weight (1.0), so we can just pick one at random. If the chosen edge connects two
    disjoint components, we keep it. This edge opens a path between two previously
    unreachable components. Otherwise, in the case where the chosen edge joins two
    already connected components, we discard it, since adding multiple paths between
    components would result in loops and break the maze convention of having a single
    path.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机迷宫的关键直观上是随机选择下一条边。Kruskal算法和Prim算法都依赖于某种方法来打破权重相同边之间的平局。然而，在这个案例中，所有的边权重都是相同的（1.0），所以我们可以随机选择一条边。如果所选的边连接了两个不相交的组件，我们就保留它。这条边在之前无法到达的两个组件之间打开了一条路径。否则，如果所选的边连接了两个已经连接的组件，我们就舍弃它，因为在组件之间添加多个路径会导致循环，破坏迷宫必须只有一条路径的规则。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>'
- en: 'The following code allows us to randomly create a set of maze edges from a
    grid-based graph:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码允许我们从基于网格的图中随机创建一组迷宫边：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function takes a full grid-based graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>)
    to define the list of edges. The code starts by setting up helper data structures,
    including a <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp> data
    structure representing the disjoint sets (<samp class="SANS_TheSansMonoCd_W5Regular_11">djs</samp>),
    a list of all edges (<samp class="SANS_TheSansMonoCd_W5Regular_11">all_edges</samp>),
    and a list of the maze or spanning tree edges (<samp class="SANS_TheSansMonoCd_W5Regular_11">maze_edges</samp>)
    ❶. As in Kruskal’s algorithm, the code extracts the comprehensive list of edges
    from the graph ❷.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用完整的基于网格的图（<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>）来定义边列表。代码首先设置辅助数据结构，包括表示不相交集合的<ssamp
    class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>数据结构（<ssamp class="SANS_TheSansMonoCd_W5Regular_11">djs</samp>），所有边的列表（<ssamp
    class="SANS_TheSansMonoCd_W5Regular_11">all_edges</samp>），以及迷宫或生成树边的列表（<ssamp
    class="SANS_TheSansMonoCd_W5Regular_11">maze_edges</samp>）❶。像克鲁斯卡尔算法一样，代码从图中提取出完整的边列表❷。
- en: 'The algorithm iterates through a single <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop until all nodes are the same set (and thus reachable) ❸. During each iteration
    of the loop, the algorithm selects an edge randomly ❹, using Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">random</samp>
    library’s <samp class="SANS_TheSansMonoCd_W5Regular_11">randint()</samp> function
    (which requires us to include <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    random</samp> at the start of the file). It then removes the selected edge from
    the list of all edges and checks whether it joins two previously disjoint sets
    ❺. If so, the edge is added to the list of maze edges and the corresponding sets
    are merged. Otherwise, the edge is ignored. The algorithm completes after all
    the nodes are merged into a single set, returning the list of edges that defines
    the maze: the minimum spanning tree.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法通过单个<ssamp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环进行迭代，直到所有节点属于同一集合（因此可达）❸。在每次循环迭代中，算法随机选择一条边❹，使用
    Python 的<ssamp class="SANS_TheSansMonoCd_W5Regular_11">random</samp>库中的<ssamp
    class="SANS_TheSansMonoCd_W5Regular_11">randint()</samp>函数（这要求我们在文件开头包含<ssamp
    class="SANS_TheSansMonoCd_W5Regular_11">import random</samp>）。然后，它从所有边列表中移除选中的边，并检查它是否连接了两个之前不相交的集合❺。如果是，则将该边添加到迷宫边列表中，并合并对应的集合。否则，忽略该边。算法在所有节点合并为一个集合后完成，返回定义迷宫的边列表：最小生成树。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个示例</samp>
- en: '[Figure 10-7](#fig10-7) shows an example of the first few steps of this algorithm.
    The left diagram of each subfigure shows the current maze as defined by the walls
    that have been removed, while the right diagram shows the maze as defined by edges
    that have been added to a graph. During each step (each iteration of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop), one edge at most is
    added.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-7](#fig10-7)展示了该算法前几个步骤的示例。每个子图的左侧图示表示当前迷宫，定义为已移除的墙壁，而右侧图示则表示通过添加边缘到图中的迷宫。在每一步（每次<ssamp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环迭代中），最多添加一条边。'
- en: '![Six subfigures. (A) shows a 4 × 4 grid and a corresponding 4 × 4 arrangement
    of unconnected nodes. (B) shows the same grid with one wall missing and the same
    nodes with the corresponding nodes linked by an edge.](../images/f10007.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![六个子图。（A）展示了一个 4×4 的网格和相应的 4×4 的未连接节点排列。（B）展示了相同的网格，缺少了一堵墙，并且相同的节点通过一条边连接。](../images/f10007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-7: Six steps of the
    maze construction algorithm</samp>'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-7：迷宫构造算法的六个步骤</samp>
- en: It is not strictly necessary to construct the full grid-based graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>)
    ahead of time. Instead, we could just programmatically fill the <samp class="SANS_TheSansMonoCd_W5Regular_11">all_edges</samp>
    list based on computed adjacencies, as we did when constructing grids in [Chapter
    5](chapter5.xhtml), for example. However, for the purposes of this chapter, starting
    with the full grid-based graph makes the code’s connection to Kruskal’s algorithm
    more apparent and keeps the function simpler.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 提前构建完整的基于网格的图（<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>）并不是绝对必要的。相反，我们可以像在[第
    5 章](chapter5.xhtml)中构建网格时那样，根据计算出的邻接关系编程填充<ssamp class="SANS_TheSansMonoCd_W5Regular_11">all_edges</samp>列表。然而，在本章的目的下，从完整的基于网格的图开始，使代码与克鲁斯卡尔算法的关联更加明显，并且保持代码简单。
- en: The randomized Kruskal’s algorithm is a simplistic approach to generating mazes
    that makes no guarantee that the ending node is at the end of a deep path with
    a bunch of turns. It may result in quite boring mazes such as the ones shown in
    [Figures 10-8(a)](#fig10-8), [10-8(b)](#fig10-8), and [10-8(c)](#fig10-8). We
    can only be sure that the algorithm will *not* produce a maze where the end is
    unreachable, such as the one shown in [Figure 10-8(d)](#fig10-8).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 随机化的 Kruskal 算法是一种生成迷宫的简单方法，它不能保证终点位于一条深且转弯多的路径的尽头。它可能会生成非常无聊的迷宫，比如在[图 10-8(a)](#fig10-8)、[10-8(b)](#fig10-8)和[10-8(c)](#fig10-8)中所示的那些。我们只能确保该算法*不会*生成一个终点无法到达的迷宫，例如在[图
    10-8(d)](#fig10-8)中所示的那个。
- en: '![Each subfigure shows a 5 × 5 grid with a different maze. The top left corner
    is labeled S and the bottom right is labeled E. The first three mazes have simple
    paths. The fourth maze does not have a valid path.](../images/f10008.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![每个子图显示一个 5×5 的网格和不同的迷宫。左上角标记为 S，右下角标记为 E。前三个迷宫有简单的路径。第四个迷宫没有有效的路径。](../images/f10008.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-8: Three overly simple
    mazes and one unsolvable maze</samp>'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-8：三个过于简单的迷宫和一个无法解决的迷宫</samp>
- en: Beyond the exciting commercial opportunities involved in designing children’s
    place mats, the maze-generation algorithm in this section shows how we can extend
    the basic components of minimum spanning trees and Kruskal’s algorithm. Further,
    it demonstrates how randomization can be used within an algorithm to create different
    spanning trees.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设计儿童餐垫所涉及的激动人心的商业机会外，本节中的迷宫生成算法展示了我们如何扩展最小生成树和 Kruskal 算法的基本组件。此外，它还演示了如何在算法中使用随机化来生成不同的生成树。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Single-Linkage Hierarchical Clustering</samp>
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">单链接层次聚类</samp>
- en: We can also adapt Kruskal’s algorithm to handle the seemingly different problem
    of clustering spatial points. *Clustering* is a common unsupervised data-mining
    and machine-learning approach that assigns data points to clusters such that the
    points within each cluster are similar (for some given definition of similar).
    For example, we might cluster cafés based on geographic proximity so that all
    the coffee shops in Anchorage are placed together in one cluster, while cafés
    in Honolulu are placed in another. The resulting clusters provide a partitioning
    of data points that can help us discover structure in the data or classify similar
    data points.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以调整 Kruskal 算法来处理看似不同的空间点聚类问题。*聚类*是常见的无监督数据挖掘和机器学习方法，它将数据点分配到簇中，使得每个簇中的点是相似的（根据某种给定的相似性定义）。例如，我们可以根据地理接近度将咖啡馆进行聚类，使得安克雷奇的所有咖啡店都聚集在一个簇中，而檀香山的咖啡馆则聚集在另一个簇中。生成的簇为数据点提供了一个分区，这可以帮助我们发现数据中的结构或对相似的数据点进行分类。
- en: 'There is a wide range of clustering techniques that vary in how they define
    similar points and how points are assigned to clusters. As its name implies, hierarchical
    clustering is an approach that creates a hierarchy of clusters by merging two
    “nearby” clusters at each level of the hierarchy. Each data point initially defines
    its own cluster; these clusters are iteratively joined until all the points are
    part of the same cluster. Even within hierarchical clustering, there are various
    approaches to determining which clusters to merge, including the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种聚类技术，它们在定义相似点和如何将点分配到簇中的方式上有所不同。顾名思义，层次聚类是一种通过在每个层次上合并两个“相邻”的簇来创建簇层次结构的方法。每个数据点最初定义自己的簇；这些簇会迭代地合并，直到所有点都属于同一个簇。即使在层次聚类中，也有不同的方法来确定合并哪些簇，包括以下几种：
- en: Computing the mean position over each cluster’s points and merging the clusters
    with the closest centers
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算每个簇的点的均值位置，并合并中心最接近的簇
- en: Finding the farthest of any pair of points from two clusters and merging the
    clusters whose maximum distance is the smallest
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从两个簇中找到最远的点对，并合并最大距离最小的簇
- en: Finding the closest pair of points from two clusters and merging the clusters
    whose minimum distance is the smallest
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从两个簇中找到最接近的点对，并合并最小距离最小的簇
- en: This section focuses on the last approach, called *single-linkage clustering*,
    which joins the two clusters with the closest pair of individual points. We present
    an algorithm to implement it that is nearly identical to Kruskal’s algorithm on
    graphs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点介绍最后一种方法，称为*单链接聚类*，它通过连接两个簇中最接近的一对单独点来合并簇。我们将介绍一个几乎与图的 Kruskal 算法相同的实现算法。
- en: '[Figure 10-9](#fig10-9) shows an example of single-linkage clustering. The
    left-hand figure shows the five two-dimensional points (0, 0), (1, 0), (1.2, 1),
    (1.8, 1), and (0.5, 1.5). The right-hand figure shows the hierarchical clustering.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-9](#fig10-9)展示了单链接聚类的一个例子。左侧图形显示了五个二维点（0, 0）、（1, 0）、（1.2, 1）、（1.8, 1）和（0.5,
    1.5）。右侧图形展示了层次聚类。'
- en: '![The left subplot shows an X and Y graph with five points. The right subplot
    shows the hierarchical merging of the elements. Points 2 and 3 are merged at the
    first level. At the next level, that cluster is merged with point 4.](../images/f10009.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![左侧子图显示了带有五个点的 X 和 Y 图，右侧子图显示了元素的层次合并。第一级合并了点 2 和点 3，下一层将 {2, 3} 和点 4 合并。](../images/f10009.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-9: A set of two-dimensional
    points (left) and the corresponding single-linkage clustering (right)</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-9：一组二维点（左）及其对应的单链接聚类（右）</samp>
- en: We start with each point in its own cluster and create a merged cluster from
    the two individual points with the closest distance (points 2 and 3). Next, we
    merge the cluster {2, 3} with {4} because points 2 and 4 have the smallest distance
    of any pair of points in different clusters. This process continues as shown in
    the right-hand side of [Figure 10-9](#fig10-9).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从每个点单独作为一个簇开始，并通过合并距离最小的两个单独点（点 2 和点 3）来创建一个合并簇。接下来，我们将簇 {2, 3} 和 {4} 合并，因为点
    2 和点 4 之间的距离是不同簇中所有点对中最小的。这个过程继续进行，如[图 10-9](#fig10-9)右侧所示。
- en: The advantage of hierarchical clustering is that it provides an easily visualized
    and interpretable structure. We can use this structure to dynamically change the
    number of clusters (level of partitioning) by walking up the hierarchy until we
    hit a given distance threshold. Points that have been joined together before we
    hit the threshold are clustered together, while clusters that have not been merged
    remain disjoint.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 层次聚类的优点在于它提供了一个易于可视化和解释的结构。我们可以利用这个结构通过沿着层次结构向上走，直到达到给定的距离阈值，动态改变聚类的数量（分区级别）。在达到阈值之前已经合并的点将被归为一类，而未合并的簇则保持独立。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: 'To simplify the logic of the clustering code, we define two small helper classes
    that store information about the points and the resulting clustering links. First,
    to represent the two-dimensional points we are clustering, we define a <samp class="SANS_TheSansMonoCd_W5Regular_11">Point</samp>
    class to store the coordinates and compute pairwise distances:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化聚类代码的逻辑，我们定义了两个小的辅助类，用来存储关于点和结果聚类连接的信息。首先，为了表示我们正在聚类的二维点，我们定义了一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Point</samp>类来存储坐标并计算点对之间的距离：
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function
    computes the Euclidean distance in two- dimensional space and requires us to include
    <samp class="SANS_TheSansMonoCd_W5Regular_11">import math</samp> at the start
    of the file in order to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp>
    library’s square root function. ([Appendix A](appendix_A.xhtml) further discusses
    creating graphs from spatial points, including the use of alternative distance
    functions.)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> 函数计算二维空间中的欧几里得距离，并要求我们在文件开头包含
    <samp class="SANS_TheSansMonoCd_W5Regular_11">import math</samp>，以便使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp>
    库的平方根函数。（[附录 A](appendix_A.xhtml)进一步讨论了如何从空间点创建图形，包括使用替代距离函数。）
- en: 'Second, since we are not using an explicit graph, we also define a <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>
    data structure to hold the connection between points in the same cluster:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，由于我们没有使用显式图形，我们还定义了一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>数据结构，用于存储同一簇中各点之间的连接：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This data structure is effectively identical to an undirected graph edge. It
    stores a pair of identifiers for the points and the distance (weight) between
    them. We define it here as an independent data structure to highlight the fact
    that we do not need to explicitly build a graph for single-linkage clustering.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据结构实际上与无向图的边完全相同。它存储了一对标识符，表示两个点以及它们之间的距离（权重）。我们在这里将其定义为一个独立的数据结构，以突出我们不需要显式地构建图来进行单链接聚类这一事实。
- en: 'Using these two helper data structures, we can then implement the single-linkage
    hierarchical clustering algorithm using an approach based on Kruskal’s algorithm:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个辅助数据结构，我们可以基于克鲁斯卡尔算法的思路实现单链接层次聚类算法：
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code takes a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Point</samp>
    objects (<samp class="SANS_TheSansMonoCd_W5Regular_11">points</samp>) to cluster.
    The function starts by creating a series of helper data structures, including
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp> data structure
    representing the disjoint sets (<samp class="SANS_TheSansMonoCd_W5Regular_11">djs</samp>)
    to determine which points already belong to the same cluster, an empty list (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">all_links</samp>) to hold all pairwise
    distances, and an empty list (<samp class="SANS_TheSansMonoCd_W5Regular_11">cluster_links</samp>)
    to hold the <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> objects
    representing each merge. The code then uses a nested pair of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to iterate through all pairs of points ❶. For each pair, the code computes
    the distance using the points’ <samp class="SANS_TheSansMonoCd_W5Regular_11">distance</samp>
    function and creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>
    data structure to hold this distance information. After all the pairwise distances
    are computed, the code sorts the links in order of increasing distance ❷.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 代码接受一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Point</samp> 对象列表 (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">points</samp>) 来进行聚类。该函数首先创建一系列辅助数据结构，包括一个表示离散集的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp> 数据结构 (<samp class="SANS_TheSansMonoCd_W5Regular_11">djs</samp>)，用来确定哪些点已经属于同一个聚类，一个空列表
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">all_links</samp>) 用来存储所有的点对距离，以及一个空列表
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">cluster_links</samp>) 用来存储表示每次合并的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> 对象。然后，代码使用一对嵌套的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环遍历所有点对 ❶。对于每一对，代码使用点的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">distance</samp> 函数计算距离，并创建一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>
    数据结构来保存这个距离信息。所有点对距离计算完成后，代码将按递增距离排序链接 ❷。
- en: Next, another <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    iterates over each edge in the sorted list, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp>
    data structure to check whether the next pair of points is already in the same
    cluster ❸. If not, the program adds the link to <samp class="SANS_TheSansMonoCd_W5Regular_11">cluster
    _links</samp>, joining the two clusters that contain those points, and merges
    the disjoint sets for the points.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，另一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环遍历排序列表中的每一条边，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UnionFind</samp> 数据结构检查下一个点对是否已经在同一个聚类中
    ❸。如果不是，程序将把这个链接添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">cluster _links</samp>
    中，将包含这两个点的两个聚类合并，并合并这些点的离散集。
- en: Finally, the code returns the list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>
    objects representing the clustering. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp>
    represents a connection between two previously disjoint clusters. The links in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cluster_links</samp> will be ordered
    by increasing distance, so the first element represents the first two points merged.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码返回表示聚类的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> 对象列表。每个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Link</samp> 表示两个之前不相交的聚类之间的连接。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cluster_links</samp> 中的链接将按距离递增顺序排列，因此第一个元素表示合并的前两个点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个例子</samp>
- en: '[Figure 10-10](#fig10-10) shows the steps of our clustering algorithm on the
    points from [Figure 10-9](#fig10-9). The left column of the figure shows the current
    clusters as connected graph components of the two-dimensional points. The right
    column of the figure shows the same clusters as merged points in the hierarchy
    with each cluster represented as a circle.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-10](#fig10-10)展示了我们在[图 10-9](#fig10-9)中的数据点上运行聚类算法的步骤。图的左列显示了当前的聚类，作为二维点的连接图组件。图的右列显示了相同的聚类，在层次结构中作为合并的点，每个聚类以圆形表示。'
- en: '![Four steps of the single-linkage clustering algorithm. In subfigure A there
    are five points and only two are connected with an edge.](../images/f10010.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![单链接聚类算法的四个步骤。在子图A中，有五个点，只有两个点通过边相连接。](../images/f10010.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-10: Single-linkage
    clustering</samp>'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 10-10：单链接聚类</samp>
- en: In [Figure 10-10(a)](#fig10-10), the algorithm has joined the closest two points—those
    at (1.2, 1) and (1.8, 1)—into a single cluster. Using the points’ labels from
    [Figure 10-9](#fig10-9), we call these points 2 and 3, respectively.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 10-10(a)](#fig10-10)中，算法将最接近的两个点——(1.2, 1)和(1.8, 1)——合并为一个聚类。使用[图 10-9](#fig10-9)中的点标签，我们分别将这两个点称为2和3。
- en: In the next step, in [Figure 10-10(b)](#fig10-10), the algorithm joins the two
    clusters with the closest pair of points. At this stage, the closest points are
    (1.2, 1) and (0.5, 1.5) with a distance of approximately 0.86\. Since (1.2, 1)
    is already part of a cluster, the algorithm merges the entire cluster with the
    one containing the single point (0.5, 1.5). The resulting cluster contains three
    points {2, 3, 4}.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，图[10-10(b)](#fig10-10)中，算法将最接近的点对所在的两个聚类合并。在这一阶段，最接近的点是(1.2, 1)和(0.5,
    1.5)，它们之间的距离约为0.86。由于(1.2, 1)已经是某个聚类的一部分，算法将整个聚类与包含单个点(0.5, 1.5)的聚类合并。最终得到的聚类包含三个点{2,
    3, 4}。
- en: The algorithm continues in [Figure 10-10(c)](#fig10-10) by creating a new merged
    cluster from the two remaining individual points (0, 0) and (1, 0). The algorithm
    has now created two separate clusters with three and two points, respectively.
    During the final step, in [Figure 10-10(d)](#fig10-10), these two clusters are
    merged by adding a link between the closest pair of points from each cluster (1.2,
    1) and (1, 0).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 算法在[图 10-10(c)](#fig10-10)中继续进行，通过将剩余的两个独立点(0, 0)和(1, 0)合并为一个新的聚类。此时，算法已经创建了两个分别包含三点和两点的独立聚类。在最后一步中，图[10-10(d)](#fig10-10)中，这两个聚类通过在每个聚类中最接近的点对(1.2,
    1)和(1, 0)之间添加一条链接来合并。
- en: Since single-linkage clustering grows the clusters by linking increasingly distant
    pairs of points, we can use this distance as a stopping threshold for the algorithm.
    For example, if we set the maximum distance to 0.95, we would produce the three
    distinct clusters shown in [Figure 10-10(b)](#fig10-10).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单链接聚类通过连接越来越远的点对来扩展聚类，我们可以将这种距离作为算法的停止阈值。例如，如果我们将最大距离设置为0.95，那么我们将得到[图 10-10(b)](#fig10-10)中显示的三个不同的聚类。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么这很重要</samp>
- en: The minimum spanning tree problem allows us to solve a range of real-world optimization
    problems, from building roads to designing communication networks. Within the
    field of computer science, we can use minimum spanning trees to help solve a range
    of problems in networking, clustering, and analysis of biological data. For example,
    we can represent a communication network as a graph and find the minimum spanning
    tree to inform which links need to be upgraded to ensure that all nodes are reachable
    through the new technology.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最小生成树问题可以帮助我们解决一系列现实世界中的优化问题，从建设道路到设计通信网络。在计算机科学领域，我们可以利用最小生成树来解决网络、聚类和生物数据分析等一系列问题。例如，我们可以将通信网络表示为一个图，并找到最小生成树，以决定哪些连接需要升级，确保所有节点都可以通过新技术互通。
- en: We can also apply the same basic approach to problems we might not normally
    think of as graph based. Using a variation of Kruskal’s algorithm, we can search
    for structure in real-valued datasets by building clusters of similar data points
    or design solvable mazes by introducing randomization into the algorithm to create
    novel solutions. In single-linkage clustering, we use the distances to determine
    which points are similar.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将相同的基本方法应用于那些我们通常不认为是基于图的问题。通过使用克鲁斯卡尔算法的变体，我们可以通过构建相似数据点的簇来搜索实数值数据集中的结构，或者通过在算法中引入随机化来设计可解的迷宫，从而创造出新颖的解决方案。在单链接聚类中，我们使用距离来确定哪些点是相似的。
- en: The next chapter expands on this discussion, introducing algorithms that help
    us identify the nodes and edges that are essential to maintaining connectivity.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将扩展这一讨论，介绍帮助我们识别对保持连通性至关重要的节点和边的算法。
