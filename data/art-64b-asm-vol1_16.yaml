- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: The String Instructions
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串指令
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'A *string* is a collection of values stored in contiguous memory locations.
    The x86-64 CPUs can process four types of strings: byte strings, word strings,
    double-word strings, and quad-word strings.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*是存储在连续内存位置中的一组值。x86-64 CPU 可以处理四种类型的字符串：字节字符串、字字符串、双字字符串和四字字符串。'
- en: The x86-64 microprocessor family supports several instructions specifically
    designed to cope with strings. They can move strings, compare strings, search
    for a specific value within a string, initialize a string to a fixed value, and
    do other primitive operations on strings. The x86-64’s string instructions are
    also useful for assigning and comparing arrays, tables, and records, and they
    may speed up your array-manipulation code considerably. This chapter explores
    various uses of the string instructions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 微处理器系列支持几条专门用于处理字符串的指令。它们可以移动字符串、比较字符串、在字符串中查找特定值、将字符串初始化为固定值，并对字符串执行其他基础操作。x86-64
    的字符串指令对于分配和比较数组、表格和记录也非常有用，它们可能大大加速你的数组操作代码。本章将探讨字符串指令的各种用途。
- en: 14.1 The x86-64 String Instructions
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 x86-64 字符串指令
- en: 'All members of the x86-64 family support five string instructions: `movs``x`,
    `cmps``x`, `scas``x`, `lods``x`, and `stos``x`.^([1](#c14-footnote-1)) (`x` =
    `b`, `w`, `d`, or `q` for byte, word, double word, or quad word, respectively;
    this book generally drops the `x` suffix when talking about these string instructions
    in a general sense.) Moving, comparing, scanning, loading, and storing are the
    primitives on which you can build most other string operations.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 x86-64 系列处理器都支持五条字符串指令：`movs``x`、`cmps``x`、`scas``x`、`lods``x` 和 `stos``x`。^([1](#c14-footnote-1))（`x`
    = `b`、`w`、`d` 或 `q`，分别表示字节、字、双字或四字；本书通常在讨论这些字符串指令时省略 `x` 后缀。）移动、比较、扫描、加载和存储是你可以构建大多数其他字符串操作的基础。
- en: 'The string instructions operate on *blocks* (contiguous linear arrays) of memory.
    For example, the `movs` instruction moves a sequence of bytes from one memory
    location to another, the `cmps` instruction compares two blocks of memory, and
    the `scas` instruction scans a block of memory for a particular value. The source
    and destination blocks (and any other values an instruction needs) are not provided
    as explicit operands, however. Instead, the string instructions use specific registers
    as operands:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串指令操作的是 *块*（连续的线性数组）内存。例如，`movs` 指令将一系列字节从一个内存位置移动到另一个位置，`cmps` 指令比较两个内存块，`scas`
    指令扫描内存块以查找特定值。然而，源块和目标块（以及指令需要的任何其他值）并不是作为显式操作数提供的。相反，字符串指令使用特定寄存器作为操作数：
- en: RSI (source index) register
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSI（源索引）寄存器
- en: RDI (destination index) register
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RDI（目标索引）寄存器
- en: RCX (count) register
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RCX（计数）寄存器
- en: AL, AX, EAX, and RAX registers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AL、AX、EAX 和 RAX 寄存器
- en: The direction flag in the FLAGS register
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FLAGS 寄存器中的方向标志
- en: For example, the `movs` (*move string*) instruction copies RCX elements from
    the source address specified by RSI to the destination address specified by RDI.
    Likewise, the `cmps` instruction compares the string pointed at by RSI, of length
    RCX, to the string pointed at by RDI.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`movs`（*移动字符串*）指令将从 RSI 指定的源地址复制 RCX 个元素到 RDI 指定的目标地址。同样，`cmps` 指令将 RSI 指向的字符串（长度为
    RCX）与 RDI 指向的字符串进行比较。
- en: 'The sections that follow describe how to use these five instructions, starting
    with a prefix that makes the instructions do what you’d expect: repeat their operation
    for each value in the string pointed to by RSI.^([2](#c14-footnote-2))'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分描述了如何使用这五条指令，首先是一个前缀，它使指令按照预期执行：对由 RSI 指向的字符串中的每个值重复操作。^([2](#c14-footnote-2))
- en: 14.1.1 The rep, repe, repz, and the repnz and repne Prefixes
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 rep、repe、repz、repnz 和 repne 前缀
- en: By themselves, the string instructions do not operate on strings of data. For
    example, the `movs` instruction will only copy a single byte, word, double word,
    or quad word. The repeat prefixes tell the x86-64 to do a multi-byte string operation—specifically,
    to repeat a string operation up to RCX times.^([3](#c14-footnote-3))
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用时，字符串指令不会对数据字符串进行操作。例如，`movs` 指令只会复制一个字节、字、双字或四字。重复前缀告诉 x86-64 执行多字节字符串操作——具体来说，重复执行字符串操作最多
    RCX 次。^([3](#c14-footnote-3))
- en: 'The syntax for the string instructions with repeat prefixes is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 带有重复前缀的字符串指令的语法如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You don’t normally use the repeat prefixes with the `lods` instruction.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不会将重复前缀与 `lods` 指令一起使用。
- en: The `rep` prefix tells the CPU to “repeat this operation the number of times
    specified by the RCX register.” The `repe` prefix says to “repeat this operation
    while the comparison is equal, or up to the number of times specified by RCX (whichever
    condition fails first).” The `repne` prefix’s action is “repeat this operation
    while the comparison is not equal, or up to the number of times specified by RCX.”
    As it turns out, you’ll use `repe` for most character string comparisons; `repne`
    is used mainly with the `scas``x` instructions to locate a specific character
    within a string (such as a zero-terminating byte).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`rep` 前缀告诉 CPU “按 RCX 寄存器指定的次数重复此操作。” `repe` 前缀表示“当比较相等时，重复此操作，或重复 RCX 指定的次数（先满足的条件为止）。”
    `repne` 前缀的动作是“当比较不相等时，重复此操作，或重复 RCX 指定的次数。” 实际上，你会在大多数字符字符串比较中使用 `repe`；`repne`
    主要与 `scas``x` 指令一起使用，用来在字符串中查找特定字符（如零终止字节）。'
- en: You can use repeat prefixes to process entire strings with a single instruction.
    You can use the string instructions, without the repeat prefix, as string primitive
    operations to synthesize more powerful string operations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用重复前缀通过单条指令处理整个字符串。你也可以在不使用重复前缀的情况下使用字符串指令，作为字符串原始操作来合成更强大的字符串操作。
- en: 14.1.2 The Direction Flag
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2 方向标志
- en: The *direction flag* in the FLAGS register controls how the CPU processes strings.
    If the direction flag is clear, the CPU increments RSI and RDI after operating
    on each string element. For example, executing `movs` will move the byte, word,
    double word, or quad word at RSI to RDI and then increment RSI and RDI by 1, 2,
    4, or 8 (respectively). When specifying the `rep` prefix before this instruction,
    the CPU increments RSI and RDI for each element in the string (the count in RCX
    specifies the number of elements). At completion, the RSI and RDI registers will
    be pointing at the first item beyond the strings.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: FLAGS 寄存器中的 *方向标志* 控制 CPU 如何处理字符串。如果方向标志被清除，CPU 在处理每个字符串元素后会增加 RSI 和 RDI。例如，执行
    `movs` 将会把 RSI 处的字节、字、双字或四字移动到 RDI，然后分别增加 RSI 和 RDI 1、2、4 或 8（依此类推）。当在此指令前指定 `rep`
    前缀时，CPU 会为字符串中的每个元素增加 RSI 和 RDI（RCX 中的计数指定元素的数量）。完成后，RSI 和 RDI 寄存器将指向字符串之后的第一个元素。
- en: If the direction flag is set, the x86-64 decrements RSI and RDI after it processes
    each string element (again, RCX specifies the number of string elements for a
    repeated string operation). Afterward, the RSI and RDI registers will be pointing
    at the first byte, word, or double word before the strings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方向标志被设置，x86-64 在处理每个字符串元素后会递减 RSI 和 RDI（同样，RCX 指定了重复字符串操作的元素数量）。之后，RSI 和 RDI
    寄存器将指向字符串之前的第一个字节、字或双字。
- en: You can change the direction flag’s value by using the `cld` (*clear direction
    flag*) and `std` (*set direction flag*) instructions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `cld`（*清除方向标志*）和 `std`（*设置方向标志*）指令来改变方向标志的值。
- en: The Microsoft ABI requires that the direction flag be clear upon entry into
    a (Microsoft ABI–compliant) procedure. Therefore, if you set the direction flag
    within a procedure, you should always clear that flag when you are finished using
    it (and especially before calling any other code or returning from the procedure).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 ABI 要求在进入一个（符合微软 ABI 的）过程时，方向标志必须被清除。因此，如果在过程内设置了方向标志，你应该在使用完它后始终清除该标志（特别是在调用其他代码或从过程返回之前）。
- en: 14.1.3 The movs Instruction
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3 movs 指令
- en: 'The `movs` instruction uses the following syntax:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`movs` 指令使用以下语法：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `movsb` (*move string, bytes*) instruction fetches the byte at address RSI,
    stores it at address RDI, and then increments or decrements the RSI and RDI registers
    by 1\. If the `rep` prefix is present, the CPU checks RCX to see whether it contains
    0\. If not, it moves the byte from RSI to RDI and decrements the RCX register.
    This process repeats until RCX becomes 0\. If RCX contains 0 upon initial execution,
    the `movsb` instruction will not copy any data bytes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`movsb`（*移动字符串，字节*）指令获取地址 RSI 处的字节，将其存储到地址 RDI，然后将 RSI 和 RDI 寄存器分别增加或减少 1。如果存在
    `rep` 前缀，CPU 会检查 RCX 是否为 0。如果不是，它会将字节从 RSI 移动到 RDI 并递减 RCX 寄存器。这个过程会重复，直到 RCX
    变为 0。如果 RCX 在初次执行时为 0，`movsb` 指令将不会复制任何数据字节。'
- en: The `movsw` (*move string, words*) instruction fetches the word at address RSI,
    stores it at address RDI, and then increments or decrements RSI and RDI by 2\.
    If there is a `rep` prefix, the CPU repeats this procedure RCX times.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`movsw`（*移动字符串，字长*）指令从地址RSI获取一个字，将其存储到地址RDI，然后将RSI和RDI分别增加或减少2。如果有`rep`前缀，CPU会重复执行此过程RCX次。'
- en: The `movsd` instruction operates in a similar fashion on double words. It increments
    or decrements RSI and RDI by 4 after each data movement.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`movsd`指令在双字（double words）上以类似的方式操作。在每次数据移动后，它会将RSI和RDI各增加或减少4。'
- en: Finally, the `movsq` instruction does the same thing on quad words. It increments
    or decrements RSI and RDI by 8 after each data movement.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`movsq`指令对四字（quad words）执行相同的操作。每次数据移动后，它会将RSI和RDI各增加或减少8。
- en: 'For example, this code segment copies 384 bytes from `CharArray1` to `CharArray2`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这段代码将384字节从`CharArray1`复制到`CharArray2`：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you substitute `movsw` for `movsb`, the preceding code will move 384 words
    (768 bytes) rather than 384 bytes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用`movsw`替换`movsb`，前面的代码将移动384个字（768字节），而不是384个字节：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Remember, the RCX register contains the element count, not the byte count; fortunately,
    the MASM `lengthof` operator returns the number of array elements (words), not
    the number of bytes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，RCX寄存器包含的是元素计数，而不是字节计数；幸运的是，MASM中的`lengthof`操作符返回的是数组元素的数量（字长），而不是字节数量。
- en: 'If you’ve set the direction flag before executing a `movsq`, `movsb`, `movsw`,
    or `movsd` instruction, the CPU decrements the RSI and RDI registers after moving
    each string element. This means that the RSI and RDI registers must point at the
    last element of their respective strings before executing a `movsb`, `movsw`,
    `movsd`, or `movsq` instruction. For example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在执行`movsq`、`movsb`、`movsw`或`movsd`指令之前设置了方向标志，CPU将在每次移动一个字符串元素后递减RSI和RDI寄存器。这意味着，在执行`movsb`、`movsw`、`movsd`或`movsq`指令之前，RSI和RDI寄存器必须指向各自字符串的最后一个元素。例如：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Although sometimes processing a string from tail to head is useful (see “Comparing
    Extended-Precision Integers” on page 834), generally you’ll process strings in
    the forward direction. For one class of string operations, being able to process
    strings in both directions is mandatory: moving strings when the source and destination
    blocks overlap. Consider what happens in the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时从尾到头处理字符串是有用的（参见第834页的“比较扩展精度整数”），但通常情况下，你会按正向方向处理字符串。对于某一类字符串操作，能够在两种方向上处理字符串是必需的：当源和目标块重叠时移动字符串。考虑以下代码的执行：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This sequence of instructions treats `CharArray1` and `CharArray2` as a pair
    of 384-byte strings. However, the last 383 bytes in the `CharArray1` array overlap
    the first 383 bytes in the `CharArray2` array. Let’s trace the operation of this
    code byte by byte.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这组指令将`CharArray1`和`CharArray2`当作一对384字节的字符串来处理。然而，`CharArray1`数组中的最后383个字节与`CharArray2`数组中的前383个字节重叠。让我们逐字节跟踪这段代码的执行。
- en: 'When the CPU executes the `movsb` instruction, it does the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当CPU执行`movsb`指令时，它会执行以下操作：
- en: Copies the byte at RSI (`CharArray1`) to the byte pointed at by RDI (`CharArray2`).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RSI指向的字节（`CharArray1`）复制到RDI指向的字节（`CharArray2`）。
- en: Increments RSI and RDI, and decrements RCX by 1\. Now the RSI register points
    at `CharArray1 + 1` (which is the address of `CharArray2`), and the RDI register
    points at `CharArray2 + 1`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加RSI和RDI，并将RCX递减1。现在RSI寄存器指向`CharArray1 + 1`（即`CharArray2`的地址），RDI寄存器指向`CharArray2
    + 1`。
- en: Copies the byte pointed at by RSI to the byte pointed at by RDI. However, this
    is the byte originally copied from location `CharArray1`. So, the `movsb` instruction
    copies the value originally in location `CharArray1` to both locations `CharArray2`
    and `CharArray2 + 1`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RSI指向的字节复制到RDI指向的字节。然而，这个字节原本是从`CharArray1`位置复制过来的。因此，`movsb`指令将原本位于`CharArray1`位置的值复制到`CharArray2`和`CharArray2
    + 1`位置。
- en: Again increments RSI and RDI, and decrements RCX.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次增加RSI和RDI，并递减RCX。
- en: Copies the byte from location `CharArray1 + 2` (`CharArray2 + 1`) to location
    `CharArray2 + 2`. Once again, this is the value that originally appeared in location
    `CharArray1`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将位于`CharArray1 + 2`（`CharArray2 + 1`）的字节复制到`CharArray2 + 2`位置。同样，这个值原本出现在`CharArray1`位置。
- en: Each repetition of the loop copies the next element in `CharArray1` to the next
    available location in the `CharArray2` array. Pictorially, it looks something
    like [Figure 14-1](#figure14-1). The result is that the `movsb` instruction replicates
    `X` throughout the string.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的每次重复都会将`CharArray1`中的下一个元素复制到`CharArray2`数组中下一个可用的位置。形象地看，类似于[图14-1](#figure14-1)。结果是`movsb`指令在字符串中复制了`X`。
- en: '![f14001](image_fi/501089c14/f14001.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![f14001](image_fi/501089c14/f14001.png)'
- en: 'Figure 14-1: Copying data between two overlapping arrays (forward direction)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-1：在两个重叠数组之间复制数据（正向方向）
- en: If you really want to move one array into another when they overlap like this,
    you should move each element of the source string to the destination string, starting
    at the end of the two strings, as shown in [Figure 14-2](#figure14-2).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的希望在两个数组重叠时将一个数组移入另一个数组，你应该从两个字符串的末尾开始，逐个元素地将源字符串的每个元素移动到目标字符串，如[图14-2](#figure14-2)所示。
- en: '![f14002](image_fi/501089c14/f14002.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![f14002](image_fi/501089c14/f14002.png)'
- en: 'Figure 14-2: Using a backward copy to copy data in overlapping arrays'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-2：使用反向复制复制重叠数组中的数据
- en: Setting the direction flag and pointing RSI and RDI at the end of the strings
    will allow you to (correctly) move one string to another when the two strings
    overlap and the source string begins at a lower address than the destination string.
    If the two strings overlap and the source string begins at a higher address than
    the destination string, clear the direction flag and point RSI and RDI at the
    beginning of the two strings.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设置方向标志并将RSI和RDI指向字符串的末尾，当两个字符串重叠并且源字符串的地址低于目标字符串时，这样可以让你（正确地）将一个字符串移动到另一个字符串。如果两个字符串重叠并且源字符串的地址高于目标字符串，则清除方向标志并将RSI和RDI指向两个字符串的开头。
- en: If the two strings do not overlap, you can use either technique to move the
    strings around in memory. Generally, operating with the direction flag clear is
    the easiest.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个字符串没有重叠，你可以使用任意一种技巧在内存中移动字符串。通常，清除方向标志进行操作是最简单的。
- en: You shouldn’t use the `movs``x` instruction to fill an array with a single byte,
    word, double-word, or quad-word value. Another string instruction, `stos`, is
    much better for this purpose.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该使用`movs``x`指令将一个数组填充为单一字节、字、双字或四字的值。另一个字符串指令`stos`在这种情况下要好得多。
- en: 'If you are moving a large number of bytes from one array to another, the copy
    operation will be faster if you can use the `movsq` instruction rather than the
    `movsb` instruction. If the number of bytes you wish to move is an even multiple
    of 8, this is a trivial change; just divide the number of bytes to copy by 8,
    load this value into RCX, and then use the `movsq` instruction. If the number
    of bytes is not evenly divisible by 8, you can use the `movsq` instruction to
    copy all but the last 1, 2, . . . , 7 bytes of the array (that is, the remainder
    after you divide the byte count by 8). For example, if you want to efficiently
    move 4099 bytes, you can do so with the following instruction sequence:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要从一个数组移动大量字节到另一个数组，使用`movsq`指令比使用`movsb`指令要更快。如果你要移动的字节数是8的偶数倍，那么这只是一个微不足道的变化；只需将要复制的字节数除以8，将这个值加载到RCX寄存器中，然后使用`movsq`指令。如果字节数不能被8整除，你可以使用`movsq`指令复制数组中除了最后1、2、……、7个字节以外的所有字节（也就是说，除去字节数除以8后的余数）。例如，如果你想高效地移动4099个字节，你可以使用以下指令序列：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using this technique to copy data never requires more than four `movs``x` instructions
    because you can copy 1, . . . , 7 bytes with no more than one (each) of the `movsb`,
    `movsw`, and `movsd` instructions. The preceding scheme is most efficient if the
    two arrays are aligned on quad-word boundaries. If not, you might want to move
    the `movsb`, `movsw`, or `movsd` instruction (or all three) before or after the
    `movsq` instruction so that `movsq` works with quad-word–aligned data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此技术复制数据时，最多只需要四个`movs``x`指令，因为你可以用不超过一个（每个）`movsb`、`movsw`和`movsd`指令来复制1、……、7个字节。如果两个数组按照四字对齐，这种方案最为高效。如果没有四字对齐，你可能需要将`movsb`、`movsw`或`movsd`指令（或所有三者）移到`movsq`指令之前或之后，以便`movsq`指令与四字对齐的数据一起工作。
- en: 'If you do not know the size of the block you are copying until the program
    executes, you can still use code like the following to improve the performance
    of a block move of bytes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在程序执行时才知道要复制的块的大小，仍然可以使用如下代码来提高字节块移动的性能：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On many computer systems, the `movsq` instruction provides about the fastest
    way to copy bulk data from one location to another. While there are, arguably,
    faster ways to copy data on certain CPUs, ultimately the memory bus performance
    is the limiting factor, and the CPUs are generally much faster than the memory
    bus. Therefore, unless you have a special system, writing fancy code to improve
    memory-to-memory transfers is probably a waste of time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多计算机系统上，`movsq`指令提供了一种快速的方式，将数据从一个位置复制到另一个位置。虽然在某些CPU上可能有更快的方式复制数据，但最终内存总线性能才是限制因素，而CPU通常比内存总线要快。因此，除非你有特别的系统，编写复杂的代码来提升内存到内存的传输速度可能是在浪费时间。
- en: Also, Intel has improved the performance of the `movs``x` instructions on later
    processors so that `movsb` operates as efficiently as `movsw`, `movsd`, and `movsq`
    when copying the same number of bytes. On these later processors, it may be more
    efficient to use `movsb` to copy the specified number of bytes rather than go
    through all the complexity outlined previously.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，英特尔在后来的处理器中改进了`movs``x`指令的性能，使得在复制相同数量字节时，`movsb`的效率与`movsw`、`movsd`和`movsq`相同。在这些后来的处理器上，使用`movsb`来复制指定数量的字节可能比之前提到的复杂方法更高效。
- en: 'The bottom line is this: if the speed of a block move matters to you, try it
    several different ways and pick the fastest (or the simplest, if they all run
    the same speed, which is likely).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是：如果块移动的速度对你很重要，可以尝试几种不同的方法，并选择最快的（或者如果它们速度相同，选择最简单的，这种情况也很有可能）。
- en: 14.1.4 The cmps Instruction
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.4 cmps指令
- en: 'The `cmps` instruction compares two strings. The CPU compares the value referenced
    by RDI to the value pointed at by RSI. RCX contains the number of elements in
    the source string when using the `repe` or `repne` prefix to compare entire strings.
    Like the `movs` instruction, MASM allows several forms of this instruction:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmps`指令用于比较两个字符串。CPU将RDI指向的值与RSI指向的值进行比较。当使用`repe`或`repne`前缀来比较整个字符串时，RCX包含源字符串中的元素数量。像`movs`指令一样，MASM允许此指令的几种形式：'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Without a repeat prefix, the `cmps` instruction subtracts the value at location
    RDI from the value at RSI and updates the flags according to the result (which
    it discards). After comparing the two locations, `cmps` increments or decrements
    the RSI and RDI registers by 1, 2, 4, or 8 (for `cmpsb`, `cmpsw`, `cmpsd`, and
    `cmpsq`, respectively). `cmps` increments the RSI and RDI registers if the direction
    flag is clear and decrements them otherwise.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有重复前缀，`cmps`指令会将RDI位置的值与RSI位置的值相减，并根据结果更新标志（结果会被丢弃）。在比较完这两个位置后，`cmps`会根据`cmpsb`、`cmpsw`、`cmpsd`和`cmpsq`的不同，分别将RSI和RDI寄存器加1、加2、加4或加8。如果方向标志为清除，`cmps`会递增RSI和RDI寄存器，否则会递减它们。
- en: Remember, the value in the RCX register determines the number of elements to
    process, not the number of bytes. Therefore, when using `cmpsw`, RCX specifies
    the number of words to compare. Likewise, for `cmpsd` and `cmpsq`, RCX contains
    the number of double and quad words to process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，RCX寄存器中的值决定了处理的元素数量，而不是字节数。因此，在使用`cmpsw`时，RCX指定比较的字数。同样，`cmpsd`和`cmpsq`时，RCX包含要处理的双字和四字的数量。
- en: The `repe` prefix compares successive elements in a string as long as they are
    equal and RCX is greater than 0\. The `repne` prefix does the same as long the
    elements are not equal.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`repe`前缀会在元素相等并且RCX大于0时，比较字符串中的连续元素。`repne`前缀则在元素不相等时执行相同操作。'
- en: After the execution of `repne cmps`, either the RCX register is 0 (in which
    case the two strings are totally different), or the RCX contains the number of
    elements compared in the two strings until a match is found. While this form of
    the `cmps` instruction isn’t particularly useful for comparing strings, it is
    useful for locating the first pair of matching items in a couple of byte, word,
    or double-word arrays.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完`repne cmps`后，RCX寄存器的值为0（此时两个字符串完全不同），或者RCX包含两个字符串中比较的元素数量，直到找到匹配项。虽然这种形式的`cmps`指令对比较字符串并不特别有用，但它对于定位字节、字或双字数组中第一对匹配的元素非常有用。
- en: 14.1.4.1 Comparing Character Strings
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.4.1 比较字符字符串
- en: Character strings are usually compared using *lexicographical ordering*, the
    standard alphabetical ordering you’ve grown up with. We compare corresponding
    elements until encountering a character that doesn’t match or the end of the shorter
    string. If a pair of corresponding characters does not match, compare the two
    strings based on that single character. If the two strings match up to the length
    of the shorter string, compare their length. The two strings are equal if and
    only if their lengths are equal and each corresponding pair of characters in the
    two strings is identical. The length of a string affects the comparison only if
    the two strings are identical up to the length of the shorter string. For example,
    `Zebra` is less than `Zebras` because it is the shorter of the two strings; however,
    `Zebra` is greater than `AAAAAAAAAAH!` even though `Zebra` is shorter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串通常使用 *字典顺序* 来比较，也就是你从小到大熟悉的标准字母顺序。我们比较对应的元素，直到遇到一个不匹配的字符或更短字符串的结尾。如果一对对应的字符不匹配，就基于该字符来比较两个字符串。如果两个字符串匹配到更短字符串的长度，那么就比较它们的长度。只有当两个字符串的长度相等，并且每对对应的字符都完全相同，两个字符串才被认为相等。字符串的长度只在两个字符串在更短字符串的长度范围内完全相等时才影响比较。例如，`Zebra`
    小于 `Zebras`，因为它是较短的那个字符串；然而，尽管 `Zebra` 较短，它还是大于 `AAAAAAAAAAH!`。
- en: 'For (ASCII) character strings, use the `cmpsb` instruction in the following
    manner:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于（ASCII）字符字符串，请按以下方式使用 `cmpsb` 指令：
- en: Clear the direction flag.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除方向标志。
- en: Load the RCX register with the length of the smaller string.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 RCX 寄存器加载为较短字符串的长度。
- en: Point the RSI and RDI registers at the first characters in the two strings you
    want to compare.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 RSI 和 RDI 寄存器指向你要比较的两个字符串的第一个字符。
- en: Use the `repe` prefix with the `cmpsb` instruction to compare the strings on
    a byte-by-byte basis.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `repe` 前缀和 `cmpsb` 指令按字节逐一比较字符串。
- en: If the two strings are equal, compare their lengths.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个字符串相等，则比较它们的长度。
- en: 'The following code compares a couple of character strings:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码比较了几个字符字符串：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you’re using bytes to hold the string lengths, you should adjust this code
    appropriately (that is, use a `movzx` instruction to load the lengths into RCX).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用字节来存储字符串长度，应该适当地调整此代码（即，使用 `movzx` 指令将长度加载到 RCX 寄存器中）。
- en: 14.1.4.2 Comparing Extended-Precision Integers
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.4.2 比较扩展精度整数
- en: You can also use the `cmps` instruction to compare multi-word integer values
    (that is, extended-precision integer values). Because of the setup required for
    a string comparison, this isn’t practical for integer values less than six or
    eight double words in length, but for large integer values, it’s excellent.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `cmps` 指令来比较多字整数值（即扩展精度整数值）。由于进行字符串比较需要一定的设置，因此对于小于六个或八个双字长度的整数值，这种方法并不实际，但对于大整数值来说，非常适用。
- en: 'Unlike with character strings, we cannot compare integer strings by using lexicographical
    ordering. When comparing strings, we compare the characters from the least significant
    byte to the most significant byte. When comparing integers, we must compare the
    values from the most significant byte, word, or double word down to the least
    significant. So, to compare two 32-byte (256-bit) integer values, use the following
    code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串不同，我们不能通过字典顺序来比较整数串。在比较字符串时，我们从最低有效字节到最高有效字节依次比较字符。而在比较整数时，我们必须从最高有效字节、字或双字开始，逐步比较到最低有效字节。所以，要比较两个32字节（256位）的整数值，可以使用以下代码：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code compares the integers from their most significant qword down to the
    least significant qword. The `cmpsq` instruction finishes when the two values
    are unequal or upon decrementing RCX to 0 (implying that the two values are equal).
    Once again, the flags provide the result of the comparison.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将整数从最重要的四字（qword）到最不重要的四字进行比较。`cmpsq` 指令在两个值不相等时停止，或者当 RCX 递减至 0 时停止（意味着两个值相等）。一如既往，标志提供比较结果。
- en: 14.1.5 The scas Instruction
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.5 `scas` 指令
- en: The `scas` (*scan string*) instruction is used to search for a particular element
    within a string—for example, to quickly scan for a 0 throughout another string.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`scas`（*扫描字符串*）指令用于在字符串中查找特定元素——例如，快速扫描另一个字符串中的 0。'
- en: Unlike the `movs` and `cmps` instructions, `scas` requires only a destination
    string (pointed at by RDI). The source operand is the value in the AL (`scasb`),
    AX (`scasw`), EAX (`scasd`), or RAX (`scasq`) register. The `scas` instruction
    compares the value in the accumulator (AL, AX, EAX, or RAX) against the value
    pointed at by RDI and then increments (or decrements) RDI by 1, 2, 4, or 8\. The
    CPU sets the flags according to the result of the comparison.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `movs` 和 `cmps` 指令不同，`scas` 只需要一个目标字符串（由 RDI 指向）。源操作数是 AL（`scasb`）、AX（`scasw`）、EAX（`scasd`）或
    RAX（`scasq`）寄存器中的值。`scas` 指令将累加器中的值（AL、AX、EAX 或 RAX）与由 RDI 指向的值进行比较，然后将 RDI 增加（或减少）1、2、4
    或 8。CPU 根据比较结果设置标志。
- en: 'The `scas` instructions take the following forms:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`scas` 指令有以下几种形式：'
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the `repe` prefix, `scas` scans the string, searching for an element that
    does not match the value in the accumulator. When using the `repne` prefix, `scas`
    scans the string, searching for the first element that is equal to the value in
    the accumulator. This is counterintuitive, because `repe` `scas` actually scans
    through the string while the value in the accumulator is equal to the string operand,
    and `repne` `scas` scans through the string while the accumulator is not equal
    to the string operand.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `repe` 前缀时，`scas` 扫描字符串，寻找一个与累加器中的值不匹配的元素。使用 `repne` 前缀时，`scas` 扫描字符串，寻找第一个与累加器中的值相等的元素。这有点反直觉，因为
    `repe` `scas` 实际上是在扫描字符串，而累加器中的值与字符串操作数相等，`repne` `scas` 则是在扫描字符串，而累加器的值与字符串操作数不相等。
- en: Like the `cmps` and `movs` instructions, the value in the RCX register specifies
    the number of elements, not bytes, to process when using a repeat prefix.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `cmps` 和 `movs` 指令一样，RCX 寄存器中的值指定了在使用重复前缀时要处理的元素数量，而不是字节数量。
- en: 14.1.6 The stos Instruction
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.6 `stos` 指令
- en: 'The `stos` instruction stores the value in the accumulator at the location
    specified by RDI. After storing the value, the CPU increments or decrements RDI
    depending on the state of the direction flag. Although the `stos` instruction
    has many uses, its primary use is to initialize arrays and strings to a constant
    value. For example, if you have a 256-byte array that you want to clear out with
    0s, use the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`stos` 指令将累加器中的值存储到由 RDI 指定的位置。存储值后，CPU 会根据方向标志的状态增加或减少 RDI。虽然 `stos` 指令有很多用途，但它的主要用途是将数组和字符串初始化为常量值。例如，如果你有一个
    256 字节的数组，想用 0 清空它，可以使用以下代码：'
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code writes 32 quad words rather than 256 bytes because a single `stosq`
    operation is faster (on some older CPUs) than four `stosb` operations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码写入的是 32 个四字，而不是 256 个字节，因为单个 `stosq` 操作比四个 `stosb` 操作要快（在一些旧的 CPU 上）。
- en: 'The `stos` instructions take eight forms:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`stos` 指令有八种形式：'
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `stosb` instruction stores the value in the AL register into the specified
    memory location(s), `stosw` stores the AX register into the specified memory location(s),
    `stosd` stores EAX into the specified location(s), and `stosq` stores RAX into
    the specified location(s). With the `rep` prefix, this process repeats the number
    of times specified by the RCX register.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`stosb` 指令将 AL 寄存器中的值存储到指定的内存位置，`stosw` 将 AX 寄存器存储到指定的内存位置，`stosd` 将 EAX 存储到指定的位置，`stosq`
    将 RAX 存储到指定的位置。使用 `rep` 前缀时，这个过程会重复 RCX 寄存器指定的次数。'
- en: If you need to initialize an array with elements that have different values,
    you cannot (easily) use `stos`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要初始化一个元素值不同的数组，你无法（轻易地）使用 `stos`。
- en: 14.1.7 The lods Instruction
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.7 `lods` 指令
- en: The `lods` instruction copies the byte, word, double word, or quad word pointed
    at by RSI into the AL, AX, EAX, or RAX register, after which it increments or
    decrements the RSI register by 1, 2, 4, or 8\. Use `lods` to fetch bytes (`lodsb`),
    words (`lodsw`), double words (`lodsd`), or quad words (`lodsq`) from memory for
    further processing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`lods` 指令将由 RSI 指向的字节、字、双字或四字复制到 AL、AX、EAX 或 RAX 寄存器中，之后它会增加或减少 RSI 寄存器的值，步长为
    1、2、4 或 8。使用 `lods` 从内存中获取字节（`lodsb`）、字（`lodsw`）、双字（`lodsd`）或四字（`lodsq`）以进行进一步处理。'
- en: 'Like `stos`, the `lods` instructions take eight forms:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `stos` 一样，`lods` 指令也有八种形式：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You will probably never use a repeat prefix with this instruction, because the
    accumulator register will be overwritten each time `lods` repeats. At the end
    of the repeat operation, the accumulator will contain the last value read from
    memory.^([4](#c14-footnote-4))
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能永远不会在此指令中使用重复前缀，因为每次 `lods` 重复时，累加器寄存器都会被覆盖。重复操作结束时，累加器将包含从内存读取的最后一个值。^([4](#c14-footnote-4))
- en: 14.1.8 Building Complex String Functions from lods and stos
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.8 从 lods 和 stos 构建复杂的字符串函数
- en: 'You can use the `lods` and `stos` instructions to generate any particular string
    operation. For example, suppose you want a string operation that converts all
    the uppercase characters in a string to lowercase. You could use the following
    code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `lods` 和 `stos` 指令生成任何特定的字符串操作。例如，假设你需要一个将字符串中的所有大写字符转换为小写的字符串操作。你可以使用以下代码：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `rpt` loop fetches the byte at the location specified by RSI, tests whether
    it is an uppercase character, converts it to lowercase if it is (leaving it unchanged
    if it is not), stores the resulting character at the location specified by RDI,
    and then repeats this process the number of times specified by the value in RCX.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`rpt` 循环获取 RSI 指定位置的字节，测试其是否为大写字母，如果是，则将其转换为小写字母（如果不是，则保持不变），然后将结果字符存储在 RDI
    指定的位置，并重复这一过程，直到 RCX 中的值指定的次数为止。'
- en: Because the `lods` and `stos` instructions use the accumulator as an intermediary
    location, you can use any accumulator operation to quickly manipulate string elements.
    This could be something as simple as a `toLower` (or `toUpper`) function or as
    complex as data encryption. You might even use this instruction sequence to compute
    a hash, checksum, or CRC value while moving data from one string to another. Any
    operation you would do on a string on a character-by-character basis while moving
    the string data around is a candidate.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `lods` 和 `stos` 指令使用累加器作为中介位置，你可以使用任何累加器操作来快速操作字符串元素。这可以是像 `toLower`（或 `toUpper`）这样的简单函数，也可以是像数据加密这样的复杂操作。你甚至可以使用这一指令序列在将数据从一个字符串移动到另一个字符串时计算哈希值、校验和或
    CRC 值。在移动字符串数据的同时，你对字符串逐字符进行的任何操作都是可行的。
- en: 14.2 Performance of the x86-64 String Instructions
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 x86-64 字符串指令的性能
- en: In the early x86-64 processors, the string instructions provided the most efficient
    way to manipulate strings and blocks of data. However, these instructions are
    not part of Intel’s RISC Core instruction set and can be slower (though more compact)
    than if you did the same operations with discrete instructions. Intel has optimized
    `movs` and `stos` on later processors so that they operate as rapidly as possible,
    but the other string instructions can be fairly slow.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的 x86-64 处理器中，字符串指令提供了操作字符串和数据块的最有效方法。然而，这些指令并不是 Intel RISC 核心指令集的一部分，因此可能比使用离散指令执行相同操作时要慢（尽管它们更紧凑）。Intel
    在后来的处理器上优化了 `movs` 和 `stos` 指令，使其尽可能快速运行，但其他字符串指令可能相对较慢。
- en: As always, it’s a good idea to implement performance-critical algorithms by
    using different algorithms (with and without the string instructions) and comparing
    their performance to determine which solution to use. Because the string instructions
    run at different speeds relative to other instructions depending on which processor
    you’re using, try your experiments on the processors where you expect your code
    to run.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，建议通过使用不同的算法（包括使用和不使用字符串指令的算法）来实现性能关键的算法，并通过比较它们的性能来确定使用哪种解决方案。由于字符串指令相对于其他指令的运行速度取决于你使用的处理器，因此请在你预期代码运行的处理器上进行实验。
- en: 14.3 SIMD String Instructions
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 SIMD 字符串指令
- en: The SSE4.2 instruction set extensions include four powerful instructions for
    manipulating character strings. These instructions were first introduced in 2008,
    so some computers in use today still might not support them. Always use `cpuid`
    to determine if these instructions are available before attempting to use them
    in wide-distribution commercial applications (see “Using cpuid to Differentiate
    Instruction Sets” in Chapter 11).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: SSE4.2 指令集扩展包括四条强大的字符字符串操作指令。这些指令最早在 2008 年推出，因此今天仍有一些计算机可能不支持它们。在尝试在广泛分发的商业应用程序中使用它们之前，请始终使用
    `cpuid` 来确定这些指令是否可用（请参见第 11 章中的“使用 cpuid 区分指令集”）。
- en: 'The four SSE4.2 instructions that process text and string fragments are as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文本和字符串片段的四条 SSE4.2 指令如下：
- en: '`PCMPESTRI` Packed compare explicit-length strings, return index'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PCMPESTRI` 打包比较显式长度字符串，返回索引'
- en: '`PCMPESTRM` Packed compare explicit-length strings, return mask'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PCMPESTRM` 打包比较显式长度字符串，返回掩码'
- en: '`PCMPISTRI` Packed compare implicit-length strings, return index'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PCMPISTRI` 打包比较隐式长度字符串，返回索引'
- en: '`PCMPISTRM` Packed compare implicit-length strings, return mask'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PCMPISTRM` 打包比较隐式长度字符串，返回掩码'
- en: '*Implicit-length strings* use a sentinel (trailing) byte to mark the end of
    the string, specifically, a zero-terminating byte (or word, in the case of Unicode
    characters). *Explicit-length strings* are those for which you supply a string
    length.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*隐式长度字符串*使用哨兵（尾部）字节标记字符串的结束，具体来说，是一个零终止字节（或在 Unicode 字符的情况下是字）。*显式长度字符串*是那些你需要提供字符串长度的字符串。'
- en: Instructions that produce an index return the index of the first (or last) matching
    occurrence within the source string. Instructions that return a bit mask return
    an array of 0 or (all) 1 bits that mark each occurrence of the match within the
    two input strings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 产生索引的指令返回源字符串中第一次（或最后一次）匹配的索引。返回位掩码的指令返回一个包含 0 或（全部）1 位的数组，标记两个输入字符串中每个匹配的出现位置。
- en: The packed compare string instructions are among the most complex in the x86-64
    instruction set. The syntax for these instructions is
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 打包比较字符串指令是 x86-64 指令集中最复杂的指令之一。这些指令的语法为
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: where `X` is `E` or `I`, and `Y` is `I` or `M`. Both forms use 128-bit operands
    (no 256-bit YMM registers for the `v`-prefixed form in this case), and, unlike
    most SSE instructions, the `(v)pcmp``X``str``Y` instructions allow memory operands
    that are not aligned on a 16-byte boundary (they would be nearly useless for their
    intended operation if they required 16-byte-aligned memory operands).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `X` 为 `E` 或 `I`，`Y` 为 `I` 或 `M`。这两种形式都使用 128 位操作数（在这种情况下，`v` 前缀形式没有 256 位的
    YMM 寄存器），并且与大多数 SSE 指令不同，`(v)pcmp``X``str``Y` 指令允许操作数不按 16 字节对齐（如果需要 16 字节对齐的内存操作数，它们将几乎无法用于其预期操作）。
- en: The `(v)pcmp``X``str``Y` instructions compare corresponding bytes or words in
    a pair of XMM registers, combine the results of the individual comparisons into
    a vector (bit mask), and return the results for all the comparisons. The `imm`[8]
    operand controls various comparison attributes as described in “Type of Comparison”
    on the following page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pcmp``X``str``Y` 指令比较一对 XMM 寄存器中相应的字节或字，将各个比较结果合并成一个向量（位掩码），并返回所有比较的结果。`imm`[8]
    操作数控制各种比较属性，如“比较类型”中所述（见下一页）。'
- en: 14.3.1 Packed Compare Operand Sizes
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.1 打包比较操作数大小
- en: Bits 0 and 1 of the immediate operand specify the size and type of the string
    elements. The elements can be bytes or words, or they can be treated as unsigned
    or signed values for the comparison (see [Table 14-1](#table14-1)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 立即数操作数的第 0 位和第 1 位指定字符串元素的大小和类型。元素可以是字节或字，或者它们可以作为无符号或有符号值用于比较（请参见 [表 14-1](#table14-1)）。
- en: Bit 0 specifies word (Unicode) or byte (ASCII) operands. Bit 1 specifies whether
    the operands are signed or unsigned. Generally, for character strings, you use
    unsigned comparisons. However, in certain situations (or when processing strings
    of integers rather than characters), you may want to specify signed comparisons.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 位 0 指定字（Unicode）或字节（ASCII）操作数。位 1 指定操作数是有符号还是无符号。通常，对于字符字符串，使用无符号比较。然而，在某些情况下（或处理整数而非字符的字符串时），你可能需要指定有符号比较。
- en: 'Table 14-1: Packed Compare `imm`[8] Bits 0 and 1'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-1：打包比较 `imm`[8] 第 0 位和第 1 位
- en: '| **Bit(s)** | **Bit value** | **Meaning** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **位(s)** | **位值** | **含义** |'
- en: '| --- | --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0–1 | 00 | Both source operands contain 16 unsigned bytes. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 0–1 | 00 | 两个源操作数都包含 16 个无符号字节。 |'
- en: '|  | 01 | Both source operands contain 8 unsigned words. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|  | 01 | 两个源操作数都包含 8 个无符号字。 |'
- en: '|  | 10 | Both source operands contain 16 signed bytes. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|  | 10 | 两个源操作数都包含 16 个有符号字节。 |'
- en: '|  | 11 | Both source operands contain 8 signed words. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|  | 11 | 两个源操作数都包含 8 个有符号字。 |'
- en: 14.3.2 Type of Comparison
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.2 比较类型
- en: Bits 2 and 3 of the immediate operand specify how the instruction will compare
    the two strings. There are four comparison types, which test characters from one
    string against the set of characters in the second, test characters from one string
    against a range of characters, do a straight string comparison, or search for
    a substring within another string (see [Table 14-2](#table14-2)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 立即数操作数的第 2 位和第 3 位指定指令如何比较这两个字符串。有四种比较类型，它们分别是：测试一个字符串中的字符与第二个字符串中的字符集合进行比较，测试一个字符串中的字符与字符范围进行比较，执行字符串的直接比较，或者在另一个字符串中搜索子字符串（见
    [表 14-2](#table14-2)）。
- en: 'Table 14-2: Packed Compare `imm`[8] Bits 2 and 3'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-2：打包比较 `imm`[8] 第 2 位和第 3 位
- en: '| **Bit(s)** | **Bit value** | **Meaning** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **位(s)** | **位值** | **含义** |'
- en: '| --- | --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 2–3 | 00 | Equal any: compares each character in the second source string
    against a set of characters appearing in the first source operand. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 2–3 | 00 | 等于任何：比较第二个源字符串中的每个字符与第一个源操作数中出现的字符集合。 |'
- en: '|  | 01 | Ranges: compares each value in the second source operand against
    a set of ranges specified by the first source operand. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  | 01 | 范围：将第二个源操作数中的每个值与第一个源操作数指定的一组范围进行比较。 |'
- en: '|  | 10 | Equal each: compares each corresponding element for equality (character-by-character
    comparison of the two operands). |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|  | 10 | 每个相等：逐字符比较两个操作数的每个对应元素的相等性。 |'
- en: '|  | 11 | Equal ordered: searches for the substring specified by the first
    operand within the string specified by the second operand. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|  | 11 | 有序相等：在由第二个操作数指定的字符串中查找由第一个操作数指定的子字符串。 |'
- en: Bits 2 to 3 specify the type of comparison to perform (the *aggregate operation*
    in Intel terminology). *Equal each* (10b) is probably the easiest comparison to
    understand. The packed compare instruction will compare each corresponding character
    in the string (up to the length of the string—more on that later) and set a Boolean
    flag for the result of the comparison of each byte or word in the string, as shown
    in [Figure 14-3](#figure14-3). This is comparable to the operation of the C/C++
    `memcmp()` or `strcmp()` functions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 位2到3指定要执行的比较类型（在Intel术语中称为*聚合操作*）。*每个相等*（10b）可能是最容易理解的比较方式。打包的比较指令将比较字符串中每个相应的字符（最多到字符串的长度——稍后会详细说明），并为字符串中每个字节或字的比较结果设置一个布尔标志，如[图14-3](#figure14-3)所示。这与C/C++的`memcmp()`或`strcmp()`函数的操作类似。
- en: '![f14003](image_fi/501089c14/f14003.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![f14003](image_fi/501089c14/f14003.png)'
- en: 'Figure 14-3: Equal each aggregate comparison operation'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-3：每个相等聚合比较操作
- en: The *equal any* comparison compares each byte in the second source operand to
    see whether it is any of the characters found in the first source operand (XMM[src2]/mem[src2]).
    For example, if XMM[src1] contains the string `abcdefABCDEF` (and four 0 bytes),
    and XMM[src2]/mem[src2] contains `12AF89C0`, the resulting comparison would yield
    00101100b (1s in the character positions corresponding to the A, F, and C characters).
    Also note that the first character (1) maps to bit 0, and the A and F characters
    map to bits 2 and 3\. This is similar to the `strspn()` and `strcspn()` functions
    in the C Standard Library.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*任意相等*比较将第二个源操作数中的每个字节与第一个源操作数中的字符进行比较，看它是否与其中的任何一个字符匹配（XMM[src2]/mem[src2]）。例如，如果XMM[src1]包含字符串`abcdefABCDEF`（以及四个0字节），而XMM[src2]/mem[src2]包含`12AF89C0`，则结果比较将产生00101100b（在对应于字符A、F和C的位置上是1）。还请注意，第一个字符（1）映射到位0，A和F字符分别映射到位2和3。这类似于C标准库中的`strspn()`和`strcspn()`函数。'
- en: The *equal ordered* comparison searches for each occurrence of the string in
    XMM[src1] that can be found in the XMM[src2]/mem[src2] operand. For example, if
    the XMM[src2]/mem[src2] operand contains the string `never need shine` and the
    XMM[src1] operand has the string `ne` (padded with 0s), then the equal ordered
    comparison produces the vector 0100000001000001b. This is similar to the `strstr()`
    function in the C Standard Library.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*有序相等*比较将在XMM[src1]中查找每个可以在XMM[src2]/mem[src2]操作数中找到的字符串。例如，如果XMM[src2]/mem[src2]操作数包含字符串`never
    need shine`，而XMM[src1]操作数包含字符串`ne`（用0填充），则有序相等比较将生成向量0100000001000001b。这类似于C标准库中的`strstr()`函数。'
- en: The *ranges* comparison aggregate operation breaks the entries in the XMM[src1]
    operand into pairs (at even and odd indexes in the register). The first element
    (byte or word) specifies a lower bound, and the second entry specifies an upper
    bound. The XMM[src1] register supports up to eight byte ranges or four word ranges
    (if you need fewer ranges, pad the remaining pairs with 0s). This aggregate operation
    compares each character in the XMM[src2]/mem[src2] operand against each of these
    ranges and stores true in the resultant vector if the character is within one
    of the specified ranges (inclusive) and false if it is outside all of these ranges.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*范围*比较聚合操作将XMM[src1]操作数中的条目分成成对（在寄存器的偶数和奇数索引处）。第一个元素（字节或字）指定下限，第二个条目指定上限。XMM[src1]寄存器最多支持八个字节范围或四个字范围（如果需要更少的范围，可以将剩余的对填充为0）。此聚合操作将XMM[src2]/mem[src2]操作数中的每个字符与这些范围中的每个进行比较，如果字符在指定的范围内（包括在内），则在结果向量中存储true，如果它超出了这些范围，则存储false。'
- en: 14.3.3 Result Polarity
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.3 结果极性
- en: Bits 4 and 5 of the immediate operand specify the result polarity (see [Table
    14-3](#table14-3)). This chapter will fully discuss the meaning of these bits
    in a moment (some additional commentary is necessary).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 立即数操作数的位4和位5指定结果的极性（见[表14-3](#table14-3)）。本章将在稍后详细讨论这些位的含义（需要一些额外的注释）。
- en: 'Table 14-3: Packed Compare `imm`[8] Bits 4 and 5'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '表 14-3: 打包比较 `imm`[8] 位 4 和 5'
- en: '| **Bit(s)** | **Bit value** | **Meaning** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **位值** | **含义** |'
- en: '| --- | --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 4–5 | 00 | Positive polarity |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 4–5 | 00 | 正极性 |'
- en: '|  | 01 | Negative polarity |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|  | 01 | 负极性 |'
- en: '|  | 10 | Positive masked |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|  | 10 | 正掩码 |'
- en: '|  | 11 | Negative masked |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|  | 11 | 负掩码 |'
- en: 14.3.4 Output Processing
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.4 输出处理
- en: Bit 6 of the immediate operand specifies the instruction result (see [Table
    14-4](#table14-4)). The packed compare instructions do not use bit 7; it should
    always be 0.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 立即操作数的第 6 位指定指令结果（参见 [表 14-4](#table14-4)）。打包比较指令不使用第 7 位；它应始终为 0。
- en: 'Table 14-4: Packed Compare `imm`[8] Bit 6 (and 7)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '表 14-4: 打包比较 `imm`[8] 位 6（和 7）'
- en: '| **Bit(s)** | **Bit value** | **Meaning** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **位** | **位值** | **含义** |'
- en: '| --- | --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 6 | 0 | `(v)pcom``X``stri` only, the index returned in ECX is the first result.
    `(v)pcom``X``strm` only, the mask appears in the LO bits of XMM0 with zero extension
    to 128 bits. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0 | 仅限 `(v)pcom``X``stri`，返回的索引存储在 ECX 中，是第一个结果。仅限 `(v)pcom``X``strm`，掩码出现在
    XMM0 的低位，零扩展到 128 位。 |'
- en: '|  | 1 | `(v)pcom``X``stri` only, the index returned in ECX is the last result.
    `(v)pcom``X``strm` only, expand the bit mask into a byte or word mask. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|  | 1 | 仅限 `(v)pcom``X``stri`，返回的索引存储在 ECX 中，是最后一个结果。仅限 `(v)pcom``X``strm`，将位掩码扩展为字节或字掩码。
    |'
- en: '| 7 | 0 | This bit is reserved and should always be 0. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 0 | 此位保留，应始终为 0。 |'
- en: The `(v)pcmpestrm` and `(v)pcmpistrm` instructions produce a bit-mask result
    and store it into the XMM0 register (this is fixed—the CPU does not determine
    this by the operands to these instructions). If bit 6 of the `imm`8 operand contains
    a 0, these two instructions pack this bit mask into 8 or 16 bits and store them
    into the LO 8 (or 16) bits of XMM0, zero-extending that value through the upper
    bits of XMM0\. If `imm`8 bit 6 contains a 1, these instructions will store the
    bit mask (all 1 bits per byte or word) throughout the XMM0 register.^([5](#c14-footnote-5))
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pcmpestrm` 和 `(v)pcmpistrm` 指令生成一个位掩码结果并将其存储到 XMM0 寄存器中（这是固定的——CPU 不根据这些指令的操作数来确定）。如果
    `imm`8 操作数的第 6 位是 0，这两个指令会将该位掩码打包成 8 或 16 位并存储到 XMM0 的低 8 位（或 16 位），并将该值零扩展到 XMM0
    的高位。如果 `imm`8 位 6 是 1，这些指令将会将位掩码（每个字节或字的所有 1 位）存储到整个 XMM0 寄存器中。^([5](#c14-footnote-5))'
- en: The `(v)pcmpestri` and `(v)pcmpistri` instructions produce an index result and
    return this value in the ECX register.^([6](#c14-footnote-6)) If bit 6 of the
    `imm`8 operand contains a 0, these two instructions return the index of the LO
    set bit in the result bit mask (that is, the first matching comparison). If bit
    6 of the `imm`8 operand is 1, these instructions return the index of the highest-order
    set bit in the resultant bit mask (that is, the last matching comparison). If
    there are no set bits in the result bit mask, these instructions return 16 (for
    byte comparisons) or 8 (for word comparisons) in the ECX register. Although these
    instructions internally generate a bit mask result in order to calculate the index,
    they do not overwrite the XMM0 register (as do the `(v)pcmpestrm` and `(v)pcmpistrm`
    instructions).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pcmpestri` 和 `(v)pcmpistri` 指令生成一个索引结果，并将该值返回到 ECX 寄存器中。^([6](#c14-footnote-6))
    如果 `imm`8 操作数的第 6 位是 0，这两个指令返回结果位掩码中最低位设置的位的索引（即，第一个匹配的比较）。如果 `imm`8 操作数的第 6 位是
    1，这些指令返回结果位掩码中最高位设置的位的索引（即，最后一个匹配的比较）。如果结果位掩码中没有设置的位，这些指令将返回 16（用于字节比较）或 8（用于字比较）到
    ECX 寄存器。尽管这些指令在内部生成位掩码结果以计算索引，但它们不会覆盖 XMM0 寄存器（与 `(v)pcmpestrm` 和 `(v)pcmpistrm`
    指令不同）。'
- en: 14.3.5 Packed String Compare Lengths
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.5 打包字符串比较长度
- en: The `(v)pcmp``X``str``Y` instructions have a 16-byte (XMM register size) comparison
    limit. This is true even on AVX processors with 32-byte YMM registers. To compare
    larger strings requires executing multiple `(v)pcmp``X``str``Y` instructions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pcmp``X``str``Y` 指令有一个 16 字节（XMM 寄存器大小）的比较限制。即使在具有 32 字节 YMM 寄存器的 AVX 处理器上也是如此。要比较更大的字符串，需要执行多个
    `(v)pcmp``X``str``Y` 指令。'
- en: The `(v)pcmpistri` and `(v)pcmpistrm` instructions use an implicit string length.
    The strings appear in the XMM registers or memory with the first character (if
    any) appearing in the LO byte followed by the remaining characters in the string.
    The strings end with a zero-terminating byte or word. If there are more than 16
    characters (if byte strings, or 8 characters if word strings), then the register
    (or 128-bit memory) size delimits the string.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pcmpistri`和`(v)pcmpistrm`指令使用隐式字符串长度。字符串出现在XMM寄存器或内存中，首字符（如果有）出现在LO字节中，后续字符按顺序排列。字符串以零终止字节或字结束。如果字符数超过16（字节字符串）或8（字字符串），则寄存器（或128位内存）大小将限制字符串的长度。'
- en: The `(v)pcmpestri` and `(v)pcmpestrm` instructions use explicitly supplied string
    lengths. The RAX and EAX registers specify the string length for the string appearing
    in XMM[src1], and the RDX and EDX registers specify the string length for the
    string appearing in XMM[src2]/mem[src2]. If the string length is greater than
    16 (for byte strings) or 8 (for word strings), the instruction saturates the length
    at 16 or 8\. Also, the `(v)pcmpestri` and `(v)pcmpestrm` instructions take the
    absolute value of the length, so –1 to –16 is equivalent to 1 to 16\.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pcmpestri`和`(v)pcmpestrm`指令使用显式提供的字符串长度。RAX和EAX寄存器指定XMM[src1]中字符串的长度，RDX和EDX寄存器指定XMM[src2]/mem[src2]中字符串的长度。如果字符串长度大于16（字节字符串）或8（字字符串），指令会将长度饱和为16或8。另外，`(v)pcmpestri`和`(v)pcmpestrm`指令会取长度的绝对值，因此-1到-16等同于1到16。'
- en: The reason the explicit-length instructions saturate the length to 16 (or 8)
    is to allow a program to process larger strings in a loop. By processing 16 bytes
    (or 8 words) at a time in a loop and decrementing the overall string length (from
    some large value down to 0), the packed string operations will operate on 16 or
    8 characters per loop iteration until the very last loop iteration. At that point,
    the instructions will process the remaining (total length mod 16 or 8) characters
    in the string.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 显式长度指令将长度饱和为16（或8）的原因是允许程序在循环中处理更大的字符串。通过在循环中每次处理16字节（或8字）并递减总字符串长度（从某个大值递减到0），打包字符串操作将在每次循环迭代时处理16个或8个字符，直到最后一次循环迭代。在这一点上，指令将处理字符串中剩余的（总长度对16或8取模）字符。
- en: The reason the explicit-length instructions take the absolute value of the length
    is to allow code that processes large strings to either decrement the loop counter
    (from a large positive value) to 0 or increment the loop counter (from a negative
    value) toward 0, whichever is more convenient for the program.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 显式长度指令取长度的绝对值的原因是允许处理大字符串的代码将循环计数器（从大正值到0递减）或（从负值递增）到0，以便程序能够更方便地操作。
- en: Whenever the length (implicit or explicit) is less than 16 (for bytes) or 8
    (for words), certain characters in the XMM register (or 128-bit memory location)
    will be invalid. Specifically, every character after the zero-terminating character
    (for implicit-length strings) or beyond the count in RAX and EAX or RDX and EDX
    will be invalid. Regardless of the presence of invalid characters, the packed
    compare instructions still produce an intermediate bit vector result by comparing
    all characters in the string.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当长度（隐式或显式）小于16（字节）或8（字）时，XMM寄存器（或128位内存位置）中的某些字符将无效。具体来说，零终止字符后的每个字符（对于隐式长度字符串）或超出RAX和EAX或RDX和EDX中计数的部分将无效。无论是否存在无效字符，打包比较指令仍会通过比较字符串中的所有字符，生成一个中间位向量结果。
- en: 'Because the string lengths of the two input strings (in XMM[src1] and XMM[src2]/mem[src2])
    are not necessarily equal, there are four possible situations: `src1` and `src2`
    are both invalid, exactly one of the two source operands is invalid (and the other
    is valid, so there are two cases here), or both are valid. Depending on which
    operands are valid or invalid, the packed compare instructions may force the result
    to true or false. [Table 14-5](#table14-5) lists how these instructions force
    results, based on the type of comparison (aggregate operation) specified by the
    `imm`8 operand.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '由于两个输入字符串（在XMM[src1]和XMM[src2]/mem[src2]中）的字符串长度不一定相等，因此有四种可能的情况：`src1`和`src2`都无效，恰好一个源操作数无效（另一个有效，所以这里有两种情况），或者两者都有效。根据哪个操作数有效或无效，打包比较指令可能会强制结果为真或假。[表14-5](#table14-5)列出了这些指令如何强制结果，具体取决于`imm`8操作数指定的比较类型（聚合操作）。 '
- en: 'Table 14-5: Comparison Result When Source 1 and Source 2 Are Valid or Invalid'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表14-5：当源1和源2有效或无效时的比较结果
- en: '| **Src1** | **Src2** | **Equal any** | **Ranges** | **Equal each** | **Equal
    ordered** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **Src1** | **Src2** | **等任意** | **范围** | **等每个** | **等序** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Invalid | Invalid | Force false | Force false | Force true | Force true |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 无效 | 无效 | 强制假 | 强制假 | 强制真 | 强制真 |'
- en: '| Invalid | Valid | Force false | Force false | Force false | Force true |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 无效 | 有效 | 强制假 | 强制假 | 强制假 | 强制真 |'
- en: '| Valid | Invalid | Force false | Force false | Force false | Force false |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 有效 | 无效 | 强制假 | 强制假 | 强制假 | 强制假 |'
- en: '| Valid | Valid | Result | Result | Result | Result |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 有效 | 有效 | 结果 | 结果 | 结果 | 结果 |'
- en: To understand the entries in this table, you must consider each comparison type
    individually.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解此表中的条目，你必须分别考虑每种比较类型。
- en: The *equal any* comparison checks whether each character appearing in `src2`
    appears anywhere in the set of characters specified by `src1`. If a character
    in `src1` is invalid, that means the instructions are comparing against a character
    that is not in the set; in this situation, you want to return false (regardless
    of `src2`’s validity). If `src1` is valid but `src2` is invalid, you’re at (or
    beyond) the end of the string; that’s not a valid comparison, so equal any also
    forces a false result in this situation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*等任意*比较会检查`src2`中每个出现的字符是否出现在`src1`指定的字符集内。如果`src1`中的某个字符无效，那意味着指令正在比较一个不在字符集中的字符；在这种情况下，你希望返回假（不论`src2`是否有效）。如果`src1`有效但`src2`无效，则你已经到达（或超过）字符串的末尾；这不是一个有效的比较，因此*等任意*也会在这种情况下强制返回假结果。'
- en: The *ranges* comparison is also (in a sense) comparing a source string (`src2`)
    against a set of characters (specified by the ranges in `src1`). Therefore, the
    packed compare instructions force false if either (or both) operands are invalid
    for the same reasons as *equal any* comparisons.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*范围*比较也是（某种意义上）将源字符串（`src2`）与一组字符（由`src1`中的范围指定）进行比较。因此，如果任一操作数无效，打包比较指令会强制返回假，原因与*等任意*比较相同。'
- en: The *equal each* comparison is the traditional string comparison operation,
    comparing the string in `src2` to the string in `src1`. If the corresponding character
    in both strings is invalid, you’ve moved beyond the end of both strings. The packed
    compare instructions force the result to true in this situation because these
    instructions are, effectively, comparing empty strings at this point (and empty
    strings are equal). If a character in one string is valid but the corresponding
    character in the other string is invalid, you’re comparing actual characters against
    an empty string, which is always *not equal*; hence, the packed string comparison
    instructions force a false result.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*等每个*比较是传统的字符串比较操作，比较`src2`中的字符串与`src1`中的字符串。如果两个字符串中对应的字符无效，那么你已经越过了两个字符串的末尾。打包比较指令在这种情况下会强制返回真，因为这些指令实际上是在比较空字符串（空字符串是相等的）。如果一个字符串中的字符有效，而另一个字符串中对应的字符无效，那么你是在将实际字符与空字符串进行比较，这总是*不相等*；因此，打包字符串比较指令会强制返回假结果。'
- en: The *equal ordered* operation searches for the substring XMM[src1] within the
    larger string XMM[src2]/mem[src2]. If you’ve gone beyond the end of both strings,
    you’re comparing empty strings (and one empty string is always a substring of
    another empty string), so the packed comparison instructions return a true result.
    If you’ve reached the end of the string in `src1` (the substring to search for),
    the result is true even if there are more characters in `src2`; hence, the packed
    comparisons return true in this situation. However, if you’ve reached the end
    of the `src2` string but not the end of the `src1` (substring) string, there is
    no way that *equal ordered* will return true, so the packed comparison instructions
    force a false in this situation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*等序*操作会在较大的字符串XMM[src2]/mem[src2]中查找子字符串XMM[src1]。如果你已经超出了两个字符串的末尾，你实际上是在比较空字符串（而且一个空字符串总是另一个空字符串的子字符串），因此，打包比较指令会返回一个真实结果。如果你已经到达`src1`字符串的末尾（即要查找的子字符串），即使`src2`中还有更多字符，结果也为真；因此，在这种情况下，打包比较会返回真。然而，如果你已经到达`src2`字符串的末尾，但`src1`（子字符串）字符串还没到末尾，*等序*操作就不可能返回真，因此，打包比较指令会在这种情况下强制返回假。'
- en: If the polarity bits (bits 4 to 5 of `imm`8) contain 00b or 10b, the polarity
    bits do not affect the comparison operation. If the polarity bits are 01b, the
    packed string comparison instructions invert all the bits in the temporary bit
    map result before copying the data to XMM0 (`(v)pcmpistrm` and `(v)pcmpestrm`)
    or calculating the index (`(v)pcmpestri` and `(v)pcmpistri`). If the polarity
    setting is 11b, the packed string comparison instructions invert the resultant
    bit if and only if the corresponding `src2` character is valid.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果极性位（`imm`8的第4到第5位）包含00b或10b，则极性位不会影响比较操作。如果极性位是01b，打包字符串比较指令在将数据复制到XMM0（`(v)pcmpistrm`和`(v)pcmpestrm`）或计算索引（`(v)pcmpestri`和`(v)pcmpistri`）之前，会反转临时位图结果中的所有位。如果极性设置为11b，则打包字符串比较指令仅在对应的`src2`字符有效时，才反转结果位。
- en: 14.3.6 Packed String Comparison Results
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.6 打包字符串比较结果
- en: The last thing to note about the packed string comparison instructions is how
    they affect the CPU flags. These instructions are unusual among the SSE/AVX instructions
    insofar as they affect the condition codes. However, they do not affect the condition
    codes in standard ways (for example, you cannot use the carry and zero flags to
    test for string less than or greater than, as you can with the `cmps` instructions).
    Instead, these instructions overload the meanings of the carry, zero, sign, and
    overflow flags; furthermore, each instruction defines the meaning of these flags
    independently.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 关于打包字符串比较指令的最后一点要注意的是它们如何影响CPU标志。这些指令在SSE/AVX指令中比较特殊，因为它们会影响条件代码。然而，它们并不会以标准方式影响条件代码（例如，你不能像使用`cmps`指令那样，通过进位标志和零标志测试字符串是否小于或大于）。相反，这些指令重新定义了进位、零、符号和溢出标志的含义；此外，每条指令独立地定义这些标志的含义。
- en: All eight instructions—`(v)pcmpestri`, `(v)pcmpistri`, `(v)pcmpestrm`, and `(v)pcmpistrm`—clear
    the carry flag if all of the bits in the (internal) result bit map are 0 (no comparison);
    these instructions set the carry flag if there is at least 1 bit set in the bit
    map. Note that the carry flag is set or cleared after the application of the polarity.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 所有八条指令—`(v)pcmpestri`、`(v)pcmpistri`、`(v)pcmpestrm`和`(v)pcmpistrm`—如果（内部）结果位图中的所有位都是0（无比较），则清除进位标志；如果位图中至少有1个位被设置，则设置进位标志。请注意，进位标志在应用极性后被设置或清除。
- en: The zero flag indicates whether the `src2` length is less than 16 (8 for word
    characters). For the `(v)pcmpestri` and `(v)pcmpestrm` instructions, the zero
    flag is set if EDX is less than 16 (8); for the `(v)pcmpistri` and `(v)pcmpistrm`
    instructions, the zero flag is set if XMM[src2]/mem[src2] contains a null character.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 零标志指示`src2`的长度是否小于16（对于字字符是8）。对于`(v)pcmpestri`和`(v)pcmpestrm`指令，如果EDX小于16（8），则设置零标志；对于`(v)pcmpistri`和`(v)pcmpistrm`指令，如果XMM[src2]/mem[src2]包含空字符，则设置零标志。
- en: The sign flag indicates whether the `src1` length is less than 16 (8 for word
    characters). For the `(v)pcmpestri` and `(v)pcmpestrm` instructions, the sign
    flag is set if EAX is less than 16 (8); for the `(v)pcmpistri` and `(v)pcmpistrm`
    instructions, the zero flag is set if XMM[src1] contains a null character.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 符号标志指示`src1`的长度是否小于16（对于字字符是8）。对于`(v)pcmpestri`和`(v)pcmpestrm`指令，如果EAX小于16（8），则设置符号标志；对于`(v)pcmpistri`和`(v)pcmpistrm`指令，如果XMM[src1]包含空字符，则设置零标志。
- en: The overflow flag contains the setting for bit 0 of the result bit map (that
    is, whether the first character of the source string was a match). This can be
    useful after an equal ordered comparison to see if the substring is a prefix of
    the larger string (for example).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出标志包含结果位图的第0位的设置（即，源字符串的第一个字符是否匹配）。这在执行等序比较后可能会很有用，可以用来检查子字符串是否是较大字符串的前缀（例如）。
- en: 14.4 Alignment and Memory Management Unit Pages
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4 对齐和内存管理单元页面
- en: 'The `(v)pcmp``X``str``Y` instructions are nice insofar as they do not require
    their memory operand to be 16-byte aligned. However, this lack of alignment creates
    a special problem of its own: it is possible for a single `(v)pcmp``X``str``Y`
    instruction memory access to cross an MMU page boundary. As noted in “Memory Access
    and 4K Memory Management Unit Pages” in Chapter 3, some MMU pages might not be
    accessible and will generate a general protection fault if the CPU attempts to
    read data from them.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`(v)pcmp``X``str``Y`指令的优点在于它们不要求其内存操作数是16字节对齐的。然而，这种缺乏对齐性会产生一个特殊问题：单条`(v)pcmp``X``str``Y`指令的内存访问可能会跨越MMU页面边界。如在第3章“内存访问和4K内存管理单元页面”中所述，一些MMU页面可能无法访问，如果CPU尝试从这些页面读取数据，将生成一般保护错误。'
- en: If the string is less than 16 bytes in length and ends before the page boundary,
    using `(v)pcmp``X``str``Y` to access that data may cause an inadvertent page fault
    when it reads a full 16 bytes from memory, including data beyond the end of the
    string. Though accessing data beyond the string that crosses into a new, inaccessible
    MMU page is a rare situation, it can happen, so you want to ensure you don’t access
    data across MMU page boundaries unless the next MMU page contains actual data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串的长度小于 16 字节并且在页面边界之前结束，使用 `(v)pcmp``X``str``Y` 来访问该数据可能会导致意外的页面错误，因为它会从内存中读取完整的
    16 字节数据，包括字符串末尾之后的数据。虽然访问超出字符串并跨越到新的、不可访问的 MMU 页面的数据是一个罕见的情况，但它确实可能发生，因此你需要确保不会跨越
    MMU 页面边界访问数据，除非下一个 MMU 页面包含实际数据。
- en: 'If you have aligned an address on a 16-byte boundary and you access 16 bytes
    from memory starting at that address, you never have to worry about crossing into
    a new MMU page. MMU pages contain an integral multiple of 16 bytes (there are
    256 16-byte blocks in an MMU page). If the CPU accesses 16 bytes starting at a
    16-byte boundary, the last 15 bytes of that block will fall into the same MMU
    page as the first byte. This is why most SSE memory accesses are okay: they require
    16-byte-aligned memory operands. The exceptions are the unaligned move instructions
    and the `(v)pcmp``X``str``Y` instructions.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已将地址对齐到 16 字节边界，并且从该地址开始访问 16 字节内存，你就不必担心会跨越新的 MMU 页面。MMU 页面包含 16 字节的整数倍（一个
    MMU 页面包含 256 个 16 字节的块）。如果 CPU 从 16 字节边界开始访问 16 字节数据，那么该块的最后 15 字节会落在与第一个字节相同的
    MMU 页面中。这就是为什么大多数 SSE 内存访问是安全的：它们要求 16 字节对齐的内存操作数。例外情况是未对齐的移动指令和 `(v)pcmp``X``str``Y`
    指令。
- en: You typically use the unaligned move instructions (for example, `movdqu` and
    `movupd`) to move 16 actual bytes of data into an SSE/AVX register; therefore,
    these instructions don’t usually access extra bytes in memory. The `(v)pcmp``X``str``Y`
    instructions, however, often access data bytes beyond the end of the actual string.
    These instructions read a full 16 bytes from memory even if the string consumes
    fewer than 16 of those bytes. Therefore, when using the `(v)pcmp``X``str``Y` instructions
    (and the other unaligned moves, if you’re using them to read beyond the end of
    a data structure), you should ensure that the memory address you are supplying
    is at least 16 bytes before the end of an MMU page, or that the next page in memory
    contains valid data.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你使用未对齐的移动指令（例如，`movdqu` 和 `movupd`）将 16 个实际字节的数据移动到 SSE/AVX 寄存器中；因此，这些指令通常不会访问内存中的额外字节。然而，`(v)pcmp``X``str``Y`
    指令通常会访问超出实际字符串末尾的数据字节。这些指令会从内存中读取完整的 16 字节，即使字符串实际使用的字节少于 16 个。因此，在使用 `(v)pcmp``X``str``Y`
    指令（以及其他未对齐的移动指令，如果你使用它们来读取数据结构的末尾之外的内容）时，你应该确保你提供的内存地址至少距离 MMU 页面末尾 16 字节，或者确保内存中的下一页包含有效数据。
- en: As Chapter 3 notes, there is no machine instruction that lets you test a page
    in memory to see if the application can legally access that page. So you have
    to ensure that no memory accesses by the `(v)pcmp``X``str``Y` instructions will
    cross a page boundary. The next chapter provides several examples.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 3 章所述，机器指令没有允许你测试内存页面是否能合法访问的指令。因此，你必须确保 `(v)pcmp``X``str``Y` 指令的任何内存访问都不会跨越页面边界。下一章提供了几个例子。
- en: 14.5 For More Information
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5 获取更多信息
- en: Agner Fog is one of the world’s foremost experts on optimization of x86(-64)
    assembly language. His website ([https://www.agner.org/optimize/#manuals/](https://www.agner.org/optimize/#manuals/))
    has a lot to say about optimizing memory moves and other string instructions.
    This website is highly recommended if you want to write fast string code in x86
    assembly language.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Agner Fog 是全球顶尖的 x86(-64) 汇编语言优化专家之一。他的网站 ([https://www.agner.org/optimize/#manuals/](https://www.agner.org/optimize/#manuals/))
    详细介绍了优化内存移动和其他字符串指令的内容。如果你想编写快速的 x86 汇编语言字符串代码，强烈推荐这个网站。
- en: T. Herselman has spent a huge amount of time writing fast `memcpy` functions.
    You can find his results at [https://www.codeproject.com/Articles/1110153/Apex-memmove-the-fastest-memcpy-memmove-on-x-x-EVE/](https://www.codeproject.com/Articles/1110153/Apex-memmove-the-fastest-memcpy-memmove-on-x-x-EVE/)
    (or just search the web for *Apex memmove*). The length of this code will, undoubtedly,
    convince you to stick with the `movs` instruction (which runs fairly fast on modern
    x86-64 CPUs).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: T. Herselman花费了大量时间编写快速的`memcpy`函数。你可以在[https://www.codeproject.com/Articles/1110153/Apex-memmove-the-fastest-memcpy-memmove-on-x-x-EVE/](https://www.codeproject.com/Articles/1110153/Apex-memmove-the-fastest-memcpy-memmove-on-x-x-EVE/)（或者搜索网络上的*Apex
    memmove*）找到他的成果。这段代码的长度无疑会让你决定继续使用`movs`指令（在现代x86-64 CPU上运行相当快）。
- en: 14.6 Test Yourself
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.6 自我测试
- en: What size operands do the generic string instructions support?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通用字符串指令支持什么大小的操作数？
- en: What are the five general-purpose string instructions?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 五个通用字符串指令是什么？
- en: What size operands do the `pcmp``X``str``Y` instructions support?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pcmp``X``str``Y`指令支持什么大小的操作数？'
- en: What registers does the `rep` `movsb` instruction use?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rep` `movsb`指令使用哪些寄存器？'
- en: What registers does the `cmpsw` instruction use?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cmpsw`指令使用哪些寄存器？'
- en: What registers does the `repne` `scasb` instruction use?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`repne` `scasb`指令使用哪些寄存器？'
- en: What registers does the `stosd` instruction use?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`stosd`指令使用哪些寄存器？'
- en: If you want to increment the RSI and RDI registers after each string operation,
    what direction flag setting do you use?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望在每次字符串操作后递增RSI和RDI寄存器，应该设置什么方向标志？
- en: If you want to decrement the RSI and RDI registers after each string operation,
    what direction flag setting do you use?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你希望在每次字符串操作后递减RSI和RDI寄存器，应该设置什么方向标志？
- en: If a function or procedure modifies the direction flag, what should that function
    do before returning?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个函数或过程修改了方向标志，那么它在返回之前应该做什么？
- en: The Microsoft ABI requires a function to _ the direction flag before returning
    if it modifies the flag’s value.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数修改了方向标志的值，微软ABI要求函数在返回之前_方向标志。
- en: Which string instructions have Intel optimized for performance on later x86-64
    CPUs?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些字符串指令是Intel为后来的x86-64 CPU优化的，以提高性能？
- en: When would you want to set the direction flag prior to using a `movs` instruction?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在使用`movs`指令之前，何时需要设置方向标志？
- en: When would you want to clear the direction flag prior to using a `movs` instruction?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在使用`movs`指令之前，何时需要清除方向标志？
- en: What can happen if the direction flag is not set properly when you are executing
    a `movs` instruction?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果方向标志没有正确设置，当你执行`movs`指令时会发生什么情况？
- en: Which string prefix would you normally use with `cmpsb` to test two strings
    to see if they are equal?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常使用哪个字符串前缀与`cmpsb`一起测试两个字符串是否相等？
- en: When comparing two character strings, how should the direction flag normally
    be set?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在比较两个字符串时，通常应该如何设置方向标志？
- en: Do you need to test whether RCX is 0 before executing a string instruction with
    a repeat prefix?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行带有重复前缀的字符串指令之前，是否需要测试RCX是否为0？
- en: If you wanted to search for a zero-terminating byte in a C/C++ string, what
    (general-purpose) string instruction would be most appropriate?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想在C/C++字符串中查找一个以零终止的字节，最合适的（通用）字符串指令是什么？
- en: If you wanted to fill a block of memory with 0s, what string instruction would
    be most appropriate?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想用0填充一块内存，最合适的字符串指令是什么？
- en: If you wanted to concoct your own string operations, what string instruction(s)
    would you use?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想编写自己的字符串操作，你会使用哪些字符串指令？
- en: Which string instruction would you typically never use with a repeat prefix?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个字符串指令通常不与重复前缀一起使用？
- en: Before using one of the `pcmp``X``str``Y` instructions, what should you do?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`pcmp``X``str``Y`指令之前，你应该做什么？
- en: Which SSE string instructions automatically handle zero-terminated strings?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些SSE字符串指令自动处理零终止字符串？
- en: Which SSE string instructions require an explicit length value?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些SSE字符串指令需要显式的长度值？
- en: Where do you pass explicit lengths to the `pcmp``X``str``Y` instructions?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pcmp``X``str``Y`指令中，你应该在哪里传递显式长度？
- en: Which `pcmp``X``str``Y` aggregate operation searches for characters belonging
    to a set of characters?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个`pcmp``X``str``Y`聚合操作用于搜索属于字符集合的字符？
- en: Which `pcmp``X``str``Y` aggregate operation compares two strings?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个`pcmp``X``str``Y`聚合操作用于比较两个字符串？
- en: Which `pcmp``X``str``Y` aggregate operation checks whether one string is a substring
    of another?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个`pcmp``X``str``Y`聚合操作检查一个字符串是否是另一个字符串的子串？
- en: What is the problem with the `pcmp``X``str``Y` instruction and MMU pages?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pcmp``X``str``Y` 指令和 MMU 页有什么问题？'
