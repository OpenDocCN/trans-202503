- en: '**5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5'
- en: CRYPTOGRAPHY AND RANSOMWARE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 加密与勒索病毒**
- en: '*Unless you know the code, it has no meaning.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*除非你知道密码，否则它没有意义。*'
- en: –John Connolly, *The Book of Lost Things*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: –John Connolly, *《失落的事物之书》*
- en: '![image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: '*Ransomware* is malicious code that holds a machine hostage by encrypting its
    files. After encrypting the files, ransomware usually displays a window demanding
    money in exchange for the decrypted files. This chapter will show you how hackers
    write encryption ransomware to extort money from a company. However, before we
    do that, you must understand encryption algorithms and secure communications more
    generally. After reading this chapter, you should be able to encrypt a file with
    a block cipher, send an encrypted email using public-key cryptography, and design
    your own encryption ransomware.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*勒索病毒*是一种恶意代码，通过加密计算机的文件来控制机器。一旦加密了文件，勒索病毒通常会显示一个窗口，要求支付赎金以换取解密文件。本章将向你展示黑客如何编写加密勒索病毒来敲诈公司。然而，在此之前，你必须先了解加密算法和安全通信的一般知识。阅读本章后，你应该能够使用块加密算法加密文件，使用公钥加密法发送加密邮件，并设计你自己的加密勒索病毒。'
- en: '**Encryption**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加密**'
- en: Imagine that Alice wants to prevent people from reading her diary, so she locks
    it in a safe and keeps the key. In computer systems, the analogous activity to
    placing a diary in a safe is to *encrypt* it by scrambling the data in some systematic
    way. If Alice encrypted her diary, anyone who stole it would have trouble recovering
    the information inside. Cryptographers refer to the original diary as *plaintext*,
    because everyone can plainly see what’s inside, and they refer to the encrypted
    diary as *cipher text*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，爱丽丝希望防止别人阅读她的日记，因此她将其锁进一个保险箱并保管好钥匙。在计算机系统中，类似于将日记放入保险箱的操作是通过某种系统化的方式*加密*数据。如果爱丽丝加密了她的日记，那么任何偷走它的人都会很难恢复其中的信息。密码学家将原始日记称为*明文*，因为每个人都可以清楚地看到里面的内容，而将加密后的日记称为*密文*。
- en: The *Caesar cipher* was one of the earliest encryption algorithms. It encrypts
    messages by replacing one letter with another. For example, the letter *a* might
    be replaced with *b* and the letter *c* would be replaced with the letter *d*,
    and so on. [Figure 5-1](ch05.xhtml#ch5fig1) shows an example of one possible mapping.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*凯撒密码*是最早的加密算法之一。它通过将一个字母替换为另一个字母来加密消息。例如，字母*a*可能会被替换为*b*，字母*c*将被替换为字母*d*，依此类推。[图
    5-1](ch05.xhtml#ch5fig1)展示了一种可能的映射示例。'
- en: '![image](../images/ch05fig01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch05fig01.jpg)'
- en: '*Figure 5-1: Caesar cipher encryption mapping*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：凯撒密码加密映射*'
- en: Try using the mapping shown in [Figure 5-1](ch05.xhtml#ch5fig1) to decrypt the
    cipher text “dbu buubdl.” You should easily retrieve the message “cat attack.”
    However, the original plaintext message wouldn’t be obvious to someone who read
    the cipher text “dbu buubdl” unless they also knew the mapping. We refer to this
    mapping as the *key*. In our example, the key is 1, as we’ve shifted letters by
    one spot in the alphabet.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用[图 5-1](ch05.xhtml#ch5fig1)中显示的映射来解密密文“dbu buubdl”。你应该能够轻松地恢复出“cat attack”这条消息。然而，除非解密者也知道这个映射，否则他们很难理解密文“dbu
    buubdl”所表达的原始明文信息。我们将这种映射称为*密钥*。在我们的例子中，密钥是1，因为我们将字母在字母表中向后移了一位。
- en: 'Notice a weakness in the Caesar cipher: if messages can contain only 26 unique
    letters, there are only 26 possible keys. A hacker could merely try each key until
    they found one that unlocked the message. The number of possible keys is called
    the *key space*. Encryption algorithms with larger key spaces are more secure
    because hackers must test more keys. The Caesar cipher isn’t secure because its
    key space is too small.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意凯撒密码的一个弱点：如果消息中只能包含26个唯一字母，则只有26个可能的密钥。黑客可以仅仅尝试每个密钥，直到找到解锁消息的密钥。所有可能的密钥数量称为*密钥空间*。具有更大密钥空间的加密算法更安全，因为黑客必须测试更多的密钥。凯撒密码不安全，因为它的密钥空间太小。
- en: The most secure encryption algorithms make any possible mapping equally likely,
    creating the largest possible key space. An algorithm known as the *one-time pad*
    achieves this.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的加密算法使任何可能的映射具有相同的概率，从而创造出最大的密钥空间。一种称为*一次性密码本*的算法实现了这一点。
- en: '***One-Time Pad***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***一次性密码本***'
- en: The one-time pad algorithm encrypts a message by computing the *exclusive OR
    (XOR)* between the message and key. The XOR is a logic operation that outputs
    1 when the two input bits differ and 0 when they are the same. For example, 1
    XOR 0 = 1, whereas 1 XOR 1 = 0\. [Figure 5-2](ch05.xhtml#ch5fig2) shows an example
    of encrypting the word *SECRET* with the key `po7suq`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密码本算法通过计算消息和密钥之间的*异或（XOR）*来加密消息。异或是一种逻辑操作，当两个输入位不同时时输出1，相同时输出0。例如，1 XOR 0
    = 1，而1 XOR 1 = 0。 [图5-2](ch05.xhtml#ch5fig2)展示了使用密钥`po7suq`加密词语*SECRET*的例子。
- en: '![image](../images/ch05fig02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch05fig02.jpg)'
- en: '*Figure 5-2: The process of using a key to encrypt a message*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-2：使用密钥加密消息的过程*'
- en: 'First, each letter in the plaintext and key is converted to its binary representation
    using the ASCII mapping. The *American Standard Code for Information Interchange
    (ASCII)* is a standard that assigns natural language characters to binary codes.
    For example, the characters in the key `po7suq` map as follows: p = 0111000, o
    = 01101111, 7 = 00110111, s = 0110011, u = 001110101, and q = 00111001\. Next,
    the two binary values are XOR-ed and converted back into ASCII, resulting in the
    string `#*T!0%`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，明文和密钥中的每个字母都使用ASCII映射转换为其二进制表示。*美国信息交换标准代码（ASCII）*是一种标准，将自然语言字符映射为二进制代码。例如，密钥`po7suq`中的字符映射如下：p
    = 0111000, o = 01101111, 7 = 00110111, s = 0110011, u = 001110101, q = 00111001。接下来，两个二进制值进行异或运算并转换回ASCII，结果是字符串`#*T!0%`。
- en: 'To understand this better, let’s consider the process of encrypting *S* with
    the key *p*. We convert the character *S* and *p* to their respective binary representations,
    01010011 and 01110000, and then compute the XOR for each pair of bits in *S* and
    *p* from left to right. This means that we XOR 0 with 0, 1 XOR 1, and so on, until
    we reach the final pair 1 XOR 0\. The resulting value is 00100011, which when
    converted back to ASCII yields the cipher text #.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，我们来考虑用密钥*p*对*S*进行加密的过程。我们将字符*S*和*p*转换为它们各自的二进制表示，分别是01010011和01110000，然后计算*S*和*p*中每一对二进制位的异或（XOR），从左到右进行。这意味着我们将0与0异或，1与1异或，依此类推，直到最后一对1与0异或。得到的结果是00100011，当转换回ASCII时，得到的密文是#。
- en: Unless an attacker knows the key, it will be impossible for them to recover
    the original message. This is because the one-time pad algorithm ensures that
    any possible mapping is equally likely. Each 0 or 1 in the cipher text is equally
    likely to have been 0 or 1 in the plaintext, assuming you’ve randomly chosen the
    values in your key. A cipher value 00 is equally likely to map to a plaintext
    value of 11, 10, 01, or 00\. This means that an *n*-bit plaintext has 2*^n* possible
    cipher values. Thus, our 48-bit plaintext `SECRET` has 281 trillion possible mappings.
    Now *that* is a large key space.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除非攻击者知道密钥，否则他们不可能恢复原始消息。这是因为一次性密码本算法确保任何可能的映射都是等概率的。密文中的每个0或1都有相同的概率是明文中的0或1，前提是你随机选择了密钥中的值。密文值00同样可能映射到明文值11、10、01或00。这意味着一个*n*位的明文有2*^n*种可能的密文值。因此，我们48位的明文`SECRET`有281万亿种可能的映射。现在，这就是一个庞大的密钥空间。
- en: The one-time pad does leak some information. In this case, we know that the
    cipher text, key, and original message are all six characters long. However, this
    doesn’t tell us much given that the ciphertext is just as likely to correspond
    to the word *SECRET* as to any other six-character word, such as *puzzle*, *quacks*,
    or *hazmat*. This is because we could choose a six-character key that would map
    any of these words to the ciphertext. To decrypt the message, you’d need to XOR
    the cipher text with the key once again.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密码本确实会泄露一些信息。在这种情况下，我们知道密文、密钥和原始消息的长度都是六个字符。然而，考虑到密文有可能与词语*SECRET*一样，也有可能与其他六个字符的词语（如*puzzle*、*quacks*或*hazmat*）对应，这并不会告诉我们太多信息。这是因为我们可以选择一个六个字符的密钥，将这些词语中的任何一个映射到密文。要解密消息，你需要再次将密文与密钥进行异或操作。
- en: '**THE MATH BEHIND THE ONE-TIME PAD**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**一次性密码本背后的数学**'
- en: 'To better understand how the one-time pad algorithm works, and how the same
    operation can both encrypt and decrypt data, consider the algebra behind it. Let’s
    begin by introducing some notation. Let *E*(*k*, *m*) represent the function that
    encrypts a message *m* by XOR-ing it with a key *k*. We’ll use the symbol *⊕*
    to represent the XOR operation and let *c* represent the cipher text. The following
    equation expresses these ideas mathematically:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解一次性密钥算法是如何工作的，以及相同的操作如何既能加密又能解密数据，考虑一下背后的代数原理。我们首先引入一些符号。让 *E*(*k*, *m*)
    表示通过将消息 *m* 与密钥 *k* 进行 XOR 运算来加密消息 *m* 的函数。我们将使用符号 *⊕* 来表示 XOR 运算，并让 *c* 表示密文。以下方程式用数学语言表达了这些思想：
- en: '*E*(*k*, *m*) = *m* ⊕ *k* = *c*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*E*(*k*, *m*) = *m* ⊕ *k* = *c*'
- en: '*D*(*c*, *k*) is the function that decrypts cipher text *c* by XOR-ing it with
    the same key, *k*. If you look at the encryption equation, you’ll see that we
    can substitute (*m* ⊕ *k*) for the cipher text *c*, which will result in the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*D*(*c*, *k*) 是通过将密文 *c* 与相同的密钥 *k* 进行 XOR 运算来解密密文的函数。如果你看一下加密方程式，你会发现我们可以将
    (*m* ⊕ *k*) 代替密文 *c*，从而得到以下结果：'
- en: '*D*(*k*, *c*) = *c* ⊕ *k* = (*m* ⊕ *k*) ⊕ *k*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*D*(*k*, *c*) = *c* ⊕ *k* = (*m* ⊕ *k*) ⊕ *k*'
- en: 'The XOR operator is associative, which means that the order of operations doesn’t
    matter. So we can rearrange the parentheses and rewrite the right-hand side of
    the equation as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: XOR 运算符是结合的，这意味着运算的顺序不影响结果。所以我们可以重新排列括号，并将方程式的右边改写如下：
- en: (*m* ⊕ *k*) ⊕ *k* = *m* ⊕ (*k* ⊕ *k*)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: (*m* ⊕ *k*) ⊕ *k* = *m* ⊕ (*k* ⊕ *k*)
- en: 'The XOR operator is also self-inversive, meaning that if we XOR a number with
    itself, the result will be 0\. This gives us the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: XOR 运算符还是自反的，这意味着如果我们将一个数字与它自身进行 XOR 运算，结果将是 0。这就给出了以下结果：
- en: '*m* ⊕ (*k* ⊕ *k*) = *m* ⊕ (0)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*m* ⊕ (*k* ⊕ *k*) = *m* ⊕ (0)'
- en: The XOR operator also follows the identity element property, which means that
    XOR-ing a number with 0 simply returns the number.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: XOR 运算符还遵循恒等元素的性质，这意味着将一个数字与 0 进行 XOR 运算会直接返回该数字。
- en: '*m* ⊕ (0) = *m*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*m* ⊕ (0) = *m*'
- en: 'Through the preceding steps, I have shown that decrypting the cipher text by
    XOR-ing it with the key will give us the original message:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的步骤，我已经证明了通过将密文与密钥进行 XOR 运算，可以解密出原始消息：
- en: '*D*(*k*, *c*) = *c* ⊕ *k* = (*m* ⊕ *k*) ⊕ *k* = *m*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*D*(*k*, *c*) = *c* ⊕ *k* = (*m* ⊕ *k*) ⊕ *k* = *m*'
- en: The one-time pad algorithm has two limitations. First, you can use each key
    only once. If the same key is used more than once, a hacker can discover information
    about the message by XOR-ing the two cipher texts. For instance, in [Figure 5-3](ch05.xhtml#ch5fig3),
    you can see that XOR-ing the bee and stop ciphers with each other is equivalent
    to XOR-ing the two plaintext messages.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密钥算法有两个局限性。首先，每个密钥只能使用一次。如果相同的密钥被使用多次，黑客就可以通过将两个密文进行 XOR 运算来发现关于消息的信息。例如，在
    [图 5-3](ch05.xhtml#ch5fig3) 中，你可以看到将蜜蜂和停止密码进行 XOR 运算等同于对两个明文消息进行 XOR 运算。
- en: '![image](../images/ch05fig03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch05fig03.jpg)'
- en: '*Figure 5-3: How a hacker can recover information from two messages encrypted
    with same key*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：黑客如何从使用相同密钥加密的两条消息中恢复信息*'
- en: 'The following equation outlines, in algebraic terms, how XOR-ing two ciphers
    (*c*[1] and *c*[2]) encrypted with same key *k* is equivalent to XOR-ing the two
    plaintext messages *m*[1] and *m*[2]. The self-inversive property (described in
    the box) causes the keys in both ciphers to cancel each other:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方程式在代数上概述了，将使用相同密钥 *k* 加密的两个密文 (*c*[1] 和 *c*[2]) 进行 XOR 运算如何等价于对两个明文消息 *m*[1]
    和 *m*[2] 进行 XOR 运算。自反特性（如框中所述）使得两个密文中的密钥相互抵消：
- en: '*c*[1] ⊕ *c*[2] *⇒* (*m*[1] ⊕ *k*) ⊕ (*m*[2] ⊕ *k*) *⇒* (*m*[1] ⊕ *m*[2]) ⊕
    (*k* ⊕ *k*) *⇒* (*m*[1] ⊕ *m*[2])'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*[1] ⊕ *c*[2] *⇒* (*m*[1] ⊕ *k*) ⊕ (*m*[2] ⊕ *k*) *⇒* (*m*[1] ⊕ *m*[2]) ⊕
    (*k* ⊕ *k*) *⇒* (*m*[1] ⊕ *m*[2])'
- en: In other words, the random information that the key provides disappears when
    we XOR the two cipher texts. Also, encrypting the same message with the same key
    will always result in the same cipher text. This allows a hacker to detect that
    the same message was sent twice.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当我们对两个密文进行 XOR 运算时，密钥提供的随机信息就消失了。此外，使用相同的密钥加密相同的消息总会得到相同的密文。这使得黑客能够检测到相同的消息被发送了两次。
- en: The key must also be the same length as the message; thus, long messages need
    long keys. This means that to encrypt a 250-word document, assuming an average
    word length of five characters, you’d need to remember a key that is 1,250 characters
    long.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥的长度还必须与消息长度相同；因此，长消息需要长密钥。这意味着，要加密一篇 250 字的文档，假设平均每个单词五个字符，你就需要记住一个 1,250
    个字符长的密钥。
- en: What if you could convert shorter keys, like `tfkd`, into longer keys, like
    `qwedfagberw`? You could then use shorter keys to encrypt long messages. As it
    so happens, we can achieve this by using a pseudorandom generator.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以将较短的密钥（例如`tfkd`）转换为较长的密钥（如`qwedfagberw`），那么你就可以用较短的密钥来加密长消息。恰巧的是，我们可以通过使用伪随机生成器来实现这一点。
- en: '***Pseudorandom Generators***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***伪随机生成器***'
- en: A *pseudorandom generator (PRG)* is an algorithm that always generates the same
    random-looking output given the same key. This allows you to use a shorter password
    to create a key that is the same length as the message without having to remember
    the whole key. Discussions of randomness are always tricky. The results of PRGs
    look *statistically* random, even though they’re not sampled from a random source
    like atmospheric noise or radioactive decay. However, they cannot be truly statistically
    random because the PRG’s input is much shorter than its output. Nonetheless, no
    efficient algorithm will be able to tell the difference, so PRG output is as good
    as a statistically uniform string.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*伪随机生成器（PRG）*是一种算法，它在给定相同密钥的情况下总是生成相同的看似随机的输出。这使得你可以使用较短的密码来创建一个与消息长度相同的密钥，而无需记住整个密钥。关于随机性的讨论总是很棘手。PRG的结果看起来*统计上*是随机的，尽管它们并不是从像大气噪声或放射性衰变这样的随机源中抽样的。然而，它们不可能是真正统计上的随机，因为PRG的输入远小于其输出。尽管如此，没有有效的算法能够区分它们，因此PRG的输出可以和统计均匀的字符串一样好。'
- en: 'How is it possible to repeatedly generate the same pseudorandom sequence of
    numbers from a short key? One way is to use a *linear congruential* *generator
    (LCG)*. The details of this formula aren’t important, but the following equation
    describes it if you’re curious. Here, *X[n]* represents the *n*th number in the
    sequence:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如何从一个短的密钥反复生成相同的伪随机数序列？一种方法是使用*线性同余* *生成器（LCG）*。这个公式的细节并不重要，但如果你感兴趣，下面的方程式描述了它。在这里，*X[n]*代表序列中的第*n*个数字：
- en: '*X[n]*[+1] = (*aX[n]* + *c*) mod *m*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*X[n]*[+1] = (*aX[n]* + *c*) mod *m*'
- en: 'Depending on the sequence’s length, you can select different values for *a*,
    *c*, and *m*. You can also choose the first number in the sequence, *X*[0], which
    is called the *seed*. Consider a case with parameters *m* = 9, *a* = 2, and *c*
    = 0, and a seed of 1 (that is, *X*[0] = 1). These parameters produce the following
    output: 2, 4, 8, 7, 5, 1\. [Table 5-1](ch05.xhtml#ch5tab1) shows how each number
    in the sequence is calculated.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据序列的长度，你可以为*a*、*c*和*m*选择不同的值。你还可以选择序列中的第一个数字，*X*[0]，它被称为*种子*。考虑一个参数为*m* = 9，*a*
    = 2，*c* = 0，种子为1（即*X*[0] = 1）的情况。这些参数产生以下输出：2, 4, 8, 7, 5, 1。 [表5-1](ch05.xhtml#ch5tab1)展示了如何计算序列中的每个数字。
- en: '**Table 5-1:** How the LCG Computes the Numbers in the Pseudorandom Sequence'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-1：** LCG如何计算伪随机序列中的数字'
- en: '| ***X****[n+1]*** | (***aX****[n]** **+ c)*** mod ***m*** | ***X****[n]***
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| ***X****[n+1]*** | (***aX****[n]** **+ c)*** mod ***m*** | ***X****[n]***
    |'
- en: '| --- | --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 2 | 2 *** 1 + 0 mod 9 | 1 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 *** 1 + 0 mod 9 | 1 |'
- en: '| 4 | 2 *** 2 + 0 mod 9 | 2 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2 *** 2 + 0 mod 9 | 2 |'
- en: '| 8 | 2 *** 4 + 0 mod 9 | 4 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 2 *** 4 + 0 mod 9 | 4 |'
- en: '| 7 | 2 *** 8 + 0 mod 9 | 8 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 2 *** 8 + 0 mod 9 | 8 |'
- en: '| 5 | 2 *** 7 + 0 mod 9 | 7 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2 *** 7 + 0 mod 9 | 7 |'
- en: '| 1 | 2 *** 5 + 0 mod 9 | 5 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 *** 5 + 0 mod 9 | 5 |'
- en: '| 2 | 2 *** 1 + 0 mod 9 | 1 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 *** 1 + 0 mod 9 | 1 |'
- en: The sequence isn’t infinite, because it repeats. You can generate longer sequences
    by carefully choosing the parameters; however, all sequences eventually cycle
    back to the beginning. This process of generating longer keys from short ones
    is called *key derivation*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列不是无限的，因为它会重复。你可以通过仔细选择参数来生成更长的序列；然而，所有序列最终都会回到起点。通过从短密钥生成更长密钥的这个过程称为*密钥派生*。
- en: The length of sequence before the cycle repeats is called its *period*. Repetition
    is not the only issue with LCGs. For instance, an LCG with an extremely large
    period is still insecure. Another issue is that the values are predictable (even
    without computing a full period). You should never use LCG algorithms in cryptographic
    applications. We recommend that you use the *Password-Based Key Derivation Function
    2 (PBKDF2)* whenever you need to derive keys.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在周期重复之前的序列长度称为它的*周期*。重复性并不是LCGs唯一的问题。例如，一个具有极大周期的LCG仍然不安全。另一个问题是这些值是可预测的（即使不计算完整的周期）。你永远不应该在加密应用中使用LCG算法。我们建议你在需要推导密钥时使用*基于密码的密钥派生函数2（PBKDF2）*。
- en: '***Insecure Block Ciphers Modes***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***不安全的分组密码模式***'
- en: What if, instead of generating keys the same length as our message, we split
    the message into blocks? Then we could encrypt each block of the large file independently
    with a shorter key. This is the central idea behind *block cipher modes*. The
    *electronic code book (ECB)* cipher mode was one of the earliest, and although
    it isn’t secure, ECB illustrates the concept well.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不是生成与消息长度相同的密钥，而是将消息拆分成多个块呢？那么我们就可以使用更短的密钥独立加密每个大文件的块。这就是*块密码模式*的核心思想。*电子密码本（ECB）*密码模式是最早的一种，虽然它不安全，但它很好地展示了这个概念。
- en: '[Figure 5-4](ch05.xhtml#ch5fig4) shows how ECB encrypts the binary sequence
    `00011011`. Notice how the binary sequence is split into four blocks, each of
    which is encrypted in parallel.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-4](ch05.xhtml#ch5fig4)展示了ECB如何加密二进制序列`00011011`。请注意，二进制序列被分成四个块，每个块都并行加密。'
- en: '![image](../images/ch05fig04.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch05fig04.jpg)'
- en: '*Figure 5-4: An ECB block cipher mode encrypting the binary sequence* `*00011011*`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：ECB 块密码模式加密二进制序列* `*00011011*`'
- en: In this example, the block implements a simple function that XORs the input
    with the key 01\. However, given the same key and input, ECB will always output
    the same cipher text, leaking information to the hacker. ECB also reuses the key
    for each block, which reduces the number of possible outcomes and makes it easier
    for a hacker to decrypt the message. For example, [Figure 5-5](ch05.xhtml#ch5fig5)
    shows an image that has been encrypted with ECB.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，块执行一个简单的函数，将输入与密钥01进行异或。然而，在给定相同的密钥和输入的情况下，ECB总是输出相同的密文，泄露信息给黑客。ECB还为每个块重复使用密钥，这减少了可能的结果数量，使黑客更容易解密消息。例如，[图
    5-5](ch05.xhtml#ch5fig5)展示了一张被ECB加密的图片。
- en: '![image](../images/ch05fig05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch05fig05.jpg)'
- en: '*Figure 5-5: The image on the left is the original image, whereas the image
    on right is an encrypted image.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：左侧的图片是原始图片，而右侧的图片是加密后的图片。*'
- en: Notice that you can still see the outline of the atom in the encrypted file.
    This is due to information leakage from using the same key for each block. A similar
    amount of information would be leaked if the ECB cipher were used to encrypt text.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在加密后的文件中，你仍然能看到原子轮廓。这是由于每个块使用相同的密钥而导致的信息泄露。如果使用ECB模式加密文本，也会泄露相似量的信息。
- en: The subtle flaws of the Caesar cipher, one-time pad, and ECB should illustrate
    why you should never implement an encryption algorithm yourself. Encryption is
    very delicate, and small deviations from the specification could result in an
    insecure implementation. Always use secure algorithms from trusted libraries.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码、一次性密钥和电子密码本（ECB）模式的微小缺陷应该能够说明为什么你永远不应该自己实现加密算法。加密非常精密，稍微偏离规范就可能导致不安全的实现。总是使用来自受信任库的安全算法。
- en: '***Secure Block Ciphers Modes***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安全块密码模式***'
- en: Let’s take a look at a better encryption algorithm. [Figure 5-6](ch05.xhtml#ch5fig6)
    shows the design of the *counter mode block cipher (CTR)*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一个更好的加密算法。[图 5-6](ch05.xhtml#ch5fig6)展示了*计数器模式块密码（CTR）*的设计。
- en: '![image](../images/ch05fig06.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch05fig06.jpg)'
- en: '*Figure 5-6: The design of the CTR*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：CTR 设计*'
- en: CTR overcomes two limitations of ECB. First, CTR generates a random number,
    called a *nonce* (a number used once), which it uses to create a unique pad every
    time the file is encrypted. It then attaches the nonce to a counter that uniquely
    identifies each block before sending it to the block. This ensures that each block
    receives unique information.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: CTR克服了ECB的两个局限性。首先，CTR生成一个随机数，称为*nonce*（一次性使用的数字），它用这个数在每次加密文件时创建唯一的密钥。然后，它将nonce附加到一个计数器上，该计数器唯一标识每个块，然后将其发送到块中。这确保了每个块接收到唯一的信息。
- en: 'Let’s consider an example. We’ll use a 1-bit counter and 1-bit nonce value
    of 0\. The counter will cycle between 0 and 1\. When attached to the end of the
    nonce, this would result in the following inputs: 00 and 01\. The combination
    of nonce and counter is then fed to each block, which returns a block-specific
    pad. To encrypt the block, we XOR this block-specific pad with the plaintext in
    that block to create the final cipher text. [Figure 5-7](ch05.xhtml#ch5fig7) shows
    an example of encrypting the binary sequence 0000 using a CTR with a 1-bit counter{0,1}
    and a 1-bit nonce (coin flip heads:1, tails:0).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子。我们将使用一个 1 位计数器和一个 1 位随机数值为 0。计数器将在 0 和 1 之间循环。当它附加到随机数的末尾时，这将产生以下输入：00
    和 01。随机数和计数器的组合被送入每个块，返回一个块特定的填充。为了加密块，我们将此块特定的填充与该块的明文进行异或操作，从而生成最终的密文。[图 5-7](ch05.xhtml#ch5fig7)
    显示了使用具有 1 位计数器{0,1} 和 1 位随机数（抛硬币正面：1，反面：0）的 CTR 加密二进制序列 0000 的示例。
- en: '![image](../images/ch05fig07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch05fig07.jpg)'
- en: '*Figure 5-7: Encrypting the binary sequence* `*0000*` *using a CTR with a 1-bit
    counter and a 1-bit nonce*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：使用 CTR 和 1 位计数器以及 1 位随机数加密二进制序列* `*0000*`'
- en: The blocks in this example use the same key and mapping shown in [Figure 5-6](ch05.xhtml#ch5fig6).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的块使用与 [图 5-6](ch05.xhtml#ch5fig6) 中显示的相同的密钥和映射。
- en: It’s important to distinguish between block ciphers and a block cipher mode
    of operation. A block cipher is a keyed function that takes a block of *n* bits
    and outputs a block of *n* bits. The output of a secure block cipher looks like
    a random permutation of the input block. Though we have been using the XOR function
    in our examples, the NSA recommends using the *Advanced Encryption Standard (AES)*
    cipher.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 区分块密码和块密码操作模式非常重要。块密码是一种带密钥的函数，它接受一个 *n* 位的块，并输出一个 *n* 位的块。一个安全的块密码的输出看起来像是输入块的随机排列。尽管我们在示例中使用的是
    XOR 函数，但 NSA 推荐使用 *高级加密标准 (AES)* 密码。
- en: Block ciphers themselves are not an encryption scheme; however, you can use
    them in various “modes” to obtain an encryption scheme. ECB and CTR are examples
    of modes of operation. When we say that ECB is insecure, it’s the mode that is
    broken and not the underlying block cipher.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 块密码本身不是加密方案；然而，你可以将它们用于不同的“模式”来获得加密方案。ECB 和 CTR 就是操作模式的例子。当我们说 ECB 不安全时，指的是模式本身被破坏，而不是底层的块密码。
- en: '**Encrypting and Decrypting a File**'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加密和解密文件**'
- en: 'Let’s use the CTR cipher to encrypt a file. Begin by opening a terminal on
    the Kali Linux virtual machine. Create a text file containing the message “Top
    Secret Code” by running the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 CTR 密码来加密一个文件。首先，在 Kali Linux 虚拟机上打开终端。通过运行以下命令创建一个包含消息“Top Secret Code”的文本文件：
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To view the content of the file, run the `cat` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看文件的内容，运行 `cat` 命令：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We’ll use the `openssl` library, which includes several encryption algorithms
    and is preinstalled on Kali Linux. Encrypt the file by running the following command
    and entering a password when prompted:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `openssl` 库，它包括多个加密算法，并预装在 Kali Linux 中。通过运行以下命令并在提示时输入密码来加密文件：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `enc -aes-256-ctr` flag specifies that you want to use the *aes-256-ctr*
    block cipher. The block cipher’s name is divided into three parts. The first section
    (`aes`) represents the mapping function used in each block, in this case the AES
    cipher mentioned earlier. The next section (`256`) represents the block size,
    which is 256 bits in this case. The last section (`ctr`) represents a CTR block
    cipher mode. The next option, `-pbkdf2`, represents the key derivation function,
    and the `-e` flag tells `openssl` to encrypt the file. The `-a` flag outputs an
    encrypted file in Base64 encoding instead of binary, which will make it easier
    for us to print the encrypted file in the terminal. Lastly, we use the options
    `-in` and `-out` to specify the file that we want to encrypt and the name of the
    output file, respectively.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`enc -aes-256-ctr` 标志表示你想要使用 *aes-256-ctr* 块密码。块密码的名称分为三个部分。第一部分（`aes`）表示每个块中使用的映射函数，在这种情况下是之前提到的
    AES 密码。接下来的部分（`256`）表示块大小，在此例中是 256 位。最后一部分（`ctr`）表示一个 CTR 块密码模式。下一个选项 `-pbkdf2`
    表示密钥派生函数，`-e` 标志告诉 `openssl` 对文件进行加密。`-a` 标志以 Base64 编码输出加密文件，而不是二进制文件，这将使我们更容易在终端中打印加密文件。最后，我们使用
    `-in` 和 `-out` 选项来指定要加密的文件和输出文件的名称。'
- en: 'To view the contents of your encrypted file, use the `cat` command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看加密文件的内容，使用 `cat` 命令：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To decrypt the file, run the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密文件，运行以下命令：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `-d` flag instructs `openssl` to decrypt the file. Enter the password you
    used earlier. Like the one-time pad algorithm, the CTR decrypts cipher text by
    XORing it with the key output by the block, thereby reversing the encryption process.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d` 标志指示 `openssl` 解密文件。请输入您之前使用的密码。像一次性密码本算法一样，CTR 通过将密文与由块输出的密钥进行异或操作来解密，从而逆转加密过程。'
- en: Note that a hacker who steals this encrypted file might not be able to decrypt
    it, but they can still corrupt it by changing the encrypted bits. In [Chapter
    6](ch06.xhtml#ch6), we’ll discuss an encryption algorithm that allows you to share
    encrypted files and detect a corrupted copy.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，窃取该加密文件的黑客可能无法解密它，但他们仍然可以通过更改加密的位来破坏它。在[第六章](ch06.xhtml#ch6)中，我们将讨论一种加密算法，它允许您共享加密文件并检测已损坏的副本。
- en: '**Email Encryption**'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**电子邮件加密**'
- en: Now that you’ve encrypted and decrypted a file, let’s tackle the challenge of
    sending an encrypted email over a public network, where you should assume that
    anyone can read any unencrypted messages you send. At first glance, correcting
    this problem doesn’t seem too difficult. You can create a key and send an encrypted
    message over the public network so those who intercept the message won’t be able
    to read it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经加密并解密了一个文件，让我们来解决如何在公共网络上发送加密邮件的问题，在这种情况下，您应该假设任何人都可以读取您发送的未加密信息。乍一看，解决这个问题似乎并不难。您可以创建一个密钥并通过公共网络发送加密消息，这样拦截该消息的人就无法读取它。
- en: However, your recipient won’t be able to read the message either because they
    don’t have the key. Assuming that you’ll never meet in person to exchange keys,
    how can you get the key to your recipient without it being intercepted? You can
    use a technique called *publickey cryptography*, also known as *asymmetric cryptography*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您的收件人也无法读取这条消息，因为他们没有密钥。假设你们永远不会面对面交换密钥，那么如何将密钥传递给收件人而不被截获呢？您可以使用一种叫做*公钥加密*的技术，也叫做*非对称加密*。
- en: '***Public-Key Cryptography***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***公钥加密***'
- en: 'Instead of a single shared key, public-key cryptography uses two keys: a public
    key, which everyone can see, and a private key, which is never shared. These two
    keys are mathematically linked, so messages encrypted with the public key can
    be decrypted only by using the private key, and vice versa.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密与传统的共享密钥不同，它使用两把密钥：一把公钥，任何人都可以看到，一把私钥，永远不会共享。这两把密钥在数学上是相互关联的，因此，使用公钥加密的消息只能通过使用私钥解密，反之亦然。
- en: To see how public-key cryptography is useful for sending messages, let’s consider
    an analogy. What if you wanted to send Alice your diary through the mail, but
    you didn’t want anyone in the mail system to be able to read it? You could lock
    your diary in a box and send it to Alice, but Alice can’t open the box because
    she doesn’t have the key. Instead, what if Alice first sends you an open lock
    and keeps the key? The lock doesn’t protect any secret information, so it’s fine
    if everyone in the public mail system can see it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解公钥加密如何在发送消息时发挥作用，我们可以考虑一个类比。如果您想通过邮件将日记发送给爱丽丝，但又不希望邮件系统中的任何人能够阅读它，您该怎么办？您可以将日记放入盒子并锁住，然后发送给爱丽丝，但爱丽丝无法打开这个盒子，因为她没有钥匙。相反，如果爱丽丝先发送给您一个开锁的锁并保留钥匙呢？这个锁并不保护任何机密信息，所以即使公共邮件系统中的每个人都能看到它也没关系。
- en: You can think of this lock as Alice’s public key. Now you can lock the diary
    in a box using the lock Alice sent you and send it through the mail to Alice.
    No one in the mail system would be able to open your box (not even you!) because
    only Alice has the key. When Alice receives the box, she unlocks it using her
    private key.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以把这个锁想象成爱丽丝的公钥。现在，您可以使用爱丽丝给您的锁把日记锁在盒子里，并通过邮寄的方式将其送到爱丽丝手中。邮件系统中的任何人都无法打开您的盒子（甚至您也不能！），因为只有爱丽丝拥有密钥。当爱丽丝收到盒子时，她会用她的私钥解锁它。
- en: Actual public keys are a bit different than locks because they can both encrypt
    (like a lock) and decrypt (like a key). The same is true of private keys. If a
    message is encrypted using a public key, only the individual with the private
    key can decrypt it. But if a message is encrypted using the private key, anyone
    with the public key can decrypt it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的公钥与锁有些不同，因为它们既可以加密（像锁一样）也可以解密（像钥匙一样）。私钥也是如此。如果一条消息使用公钥加密，只有拥有私钥的人才能解密它。但如果一条消息使用私钥加密，任何拥有公钥的人都可以解密它。
- en: It might not be obvious at first why anyone would ever encrypt something with
    their private key since anyone with access to your public key could decrypt the
    message. But encrypting messages with your private key guarantees to others that
    the message came from you because you’re the only person with access to your private
    key. The process of encrypting messages with your private key is often referred
    to as *signing*. By signing a message, you guarantee that it came from you. For
    example, when you request a web page from your bank, the bank’s server will provide
    a signed certificate, proving its authenticity. We will discuss this topic in
    more detail in [Chapter 6](ch06.xhtml#ch6).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，可能不太明显为什么有人会用自己的私钥加密信息，因为任何拥有你公钥的人都可以解密消息。但用私钥加密消息可以向他人保证消息确实来自你，因为只有你能访问你的私钥。用私钥加密消息的过程通常被称为*签名*。通过签署消息，你保证消息确实来自你。例如，当你请求银行的网页时，银行的服务器会提供一个签名证书，证明其真实性。我们将在[第六章](ch06.xhtml#ch6)中详细讨论这个话题。
- en: 'Let’s take a look at one of the algorithms that makes public-key cryptography
    possible: Rivest–Shamir–Adleman.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下使得公钥加密技术成为可能的算法之一：里维斯–沙米尔–阿德尔曼。
- en: '***Rivest–Shamir–Adleman Theory***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***里维斯–沙米尔–阿德尔曼理论***'
- en: Instead of randomly generating a key, public-key cryptography creates the relationship
    between the two keys by computing them. Let’s develop some mathematical notation
    to help us discuss the *Rivest–Shamir–Adleman (RSA)* algorithm. We’ll denote the
    integer representing the public key as *e*, for encryption, and the integer representing
    the private key as *d* for decryption. (These were the variables used in the paper
    that first introduced RSA.) Before we discuss how these keys are generated, we’ll
    cover the encryption and decryption process.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密技术并不是通过随机生成一个密钥，而是通过计算生成两个密钥之间的关系。让我们使用一些数学符号来帮助讨论*里维斯–沙米尔–阿德尔曼 (RSA)*算法。我们将用整数*e*表示公钥，用于加密，整数*d*表示私钥，用于解密。（这些变量是在首次介绍RSA的论文中使用的。）在讨论如何生成这些密钥之前，我们将先介绍加密和解密过程。
- en: 'We can represent a message *m* in binary, and these binary values can be interpreted
    as decimal numbers. For example, the ASCII character *A* corresponds to the binary
    value 1000001, which can be interpreted as the integer 65\. We can now encrypt
    the value 65 by defining a function that maps 65 to a new cipher value *c*. The
    following equation defines the encryption function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将消息*m*表示为二进制，这些二进制值可以解释为十进制数字。例如，ASCII字符*A*对应的二进制值是1000001，它可以解释为整数65。我们现在可以通过定义一个函数将65映射到一个新的密文值*c*来加密值65。以下方程定义了加密函数：
- en: '*E*(*e*, *m*, *n*) = *m^e* mod *n* ≡ *c*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*E*(*e*, *m*, *n*) = *m^e* mod *n* ≡ *c*'
- en: This encryption equation introduces a new public parameter, *n*. This parameter
    is created during the key generation process and we’ll discuss it later.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个加密方程引入了一个新的公共参数*n*。这个参数是在密钥生成过程中创建的，我们稍后会讨论它。
- en: You might also be wondering why a hacker can’t decrypt a message by computing
    ![image](../images/077equ01.jpg). This is difficult to compute for large values
    of *m* and *e*, and is further complicated by the fact that you must account for
    the mod *n* operation. So how can Alice decrypt the message? The public key (*e*)
    and the private key (*d*) are designed so that if you raise the cipher text to
    the value of private key *d* and compute the modulus, you will get the original
    message back. (We commonly referred to features like these as *trapdoors*.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你也许会想，为什么黑客不能通过计算![image](../images/077equ01.jpg)来解密消息。这对于大数值的*m*和*e*来说是很难计算的，而且还因为必须考虑模*n*操作，使得这一过程更加复杂。那么，爱丽丝如何解密消息呢？公钥（*e*）和私钥（*d*）的设计是这样的，如果你将密文提高到私钥*d*的值并计算模数，你将得到原始消息。（我们通常将这些特性称为*陷门*。）
- en: '***The RSA Math***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***RSA数学***'
- en: 'Let’s explain how this all works. Let’s begin by expressing the decryption
    process mathematically:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这一切是如何工作的。我们首先用数学的方式表达解密过程：
- en: '*D*(*d*, *c*, *n*) = *c^d* mod *n* ≡ *m*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*D*(*d*, *c*, *n*) = *c^d* mod *n* ≡ *m*'
- en: 'If we substitute the expression for *c* from the encryption equation into the
    decryption equation, we can rewrite the decryption equation so that it contains
    the public and private keys (*e*, *d*) and the generated parameter (*n*):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将加密方程中* c*的表达式代入解密方程，我们可以重写解密方程，使其包含公钥和私钥（*e*, *d*）以及生成的参数（*n*）：
- en: (*m^e* mod *n*)*^d* mod *n* ≡ *m*
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: (*m^e* mod *n*)*^d* mod *n* ≡ *m*
- en: 'We can then simplify the equation using the following mathematical property:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用以下数学属性简化方程：
- en: (*a* mod *n*)*^d* mod *n* ≡ *a^d* mod *n*
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: (*a* mod *n*)*^d* mod *n* ≡ *a^d* mod *n*
- en: 'Which allows us to rewrite it as:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们将其改写为：
- en: '*m^(ed)* mod *n* ≡ *m*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*m^(ed)* mod *n* ≡ *m*'
- en: 'Now, if only we could choose *e*, *d* values so that coefficient of *m* would
    be 1\. We could then show that *m^(ed)* mod *n* = *m* for all values of *m* smaller
    than *n*, as shown in the following equation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们能够选择 *e*、*d* 的值，使得 *m* 的系数为 1，那么就可以证明对于所有小于 *n* 的 *m*，都有 *m^(ed)* mod
    *n* = *m*，如下面的方程所示：
- en: '*m^(ed)* mod *n* ≡ *m*¹ mod *n* ≡ *m*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*m^(ed)* mod *n* ≡ *m*¹ mod *n* ≡ *m*'
- en: 'We could make this true if we set both integers *e* and *d* to 1\. But how
    could we rewrite the equation so that it’s true for other values? Consider the
    following property, which is true for any *x* and *y* value where *n* is the product
    of two primes: *p*, *q* and *z* = (*p* – 1)(*q* – 1):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将整数 *e* 和 *d* 都设为 1，那么这个等式就成立。但我们如何改写这个方程，使其在其他值下也成立呢？考虑以下属性，对于任何 *x* 和
    *y* 的值，当 *n* 是两个质数的乘积时：*p*, *q* 和 *z* = (*p* – 1)(*q* – 1)，该属性成立：
- en: '*x^y* mod *n* ≡ *x*^((*y* mod *z*)) mod *n*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*x^y* mod *n* ≡ *x*^((*y* mod *z*)) mod *n*'
- en: 'If we rewrite the previous equation using this property, we get the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这个属性重新写上面的方程，我们得到以下结果：
- en: '*m*^((*ed* mod *z*)) mod *n* ≡ *m*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*m*^((*ed* mod *z*)) mod *n* ≡ *m*'
- en: Now we can use integer values other than 1 for *e* and *d*, as long as we ensure
    that *ed* mod *z* = 1.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 1 以外的整数值作为 *e* 和 *d*，只要我们确保 *ed* mod *z* = 1。
- en: 'But how do we programmatically discover the integer values for *e* and *d*?
    The key generator algorithm allows us to generate appropriate integer values for
    *e*, *d*, and *n*. The key generation algorithm consists of four key steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何通过编程方法发现 *e* 和 *d* 的整数值呢？密钥生成算法允许我们为 *e*、*d* 和 *n* 生成合适的整数值。密钥生成算法由四个关键步骤组成：
- en: 1\. Select two large prime numbers (*p*, *q*) and keep them secret.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 选择两个大的质数 (*p*, *q*) 并保持它们的秘密。
- en: 2\. Compute *n* = *pq* and *z* = (*p* – 1)(*q* – 1).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 计算 *n* = *pq* 和 *z* = (*p* – 1)(*q* – 1)。
- en: 3\. Compute the public key (*e*) by choosing an integer that is less than *n*
    and relatively prime to *z*, meaning that it has no factors in common with z.
    Algorithms often choose the value 65,537.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 通过选择一个小于 *n* 且与 *z* 相对素的整数来计算公钥 (*e*)，这意味着它与 *z* 没有共同的因子。算法通常选择值 65,537。
- en: 4\. Use the *extended Euclidean* algorithm to compute the public key (*d*) by
    choosing an integer *d* such that *ed* mod *z* = 1.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 使用 *扩展欧几里得* 算法计算公钥 (*d*)，方法是选择一个整数 *d* 使得 *ed* mod *z* = 1。
- en: Now you have the values for *e*, *d*, and *n*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你得到了 *e*、*d* 和 *n* 的值。
- en: So far we’ve focused solely on the RSA algorithm. But secure implementations
    of RSA must also use the *optimal asymmetric encryption padding (OAEP)* algorithm.
    For simplicity, I’ve delayed discussing the OAEP algorithm and will cover it later
    in the chapter. But don’t worry, we’ll include the `-oaep` flag when encrypting
    and decrypting files using `openssl`, so the commands shown here should be secure.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只关注了 RSA 算法。但安全的 RSA 实现还必须使用 *最优非对称加密填充 (OAEP)* 算法。为了简单起见，我推迟了对 OAEP
    算法的讨论，并将在本章稍后进行介绍。但不用担心，当使用 `openssl` 对文件进行加密和解密时，我们会包含 `-oaep` 标志，因此这里显示的命令应该是安全的。
- en: '**Encrypting a File with RSA**'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 RSA 加密文件**'
- en: 'Now that you know the theory behind RSA, let’s use the `openssl` library to
    generate an encrypted email. To begin, generate a pair of public and private keys
    by running the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 RSA 背后的理论，让我们使用 `openssl` 库生成一个加密的电子邮件。首先，运行以下命令生成一对公钥和私钥：
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `genrsa` flag lets `openssl` know that you want to generate an RSA key,
    the `-out` flag specifies the name of the output file, and the value `1024` represents
    the length of the key. Longer keys are more secure. The NSA recommends RSA key
    lengths of 3,072 bits or longer. Remember: don’t share your private key with anyone.
    You can view the key pair you generated by running the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`genrsa` 标志告诉 `openssl` 你想要生成一个 RSA 密钥，`-out` 标志指定输出文件的名称，值 `1024` 表示密钥的长度。更长的密钥更安全。NSA
    推荐使用 3,072 位或更长的 RSA 密钥。记住：不要与任何人分享你的私钥。你可以通过运行以下命令查看你生成的密钥对：'
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `rsa` flag tells `openssl` to interpret the key as an RSA key and the `-text`
    flag displays the key in human-readable format. You should see output like the
    following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`rsa` 标志告诉 `openssl` 将密钥视为 RSA 密钥，`-text` 标志以人类可读的格式显示密钥。你应该看到类似以下内容的输出：'
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The labels in this output correspond to the theory we discussed earlier in this
    chapter, and the modulus is the value *n*. Remember that this is the product of
    the two prime factors *p* and *q*, which are labeled prime1 and prime2 in the
    output. The public exponent (public key) is the value *e*, whereas the private
    exponent (private key) is the value *d*. The section at the bottom represents
    the Base64-encoded version of the public–private key pair, with all of its components.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出中的标签对应于我们在本章前面讨论的理论，模数是值 *n*。记住，这就是两个质因子 *p* 和 *q* 的乘积，它们在输出中被标记为 prime1
    和 prime2。公钥指数（公钥）是值 *e*，而私钥指数（私钥）是值 *d*。底部的部分代表了公私钥对的 Base64 编码版本，其中包含了所有组件。
- en: 'You can extract the public key from this file by running the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令从这个文件中提取公钥：
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `-pubout` flag tells `openssl` to extract the public key from the file.
    You can view the public key by running the following command, in which the `-pubin`
    flag instructs `openssl` to treat the input as a public key:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`-pubout` 标志告诉 `openssl` 从文件中提取公钥。你可以通过运行以下命令查看公钥，其中 `-pubin` 标志指示 `openssl`
    将输入视为公钥：'
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can make your public key available by publishing it on your website. Notice
    that the public key also includes the modulus *n* required for decryption. Because
    *n* is the product of the two secret prime numbers (*p* and *q*), if a hacker
    were able to factor *n*, they could decrypt the RSA cipher text. However, no classical
    algorithms currently exist that would allow a hacker to efficiently factor *n*
    if the prime numbers are large. In 1994, Peter Shor proposed a *quantum algorithm*
    that could factor large numbers. The algorithm works, but we haven’t yet been
    able to create a quantum computer that can run it on large numbers. Until we have
    a capable quantum computer, RSA remains a safe form of encryption.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将公钥发布在你的网站上来使其可用。请注意，公钥也包括了解密所需的模数 *n*。因为 *n* 是两个秘密质数（*p* 和 *q*）的乘积，如果黑客能够因式分解
    *n*，他们就可以解密 RSA 密文。然而，目前没有经典算法能够有效地因式分解 *n*，如果质数较大。1994年，彼得·肖尔提出了一种 *量子算法*，可以因式分解大数。该算法是有效的，但我们还无法创造出能够在大数上运行的量子计算机。在我们拥有强大的量子计算机之前，RSA
    仍然是一个安全的加密形式。
- en: 'Time to make use of your new public and private keys. Create a text file to
    encrypt:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候使用你新的公钥和私钥了。创建一个文本文件进行加密：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use the RSA utility (`rsautl`), which is part of `openssl`, to create an encrypted
    binary file (*cipher.bin*):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RSA 工具（`rsautl`），这是 `openssl` 的一部分，创建一个加密的二进制文件（*cipher.bin*）：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that we included the `-oaep` flag. Secure implementations of RSA must
    also use the OAEP algorithm discussed in the next section. Whenever you’re encrypting
    and decrypting files using `openssl`, be sure to apply this flag to make the operations
    secure.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们包括了 `-oaep` 标志。RSA 的安全实现必须使用在下一节中讨论的 OAEP 算法。每当你使用 `openssl` 进行加密和解密文件时，务必应用此标志以确保操作安全。
- en: 'Convert the binary file to Base64 by running the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令将二进制文件转换为 Base64：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Converting the file from binary to Base64 encoding allows you to paste it into
    an email as text. You can view the Base64-encoded text using the `cat` command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件从二进制转换为 Base64 编码可以让你将其作为文本粘贴到电子邮件中。你可以使用 `cat` 命令查看 Base64 编码后的文本：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Base64 encoding the file doesn’t really encrypt the file; it simply formats
    it. Always encrypt the file before Base64 encoding it. Decrypt the message by
    converting the Base64 text back into binary:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件进行 Base64 编码并不是真正的加密；它仅仅是格式化文件。总是先加密文件，再进行 Base64 编码。通过将 Base64 文本转换回二进制来解密消息：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, decrypt the binary using the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令解密该二进制文件：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, you can view the decrypted message using the `cat` command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用 `cat` 命令查看解密后的消息：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see your original message: The cat is alive.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到原始消息：猫还活着。
- en: '***Optimal Asymmetric Encryption Padding***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***最佳非对称加密填充***'
- en: Plain RSA isn’t secure because a message will always produce the same cipher
    text when encrypted with the same public key *e*. This is because the encryption
    process (*m^e* mod *n*) doesn’t include a random nonce, among other weaknesses.
    The OAEP preprocessing and postprocessing steps address these issues.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 纯 RSA 并不安全，因为在使用相同公钥 *e* 加密时，消息总是会生成相同的密文。这是因为加密过程（*m^e* mod *n*）不包括随机数 nonce，除此之外还有其他弱点。OAEP
    预处理和后处理步骤解决了这些问题。
- en: 'Let’s take a look at the OAEP algorithm, leaving some of mathematical details
    abstract. Before a message is encrypted, it is first run through an OAEP preprocessing
    step:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下OAEP算法，略去一些数学细节。在消息加密之前，它首先会经过OAEP预处理步骤：
- en: '*E*(*e*, *m*, *n*) = (OAEP-PRE(*m*))*^e* mod *n* ≡ *c*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*E*(*e*, *m*, *n*) = (OAEP-PRE(*m*))*^e* mod *n* ≡ *c*'
- en: 'You can represent this step using the following pseudocode:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下伪代码表示此步骤：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `pad()` function ➊ makes *m* a larger number by adding zeros to the end
    of its bit representation, and `Hash()` represents a hash function, like SHA-256\.
    Why do we need to make *m* a large number? If *m^e* is small, the encryption function
    *m^e* mod *n* doesn’t use the modulus, and computing ![image](../images/077equ01.jpg)
    is easy. OAEP is a padding algorithm that ensures small numbers are converted
    into larger ones that use the modulus.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`pad()`函数 ➊ 通过在其位表示的末尾添加零使得 *m* 成为一个更大的数字，而`Hash()`代表哈希函数，如SHA-256。为什么我们需要把
    *m* 变成一个大数字？如果 *m^e* 很小，加密函数 *m^e* mod *n* 就无法使用模运算，并且计算![image](../images/077equ01.jpg)就变得容易了。OAEP
    是一种填充算法，确保小数字被转换为使用模运算的大数字。'
- en: 'The OEAP postprocessing step recovers the original message and can be represented
    using the following pseudocode:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: OEAP后处理步骤恢复原始消息，并可以使用以下伪代码表示：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because these encryption processes are so delicate, a hacker could easily break
    the encryption if they discovered flaws in how a software developer or system
    administrator used these encryption algorithms. For example, if a programmer used
    PKCS1 version 1.5 instead of OAEP for preprocessing, a hacker could decrypt the
    cipher text. So when attempting to break an encrypted message, an attacker should
    first examine the options used to encrypt the message.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些加密过程非常精细，如果黑客发现软件开发人员或系统管理员使用这些加密算法时存在漏洞，他们很容易破解加密。例如，如果程序员在预处理时使用了PKCS1版本1.5而不是OAEP，黑客就能解密密文。因此，当试图破解加密消息时，攻击者应该首先检查加密消息时使用的选项。
- en: 'Now let us combine these ideas to implement something a lot cooler: ransomware.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些想法结合起来，实现一些更酷的东西：勒索软件。
- en: '**Writing Ransomware**'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编写勒索软件**'
- en: The first ransomware systems used symmetric key cryptography and stored the
    keys in the ransomware itself, which allowed security researchers to extract the
    keys. Modern ransomware systems use a hybrid approach. They’ll still use a random
    symmetric key to encrypt files on the victim’s machine, but to prevent security
    researchers from extracting the key, they’ll encrypt the symmetric key with the
    hacker’s public key. [Figure 5-8](ch05.xhtml#ch5fig8) shows an overview of this
    process.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第一代勒索软件系统使用对称密钥加密，并将密钥存储在勒索软件本身中，这使得安全研究人员能够提取密钥。现代勒索软件系统使用混合方法。它们仍然使用随机对称密钥来加密受害者机器上的文件，但为了防止安全研究人员提取密钥，它们会用黑客的公钥加密对称密钥。[图5-8](ch05.xhtml#ch5fig8)显示了这个过程的概览。
- en: If the victim pays the ransom, usually by uploading Bitcoin and a copy of the
    encrypted symmetric key, the ransomware server will use the hacker’s private key
    to decrypt the symmetric key and return it to the victim. The victim uses this
    key to decrypt the files.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果受害者支付赎金，通常通过上传比特币和加密的对称密钥副本，勒索软件服务器将使用黑客的私钥解密对称密钥并将其返回给受害者。受害者使用此密钥解密文件。
- en: '![image](../images/ch05fig08.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch05fig08.jpg)'
- en: '*Figure 5-8: How the ransomware protects the symmetric key by encrypting it
    using a hacker’s public key*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-8：勒索软件如何通过使用黑客的公钥加密对称密钥来保护它*'
- en: Of course, the attacker could just accept the payment and ignore the victim,
    never decrypting the files nor sending the key. Once the victim pays, the attacker
    has little to gain from participating in the decryption process.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，攻击者可以接受支付并忽略受害者，既不解密文件，也不发送密钥。一旦受害者支付了赎金，攻击者从解密过程中的参与中几乎没有任何收获。
- en: In this section, we’ll write our own ransomware client in Python. So that we
    don’t encrypt all the files on the Kali Linux virtual machine, we’ll limit our
    ransomware client to encrypting only one file. However, you could easily extend
    the implementation to encrypt every file on a victim’s computer. First we’ll generate
    a random symmetric key and then use that key to encrypt the file. After the file
    has been encrypted, we’ll use our public key to encrypt the symmetric key and
    save it to a file on the Kali Linux machine. When the program terminates, it will
    delete the symmetric key.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写自己的Python勒索病毒客户端。为了避免加密Kali Linux虚拟机上的所有文件，我们将限制勒索病毒客户端仅加密一个文件。然而，你可以轻松地扩展实现，使其加密受害者计算机上的每个文件。首先，我们将生成一个随机的对称密钥，然后使用该密钥加密文件。文件加密后，我们将使用公钥加密对称密钥，并将其保存到Kali
    Linux机器上的一个文件中。当程序终止时，它将删除对称密钥。
- en: 'We’ll use the pyca`/cryptography` library recommended by the Python Cryptography
    Authority. Install the library by running this command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python加密权威机构推荐的pyca`/cryptography`库。通过运行以下命令安装该库：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After you’ve installed the library, open a text editor such as Mousepad and
    enter the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 安装库后，打开一个文本编辑器，如Mousepad，并输入以下内容：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Fernet` module ➊ provides a simple API for performing symmetrickey cryptography.
    We load the public key from a file by using the `with` keyword ➋, which is a better
    alternative to Python’s `try finally` keywords because it implicitly manages the
    resource. To see how, consider the following examples. The first example uses
    the `try` and `finally` keywords to open, edit, and close a file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fernet`模块 ➊ 提供了一个简单的API，用于执行对称密钥加密。我们通过使用`with`关键字 ➋ 从文件加载公钥，这比Python的`try
    finally`关键字更好，因为它隐式地管理资源。为了说明这一点，考虑以下示例。第一个示例使用`try`和`finally`关键字打开、编辑和关闭文件：'
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In contrast, the second example uses the `with` keyword to implicitly manage
    the resource, resulting in shorter and more readable code like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，第二个示例使用`with`关键字来隐式地管理资源，从而产生更简洁、更易读的代码，如下所示：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We then used the OAEP algorithm ➌. Because OAEP internally relies on a cryptographic
    hash function, we must select one to use. Here we select the SHA256 hash algorithm
    ➍.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用了OAEP算法 ➌。由于OAEP内部依赖于加密哈希函数，我们必须选择一个来使用。这里我们选择了SHA256哈希算法 ➍。
- en: Next, we write the encrypted key to a file in memory ➎ and then encrypt the
    file ➏. When the program terminates, the plaintext symmetric key will be erased
    from the computer’s memory.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将加密密钥写入内存中的文件 ➎ 然后加密该文件 ➏。程序终止时，明文对称密钥将从计算机内存中删除。
- en: Now, how can an attacker in a coffee shop demand money from a company by uploading
    this encryption ransomware to the company’s systems? In [Chapter 2](ch02.xhtml#ch2),
    we discussed how an attacker could use an ARP spoofing attack to intercept a target’s
    web traffic. In [Chapter 3](ch03.xhtml#ch3), you learned how the attacker used
    Wireshark to extract the IP address of a server the target was visiting, and in
    [Chapter 4](ch04.xhtml#ch4), we looked at how the attacker used `nmap` to scan
    the server and discover a vulnerable FTP application running on port 21\. We also
    saw how an attacker could exploit the FTP application and upload a custom reverse
    shell. The attacker could then use this reverse shell to upload a copy of their
    own encryption ransomware to the web server. In [Chapters 7](ch07.xhtml#ch7) and
    [8](ch08.xhtml#ch8), we’ll discuss techniques that hackers could use if they can’t
    find other vulnerabilities in the server.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个咖啡店的攻击者如何通过上传这种加密勒索软件到公司的系统来勒索公司呢？在[第2章](ch02.xhtml#ch2)中，我们讨论了攻击者如何使用ARP欺骗攻击拦截目标的Web流量。在[第3章](ch03.xhtml#ch3)中，你学到了攻击者如何使用Wireshark提取目标访问的服务器IP地址，在[第4章](ch04.xhtml#ch4)中，我们看到攻击者如何使用`nmap`扫描服务器并发现运行在21端口的易受攻击的FTP应用程序。我们还看到攻击者如何利用FTP应用程序上传自定义的反向Shell。然后，攻击者可以使用这个反向Shell将自己的加密勒索软件上传到Web服务器。在[第7章](ch07.xhtml#ch7)和[第8章](ch08.xhtml#ch8)中，我们将讨论如果攻击者在服务器上找不到其他漏洞时，可能使用的技术。
- en: '**Exercises**'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习**'
- en: Attempt the following exercises to deepen your understanding of encryption and
    ransomware. In the first exercise, you’ll write a ransomware server that decrypts
    the symmetric key and returns it to the client. In the second exercise, you’ll
    extend the client so that it sends a copy of the encrypted key to the server.
    In the final exercise, you’ll explore the solved and unsolved codes written on
    the Kryptos statue in front of Central Intelligence Agency (CIA) headquarters
    in Langley, Virginia.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下练习以加深你对加密和勒索软件的理解。在第一个练习中，你将编写一个勒索软件服务器，解密对称密钥并将其返回给客户端。在第二个练习中，你将扩展客户端，使其将加密的密钥副本发送到服务器。在最后一个练习中，你将探索位于弗吉尼亚州兰利中央情报局总部前Kryptos雕像上的已解决和未解决的代码。
- en: '***The Ransomware Server***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***勒索软件服务器***'
- en: 'Implement a server that communicates with your ransomware client. Your server
    should be able to handle multiple client connections. Once a client connects to
    the server, the client will send the server an encrypted symmetric key. Your server
    should decrypt this key using its private key and then send it to the client:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个与勒索软件客户端通信的服务器。你的服务器应该能够处理多个客户端连接。一旦客户端连接到服务器，客户端将发送一个加密的对称密钥到服务器。服务器应该使用其私钥解密该密钥，然后将其发送回客户端：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We began implementing the function that will decrypt the symmetric key and
    send it back to the client ➊. As an exercise, try modifying the function so that
    it decrypts the key and sends it back. Hint: read the RSA decryption section of
    the pyca/`cryptography` library documentation at *[https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa.html](https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa.html)*.
    Remember that you need to load the private key before you use it.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始实现将解密对称密钥并将其发送回客户端的功能 ➊。作为练习，尝试修改该函数，使其解密密钥并将其发送回客户端。提示：阅读pyca/`cryptography`库文档中的RSA解密部分，地址是*[https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa.html](https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa.html)*。记住，使用私钥之前需要加载它。
- en: Next, we create a new instance of the TCP server ➋, and then we start the server
    ➌. This is the same TCP server code you used in [Chapter 4](ch04.xhtml#ch4).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的TCP服务器实例 ➋，然后启动服务器 ➌。这是你在[第4章](ch04.xhtml#ch4)中使用的相同TCP服务器代码。
- en: As an added challenge, try extending the ransomware server to check for the
    receipt of a Bitcoin payment before sending the decrypted key.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 作为附加挑战，尝试扩展勒索软件服务器，在发送解密密钥之前检查是否已收到比特币付款。
- en: '***Extending the Ransomware Client***'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***扩展勒索软件客户端***'
- en: Extend the ransomware client you built in this chapter to include the ability
    to decrypt the file after it receives the decrypted symmetric key from the ransomware
    server you built in the previous exercise. This client will need to send the ransomware
    server a copy of the encrypted symmetric key and read the decrypted symmetric
    key that the server sends back. It will then need to use the decrypted symmetric
    key to decrypt the file it encrypted earlier.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展你在本章中构建的勒索软件客户端，加入接收解密后的对称密钥后解密文件的功能。这个客户端需要将加密的对称密钥副本发送到你在上一个练习中构建的勒索软件服务器，并读取服务器返回的解密后的对称密钥。然后，它需要使用解密后的对称密钥解密它之前加密的文件。
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We create a new socket and open the key file ➊. Then, you need to implement
    the code that sends the key file and waits for the decrypted result ➋. When you
    receive the decrypted key, pass it to the `decryptFile()` function ➌.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的套接字并打开密钥文件 ➊。然后，你需要实现发送密钥文件并等待解密结果的代码 ➋。当你收到解密后的密钥时，将其传递给`decryptFile()`函数
    ➌。
- en: 'Notice that this function contains no code: I’ll leave it to you to implement
    the decryption function so that it uses the `Fernet` module to restore the file.
    Hint: read *[https://cryptography.io/en/latest/](https://cryptography.io/en/latest/)*
    for tips on how to do this.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个函数没有代码：我将留给你实现解密函数，使其使用`Fernet`模块恢复文件。提示：阅读*[https://cryptography.io/en/latest/](https://cryptography.io/en/latest/)*以获得如何操作的提示。
- en: '***Unsolved Codes***'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***未解决的代码***'
- en: Several codes remain unsolved, including the famous ones written on the Kryptos
    statue in front of CIA headquarters. The statue contains four encrypted messages,
    three of which have been solved. The first two codes were encrypted using an extension
    of the Caesar cipher called the *Vigenère cipher*. The third was encrypted using
    a technique called *transposition*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个密码仍未解开，包括在中央情报局总部前的Kryptos雕像上写的著名密码。雕像包含四个加密信息，其中三个已经解开。前两个密码是使用凯撒密码的扩展——*维吉尼亚密码*加密的。第三个密码是使用一种叫做*换位法*的技术加密的。
- en: 'However, no one has been able to decrypt the fourth code. The artist who created
    the statue, Jim Sanborn, has provided four hints, shown in [Table 5-2](ch05.xhtml#ch5tab2).
    Try solving the first three codes yourself. The first code was encrypted using
    a Vigenère cipher and the key: Kryptos, Palimpsest. If you use this key and a
    Vigenère table, you will be able decode it. Then, if you feel brave enough, try
    decoding the fourth, unsolved code.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没人能解开第四个密码。创建雕像的艺术家吉姆·桑博恩（Jim Sanborn）提供了四个线索，见[表5-2](ch05.xhtml#ch5tab2)。试着自己解开前三个密码。第一个密码是使用维吉尼亚密码加密的，密钥是：Kryptos,
    Palimpsest。如果你使用这个密钥和维吉尼亚表格，你将能够解码它。然后，如果你足够勇敢，可以尝试解开第四个未解的密码。
- en: '**Table 5-2:** Four Hints from Jim Sanborn'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**表5-2：** 吉姆·桑博恩提供的四个线索'
- en: '| Position | Cipher text | Plaintext |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | 密文 | 明文 |'
- en: '| --- | --- | --- |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 64th–69th letters | “NYPVTT” | “BERLIN |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 第64至69位字母 | “NYPVTT” | “BERLIN” |'
- en: '| 70th–74th | “MZFPK” | “CLOCK” |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 第70至74位 | “MZFPK” | “CLOCK” |'
- en: '| 26th–34th | “EFGHIJL0H” | “NORTHEAST” |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 第26至34位 | “EFGHIJL0H” | “NORTHEAST” |'
- en: '| 22nd–25th | “FLRV” | “EAST” |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 第22至25位 | “FLRV” | “EAST” |'
- en: 'Following is a representation of the four encrypted messages:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是四个加密信息的表现形式：
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
