- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Controlling User Commands with sudo
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用sudo控制用户命令
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: So far, you have secured access to your VM with a public key and two-factor
    authentication. You have also controlled access to a specific file and directory,
    using group permissions. The next foundational piece is allowing users to run
    elevated commands on the VM. Users typically need access to commands that may
    require administrative permissions, such as restarting a service or installing
    a missing package. As an administrator, you want to keep a tight control on who
    can run which commands. On Linux operating systems, the `sudo` (superuser do)
    command allows users to run specific commands as *root* or another user while
    keeping an audit trail of events.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经通过公钥和双因素认证确保了对虚拟机的访问。你还通过使用组权限控制了对特定文件和目录的访问。接下来的基础步骤是允许用户在虚拟机上运行提升权限的命令。用户通常需要访问一些可能需要管理员权限的命令，比如重启服务或安装缺失的软件包。作为管理员，你希望严格控制谁可以运行哪些命令。在Linux操作系统上，`sudo`（超级用户执行）命令允许用户以*root*或其他用户的身份执行特定命令，同时保持事件的审计痕迹。
- en: In this chapter, you’ll use Ansible to install a simple Python Flask web application.
    You’ll also use Ansible to create a *sudoers* security policy, which is configured
    by a file and determines what permissions users have when they invoke the `sudo`
    command. This policy will allow members of the *developers* group to use the `sudo`
    command to start, stop, restart, and edit the sample web application. Although
    this is a made-up example, it follows a typical release workflow that software
    engineers should be accustomed to. By the end of the chapter, you’ll have a good
    grasp of how to automate application deployment and control it with a *sudoers*
    policy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用Ansible安装一个简单的Python Flask web应用程序。你还将使用Ansible创建一个*sudoers*安全策略，这个策略由一个文件配置，决定了用户在调用`sudo`命令时拥有的权限。这个策略将允许*developers*组的成员使用`sudo`命令启动、停止、重启以及编辑示例web应用程序。虽然这是一个假设的例子，但它遵循了软件工程师应熟悉的典型发布工作流程。在本章结束时，你将对如何自动化应用程序部署并通过*sudoers*策略进行控制有一个清晰的理解。
- en: What Is sudo?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是sudo？
- en: If you are new to `sudo`, it is a command line tool on most Unix OSs that allows
    a user or group of users to run commands as another user. For example, a software
    engineer may need to restart an Nginx web server that’s owned by the *root* user,
    or a system administrator may need elevated permissions to install some software
    packages. If you have been around Linux long enough, you have likely used `sudo`
    to run a command that requires elevated privileges. Normally, you would not allow
    just anyone to have such privileges, due to various security implications. Regardless
    of your use case, users will need a safe and accountable way to access privileged
    commands to do their jobs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是`sudo`的新手，它是大多数Unix操作系统中的一个命令行工具，允许用户或用户组以其他用户的身份执行命令。例如，一个软件工程师可能需要重启由*root*用户拥有的Nginx
    web服务器，或者系统管理员可能需要提升权限来安装一些软件包。如果你在Linux上待得够久，你可能已经使用过`sudo`来执行需要提升权限的命令。通常，你不会允许任何人拥有这种权限，因为这会涉及到各种安全问题。无论你的使用场景如何，用户都需要一种安全且可追溯的方式来访问特权命令，以完成他们的工作。
- en: One of the best features of `sudo` is its ability to leave an audit trail. If
    someone runs a command with `sudo`, you can check the log to see who ran what
    command. Without `sudo`, there is zero accountability if you blindly allow people
    to switch to other users to run commands.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo`的最佳特性之一是它能够留下审计痕迹。如果有人使用`sudo`执行命令，你可以查看日志，看看是谁执行了什么命令。如果没有`sudo`，如果你盲目允许人们切换到其他用户去执行命令，就没有任何责任追踪。'
- en: You also can enhance `sudo` with plug-ins. In fact, `sudo` comes with a default
    security policy plug-in called *sudoers*, which determines what permissions users
    have when they invoke the `sudo` command. You’ll implement this policy for your
    user *bender*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过插件增强`sudo`。实际上，`sudo`自带一个名为*sudoers*的默认安全策略插件，它决定了用户在调用`sudo`命令时拥有的权限。你将为用户*bender*实现这一策略。
- en: Planning a sudoers Security Policy
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规划sudoers安全策略
- en: When you are planning a *sudoers* policy, less is more. You want a user or group
    of users to have just the right amount of permissions on a host. If you have a
    user that can run many privileged commands while administering the company website
    at the same time, you’ll have serious issues if that user is compromised. This
    is because any attackers will inherit the same access that the compromised user
    has.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你规划一个*sudoers*策略时，少即是多。你希望一个用户或一组用户在主机上拥有恰到好处的权限。如果有一个用户能够在管理公司网站时运行许多特权命令，那么如果这个用户被攻击者利用，你将面临严重的问题。这是因为任何攻击者都会继承被攻破用户的相同访问权限。
- en: That said, it is naive to think you can lock down a host completely and still
    get things done. Imagine a software delivery workflow where an application needs
    to be restarted after each deployment. Without proper user permissions, you will
    not be able to automate continuous delivery for that application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，认为你可以完全锁定主机并仍然能够完成工作是天真的。试想一个软件交付工作流，其中应用程序在每次部署后需要重新启动。如果没有适当的用户权限，你将无法为该应用程序实现持续交付自动化。
- en: For the example security policy you’ll set up in this chapter, everyone in the
    *developers* group will be able to access the sample web application. They’ll
    also be able to stop, start, and edit the main application file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将设置的示例安全策略是，*developers*组中的每个人都能够访问示例Web应用程序。他们还将能够停止、启动和编辑主应用程序文件。
- en: Installing the Greeting Web Application
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装问候Web应用程序
- en: The sample Python web application I have provided is cleverly (and lazily) named
    *Greeting*. This simple web application responds with an enthusiastic “Greetings!”
    when you visit *http://localhost:5000* on the VM. I am providing this application
    so you can focus on learning automation and provisioning; I won’t go over its
    code here.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我提供的示例Python Web应用程序巧妙地（也是懒惰地）命名为*Greeting*。这个简单的Web应用程序在你访问虚拟机上的*http://localhost:5000*时，会热情地回应“Greetings！”我提供这个应用程序是为了让你集中精力学习自动化和配置；在这里我不会讲解它的代码。
- en: You’ll use Ansible tasks to install the necessary libraries and files to run
    the web application. You’ll also install a *systemd* unit file, the standard service
    manager that manages processes and services on a Linux host, to make it easier
    to start and stop the web application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用Ansible任务安装运行Web应用程序所需的库和文件。你还将安装一个*systemd*单元文件，它是管理Linux主机上进程和服务的标准服务管理器，便于启动和停止Web应用程序。
- en: The Ansible tasks to install the web application (and all the other tasks for
    this chapter) are located in the *ansible/chapter4/* directory. You should navigate
    to that directory and open the task file named *web_application.yml* in your favorite
    editor.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Web应用程序的Ansible任务（以及本章的所有其他任务）位于*ansible/chapter4/*目录中。你应该导航到该目录并在你喜欢的编辑器中打开名为*web_application.yml*的任务文件。
- en: 'This file contains four individual tasks, named as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件包含四个独立的任务，名称如下：
- en: Install `python3-flask`, `gunicorn3`, and `nginx`
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`python3-flask`、`gunicorn3`和`nginx`
- en: Copy Flask Sample Application
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制Flask示例应用程序
- en: Copy *Systemd* Unit file for Greeting
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制*Systemd*单元文件以启动问候应用程序
- en: Start and enable Greeting Application
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动并启用问候应用程序
- en: 'I’ll go over each of these tasks, starting with the one that installs the web
    application dependencies: `python3-flask`, `gunicorn3`, and `nginx`. It’s the
    first task at the top of the file, and it should look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我将逐个讲解这些任务，首先从安装Web应用程序依赖项的任务开始：`python3-flask`、`gunicorn3`和`nginx`。这是文件顶部的第一个任务，应该如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The task `name` describes its intent, which is to `Install` some software packages.
    The `apt` module is used again to install the `python3-flask`, the `gunicorn3`,
    and the `nginx` packages from the Ubuntu repository on the VM. This time, however,
    the `apt` module uses some syntactical sugar: a YAML list. This feature allows
    you to install multiple packages (or remove them) in a single task, instead of
    having to create a task for each package you want to install.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 任务`name`描述了它的意图，即`安装`一些软件包。`apt`模块再次被用来从Ubuntu存储库中在虚拟机上安装`python3-flask`、`gunicorn3`和`nginx`包。然而这次，`apt`模块使用了一些语法糖：YAML列表。这一特性允许你在一个任务中安装多个软件包（或卸载它们），而不需要为每个要安装的软件包创建单独的任务。
- en: 'The second task from the top copies the sample Greeting application over to
    the VM. You need two files to bring the Greeting web application to life, and
    the task should look like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始的第二个任务将示例问候应用程序复制到虚拟机上。你需要两个文件来让问候Web应用程序正常运行，任务应该如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `copy` module copies the two files from the provided repository to the
    VM. The `src` and `dest` lines are templated (with double curly brackets) and
    replaced by the values from the `loop` module. Here, the `loop` module references
    two files by name: *greeting.py* and *wsgi.py*. The *greeting.py* file is the
    actual Python Flask code, while the *wsgi.py* file contains the application object
    for the HTTP server. During this task’s runtime, the placeholder `{{ item }}`
    will be replaced with each of these two filenames from the `loop`. For example,
    the `src` line will look like `"../ansible/chapter4/greeting.py"` after the first
    pass of the `loop`. The `mode` line sets the permissions on both files to be read
    and to execute for anyone in the *developers* group.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy` 模块将两个文件从提供的仓库复制到虚拟机（VM）。`src` 和 `dest` 行是模板化的（使用双大括号），并由 `loop` 模块的值替换。在这里，`loop`
    模块通过名称引用了两个文件：*greeting.py* 和 *wsgi.py*。*greeting.py* 文件是实际的 Python Flask 代码，而
    *wsgi.py* 文件包含了 HTTP 服务器的应用程序对象。在此任务的运行时，`{{ item }}` 占位符会被 `loop` 中的这两个文件名之一替换。例如，`src`
    行在 `loop` 第一次遍历时会变成 `"../ansible/chapter4/greeting.py"`。`mode` 行将两个文件的权限设置为任何
    *developers* 组的成员都可以读取和执行。'
- en: 'Next, let’s look at the task that copies the *systemd* unit file over to the
    VM. This task, located third from the top, should look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看复制 *systemd* 单元文件到虚拟机的任务。此任务位于从顶部数起的第三个位置，应如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This task starts with a descriptive `name`, as usual. Then, the familiar Ansible
    `copy` module copies a file from the local host to the VM. In this case, it copies
    the *greeting.service* file to a place on the VM where `systemd` can find it:
    */etc/systemd/system*.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该任务首先使用描述性的 `name`，如往常一样。然后，熟悉的 Ansible `copy` 模块将一个文件从本地主机复制到虚拟机。在这种情况下，它将
    *greeting.service* 文件复制到虚拟机上 `systemd` 可以找到的位置：*/etc/systemd/system*。
- en: Let’s review the *system service* file. Such files can have many options and
    settings, but for this example, I’ve provided a simple one to control the Greeting
    web application’s life cycle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 *system service* 文件。这类文件可以有很多选项和设置，但在本例中，我提供了一个简单的文件来控制 Greeting Web
    应用程序的生命周期。
- en: 'Open the *ansible/chapter4/greeting.service* file in your editor. It should
    look like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中打开 *ansible/chapter4/greeting.service* 文件。它应如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `WorkingDirectory` and `ExecStart` lines are the most important in this
    file. The first sets the working directory to */opt/engineering*, since that’s
    where your application code lives. In the `ExecStart` line, the `gunicorn3` application
    calls the *wsgi.py* file to start the web application. You’ll also tell `gunicorn3`
    to log STDOUT (`--access-logfile -` ) and STDERR (`--error-logfile -` ) to the
    *systemd* journal, which is forwarded by default to the */var/log/syslog* file.
    Close the *greeting.service* file for now.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkingDirectory` 和 `ExecStart` 行是此文件中最重要的部分。第一行将工作目录设置为 */opt/engineering*，因为这是应用程序代码所在的目录。在
    `ExecStart` 行中，`gunicorn3` 应用程序调用 *wsgi.py* 文件来启动 Web 应用程序。你还会告诉 `gunicorn3` 将
    STDOUT（`--access-logfile -`）和 STDERR（`--error-logfile -`）日志记录到 *systemd* 日志中，默认情况下，这些日志会转发到
    */var/log/syslog* 文件。现在关闭 *greeting.service* 文件。'
- en: 'The last task in the *web_application.yml* file ensures that the Greeting web
    application is started and that the `systemd` daemon is reloaded each time a provision
    is run. It should look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*web_application.yml* 文件中的最后一个任务确保 Greeting Web 应用程序已启动，并且每次执行配置时都会重新加载 `systemd`
    守护进程。它应如下所示：'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the `systemd` Ansible module starts the Greeting web application. The
    module requires you to set the `name` and `state`, which in this case are `greeting.service`
    and `started`, respectively. The `enabled` parameter tells `systemd` to start
    the service automatically during startup. Using the `daemon_reload` parameter
    also forces `systemd` to reload all service files and discover the *greeting.service*
    file before doing anything else. It’s equivalent to running `systemctl daemon-reload`.
    The `daemon_reload` parameter is useful on the first provision of a host to make
    sure `systemd` knows about the service. Be sure to use the `daemon_reload` parameter
    so that `systemd` always knows about any changes to the service file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`systemd` Ansible 模块启动 Greeting Web 应用程序。该模块要求你设置 `name` 和 `state`，在此情况下分别为
    `greeting.service` 和 `started`。`enabled` 参数告诉 `systemd` 在启动时自动启动该服务。使用 `daemon_reload`
    参数还强制 `systemd` 重新加载所有服务文件，并在执行其他操作之前发现 *greeting.service* 文件。这相当于运行 `systemctl
    daemon-reload`。`daemon_reload` 参数在主机的首次配置时非常有用，以确保 `systemd` 知道该服务。务必使用 `daemon_reload`
    参数，以确保 `systemd` 始终知道服务文件的任何更改。
- en: Anatomy of a sudoers File
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sudoers 文件的结构
- en: A *sudoers* file is the place where you configure security policies (for users
    and groups) that invoke the `sudo` command. This type of security file is composed
    of sections called `Defaults`, `User Specifications`, and `Aliases`. A *sudoers*
    file is read from the top down, and since rules are applied in that order, the
    last matching rule always wins.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*sudoers* 文件是配置安全策略（针对用户和组），用于调用 `sudo` 命令的地方。此类安全文件由名为 `Defaults`、`User Specifications`
    和 `Aliases` 的部分组成。*sudoers* 文件是从上到下读取的，规则按此顺序应用，因此最后匹配的规则总是会生效。'
- en: The `Defaults` syntax allows you to override some *sudoers* options at runtime,
    such as setting environment variables that users have access to when they run
    `sudo`. The `User Specifications` section determines which commands users can
    run and on which host they can run them. For example, you could give the *bender*
    user permission to run the `apt install` command on all web server hosts. The
    `Aliases` syntax references other objects inside the file, and that is useful
    for keeping the configuration clear and concise when there is a lot of duplication.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Defaults` 语法允许你在运行时覆盖一些 *sudoers* 选项，例如设置用户在运行 `sudo` 时可以访问的环境变量。`User Specifications`
    部分决定了用户可以运行哪些命令，以及可以在哪些主机上运行这些命令。例如，你可以授予 *bender* 用户在所有 Web 服务器主机上运行 `apt install`
    命令的权限。`Aliases` 语法引用文件中的其他对象，这对于在有很多重复内容时保持配置清晰简洁非常有用。'
- en: 'The four aliases you can mix and match are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以混合使用的四个别名如下：
- en: '`Host_Alias` A host or a group of hosts'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Host_Alias` 指定一个主机或一组主机'
- en: '`Runas_Alias` A list of users or groups a command can be run as'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Runas_Alias` 指定一个命令可以以哪些用户或组的身份运行'
- en: '`Cmnd_Alias` Specifies a command or multiple commands'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Cmnd_Alias` 指定一个或多个命令'
- en: '`User_Alias` A user or group of users'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`User_Alias` 指定一个用户或一组用户'
- en: For this example, you’ll only use `Cmnd_Alias` and `Host_Alias`in your *sudoers*
    file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，你只会在 *sudoers* 文件中使用 `Cmnd_Alias` 和 `Host_Alias`。
- en: Creating the sudoers File
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 *sudoers* 文件
- en: To create the *sudoers* file, you’ll use the Ansible `template` module and a
    template file. The Ansible `template` module is useful for creating files that
    will require some modification with variables. The `template` module creates files
    using the Jinja2 template engine for Python templates. You’ll keep template files
    in a separate directory called *ansible/templates/* (more on this later).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 *sudoers* 文件，你将使用 Ansible 的 `template` 模块和一个模板文件。Ansible 的 `template` 模块对于创建需要用变量修改的文件非常有用。`template`
    模块使用 Python 模板的 Jinja2 模板引擎来创建文件。你将把模板文件保存在一个名为 *ansible/templates/* 的独立目录中（稍后会详细说明）。
- en: 'In the *ansible/chapter4/* directory, open the task file named *sudoers.yml*
    in your favorite editor. The first thing you should notice, at the top of the
    file, is a new Ansible module called `set_fact`. This module allows you to set
    host variables that can be used in a task or across a playbook. Here, you’ll set
    a variable with it for use in your template file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *ansible/chapter4/* 目录下，使用你喜欢的编辑器打开名为 *sudoers.yml* 的任务文件。你首先应该注意到的是，在文件顶部有一个新的
    Ansible 模块，叫做 `set_fact`。这个模块允许你设置主机变量，这些变量可以在任务或整个剧本中使用。在这里，你将使用它来设置一个变量，并在模板文件中使用：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This creates a variable named `greeting_application_file` and sets its value
    to */opt/engineering/greeting.py* (where the previous tasks will install the web
    application). As noted previously, anyone in the *developers* group can read and
    execute in the */opt/engineering/* directory.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个名为 `greeting_application_file` 的变量，并将其值设置为 */opt/engineering/greeting.py*（之前的任务会安装这个
    Web 应用）。如前所述，*developers* 组中的任何人都可以在 */opt/engineering/* 目录下读取和执行文件。
- en: 'Next, locate the task right below the `set_fact` module. This task creates
    the *sudoers* file for the *developers* group and should look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，找到位于 `set_fact` 模块下面的任务。这个任务为 *developers* 组创建 *sudoers* 文件，应该如下所示：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Ansible `template` module builds out your *sudoers* file. It requires a
    source file (`src`) and a destination file (`dest`). The source file is your local
    Jinja2 template (*developers.j2*), and the destination file will be the *developers
    sudoers* file on the VM. The `template` module also contains a `validate` step
    to verify whether the template is correct. In this case, the `visudo` command
    edits and validates your *sudoers* file in a safe manner. Adding the `-cf` flag
    to `visudo` makes sure the *sudoers* file is compliant and free of syntax errors.
    The `%s` is a placeholder for the file in the `dest` parameter. If the `validate`
    command fails for any reason, the Ansible task will fail, too. Finally, set the
    owner, group, and permissions of the file to `root`, `root`, and `0440` (respectively).
    This is what *sudoers* is expecting for proper permissions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的`template`模块构建了你的*sudoers*文件。它需要一个源文件（`src`）和一个目标文件（`dest`）。源文件是你本地的
    Jinja2 模板（*developers.j2*），目标文件将在 VM 上创建*developers sudoers*文件。`template`模块还包含一个`validate`步骤，用于验证模板是否正确。在这种情况下，`visudo`命令以安全的方式编辑并验证你的*sudoers*文件。给`visudo`命令加上`-cf`标志可以确保*sudoers*文件合规并且没有语法错误。`%s`是`dest`参数中文件的占位符。如果`validate`命令因任何原因失败，Ansible任务也会失败。最后，将文件的所有者、组和权限设置为`root`、`root`和`0440`（分别）。这是*sudoers*期望的正确权限。
- en: The sudoers Template
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sudoers 模板
- en: The Ansible `template` module task referenced a source Jinja2 template file
    located in the *ansible/templates/* directory. It has the building blocks of your
    *sudoers* policy for the *developers* group.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的`template`模块任务引用了位于*ansible/templates/*目录中的源 Jinja2 模板文件。它包含了为*developers*组创建*sudoers*策略的基本构建块。
- en: 'Navigate to the *ansible/templates/* directory and open the *developers.j2*
    file in your editor. The *.j2* suffix on the file tells Ansible that it’s a Jinja2
    template. The contents of the file should look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到*ansible/templates/*目录，并在编辑器中打开*developers.j2*文件。文件的*.j2*后缀告诉 Ansible 这是一个
    Jinja2 模板。文件的内容应如下所示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The file begins with three `Cmnd_Alias` declarations that stop, start, and restart
    the Greeting web application. (In `systemd`, a service can be referred to as either
    `greeting` or `greeting.service`, so this handles both cases.) Next, a `Host_Alias`
    called `LOCAL_VM` is set to the private IP address of the VM. The built-in Ansible
    variable `hostvars` dynamically fetches the IP address of the VM during provision
    runtime. This is useful if you are provisioning many hosts at the same time. Finally,
    this creates a user specification for the *developers* group. (The `%` denotes
    it is a group and not a user.) The user specification rule states that anyone
    in the *developers* group, on the `LOCAL_VM`, can start, stop, restart, and edit
    the Greeting web application without a password, as the *root* user. Notice that
    issuing the `sudoedit` command is allowed only for editing the web application.
    (I’ll discuss `sudoedit` in more detail later.) The `{{ greeting_application_file
    }}` variable will be set during runtime to point to your Greeting web application
    file via `set_fact`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件以三个`Cmnd_Alias`声明开始，这些声明用于停止、启动和重启 Greeting Web 应用程序。（在`systemd`中，服务可以被称为`greeting`或`greeting.service`，所以这两种情况都会被处理。）接下来，设置一个名为`LOCAL_VM`的`Host_Alias`，它指向
    VM 的私有 IP 地址。内建的 Ansible 变量`hostvars`在配置运行时动态获取 VM 的 IP 地址。如果你同时配置多个主机，这将非常有用。最后，这会为*developers*组创建一个用户规范。（`%`表示这是一个组，而不是一个用户。）用户规范规则声明，在`LOCAL_VM`上的任何*developers*组成员，都可以作为*root*用户，无需密码启动、停止、重启或编辑
    Greeting Web 应用程序。请注意，发出`sudoedit`命令仅允许编辑 Web 应用程序。（稍后我会更详细地讨论`sudoedit`。）`{{
    greeting_application_file }}`变量将在运行时设置，指向通过`set_fact`设置的 Greeting Web 应用程序文件。
- en: At this point, it is safe to close all open files. Next, you’ll configure the
    VM and test *bender*’s `sudo` privileges.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，可以安全地关闭所有打开的文件。接下来，你将配置 VM 并测试*bender*的`sudo`权限。
- en: Provisioning the VM
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 VM
- en: 'To run all the tasks for this chapter, you need to uncomment them in the playbook
    like you did in previous chapters. Open the *ansible/site.yml* file in your editor
    and locate the task for installing the web application. It should look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章的所有任务，你需要像在前几章中一样取消注释它们。在编辑器中打开*ansible/site.yml*文件，并找到安装 Web 应用程序的任务。它应该像这样：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Remove the `#` symbol to uncomment it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`#`符号以取消注释。
- en: 'Next, find the task that creates the *developers sudoer* policy:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，找到创建*developers sudoer*策略的任务：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Uncomment that line by removing the `#` symbol as well.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除`#`符号来取消注释该行。
- en: 'The playbook should now look like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剧本应该看起来像这样：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The changes to the playbook for Chapter 4 are added to the changes from Chapter
    3.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第 4 章的 playbook 更改已经添加到第 3 章的更改中
- en: 'Now, you’ll run the Ansible tasks using Vagrant. Navigate back to the *vagrant/*
    directory where your *Vagrant* file is located and enter the following command
    to provision the VM:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将使用 Vagrant 运行 Ansible 任务。返回到 *vagrant/* 目录，其中包含你的 *Vagrant* 文件，并输入以下命令来配置虚拟机：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The values from the provision output will vary, depending on how many times
    you run the `provision` command, as Ansible makes sure your environment is consistent
    and doesn’t do extra work if it’s not needed. The total task count here has increased
    to `21`. You’ve also changed these six things on the VM:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 配置输出中的值会有所不同，具体取决于你运行 `provision` 命令的次数，因为 Ansible 会确保你的环境一致，如果不需要，它不会做多余的工作。这里的总任务数量已增加到
    `21`。你还在虚拟机上更改了以下六个内容：
- en: Five new tasks from Chapter 4
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 4 章的五个新任务
- en: One task that updates the timestamp on the empty file from Chapter 2
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个任务更新了第 2 章中的空文件的时间戳
- en: Once again, make sure no actions have failed before you continue.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 再次确认在继续之前没有操作失败。
- en: Testing Permissions
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试权限
- en: With the VM successfully provisioned, you can now check your security policy
    by testing *bender*’s command access. First, you’ll need to log in to the VM as
    *bender* again. The *sudoers* policy should allow anyone in the *developers* group
    (*bender*, in this case) to start, stop, restart, or edit the web application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机成功配置后，你现在可以通过测试 *bender* 的命令访问来检查你的安全策略。首先，你需要重新以 *bender* 用户登录虚拟机。*sudoers*
    策略应该允许 *developers* 组中的任何人（在这个案例中是 *bender*）启动、停止、重启或编辑网络应用程序。
- en: 'To log in as *bender*, grab another 2FA token. This time, locate the second
    2FA token from the top in the *ansible/chapter3/google_authenticator* file; it
    should be `68385555`. Once you have it, enter the following command in your terminal
    to log in as *bender*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要以 *bender* 身份登录，请获取另一个 2FA 令牌。这次，找到 *ansible/chapter3/google_authenticator*
    文件顶部的第二个 2FA 令牌；它应该是 `68385555`。拿到它后，在终端输入以下命令以 *bender* 用户身份登录：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, you’re using the SSH parameters from Chapter 3 to log in to the VM. When
    prompted for the 2FA token, use the second one you just grabbed. This login process
    should be familiar by now, but if not, revisit Chapter 3 for a refresher.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你使用的是第 3 章中的 SSH 参数来登录虚拟机。当系统提示输入 2FA 令牌时，使用刚刚获取的第二个令牌。这个登录过程现在应该很熟悉了，如果不熟悉，请回顾第
    3 章以获取更多信息。
- en: Accessing the Web Application
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问网络应用程序
- en: 'You’ll need to make sure the web application is running and responding to requests.
    You’ll test it with the `curl` command, which transfers data to servers (in this
    case, an HTTP server). The Greeting application server listens for requests on
    all interfaces on port 5000\. So, in the terminal, enter the following command
    to send an `HTTP GET` request to the greeting server on port 5000:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要确保网络应用程序正在运行并响应请求。你将使用 `curl` 命令来测试，它将数据传输到服务器（在此情况下是 HTTP 服务器）。Greeting
    应用程序服务器在所有接口上监听 5000 端口的请求。所以，在终端输入以下命令，向 Greeting 服务器的 5000 端口发送 `HTTP GET` 请求：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The output shows the Greeting web application is responding to requests successfully
    on `localhost` in the VM.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，Greeting 网络应用程序在虚拟机的 `localhost` 上成功响应请求。
- en: Editing greeting.py to Test the sudoers Policy
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑 greeting.py 来测试 sudoers 策略
- en: Next, you’ll make a small change to the Greeting application using `sudoedit`
    to test *bender*’s permissions. The *sudoers* policy you set earlier in this chapter
    allows the *developers* group members to edit the */opt/engineering/greeting.py*
    file with the `sudoedit` command, which lets users edit a file with any editor.
    It also makes a copy of the file before editing, in case things go awry. Without
    `sudoedit`, you might need to create multiple command aliases for each editor
    a user wants to use.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将通过 `sudoedit` 对 Greeting 应用程序进行小幅修改，以测试 *bender* 的权限。你在本章早些时候设置的 *sudoers*
    策略允许 *developers* 组的成员使用 `sudoedit` 命令编辑 */opt/engineering/greeting.py* 文件，`sudoedit`
    让用户可以用任何编辑器编辑文件，并且在编辑前会复制一份文件，以防出错。如果没有 `sudoedit`，你可能需要为每个用户想使用的编辑器创建多个命令别名。
- en: In a real production system, you probably would not edit a file directly on
    a host. Instead, you would edit the source-controlled version and allow your automation
    to update it with the newest version. However, I’m describing this approach to
    show how to test your *sudoers* policy.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实的生产系统中，你可能不会直接在主机上编辑文件。相反，你会编辑源控版本，并允许你的自动化更新它，确保使用最新版本。然而，我之所以描述这种方法，是为了展示如何测试你的
    *sudoers* 策略。
- en: 'While still logged in as *bender*, enter the following command to edit the
    *greeting.py* file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在仍然以 *bender* 身份登录的情况下，输入以下命令以编辑 *greeting.py* 文件：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The command should drop you into the Nano text editor (default for Ubuntu).
    Once there, locate the line that looks like this inside the `hello()` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应该将你带入 Nano 文本编辑器（Ubuntu 的默认编辑器）。进入编辑器后，在 `hello()` 函数内找到类似下面的代码行：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Change the `Greetings!` text inside the heading tag to `Greetings and Salutations!`
    so the line looks like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `<h1>Greetings!</h1>` 文本修改为 `<h1>Greetings and Salutations!</h1>`，使该行如下所示：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Save the file and exit the Nano text editor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并退出 Nano 文本编辑器。
- en: Stopping and Starting with systemctl
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 systemctl 停止和启动
- en: For the Greeting string changes to take effect, you’ll need to stop and start
    the web application server using `sudo` and the `systemctl` command (the latter
    of which is a command line application that allows you to control a service governed
    by `systemd`). The `Cmnd_Alias` declarations in your *sudoers* policy allow anyone
    in the *developers* group to run `/bin/systemctl stop greeting` or `/bin/systemctl
    start greeting`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使问候语字符串更改生效，你需要使用 `sudo` 和 `systemctl` 命令（后者是一个命令行应用程序，允许你控制由 `systemd` 管理的服务）停止并启动
    Web 应用程序服务器。你在 *sudoers* 策略中的 `Cmnd_Alias` 声明允许任何属于 *developers* 组的用户执行 `/bin/systemctl
    stop greeting` 或 `/bin/systemctl start greeting` 命令。
- en: 'To stop the already running Greeting application using `systemctl`, enter the
    following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `systemctl` 停止正在运行的 Greeting 应用程序，请输入以下命令：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There should be no output from the command, and you should not be prompted for
    a password.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 命令应没有输出，并且不应该提示输入密码。
- en: 'Next, run `curl` again to be sure the web application is stopped:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，重新运行 `curl` 命令，以确保 Web 应用程序已停止：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `curl` responded with a `Connection refused` error since the server is
    not running any longer.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`curl` 返回了一个 `Connection refused` 错误，因为服务器不再运行。
- en: 'Restart the stopped Greeting server by entering this command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令重新启动已停止的 Greeting 服务器：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There won’t be any output from this command if it is successful.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令成功执行，将不会有任何输出。
- en: 'Run the `curl` command again to check whether the web application is running
    with the new code changes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行 `curl` 命令，检查 Web 应用程序是否正在运行并且代码已更新：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The Greeting server provides a successful response with the new and improved
    greeting. If, for some reason, your Greeting application isn’t responding like
    this, go back and retrace your steps. Start by looking for errors in the */var/log/syslog*
    file or the */var/log/auth.log* file on the VM.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Greeting 服务器成功响应了新的改进版问候语。如果由于某种原因，你的 Greeting 应用程序没有像这样响应，请回溯你的步骤。从检查虚拟机上的
    */var/log/syslog* 文件或 */var/log/auth.log* 文件中的错误开始。
- en: Audit Logs
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审计日志
- en: As mentioned previously, one great feature of `sudo` is that it leaves behind
    an audit trail. The events in this trail are typically used in a monitoring framework
    or when doing forensics during an incident response. No matter what, you should
    make sure the audit data is in an accessible area so you can review it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`sudo` 的一个重要特点是它会留下审计日志。这些日志中的事件通常用于监控框架，或在事件响应过程中进行取证。不管怎样，你应该确保审计数据存放在一个可访问的区域，以便你进行查看。
- en: If you followed along with the testing in this chapter, you ran the `sudo` command
    three different times. Those events were captured in the */var/log/auth.log* file,
    so let’s explore some of the log lines from those `sudo` commands. I have cherry-picked
    a few that are pertinent to this example so you won’t get bogged down in the art
    of log parsing. However, feel free to explore the logfile in more depth on your
    own.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照本章中的测试进行操作，你会执行了三次 `sudo` 命令。那些事件被记录在 */var/log/auth.log* 文件中，因此让我们查看一些与这些
    `sudo` 命令相关的日志行。我已经挑选出了一些与本示例相关的日志行，以免你被日志解析的艺术所困扰。然而，你可以随时深入探索日志文件。
- en: 'The first line in *auth.log* you’ll look at pertains to *bender*’s use of `sudoedit`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *auth.log* 文件中，你将看到的第一行日志是关于 *bender* 使用 `sudoedit` 的：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This line provides quite a bit of information, but let’s focus on the `date/time`,
    `USER`, and `COMMAND` columns. You can see that *bender* invoked `sudo` on `July
    23` at `23:17:43`, using the `sudoedit /opt/engineering/greeting.py` command.
    This happened when you changed the *greeting.py* file to alter the greeting text.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这行日志提供了相当多的信息，但我们将重点关注 `date/time`、`USER` 和 `COMMAND` 列。你可以看到 *bender* 在 `7月23日`
    的 `23:17:43` 调用了 `sudo`，执行了 `sudoedit /opt/engineering/greeting.py` 命令。这是在你修改
    *greeting.py* 文件以更改问候文本时发生的。
- en: 'This log line shows when you used *bender* to stop the Greeting server:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这行日志显示了你使用 *bender* 停止 Greeting 服务器的操作：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: On `July 23` at `23:18:19`, *bender* used `sudo` to execute the `/bin/systemctl
    stop greeting` command as the *root* user.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`7月23日`的`23:18:19`，*bender*以*root*用户身份使用`sudo`执行了`/bin/systemctl stop greeting`命令。
- en: 'Finally, here is the log line showing *bender* starting the Greeting application:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是日志行，显示了*bender*启动了Greeting应用程序：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: On `July 23` at `23:18:39`, *bender* used `sudo` to execute the command `/bin/systemctl
    start greeting` as the *root* user.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`7月23日`的`23:18:39`，*bender*以*root*用户身份使用`sudo`执行了`/bin/systemctl start greeting`命令。
- en: 'So far, I have shown log entries that were successful and expected. The following
    line shows *bender* executing an unsuccessful command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经展示了成功且预期的日志条目。以下一行展示了*bender*执行失败的命令：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: On `July 23` at `23:25:14`, *bender* tried to run the `/usr/bin/tail /var/log/auth.log`
    command, and it was denied. These are the types of log lines you probably want
    to track in an alerting system, as this could be a bad actor trying to navigate
    a host.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`7月23日`的`23:25:14`，*bender*尝试运行`/usr/bin/tail /var/log/auth.log`命令，但被拒绝。这些可能是你希望在警报系统中追踪的日志行，因为这可能是一个恶意行为者试图在主机上进行导航。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored the importance of allowing users to run commands with
    elevated privileges. Using Ansible, the `sudo` command, and a *sudoers* file,
    you can restrict command access and log an audit trail for security. You also
    worked with some different Ansible modules like `template`, `systemd`, and `set_fact`,
    which allowed you to automate the installation of your web application and control
    its life cycle.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了允许用户以提升的权限运行命令的重要性。使用Ansible、`sudo`命令和*sudoers*文件，你可以限制命令访问并记录审计日志以确保安全。你还使用了不同的Ansible模块，如`template`、`systemd`和`set_fact`，这些模块使你能够自动化安装Web应用程序并控制其生命周期。
- en: In the next chapter, you’ll wrap up this section on provisioning and security.
    You’ll also use some provided Ansible tasks to secure the network and implement
    a firewall for the VM.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将总结这一节关于配置和安全性的内容。你还将使用一些提供的Ansible任务来保护网络并为虚拟机实现防火墙。
