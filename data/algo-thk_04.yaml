- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: ADVANCED MEMOIZATION AND DYNAMIC PROGRAMMING
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 高级记忆化与动态规划
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common01.jpg)'
- en: In this chapter, we’re going to continue with memoization and dynamic programming.
    You don’t need to read this chapter to continue through the book. But there’s
    more to learn if you’d like to deepen your understanding. We’ll see how to make
    a dynamic-programming problem easier through a change in perspective, work with
    more than two dimensions in our subproblem arrays, and stretch our skills to go
    beyond the “optimize the solution” problems we’ve seen thus far. We’ll also get
    a bit more practice with the fundamentals. You’ll be a dynamic-programming rock
    star after this.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续讨论记忆化与动态规划。你不需要阅读本章内容就能继续阅读本书。但如果你希望深入理解，还是可以从中学到更多内容。我们将看到如何通过改变视角使动态规划问题变得更容易，如何在子问题数组中处理超过二维的问题，并将技能拓展到超越我们至今所见的“优化解法”问题。我们还将进一步练习基础知识。通过本章，你将成为动态规划的高手。
- en: 'Problem 1: The Jumper'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 1：跳跃者
- en: We’ll start this chapter with a dynamic-programming problem that’s solvable
    using what we learned in [Chapter 3](ch03.xhtml). As in that chapter, we’ll be
    able to solve the problem by focusing on what the end of the optimal solution
    must look like. We’ll see, though, that this isn’t the only way to do it. In particular,
    we’ll see that we can instead focus not on the *end* of the optimal solution,
    but on its *beginning*. You may find this second approach more intuitive than
    the first, if not for this problem then perhaps for other problems. And once you
    learn this change in perspective, you’ll have two approaches to throw at your
    next dynamic-programming problem.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将从一个可以通过我们在[第 3 章](ch03.xhtml)学到的内容解决的动态规划问题开始。和第 3 章一样，我们能够通过关注最优解的结尾来解决问题。不过，我们会发现这并不是唯一的解法。具体来说，我们将看到，我们可以选择不关注最优解的*结尾*，而是关注它的*开头*。你可能会觉得这种第二种方法比第一种方法更直观，如果不是对这个问题，那么也许对其他问题来说更合适。一旦你学会了这种视角的转变，你将拥有两种方法来解决下一个动态规划问题。
- en: This is DMOJ problem `crci07p2`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题`crci07p2`。
- en: '*The Problem*'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: 'Nikola is playing a game on a row of *n* squares. The leftmost square is Square
    1 and the rightmost square is Square *n*. Nikola starts on Square 1 and wants
    to get to Square *n*. To do so, she makes one or more jumps. Her first jump is
    required to be from Square 1 to Square 2\. After that, the jumping rules are as
    follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尼古拉正在玩一个由 *n* 个方格组成的游戏。最左边的方格是方格 1，最右边的方格是方格 *n*。尼古拉从方格 1 开始，想要到达方格 *n*。为了实现这一目标，她需要进行一次或多次跳跃。她的第一次跳跃必须是从方格
    1 跳到方格 2。之后，跳跃规则如下：
- en: Nikola can jump to the right by exactly one more than the number of squares
    on her previous jump. For example, if Nikola jumped 3 squares on her previous
    jump, then she can jump to the right by 4 squares now.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尼古拉可以跳跃到右侧，跳跃的方格数比上一次跳跃多 1。例如，如果尼古拉上次跳了 3 个方格，那么她这次可以向右跳 4 个方格。
- en: Nikola can jump to the left by exactly the same number of squares as on her
    previous jump. For example, if Nikola jumped 3 squares on her previous jump, then
    she can jump 3 squares to the left now.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尼古拉可以跳跃到左侧，跳跃的方格数与上次跳跃相同。例如，如果尼古拉上次跳了 3 个方格，那么她这次可以向左跳 3 个方格。
- en: I’ll use the term *jump distance* to refer to the number of squares moved on
    a given jump.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用*跳跃距离*一词来指代某次跳跃中移动的方格数。
- en: The valid squares here are those from 1 to *n*. Therefore, if a jump would take
    Nikola to the left of square 1 or to the right of square *n*, that jump is not
    allowed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有效的方格是从 1 到 *n* 的方格。因此，如果一次跳跃将尼古拉带到方格 1 左侧或方格 *n* 右侧，那么该跳跃是不允许的。
- en: Each square has an entry cost. Whenever Nikola jumps, she pays the entry cost
    of the square in which she lands.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方格都有进入成本。每当尼古拉跳跃时，她需要支付她落脚的方格的进入成本。
- en: We want to determine the minimum total cost for Nikola to get from Square 1
    to Square *n*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要确定尼古拉从方格 1 跳跃到方格 *n* 的最小总成本。
- en: Input
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of the following lines:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含以下几行：
- en: A line containing *n*, the number of squares in the row. *n* is between 2 and
    1,000.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含 *n*，表示行中方格的数量。*n* 的值在 2 到 1,000 之间。
- en: '*n* lines, each giving the entry cost for a square. The first of these lines
    is the entry cost for Square 1, the second is the entry cost for Square 2, and
    so on. Each entry cost is an integer between 1 and 500.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行给出一个方格的进入成本。这些行的第一行是方格 1 的进入成本，第二行是方格 2 的进入成本，以此类推。每个进入成本是一个介于 1 到
    500 之间的整数。'
- en: Output
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: Output the minimum total cost for Nikola to get from Square 1 to Square *n*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 输出尼古拉从第1格到第*n*格的最小总成本。
- en: The time limit for solving the test case is 0.6 seconds.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制是0.6秒。
- en: '*Working Through an Example*'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*通过一个例子来推导*'
- en: 'Let’s work through one test case to make sure we know exactly what we are being
    asked to do. Here it is:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个测试用例来确保我们清楚自己需要做什么。这里是：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Nikola starts on Square 1 and has to get to Square 7\. Remembering that the
    first jump has to be to Square 2, here’s one possible route:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尼古拉从第1格开始，必须到达第7格。记住，第一次跳跃必须跳到第2格，以下是一条可能的路线：
- en: '**Square 1 to Square 2**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**第1格到第2格**'
- en: Cost 5.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 成本5。
- en: Most recent jump distance is now 1.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的跳跃距离现在是1。
- en: '**Square 2 to Square 4**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**第2格到第4格**'
- en: Cost 9.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 成本9。
- en: Most recent jump distance is now 2.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的跳跃距离现在是2。
- en: '**Square 4 to Square 7**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**第4格到第7格**'
- en: Cost 3.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 成本3。
- en: Most recent jump distance is now 3.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的跳跃距离现在是3。
- en: We made it to Square 7! The total cost is 5 + 9 + 3 = 17\. This is *not* the
    minimum total cost, though. Try to find it before continuing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到达了第7格！总成本是5 + 9 + 3 = 17。然而，这*不是*最小的总成本。试着在继续之前找到最小的成本。
- en: 'Here’s how we can get the minimum total cost:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何得到最小总成本的方法：
- en: '**Square 1 to Square 2**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**第1格到第2格**'
- en: Cost 5.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 成本5。
- en: Most recent jump distance is now 1.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的跳跃距离现在是1。
- en: '**Square 2 to Square 1**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**第2格到第1格**'
- en: Cost 3.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 成本3。
- en: Most recent jump distance remains 1.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的跳跃距离保持为1。
- en: '**Square 1 to Square 3**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**第1格到第3格**'
- en: Cost 1.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 成本1。
- en: Most recent jump distance is now 2.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的跳跃距离现在是2。
- en: '**Square 3 to Square 6**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3格到第6格**'
- en: Cost 2.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 成本2。
- en: Most recent jump distance is now 3.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的跳跃距离现在是3。
- en: '**Square 6 to Square 3**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**第6格到第3格**'
- en: Cost 1.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 成本1。
- en: Most recent jump distance remains 3.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的跳跃距离保持为3。
- en: '**Square 3 to Square 7**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3格到第7格**'
- en: Cost 3.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 成本3。
- en: Most recent jump distance is now 4.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的跳跃距离现在是4。
- en: The total cost this time is 5 + 3 + 1 + 2 + 1 + 3 = 15.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的总成本是5 + 3 + 1 + 2 + 1 + 3 = 15。
- en: '*Solution 1: Backward Formulation*'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解法1：逆向推导*'
- en: Before we can write any code, we need to settle on our subproblems and how to
    use these subproblems to characterize the structure of an optimal solution.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写任何代码之前，我们需要确定子问题，并了解如何利用这些子问题来表征最优解的结构。
- en: Finding the Subproblems
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 寻找子问题
- en: How many subproblem parameters do we need? Could we get away with just one?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要多少个子问题参数？我们能只用一个吗？
- en: If we have only one subproblem parameter, then we could use it to keep track
    of which square Nikola is on. But then how would we know which jumps were allowed
    for a given subproblem? Think about the end of an optimal solution for getting
    from Square 1 to Square 4\. To get closer to a base case, we’d need to know which
    square Nikola was on prior to Square 4 so that we could make a recursive call
    to that earlier square. For example, if we knew that Nikola used a jump distance
    of 2 to get to Square 4, then we would know that prior to Square 4 she must have
    been on Square 2 or Square 6\. But we don’t know the jump distance that Nikola
    used—it’s not one of our subproblem parameters. This isn’t going to work.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只有一个子问题参数，那么我们可以用它来跟踪尼古拉在哪一格。但那样的话，我们怎么知道给定子问题中哪些跳跃是允许的呢？想想从第1格到第4格的最优解结束时的情况。为了更接近基本情况，我们需要知道尼古拉在第4格之前在哪一格，这样我们才能递归调用到那个较早的格子。例如，如果我们知道尼古拉用了2的跳跃距离到达第4格，那么我们就知道她在到达第4格之前肯定是在第2格或第6格。但我们并不知道尼古拉使用的跳跃距离——它不是我们的子问题参数之一。这行不通。
- en: Let’s try one more time with just one subproblem parameter. What if we use it
    to keep track of the most recent jump distance? Well, then we won’t have a subproblem
    parameter available to tell us which square Nikola is on! And without knowing
    where Nikola is, we won’t have a way to know when we’ve reached the base case
    square.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再试一次，仅使用一个子问题参数。如果我们用它来跟踪最近的跳跃距离呢？那么我们就没有一个子问题参数来告诉我们尼古拉在哪一格！没有知道尼古拉在哪一格，我们就无法知道何时到达基本情况格。
- en: 'It looks like we need two subproblem parameters: one to tell us the square
    that Nikola is on and one to tell us the jump distance that she used to get to
    that square.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们需要两个子问题参数：一个告诉我们尼古拉在哪一格，另一个告诉我们她跳到那一格所用的跳跃距离。
- en: For each of these parameters, we need to decide whether to use “exactly.” In
    [Chapter 3](ch03.xhtml), we saw examples of using “exactly” subproblems when we
    solved Burger Fervor and Moneygrubbers. We also saw an example of *not* using
    “exactly” when we solved Hockey Rivalry. Had we used “exactly” in Hockey Rivalry,
    our subproblems would have forced specific games to be matched as rivalry games,
    which wasn’t needed for that problem.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些参数中的每一个，我们需要决定是否使用“确切”。在[第三章](ch03.xhtml)中，我们看到了在解决《汉堡狂热》和《贪婪者》时使用“确切”子问题的例子。我们还看到了在解决《冰球对抗赛》时*没有*使用“确切”的例子。如果我们在《冰球对抗赛》中使用了“确切”，我们的子问题就会强制特定的比赛被匹配为对抗赛，这在那个问题中是不需要的。
- en: Here, it makes sense that we’d want to know *exactly* which square Nikola is
    on. We could use that to figure out exactly which square she was on prior to the
    most recent jump . . . well, not quite. We’d also need to know *exactly* the jump
    distance that she used to get to the current square. We could then use both the
    current square and jump distance to figure out exactly where Nikola must have
    come from. That is, we need “exactly” for both subproblem parameters.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，知道尼古拉究竟在哪个方格是有意义的。我们可以利用这一点来确定她在最近一次跳跃之前究竟在哪个方格……嗯，不完全是。我们还需要知道她用来跳到当前方格的*确切*跳跃距离。然后我们可以通过当前方格和跳跃距离来精确推算出尼古拉一定是从哪个地方来的。也就是说，我们需要对这两个子问题的参数都要求“确切”。
- en: 'The problem description specifies that we have no choice for the first jump:
    it has to be from Square 1 to Square 2\. Instead of worrying about maintaining
    that condition in our subproblems, we’ll just ignore it: our subproblems will
    tell us the minimum cost to get from Square 2 to some other square. Later, we’ll
    add the cost of jumping from Square 1 to Square 2, and that’ll give us our final
    solution.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 问题描述规定，第一次跳跃没有选择：必须从方格1跳到方格2。我们不需要担心在子问题中维护这个条件，而是直接忽略它：我们的子问题将告诉我们从方格2跳到另一个方格的最小费用。稍后，我们会加上从方格1到方格2的跳跃费用，这样就能得到最终解答。
- en: We can’t use any old sequence of jumps from Square 2, though. Think about what
    would happen if our solution from Square 2 started with a jump of distance 3\.
    We need to jump from Square 1 to Square 2 first and, uh-oh, a jump distance of
    3 is not allowed to follow that! We need to ensure that our subproblems solve
    only for solutions that are feasible given that we’ll prepend the jump from Square
    1 to Square 2\. We’ll call such solutions *connectible*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能随便使用从方格2跳跃的任意顺序。想象一下，如果我们从方格2的解答开始，跳跃距离是3会发生什么？我们需要先从方格1跳到方格2，哦哦，跳跃距离为3是不允许紧随其后的！我们需要确保我们的子问题只求解那些可行的解，因为我们会将从方格1到方格2的跳跃放在前面。我们称这样的解答为*可连接的*。
- en: Okay, now we’re ready for the subproblems! The subproblem with parameters *i*
    and *j* will tell us the minimum cost of a connectible solution from Square 2
    to exactly Square *i* using a final jump distance of exactly *j*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们准备好解决子问题了！具有*i*和*j*参数的子问题将告诉我们，从方格2到*确切*的方格*i*，使用最终跳跃距离为*j*的可连接解答的最小费用。
- en: That subproblem definition is quite a mouthful. Let’s use the test case from
    the prior section to nail down a few examples of how the definition works.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子问题的定义相当复杂。让我们用上一节中的测试用例来确定几个关于定义如何工作的例子。
- en: What is the solution for the subproblem when *i* = 7 and *j* = 3? This is asking
    us for the best connectible solution that starts at Square 2, ends at Square 7,
    and has a final jump distance of 3\. The answer is 12, witnessed by Nikola jumping
    from Square 2 to Square 4 (cost 9), to Square 7 (cost 3). (Remember we’re ignoring
    the cost of jumping from Square 1 to Square 2 in these subproblems.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当*i* = 7，*j* = 3时，子问题的解是什么？这在问我们，从方格2开始，最终到达方格7，并且最后的跳跃距离是3的最佳可连接解答是什么？答案是12，尼古拉从方格2跳到方格4（费用9），再跳到方格7（费用3）。（记住，在这些子问题中，我们忽略了从方格1到方格2的跳跃费用。）
- en: 'What about the solution for the subproblem with *i* = 7 and *j* = 4? The answer
    is 10: Nikola can jump from Square 2 to Square 1 (cost 3), then to Square 3 (cost
    1), to Square 6 (cost 2), to Square 3 (cost 1), and finally to Square 7 (cost
    3).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，*i* = 7，*j* = 4的子问题解答是什么？答案是10：尼古拉可以先从方格2跳到方格1（费用3），再跳到方格3（费用1），跳到方格6（费用2），再跳回方格3（费用1），最后跳到方格7（费用3）。
- en: 'What about *i* = 7 and *j* = 2? Try it, and you should find that achieving
    this is impossible: there’s no way to find a connectible solution that gets from
    Square 2 to Square 7 with a final jump distance of 2.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么*i* = 7，*j* = 2呢？试试，你应该会发现这是不可能的：没有办法找到一个从方格2跳到方格7，并且最终跳跃距离为2的可连接解答。
- en: 'One more: *i* = 2 and *j* = 1\. We’re already at Square 2 here. Furthermore,
    *j* = 1 means that we need a jump of distance 1 to get us to Square 2\. No problem:
    the jump from square 1 to Square 2 that we’re going to prepend is exactly this
    kind of jump! The answer here is therefore 0\. Hmm, I think we may have just found
    a base case.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 再来一个：*i* = 2 和 *j* = 1。我们已经处在方格2了。此外，*j* = 1意味着我们需要一个距离为1的跳跃才能到达方格2。没问题：我们将在前面加上的从方格1到方格2的跳跃正是这种跳跃！因此，这里的答案是0。嗯，我想我们可能刚刚找到一个基础情况。
- en: Characterizing Optimal Solutions
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述最优解
- en: Consider a subproblem with some value of *i* and some value of *j*. What might
    the optimal solution look like for this subproblem?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个具有某个值*i*和某个值*j*的子问题。这个子问题的最优解可能是什么样子的？
- en: '**Option 1**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项1**'
- en: One option is that this optimal solution ends with a jump to the right. The
    *j* value gives us the distance of this jump, so we know that this jump must have
    been from Square *i* – *j*. In order to jump to the right by *j*, Nikola must
    have gotten to her previous square with a jump distance of *j* – 1\. (Why *j*
    – 1? Because a jump to the right is required to have a jump distance that’s one
    more than the jump distance of the previous jump.) So the solution for this option
    is the solution to the subproblem for Square *i* – *j* and jump distance *j* –
    1, plus the entry cost of Square *i*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选项是这个最优解以跳向右边结束。*j*值给出了这个跳跃的距离，所以我们知道这个跳跃一定是从方格*i* – *j*跳过来的。为了向右跳跃*j*，尼古拉必须已经通过跳跃距离*j*
    – 1到达了她之前的方格。（为什么是*j* – 1？因为向右跳跃需要的跳跃距离比前一次跳跃多1。）因此，这个选项的解决方案是方格*i* – *j*和跳跃距离*j*
    – 1的子问题的解决方案，再加上方格*i*的进入成本。
- en: 'Yikes—it can be confusing thinking about the solution backward like this! For
    example, we’re talking about jumping to the right, yet we’re using a Square *i*
    – *j* that’s to the left. But remember: we’re looking for the square that Nikola
    came from, so if she jumped to the right from that square, then she indeed came
    from a smaller-numbered square.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，像这样倒着思考解决方案可能会让人困惑！例如，我们正在讨论跳到右边，但我们却使用了一个位于左边的方格*i* – *j*。但记住：我们在寻找尼古拉从哪个方格跳过来的，所以如果她从那个方格跳到右边，那么她确实是从一个编号较小的方格跳过来的。
- en: '**Option 2**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项2**'
- en: Our second option is that this optimal solution ends with a jump to the left.
    The *j* value gives us the distance of this jump, so we know that this jump must
    have been from Square *i* + *j*. In order to jump to the left by *j*, Nikola must
    have gotten to her previous square with a jump distance of *j*. So the solution
    for this option is the solution to the subproblem for Square *i* + *j* and jump
    distance *j*, plus the entry cost of Square *i*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个选择是这个最优解以跳向左边结束。*j*值给出了这个跳跃的距离，所以我们知道这个跳跃一定是从方格*i* + *j*跳过来的。为了向左跳跃*j*，尼古拉必须已经通过跳跃距离*j*到达了她之前的方格。所以这个选项的解决方案是方格*i*
    + *j*和跳跃距离*j*的子问题的解决方案，再加上方格*i*的进入成本。
- en: Solving One Subproblem
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决一个子问题
- en: 'Let’s skip the bare recursive solution and work on a memoized solution. To
    do so, we’ll start by writing the code for the following `solve_ij` function signature:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跳过裸递归解决方案，改为处理一个带备忘录的解决方案。为此，我们将从编写以下`solve_ij`函数签名的代码开始：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This function solves the subproblem for the given values of `i` and `j`. Here’s
    what each parameter is for:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数解决给定的`i`和`j`值的子问题。以下是每个参数的作用：
- en: cost   The array of entry costs. The entry cost for Square 1 is `cost[1]`, the
    entry cost for Square 2 is `cost[2]`, and so on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: cost   进入成本数组。方格1的进入成本是`cost[1]`，方格2的进入成本是`cost[2]`，以此类推。
- en: n   The number of squares in the row.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: n   行中的方格数。
- en: i   The ending square for this subproblem.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: i   这个子问题的结束方格。
- en: j   The final jump distance for this subproblem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: j   这个子问题的最终跳跃距离。
- en: memo   The memoization array.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: memo   备忘录数组。
- en: The code for this function is given in [Listing 4-1](ch04.xhtml#ch04ex01).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的代码在[列表4-1](ch04.xhtml#ch04ex01)中给出。
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 4-1: Solving one subproblem*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表4-1：解决一个子问题*'
- en: As we did when solving Burger Fervor in [Chapter 3](ch03.xhtml), we use `-2`
    in the `memo` array ➊ to indicate that a subproblem hasn’t been solved yet. The
    typical value to use here would be `-1`, but we’ll use `-1` to indicate that we’ve
    already tried to solve a subproblem but that it has no solution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](ch03.xhtml)中解决“汉堡狂热”时所做的那样，我们在`memo`数组中使用`-2` ➊来表示一个子问题尚未解决。这里使用的典型值是`-1`，但我们将使用`-1`来表示我们已经尝试解决一个子问题，但它没有解决方案。
- en: 'As we discovered in the previous section, an important base case is when we’re
    on square 2 and need to get to that square with a jump of distance 1 ➋. In this
    case, we return `0`: there’s no cost to get from Square 2 to Square 2!'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中发现的，一个重要的基础情况是，当我们在方块2上，需要用距离为1的跳跃到达该方块 ➋。在这种情况下，我们返回`0`：从方块2到方块2没有任何成本！
- en: Next we try each of the two options for an optimal solution. We use the variable
    `first` to hold the value for Option 1 and `second` to hold the value for Option
    2.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们尝试两种选项以找到最佳解决方案。我们使用`first`变量来保存选项1的值，`second`变量来保存选项2的值。
- en: '**Option 1**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项 1**'
- en: This is the option where Nikola jumps to the right to get to Square `i`. To
    use this option, we need to ensure that Nikola would have come from a valid square.
    We also need to ensure that `j` is at least `2` ➌, which guarantees that she got
    to the previous square with a jump distance of at least 1\. After all, it wouldn’t
    make sense to say that Nikola got to a prior square using a jump of distance 0!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是尼古拉跳到右侧以到达方块`i`的选项。为了使用此选项，我们需要确保尼古拉来自一个有效的方块。我们还需要确保`j`至少为`2` ➌，这可以保证她是通过至少1的跳跃距离到达前一个方块的。毕竟，说尼古拉用0的跳跃距离到达一个先前的方块是没有意义的！
- en: '**Option 2**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项 2**'
- en: This is the option where Nikola jumps to the left to get to Square `i`. As in
    the previous option, we need to ensure that Nikola came from a valid square ➍.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是尼古拉跳到左侧以到达方块`i`的选项。与之前的选项一样，我们需要确保尼古拉来自一个有效的方块 ➍。
- en: It’s possible for one or both options to fail to find a solution; in those cases
    we use a value of `-1`. If both options fail, then we return `-1` ➎. The rest
    of the code determines which of the two options is best, and returns that plus
    `cost[i]` as the solution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个或两个选项可能无法找到解决方案；在这种情况下，我们使用`-1`的值。如果两个选项都失败，那么我们返回`-1` ➎。其余的代码决定哪个选项最好，并返回该选项加上`cost[i]`作为解决方案。
- en: Where’s the Optimal Solution?
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最优解在哪里？
- en: Now we can solve any subproblem we want. So, what call of `solve_ij` should
    we make to find the solution to the original problem?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以解决任何我们想要的子问题。那么，我们应该调用哪个`solve_ij`来找到原始问题的解决方案呢？
- en: 'Trick question: one call won’t be enough! We’re going to need to do some searching,
    much as we did when we solved Burger Fervor and Money-grubbers in [Chapter 3](ch03.xhtml).
    But why?'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 难题：一次调用不够！我们需要做一些搜索，就像我们在[第3章](ch03.xhtml)解决《汉堡热潮》和《钱袋贼》问题时一样。但为什么呢？
- en: We know for sure that we need to end exactly on Square *n*, so we don’t need
    any searching there. What we *don’t* know is the jump distance that we should
    have used as the final jump. Should we have ended with a jump distance of 2? 3?
    4? Who knows? We need to try them all and pick the best one. See [Listing 4-2](ch04.xhtml#ch04ex02)
    for the code to do this.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们必须精确地停在方块*n*上，所以我们不需要在这里做搜索。我们*不知道*的是我们应该用什么跳跃距离作为最后一跳。我们应该以2的跳跃距离结束吗？3？4？谁知道？我们需要尝试所有并选择最好的一个。有关代码，请参见[列表
    4-2](ch04.xhtml#ch04ex02)。
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 4-2: Solution 1*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-2：解决方案 1*'
- en: This function is where we set up the `memo` array ➊ so that it’s shared across
    all calls to `solve_ij`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是我们设置`memo`数组 ➊ 的地方，以便它在所有对`solve_ij`的调用之间共享。
- en: 'The `best` variable holds the best solution that we’ve found thus far. It begins
    at `-1` ➋ and is updated whenever we find a better solution ➍ ➎. Be careful: we
    need to add `cost[2]` here in order to reincorporate the jump from Square 1 to
    Square 2.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`best`变量保存我们迄今为止找到的最佳解决方案。它从`-1` ➋ 开始，每当我们找到更好的解决方案时，就会更新 ➍ ➎。小心：我们需要在这里添加`cost[2]`，以重新计算从方块1到方块2的跳跃。'
- en: Notice that we’re looping through the final jump distances between `1` and `n`
    ➌. There’s no point trying any final distance larger than `n` because they can’t
    lead to a valid square. That is, we’re guaranteed to find the best final jump
    distance because we’re trying all of the valid possibilities.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在循环遍历`1`到`n`之间的最终跳跃距离 ➌。没有必要尝试任何大于`n`的最终距离，因为它们无法到达有效的方块。也就是说，我们保证找到最佳的最终跳跃距离，因为我们正在尝试所有有效的可能性。
- en: The main Function
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主要函数
- en: It’s time to wrap up this solution. All we need is a `main` function to read
    the input and call `solve`. The code is in [Listing 4-3](ch04.xhtml#ch04ex03).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候总结这个解决方案了。我们只需要一个`main`函数来读取输入并调用`solve`。代码见[列表 4-3](ch04.xhtml#ch04ex03)。
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 4-3: The* main *function*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-3：* 主要 *函数*'
- en: If you submit our code to the judge, you should pass all test cases within the
    time limit.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将我们的代码提交给评审，你应该能够在时间限制内通过所有测试用例。
- en: But we can still do better.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然可以做得更好。
- en: '*Solution 2: Forward Formulation*'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决方案 2：前向公式化*'
- en: Let’s first talk about why Solution 1 is fast, and then discuss why we can still
    improve it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先来谈谈为什么解决方案1很快，然后再讨论为什么我们仍然可以改进它。
- en: How Fast is Solution 1?
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案1有多快？
- en: Solution 1 is an *O*(*n*²) algorithm. It’d be easier to see that from a bottom-up
    dynamic-programming solution, with its telltale two nested loops, but we can still
    make an argument using our memoized solution. Our `solve_ij` function ([Listing
    4-1](ch04.xhtml#ch04ex01)) fills in each of the *n*² elements of `memo` at most
    once. To fill in each such element, our code makes two recursive calls. We can
    therefore say that our code makes at most 2*n*² recursive calls. Beyond that,
    each recursive call of `solve_ij` performs a constant number of steps to decide
    whether to use `first` or `second` in the optimal solution. So `solve_ij` takes
    *O*(*n*²) time throughout all recursive calls.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案1是一个 *O*( *n*²) 算法。从自底向上的动态规划解法中，我们可以更容易看到这一点，里面有明显的两个嵌套循环，但我们仍然可以使用备忘录解法来说明这一点。我们的
    `solve_ij` 函数（见 [Listing 4-1](ch04.xhtml#ch04ex01)）最多填充 `memo` 中的每个 *n*² 元素一次。为了填充每个元素，我们的代码会做两次递归调用。因此，我们可以说我们的代码最多做
    2*n*² 次递归调用。除此之外，`solve_ij` 的每次递归调用会执行一个常数步骤来决定是使用 `first` 还是 `second` 作为最优解的一部分。因此，`solve_ij`
    在所有递归调用中都需要 *O*( *n*²) 的时间。
- en: The maximum number of squares in a row is 1,000\. Our *O*(*n*²) algorithm is
    therefore performing something like 1,000² = 1,000,000 steps. We can do that easily
    within our 0.6-second time limit.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一排格子的最大数量是1,000。我们的 *O*( *n*²) 算法因此大致执行了 1,000² = 1,000,000 步。在0.6秒的时间限制内我们可以轻松完成。
- en: All right, so Solution 1 is fast. What could we possibly want to improve, then?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么解决方案1很快。那么我们还可以改进什么呢？
- en: Backward vs. Forward
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 反向 vs. 正向
- en: Perhaps you’ve been bothered by an incongruity between the way that Nikola’s
    jumps are described in the problem description and the way that we thought about
    jumps in our memoized solution. The problem description tells us what Nikola can
    do on each jump starting from the first jump. That is, it focuses on where Nikola
    is right now and what she can do next. Our memoized solution, by contrast, focuses
    on where Nikola got to and how she got there. For example, rather than thinking,
    “Nikola jumped from Square 2 to Square 4,” we have to think, “Nikola got to Square
    4 by jumping from Square 2.” We have to think about the problem backward!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你一直被问题描述中尼古拉的跳跃方式与我们在备忘录解法中思考跳跃的方式之间的不一致所困扰。问题描述告诉我们尼古拉从第一跳开始每次跳跃时能做什么。也就是说，它关注的是尼古拉现在在哪里以及她接下来能做什么。相比之下，我们的备忘录解法关注的是尼古拉到达了哪里，以及她是如何到达那里的。例如，我们不是想着“尼古拉从第2格跳到第4格”，而是要想着“尼古拉通过从第2格跳跃到第4格达到了第4格”。我们必须从问题的反向思考！
- en: 'In addition to those extra mental gymnastics, our backward formulation has
    a consequence on the amount of code we have to write as well. Remember how we
    had to search through all possible final jump distances in [Listing 4-2](ch04.xhtml#ch04ex02)?
    The reason we needed that is because we don’t know how the optimal solution ends.
    Maybe it ends with a jump distance of 2, or a jump distance of 3, or a jump distance
    of 4, and so on. But we *do* know exactly how it begins: with a jump distance
    of 1 from Square 1 to Square 2! As long as we keep track of the most recent jump
    distance, we’ll never have to guess what it might be. That is, if we solve the
    problem forward (keeping track of where we are) rather than backward (keeping
    track of where we ended up), we’ll be able to entirely avoid the jump-distance
    search. We’ll get to the end of the optimal solution with whatever we need the
    final jump distance to be.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些额外的思维挑战之外，我们的反向表达方式还对我们需要编写的代码量产生了影响。还记得我们在 [Listing 4-2](ch04.xhtml#ch04ex02)
    中需要搜索所有可能的最终跳跃距离吗？之所以需要这样做，是因为我们不知道最优解是如何结束的。也许它以跳跃距离2结束，或者以跳跃距离3结束，或者以跳跃距离4结束，依此类推。但我们*确实*知道它是如何开始的：从第1格到第2格，跳跃距离是1！只要我们跟踪最近的跳跃距离，我们就永远不需要猜测它可能是什么。也就是说，如果我们从正向解决问题（关注我们现在的位置），而不是从反向解决问题（关注我们最终的位置），我们将能够完全避免跳跃距离的搜索。我们将能够到达最优解的终点，正好需要我们想要的最终跳跃距离。
- en: Finding the Subproblems, Again
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 再次寻找子问题
- en: We’ll stick with our earlier idea of using two subproblem parameters. That’s
    because we need one to tell us the square that Nikola is on and one to tell us
    the jump distance that she used to get to that square.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将坚持使用之前的两个子问题参数的思路。因为我们需要一个参数告诉我们尼古拉所在的格子，另一个参数告诉我们她用来到达该格子的跳跃距离。
- en: This time, the subproblem with parameters *i* and *j* is going to tell us the
    minimum cost of a solution from exactly Square *i* to Square *n* given that Square
    *i* was reached with a jump distance of exactly *j*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，参数 *i* 和 *j* 的子问题将告诉我们从方格 *i* 到方格 *n* 的最小成本解，前提是方格 *i* 是通过跳跃距离正好为 *j* 到达的。
- en: We need some examples of this! We’ll again use the test case from “Working Through
    an Example” on [page 127](ch04.xhtml#sec58).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些例子来说明！我们将再次使用在 [第 127 页](ch04.xhtml#sec58) 中的“通过实例演示”的测试用例。
- en: 'Let’s start with the subproblem with *i* = 2 and *j* = 1\. This is asking us
    for the best solution that starts at Square 2, ends at Square 7, and got to Square
    2 using a jump distance of 1\. (Notice that we don’t care at all about the jump
    distance that ultimately takes us to Square *n*. It could be anything!) The answer
    here is 10: Nikola can jump from Square 2 to Square 1 (cost 3), to Square 3 (cost
    1), to Square 6 (cost 2), to Square 3 (cost 1), to Square 7 (cost 3). Hey, that’s
    the same answer as for the *i* = 7, *j* = 4 subproblem from the backward formulation!
    But in the backward formulation, we would have to try all final jump distances
    to confirm that this is the optimal one. No longer.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从子问题 *i* = 2 和 *j* = 1 开始。这是在询问我们从方格 2 出发，最终到达方格 7，并且通过跳跃距离 1 到达方格 2 的最佳解。（请注意，我们完全不关心最终带我们到方格
    *n* 的跳跃距离，它可以是任何值！）这里的答案是 10：尼古拉可以从方格 2 跳到方格 1（花费 3），然后跳到方格 3（花费 1），再跳到方格 6（花费
    2），然后跳到方格 3（花费 1），最后跳到方格 7（花费 3）。嘿，这和从反向推导得到的 *i* = 7, *j* = 4 子问题的答案是一样的！但是在反向推导中，我们必须尝试所有可能的最终跳跃距离，以确认这是最优的，而现在不再需要了。
- en: 'Now think about any subproblem with *i* = *n*. What’s the answer? It’s 0: we’re
    already on square *n*! We don’t care what *j* is, because we don’t care how we
    got to Square *n*. We’ve found our base case again.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑任何 *i* = *n* 的子问题。答案是什么？是 0：我们已经在方格 *n* 上了！我们不关心 *j* 是什么，因为我们不在乎是如何到达方格
    *n* 的。我们又找到了基础情况。
- en: Characterizing Optimal Solutions, Again
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 再次描述最优解
- en: We need to redo our optimal substructure work from Solution 1.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重新做一下优化子结构的工作，参见解决方案 1。
- en: '**Option 1**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项 1**'
- en: One option is that Nikola next makes a jump to the right. The *j* value gives
    us the jump distance to the current square. The jump to the right will have distance
    *j* + 1, and Nikola will therefore land on Square *i* + *j* + 1\. So the solution
    for this option is the entry cost of Square *i* + *j* + 1, plus the solution to
    the subproblem for Square *i* + *j* + 1 and jump distance *j* + 1.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是尼古拉接着向右跳跃。*j* 值给出了当前方格的跳跃距离。向右跳跃的距离是 *j* + 1，因此尼古拉将着陆在方格 *i* + *j* + 1。此选项的解决方案是方格
    *i* + *j* + 1 的进入成本，再加上方格 *i* + *j* + 1 和跳跃距离 *j* + 1 的子问题的解。
- en: '**Option 2**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项 2**'
- en: Our second option is that Nikola next makes a jump to the left. That jump to
    the left will have distance *j*, and Nikola will therefore land on Square *i*–*j*.
    So the solution for this option is the entry cost of Square *i*–*j*, plus the
    solution to the subproblem for Square *i* – *j* and jump distance *j*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二种选择是尼古拉接着向左跳跃。向左跳跃的距离是 *j*，因此尼古拉将着陆在方格 *i*–*j*。因此，此选项的解决方案是方格 *i*–*j* 的进入成本，再加上方格
    *i*–*j* 和跳跃距离 *j* 的子问题的解。
- en: Solving the Needed Subproblem
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 求解所需的子问题
- en: Now we can write a `solve` function that solves a subproblem of our choice.
    See [Listing 4-4](ch04.xhtml#ch04ex04) for the code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个 `solve` 函数来解决我们选择的子问题。查看 [列表 4-4](ch04.xhtml#ch04ex04) 中的代码。
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 4-4: Solution 2*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-4：解决方案 2*'
- en: As in our backward formulation ([Listing 4-1](ch04.xhtml#ch04ex01)), we need
    to implement each of the two options for an optimal solution. In each case, we
    first check that the next square is a valid square ❶ ➋ prior to considering the
    jump.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在反向推导中（参见 [列表 4-1](ch04.xhtml#ch04ex01)），我们需要实现最优解的两种选项。在每种情况下，我们首先检查下一个方格是否是有效的方格
    ❶ ➋，然后再考虑跳跃。
- en: The main Function
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主函数
- en: What call of `solve` should we make in order to find the solution to the original
    problem?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到原问题的解，我们应该调用 `solve` 函数吗？
- en: That’s not a trick question this time—we know exactly which subproblem we need
    to solve! We need to solve the subproblem with *i* = 2 (starting on square 2)
    and *j* = 1 (getting to square 2 with a jump of distance 1). We can incorporate
    this in our `main` function that reads the input. Check out the code in [Listing
    4-5](ch04.xhtml#ch04ex05).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这次不是一个技巧性问题——我们完全知道需要解决哪个子问题！我们需要解决 *i* = 2（从方格 2 开始）和 *j* = 1（通过跳跃距离 1 到达方格
    2）的子问题。我们可以在读取输入的 `main` 函数中包含这一部分。查看 [列表 4-5](ch04.xhtml#ch04ex05) 中的代码。
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 4-5: The* main *function*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-5：* 主 *函数*'
- en: For this problem, I prefer the forward solution, but you may instead prefer
    the backward solution—it’s an individual choice!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，我更喜欢使用前向解法，但你也可以选择反向解法——这是个人的选择！
- en: When I’m working on a memoization or dynamic-programming solution, I always
    start by trying to formulate a backward solution. Backward solutions often feel
    more natural to me because they more closely model the way that I think about
    recursion. If I get stuck for too long, though, or when there’s friction between
    the forward nature of the problem description and the backward formulation, I’ll
    give it a whirl with a forward solution. Keep both of these complementary approaches
    in your dynamic-programming toolbox!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在做备忘录法或动态规划解法时，我总是从尝试制定反向解法开始。反向解法对我来说通常更自然，因为它更贴近我对递归的思考方式。然而，如果我卡住太久，或者当问题的前向描述与反向表述之间产生摩擦时，我会尝试使用前向解法。把这两种互补的方法都放在你的动态规划工具箱里！
- en: What About Dynamic Programming?
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动态规划怎么回事？
- en: We have a perfectly good forward memoized solution for this problem. Still,
    you might want to develop a dynamic-programming solution. If you do, there’s a
    bit of a surprise waiting in there!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了一个非常好的前向备忘录解法。尽管如此，你可能还是想开发一个动态规划解法。如果你这么做，里面会有一些惊喜等着你！
- en: 'Think back to how we solved Hockey Rivalry in [Chapter 3](ch03.xhtml) with
    dynamic programming. In “Solution 3: Dynamic Programming” on [page 119](ch03.xhtml#sec55),
    we learned that we need to figure out the order in which to solve the subproblems.
    In Hockey Rivalry, we did this by solving all of the subproblems in row 0 from
    left to right, then all of the subproblems in row 1 from left to right, and so
    on.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 想回我们如何在[第3章](ch03.xhtml)中使用动态规划解决《冰球对抗》。在[第119页](ch03.xhtml#sec55)的“解决方案3：动态规划”中，我们学到了解决子问题的顺序。在《冰球对抗》中，我们通过从左到右解决第0行的所有子问题，再从左到右解决第1行的所有子问题，依此类推，来确定了解决子问题的顺序。
- en: But that order won’t work for us now.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个顺序现在对我们不起作用。
- en: What do we need in order to solve `dp[i][j]`? From Option 1, we need to have
    already solved `dp[i + j + 1][j + 1]`; that is, we need something from a higher-numbered
    column. From Option 2, we need to have already solved `dp[i - j][j]`; that is,
    we need something from a lower-numbered row in the current column. Taken together,
    we need to solve all of the subproblems in column `n`, then all of the subproblems
    in column `n - 1`, and so on. And within each column, we need to solve the subproblem
    in row 1, then row 2, and so on.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决`dp[i][j]`，我们需要什么？从选项1来看，我们需要已经解决了`dp[i + j + 1][j + 1]`；也就是说，我们需要来自更高编号列的某些内容。从选项2来看，我们需要已经解决了`dp[i
    - j][j]`；也就是说，我们需要来自当前列较低编号行的某些内容。综合来看，我们需要先解决第`n`列的所有子问题，然后解决第`n-1`列的所有子问题，依此类推。在每一列内部，我们需要先解决第1行的子问题，然后是第2行，依此类推。
- en: 'Here’s the double `for` loop that we can use to solve the subproblems in the
    right order:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以用来按正确顺序解决子问题的双重`for`循环：
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Always be careful with the order that you solve the subproblems!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 解决子问题时，永远要小心顺序！
- en: If you’d like to see the full dynamic-programming solution, please check the
    online resources for this book. Otherwise, we’re ready to continue here with another
    dynamic-programming problem. A real doozy. You’re so ready for this.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到完整的动态规划解法，请查看本书的在线资源。否则，我们准备继续在这里解决另一个动态规划问题。一个真正棘手的题目，你已经准备好迎接它了。
- en: 'Problem 2: Ways to Build'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题2：构建方式
- en: 'The four dynamic-programming problems that we’ve solved so far (three in [Chapter
    3](ch03.xhtml) and one in this chapter) asked us to maximize (Burger Fervor and
    Hockey Rivalry) or minimize (Moneygrubbers and The Jumper) the value of a solution.
    I’d like to end this chapter with a problem of a slightly different flavor: rather
    than find an optimal solution, we’ll count the number of possible solutions.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们解决的四个动态规划问题（在[第3章](ch03.xhtml)中的三个和本章中的一个）要求我们最大化（《汉堡热情》和《冰球对抗》）或最小化（《钱财贪婪者》和《跳跃者》）解的值。我想以一个稍有不同口味的问题结束本章：我们不再寻找最佳解，而是计算可能解的数量。
- en: One other difference that will arise is in the number of dimensions of our subproblem
    array. In the four earlier problems, we used a one- or two-dimensional array of
    subproblem solutions. We’re going to need more dimensions than that to solve this
    one.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个出现的差异是我们子问题数组的维度数。在前四个问题中，我们使用了一维或二维数组来存储子问题的解。为了这个问题，我们需要更多的维度。
- en: This is DMOJ problem `noip15p5`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`noip15p5`。
- en: '*The Problem*'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: We’re given a source string *a*, a target string *b*, and an integer *k*. We
    want to build *b* from *a* by putting together *k* substrings of *a*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给定了一个源字符串 *a*，一个目标字符串 *b*，以及一个整数 *k*。我们希望通过将 *a* 的 *k* 个子字符串拼接在一起，来构建 *b*。
- en: 'There are some rules that we need to follow:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要遵循一些规则：
- en: We have to use the substrings of *a* in the same order that they occur in *a*.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须按照它们在 *a* 中出现的顺序来使用 *a* 的子字符串。
- en: We’re not allowed to use any empty substrings—each one has to have at least
    one character.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不允许使用任何空子字符串——每个子字符串必须至少包含一个字符。
- en: 'We’re not allowed to use substrings that overlap: if we use some character
    from *a* in one of our substrings, then we are not allowed to use that character
    in some other substring.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不允许使用重叠的子字符串：如果我们在一个子字符串中使用了 *a* 中的某个字符，那么我们不能在其他子字符串中再次使用该字符。
- en: We have to use exactly *k* substrings of *a* to build *b*.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须使用 *a* 中恰好 *k* 个子字符串来构建 *b*。
- en: For example, let’s say that *a* is `xxyzxyz`, *b* is `xxyz`, and *k* is `3`.
    One way to build *b* by putting together three substrings of *a* is to take the
    `x` from the beginning of *a*, the `xy` to the right of that, and the `z` from
    the end of *a*. Putting those substrings together gives us `xxyz`, exactly the
    string *b* that we need.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设 *a* 是 `xxyzxyz`，*b* 是 `xxyz`，*k* 是 `3`。一种通过拼接 *a* 的三个子字符串来构建 *b* 的方法是从
    *a* 开头取 `x`，然后取右边的 `xy`，最后从 *a* 末尾取 `z`。将这些子字符串拼接在一起，我们得到了 `xxyz`，正好是我们需要的字符串
    *b*。
- en: Now, there may be many different ways to build *b* from *a*. But notice that
    as long as we follow the rules it doesn’t matter how we build *b*—each way is
    just as good as the others. It therefore doesn’t make sense to talk about the
    optimal way to build *b*. What we’re asked to determine for this problem, then,
    is not the best way to build *b*, but the total number of ways that we can build
    *b*. In the previous example, there are 11 ways. Can you find them all?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从 *a* 中构建 *b* 的方法可能有很多种。但要注意，只要我们遵守规则，构建 *b* 的方式并不重要——每种方式都是一样好的。因此，讨论构建
    *b* 的最佳方式没有意义。那么，我们要在本问题中解决的，并不是构建 *b* 的最佳方式，而是可以构建 *b* 的总方式数量。在上面的示例中，有 11 种方法。你能找到它们全部吗？
- en: Input
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input contains one test case, the information for which is spread over
    three lines as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一个测试用例，其信息分布在以下三行中：
- en: 'The first line contains three numbers: the length of String *a*, the length
    of String *b*, and the integer *k* giving the number of substrings that we must
    take from *a* to build *b*. The length of String *a* is between 1 and 1,000, the
    length of String *b* is between 1 and 200, and *k* is between 0 and 200.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行包含三个数字：字符串 *a* 的长度，字符串 *b* 的长度，以及整数 *k*，它表示我们必须从 *a* 中取出 *k* 个子字符串来构建 *b*。字符串
    *a* 的长度在 1 到 1,000 之间，字符串 *b* 的长度在 1 到 200 之间，*k* 的值在 0 到 200 之间。
- en: The second line contains the String *a*.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行包含字符串 *a*。
- en: The third line contains the String *b*.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行包含字符串 *b*。
- en: Output
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: Output the number of ways we can build *b* using exactly *k* substrings of *a*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输出我们可以使用 *a* 中恰好 *k* 个子字符串来构建 *b* 的方式数量。
- en: This number may be huge. To spare us from integer overflow worries, the problem
    specifies that we output this number mod 1,000,000,007.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字可能非常大。为了避免整数溢出的情况，问题要求我们输出这个数字对 1,000,000,007 取模后的结果。
- en: The time limit for solving the test case is two seconds.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 解决该测试用例的时间限制是两秒。
- en: '*Working Through an Example*'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*通过一个示例进行演示*'
- en: Were you able to find all 11 ways to build *b* for the example that I gave in
    the problem description? Let’s make sure you have them all, as we’ll be using
    this as a running example for this problem.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你能找到我在问题描述中给出的示例中构建 *b* 的所有 11 种方式吗？让我们确保你找到了所有方式，因为我们将以这个作为本问题的示例来进行分析。
- en: 'Here is the example in the form of a test case:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是以测试用例形式给出的示例：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For quick reference, here are the indices for the characters of *a*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 方便参考，以下是字符串 *a* 中字符的索引：
- en: '![Image](../images/unch04fig01.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/unch04fig01.jpg)'
- en: How can we build `xxyz` from `xxyzxyz` using exactly three substrings? In the
    following, I’ll indicate each substring of *a* using a range of indices; for example,
    0-0 refers to the substring of *a* that consists of the character at index 0,
    and 1-2 refers to the substring of *a* consisting of the characters at indices
    1 and 2.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用恰好三个子字符串从 `xxyzxyz` 构建出 `xxyz` 呢？在下面，我将用索引范围表示每个子字符串；例如，0-0 指的是 *a* 中索引为
    0 的字符组成的子字符串，而 1-2 指的是 *a* 中索引为 1 和 2 的字符组成的子字符串。
- en: 'Here are five ways to do it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是五种做法：
- en: 0-1 (`xx`), 5-5 (`y`), 6-6 (`z`)
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-1 (`xx`)，5-5 (`y`)，6-6 (`z`)
- en: 1-1 (`x`), 4-5 (`xy`), 6-6 (`z`)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1-1 (`x`)，4-5 (`xy`)，6-6 (`z`)
- en: 0-0 (`x`), 4-5 (`xy`), 6-6 (`z`)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-0 (`x`), 4-5 (`xy`), 6-6 (`z`)
- en: 0-1 (`xx`), 2-2 (`y`), 6-6 (`z`)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-1 (`xx`), 2-2 (`y`), 6-6 (`z`)
- en: 0-0 (`x`), 1-2 (`xy`), 6-6 (`z`)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-0 (`x`), 1-2 (`xy`), 6-6 (`z`)
- en: Notice in each of these ways that our final substring is the final character
    *z* from *a*. That is, we’ve fixed the final substring to be that `z` and then
    searched for ways to take two substrings from `xxyzxy` to build `xxy`. We are
    starting to see how we can find solutions to the initial problem by finding solutions
    to smaller subproblems.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这些情况下，我们的最终子字符串是来自 *a* 的最后一个字符 *z*。也就是说，我们已经将最终的子字符串固定为那个 `z`，然后从 `xxyzxy`
    中寻找构建 `xxy` 的方式。我们开始看到通过解决更小的子问题来找到初始问题的解决方法。
- en: 'There are six remaining ways. Let’s get those down:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 还有六种可能的方式。我们把它们列出来：
- en: 1-1 (`x`), 4-4 (`x`), 5-6 (`yz`)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1-1 (`x`), 4-4 (`x`), 5-6 (`yz`)
- en: 0-0 (`x`), 4-4 (`x`), 5-6 (`yz`)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-0 (`x`), 4-4 (`x`), 5-6 (`yz`)
- en: 0-0 (`x`), 1-1 (`x`), 5-6 (`yz`)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-0 (`x`), 1-1 (`x`), 5-6 (`yz`)
- en: 0-1 (`xx`), 2-2 (`y`), 3-3 (`z`)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-1 (`xx`), 2-2 (`y`), 3-3 (`z`)
- en: 0-0 (`x`), 1-2 (`xy`), 3-3 (`z`)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-0 (`x`), 1-2 (`xy`), 3-3 (`z`)
- en: 0-0 (`x`), 1-1 (`x`), 2-3 (`yz`)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-0 (`x`), 1-1 (`x`), 2-3 (`yz`)
- en: Adding up the five ways from before, we now have a total of 5 + 6 = 11 ways
    to solve the problem.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 加上之前的五种方式，我们现在一共有 5 + 6 = 11 种解决方案。
- en: '*Solution 1: Using “Exactly” Subproblems*'
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解法 1：使用“准确的”子问题*'
- en: We need to identify our subproblems and then use them to find all optimal solutions.
    We’ll try for a backward formulation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要识别出我们的子问题，然后利用它们找到所有最优解。我们将尝试采用反向公式。
- en: Finding the Subproblems
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 寻找子问题
- en: How many subproblem parameters will we need this time?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们需要多少个子问题参数？
- en: We need to keep track of where we are in String *a* and keep track of where
    we are in String *b*. That’s a good start, but it isn’t quite enough. We also
    need a subproblem parameter to tell us how many more substrings to take. For the
    first time, we’re going to use three subproblem parameters!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要跟踪我们在字符串 *a* 中的位置，并且需要跟踪我们在字符串 *b* 中的位置。这个是一个不错的开始，但还不够。我们还需要一个子问题参数来告诉我们还需要提取多少个子字符串。这是我们第一次使用三个子问题参数！
- en: We did well using “exactly” subproblem parameters when we solved The Jumper
    earlier in this chapter. As usual, we need to decide whether to use it for each
    of our subproblem parameters here. It makes sense to use “exactly” for the parameter
    that tracks how many more substrings to take, because we need to use exactly that
    number of substrings (not, for instance, at most that number of substrings). It’s
    less clear what to do for the subproblem parameters that keep track of where we
    are in *a* and where we are in *b*. Let’s just start with “exactly” parameters
    for those, too, and see what happens. In what follows, we’ll use the notation
    *s*[*i*..*j*] to refer to the characters from index *i* up to and including index
    *j* of String *s*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面我们解决“跳跃者”问题时，使用了“准确的”子问题参数，效果不错。像往常一样，我们需要决定是否对每个子问题参数使用这个方法。对于记录还需要提取多少个子字符串的参数，使用“准确的”是有意义的，因为我们需要正好提取这么多个子字符串（而不是例如提取最多这么多的子字符串）。对于那些记录我们在
    *a* 和 *b* 中当前所在位置的子问题参数，使用“准确的”就不那么明确了。我们就先对这些参数也使用“准确的”，然后看看结果如何。接下来，我们将使用符号
    *s*[*i*..*j*] 来表示从字符串 *s* 的索引 *i* 到索引 *j*（包括 *j*）的字符。
- en: The subproblem with parameters *i*, *j*, and *k* is going to tell us the number
    of ways that we can choose exactly *k* substrings from *a*[0..*i*] to build exactly
    *b*[0..*j*], with the restriction that the rightmost substring ends with exactly
    the character *a*[*i*].
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 具有参数 *i*、*j* 和 *k* 的子问题将告诉我们从 *a*[0..*i*] 中正好选择 *k* 个子字符串来构建正好是 *b*[0..*j*]
    的方法数，并且要求右边的子字符串必须恰好以字符 *a*[*i*] 结尾。
- en: Let’s return to our running example to clarify how these subproblems work. What’s
    our answer for the subproblem with *i* = 6, *j* = 3, and *k* = 3? (Don’t answer
    “11” too quickly!)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的例子，以便更清楚地说明这些子问题如何工作。对于 *i* = 6，*j* = 3，*k* = 3 的子问题，我们的答案是什么？（不要太快回答“11”！）
- en: Since *a*[0..6] is all of *a*, and *b*[0..3] is all of *b*, this subproblem
    is asking about the full *a* and *b* strings. So we’re looking for all ways to
    choose exactly three substrings from *a* to build *b*, with the restriction that
    the rightmost substring ends with exactly the `z` at *a*[6].
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *a*[0..6] 是整个 *a*，而 *b*[0..3] 是整个 *b*，这个子问题是在询问整个 *a* 和 *b* 字符串的情况。所以我们在寻找从
    *a* 中选择正好三个子字符串来构建 *b* 的所有方法，且要求右边的子字符串必须恰好以 *a*[6] 中的 `z` 结尾。
- en: 'The answer is 8! Here they are—the first five are the ones that use the final
    `z` in *a* as its own substring, and the remaining three use the final `yz` in
    *a* as its own substring:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 8！这些就是——前五个是使用 *a* 中的最终 `z` 作为其自身子字符串的，而剩下的三个则使用 *a* 中的最终 `yz` 作为其自身子字符串：
- en: 0-1 (`xx`), 5-5 (`y`), 6-6 (`z`)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-1 (`xx`)、5-5 (`y`)、6-6 (`z`)
- en: 1-1 (`x`), 4-5 (`xy`), 6-6 (`z`)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1-1 (`x`)、4-5 (`xy`)、6-6 (`z`)
- en: 0-0 (`x`), 4-5 (`xy`), 6-6 (`z`)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-0 (`x`)、4-5 (`xy`)、6-6 (`z`)
- en: 0-1 (`xx`), 2-2 (`y`), 6-6 (`z`)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-1 (`xx`)、2-2 (`y`)、6-6 (`z`)
- en: 0-0 (`x`), 1-2 (`xy`), 6-6 (`z`)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-0 (`x`)、1-2 (`xy`)、6-6 (`z`)
- en: 1-1 (`x`), 4-4 (`x`), 5-6 (`yz`)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1-1 (`x`)、4-4 (`x`)、5-6 (`yz`)
- en: 0-0 (`x`), 4-4 (`x`), 5-6 (`yz`)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-0 (`x`)、4-4 (`x`)、5-6 (`yz`)
- en: 0-0 (`x`), 1-1 (`x`), 5-6 (`yz`)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-0 (`x`)、1-1 (`x`)、5-6 (`yz`)
- en: But why can’t we include the missing solutions, like 0-1 (`xx`), 2-2 (`y`),
    3-3 (`z`)? Shouldn’t those count?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么我们不能包括缺失的解法，比如 0-1 (`xx`)、2-2 (`y`)、3-3 (`z`)? 难道这些不应该算吗？
- en: The reason we can’t use them here is because they don’t use that final `z` at
    *a*[6]. They don’t satisfy the requirements of the type of “exactly” subproblem
    that we’re using.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不能使用它们的原因是它们没有使用 *a*[6] 中的最终 `z`。它们不满足我们所使用的“精确”子问题的要求。
- en: 'That said, we have eight ways so far, and we do need to get to 11\. Looking
    at the *i* = 6, *j* = 3, *k* = 3 subproblem therefore isn’t enough. We can find
    the three missing ways by looking at the subproblem *i* = 3, *j* = 3, *k* = 3\.
    Those ways are as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，到目前为止我们已经有了八种方法，我们确实需要得到 11 种。仅仅看 *i* = 6、*j* = 3、*k* = 3 的子问题是不够的。我们可以通过查看
    *i* = 3、*j* = 3、*k* = 3 的子问题来找到剩下的三种方法。这些方法如下：
- en: 0-1 (`xx`), 2-2 (`y`), 3-3 (`z`)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-1 (`xx`)、2-2 (`y`)、3-3 (`z`)
- en: 0-0 (`x`), 1-2 (`xy`), 3-3 (`z`)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-0 (`x`)、1-2 (`xy`)、3-3 (`z`)
- en: 0-0 (`x`), 1-1 (`x`), 2-3 (`yz`)
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-0 (`x`)、1-1 (`x`)、2-3 (`yz`)
- en: As in our backward formulation of The Jumper in this chapter and Burger Fervor
    and Moneygrubbers in [Chapter 3](ch03.xhtml), we’ll need to do some postprocessing
    to find what we need. In those other problems, we searched the relevant subproblems
    to discover the optimal one; here, we’ll search the relevant subproblems to find
    all possible solutions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中对《跳跃者》的逆向构造以及《汉堡狂热》和《钱财贪婪者》在[第 3 章](ch03.xhtml)中的处理一样，我们需要进行一些后处理来找出我们需要的内容。在其他问题中，我们搜索了相关的子问题来发现最优解；在这里，我们将搜索相关的子问题来找到所有可能的解。
- en: Characterizing the Ways
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 描述方法
- en: Consider an *i*, *j*, *k* subproblem as described in the previous section. There
    are two categories of ways to satisfy this subproblem. In each category, we require
    that *a*[*i*] is the same character as *b*[*j*]—if it isn’t, then the requirements
    of the subproblem are not met and the answer is zero.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前一节中描述的 *i*、*j*、*k* 子问题。满足此子问题有两类方法。在每一类中，我们要求 *a*[*i*] 和 *b*[*j*] 是相同的字符——如果不是，那么子问题的要求就没有得到满足，答案为零。
- en: '**Category 1**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**类别 1**'
- en: One category of ways involves using *a*[*i*] as the final substring. If we use
    up one substring on *a*[*i*], then we have *k* – 1 substrings to go, so we’ll
    continue by solving subproblems with *k* – 1 as the third parameter. Similarly,
    we’ll continue with *j* – 1 as the second parameter, because we just used character
    *b*[*j*].
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一类方法涉及将 *a*[*i*] 作为最终的子字符串。如果我们用完 *a*[*i*] 上的一个子字符串，那么就剩下 *k* – 1 个子字符串要处理，所以我们会继续解决第三个参数为
    *k* – 1 的子问题。同样，我们会继续使用 *j* – 1 作为第二个参数，因为我们刚刚用过字符 *b*[*j*]。
- en: What about the first parameter—what do we do there? Do we just do the same thing
    that we did with *j* and *k* and continue with *i* – 1?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 那么第一个参数怎么办——我们该怎么做？难道我们不只是像处理 *j* 和 *k* 一样，继续使用 *i* – 1 吗？
- en: Not necessarily! It’s true that continuing with *i* – 1 is one possibility,
    but there are others. We need to be able to skip some characters from *a* and
    continue at an earlier point. That is, we might want to match *b*[*j* – 1] with
    *a*[*i* – 2] or *a*[*i* – 3] or some even earlier character. We’re going to need
    a loop in here that tries all values of the first parameter up to *i* – 1, while
    fixing *j* – 1 for the second parameter and *k* – 1 for the third parameter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 不一定！确实，继续使用 *i* – 1 是一种可能性，但也有其他方法。我们需要能够跳过 *a* 中的一些字符，并在更早的地方继续。也就是说，我们可能希望将
    *b*[*j* – 1] 与 *a*[*i* – 2] 或 *a*[*i* – 3] 或更早的字符匹配。我们需要在这里加一个循环，尝试第一个参数的所有值，直到
    *i* – 1，同时固定第二个参数 *j* – 1 和第三个参数 *k* – 1。
- en: Using our running example, consider again the subproblem with *i* = 6, *j* =
    3, and *k* = 3\. We know that the answer for this subproblem is 8\. Of those 8,
    there are 5 that fall into Category 1\. We get 3 of those 5 from the subproblem
    with *i* = 5, *j* = 2, and *k* = 2 and the other 2 from the subproblem with *i*
    = 2, *j* = 2, and *k* = 2.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的运行示例，再次考虑 *i* = 6，*j* = 3 和 *k* = 3 的子问题。我们知道这个子问题的答案是 8。在这 8 个答案中，有 5
    个属于类别 1。我们从 *i* = 5，*j* = 2 和 *k* = 2 的子问题得到 3 个解，另外 2 个来自 *i* = 2，*j* = 2 和 *k*
    = 2 的子问题。
- en: '**Category 2**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**类别 2**'
- en: The other category of ways involves using at least two characters for the final
    substring.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类解法涉及使用至少两个字符作为最终子串。
- en: 'There’s a neat trick that we can use for this one. Imagine that we solve the
    subproblem with parameters *i* – 1, *j* – 1, and *k* (that’s right: the third
    parameter is *k*, not *k* – 1!). It turns out that this is the only subproblem
    that we need to solve!'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，我们有一个巧妙的技巧可以使用。假设我们解决了具有参数 *i* – 1，*j* – 1 和 *k* 的子问题（没错：第三个参数是 *k*，不是
    *k* – 1！）。事实证明，这就是我们需要解决的唯一子问题！
- en: That subproblem uses all *k* substrings to find solutions that end by matching
    *a*[*i* – 1] with *b*[*j* – 1]. But each of those solutions can be extended to
    a solution that matches *a*[*i*] with *b*[*j*] by just tacking *a*[*i*] (or *b*[*j*]—they’re
    the same) on to the final substring. Similarly, any solution in this category
    that matches *a*[*i*] with *b*[*j*] and uses *k* substrings corresponds to a solution
    to the subproblem that matches *a*[*i* – 1] with *b*[*j* – 1] and uses *k* substrings.
    In conclusion, the number of solutions here is exactly the same as it is for the
    *i* – 1, *j* – 1, *k* subproblem.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 该子问题使用所有的 *k* 个子串来寻找通过将 *a*[*i* – 1] 与 *b*[*j* – 1] 匹配的解决方案。但这些解决方案中的每一个都可以扩展为一个解决方案，通过将
    *a*[*i*]（或 *b*[*j*]—它们是相同的）附加到最终子串上，从而将 *a*[*i*] 与 *b*[*j*] 匹配。同样，任何一个匹配 *a*[*i*]
    与 *b*[*j*] 并且使用 *k* 个子串的类别 2 中的解决方案，都对应于一个匹配 *a*[*i* – 1] 与 *b*[*j* – 1] 并使用 *k*
    个子串的子问题的解决方案。总之，这里解的数量与 *i* – 1，*j* – 1，*k* 子问题的解数量是完全相同的。
- en: In our running example, the subproblem with *i* = 6, *j* = 3, and *k* = 3 has
    three solutions in this category. We get that by looking up the answer to the
    subproblem with *i* = 5, *j* = 2, and *k* = 3.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的运行示例中，*i* = 6，*j* = 3 和 *k* = 3 的子问题在这一类中有三个解。我们通过查找 *i* = 5，*j* = 2 和 *k*
    = 3 的子问题的答案得到这些解。
- en: Notice that there can not be any other categories besides these two. Category
    1 uses the single-character string *a*[*i*] as the final substring; Category 2
    uses a longer string that ends with *a*[*i*] as the final substring. There can’t
    be anything else.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了这两类外，不可能有其他类别。类别 1 使用单字符字符串 *a*[*i*] 作为最终子串；类别 2 使用一个更长的字符串，其中以 *a*[*i*]
    结尾作为最终子串。不能有其他的情况。
- en: Solving One Subproblem
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决一个子问题
- en: 'As we did when solving The Jumper earlier in this chapter, we’ll skip the unadorned
    recursive solution and jump right to a memoized one. We need a function to tell
    us the answer for the subproblem with the given `i`, `j`, and `k` values. That
    function will have the following signature:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面解决《跳跃者》时所做的那样，我们将跳过没有修饰的递归解法，直接跳到记忆化解法。我们需要一个函数来告诉我们给定 `i`、`j` 和 `k`
    值的子问题的答案。这个函数的签名如下：
- en: '[PRE9]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, `a` is the source string; `b` is the target string; `i`, `j`, and `k`
    are the three subproblem parameters; and `memo` is the memoization array.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`a` 是源字符串；`b` 是目标字符串；`i`、`j` 和 `k` 是三个子问题参数；`memo` 是记忆化数组。
- en: The code for this function is given in [Listing 4-6](ch04.xhtml#ch04ex06).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的代码见 [Listing 4-6](ch04.xhtml#ch04ex06)。
- en: '[PRE10]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 4-6: Solving one subproblem*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-6: 解决一个子问题*'
- en: When we solved Hockey Rivalry in [Chapter 3](ch03.xhtml), we started indexing
    our arrays at 1 rather than 0, and that simplified our solution a little. Here,
    however, I’ve decided to index starting at 0\. You could indeed use the Hockey
    Rivalry indexing trick here as well; I’ve chosen not to in order to spare us the
    trouble of defining what subproblems mean when the empty string is in play.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 [第 3 章](ch03.xhtml) 中解决《冰球对抗赛》时，我们将数组的索引从 0 改为从 1 开始，这使得我们的解法变得稍微简单一些。然而，在这里，我决定从
    0 开始索引。你确实可以在这里使用《冰球对抗赛》的索引技巧；我之所以没有使用，是为了避免在空字符串参与时需要定义子问题的含义。
- en: Let’s work through the code, starting with the base cases.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本情况开始，逐步分析代码。
- en: Our first base case is when `j` is `0`, `k` is `1`, and `a[i]` and `b[j]` are
    the same character ➊. What we’re being asked for here is the number of ways to
    build the one-character string `b[0]` using `a[i]` given that `a[i]` matches `b[0]`.
    The answer is `1`, because we can use `a[i]` as a match!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个基本情况是当`j`为`0`，`k`为`1`，且`a[i]`和`b[j]`是相同字符 ➊时。在这里，我们要求的是在`a[i]`与`b[0]`匹配的前提下，构建单字符字符串`b[0]`的方式数。答案是`1`，因为我们可以使用`a[i]`作为匹配！
- en: Now, in any other case where `i` is `0`, or `j` is `0`, or `k` is `0` ➋, the
    answer is `0`. For example, if `i` is `0` and `j` is greater than `0`, then we’re
    being asked to choose substrings from a one-character string to build a string
    with more than one character. That would be impossible!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在任何其他情况下，当`i`为`0`，或`j`为`0`，或`k`为`0` ➋时，答案是`0`。例如，如果`i`为`0`且`j`大于`0`，那么我们正在被要求从一个只有一个字符的字符串中选择子字符串，来构建一个包含多个字符的字符串。这是不可能的！
- en: There’s actually one more base case here ➌, and it kicks in when characters
    `a[i]` and `b[j]` are not equal. In this case, we return `0` right away, because
    there’s no way to use that final character `a[i]` to match `b[j]`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这里还有一个基本情况 ➌，它在`a[i]`和`b[j]`不相等时触发。在这种情况下，我们立刻返回`0`，因为无法用`a[i]`的最终字符匹配`b[j]`。
- en: Now we arrive at the code for implementing each of the two categories. Each
    one adds its contribution to the `total` variable.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了实现这两个类别的代码。每个类别都会向`total`变量贡献其部分答案。
- en: For Category 1, we need a loop ➍ that tries each relevant ending point of `a`,
    adding the subproblem answers to `total` ➎. We use the mod operator here as required
    by the problem description.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类别1，我们需要一个循环 ➍，它尝试`a`的每个相关结束点，并将子问题的答案加到`total` ➎中。这里我们使用了模运算符，这是根据问题描述的要求。
- en: 'For Category 2, we don’t need a loop: we just solve the one subproblem that
    directly gives us the answer ➏.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类别2，我们不需要循环：我们只需解决一个直接给出答案的子问题 ➏。
- en: Collecting the Solutions
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 收集解决方案
- en: We need to call `solve_ijk` using all values of `i`. That’s because any character
    of `a` might match the rightmost character of `b`. The code that calls `solve_ijk`
    in the needed ways is in [Listing 4-7](ch04.xhtml#ch04ex07).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用所有`i`的值调用`solve_ijk`。这是因为`a`的任何字符都可能与`b`的最右边字符匹配。以所需方式调用`solve_ijk`的代码在[清单4-7](ch04.xhtml#ch04ex07)中。
- en: '[PRE11]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 4-7: Solution 1*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-7：解决方案1*'
- en: In our prior dynamic-programming problems, we used `min` or `max` to find the
    best solution. But notice in [Listing 4-6](ch04.xhtml#ch04ex06) and [Listing 4-7](ch04.xhtml#ch04ex07)
    that we’re not doing that. Instead, because we want to find the total number of
    solutions, we are adding everything together using `+`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的动态规划问题中，我们使用了`min`或`max`来找到最佳解决方案。但请注意，在[清单4-6](ch04.xhtml#ch04ex06)和[清单4-7](ch04.xhtml#ch04ex07)中，我们并没有这样做。相反，因为我们想找到所有解决方案的总数，所以我们通过使用`+`将所有内容加在一起。
- en: The main Function
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主函数
- en: The `main` function for this solution is in [Listing 4-8](ch04.xhtml#ch04ex08).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本解决方案的`main`函数在[清单4-8](ch04.xhtml#ch04ex08)中。
- en: '[PRE12]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 4-8: The* main *function*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-8：* 主 *函数*'
- en: Now we have a complete solution to this problem. Feel free to submit to the
    judge.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了这个问题的完整解决方案。可以提交给评测系统了。
- en: Prepare to be disappointed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好失望吧。
- en: '*Solution 2: Adding More Subproblems*'
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决方案2：增加更多子问题*'
- en: For the first time in this book, we have received a “Time-Limit Exceeded” error
    when using memoization. The thing is, even if we use memoization or dynamic programming,
    we may still have to be concerned with the efficiency of our algorithm. Some problems
    admit multiple such solutions that, while faster than exponential time, may still
    differ from each other in terms of their efficiency.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中第一次出现“时间限制超出”错误是使用了记忆化技术时发生的。问题是，即使我们使用了记忆化或动态规划，我们仍然可能需要考虑算法的效率。一些问题允许多种解决方案，尽管这些解决方案比指数时间更快，但它们在效率上可能有所不同。
- en: Runtime of Solution 1
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案1的运行时
- en: 'Let’s use *m* for the length of the source string, *n* for the length of the
    target string, and *k* for the number of substrings we need to take. There are
    a total of about *mnk* subproblems that our solution may end up solving. For each,
    we get hammered by Category 1 solutions, which require that we loop through the
    source string, adding another factor of *m* to our runtime. What we have, then,
    is an algorithm that takes a number of steps proportional to *m*²*nk*. To see
    how bad this is, let’s substitute the maximum values for these variables here:
    1,000 for *m*, 200 for *n*, and 200 for *k*. This will give us 1,000² × 200 ×
    200 = 40,000,000,000\. Forty billion! And we need to get all of this done with
    a two-second time limit? Not gonna happen. We need to do better. As we’ll see,
    we’ll be able to drop one of the factors of *m* and solve this thing in just *O*(*mnk*)
    time.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们用 *m* 表示源字符串的长度，用 *n* 表示目标字符串的长度，用 *k* 表示我们需要处理的子字符串的数量。我们的方法可能最终需要解决大约
    *mnk* 个子问题。对于每个子问题，我们都会被类别 1 的解决方案“重击”，这些方案要求我们遍历源字符串，给我们的运行时间再增加一个 *m* 的因素。那么，问题是，我们的算法的步骤数与
    *m*²*nk* 成正比。为了看看这个问题有多严重，我们这里代入这些变量的最大值：*m* 为 1,000，*n* 为 200，*k* 为 200。这样计算结果是
    1,000² × 200 × 200 = 40,000,000,000。四百亿！而我们需要在两秒钟内完成所有这些工作？根本不可能。我们需要做得更好。正如我们将看到的，我们能够去掉
    *m* 中的一个因子，并将这个问题的解决时间降到 *O*(*mnk*) 时间。
- en: There are two general strategies we might consider at this point. The first
    is to throw our existing subproblems away and try again with new subproblems.
    I tried doing that; you can check the online resources for this book to see what
    I came up with. It didn’t help.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可能考虑两种常见的策略。第一种是丢弃现有的子问题，然后用新的子问题重新尝试。我曾经尝试过这么做；你可以查阅这本书的在线资源，看看我得出了什么结果。结果没有帮助。
- en: Throwing those subproblems away in this case is a needlessly drastic move. After
    all, we have a correct and reasonably efficient solution; the only hitch is the
    loop that we need for each subproblem in Category 1.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，丢弃这些子问题是一个不必要的极端举动。毕竟，我们已经有了一个正确且相对高效的解决方案；唯一的问题是我们需要为每个类别 1 中的子问题使用的循环。
- en: The second strategy, and the one that we will succeed with here, is to add new
    subproblems to our existing subproblems. This second strategy may seem counterintuitive.
    You might reason that if our program is already too slow, adding and solving more
    subproblems would just slow us down even further. But what if our new subproblems
    in fact helped us solve our existing subproblems faster? In particular, what if
    they gave us a way to solve subproblems from Category 1 without the need of a
    loop? And what if we could also solve those new subproblems efficiently? Then
    we’d be golden! We’ll be solving more subproblems, yes, but we’ll make up for
    it bigtime with how efficiently we can solve each subproblem. Let’s try!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种策略，也是我们在这里会成功的策略，是将新的子问题添加到现有的子问题中。第二种策略可能看起来违反直觉。你可能会认为，如果我们的程序已经太慢了，那么添加和解决更多的子问题只会进一步拖慢速度。但是，如果我们的新子问题实际上能帮助我们更快地解决现有的子问题呢？特别是，如果它们为我们提供了一种不需要循环就能解决类别
    1 中子问题的方法呢？如果我们还能高效地解决这些新子问题呢？那我们就发财了！是的，我们将解决更多的子问题，但我们可以通过高效解决每个子问题来弥补这一点。让我们试试吧！
- en: The New Subproblems
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 新的子问题
- en: Remember this bit of code from [Listing 4-6](ch04.xhtml#ch04ex06)?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得[清单 4-6](ch04.xhtml#ch04ex06)中的这段代码吗？
- en: '[PRE13]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That’s the loop that adds up all of the ways in Category 1\. It’s the loop we
    need to eliminate.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是加总类别 1 中所有方式的循环。它是我们需要消除的循环。
- en: This `q` loop keeps `j - 1` and `k - 1` fixed, and varies the first subproblem
    parameter from `0` to `i - 1`. That is, it solves the 0, *j* – 1, *k* – 1 subproblem,
    then the 1, *j* – 1, *k* – 1 subproblem, then the 2, *j* – 1, *k* – 1 subproblem,
    and so on.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`q`循环保持`j - 1`和`k - 1`不变，并将第一个子问题的参数从`0`变到`i - 1`。也就是说，它首先解决 0, *j* – 1, *k*
    – 1 的子问题，然后是 1, *j* – 1, *k* – 1 的子问题，再然后是 2, *j* – 1, *k* – 1 的子问题，以此类推。
- en: 'How awesome would it be if we could look up, in one shot, the sum of all of
    these subproblem answers? Then we wouldn’t need the `q` loop at all. This is what
    our new subproblems are going to do for us. For example, a new subproblem with
    parameters *i* = 4, *j*, and *k* will be the sum of five of our old subproblems:
    the ones with the same *j* and *k* values, but where *i* is 0, 1, 2, 3, or 4\.
    That is, the new subproblems drop the requirement that *a*[*i*] is the same character
    as *b*[*j*]. Here are the definitions for both our old and new subproblems.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够一次性查找所有这些子问题答案的总和，那该有多棒！那样我们就根本不需要 `q` 循环了。这正是我们的新子问题将为我们做的事情。例如，具有参数
    *i* = 4、*j* 和 *k* 的新子问题将是我们五个旧子问题的和：这些旧子问题的 *j* 和 *k* 值相同，但 *i* 值为 0、1、2、3 或 4。也就是说，新的子问题不再要求
    *a*[*i*] 与 *b*[*j*] 是相同的字符。以下是我们旧子问题和新子问题的定义。
- en: '**Old**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**旧**'
- en: The old subproblem with parameters *i*, *j*, and *k* is going to tell us the
    number of ways that we can choose exactly *k* substrings from *a*[0..*i*] to build
    exactly *b*[0..*j*], with the restriction that the rightmost substring ends with
    exactly the character *a*[*i*].
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 具有参数 *i*、*j* 和 *k* 的旧子问题将告诉我们从 *a*[0..*i*] 中恰好选择 *k* 个子字符串来精确构建 *b*[0..*j*]
    的方式数，且有一个限制条件，即最右边的子字符串恰好以字符 *a*[*i*] 结尾。
- en: '**New**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**新**'
- en: The new subproblem with parameters *i*, *j*, and *k* is going to tell us the
    number of ways that we can choose exactly *k* substrings from *a*[0..*i*] to build
    exactly *b*[0..*j*].
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 新的子问题，参数为 *i*、*j* 和 *k*，将告诉我们从 *a*[0..*i*] 中恰好选择 *k* 个子字符串来精确构建 *b*[0..*j*]
    的方式数。
- en: 'Now, with these new subproblems, let’s return to our running example. What’s
    our answer for the new subproblem with *i* = 6, *j* = 3, and *k* = 3? This time
    it really is 11! The subproblem is asking, with no restrictions, for all the ways
    that we can choose exactly three substrings from *a* to build *b*. And we know
    that there are 11 of them. Notice, as a nice side bonus here, that we no longer
    need to solve multiple subproblems as in [Listing 4-7](ch04.xhtml#ch04ex07). All
    we need is the answer to one subproblem: the one that includes all characters
    of *a*, all characters of *b*, and the number of substrings *k*.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，借助这些新子问题，让我们回到我们的运行示例。对于新子问题 *i* = 6、*j* = 3 和 *k* = 3 的答案是什么？这次答案真的是 11！这个子问题是在没有限制的情况下，询问我们从
    *a* 中选择恰好三个子字符串来构建 *b* 的所有方式。我们知道有 11 种方式。注意，作为一个额外的好处，我们不再需要像在[列表 4-7](ch04.xhtml#ch04ex07)中那样解决多个子问题。我们只需要一个子问题的答案：那个包含
    *a* 的所有字符、*b* 的所有字符以及子字符串 *k* 数量的子问题。
- en: Solving the Needed Subproblem
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决所需的子问题
- en: 'Let’s jump to the new code. For each triple of values `i`, `j`, and `k`, we’re
    going to store answers not for one, but for two subproblems. We’ll use a C struct
    to collect both:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到新代码。对于每一组三个值 `i`、`j` 和 `k`，我们将存储不止一个，而是两个子问题的答案。我们将使用 C 结构体来收集这两个答案：
- en: '[PRE14]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `end_at_i` member will store the number of solutions for our old subproblems
    (the ones from Solution 1), and the `total` member will store the number of solutions
    for our new subproblems. Our `memo` array stays as a three-dimensional array,
    with each element now consisting of both `end_at_i` and `total`. Other possible
    designs include two separate three-dimensional memo arrays or a four-dimensional
    array where the new dimension is of length 2.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`end_at_i` 成员将存储我们旧子问题的解（来自解决方案 1 的那些），而 `total` 成员将存储我们新子问题的解。我们的 `memo` 数组仍然是三维数组，每个元素现在包含
    `end_at_i` 和 `total`。其他可能的设计包括两个独立的三维记忆数组，或一个四维数组，其中新维度的长度为 2。'
- en: Now we can write the code that will solve both our old and new subproblems.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写解决我们旧子问题和新子问题的代码。
- en: In all of our memoization and dynamic-programming code thus far, we had to figure
    out one answer for each setting of the subproblem parameters. But here we need
    to figure out two, one for each member of the struct. Look out for that as you
    read through the code. Check it out in [Listing 4-9](ch04.xhtml#ch04ex09).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前所有的记忆化和动态规划代码中，我们必须为每个子问题参数的设置找到一个答案。但在这里，我们需要为结构体的每个成员找到两个答案。请在阅读代码时留意这一点。可以在[列表
    4-9](ch04.xhtml#ch04ex09)中查看。
- en: '[PRE15]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 4-9: Solution 2*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-9：解决方案 2*'
- en: As in Solution 1, a critical case here is when `j` is `0` and `k` is `1`. There
    are two important subcases to consider.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 与解决方案 1 中一样，这里的一个关键情况是当 `j` 为 `0` 且 `k` 为 `1` 时。我们需要考虑两个重要的子情况。
- en: Let’s begin with the one where `a[i]` and `b[j]` are different characters ➊.
    We know that the `end_at_i` number of solutions is `0` here, as it would be in
    Solution 1\. But the `total` number of solutions might not be 0\. For example,
    if `i` were `4` and each of the first three characters of `a` were the same as
    `b[0]`, then our answer would be `3` here. To get them all, we make a recursive
    call to find the total number of matches using the characters from `a` up to index
    `i - 1` ➋. We then store in our `memo` array both the `total` answer that we calculated
    and the `end_at_i` answer of `0` ➌.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`a[i]`和`b[j]`是不同字符的情况开始 ➊。我们知道此时`end_at_i`的解为`0`，就像在解法 1 中一样。但`total`的解可能不为0。例如，如果`i`为`4`，并且`a`的前三个字符与`b[0]`相同，那么我们的答案就是`3`。为了获得所有解，我们进行递归调用，查找使用`a`中从索引`i
    - 1`之前的字符匹配的总数 ➋。然后我们在`memo`数组中存储我们计算的`total`答案和`end_at_i`答案`0` ➌。
- en: Our handling of the subcase where `a[i]` and `b[j]` are the same character is
    similar; we just need to add 1 to both `end_at_i` and `total` to account for the
    match between `a[i]` and `b[j]`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理子案例的方式，当`a[i]`和`b[j]`是相同字符时类似；我们只需要将`end_at_i`和`total`都加1，以考虑`a[i]`和`b[j]`之间的匹配。
- en: Now let’s work on how to solve the current `end_at_i` subproblem. Recall that
    Category 1 involves using *a*[*i*] as the final substring, and Category 2 involves
    using at least two characters for the final substring.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们着手解决当前的`end_at_i`子问题。回想一下，类别 1 涉及使用 *a*[*i*] 作为最终子字符串，而类别 2 涉及使用至少两个字符作为最终子字符串。
- en: 'It’s easier to talk through Category 2, so let’s do that one first. That code
    is nearly the same as before: we retrieve the number of `end_at_i` solutions using
    the subproblem parameters `i - 1`, `j - 1`, and `k` ➎.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 讲解类别 2 会更容易，所以我们先讲解这个。该代码几乎与之前一样：我们使用子问题参数`i - 1`、`j - 1`和`k` ➎来检索`end_at_i`解的数量。
- en: What about our new code for Category 1? This is our moment of victory, because
    we can solve such a subproblem in a single step ➍ by looking up the needed `total`
    subproblem directly!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于我们为类别 1 编写的新代码怎么样呢？这是我们胜利的时刻，因为我们可以通过直接查找所需的`total`子问题来一步解决这种子问题 ➍！
- en: There’s one final thing that we need to do. After all, we have those new `total`
    subproblems now. It’s our responsibility to solve those, too, so that they’re
    correct when we look them up. Fortunately, we’ll be able to solve each `total`
    subproblem quickly as well. To do it, we make use of the fact that we just found
    the number of solutions that use `a[i]`. We can just add that to the old total
    for `i - 1` to get our final total ➏.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 还有最后一件事我们需要做。毕竟，我们现在有了新的`total`子问题。我们有责任解决它们，确保它们在查找时是正确的。幸运的是，我们也能快速解决每个`total`子问题。为此，我们利用了刚刚找到的使用`a[i]`的解的数量。我们只需将它加到`i
    - 1`的旧总数上，得到最终的总数 ➏。
- en: 'There’s a nice interplay here between the `end_at_i` subproblems and the `total`
    subproblems in that we use each to efficiently solve the other. This is the core
    reason why adding our new `total` subproblems helped us: they speed up the computation
    of the `end_at_i` subproblems and, having quickly solved the relevant `end_at_i`
    subproblem, we can repay the favor and quickly solve the `total` subproblem as
    well.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`end_at_i`子问题和`total`子问题之间有一个很好的相互作用，我们利用它们来高效地解决对方。这是我们添加新的`total`子问题能够帮助我们的核心原因：它们加速了`end_at_i`子问题的计算，并且通过快速解决相关的`end_at_i`子问题，我们也可以回报这个帮助，快速解决`total`子问题。
- en: The main Function
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主要函数
- en: All we need now is our `main` function. See the code in [Listing 4-10](ch04.xhtml#ch04ex010).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要我们的`main`函数了。请参见[清单 4-10](ch04.xhtml#ch04ex010)中的代码。
- en: '[PRE16]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 4-10: The* main *function*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-10：* 主要 *函数*'
- en: If you submit this solution to the judge, you should be able to pass all test
    cases in time.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个解决方案提交给评测系统，你应该能够按时通过所有测试用例。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve learned that dynamic-programming problems can be solved
    forward or backward, and that sometimes it matters a great deal which we choose.
    We’ve also learned that our initial solution approach may not be fast enough,
    at which point we need to reconsider our subproblems or add new subproblems.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了动态规划问题可以正向或反向解决，有时选择哪种方式非常重要。我们还学到了我们的初始解决方法可能不够快，这时我们需要重新考虑我们的子问题或添加新的子问题。
- en: Can’t get enough of this? You may be happy to know that ideas related to dynamic
    programming often make cameos in other algorithms. In the next chapter, for example,
    you’ll see that we’ll once again store results for later lookup. And in [Chapter
    7](ch07.xhtml), you’ll see a problem in which dynamic programming plays a supporting
    role, speeding up computation required by the main algorithm of interest.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 还觉得不过瘾吗？你可能会很高兴地知道，动态规划相关的思想经常在其他算法中出现。在下一章中，例如，你将看到我们再次存储结果以供后续查找。而在[第7章](ch07.xhtml)中，你将看到一个问题，其中动态规划起到了辅助作用，加速了主算法所需的计算。
- en: Notes
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: The Jumper is originally from the 2007 Croatian Regional Competition in Informatics.
    Ways to Build is originally from the 2015 National Olympiad in Informatics in
    Provinces.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Jumper 最初来自2007年克罗地亚信息学区域竞赛。Ways to Build 最初来自2015年省级信息学奥林匹克。
