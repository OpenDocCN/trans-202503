- en: '**10**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10**'
- en: '**MINECRAFT MAGIC WITH FOR LOOPS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 for 循环在 Minecraft 中施展魔法**'
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/common01.jpg)'
- en: Now it’s time to learn about `for` loops. `for` loops are super useful because
    they iterate over lists of items, like the lists you saw in [Chapter 9](ch09.html#ch09).
    This means that they are perfect when you want to use loops with lists in your
    programs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习 `for` 循环了。`for` 循环非常有用，因为它们可以遍历列表中的项目，就像你在 [第 9 章](ch09.html#ch09) 中看到的列表一样。这意味着当你在程序中需要使用循环遍历列表时，`for`
    循环是完美的选择。
- en: While following along with the missions in this chapter, you’ll use `for` loops
    to generate stairs, pillars, pyramids, and weather-beaten walls. With nested `for`
    loops and lists, you’ll be able to create pixel art and generate new structures
    in seconds. `for` loops are very powerful tools for building in Minecraft!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在跟随本章任务的过程中，你将使用 `for` 循环生成楼梯、柱子、金字塔和风化的墙壁。通过嵌套的 `for` 循环和列表，你将能够在几秒钟内创建像素艺术并生成新结构。`for`
    循环是 Minecraft 中构建的强大工具！
- en: '**A SIMPLE FOR LOOP**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**一个简单的 for 循环**'
- en: A `for` loop repeats a block of code for each item in a list until the list
    ends, rather than using a condition like a `while` loop or an `if` statement.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环会对列表中的每个项目重复执行一段代码，直到列表结束，而不是像 `while` 循环或 `if` 语句那样使用条件。'
- en: 'The list you use in a `for` statement can contain any number of items of any
    data type. The `for` loop will iterate through each one in order, that is, by
    its index. For example, to print every item in the noodle soup list, we would
    use the following code:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 `for` 语句中使用的列表可以包含任意数量的任何数据类型的项。`for` 循环将按顺序遍历每个项，即按其索引。例如，要打印面条汤列表中的每一项，我们可以使用以下代码：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We use the `for` operator to tell Python we’re using a loop.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `for` 操作符告诉 Python 我们正在使用一个循环。
- en: After the `for` operator is a variable, `ingredient`, that represents the item
    that the loop is currently using. The value changes every time the loop iterates
    until it has looped through each item in the list. The first time the loop executes,
    the value will be the item in index position 0 (in this case `"water"`), the second
    time the value will be the item in index 1 (`"soy sauce"`), the third time the
    value will be the item in index 2 (`"spring onions"`), and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for` 操作符后面是一个变量 `ingredient`，它代表循环当前使用的项目。每次循环迭代时，值都会改变，直到循环遍历完列表中的每一项。第一次执行时，值将是索引位置
    0 的项（在这个例子中是 `"water"`），第二次执行时，值将是索引位置 1 的项（`"soy sauce"`），第三次执行时，值将是索引位置 2 的项（`"spring
    onions"`），依此类推。
- en: The `in` operator and the list name at the end of the statement tell Python
    which list you’re using. The name of the list in this example is `noodleSoup`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 操作符和语句末尾的列表名称告诉 Python 你正在使用哪个列表。这个例子中，列表的名称是 `noodleSoup`。'
- en: 'The loop executes once for each item in the list and then ends when it reaches
    the end of the list. Here’s the output for this program:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 循环会对列表中的每一项执行一次，直到达到列表的末尾才结束。以下是这个程序的输出：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Every item in the list is printed! Now let’s have some fun with `for` loops
    in Minecraft.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个项都会被打印出来！现在，让我们在 Minecraft 中用 `for` 循环来玩得开心吧。
- en: '**MISSION #55: MAGIC WAND**'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #55：魔法棒**'
- en: Every tool in Minecraft has its own purpose. The shovel digs dirt, the pickaxe
    breaks stone blocks, the axe cuts wood, and the sword hits baddies. Usually, you
    can’t change how the tools behave; you just have to accept that the sword only
    hits enemies. But with Python, you can change how the tools work. In this program,
    we’ll turn the sword into a magic wand.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Minecraft 中的每个工具都有其独特的功能。铲子挖掘泥土，镐子打破石块，斧头砍伐木材，而剑则击打敌人。通常，你不能改变工具的行为；你只能接受剑只击打敌人。但使用
    Python，你可以改变工具的工作方式。在这个程序中，我们将把剑变成魔法棒。
- en: In [Chapter 9](ch09.html#ch09), you learned about the `pollBlockHits()` function.
    This function returns a list of block coordinates that the sword has hit. Using
    a `for` loop, you can access each set of coordinates in this list. We’re going
    to turn all the blocks we hit in the last 60 seconds into melons. You can see
    how this works in [Figure 10-1](ch10.html#ch10fig1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 9 章](ch09.html#ch09) 中，你了解了 `pollBlockHits()` 函数。这个函数返回一个包含剑击中的方块坐标的列表。通过
    `for` 循环，你可以访问该列表中的每一组坐标。我们将把过去 60 秒内我们打到的所有方块变成西瓜。你可以在 [图 10-1](ch10.html#ch10fig1)
    中看到它是如何实现的。
- en: '![image](graphics/f10-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](graphics/f10-01.jpg)'
- en: '*Figure 10-1: Abracadabra! All the blocks I hit are now melons.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：变魔术！我打到的所有方块现在变成了西瓜。*'
- en: '[Listing 10-1](ch10.html#ch10ex1) contains the start of the program. Save it
    as *magicWand.py* in a new folder called *forLoops*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-1](ch10.html#ch10ex1) 包含了程序的开头。将其保存为 *magicWand.py*，并放入一个名为 *forLoops*
    的新文件夹中。'
- en: '*magicWand.py*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*magicWand.py*'
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 10-1: The start of the magic wand program*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例10-1：魔法棒程序的开始部分*'
- en: To get the list of block hits, we call the `pollBlockHits()` function and store
    the result in the `hits` variable ➊.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取方块击中的列表，我们调用`pollBlockHits()`函数并将结果存储在`hits`变量中➊。
- en: Included is a line of code that will get the position of any block you hit and
    store its coordinates in the `x`, `y`, and `z` variables ➌. It uses a tuple (introduced
    in “[Tuples](ch09.html#ch09lev1sec04)” on [page 175](ch09.html#page_175)) to assign
    the three variables in a single line.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中包括了一行将获取你击中的方块位置并将其坐标存储在`x`、`y`和`z`变量中的代码➌。它使用一个元组（在[第9章](ch09.html#ch09lev1sec04)的[页面175](ch09.html#page_175)中介绍）来在一行中为三个变量赋值。
- en: 'At the moment, this line of code won’t work because the `hit` variable doesn’t
    exist. Create a `for` loop at ➋ and call the variable of the `for` loop `hit`.
    The `for` loop should iterate over the `hits` list. The code for the first part
    of the `for` loop should look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这行代码无法工作，因为`hit`变量并不存在。在➋处创建一个`for`循环，并将`for`循环的变量命名为`hit`。`for`循环应遍历`hits`列表。`for`循环的第一部分代码应如下所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Make sure you indent the line of code that gets the `x`, `y`, and `z` values
    inside the `for` loop at ➌. On the last line of the `for` loop, add the `setBlock()`
    function to set a melon block at the x-, y-, and z-coordinates ➍.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将获取`x`、`y`和`z`值的代码行缩进到➌的`for`循环内。在`for`循环的最后一行，添加`setBlock()`函数以在x、y和z坐标➍处设置一个西瓜方块。
- en: When the user runs the completed program, they’ll have 60 seconds to run around
    and right-click as many blocks as they can with their sword. After 60 seconds,
    all the blocks that were hit with the sword will turn to melons.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户运行完成的程序时，他们将有60秒钟的时间在四处奔跑，并用剑右键点击尽可能多的方块。60秒后，所有被剑击中的方块将变成西瓜。
- en: '**BONUS OBJECTIVE: YOU’RE A WIZARD**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外目标：你是一个巫师**'
- en: 'Change the *magicWand.py* program so it teleports the player: the first hit
    sets the location, and the second hit takes them there.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 修改*magicWand.py*程序，使其传送玩家：第一次击中设置位置，第二次击中将玩家传送到该位置。
- en: '**THE RANGE() FUNCTION**'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**range()函数**'
- en: 'The `range()` function creates a list of integers. It’s a good way to create
    a list of numbers for your `for` loops very quickly. Let’s take a look and pass
    two arguments, 0 and 5, to the `range()` function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()`函数创建一个整数列表。它是为`for`循环快速生成数字列表的好方法。让我们来看一下并传递两个参数，0和5，给`range()`函数：'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is a faster way to create a list than writing each item in the list individually,
    which would look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是比单独写出每个列表项更快速的创建列表的方法，单独写出的列表项会像这样：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the `range()` function’s second argument is 5, but the last item
    in the list is 4\. This is because the function only creates values that are less
    than but not equal to the second argument.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`range()`函数的第二个参数是5，但列表中的最后一个项是4。这是因为该函数只生成小于但不等于第二个参数的值。
- en: 'To create a loop that uses the `range()` function to print the numbers 1 to
    15, you would use the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个使用`range()`函数打印从1到15的数字的循环，你可以使用以下代码：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You could print double the value of every item in a list like so:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样打印出列表中每个项的两倍值：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can do the same thing with a `while` loop, which you learned about in [Chapter
    7](ch07.html#ch07). The following code uses a `while` loop instead of a `for`
    loop to print the numbers 1 to 15:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`while`循环做同样的事情，在[第7章](ch07.html#ch07)中你已经学习过`while`循环。以下代码使用`while`循环代替`for`循环，打印从1到15的数字：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that the `for` loop is simpler and easier to read. In large and complex
    programs, a `for` loop is often a better choice than a `while` loop with `count`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`for`循环更简单且更易于阅读。在大型复杂的程序中，`for`循环通常比带有`count`的`while`循环更合适。
- en: '**MISSION #56: MAGIC STAIRS**'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务#56：魔法楼梯**'
- en: One of the best features of using Minecraft with Python is that you can build
    things quickly with just a few lines of code. Instead of spending lots of time
    building walls, you can just run some code and it’s done. You can also reuse the
    code as many times as you want, saving time and effort.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Minecraft和Python的一个最佳特点是，你只需几行代码就能快速构建东西。你不必花费大量时间建造墙壁，只需运行一些代码就完成了。你还可以随时重复使用这些代码，节省时间和精力。
- en: Building stairs is one task that often takes a long time to do. Fortunately,
    with just a few lines of Python code, you can quickly create a staircase in Minecraft.
    In this mission, you’ll use a `for` loop to make a staircase appear in the game
    world.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 建造楼梯是一个通常需要花费大量时间的任务。幸运的是，通过几行 Python 代码，你可以在 Minecraft 中快速创建楼梯。在这个任务中，你将使用
    `for` 循环让楼梯在游戏世界中出现。
- en: '[Listing 10-2](ch10.html#ch10ex2) creates a staircase in Minecraft using a
    `while` loop. Save it as *stairs.py* in the *forLoops* folder.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-2](ch10.html#ch10ex2) 使用 `while` 循环在 Minecraft 中创建楼梯。将其保存为 *stairs.py*
    文件，放入 *forLoops* 文件夹中。'
- en: '*stairs.py*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*stairs.py*'
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 10-2: A program that creates a staircase using a* `while` *loop*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-2: 使用 `while` 循环创建楼梯的程序*'
- en: Although you can use a `while` loop for this program, as shown here, a `for`
    loop is actually more suitable. Unlike the `while` loop, a `for` loop doesn’t
    require a `count` or `step` variable. Instead, you can use the `range()` function
    to determine how many times the loop repeats.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以像这里展示的那样使用 `while` 循环来实现这个程序，但实际上 `for` 循环更为合适。与 `while` 循环不同，`for` 循环不需要
    `count` 或 `step` 变量。相反，你可以使用 `range()` 函数来确定循环重复的次数。
- en: To complete the program, change the code so it uses a `for` loop instead of
    a `while` loop.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成程序，将代码修改为使用 `for` 循环，而不是 `while` 循环。
- en: You can see the result of the program in [Figure 10-2](ch10.html#ch10fig2).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [图 10-2](ch10.html#ch10fig2) 中看到程序的结果。
- en: '**BONUS OBJECTIVE: GOING DOWN?**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外目标：向下走？**'
- en: 'At the moment, the *stairs.py* program only builds stairs in one direction.
    Try to work out how to build stairs in other directions. Hint: You’ll use the
    optional block states argument in the `setBlock()` function and add to or take
    away from the `x` or `z` variables.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，*stairs.py* 程序只在一个方向上建造楼梯。尝试找出如何在其他方向上建造楼梯。提示：你将使用 `setBlock()` 函数中的可选块状态参数，并对
    `x` 或 `z` 变量进行加法或减法操作。
- en: '![image](graphics/f10-02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-02.jpg)'
- en: '*Figure 10-2: Where will your magic staircase lead?*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2: 你的魔法楼梯将通向何方？*'
- en: '**PLAYING AROUND WITH RANGE()**'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**玩转 RANGE()**'
- en: 'You’ve learned a bit about the `range()` function and what happens when you
    pass two arguments to the function. What if you pass just one argument? Enter
    this code in the IDLE shell to see what happens:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了 `range()` 函数以及当你传递两个参数时会发生什么。如果你只传递一个参数会怎样呢？在 IDLE shell 中输入这段代码看看会发生什么：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you give the `range()` function only one argument, it will start at 0
    and store each value up to one less than the value you pass in as an argument.
    In other words, it’s as if you passed 0 for the first argument and 5 for the second
    argument. In this example, the `list()` function shows the list values created
    by the `range()` function (otherwise, you wouldn’t see them!). As you can see,
    the value of `list(aRange)` is a list of five numbers that start at 0: `[0, 1,
    2, 3, 4]`. This is a fast way to create a range if you want to start with 0 as
    the first value.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只向 `range()` 函数传递一个参数时，它将从 0 开始，并存储每个值，直到值比你传递的参数小 1。换句话说，就好像你为第一个参数传递了 0，为第二个参数传递了
    5。在这个示例中，`list()` 函数显示了 `range()` 函数创建的列表值（否则你是看不到它们的！）。如你所见，`list(aRange)` 的值是一个包含五个数字的列表，从
    0 开始：`[0, 1, 2, 3, 4]`。这是一个快速创建范围的方式，如果你想让第一个值从 0 开始的话。
- en: 'As you’ve seen, when you pass two arguments to `range()`, the list starts at
    the first argument provided and ends before the second argument:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当你向 `range()` 函数传递两个参数时，列表从第一个参数开始，到第二个参数之前结束：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example creates a range equivalent to the list `[2, 3, 4]`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例创建了一个与列表 `[2, 3, 4]` 等效的范围。
- en: When you give `range()` three arguments, the third argument defines the *step*
    between items. Normally, each value in the list created by the `range()` function
    is one larger than the previous value. By changing the step, you change the difference
    between values. For example, a step of 2 would make the next value in a list 2
    more than the previous item. A step of 3 would make it 3 more than the previous
    item, and so on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给 `range()` 函数提供三个参数时，第三个参数定义了项与项之间的 *步长*。通常，`range()` 函数创建的列表中的每个值比前一个值大
    1。通过更改步长，你可以改变项之间的差异。例如，步长为 2 时，列表中的下一个值将比前一个值大 2。步长为 3 时，下一个值比前一个值大 3，依此类推。
- en: 'For example, this list adds 2 to the previous value to get the next value:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个列表通过将前一个值加 2 来得到下一个值：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that each item is 2 more than the previous item (5 is 3 + 2, 7 is 5 +
    2, and 9 is 7 + 2).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个项比前一个项大 2（5 是 3 + 2，7 是 5 + 2，9 是 7 + 2）。
- en: 'You can even give `range()` a negative step value, like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以给 `range()` 函数一个负步长值，像这样：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that the values in the list decrease by 2 because of the negative step
    value.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，列表中的值每次减少2，因为使用了负步长值。
- en: '**OTHER LIST FUNCTIONS**'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**其他列表函数**'
- en: Because we’re working with lists, let’s explore a few other functions designed
    to interact with lists.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理列表，让我们探索一些其他专为与列表交互而设计的函数。
- en: 'The `reversed()` function takes one argument, the list you want to use, and
    returns the list reversed. The last item will be the first item, the second-to-last
    item will be the second item, and so on. Let’s reverse an earlier list:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`reversed()`函数接受一个参数，即你想要使用的列表，并返回反转后的列表。最后一个元素将成为第一个元素，倒数第二个元素将成为第二个元素，依此类推。让我们反转一个先前的列表：'
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Items in the list have been reversed, just as we wanted. This kind of list manipulation
    comes in handy when you’re writing `for` loops.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的项目已被反转，正如我们所期望的那样。这种列表操作在你编写`for`循环时非常有用。
- en: 'The following example generates a list of numbers from 1 to 100 using the `range()`
    function. It then reverses the list and prints it using a `for` loop, effectively
    creating a countdown from 100 to 1:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`range()`函数生成从1到100的数字列表。然后，它反转该列表并使用`for`循环打印出来，从而有效地创建一个从100到1的倒计时：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run it to see the output!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它以查看输出结果！
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can also reverse the list when you declare the `for` loop without needing
    a variable to store the list:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在声明`for`循环时反转列表，而无需使用变量来存储列表：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This program requires fewer lines of code while having the same effect. Use
    this trick to save time so you can focus on building!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序用更少的代码行实现相同的效果。使用这个技巧节省时间，以便你可以专注于构建！
- en: '**MISSION #57: PILLARS**'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #57：柱子**'
- en: Wouldn’t it be cool to build a palace in Minecraft? Because palaces should be
    grand, ours should have rows of tall, imposing pillars. Obviously, we don’t want
    to build them by hand, so using a loop to build them is the best solution.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Minecraft中建造一个宫殿是不是很酷？因为宫殿应该是宏伟的，所以我们需要一排排高大、威严的柱子。显然，我们不想手动建造它们，所以使用循环来建造它们是最好的解决方案。
- en: We’ll create a function that builds a pillar and then call the function when
    we want to build one. [Listing 10-3](ch10.html#ch10ex3) contains the function
    to build a pillar. Copy it into a new file called *pillars.py* and save it in
    the *forLoops* folder.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个函数来构建柱子，然后在需要时调用该函数。[列表 10-3](ch10.html#ch10ex3)包含了构建柱子的函数。将其复制到一个名为*pillars.py*的新文件中，并将其保存在*forLoops*文件夹中。
- en: '*pillars.py*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*pillars.py*'
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 10-3: A function that creates a pillar*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-3：创建柱子的函数*'
- en: 'The `setPillar()` function creates a pillar. It takes four arguments: the x-,
    y-, and z-coordinates and the pillar height.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPillar()`函数用来创建一个柱子。它需要四个参数：x、y和z坐标以及柱子的高度。'
- en: To finish the program, add a `for` loop ➊ that calls the `setPillar()` function
    ➋. We want to create a row of 20 pillars that are each 5 blocks apart. To do that,
    use a `range()` function with three arguments to determine how many pillars will
    be created and how far apart they will be. By adding the values stored in the
    `for` loop’s variable to the `x` or `z` variable in the `setPillar()` function
    call, you can make each pillar an equal distance apart.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成程序，添加一个`for`循环 ➊，它调用`setPillar()`函数 ➋。我们想要创建一排20根柱子，每根柱子相距5个方块。为此，使用一个带有三个参数的`range()`函数来确定将创建多少根柱子，以及它们之间的间隔。通过将`for`循环中变量的值添加到`setPillar()`函数调用中的`x`或`z`变量，你可以确保每根柱子之间的距离相等。
- en: '[Figure 10-3](ch10.html#ch10fig3) shows some of the pillars.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-3](ch10.html#ch10fig3)展示了其中一些柱子。'
- en: '![image](graphics/f10-03.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-03.jpg)'
- en: '*Figure 10-3: A brilliant row of pillars*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：一排精美的柱子*'
- en: '**MISSION #58: PYRAMID**'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #58：金字塔**'
- en: Continuing the theme of building awesome stuff with `for` loops, let’s build
    a pyramid. A pyramid is made up of many levels. The bottom level is the widest,
    and the top level—the peak—is the narrowest. Each level is a square of blocks.
    We’ll make a pyramid that’s two blocks narrower on each level. For example, if
    the base level is seven blocks wide, the next level would be five blocks wide,
    then three blocks, and finally the top level would be one block wide.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用`for`循环构建精彩物品的主题，让我们来建造一个金字塔。金字塔由许多层组成。最底层最宽，顶部最窄。每一层都是由方块组成的。我们将构建一个每层宽度比上一层少两个方块的金字塔。例如，如果底层宽度是七个方块，那么下一层将是五个方块宽，接着是三个方块宽，最后顶层为一个方块宽。
- en: '[Listing 10-4](ch10.html#ch10ex4) creates a pyramid. Copy it into a new file
    called *pyramid.py* and save it in the *forLoops* folder.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-4](ch10.html#ch10ex4) 创建了一个金字塔。将其复制到一个名为*pyramid.py*的新文件中，并将其保存在*forLoops*文件夹中。'
- en: '*pyramid.py*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*pyramid.py*'
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 10-4: An upside-down pyramid program*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-4：倒金字塔程序*'
- en: Although [Listing 10-4](ch10.html#ch10ex4) creates a pyramid, it contains a
    minor bug you need to fix! We store the pyramid’s height in the `height` variable
    ➊. You can change the value of the `height` variable to anything you want. The
    `levels` variable uses the `range()` function to create a list that contains one
    item for each level of the pyramid ➋. The `height` variable is added to the player’s
    x-coordinate when we set the `x`, `y`, and `z` variables ➌. If we didn’t do this,
    the player would be trapped at the center of the pyramid when it’s built.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管[示例 10-4](ch10.html#ch10ex4)创建了一个金字塔，但它包含了一个你需要修复的小bug！我们将金字塔的高度存储在`height`变量中➊。你可以将`height`变量的值更改为任何你想要的值。`levels`变量使用`range()`函数创建一个列表，每个金字塔的每一层都包含一个元素➋。当我们设置`x`、`y`和`z`变量时，`height`变量被加到玩家的x坐标上➌。如果我们不这么做，当金字塔建造时，玩家就会被困在金字塔的中心。
- en: The `for` loop iterates for each `level` in the `levels` list ➍. The line of
    code that creates each level of the pyramid uses the `level` variable to work
    out the width of each square of blocks that it creates ➎. The width and length
    of each pyramid level will always be twice the size of the `level` variable.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环会遍历`levels`列表中的每个`level` ➍。创建每个金字塔层的代码行使用`level`变量来计算每个方块的宽度 ➎。每一层金字塔的宽度和长度将始终是`level`变量的两倍大小。'
- en: Remember that bug I mentioned earlier? Run the program to see what the problem
    is. The pyramid is upside down!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我之前提到的那个bug吗？运行程序看看问题出在哪里。金字塔是倒过来的！
- en: To fix this issue and make the pyramid right side up, you’ll need to use the
    `reversed()` function on the `levels` variable to make a list that gets smaller
    over time. Or you could be sneaky and call the `range()` function with a negative
    value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题并让金字塔恢复正常，你需要对`levels`变量使用`reversed()`函数，这样可以生成一个随着时间变小的列表。或者你也可以偷偷使用带负值的`range()`函数。
- en: '[Figure 10-4](ch10.html#ch10fig4) shows the finished pyramid.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-4](ch10.html#ch10fig4)展示了完成的金字塔。'
- en: '![image](graphics/f10-04.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-04.jpg)'
- en: '*Figure 10-4: A magnificent pyramid*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：宏伟的金字塔*'
- en: '**LOOPING OVER A DICTIONARY**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**遍历字典**'
- en: You can also use a `for` loop to loop over a dictionary. When you’re using a
    dictionary with a `for` loop, the syntax is the same as a `for` loop with a list;
    however, the loop will only iterate through the dictionary’s keys.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`for`循环遍历字典。当你使用`for`循环遍历字典时，语法与遍历列表的`for`循环相同；但是，循环将仅遍历字典的键。
- en: 'For example, the following code prints the `for` loop’s variable each time
    the loop iterates. In this case, it prints the key of each item in the dictionary:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码在每次循环迭代时打印`for`循环的变量。在这种情况下，它会打印字典中每个项的键：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code prints the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码输出如下：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To print the value associated with each item in the dictionary, you need to
    use the `dictionary[key]` syntax. Here’s how to change the code so it prints the
    value of each item as well as the key:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印字典中每个项的值，你需要使用`dictionary[key]`语法。以下是如何修改代码，以便它打印每个项的值和键：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This example now prints the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例现在输出如下：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that this output is much easier to read than the dictionary itself. By
    using a loop to output the values of a dictionary, you have much more control
    over how the information is displayed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个输出比字典本身更容易阅读。通过使用循环输出字典的值，你可以更好地控制信息的显示方式。
- en: '**MISSION #59: SCOREBOARD**'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #59：记分板**'
- en: 'Recall the *swordHitsScore.py* game from [Mission #54](ch09.html#ch09lev2sec23)
    ([page 192](ch09.html#page_192)). The game recorded the number of blocks a player
    hit in a minute. The score was stored in a dictionary along with the name of the
    player. Although the program worked just fine, the scoreboard at the end of the
    program didn’t output the scores and names in a very readable format. It just
    printed a dictionary without any formatting.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '回想一下[swordHitsScore.py](ch09.html#ch09lev2sec23)游戏，来自[任务 #54](ch09.html#ch09lev2sec23)（[第192页](ch09.html#page_192)）。这个游戏记录了玩家在一分钟内击中的方块数量。分数和玩家名字被存储在一个字典中。虽然程序本身运行得很好，但程序结尾的记分板没有以非常易读的格式输出分数和名字。它只是简单地打印了一个没有任何格式化的字典。'
- en: To improve the program, in this mission you’ll modify *swordHitsScore.py* so
    it outputs the `scoreboard` dictionary in an easy-to-read format. To do this,
    you’ll use a `for` loop.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进程序，在这个任务中，你将修改*swordHitsScore.py*，使其以易读的格式输出`scoreboard`字典。为此，你将使用`for`循环。
- en: 'Open your *swordHitsScore.py* program (it should be in the *lists* folder)
    and save it as *scoreBoard.py* in the *forLoops* folder. In the program, find
    and delete this line:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 *swordHitsScore.py* 程序（它应该在 *lists* 文件夹中），并将其保存为 *scoreBoard.py*，放在 *forLoops*
    文件夹中。在程序中，找到并删除这一行：
- en: print(scoreboard)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: print(scoreboard)
- en: 'Replace this line with a `for` loop that prints the name of each player and
    their score. These values are stored in the `scoreboard` dictionary: each player’s
    name is a key in the dictionary, and their score is the value of the key.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一行替换为一个 `for` 循环，用来打印每个玩家的名字和分数。这些值存储在 `scoreboard` 字典中：每个玩家的名字是字典中的键，分数是键的值。
- en: '[Figure 10-5](ch10.html#ch10fig5) shows the updated output.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-5](ch10.html#ch10fig5) 显示了更新后的输出。'
- en: '![image](graphics/f10-05.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-05.jpg)'
- en: '*Figure 10-5: The output of the program is now easier to read.*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：程序的输出现在更容易阅读了。*'
- en: '**FOR-ELSE LOOPS**'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**FOR-ELSE 循环**'
- en: You can also use the `else` statement with a `for` loop. When you use `else`
    with a `for` loop, it executes after the `for` loop reaches the end of the list.
    If the `for` loop doesn’t reach the end of its list, the `else` statement will
    not execute.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 `for` 循环中使用 `else` 语句。当你在 `for` 循环中使用 `else` 时，它会在 `for` 循环遍历完列表后执行。如果
    `for` 循环没有遍历到列表的末尾，`else` 语句将不会执行。
- en: 'For example, here’s a bit of code that prints the ingredients of a sandwich
    and then uses an `else` statement:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一段代码，它打印三明治的成分，然后使用了一个 `else` 语句：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you run this code, it prints the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，它会输出以下内容：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You might think this code is just the same as writing the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这段代码与以下写法是一样的：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Well, yes it is. Both pieces of code will do the same thing. So what is the
    point of using `else` with a `for` loop? Well, when used with a `break` statement,
    the `else` statement will behave differently. Let’s look at that next.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，确实如此。两段代码的效果是一样的。那么，使用 `else` 和 `for` 循环有什么意义呢？其实，当与 `break` 语句一起使用时，`else`
    语句的行为会有所不同。接下来我们来看看这个情况。
- en: '**BREAKING A FOR-ELSE LOOP**'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**中断 FOR-ELSE 循环**'
- en: Using a `break` statement to exit a `for` loop is one way to prevent the `else`
    statement from executing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `break` 语句退出 `for` 循环是一种防止 `else` 语句执行的方法。
- en: 'The following example incorporates a `break` statement within an `if` statement.
    The loop will break if the current item is `"Mayonnaise"`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在 `if` 语句中加入了 `break` 语句。如果当前项是 `"Mayonnaise"`，循环将会中断：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Can you predict what the output will be? Think about it before running this
    code, and then run the code and see what happens.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你能预测输出结果吗？在运行这段代码之前想一想，然后运行代码看看会发生什么。
- en: '**MISSION #60: THE DIAMOND PROSPECTOR**'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #60：钻石勘探者**'
- en: Sometimes when I’m playing Minecraft with friends, they won’t let me use Python
    programs to generate diamond blocks. But I still need diamonds for armor, tools,
    and building diamond castles. Digging straight down for diamond is easy enough,
    but you don’t always find it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在和朋友一起玩《Minecraft》时，他们不让我用 Python 程序来生成钻石方块。但我仍然需要钻石来制作盔甲、工具以及建造钻石城堡。直接向下挖掘钻石很容易，但并不总是能找到。
- en: To save some time, I wrote a program that checks whether any diamond ore is
    directly below me. The program gets my current position and then uses a `for`
    loop to check the blocks below me one at a time to see whether they’re diamond
    ore. If diamond ore is found, the program tells me how deep the ore is; if no
    diamond ore is found, the program posts a message to say no diamond ore is below
    me.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省时间，我编写了一个程序，检查我正下方是否有钻石矿石。程序获取我的当前位置，然后使用一个 `for` 循环逐一检查我下方的方块，看看它们是否是钻石矿石。如果发现钻石矿石，程序会告诉我矿石的深度；如果没有发现钻石矿石，程序会发布一条消息，告诉我下方没有钻石矿石。
- en: Create a new program and save it as *diamondSurvey.py* in the *forLoops* folder.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新程序，并将其保存为 *diamondSurvey.py*，放在 *forLoops* 文件夹中。
- en: Use a `for` loop to change the value of the `y` variable by –1 each time the
    loop iterates. In total, the loop should repeat 50 times to check 50 blocks deep.
    For each iteration, use an `if` statement to check whether the block at that position
    is diamond ore (block ID 56). If it is a diamond ore block, post a message to
    the chat to say how far the block is below the player and break the loop. If no
    diamond ore blocks are found, use an `else` statement in your `for` loop to post
    a message that says no diamond ore blocks are directly below the player.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for` 循环，每次循环迭代时，将 `y` 变量的值减少 1。循环应该总共执行 50 次，以检查 50 个方块的深度。对于每次迭代，使用 `if`
    语句检查该位置的方块是否是钻石矿石（方块 ID 56）。如果是钻石矿石方块，向聊天中发送消息，告诉玩家该方块距离自己有多远，并退出循环。如果没有找到钻石矿石方块，使用
    `else` 语句在 `for` 循环中发送消息，告知玩家下面没有钻石矿石方块。
- en: '[Figure 10-6](ch10.html#ch10fig6) shows the working program.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-6](ch10.html#ch10fig6)显示了正在工作的程序。'
- en: '![image](graphics/f10-06.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-06.jpg)'
- en: '*Figure 10-6: It looks like a diamond ore block is four blocks below me. Time
    to start digging!*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-6：看起来像是有一个钻石矿石块在我下面四个方块的位置。是时候开始挖掘了！*'
- en: '**BONUS OBJECTIVE: GOLD IN THEM THAR HILLS**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加目标：那些山里的黄金**'
- en: Change the *diamondSurvey.py* program so it looks for other ore blocks as well,
    such as iron ore or gold ore.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 *diamondSurvey.py* 程序，使其也能寻找其他矿石块，比如铁矿石或金矿石。
- en: '**NESTED FOR LOOPS AND MULTIDIMENSIONAL LISTS**'
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**嵌套的 FOR 循环和多维列表**'
- en: Within your programs, you can use multiple lists together for a variety of reasons.
    It’s possible to include lists within lists, which are called *multidimensional
    lists*. In this section, we’ll use two-dimensional (2D) and three-dimensional
    (3D) lists to build structures in Minecraft.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序中，你可以将多个列表结合使用，达到多种目的。你可以将列表包含在其他列表中，这些被称为*多维列表*。在本节中，我们将使用二维（2D）和三维（3D）列表来在
    Minecraft 中构建结构。
- en: '**THINKING IN TWO DIMENSIONS**'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在二维中思考**'
- en: You’ve learned how to write lists, specifically *one-dimensional* lists. They’re
    called one-dimensional lists because each position in the list contains only one
    item.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何编写列表，特别是*一维*列表。它们被称为一维列表，因为列表中的每个位置只包含一个项目。
- en: 'For example, look at the following list, called `oneDimensionalRainbowList`.
    The formatting of this list is a bit different just to emphasize that each position
    contains a single item; otherwise, it’s the same as other lists you’ve worked
    with:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看下面这个列表，叫做 `oneDimensionalRainbowList`。这个列表的格式稍有不同，旨在强调每个位置只包含一个项目；否则，它与其他你工作过的列表相同：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are six items in this list: the numbers 0 to 5\. Each item in the list
    has only one value, making the list a one-dimensional list.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表中有六个项目：数字 0 到 5。列表中的每个项目只有一个值，因此这个列表是一个一维列表。
- en: '[Listing 10-5](ch10.html#ch10ex5) displays this list in Minecraft as wool blocks.
    The program file, *rainbowStack1.py*, is available in the book’s resources. Download
    the code files from *[https://www.nostarch.com/pythonwithminecraft/](https://www.nostarch.com/pythonwithminecraft/)*
    or type it yourself and play along!'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-5](ch10.html#ch10ex5)在 Minecraft 中显示了这个列表，作为羊毛方块。程序文件 *rainbowStack1.py*
    可在书本的资源中找到。你可以从 *[https://www.nostarch.com/pythonwithminecraft/](https://www.nostarch.com/pythonwithminecraft/)*
    下载代码文件，或者自己输入并一起玩！'
- en: '*rainbowStack1.py*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*rainbowStack1.py*'
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 10-5: Building a rainbow stack of blocks*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-5：构建一个彩虹堆叠的方块*'
- en: The program creates a list of block colors ➊ and then uses a `for` loop to create
    a stack of wool blocks with colors based on the colors in the list ➋.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先创建一个方块颜色的列表➊，然后使用`for`循环基于列表中的颜色来创建一个颜色堆叠的羊毛方块➋。
- en: When you run the program, you’ll get a single stack of wool blocks, as you can
    see in [Figure 10-7](ch10.html#ch10fig7). Notice that the stack is six blocks
    high and one block wide. You’ve used the `x`, `y`, and `z` variables throughout
    this book. Each of these variables can also be referred to as a *dimension*. This
    program creates a stack of six blocks on the y-dimension. By changing the `x`
    variable on the last line of the code instead of the `y` variable, you can build
    a stack of blocks on the x-dimension, which you can see in [Figure 10-8](ch10.html#ch10fig8).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你会得到一个单一的羊毛方块堆叠，如[图10-7](ch10.html#ch10fig7)所示。注意，这个堆叠有六个方块高和一个方块宽。你在本书中一直使用的`x`、`y`和`z`变量，每一个都可以被称为*维度*。这个程序在
    y 维度上创建了一个六个方块高的堆叠。通过在代码的最后一行更改`x`变量，而不是`y`变量，你可以在 x 维度上创建一个方块堆叠，正如你在[图10-8](ch10.html#ch10fig8)中看到的那样。
- en: '![image](graphics/f10-07.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-07.jpg)'
- en: '*Figure 10-7: The rainbow stack of blocks created by* rainbowStack1.py'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-7：由* rainbowStack1.py *创建的彩虹方块堆叠*'
- en: '![image](graphics/f10-08.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-08.jpg)'
- en: '*Figure 10-8: Swapping the* `y` *variable for the* `x` *variable on the last
    line of the program builds the blocks in a horizontal row.*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-8：在程序的最后一行将* `y` *变量替换为* `x` *变量，会在水平方向上构建方块。*'
- en: Because the list is one-dimensional, you can change the value of only one variable
    on a single dimension at a time. In other words, you can change the value of the
    `y` variable, `x` variable, or `z` variable but can’t change all of them at once.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表是一维的，你一次只能更改一个维度上的一个变量。换句话说，你可以更改`y`变量、`x`变量或`z`变量，但不能一次性更改所有这些变量。
- en: So, it’s time to start thinking about two dimensions! One-dimensional lists
    allow you to have a single list with only one value in each position, but two-dimensional
    lists allow you to have many values in each position of a list. You do this by
    putting a list at each position of the original list, as follows.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始考虑二维了！一维列表允许你在每个位置只存储一个值，而二维列表允许你在每个位置存储多个值。你可以通过在原始列表的每个位置放置一个列表来实现，如下所示。
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Look closely and you’ll see an opening square bracket on the first line followed
    by a list full of zeroes and then a comma ➊. That is a list inside a list! We
    can call the main list the *outer list* and say that it contains *nested lists*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，你会看到第一行有一个开括号，后面跟着一个充满零的列表，然后是一个逗号 ➊。那是一个列表里面嵌套了另一个列表！我们可以称外部的列表为*外层列表*，并说它包含*嵌套列表*。
- en: In index position 1 is a list that contains three 1s ➋. In index position 2
    is another list, this one containing three 2s ➌. This repeats on every line. On
    the last line is a list of three 5s, followed by a square bracket, which closes
    the outer list ➍. This code shows a list with six items in it, each of which is
    also a list. This is a two-dimensional list!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引位置1是一个包含三个1的列表 ➋。在索引位置2是另一个列表，这个列表包含三个2 ➌。这个模式在每一行中都会重复。最后一行是一个包含三个5的列表，后面跟着一个方括号，关闭了外层列表
    ➍。这段代码展示了一个包含六个项的列表，每一项本身也是一个列表。这就是一个二维列表！
- en: 'You’ll better understand two-dimensional lists when you use them in Minecraft.
    Let’s look at an example. By modifying *rainbowStack1.py*, we can make it work
    with the two-dimensional list. This new program is named *rainbowRows.py*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Minecraft中使用二维列表时，你会更好地理解它们。我们来看一个例子。通过修改*rainbowStack1.py*，我们可以让它与二维列表一起工作。这个新程序被命名为*rainbowRows.py*：
- en: '*rainbowRows.py*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*rainbowRows.py*'
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Before I explain the code, look at [Figure 10-9](ch10.html#ch10fig9) to see
    the output of *rainbowRows.py*, which is a set of blocks six blocks high on the
    y-dimension and three blocks wide on the x-dimension.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我解释代码之前，请查看[图10-9](ch10.html#ch10fig9)，以查看*rainbowRows.py*的输出，这是一组在y维度上有六个方块高，在x维度上有三个方块宽的方块。
- en: '![image](graphics/f10-09.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-09.jpg)'
- en: '*Figure 10-9: Using a two-dimensional list to make a rainbow wall*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-9：使用二维列表制作彩虹墙*'
- en: Because we’re working with two dimensions, we need two `for` loops to output
    the values in the `twoDimensionalRainbowList` list. The first loop iterates through
    each item in the outer list ➋. The second loop ➌, called a *nested* loop because
    it is inside another loop, then goes through each item in each nested list.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在处理二维数据，所以需要两个`for`循环来输出`twoDimensionalRainbowList`列表中的值。第一个循环遍历外层列表中的每个项
    ➋。第二个循环 ➌，因为它在另一个循环内，所以被称为*嵌套循环*，然后遍历每个嵌套列表中的项。
- en: For example, the first time the outer loop runs, it gets the item stored in
    index position 0 of the `twoDimensionalRainbowList` list and stores it in a variable
    called `row` ➋. The value of `row` is `[0, 0, 0]` because it’s the first item
    in the list.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，外层循环第一次运行时，它会获取`twoDimensionalRainbowList`列表中索引位置为0的项，并将其存储在一个名为`row`的变量中
    ➋。`row`的值是`[0, 0, 0]`，因为这是列表中的第一个项。
- en: The second loop then works through each item in the `row` list and stores it
    in the `color` variable ➌. In this case, each item will be 0\. The program then
    sets the blocks using the `color` variable to determine the color of each wool
    block ➍. The nested loop finishes after it has placed all three blocks for that
    row, and then the outer loop runs again. Next, the outer loop moves to index position
    1 and stores the value in the `row` variable, which is now `[1, 1, 1]`. It then
    runs through the nested loop to set the blocks again and iterates again until
    it reaches the end of the `twoDimensionalRainbowList` list.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个循环遍历`row`列表中的每个项目，并将其存储在`color`变量中 ➌。在这个例子中，每个项目的值将是 0。程序然后使用`color`变量来设置每个羊毛块的颜色
    ➍。嵌套循环在放置完该行的所有三个块后结束，然后外部循环再次运行。接下来，外部循环移动到索引位置 1，并将该位置的值存储在`row`变量中，此时`row`的值是`[1,
    1, 1]`。然后再次执行嵌套循环来设置块，并继续迭代，直到到达`twoDimensionalRainbowList`列表的末尾。
- en: When you’re working in two dimensions, you can change two coordinate variables
    at the same time. In this example, we increment the `y` variable on the second-to-last
    line of the outer `for` loop ➏ so each row of blocks will be placed above the
    previous row. We also increment the `x` variable inside the nested `for` loop
    ➎ to make sure the blocks are placed in a row. Then we need to reset the `x` variable
    to its original value (which is stored in the `startingX` variable ➊) every time
    the outer `for` loop iterates ➐. Resetting the `x` variable causes the first block
    of each row to be placed directly on top of the first block in the previous row,
    and so on, so the rows line up correctly with one another.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理二维数据时，你可以同时改变两个坐标变量。在这个例子中，我们在外部`for`循环的倒数第二行 ➏ 增加`y`变量，使得每一行的块都会放置在上一行的上方。我们还在嵌套的`for`循环中增加`x`变量
    ➎，以确保块按行排列。然后，每次外部`for`循环迭代时，我们需要将`x`变量重置为它的原始值（该值存储在`startingX`变量 ➊ 中）。重置`x`变量使得每一行的第一个块直接放置在上一行第一个块的正上方，依此类推，因此行与行之间能够正确对齐。
- en: '**ACCESSING VALUES IN 2D LISTS**'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问二维列表中的值**'
- en: 'When getting or setting a value in a one-dimensional list, you use square brackets
    and the index position. For example, this code creates a list called `scores`
    that records a player’s scores, and then it changes the item in index position
    2 from 6 to 7:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取或设置一维列表中的值时，你只需要使用方括号和索引位置。例如，这段代码创建了一个名为`scores`的列表来记录玩家的得分，然后它将索引位置 2 处的项从
    6 改为 7：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using or changing values in a two-dimensional list isn’t much different. You
    still use square brackets and the index position, but because you’re accessing
    two lists at the same time, you use two sets of indexes and square brackets. Let’s
    have a look!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用或更改二维列表中的值并没有太大不同。你仍然使用方括号和索引位置，但因为你同时访问两个列表，所以需要使用两组索引和方括号。我们来看一下！
- en: 'Here’s the list you saw earlier:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你之前看到的列表：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we wanted to change the second item (index position 1) in the first list
    (index position 0) to the value of 7, we would use this code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将第一个列表（索引位置 0）中第二个项目（索引位置 1）的值改为 7，我们可以使用以下代码：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Because we’re using two lists and one list is nested inside the other, we need
    to use two sets of square brackets. The first one picks the index position 0 of
    the `twoDimensionalRainbowList` list, which is its first nested list. In the second
    bracket we put the index position we want to access in the nested list, 1\. We
    then set the value of this position to 7 using the equal sign.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用了两个列表，并且一个列表嵌套在另一个列表中，所以我们需要使用两组方括号。第一组方括号选择`twoDimensionalRainbowList`列表的索引位置
    0，这是它的第一个嵌套列表。在第二组方括号中，我们放入想要访问的嵌套列表中的索引位置 1。然后，我们使用等号将该位置的值设置为 7。
- en: I added this code to the *rainbowRows.py* program ([page 211](ch10.html#page_211))
    and reran it. [Figure 10-10](ch10.html#ch10fig10) shows the result. Notice that
    the second block on the first row has changed because we changed the value in
    the nested list to 7.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这段代码添加到*rainbowRows.py*程序中（[第 211 页](ch10.html#page_211)），并重新运行。 [图 10-10](ch10.html#ch10fig10)
    显示了结果。注意到第一行的第二个块已经改变，因为我们将嵌套列表中的值改为 7。
- en: 'If you wanted to get the value of an item in a two-dimensional list, you would
    also use two sets of square brackets. For example, if you wanted to print the
    value in the first position (index 0) of the last row (index 5), you would use
    this code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取二维列表中某个项目的值，也需要使用两组方括号。例如，如果你想打印最后一行（索引 5）中第一个位置（索引 0）的值，你可以使用以下代码：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code outputs the value 5.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码输出值 5。
- en: '![image](graphics/f10-10.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-10.jpg)'
- en: '*Figure 10-10: Changing one of the values in a nested list to get a different
    result*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-10：更改嵌套列表中的一个值以获得不同的结果*'
- en: '**MISSION #61: PIXEL ART**'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #61：像素艺术**'
- en: '*Pixels* are single-colored squares that make up images on your computer. By
    combining lots of pixels in a grid, your computer can display text, images, videos,
    and everything else shown on your monitor. All photos and drawings on your computer
    are displayed using pixels.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*像素*是构成你计算机上图像的单色方块。通过将许多像素组合成网格，你的计算机可以显示文本、图像、视频以及显示在屏幕上的其他所有内容。你计算机上的所有照片和绘画都是通过像素显示的。'
- en: Pixel art is quite popular in Minecraft. Using different colored blocks in the
    Minecraft game, players build pictures in Minecraft. Pictures of characters from
    2D video games are some of the most popular. You can create pixel art by hand,
    or of course, you can use a Python program to generate the pixel art.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 像素艺术在《Minecraft》中非常流行。玩家通过使用不同颜色的方块在《Minecraft》中构建图片。在二维视频游戏中的人物图片是最受欢迎的之一。你可以手工创建像素艺术，当然，也可以使用
    Python 程序生成像素艺术。
- en: In this program, you’ll use a 2D list and nested loops to create pixel art in
    Minecraft. [Listing 10-6](ch10.html#ch10ex6) contains the beginning of the program.
    Copy it into a new file called *pixelArt.py* and save it in the *forLoops* folder.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，你将使用二维列表和嵌套循环在《Minecraft》中创建像素艺术。[列表 10-6](ch10.html#ch10ex6)包含程序的开始部分。将其复制到一个名为
    *pixelArt.py* 的新文件中，并将其保存在 *forLoops* 文件夹中。
- en: '*pixelArt.py*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*pixelArt.py*'
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 10-6: A two-dimensional list that draws a smiley face*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-6：绘制笑脸的二维列表*'
- en: The program creates a two-dimensional list called `blocks` that contains block
    IDs ➊ and then uses two loops to set the blocks in the Minecraft world ➋. To make
    sure the first row of the list is at the top when it is placed in Minecraft and
    the bottom row of the list is placed at the bottom, the `reversed()` function
    is included with the first `for` loop ➋. If it wasn’t, the image would be upside
    down compared to the order of the `blocks` list.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序创建了一个名为 `blocks` 的二维列表，其中包含方块 ID ➊，然后使用两个循环将方块放置到《Minecraft》世界中 ➋。为了确保当列表被放置到《Minecraft》时，列表的第一行位于顶部，最后一行位于底部，第一
    `for` 循环中包含了 `reversed()` 函数 ➋。如果没有这个函数，图像的顺序将与 `blocks` 列表的顺序相反，显示成倒置的样子。
- en: At the moment, the blocks are all white wool blocks and don’t display a picture.
    To finish the program, you need to rewrite the two-dimensional blocks list so
    it draws a smiley face, as shown in [Figure 10-11](ch10.html#ch10fig11).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，所有的方块都是白色羊毛方块，并且没有显示图片。为了完成程序，你需要重写二维方块列表，使其绘制一个笑脸，如[图 10-11](ch10.html#ch10fig11)所示。
- en: '![image](graphics/f10-11.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-11.jpg)'
- en: '*Figure 10-11: A smiley face drawn with blocks*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-11：用方块绘制的笑脸*'
- en: 'Change the values inside the lists so the output matches [Figure 10-11](ch10.html#ch10fig11).
    You’ll need to change some of the values in the lists from wool blocks (block
    ID 35) to lapis lazuli blocks (block ID 22). For example, change the first line
    to this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 更改列表中的一些值，使输出与[图 10-11](ch10.html#ch10fig11)匹配。你需要将列表中的一些羊毛方块（方块 ID 35）更改为青金石方块（方块
    ID 22）。例如，将第一行更改为以下内容：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You’ll also need to add more rows to the `blocks` list so the height of the
    image matches the one in the picture.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要向 `blocks` 列表中添加更多的行，以便图像的高度与图片中的高度匹配。
- en: '**BONUS OBJECTIVE: DRAW IT YOURSELF**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外目标：自己绘制**'
- en: Try changing the values in the two-dimensional list in *pixelArt.py* to display
    a different picture. You can change the lengths of the lists as well. Sketch your
    designs on graph paper first. Then convert them into two-dimensional lists so
    you can create them in Minecraft!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改 *pixelArt.py* 中二维列表的值，以显示不同的图片。你还可以改变列表的长度。先在方格纸上画出设计图。然后将其转换为二维列表，以便你可以在《Minecraft》中创建它们！
- en: '**GENERATING 2D LISTS WITH LOOPS**'
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用循环生成二维列表**'
- en: Programs that use random numbers are fun because they behave differently every
    time you run them. In the past, I’ve created lots of programs that use random
    numbers in two-dimensional lists to create pictures. Each random number might
    display a color, or in the case of Minecraft, a different block.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用随机数的程序很有趣，因为每次运行时它们的行为都会不同。在过去，我创建了很多使用随机数的程序，它们利用二维列表来创建图片。每个随机数可能显示一个颜色，或者在《Minecraft》中，显示一个不同的方块。
- en: 'Here’s the beginning of a program that generates random numbers and stores
    them in a two-dimensional set of lists:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个生成随机数并将其存储在二维列表中的程序的开头：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The program starts with an empty list called `randomNumbers` ➊. Every time the
    outer `for` loop repeats, it adds a new empty list into the `randomNumbers` list
    ➋. In the inner loop, the program then generates a random number between 1 and
    5 and stores this in the inner list ➌. The inner loop repeats 10 times to generate
    10 items in each inner list.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从一个空的列表 `randomNumbers` 开始 ➊。每当外层的 `for` 循环重复时，它会将一个新的空列表添加到 `randomNumbers`
    列表中 ➋。在内层循环中，程序会生成一个介于1和5之间的随机数，并将其存储在内层列表中 ➌。内层循环重复10次，为每个内层列表生成10个项目。
- en: 'After we add line breaks for readability, the output of the program looks like
    this (notice the 10 items in the 10 inner lists):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，我们添加了换行符，程序的输出如下所示（请注意，10个内层列表中有10个项目）：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: By incorporating random numbers into your 2D Minecraft creations, you can create
    some very cool effects that would be difficult to make by hand!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将随机数融入到你的二维Minecraft创作中，你可以创建一些非常酷的效果，而这些效果是手动创建难以实现的！
- en: '**MISSION #62: A WEATHER-WORN WALL**'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #62：风化的墙壁**'
- en: When I build walls in Minecraft, I don’t use a single block type. By swapping
    some cobblestone blocks for mossy cobblestone blocks, I can turn a plain wall
    into a wall that looks damaged, weather-beaten, organic, and cool. As fun as it
    is to build a wall by hand, I can never get the blocks I’ve added randomly to
    look random enough. You’ve probably guessed that the solution to making broken
    walls look more random is to use a Python program.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在Minecraft中建造墙壁时，我不会使用单一的方块类型。通过将一些圆石方块换成苔石圆石方块，我可以把一堵普通的墙变成看起来受损、风化、有机且酷的墙壁。虽然手动建墙很有趣，但我永远无法让我随机添加的方块看起来足够随机。你可能已经猜到，让破损墙壁看起来更随机的解决方案就是使用Python程序。
- en: 'To generate a weather-worn wall with Python, you need to break down the program
    into two main steps:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Python生成风化墙壁，你需要将程序分解为两个主要步骤：
- en: Create a two-dimensional list and store block values in the list.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个二维列表，并将方块值存储在该列表中。
- en: Output the two-dimensional list into the Minecraft world.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将二维列表输出到Minecraft世界中。
- en: To get you started, [Listing 10-7](ch10.html#ch10ex7) includes the code to choose
    a random block value, set up the list, and get the player’s position. Copy the
    listing into a new file called *brokenWall.py* and save it in the *forLoops* folder.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你入门，[清单 10-7](ch10.html#ch10ex7) 包括了选择随机方块值、设置列表和获取玩家位置的代码。将清单复制到一个名为 *brokenWall.py*
    的新文件中，并保存在 *forLoops* 文件夹中。
- en: '*brokenWall.py*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*brokenWall.py*'
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 10-7: The start of the program to create a broken wall*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-7：创建破损墙壁的程序开始部分*'
- en: The `brokenBlock()` function returns a random block value that’s used to build
    the wall ➊. The `width` and `height` variables set the width and the height of
    the wall.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`brokenBlock()` 函数返回一个随机方块值，用于构建墙体 ➊。`width` 和 `height` 变量设置墙体的宽度和高度。'
- en: To finish the program, you need to generate a two-dimensional list of block
    values, then use those values to build the design in Minecraft.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成程序，你需要生成一个二维的方块值列表，然后使用这些值在Minecraft中构建设计。
- en: Start with the blank list `brokenWall`. Using a `for` loop nested inside another
    `for` loop, generate random block values with the `brokenBlock()` function. Store
    the block values in lists, and store those lists in the `brokenWall` list. Then
    use another set of nested loops to place the blocks in Minecraft.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 从空列表 `brokenWall` 开始。使用嵌套在另一个 `for` 循环中的 `for` 循环，利用 `brokenBlock()` 函数生成随机方块值。将方块值存储在列表中，并将这些列表存储在
    `brokenWall` 列表中。然后使用另一组嵌套循环将方块放置到Minecraft中。
- en: When your program is complete, move to where you want to build your weather-worn
    wall in your Minecraft world and run the code. You can use the program to decorate
    a castle or create spooky-looking ruins in the forest. Experiment with different
    locations to see what you like best! [Figure 10-12](ch10.html#ch10fig12) shows
    what a wall will look like when you run the program.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序完成后，前往Minecraft世界中你想要建造风化墙壁的地方，运行代码。你可以使用该程序装饰城堡，或在森林中创建看起来阴森的废墟。尝试不同的位置，看看你最喜欢哪一个！[图10-12](ch10.html#ch10fig12)
    显示了运行程序后墙壁的样子。
- en: '![image](graphics/f10-12.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-12.jpg)'
- en: '*Figure 10-12: A wall with randomly generated broken blocks. It looks like
    it might be haunted!*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-12：一个随机生成破损方块的墙壁。看起来像是被幽灵附身了！*'
- en: '**BONUS OBJECTIVE: CREATE A COLORFUL WALL**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**额外目标：创建一个五彩斑斓的墙壁**'
- en: In the *brokenWall.py* program, change the block values in the `brokenBlock()`
    function’s `brokenBlocks` list to create all kinds of walls. Try changing the
    block values to different colors of wool and see what happens!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在*brokenWall.py*程序中，修改`brokenBlock()`函数中`brokenBlocks`列表中的方块值，可以创建各种墙壁。试试把方块值改成不同颜色的羊毛，看看会发生什么！
- en: '**THINKING IN THREE DIMENSIONS**'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**三维思维**'
- en: Of course, Minecraft is a game that uses three dimensions. And you’ve used three
    dimensions throughout this book. Each of the `x`, `y`, and `z` variables you used
    in most programs represents a dimension.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Minecraft是一个使用三维空间的游戏。在本书中，你也使用了三维空间。你在大多数程序中使用的`x`、`y`和`z`变量代表了一个维度。
- en: You’ve seen how to put one group of lists inside another to get a two-dimensional
    list and create cool pixel art and weathered walls. Putting a third group of lists
    inside a two-dimensional list creates a three-dimensional list, which lets you
    take your building skills to a whole new dimension!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何将一个列表嵌套到另一个列表中，从而得到二维列表，并创建炫酷的像素艺术和风化墙壁。将第三组列表嵌套到二维列表中，就能创建三维列表，这可以让你将建筑技能提升到全新的维度！
- en: Three-dimensional lists are extremely useful in Minecraft because you can use
    them to duplicate 3D structures, such as buildings, sculptures, and lots of other
    things.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 三维列表在Minecraft中非常有用，因为你可以用它们来复制三维结构，比如建筑、雕塑以及许多其他东西。
- en: The three-dimensional list in [Listing 10-8](ch10.html#ch10ex8) has four lists
    nested inside it. The kicker is that inside each index of those nested lists is
    another list! Basically, each item in this list is a 2D list. I’ve added blank
    comments to make the list easier to read.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-8](ch10.html#ch10ex8)中的三维列表有四个嵌套在其中的列表。值得注意的是，在这些嵌套列表的每个索引中，都有一个列表！基本上，这个列表中的每个元素都是一个二维列表。我已添加空白注释，以便使列表更易于阅读。'
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 10-8: A three-dimensional list with nested lists*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-8：一个包含嵌套列表的三维列表*'
- en: Code like this can be used to make a cool cube structure! Next we’ll dig into
    a program that does just that.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码可以用来创建一个酷炫的立方体结构！接下来，我们将深入研究一个正好做到这一点的程序。
- en: '**OUTPUTTING 3D LISTS**'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**输出三维列表**'
- en: Lists that have three dimensions are perfect for storing data about three-dimensional
    objects, such as your awesome Minecraft buildings. Storing three-dimensional objects
    is important, and correctly outputting them to Minecraft is just as important.
    Because a three-dimensional list is a list within a list that is within a list,
    you can use a `for` loop inside another `for` loop that is also inside another
    `for` loop to access all the data. In other words, you can use three nested `for`
    loops.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 三维列表非常适合存储有关三维物体的数据，比如你在Minecraft中的那些炫酷建筑。存储三维物体很重要，而将它们正确输出到Minecraft中同样重要。因为三维列表是一个嵌套在列表中的列表，所以你可以使用一个`for`循环嵌套在另一个`for`循环中，再嵌套在第三个`for`循环中，以访问所有数据。换句话说，你可以使用三个嵌套的`for`循环。
- en: In [Listing 10-9](ch10.html#ch10ex9), I’ve copied the three-dimensional list
    from [Listing 10-8](ch10.html#ch10ex8) and created a program called *cube.py*.
    This program uses three nested `for` loops to output all the values of the three-dimensional
    list one at a time to build a cube structure in the Minecraft world.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 10-9](ch10.html#ch10ex9)中，我复制了[清单 10-8](ch10.html#ch10ex8)中的三维列表，并创建了一个名为*cube.py*的程序。这个程序使用了三个嵌套的`for`循环，逐个输出三维列表中的所有值，以在Minecraft世界中构建一个立方体结构。
- en: '*cube.py*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*cube.py*'
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 10-9: Code to create a three-dimensional cube made of diamonds*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-9：用来创建由钻石构成的三维立方体的代码*'
- en: '[Figure 10-13](ch10.html#ch10fig13) shows the result of this program.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-13](ch10.html#ch10fig13)展示了这个程序的结果。'
- en: '![image](graphics/f10-13.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-13.jpg)'
- en: '*Figure 10-13: The cube created by the* cube.py *program*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-13：*cube.py*程序创建的立方体*'
- en: The code in *cube.py* is very similar to the two-dimensional *rainbowRows. py*
    program ([page 211](ch10.html#page_211)) that builds a rainbow wall. The main
    difference is that *cube.py* uses three `for` loops instead of two, because it
    works with a three-dimensional list. The extra `for` loop adds an extra dimension
    to the structure, depth ➋. So now the structure has width, height, and depth.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*cube.py*中的代码与用于构建彩虹墙的二维*rainbowRows.py*程序非常相似（见[第211页](ch10.html#page_211)）。主要区别在于，*cube.py*使用了三个`for`循环，而不是两个，因为它处理的是三维列表。额外的`for`循环为结构增加了一个额外的维度，即深度➋。所以，现在结构有了宽度、高度和深度。'
- en: Each time the outer loop `for depth in cube` runs, it creates a two-dimensional
    list using the two nested loops, `for height in reversed(depth)` and `for block
    in height`. The code in the two nested loops is similar to the code in the *rainbowRows.py*
    program, which means these loops build a wall in Minecraft.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 每次外层循环`for depth in cube`运行时，它会通过两个嵌套循环`for height in reversed(depth)`和`for
    block in height`创建一个二维列表。这两个嵌套循环中的代码与*rainbowRows.py*程序中的代码类似，这意味着这些循环在Minecraft中建造了一堵墙。
- en: 'Let’s look at the result of the outer loop each time it repeats so we can see
    it build the cube step-by-step. The first time the outer loop runs, it outputs
    the blocks in index position 0 of the `cube` list. That list looks like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每次外层循环重复时的结果，这样我们就能一步步看到立方体的构建过程。第一次外层循环运行时，它会输出`cube`列表中索引位置0的方块。该列表如下所示：
- en: '[PRE43]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[Figure 10-14](ch10.html#ch10fig14) shows the output: our first wall of blocks.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-14](ch10.html#ch10fig14)展示了输出结果：我们的第一堵块墙。'
- en: '![image](graphics/f10-14.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-14.jpg)'
- en: '*Figure 10-14: The result of the first two-dimensional loop,* `cube` *index
    0*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-14：第一个二维循环的结果，* `cube` *索引 0*'
- en: After each two-dimensional list is built in the game, the value of the `z` variable
    in *cube.py* ➌ is increased to move one block farther along the z-axis. This gives
    the cube depth, so we’re not just building a wall. We also need to reset the value
    of the `y` variable at ➍ to its original value ➊ so the blocks on the bottom of
    the cube line up with each other every time the outer loop repeats. If the `y`
    variable wasn’t reset, the y-coordinate of each set of blocks would keep getting
    higher and higher, creating some weird-looking stairs! [Figure 10-15](ch10.html#ch10fig15)
    shows what this would look like.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 每次游戏中构建完一个二维列表后，*cube.py* ➌中的`z`变量会增加，沿z轴移动一个方块。这赋予了立方体深度，这样我们就不仅仅是在建造一堵墙。此外，我们还需要将`y`变量的值在➍时重置为其原始值
    ➊，这样每次外层循环重复时，立方体底部的方块就能对齐。如果`y`变量没有被重置，每组方块的y坐标将不断增高，最终会形成一些奇怪的阶梯！[图 10-15](ch10.html#ch10fig15)展示了这种情况。
- en: '![image](graphics/f10-15.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-15.jpg)'
- en: '*Figure 10-15: We reset the* `y` *variable so this won’t happen!*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-15：我们重置了* `y` *变量，所以这种情况不会发生！*'
- en: 'The second time the outer loop runs, it outputs the blocks in index position
    1 of the `cube` list, which looks like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次外层循环运行时，它会输出`cube`列表中索引位置1的块，结果如下：
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This adds the next part of the cube, as you can see in [Figure 10-16](ch10.html#ch10fig16).
    After this part of the cube is built, the `z` variable increases by 1 ➌ and the
    `y` variable is reset to its original value again ➍.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这添加了立方体的下一部分，如[图 10-16](ch10.html#ch10fig16)所示。在这部分立方体构建完成后，`z`变量增加了1 ➌，`y`变量再次被重置为原始值
    ➍。
- en: '![image](graphics/f10-16.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-16.jpg)'
- en: '*Figure 10-16: The result of the second two-dimensional loop,* `cube` *index
    1*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-16：第二个二维循环的结果，* `cube` *索引 1*'
- en: 'The next time the loop repeats, it outputs the two-dimensional list in index
    position 2 of `cube`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次循环重复时，它会输出`cube`列表中索引位置2的二维列表：
- en: '[PRE45]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[Figure 10-17](ch10.html#ch10fig17) shows the result. Again, the `z` value
    is increased by 1 and the `y` value is reset.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-17](ch10.html#ch10fig17)展示了结果。同样，`z`值增加了1，`y`值被重置。'
- en: 'Then the loop repeats a fourth and final time, outputting index position 3
    of `cube`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后循环再次运行第四次并最后一次，输出`cube`的索引位置3：
- en: '[PRE46]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[Figure 10-18](ch10.html#ch10fig18) shows the finished cube structure.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-18](ch10.html#ch10fig18)展示了完成的立方体结构。'
- en: '![image](graphics/f10-17.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-17.jpg)'
- en: '*Figure 10-17: The result of the third two-dimensional loop,* `cube` *index
    2*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-17：第三个二维循环的结果，* `cube` *索引 2*'
- en: '![image](graphics/f10-18.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-18.jpg)'
- en: '*Figure 10-18: The result of the last two-dimensional loop, in the final* `cube`
    *index position*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-18：最后一个二维循环的结果，位于最终的* `cube` *索引位置*'
- en: Experiment with this program—use a different block type, try making a larger
    cube, or anything else you can imagine! In the next section, I’ll show you how
    to access values in three-dimensional lists so you can make some of these changes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下这个程序——使用不同的方块类型，尝试构建更大的立方体，或者尝试任何你能想象到的变化！在下一节中，我将向你展示如何访问三维列表中的值，这样你就可以做出这些改变。
- en: '**ACCESSING VALUES IN 3D LISTS**'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**访问三维列表中的值**'
- en: The values inside three-dimensional lists can be changed just as in one-dimensional
    and two-dimensional lists, using square brackets and index positions.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 三维列表中的值可以像一维和二维列表一样，通过使用方括号和索引位置进行修改。
- en: 'Let’s start with our three-dimensional diamond cube list:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从三维钻石立方体列表开始：
- en: '[PRE47]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: I want to change the bottom-left block on the front of my cube to gold.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我想把我立方体前面的底部左侧方块改为金色。
- en: 'First I need to access the index of the cube list that contains the front of
    the cube, which is 0\. So the first part of the expression will look like this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我需要访问包含立方体前面的立方体列表的索引，那个索引是 0。所以表达式的第一部分将像这样：
- en: '[PRE48]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If I printed the value of this expression, I would get the following output
    (which I’ve formatted to make it easier to read):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我打印这个表达式的值，我将得到如下输出（我已将其格式化以便更易阅读）：
- en: '[PRE49]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This two-dimensional list represents the front of the cube. Next, I want to
    access the bottom row, which is index 3\. So I add `[3]` to my expression:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个二维列表表示立方体的前面。接下来，我想访问最底部的行，也就是索引 3。于是我在表达式中加上 `[3]`：
- en: '[PRE50]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If I printed the list stored at this position, I would get the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我打印存储在这个位置的列表，我将得到如下结果：
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, I want to access the leftmost block in the row, which is index 3\.
    So the final expression to change the bottom-left block to a gold block looks
    like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想访问这一行中最左边的方块，它的索引是 3。所以最终的表达式将是这样，用来将底部左侧的方块改为金色方块：
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When I run the *cube.py* program with this line added, I get a cube made of
    diamonds with one single golden block, as in [Figure 10-19](ch10.html#ch10fig19).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行带有这个代码行的 *cube.py* 程序时，我得到一个由钻石制成的立方体，中间有一个单一的金色方块，如 [图 10-19](ch10.html#ch10fig19)
    所示。
- en: '![image](graphics/f10-19.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-19.jpg)'
- en: '*Figure 10-19: The modified cube with a single golden corner*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-19：修改后的立方体，角落处有一个金色方块*'
- en: '**MISSION #63: DUPLICATE A BUILDING**'
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #63: 复制一个建筑**'
- en: Even though building things in Minecraft using a Python program saves a lot
    of time, if you’re like me, you might still spend a considerable amount of effort
    adding details, like pictures and furniture, to your buildings. Sometimes you
    might need to make an identical copy of a particular object, and copying an object
    by hand can take lots of time. Placing each block one by one is a lot of work
    as well, and you might place a block in the wrong spot. The obvious solution is
    to make a program that copies a building in Minecraft and builds a copy of it
    in the game for you!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用 Python 程序在 Minecraft 中建造物品能节省大量时间，但如果你像我一样，可能仍然会花费相当多的精力在建筑中添加细节，比如图片和家具。有时你可能需要制作一个特定物品的完全复制品，而手动复制一个物品可能需要花费很多时间。一个一个地放置方块也很繁琐，而且你可能会把方块放错位置。显然的解决方案是制作一个程序，它能在
    Minecraft 中复制一个建筑，并在游戏中为你建造出一个副本！
- en: 'The finished program will need to do two things: first it will copy an area
    of the game and store it in a three-dimensional list, and then it will build the
    copied structure using that three-dimensional list.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的程序需要做两件事：首先，它会复制游戏中的一个区域，并将其存储在一个三维列表中；然后，它将使用这个三维列表来建造复制的结构。
- en: I’ve included the start of the program in [Listing 10-10](ch10.html#ch10ex10)
    to help you. Copy the listing into a new file and save it as *duplicateArea.py*
    in the *forLoops* folder.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将程序的开头部分包括在 [清单 10-10](ch10.html#ch10ex10) 中，以帮助你。将清单复制到一个新文件中，并将其保存为 *duplicateArea.py*
    在 *forLoops* 文件夹中。
- en: '*duplicateArea.py*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*duplicateArea.py*'
- en: '[PRE53]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*Listing 10-10: When the program is finished, it will duplicate buildings.*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-10：当程序完成时，它将复制建筑。*'
- en: This program is divided into several parts. First, the `sortPair()` function
    ➊ sorts a pair of values into a tuple with the lowest value in the first index
    position and the highest value in the second index position. For example, if I
    gave `sortPair()` the arguments 9 and 3, it would return a tuple with the value
    of `(3, 9)` because 3 is less than 9\. I use this function to sort pairs of `x`,
    `y`, and `z` values so the `width`, `length`, and `depth` variables are always
    positive when calculated.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序分为几个部分。首先，`sortPair()` 函数 ➊ 将一对值排序，较小的值放在第一个索引位置，较大的值放在第二个索引位置。例如，如果我给 `sortPair()`
    传入 9 和 3，它会返回一个元组 `(3, 9)`，因为 3 小于 9。我使用这个函数来对 `x`、`y` 和 `z` 的值进行排序，这样在计算时，`width`、`length`
    和 `depth` 变量始终为正值。
- en: Next, the `copyStructure()` function ➋ copies the structure from the game world,
    but it’s incomplete ➌. The `buildStructure()` function ➍ builds the structure,
    but it is also incomplete ➎. You’ll complete both in this mission.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`copyStructure()` 函数 ➋ 从游戏世界中复制结构，但它尚未完成 ➌。`buildStructure()` 函数 ➍ 用来构建结构，但它也未完成
    ➎。你将在本任务中完成这两个函数。
- en: 'I’ve added a neat trick to get the coordinates of the building you want to
    copy and the location in the game where you want to build the copy: Using the
    `input()` function, the program first asks you to move your character to one corner
    of the building and press ENTER ➏. The `input()` function makes the code wait
    until you’ve moved the player to where you want them to be. As soon as you press
    ENTER, it gets the player’s position using the `getTilePos()` function. We do
    the same again at the opposite corner of the building ➐. Then the `copyStructure()`
    function uses these two sets of coordinates to copy the building ➑. (When copying
    larger structures, this part of the program can take a while to run.) Finally,
    you move to where you want the building to be built and press ENTER ➒ to pass
    the player’s last position to the `buildStructure()` function.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个巧妙的技巧，来获取你想要复制的建筑的坐标和你希望复制建筑物的位置：使用`input()`函数，程序首先要求你将角色移动到建筑物的一个角落并按ENTER键
    ➏。`input()`函数会使程序等待，直到你将玩家移动到你希望他们停留的位置。一旦按下ENTER键，它会使用`getTilePos()`函数获取玩家的位置。我们在建筑物的对角线另一端再次执行相同的操作
    ➐。然后，`copyStructure()`函数使用这两组坐标来复制建筑物 ➑。（当复制较大的结构时，这部分程序可能需要一些时间才能运行。）最后，你移动到你希望建筑物建造的地方并按ENTER键
    ➒，将玩家的最后位置传递给`buildStructure()`函数。
- en: To finish the program, it’s your job to complete the `copyStructure()` and `buildStructure()`
    functions. Add three nested loops to the `copyStructure()` function to copy all
    the blocks between the coordinates given in the argument into a three-dimensional
    list at ➌. To finish the `buildStructure()` function, add three nested `for` loops
    that output the block values from the three-dimensional list at ➎. The function
    should use the given coordinates in its arguments.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成程序，你需要完成`copyStructure()`和`buildStructure()`函数。在`copyStructure()`函数中添加三个嵌套循环，以将参数中给出的坐标之间的所有方块复制到一个三维列表中
    ➌。为了完成`buildStructure()`函数，添加三个嵌套的`for`循环，从三维列表中输出方块值 ➎。该函数应该使用给定坐标作为参数。
- en: Make sure the program works through `x`, `y`, and `z` positions inside the structure.
    Use the `for` loops to change the `x`, `y`, and `z` positions.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 确保程序能够处理结构内部的`x`、`y`和`z`坐标。使用`for`循环更改`x`、`y`和`z`的位置。
- en: Although *duplicateArea.py* is a long program, it’s very useful and worth the
    effort. After you finish this mission, you’ll be able to build entire cities in
    your Minecraft world! I used *duplicateArea.py* to duplicate an interesting cliff
    I found when I was exploring. [Figure 10-20](ch10.html#ch10fig20) shows the cliff
    that I wanted to copy.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*duplicateArea.py*是一个较长的程序，但它非常有用，值得付出努力。完成这个任务后，你将能够在Minecraft世界中建造整个城市！我使用*duplicateArea.py*复制了一个我在探索时发现的有趣悬崖。[图10-20](ch10.html#ch10fig20)展示了我想要复制的悬崖。
- en: '![image](graphics/f10-20.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-20.jpg)'
- en: '*Figure 10-20: I liked the look of this cliff, so I made a copy of it.*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-20：我喜欢这个悬崖的外观，所以我做了一个复制。*'
- en: When you’re using the *duplicateArea.py* program to make copies, first stand
    outside (if your structure is a building) and near the bottom corner of the object
    you want to copy. Then press ENTER in IDLE. [Figure 10-21](ch10.html#ch10fig21)
    shows me standing on the first corner.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*duplicateArea.py*程序进行复制时，首先站在物体的外面（如果你的结构是建筑物的话），靠近你想要复制的物体的底部角落。然后在IDLE中按ENTER键。[图10-21](ch10.html#ch10fig21)展示了我站在第一个角落的样子。
- en: '![image](graphics/f10-21.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-21.jpg)'
- en: '*Figure 10-21: First I moved to one corner of the structure and pressed ENTER
    in IDLE.*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-21：首先我移动到结构的一个角落并在IDLE中按下ENTER键。*'
- en: Next, fly up and around to the opposite corner of the object you want to copy
    and press ENTER a second time. [Figure 10-22](ch10.html#ch10fig22) shows that
    I’ve flown into the air and moved around the cliff.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，飞到你想要复制的物体的对角线另一端，并按第二次ENTER键。[图10-22](ch10.html#ch10fig22)展示了我已经飞到空中，并围绕悬崖周围移动。
- en: '![image](graphics/f10-22.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-22.jpg)'
- en: '*Figure 10-22: Then I moved to the opposite corner of the structure and pressed
    ENTER*.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-22：然后我移动到结构的对角线另一端并按下ENTER键。*'
- en: You’ll get a message asking you to wait a moment while the structure is being
    copied by the program. Move to the location where you want to build the copy and
    wait for a message asking you where you want to build the new structure ([Figure
    10-23](ch10.html#ch10fig23)).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会发送一条消息，提示你稍等片刻，因为结构正在被复制。移动到你想要构建复制品的位置，然后等待一条消息，询问你希望在何处建造新的结构（[图10-23](ch10.html#ch10fig23)）。
- en: '![image](graphics/f10-23.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-23.jpg)'
- en: '*Figure 10-23: I waited a while for the structure to copy. Then I moved to
    where I wanted to build the copy and pressed ENTER to build it.*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-23：我等了一会儿让结构复制完成。然后我移动到想要构建复制品的位置，按下 ENTER 键来构建它。*'
- en: Press ENTER when you’re in the right place for the new building, and a copy
    of it will be built right in front of you! [Figure 10-24](ch10.html#ch10fig24)
    shows my copy of the cliff.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当你到达合适的位置时，按下 ENTER 键，复制品就会直接在你面前建成！[图 10-24](ch10.html#ch10fig24)展示了我复制的悬崖。
- en: '![image](graphics/f10-24.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f10-24.jpg)'
- en: '*Figure 10-24: The copy of the original cliff!*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-24：原始悬崖的复制品！*'
- en: '**WHAT YOU LEARNED**'
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: This chapter covered a lot of ground. You learned how to use `for` loops with
    lists, and you learned how to use the `range()` function. You also learned more
    about `for` loops and lists, such as reversing lists, looping over dictionaries,
    and breaking `for` loops. You created two- and three-dimensional lists with nested
    loops, which are super useful for building an awesome Minecraft world.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容涵盖了很多内容。你学会了如何使用`for`循环与列表，并且了解了如何使用`range()`函数。你还学习了更多关于`for`循环和列表的内容，例如反转列表、循环遍历字典以及如何中断`for`循环。你通过嵌套循环创建了二维和三维列表，这对构建一个精彩的
    Minecraft 世界非常有用。
- en: From generating stairs and pyramids to duplicating structures and creating art,
    you now have much more control over Minecraft than ever before. The programs in
    this chapter are some of my favorite programs in the book, and they’ll help you
    create your own advanced projects!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 从生成楼梯和金字塔到复制结构和创建艺术品，你现在对 Minecraft 的控制能力比以往任何时候都更强了。本章中的程序是我在书中最喜欢的一些程序，它们将帮助你创建自己的高级项目！
- en: This chapter and [Chapter 9](ch09.html#ch09) focused strongly on lists and `for`
    loops, which are closely related. In [Chapter 11](ch11.html#ch11), you’ll move
    on to files and modules, which are closely related to functions and which you’ve
    been using throughout this book. As part of the missions, you’ll learn how to
    save and load structures to and from files.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和[第 9 章](ch09.html#ch09)重点讲解了列表和`for`循环，它们是密切相关的。在[第 11 章](ch11.html#ch11)中，你将进入文件和模块的内容，这些内容与函数密切相关，而你在整本书中都在使用函数。作为任务的一部分，你将学会如何从文件中保存和加载结构。
